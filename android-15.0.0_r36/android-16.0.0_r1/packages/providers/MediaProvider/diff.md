```diff
diff --git a/Android.bp b/Android.bp
index 9cb665dbe..4dd572385 100644
--- a/Android.bp
+++ b/Android.bp
@@ -33,6 +33,8 @@ android_app {
         "exoplayer-mediaprovider-ui",
         "modules-utils-shell-command-handler",
         "SettingsLibProfileSelector",
+        "SettingsLibTopIntroPreference",
+        "SettingsLibCollapsingToolbarBaseActivity",
         "SettingsLibSelectorWithWidgetPreference",
         "mediaprovider_flags_java_lib",
         "androidx.media3.media3-common",
@@ -59,6 +61,7 @@ android_app {
 
     resource_dirs: [
         "res",
+        "photopicker/res",
     ],
     srcs: [
         ":mediaprovider-sources",
@@ -124,14 +127,12 @@ filegroup {
 java_library {
     name: "mediaprovider-database",
     srcs: [
-        "src/com/android/providers/media/util/DatabaseUtils.java",
-        "src/com/android/providers/media/util/FileUtils.java",
-        "src/com/android/providers/media/util/ForegroundThread.java",
-        "src/com/android/providers/media/util/Logging.java",
-        "src/com/android/providers/media/util/MimeUtils.java",
-        "src/com/android/providers/media/util/StringUtils.java",
-        "src/com/android/providers/media/playlist/*.java",
-        "src/com/android/providers/media/dao/*.java",
+        "legacy/src/com/android/providers/media/util/LegacyDatabaseUtils.java",
+        "legacy/src/com/android/providers/media/util/LegacyFileUtils.java",
+        "legacy/src/com/android/providers/media/util/LegacyForegroundThread.java",
+        "legacy/src/com/android/providers/media/util/LegacyLogging.java",
+        "legacy/src/com/android/providers/media/util/LegacyMimeUtils.java",
+        "legacy/src/com/android/providers/media/util/LegacyStringUtils.java",
     ],
     sdk_version: "module_current",
     min_sdk_version: "30",
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index a18581111..a19e718b5 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -54,6 +54,10 @@
     <uses-permission
         android:name="com.android.providers.media.permission.ACCESS_OEM_METADATA" />
 
+    <!-- Permission required to update OEM metadata. Declared by us -->
+    <uses-permission
+        android:name="com.android.providers.media.permission.UPDATE_OEM_METADATA" />
+
     <!-- Permission required to bind to OemMetadataService -->
     <uses-permission android:name="com.android.providers.media.permission.BIND_OEM_METADATA_SERVICE" />
 
@@ -74,6 +78,9 @@
     <permission android:name="com.android.providers.media.permission.ACCESS_OEM_METADATA"
                 android:protectionLevel="signature|privileged" />
 
+    <permission android:name="com.android.providers.media.permission.UPDATE_OEM_METADATA"
+                android:protectionLevel="signature|privileged" />
+
     <permission android:name="com.android.providers.media.permission.BIND_OEM_METADATA_SERVICE"
                 android:protectionLevel="signature"/>
 
@@ -84,11 +91,17 @@
             android:name="com.android.providers.media.MediaApplication"
             android:label="@string/picker_app_label"
             android:icon="@mipmap/picker_app_icon"
-            android:allowBackup="false"
             android:supportsRtl="true"
             android:forceQueryable="true"
             android:usesCleartextTraffic="true"
-            android:crossProfile="true">
+            android:crossProfile="true"
+            android:allowBackup="true"
+            android:fullBackupOnly="true"
+            android:backupInForeground="true"
+            android:killAfterRestore="false"
+            android:restoreAnyVersion="true"
+            android:backupAgent="com.android.providers.media.backupandrestore.MediaBackupAgent"
+            android:dataExtractionRules="@xml/data_extraction_rules">
         <provider
                 android:name="com.android.providers.media.MediaProvider"
                 android:authorities="media"
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 1f37f6d72..9a38fb418 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -179,11 +179,6 @@
                 }
             ]
         },
-        {
-            // This is a typo and is tracked in b/155715039 but flaky on CF.
-            // Will fix this once the root cause of flake is fixed.
-            "name": "AdoptableHostTest"
-        },
         {
             "name": "CtsScopedStorageCoreHostTest",
             "options": [
diff --git a/apex/Android.bp b/apex/Android.bp
index e0105a136..83f2966c1 100644
--- a/apex/Android.bp
+++ b/apex/Android.bp
@@ -111,6 +111,7 @@ bootclasspath_fragment {
         split_packages: [
             "android.graphics.pdf",
             "android.graphics.pdf.flags",
+            "android.graphics.pdf.flags.readonly",
             "android.provider",
             "android.provider.mediacognitionutils",
             "android.provider.media.internal.flags",
diff --git a/apex/framework/api/system-current.txt b/apex/framework/api/system-current.txt
index 1d11267f4..f002605a1 100644
--- a/apex/framework/api/system-current.txt
+++ b/apex/framework/api/system-current.txt
@@ -64,6 +64,7 @@ package android.provider {
   }
 
   public final class MediaStore {
+    method @FlaggedApi("com.android.providers.media.flags.enable_oem_metadata_update") public static void bulkUpdateOemMetadataInNextScan(@NonNull android.content.Context);
     method @NonNull public static android.net.Uri rewriteToLegacy(@NonNull android.net.Uri);
     method @NonNull @WorkerThread public static android.net.Uri scanFile(@NonNull android.content.ContentResolver, @NonNull java.io.File);
     method @WorkerThread public static void scanVolume(@NonNull android.content.ContentResolver, @NonNull String);
@@ -72,6 +73,7 @@ package android.provider {
     field public static final String AUTHORITY_LEGACY = "media_legacy";
     field @NonNull public static final android.net.Uri AUTHORITY_LEGACY_URI;
     field public static final String QUERY_ARG_DEFER_SCAN = "android:query-arg-defer-scan";
+    field @FlaggedApi("com.android.providers.media.flags.enable_oem_metadata_update") public static final String UPDATE_OEM_METADATA_PERMISSION = "com.android.providers.media.permission.UPDATE_OEM_METADATA";
   }
 
   @FlaggedApi("com.android.providers.media.flags.enable_oem_metadata") public abstract class OemMetadataService extends android.app.Service {
diff --git a/apex/framework/java/android/provider/CloudMediaProviderContract.java b/apex/framework/java/android/provider/CloudMediaProviderContract.java
index 3bf0fed96..e477af289 100644
--- a/apex/framework/java/android/provider/CloudMediaProviderContract.java
+++ b/apex/framework/java/android/provider/CloudMediaProviderContract.java
@@ -150,6 +150,16 @@ public final class CloudMediaProviderContract {
             return mAlbumsAsCategory;
         }
 
+        /**
+         * @hide
+         */
+        @Override
+        public String toString() {
+            return " isSearchEnabled=" + this.mSearchEnabled
+                    + " isMediaCategoriesEnabled=" + this.mMediaCategoriesEnabled
+                    + " isAlbumsAsCategoryEnabled=" + this.mAlbumsAsCategory;
+        }
+
         /**
          * Implemented for {@link Parcelable}
          */
@@ -465,6 +475,24 @@ public final class CloudMediaProviderContract {
          */
         public static final String DATA = "data";
 
+        /**
+         * Owner package of the media item
+         * <p>
+         * Type: STRING
+         *
+         * @hide
+         */
+        public static final String OWNER_PACKAGE_NAME = "owner_package_name";
+
+        /**
+         * package user id of the media item
+         * <p>
+         * Type: STRING
+         *
+         * @hide
+         */
+        public static final String USER_ID = "_user_id";
+
         /**
          * Array of all {@link MediaColumn} fields.
          *
@@ -485,6 +513,8 @@ public final class CloudMediaProviderContract {
             ORIENTATION,
             DATA,
             AUTHORITY,
+            OWNER_PACKAGE_NAME,
+            USER_ID,
         };
     }
 
@@ -1470,6 +1500,36 @@ public final class CloudMediaProviderContract {
     public static final String SEARCH_SUGGESTION_HISTORY =
             "com.android.providers.media.SEARCH_SUGGESTION_HISTORY";
 
+    /**
+     * Favorite's album suggestion
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     *
+     * @hide
+     */
+    public static final String SEARCH_SUGGESTION_FAVORITES_ALBUM =
+            "com.android.providers.media.SEARCH_SUGGESTION_FAVORITES_ALBUM";
+
+    /**
+     * Screenshot's album suggestion
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     *
+     * @hide
+     */
+    public static final String SEARCH_SUGGESTION_SCREENSHOTS_ALBUM =
+            "com.android.providers.media.SEARCH_SUGGESTION_SCREENSHOTS_ALBUM";
+
+    /**
+     * Videos's album suggestion
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     *
+     * @hide
+     */
+    public static final String SEARCH_SUGGESTION_VIDEOS_ALBUM =
+            "com.android.providers.media.SEARCH_SUGGESTION_VIDEOS_ALBUM";
+
     /**
      * Defines the different types of search suggestions available and supported in photo picker.
      *
diff --git a/apex/framework/java/android/provider/MediaStore.java b/apex/framework/java/android/provider/MediaStore.java
index 1b8d50152..b8ff19503 100644
--- a/apex/framework/java/android/provider/MediaStore.java
+++ b/apex/framework/java/android/provider/MediaStore.java
@@ -32,6 +32,7 @@ import android.annotation.WorkerThread;
 import android.app.Activity;
 import android.app.AppOpsManager;
 import android.app.PendingIntent;
+import android.app.compat.CompatChanges;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ClipData;
 import android.content.ContentProvider;
@@ -303,6 +304,9 @@ public final class MediaStore {
     public static final String REVOKED_ALL_READ_GRANTS_FOR_PACKAGE_CALL =
             "revoke_all_media_grants_for_package";
 
+    /** @hide */
+    public static final String BULK_UPDATE_OEM_METADATA_CALL = "bulk_update_oem_metadata";
+
     /** @hide */
     public static final String OPEN_FILE_CALL =
             "open_file_call";
@@ -340,6 +344,12 @@ public final class MediaStore {
     public static final String PICKER_MEDIA_SETS_INIT_CALL =
             "picker_media_sets_init_call";
     /** {@hide} */
+    public static final String PICKER_MEDIA_IN_MEDIA_SET_INIT_CALL =
+            "picker_media_in_media_set_init";
+    /** {@hide} */
+    public static final String PICKER_GET_SEARCH_PROVIDERS_CALL =
+            "picker_internal_get_search_providers";
+    /** {@hide} */
     public static final String PICKER_TRANSCODE_CALL = "picker_transcode";
     /** {@hide} */
     public static final String PICKER_TRANSCODE_RESULT = "picker_transcode_result";
@@ -656,6 +666,11 @@ public final class MediaStore {
     @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
     public static final String INTENT_ACTION_VIDEO_CAMERA = "android.media.action.VIDEO_CAMERA";
 
+    /**
+     * This is a copy of the flag that exists in MediaProvider.
+     */
+    private static final long EXCLUDE_UNRELIABLE_STORAGE_VOLUMES = 391360514L;
+
     /**
      * Standard Intent action that can be sent to have the camera application
      * capture an image and return it.
@@ -1336,6 +1351,16 @@ public final class MediaStore {
     public static final String ACCESS_OEM_METADATA_PERMISSION =
             "com.android.providers.media.permission.ACCESS_OEM_METADATA";
 
+    /**
+     * Permission that grants ability to trigger update of {@link MediaColumns#OEM_METADATA}.
+     *
+     * @hide
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_OEM_METADATA_UPDATE)
+    @SystemApi
+    public static final String UPDATE_OEM_METADATA_PERMISSION =
+            "com.android.providers.media.permission.UPDATE_OEM_METADATA";
+
     /** @hide */
     @IntDef(flag = true, prefix = { "MATCH_" }, value = {
             MATCH_DEFAULT,
@@ -1553,6 +1578,11 @@ public final class MediaStore {
      * once obtained you can directly {@link ContentResolver#update} columns
      * like {@link MediaColumns#IS_FAVORITE}, {@link MediaColumns#IS_TRASHED},
      * or {@link ContentResolver#delete}.
+     * <p>
+     * Note: if your app targets {@link android.os.Build.VERSION_CODES#BAKLAVA}
+     * and above, you can send a maximum of 2000 uris in each request.
+     * Attempting to send more than 2000 uris will result in a
+     * {@link java.lang.IllegalArgumentException}.
      *
      * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.
      *            Typically this value is {@link Context#getContentResolver()},
@@ -1585,6 +1615,11 @@ public final class MediaStore {
      * determine if you already hold write access before requesting access, use
      * {@link Context#checkUriPermission(Uri, int, int, int)} with
      * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * <p>
+     * Note: if your app targets {@link android.os.Build.VERSION_CODES#BAKLAVA}
+     * and above, you can send a maximum of 2000 uris in each request.
+     * Attempting to send more than 2000 uris will result in a
+     * {@link java.lang.IllegalArgumentException}.
      *
      * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.
      *            Typically this value is {@link Context#getContentResolver()},
@@ -1626,6 +1661,11 @@ public final class MediaStore {
      * determine if you already hold write access before requesting access, use
      * {@link Context#checkUriPermission(Uri, int, int, int)} with
      * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * <p>
+     * Note: if your app targets {@link android.os.Build.VERSION_CODES#BAKLAVA}
+     * and above, you can send a maximum of 2000 uris in each request.
+     * Attempting to send more than 2000 uris will result in a
+     * {@link java.lang.IllegalArgumentException}.
      *
      * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.
      *            Typically this value is {@link Context#getContentResolver()},
@@ -1706,6 +1746,11 @@ public final class MediaStore {
      * determine if you already hold write access before requesting access, use
      * {@link Context#checkUriPermission(Uri, int, int, int)} with
      * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * <p>
+     * Note: if your app targets {@link android.os.Build.VERSION_CODES#BAKLAVA}
+     * and above, you can send a maximum of 2000 uris in each request.
+     * Attempting to send more than 2000 uris will result in a
+     * {@link java.lang.IllegalArgumentException}.
      *
      * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.
      *            Typically this value is {@link Context#getContentResolver()},
@@ -4708,7 +4753,15 @@ public final class MediaStore {
                 case Environment.MEDIA_MOUNTED_READ_ONLY: {
                     final String volumeName = sv.getMediaStoreVolumeName();
                     if (volumeName != null) {
-                        res.add(volumeName);
+                        File directory = sv.getDirectory();
+                        if (shouldExcludeUnReliableStorageVolumes()
+                                && directory != null
+                                && directory.getAbsolutePath() != null
+                                && directory.getAbsolutePath().startsWith("/mnt/")) {
+                            Log.d(TAG, "skipping unreliable volume : " + volumeName);
+                        } else {
+                            res.add(volumeName);
+                        }
                     }
                     break;
                 }
@@ -4717,6 +4770,14 @@ public final class MediaStore {
         return res;
     }
 
+    /**
+     * Checks if the EXCLUDE_UNRELIABLE_STORAGE_VOLUMES appcompat flag is enabled.
+     */
+    private static boolean shouldExcludeUnReliableStorageVolumes() {
+        return CompatChanges.isChangeEnabled(EXCLUDE_UNRELIABLE_STORAGE_VOLUMES)
+                && Flags.excludeUnreliableVolumes();
+    }
+
     /**
      * Works exactly the same as
      * {@link ContentResolver#openFileDescriptor(Uri, String, CancellationSignal)}, but only works
@@ -5708,4 +5769,26 @@ public final class MediaStore {
             throw e.rethrowAsRuntimeException();
         }
     }
+
+    /**
+     * Allows bulk update of {@link MediaColumns#OEM_METADATA} column in next scan.
+     * Requires calling package to hold {@link UPDATE_OEM_METADATA_PERMISSION} permission. Updates
+     * {@link MediaColumns#OEM_METADATA} to NULL for OEM supported media files and re-fetch
+     * the latest values in the next scan.
+     * Caller can enforce file/volume scan after this to update MediaStore with the latest OEM
+     * metadata. If not done, next scan by MediaStore will fetch and update the latest data.
+     *
+     * @hide
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_OEM_METADATA_UPDATE)
+    @SystemApi
+    public static void bulkUpdateOemMetadataInNextScan(@NonNull Context context) {
+        final ContentResolver resolver = context.getContentResolver();
+        try (ContentProviderClient client = resolver.acquireContentProviderClient(AUTHORITY)) {
+            final Bundle extras = new Bundle();
+            client.call(BULK_UPDATE_OEM_METADATA_CALL, /* arg= */ null, /* extras= */ extras);
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+    }
 }
diff --git a/apex/framework/java/android/provider/OemMetadataServiceWrapper.java b/apex/framework/java/android/provider/OemMetadataServiceWrapper.java
index 278f1b94a..634632589 100644
--- a/apex/framework/java/android/provider/OemMetadataServiceWrapper.java
+++ b/apex/framework/java/android/provider/OemMetadataServiceWrapper.java
@@ -37,6 +37,7 @@ import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -53,6 +54,8 @@ public final class OemMetadataServiceWrapper {
 
     private final IOemMetadataService mOemMetadataService;
 
+    private final ExecutorService mExecutorService;
+
     private final long mServiceTimeoutInSeconds;
 
     public OemMetadataServiceWrapper(@NonNull IOemMetadataService oemMetadataService) {
@@ -65,6 +68,7 @@ public final class OemMetadataServiceWrapper {
 
         this.mOemMetadataService = oemMetadataService;
         this.mServiceTimeoutInSeconds = serviceTimeoutInSeconds;
+        mExecutorService = Executors.newFixedThreadPool(3);
     }
 
     /**
@@ -76,7 +80,7 @@ public final class OemMetadataServiceWrapper {
             return new HashSet<>();
         }
 
-        return Executors.newSingleThreadExecutor().submit(() -> {
+        return mExecutorService.submit(() -> {
             CompletableFuture<Set<String>> future = new CompletableFuture<>();
             RemoteCallback callback = new RemoteCallback(
                     result -> setResultForGetSupportedMimeTypes(result, future));
@@ -94,7 +98,7 @@ public final class OemMetadataServiceWrapper {
             return new HashMap<>();
         }
 
-        return Executors.newSingleThreadExecutor().submit(() -> {
+        return mExecutorService.submit(() -> {
             CompletableFuture<Map<String, String>> future = new CompletableFuture<>();
             RemoteCallback callback = new RemoteCallback(
                     result -> setResultForGetOemCustomData(result, future));
diff --git a/jni/FuseDaemon.cpp b/jni/FuseDaemon.cpp
index fb0468c5b..d22758bba 100644
--- a/jni/FuseDaemon.cpp
+++ b/jni/FuseDaemon.cpp
@@ -285,6 +285,9 @@ struct fuse {
     }
 
     inline string GetTransformsDir() { return GetEffectiveRootPath() + "/.transforms"; }
+    inline string GetPickerTranscodedDir() {
+        return GetEffectiveRootPath() + "/.picker_transcoded";
+    }
 
     // Note that these two (FromInode / ToInode) conversion wrappers are required
     // because fuse_lowlevel_ops documents that the root inode is always one
@@ -539,6 +542,14 @@ static inline bool is_transforms_dir_path(const string& path, struct fuse* fuse)
     return android::base::StartsWithIgnoreCase(path, fuse->GetTransformsDir());
 }
 
+static inline bool is_picker_transcoded_dir_path(const string& path, struct fuse* fuse) {
+    return android::base::StartsWithIgnoreCase(path, fuse->GetPickerTranscodedDir());
+}
+
+static inline bool is_hidden_dir_path(const string& path, struct fuse* fuse) {
+    return is_transforms_dir_path(path, fuse) || is_picker_transcoded_dir_path(path, fuse);
+}
+
 static std::unique_ptr<mediaprovider::fuse::FileLookupResult> validate_node_path(
         const std::string& path, const std::string& name, fuse_req_t req, int* error_code,
         struct fuse_entry_param* e, const FuseOp op) {
@@ -552,7 +563,7 @@ static std::unique_ptr<mediaprovider::fuse::FileLookupResult> validate_node_path
         return nullptr;
     }
 
-    if (is_transforms_dir_path(path, fuse)) {
+    if (is_hidden_dir_path(path, fuse)) {
         if (op == FuseOp::lookup) {
             // Lookups are only allowed under .transforms/synthetic dir
             if (!(android::base::EqualsIgnoreCase(path, fuse->GetTransformsDir()) ||
@@ -564,6 +575,8 @@ static std::unique_ptr<mediaprovider::fuse::FileLookupResult> validate_node_path
         } else {
             // user-code is only allowed to make lookups under .transforms dir, and that too only
             // under .transforms/synthetic dir
+            // Additionally No operations are allowed on .picker_transcoded directory
+            // as it should be only used by MediaProvider
             *error_code = ENOENT;
             return nullptr;
         }
@@ -713,6 +726,28 @@ namespace fuse {
  *
  */
 
+bool IsUpstreamPassthroughSupported() {
+    // Upstream passthrough requires some modifications to work. If those are present,
+    // /sys/fs/fuse/fuse_passthrough will read 'supported\n'
+    // - see fs/fuse/inode.c in the kernel source
+
+    string contents;
+    const char* filename = "/sys/fs/fuse/features/fuse_passthrough";
+    if (!android::base::ReadFileToString(filename, &contents)) {
+        LOG(INFO) << "fuse-passthrough is disabled because " << filename << " cannot be read";
+        return false;
+    }
+
+    if (contents == "supported\n") {
+        LOG(INFO) << "fuse-passthrough is enabled because " << filename << " reads 'supported'";
+        return true;
+    } else {
+        LOG(INFO) << "fuse-passthrough is disabled because " << filename
+                  << " does not read 'supported'";
+        return false;
+    }
+}
+
 static void pf_init(void* userdata, struct fuse_conn_info* conn) {
     struct fuse* fuse = reinterpret_cast<struct fuse*>(userdata);
 
@@ -752,7 +787,8 @@ static void pf_init(void* userdata, struct fuse_conn_info* conn) {
             //   b. Files requiring redaction are still faster than no-passthrough devices that use
             //      direct_io
             disable_splice_write = true;
-        } else if (conn->capable & FUSE_CAP_PASSTHROUGH_UPSTREAM) {
+        } else if ((conn->capable & FUSE_CAP_PASSTHROUGH_UPSTREAM) &&
+                   IsUpstreamPassthroughSupported()) {
             mask |= FUSE_CAP_PASSTHROUGH_UPSTREAM;
             disable_splice_write = true;
             fuse->upstream_passthrough = true;
@@ -1310,9 +1346,9 @@ static void pf_rmdir(fuse_req_t req, fuse_ino_t parent, const char* name) {
         return;
     }
 
-    if (is_transforms_dir_path(parent_path, fuse)) {
-        // .transforms is a special daemon controlled dir so apps shouldn't be able to see it via
-        // readdir, and any dir operations attempted on it should fail
+    if (is_hidden_dir_path(parent_path, fuse)) {
+        // .transforms and .picker_transcoded are special daemon controlled dirs so apps shouldn't
+        // be able to see it via readdir, and any dir operations attempted on it should fail
         fuse_reply_err(req, ENOENT);
         return;
     }
@@ -1366,9 +1402,9 @@ static int do_rename(fuse_req_t req, fuse_ino_t parent, const char* name, fuse_i
         return ENOENT;
     }
 
-    if (is_transforms_dir_path(old_parent_path, fuse)) {
-        // .transforms is a special daemon controlled dir so apps shouldn't be able to see it via
-        // readdir, and any dir operations attempted on it should fail
+    if (is_hidden_dir_path(old_parent_path, fuse)) {
+        // .transforms and .picker_transcoded are special daemon controlled dirs so apps shouldn't
+        // be able to see it via readdir, and any dir operations attempted on it should fail
         return ENOENT;
     }
 
@@ -1451,7 +1487,7 @@ static handle* create_handle_for_node(struct fuse* fuse, const string& path, int
     }
 
     if (fuse->passthrough && allow_passthrough) {
-        *keep_cache = transforms_complete && !fuse->upstream_passthrough;
+        *keep_cache = transforms_complete;
         // We only enabled passthrough iff these 2 conditions hold
         // 1. Redaction is not needed
         // 2. Node transforms are completed, e.g transcoding.
@@ -2615,6 +2651,7 @@ std::unique_ptr<FdAccessResult> FuseDaemon::CheckFdAccess(int fd, uid_t uid) con
         return std::make_unique<FdAccessResult>(string(), false);
     }
 
+    std::lock_guard<std::recursive_mutex> guard(fuse->lock);
     const node* node = node::LookupInode(fuse->root, ino);
     if (!node) {
         PLOG(DEBUG) << "CheckFdAccess no node found with given ino";
diff --git a/jni/RedactionInfo.cpp b/jni/RedactionInfo.cpp
index 384e59fed..faf9c4204 100644
--- a/jni/RedactionInfo.cpp
+++ b/jni/RedactionInfo.cpp
@@ -18,6 +18,8 @@
 
 #include <android-base/logging.h>
 
+#include <algorithm>
+
 using std::unique_ptr;
 using std::vector;
 
diff --git a/legacy/src/com/android/providers/media/LegacyDatabaseHelper.java b/legacy/src/com/android/providers/media/LegacyDatabaseHelper.java
index e13a39466..7bad81805 100644
--- a/legacy/src/com/android/providers/media/LegacyDatabaseHelper.java
+++ b/legacy/src/com/android/providers/media/LegacyDatabaseHelper.java
@@ -44,10 +44,10 @@ import androidx.annotation.NonNull;
 import androidx.annotation.VisibleForTesting;
 
 import com.android.modules.utils.BackgroundThread;
-import com.android.providers.media.util.FileUtils;
-import com.android.providers.media.util.ForegroundThread;
-import com.android.providers.media.util.Logging;
-import com.android.providers.media.util.MimeUtils;
+import com.android.providers.media.util.LegacyFileUtils;
+import com.android.providers.media.util.LegacyForegroundThread;
+import com.android.providers.media.util.LegacyLogging;
+import com.android.providers.media.util.LegacyMimeUtils;
 
 import java.io.File;
 import java.io.FilenameFilter;
@@ -287,7 +287,7 @@ public class LegacyDatabaseHelper extends SQLiteOpenHelper implements AutoClosea
             // completely finish dispatching all change notifications before we
             // process background tasks, to ensure that the background work
             // doesn't steal resources from the more important foreground work
-            ForegroundThread.getExecutor().execute(() -> {
+            LegacyForegroundThread.getExecutor().execute(() -> {
                 // Now that we've finished with all our important work, we can
                 // finally kick off any internal background tasks
                 for (int i = 0; i < state.backgroundTasks.size(); i++) {
@@ -562,11 +562,11 @@ public class LegacyDatabaseHelper extends SQLiteOpenHelper implements AutoClosea
 
         // Derive new column value based on well-known paths
         try (Cursor c = db.query("files", new String[]{FileColumns._ID, FileColumns.DATA},
-                FileColumns.DATA + " REGEXP '" + FileUtils.PATTERN_OWNED_PATH.pattern() + "'",
+                FileColumns.DATA + " REGEXP '" + LegacyFileUtils.PATTERN_OWNED_PATH.pattern() + "'",
                 null, null, null, null, null)) {
             Log.d(TAG, "Updating " + c.getCount() + " entries with well-known owners");
 
-            final Matcher m = FileUtils.PATTERN_OWNED_PATH.matcher("");
+            final Matcher m = LegacyFileUtils.PATTERN_OWNED_PATH.matcher("");
             final ContentValues values = new ContentValues();
 
             while (c.moveToNext()) {
@@ -621,7 +621,7 @@ public class LegacyDatabaseHelper extends SQLiteOpenHelper implements AutoClosea
 
     private static void updateSetIsDownload(SQLiteDatabase db) {
         db.execSQL("UPDATE files SET is_download=1 WHERE _data REGEXP '"
-                + FileUtils.PATTERN_DOWNLOADS_FILE + "'");
+                + LegacyFileUtils.PATTERN_DOWNLOADS_FILE + "'");
     }
 
     private static void updateAddExpiresAndTrashed(SQLiteDatabase db) {
@@ -734,7 +734,7 @@ public class LegacyDatabaseHelper extends SQLiteOpenHelper implements AutoClosea
             while (c.moveToNext()) {
                 final String time = c.getString(0);
                 final String message = c.getString(1);
-                Logging.logPersistent("Historical log " + time + " " + message);
+                LegacyLogging.logPersistent("Historical log " + time + " " + message);
             }
         }
         db.execSQL("DELETE FROM log;");
@@ -787,7 +787,7 @@ public class LegacyDatabaseHelper extends SQLiteOpenHelper implements AutoClosea
                 final long id = c.getLong(0);
                 final String data = c.getString(1);
                 values.put(FileColumns.DATA, data);
-                FileUtils.computeValuesFromData(values, /*isForFuse*/ false);
+                LegacyFileUtils.computeValuesFromData(values, /*isForFuse*/ false);
                 values.remove(FileColumns.DATA);
                 if (!values.isEmpty()) {
                     db.update("files", values, "_id=" + id, null);
@@ -811,9 +811,9 @@ public class LegacyDatabaseHelper extends SQLiteOpenHelper implements AutoClosea
                 final long id = c.getLong(0);
                 final String mimeType = c.getString(1);
                 // Only update Document and Subtitle media type
-                if (MimeUtils.isSubtitleMimeType(mimeType)) {
+                if (LegacyMimeUtils.isSubtitleMimeType(mimeType)) {
                     newMediaTypes.put(id, FileColumns.MEDIA_TYPE_SUBTITLE);
-                } else if (MimeUtils.isDocumentMimeType(mimeType)) {
+                } else if (LegacyMimeUtils.isDocumentMimeType(mimeType)) {
                     newMediaTypes.put(id, FileColumns.MEDIA_TYPE_DOCUMENT);
                 }
             }
diff --git a/legacy/src/com/android/providers/media/LegacyMediaProvider.java b/legacy/src/com/android/providers/media/LegacyMediaProvider.java
index 8b2224282..710602e80 100644
--- a/legacy/src/com/android/providers/media/LegacyMediaProvider.java
+++ b/legacy/src/com/android/providers/media/LegacyMediaProvider.java
@@ -37,7 +37,7 @@ import android.util.ArraySet;
 
 import androidx.annotation.NonNull;
 
-import com.android.providers.media.util.Logging;
+import com.android.providers.media.util.LegacyLogging;
 
 import java.io.File;
 import java.io.FileDescriptor;
@@ -77,7 +77,7 @@ public class LegacyMediaProvider extends ContentProvider {
         final Context context = getContext();
 
         final File persistentDir = context.getDir("logs", Context.MODE_PRIVATE);
-        Logging.initPersistent(persistentDir);
+        LegacyLogging.initPersistent(persistentDir);
 
         mInternalDatabase = new LegacyDatabaseHelper(context, INTERNAL_DATABASE_NAME, true);
         mExternalDatabase = new LegacyDatabaseHelper(context, EXTERNAL_DATABASE_NAME, true);
@@ -239,6 +239,6 @@ public class LegacyMediaProvider extends ContentProvider {
 
     @Override
     public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
-        Logging.dumpPersistent(writer);
+        LegacyLogging.dumpPersistent(writer);
     }
 }
diff --git a/legacy/src/com/android/providers/media/util/LegacyDatabaseUtils.java b/legacy/src/com/android/providers/media/util/LegacyDatabaseUtils.java
new file mode 100644
index 000000000..fd6144a29
--- /dev/null
+++ b/legacy/src/com/android/providers/media/util/LegacyDatabaseUtils.java
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import static android.content.ContentResolver.QUERY_ARG_GROUP_COLUMNS;
+import static android.content.ContentResolver.QUERY_ARG_LIMIT;
+import static android.content.ContentResolver.QUERY_ARG_OFFSET;
+import static android.content.ContentResolver.QUERY_ARG_SORT_COLLATION;
+import static android.content.ContentResolver.QUERY_ARG_SORT_COLUMNS;
+import static android.content.ContentResolver.QUERY_ARG_SORT_DIRECTION;
+import static android.content.ContentResolver.QUERY_ARG_SORT_LOCALE;
+import static android.content.ContentResolver.QUERY_ARG_SQL_GROUP_BY;
+import static android.content.ContentResolver.QUERY_ARG_SQL_LIMIT;
+import static android.content.ContentResolver.QUERY_ARG_SQL_SORT_ORDER;
+import static android.content.ContentResolver.QUERY_SORT_DIRECTION_ASCENDING;
+import static android.content.ContentResolver.QUERY_SORT_DIRECTION_DESCENDING;
+
+import static com.android.providers.media.util.LegacyLogging.TAG;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteStatement;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.Locale;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+public class LegacyDatabaseUtils {
+    /**
+     * Bind the given selection with the given selection arguments.
+     * <p>
+     * Internally assumes that '?' is only ever used for arguments, and doesn't
+     * appear as a literal or escaped value.
+     * <p>
+     * This method is typically useful for trusted code that needs to cook up a
+     * fully-bound selection.
+     *
+     * @hide
+     */
+    public static @Nullable String bindSelection(@Nullable String selection,
+            @Nullable Object... selectionArgs) {
+        if (selection == null) return null;
+        // If no arguments provided, so we can't bind anything
+        if ((selectionArgs == null) || (selectionArgs.length == 0)) return selection;
+        // If no bindings requested, so we can shortcut
+        if (selection.indexOf('?') == -1) return selection;
+
+        // Track the chars immediately before and after each bind request, to
+        // decide if it needs additional whitespace added
+        char before = ' ';
+        char after = ' ';
+
+        int argIndex = 0;
+        final int len = selection.length();
+        final StringBuilder res = new StringBuilder(len);
+        for (int i = 0; i < len; ) {
+            char c = selection.charAt(i++);
+            if (c == '?') {
+                // Assume this bind request is guarded until we find a specific
+                // trailing character below
+                after = ' ';
+
+                // Sniff forward to see if the selection is requesting a
+                // specific argument index
+                int start = i;
+                for (; i < len; i++) {
+                    c = selection.charAt(i);
+                    if (c < '0' || c > '9') {
+                        after = c;
+                        break;
+                    }
+                }
+                if (start != i) {
+                    argIndex = Integer.parseInt(selection.substring(start, i)) - 1;
+                }
+
+                // Manually bind the argument into the selection, adding
+                // whitespace when needed for clarity
+                final Object arg = selectionArgs[argIndex++];
+                if (before != ' ' && before != '=') res.append(' ');
+                switch (LegacyDatabaseUtils.getTypeOfObject(arg)) {
+                    case Cursor.FIELD_TYPE_NULL:
+                        res.append("NULL");
+                        break;
+                    case Cursor.FIELD_TYPE_INTEGER:
+                        res.append(((Number) arg).longValue());
+                        break;
+                    case Cursor.FIELD_TYPE_FLOAT:
+                        res.append(((Number) arg).doubleValue());
+                        break;
+                    case Cursor.FIELD_TYPE_BLOB:
+                        throw new IllegalArgumentException("Blobs not supported");
+                    case Cursor.FIELD_TYPE_STRING:
+                    default:
+                        if (arg instanceof Boolean) {
+                            // Provide compatibility with legacy applications which may pass
+                            // Boolean values in bind args.
+                            res.append(((Boolean) arg).booleanValue() ? 1 : 0);
+                        } else {
+                            res.append('\'');
+                            // Escape single quote character while appending the string and reject
+                            // invalid unicode.
+                            res.append(escapeSingleQuoteAndRejectInvalidUnicode(arg.toString()));
+                            res.append('\'');
+                        }
+                        break;
+                }
+                if (after != ' ') res.append(' ');
+            } else {
+                res.append(c);
+                before = c;
+            }
+        }
+        return res.toString();
+    }
+
+    private static String escapeSingleQuoteAndRejectInvalidUnicode(@NonNull String target) {
+        final int len = target.length();
+        final StringBuilder res = new StringBuilder(len);
+        boolean lastHigh = false;
+
+        for (int i = 0; i < len; ) {
+            final char c = target.charAt(i++);
+
+            if (lastHigh != Character.isLowSurrogate(c)) {
+                Log.e(TAG, "Invalid surrogate in string " + target);
+                throw new IllegalArgumentException("Invalid surrogate in string " + target);
+            }
+
+            lastHigh = Character.isHighSurrogate(c);
+
+            // Escape the single quotes by duplicating them
+            if (c == '\'') {
+                res.append(c);
+            }
+
+            res.append(c);
+        }
+
+        if (lastHigh) {
+            Log.e(TAG, "Invalid surrogate in string " + target);
+            throw new IllegalArgumentException("Invalid surrogate in string " + target);
+        }
+
+        return res.toString();
+    }
+
+    /**
+     * Returns data type of the given object's value.
+     *<p>
+     * Returned values are
+     * <ul>
+     *   <li>{@link Cursor#FIELD_TYPE_NULL}</li>
+     *   <li>{@link Cursor#FIELD_TYPE_INTEGER}</li>
+     *   <li>{@link Cursor#FIELD_TYPE_FLOAT}</li>
+     *   <li>{@link Cursor#FIELD_TYPE_STRING}</li>
+     *   <li>{@link Cursor#FIELD_TYPE_BLOB}</li>
+     *</ul>
+     *</p>
+     *
+     * @param obj the object whose value type is to be returned
+     * @return object value type
+     * @hide
+     */
+    public static int getTypeOfObject(Object obj) {
+        if (obj == null) {
+            return Cursor.FIELD_TYPE_NULL;
+        } else if (obj instanceof byte[]) {
+            return Cursor.FIELD_TYPE_BLOB;
+        } else if (obj instanceof Float || obj instanceof Double) {
+            return Cursor.FIELD_TYPE_FLOAT;
+        } else if (obj instanceof Long || obj instanceof Integer
+                || obj instanceof Short || obj instanceof Byte) {
+            return Cursor.FIELD_TYPE_INTEGER;
+        } else {
+            return Cursor.FIELD_TYPE_STRING;
+        }
+    }
+
+    /**
+     * Simple attempt to balance the given SQL expression by adding parenthesis
+     * when needed.
+     * <p>
+     * Since this is only used for recovering from abusive apps, we're not
+     * interested in trying to build a fully valid SQL parser up in Java. It'll
+     * give up when it encounters complex SQL, such as string literals.
+     */
+    public static @Nullable String maybeBalance(@Nullable String sql) {
+        if (sql == null) return null;
+
+        int count = 0;
+        char literal = '\0';
+        for (int i = 0; i < sql.length(); i++) {
+            final char c = sql.charAt(i);
+
+            if (c == '\'' || c == '"') {
+                if (literal == '\0') {
+                    // Start literal
+                    literal = c;
+                } else if (literal == c) {
+                    // End literal
+                    literal = '\0';
+                }
+            }
+
+            if (literal == '\0') {
+                if (c == '(') {
+                    count++;
+                } else if (c == ')') {
+                    count--;
+                }
+            }
+        }
+        while (count > 0) {
+            sql = sql + ")";
+            count--;
+        }
+        while (count < 0) {
+            sql = "(" + sql;
+            count++;
+        }
+        return sql;
+    }
+
+    private static void resolveGroupBy(@NonNull Bundle queryArgs,
+            @NonNull Consumer<String> honored) {
+        final String[] columns = queryArgs.getStringArray(QUERY_ARG_GROUP_COLUMNS);
+        if (columns != null && columns.length != 0) {
+            String groupBy = TextUtils.join(", ", columns);
+            honored.accept(QUERY_ARG_GROUP_COLUMNS);
+
+            queryArgs.putString(QUERY_ARG_SQL_GROUP_BY, groupBy);
+        } else {
+            honored.accept(QUERY_ARG_SQL_GROUP_BY);
+        }
+    }
+
+    private static void resolveSortOrder(@NonNull Bundle queryArgs,
+            @NonNull Consumer<String> honored,
+            @NonNull Function<String, String> collatorFactory) {
+        final String[] columns = queryArgs.getStringArray(QUERY_ARG_SORT_COLUMNS);
+        if (columns != null && columns.length != 0) {
+            String sortOrder = TextUtils.join(", ", columns);
+            honored.accept(QUERY_ARG_SORT_COLUMNS);
+
+            if (queryArgs.containsKey(QUERY_ARG_SORT_LOCALE)) {
+                final String collatorName = collatorFactory.apply(
+                        queryArgs.getString(QUERY_ARG_SORT_LOCALE));
+                sortOrder += " COLLATE " + collatorName;
+                honored.accept(QUERY_ARG_SORT_LOCALE);
+            } else {
+                // Interpret PRIMARY and SECONDARY collation strength as no-case collation based
+                // on their javadoc descriptions.
+                final int collation = queryArgs.getInt(
+                        QUERY_ARG_SORT_COLLATION, java.text.Collator.IDENTICAL);
+                switch (collation) {
+                    case java.text.Collator.IDENTICAL:
+                        honored.accept(QUERY_ARG_SORT_COLLATION);
+                        break;
+                    case java.text.Collator.PRIMARY:
+                    case java.text.Collator.SECONDARY:
+                        sortOrder += " COLLATE NOCASE";
+                        honored.accept(QUERY_ARG_SORT_COLLATION);
+                        break;
+                }
+            }
+
+            final int sortDir = queryArgs.getInt(QUERY_ARG_SORT_DIRECTION, Integer.MIN_VALUE);
+            switch (sortDir) {
+                case QUERY_SORT_DIRECTION_ASCENDING:
+                    sortOrder += " ASC";
+                    honored.accept(QUERY_ARG_SORT_DIRECTION);
+                    break;
+                case QUERY_SORT_DIRECTION_DESCENDING:
+                    sortOrder += " DESC";
+                    honored.accept(QUERY_ARG_SORT_DIRECTION);
+                    break;
+            }
+
+            queryArgs.putString(QUERY_ARG_SQL_SORT_ORDER, sortOrder);
+        } else {
+            honored.accept(QUERY_ARG_SQL_SORT_ORDER);
+        }
+    }
+
+    private static void resolveLimit(@NonNull Bundle queryArgs,
+            @NonNull Consumer<String> honored) {
+        final int limit = queryArgs.getInt(QUERY_ARG_LIMIT, Integer.MIN_VALUE);
+        if (limit != Integer.MIN_VALUE) {
+            String limitString = Integer.toString(limit);
+            honored.accept(QUERY_ARG_LIMIT);
+
+            final int offset = queryArgs.getInt(QUERY_ARG_OFFSET, Integer.MIN_VALUE);
+            if (offset != Integer.MIN_VALUE) {
+                limitString += " OFFSET " + offset;
+                honored.accept(QUERY_ARG_OFFSET);
+            }
+
+            queryArgs.putString(QUERY_ARG_SQL_LIMIT, limitString);
+        } else {
+            honored.accept(QUERY_ARG_SQL_LIMIT);
+        }
+    }
+
+    private static void bindArgs(@NonNull SQLiteStatement st, @Nullable Object[] bindArgs) {
+        if (bindArgs == null) return;
+
+        for (int i = 0; i < bindArgs.length; i++) {
+            final Object bindArg = bindArgs[i];
+            switch (getTypeOfObject(bindArg)) {
+                case Cursor.FIELD_TYPE_NULL:
+                    st.bindNull(i + 1);
+                    break;
+                case Cursor.FIELD_TYPE_INTEGER:
+                    st.bindLong(i + 1, ((Number) bindArg).longValue());
+                    break;
+                case Cursor.FIELD_TYPE_FLOAT:
+                    st.bindDouble(i + 1, ((Number) bindArg).doubleValue());
+                    break;
+                case Cursor.FIELD_TYPE_BLOB:
+                    st.bindBlob(i + 1, (byte[]) bindArg);
+                    break;
+                case Cursor.FIELD_TYPE_STRING:
+                default:
+                    if (bindArg instanceof Boolean) {
+                        // Provide compatibility with legacy
+                        // applications which may pass Boolean values in
+                        // bind args.
+                        st.bindLong(i + 1, ((Boolean) bindArg).booleanValue() ? 1 : 0);
+                    } else {
+                        st.bindString(i + 1, bindArg.toString());
+                    }
+                    break;
+            }
+        }
+    }
+
+    public static boolean parseBoolean(@Nullable Object value, boolean def) {
+        if (value instanceof Boolean) {
+            return (Boolean) value;
+        } else if (value instanceof Number) {
+            return ((Number) value).intValue() != 0;
+        } else if (value instanceof String) {
+            final String stringValue = ((String) value).toLowerCase(Locale.ROOT);
+            return (!"false".equals(stringValue) && !"0".equals(stringValue));
+        } else {
+            return def;
+        }
+    }
+
+    public static boolean getAsBoolean(@NonNull Bundle extras,
+            @NonNull String key, boolean def) {
+        return parseBoolean(extras.get(key), def);
+    }
+
+    public static boolean getAsBoolean(@NonNull ContentValues values,
+            @NonNull String key, boolean def) {
+        return parseBoolean(values.get(key), def);
+    }
+
+    public static long getAsLong(@NonNull ContentValues values,
+            @NonNull String key, long def) {
+        final Long value = values.getAsLong(key);
+        return (value != null) ? value : def;
+    }
+}
diff --git a/legacy/src/com/android/providers/media/util/LegacyFileUtils.java b/legacy/src/com/android/providers/media/util/LegacyFileUtils.java
new file mode 100644
index 000000000..3e2b9f0b4
--- /dev/null
+++ b/legacy/src/com/android/providers/media/util/LegacyFileUtils.java
@@ -0,0 +1,330 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import static com.android.providers.media.util.LegacyLogging.TAG;
+
+import android.content.ContentValues;
+import android.os.Environment;
+import android.os.SystemProperties;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AudioColumns;
+import android.provider.MediaStore.MediaColumns;
+import android.text.TextUtils;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+
+import com.android.modules.utils.build.SdkLevel;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.FileVisitResult;
+import java.nio.file.FileVisitor;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Locale;
+import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class LegacyFileUtils {
+
+    /**
+     * Recursively walk the contents of the given {@link Path}, invoking the
+     * given {@link Consumer} for every file and directory encountered. This is
+     * typically used for recursively deleting a directory tree.
+     * <p>
+     * Gracefully attempts to process as much as possible in the face of any
+     * failures.
+     */
+    public static void walkFileTreeContents(@NonNull Path path, @NonNull Consumer<Path> operation) {
+        try {
+            Files.walkFileTree(path, new FileVisitor<Path>() {
+                @Override
+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
+                    return FileVisitResult.CONTINUE;
+                }
+
+                @Override
+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
+                    if (!Objects.equals(path, file)) {
+                        operation.accept(file);
+                    }
+                    return FileVisitResult.CONTINUE;
+                }
+
+                @Override
+                public FileVisitResult visitFileFailed(Path file, IOException e) {
+                    Log.w(TAG, "Failed to visit " + file, e);
+                    return FileVisitResult.CONTINUE;
+                }
+
+                @Override
+                public FileVisitResult postVisitDirectory(Path dir, IOException e) {
+                    if (!Objects.equals(path, dir)) {
+                        operation.accept(dir);
+                    }
+                    return FileVisitResult.CONTINUE;
+                }
+            });
+        } catch (IOException e) {
+            Log.w(TAG, "Failed to walk " + path, e);
+        }
+    }
+
+    /**
+     * Recursively delete all contents inside the given directory. Gracefully
+     * attempts to delete as much as possible in the face of any failures.
+     *
+     * @deprecated if you're calling this from inside {@code MediaProvider}, you
+     * likely want to call {@link #forEach} with a separate
+     * invocation to invalidate FUSE entries.
+     */
+    @Deprecated
+    public static void deleteContents(@NonNull File dir) {
+        walkFileTreeContents(dir.toPath(), (path) -> {
+            path.toFile().delete();
+        });
+    }
+
+    public static @Nullable String extractDisplayName(@Nullable String data) {
+        if (data == null) return null;
+        if (data.indexOf('/') == -1) {
+            return data;
+        }
+        if (data.endsWith("/")) {
+            data = data.substring(0, data.length() - 1);
+        }
+        return data.substring(data.lastIndexOf('/') + 1);
+    }
+
+    public static @Nullable String extractFileExtension(@Nullable String data) {
+        if (data == null) return null;
+        data = extractDisplayName(data);
+
+        final int lastDot = data.lastIndexOf('.');
+        if (lastDot == -1) {
+            return null;
+        } else {
+            return data.substring(lastDot + 1);
+        }
+    }
+
+    public static final Pattern PATTERN_DOWNLOADS_FILE = Pattern.compile(
+            "(?i)^/storage/[^/]+/(?:[0-9]+/)?Download/.+");
+    public static final Pattern PATTERN_EXPIRES_FILE = Pattern.compile(
+            "(?i)^\\.(pending|trashed)-(\\d+)-([^/]+)$");
+
+    /**
+     * File prefix indicating that the file {@link MediaColumns#IS_PENDING}.
+     */
+    public static final String PREFIX_PENDING = "pending";
+
+    /**
+     * File prefix indicating that the file {@link MediaColumns#IS_TRASHED}.
+     */
+    public static final String PREFIX_TRASHED = "trashed";
+
+    private static final boolean PROP_CROSS_USER_ALLOWED =
+            SystemProperties.getBoolean("external_storage.cross_user.enabled", false);
+
+    private static final String PROP_CROSS_USER_ROOT = isCrossUserEnabled()
+            ? SystemProperties.get("external_storage.cross_user.root", "") : "";
+
+    private static final String PROP_CROSS_USER_ROOT_PATTERN = ((PROP_CROSS_USER_ROOT.isEmpty())
+            ? "" : "(?:" + PROP_CROSS_USER_ROOT + "/)?");
+
+    /**
+     * Regex that matches paths in all well-known package-specific directories,
+     * and which captures the package name as the first group.
+     */
+    public static final Pattern PATTERN_OWNED_PATH = Pattern.compile(
+            "(?i)^/storage/[^/]+/(?:[0-9]+/)?"
+                    + PROP_CROSS_USER_ROOT_PATTERN
+                    + "Android/(?:data|media|obb)/([^/]+)(/?.*)?");
+
+    /**
+     * The recordings directory. This is used for R OS. For S OS or later,
+     * we use {@link Environment#DIRECTORY_RECORDINGS} directly.
+     */
+    public static final String DIRECTORY_RECORDINGS = "Recordings";
+
+    /**
+     * Regex that matches paths for {@link MediaColumns#RELATIVE_PATH}
+     */
+    private static final Pattern PATTERN_RELATIVE_PATH = Pattern.compile(
+            "(?i)^/storage/(?:emulated/[0-9]+/|[^/]+/)");
+
+    /**
+     * Regex that matches paths under well-known storage paths.
+     */
+    private static final Pattern PATTERN_VOLUME_NAME = Pattern.compile(
+            "(?i)^/storage/([^/]+)");
+
+    public static boolean isCrossUserEnabled() {
+        return PROP_CROSS_USER_ALLOWED || SdkLevel.isAtLeastS();
+    }
+
+    private static @Nullable String normalizeUuid(@Nullable String fsUuid) {
+        return fsUuid != null ? fsUuid.toLowerCase(Locale.ROOT) : null;
+    }
+
+    public static @Nullable String extractVolumeName(@Nullable String data) {
+        if (data == null) return null;
+        final Matcher matcher = PATTERN_VOLUME_NAME.matcher(data);
+        if (matcher.find()) {
+            final String volumeName = matcher.group(1);
+            if (volumeName.equals("emulated")) {
+                return MediaStore.VOLUME_EXTERNAL_PRIMARY;
+            } else {
+                return normalizeUuid(volumeName);
+            }
+        } else {
+            return MediaStore.VOLUME_INTERNAL;
+        }
+    }
+
+    public static @Nullable String extractRelativePath(@Nullable String data) {
+        if (data == null) return null;
+
+        final String path;
+        try {
+            path = getCanonicalPath(data);
+        } catch (IOException e) {
+            Log.d(TAG, "Unable to get canonical path from invalid data path: " + data, e);
+            return null;
+        }
+
+        final Matcher matcher = PATTERN_RELATIVE_PATH.matcher(path);
+        if (matcher.find()) {
+            final int lastSlash = path.lastIndexOf('/');
+            if (lastSlash == -1 || lastSlash < matcher.end()) {
+                // This is a file in the top-level directory, so relative path is "/"
+                // which is different than null, which means unknown path
+                return "/";
+            } else {
+                return path.substring(matcher.end(), lastSlash + 1);
+            }
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Compute several scattered {@link MediaColumns} values from
+     * {@link MediaColumns#DATA}. This method performs no enforcement of
+     * argument validity.
+     */
+    public static void computeValuesFromData(@NonNull ContentValues values, boolean isForFuse) {
+        // Worst case we have to assume no bucket details
+        values.remove(MediaColumns.VOLUME_NAME);
+        values.remove(MediaColumns.RELATIVE_PATH);
+        values.remove(MediaColumns.IS_TRASHED);
+        values.remove(MediaColumns.DATE_EXPIRES);
+        values.remove(MediaColumns.DISPLAY_NAME);
+        values.remove(MediaColumns.BUCKET_ID);
+        values.remove(MediaColumns.BUCKET_DISPLAY_NAME);
+
+        String data = values.getAsString(MediaColumns.DATA);
+        if (TextUtils.isEmpty(data)) return;
+
+        try {
+            data = new File(data).getCanonicalPath();
+            values.put(MediaColumns.DATA, data);
+        } catch (IOException e) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ROOT, "Invalid file path:%s in request.", data));
+        }
+
+        final File file = new File(data);
+        final File fileLower = new File(data.toLowerCase(Locale.ROOT));
+
+        values.put(MediaColumns.VOLUME_NAME, extractVolumeName(data));
+        values.put(MediaColumns.RELATIVE_PATH, extractRelativePath(data));
+        final String displayName = extractDisplayName(data);
+        final Matcher matcher = LegacyFileUtils.PATTERN_EXPIRES_FILE.matcher(displayName);
+        if (matcher.matches()) {
+            values.put(MediaColumns.IS_PENDING,
+                    matcher.group(1).equals(LegacyFileUtils.PREFIX_PENDING) ? 1 : 0);
+            values.put(MediaColumns.IS_TRASHED,
+                    matcher.group(1).equals(LegacyFileUtils.PREFIX_TRASHED) ? 1 : 0);
+            values.put(MediaColumns.DATE_EXPIRES, Long.parseLong(matcher.group(2)));
+            values.put(MediaColumns.DISPLAY_NAME, matcher.group(3));
+        } else {
+            if (isForFuse) {
+                // Allow Fuse thread to set IS_PENDING when using DATA column.
+                // TODO(b/156867379) Unset IS_PENDING when Fuse thread doesn't explicitly specify
+                // IS_PENDING. It can't be done now because we scan after create. Scan doesn't
+                // explicitly specify the value of IS_PENDING.
+            } else {
+                values.put(MediaColumns.IS_PENDING, 0);
+            }
+            values.put(MediaColumns.IS_TRASHED, 0);
+            values.putNull(MediaColumns.DATE_EXPIRES);
+            values.put(MediaColumns.DISPLAY_NAME, displayName);
+        }
+
+        // Buckets are the parent directory
+        final String parent = fileLower.getParent();
+        if (parent != null) {
+            values.put(MediaColumns.BUCKET_ID, parent.hashCode());
+            // The relative path for files in the top directory is "/"
+            if (!"/".equals(values.getAsString(MediaColumns.RELATIVE_PATH))) {
+                values.put(MediaColumns.BUCKET_DISPLAY_NAME, file.getParentFile().getName());
+            } else {
+                values.putNull(MediaColumns.BUCKET_DISPLAY_NAME);
+            }
+        }
+    }
+
+    @VisibleForTesting
+    static ArrayMap<String, String> sAudioTypes = new ArrayMap<>();
+
+    static {
+        sAudioTypes.put(Environment.DIRECTORY_RINGTONES, AudioColumns.IS_RINGTONE);
+        sAudioTypes.put(Environment.DIRECTORY_NOTIFICATIONS, AudioColumns.IS_NOTIFICATION);
+        sAudioTypes.put(Environment.DIRECTORY_ALARMS, AudioColumns.IS_ALARM);
+        sAudioTypes.put(Environment.DIRECTORY_PODCASTS, AudioColumns.IS_PODCAST);
+        sAudioTypes.put(Environment.DIRECTORY_AUDIOBOOKS, AudioColumns.IS_AUDIOBOOK);
+        sAudioTypes.put(Environment.DIRECTORY_MUSIC, AudioColumns.IS_MUSIC);
+        if (SdkLevel.isAtLeastS()) {
+            sAudioTypes.put(Environment.DIRECTORY_RECORDINGS, AudioColumns.IS_RECORDING);
+        } else {
+            sAudioTypes.put(LegacyFileUtils.DIRECTORY_RECORDINGS, AudioColumns.IS_RECORDING);
+        }
+    }
+
+    /**
+     * Returns the canonical pathname string of the provided abstract pathname.
+     *
+     * @return The canonical pathname string denoting the same file or directory as this abstract
+     * pathname.
+     * @see File#getCanonicalPath()
+     */
+    @NonNull
+    public static String getCanonicalPath(@NonNull String path) throws IOException {
+        Objects.requireNonNull(path);
+        return new File(path).getCanonicalPath();
+    }
+
+}
diff --git a/legacy/src/com/android/providers/media/util/LegacyForegroundThread.java b/legacy/src/com/android/providers/media/util/LegacyForegroundThread.java
new file mode 100644
index 000000000..0dcef6fbb
--- /dev/null
+++ b/legacy/src/com/android/providers/media/util/LegacyForegroundThread.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+
+import com.android.modules.utils.HandlerExecutor;
+
+import java.util.concurrent.Executor;
+
+/**
+ * Thread for asynchronous event processing. This thread is configured as
+ * {@link android.os.Process#THREAD_PRIORITY_FOREGROUND}, which means more CPU
+ * resources will be dedicated to it, and it will be treated like "a user
+ * interface that the user is interacting with."
+ * <p>
+ * This thread is best suited for tasks that the user is actively waiting for,
+ * or for tasks that the user expects to be executed immediately.
+ *
+ * @see BackgroundThread
+ */
+public final class LegacyForegroundThread extends HandlerThread {
+    private static LegacyForegroundThread sInstance;
+    private static Handler sHandler;
+    private static HandlerExecutor sHandlerExecutor;
+
+    private LegacyForegroundThread() {
+        super("fg", android.os.Process.THREAD_PRIORITY_FOREGROUND);
+    }
+
+    private static void ensureThreadLocked() {
+        if (sInstance == null) {
+            sInstance = new LegacyForegroundThread();
+            sInstance.start();
+            sHandler = new Handler(sInstance.getLooper());
+            sHandlerExecutor = new HandlerExecutor(sHandler);
+        }
+    }
+
+    public static Executor getExecutor() {
+        synchronized (LegacyForegroundThread.class) {
+            ensureThreadLocked();
+            return sHandlerExecutor;
+        }
+    }
+
+}
diff --git a/legacy/src/com/android/providers/media/util/LegacyLogging.java b/legacy/src/com/android/providers/media/util/LegacyLogging.java
new file mode 100644
index 000000000..a85b3b807
--- /dev/null
+++ b/legacy/src/com/android/providers/media/util/LegacyLogging.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import static java.nio.file.StandardOpenOption.APPEND;
+import static java.nio.file.StandardOpenOption.CREATE;
+
+import android.util.Log;
+
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.stream.Stream;
+
+public class LegacyLogging {
+    public static final String TAG = "LegacyMediaProvider";
+
+    /** Size limit of each persistent log file, in bytes */
+    private static final int PERSISTENT_SIZE = 32 * 1024;
+    private static final SimpleDateFormat DATE_FORMAT =
+            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.ROOT);
+    private static final Object LOCK = new Object();
+
+    @GuardedBy("LOCK")
+    private static Path sPersistentDir;
+    @GuardedBy("LOCK")
+    private static Path sPersistentFile;
+    @GuardedBy("LOCK")
+    private static Writer sWriter;
+
+    /**
+     * Initialize persistent logging which is then available through
+     * {@link #logPersistent(String)} and {@link #dumpPersistent(PrintWriter)}.
+     */
+    public static void initPersistent(@NonNull File persistentDir) {
+        synchronized (LOCK) {
+            sPersistentDir = persistentDir.toPath();
+            closeWriterAndUpdatePathLocked(null);
+        }
+    }
+
+    /**
+     * Write the given message to persistent logs.
+     */
+    public static void logPersistent(@NonNull String format, @Nullable Object ... args) {
+        final String msg = (args == null || args.length == 0)
+                ? format : String.format(Locale.ROOT, format, args);
+
+        Log.i(TAG, msg);
+
+        synchronized (LOCK) {
+            if (sPersistentDir == null) return;
+
+            try {
+                Path path = resolveCurrentPersistentFileLocked();
+                if (!path.equals(sPersistentFile)) {
+                    closeWriterAndUpdatePathLocked(path);
+                }
+
+                if (sWriter == null) {
+                    sWriter = Files.newBufferedWriter(path, CREATE, APPEND);
+                }
+
+                sWriter.write(DATE_FORMAT.format(new Date()) + " " + msg + "\n");
+                // Flush to guarantee that all our writes have been sent to the filesystem
+                sWriter.flush();
+            } catch (IOException e) {
+                closeWriterAndUpdatePathLocked(null);
+                Log.w(TAG, "Failed to write: " + sPersistentFile, e);
+            }
+        }
+    }
+
+    @GuardedBy("LOCK")
+    private static void closeWriterAndUpdatePathLocked(@Nullable Path newPath) {
+        if (sWriter != null) {
+            try {
+                sWriter.close();
+            } catch (IOException ignored) {
+                Log.w(TAG, "Failed to close: " + sPersistentFile, ignored);
+            }
+            sWriter = null;
+        }
+        sPersistentFile = newPath;
+    }
+
+    /**
+     * Dump any persistent logs.
+     */
+    public static void dumpPersistent(@NonNull PrintWriter pw) {
+        Path persistentDir = null;
+        synchronized (LOCK) {
+            if (sPersistentDir == null) return;
+            persistentDir = sPersistentDir;
+        }
+
+        try (Stream<Path> stream = Files.list(persistentDir)) {
+            stream.sorted().forEach((path) -> {
+                dumpPersistentFile(path, pw);
+            });
+        } catch (IOException e) {
+            pw.println(e.getMessage());
+            pw.println();
+        }
+    }
+
+    private static void dumpPersistentFile(@NonNull Path path, @NonNull PrintWriter pw) {
+        pw.println("Persistent logs in " + path + ":");
+        try (Stream<String> stream = Files.lines(path)) {
+            stream.forEach((line) -> {
+                pw.println("  " + line);
+            });
+            pw.println();
+        } catch (IOException e) {
+            pw.println("  " + e.getMessage());
+            pw.println();
+        }
+    }
+
+    /**
+     * Resolve the current log file to write new entries into. Automatically
+     * starts new files when the current file is larger than
+     * {@link #PERSISTENT_SIZE}.
+     */
+    @GuardedBy("LOCK")
+    private static @NonNull Path resolveCurrentPersistentFileLocked() throws IOException {
+        if (sPersistentFile != null && sPersistentFile.toFile().length() < PERSISTENT_SIZE) {
+            return sPersistentFile;
+        }
+
+        return sPersistentDir.resolve(String.valueOf(System.currentTimeMillis()));
+    }
+}
diff --git a/legacy/src/com/android/providers/media/util/LegacyMimeUtils.java b/legacy/src/com/android/providers/media/util/LegacyMimeUtils.java
new file mode 100644
index 000000000..6f7a82b88
--- /dev/null
+++ b/legacy/src/com/android/providers/media/util/LegacyMimeUtils.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import androidx.annotation.Nullable;
+
+import java.util.Locale;
+
+public class LegacyMimeUtils {
+
+    /**
+     * Returns true if MIME type represents a subtitle
+     *
+     * @param mimeType MIME type string
+     * @return true if mimeType matches a subtitle type
+     */
+    public static boolean isSubtitleMimeType(@Nullable String mimeType) {
+        if (mimeType == null) return false;
+        switch (mimeType.toLowerCase(Locale.ROOT)) {
+            case "application/lrc":
+            case "application/smil+xml":
+            case "application/ttml+xml":
+            case "application/x-extension-cap":
+            case "application/x-extension-srt":
+            case "application/x-extension-sub":
+            case "application/x-extension-vtt":
+            case "application/x-subrip":
+            case "text/vtt":
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Returns true if MIME type represents a document
+     *
+     * @param mimeType MIME type string
+     * @return true if mimeType is text or a known document format
+     */
+    public static boolean isDocumentMimeType(@Nullable String mimeType) {
+        if (mimeType == null) return false;
+
+        if (LegacyStringUtils.startsWithIgnoreCase(mimeType, "text/")) return true;
+
+        switch (mimeType.toLowerCase(Locale.ROOT)) {
+            case "application/epub+zip":
+            case "application/msword":
+            case "application/pdf":
+            case "application/rtf":
+            case "application/vnd.ms-excel":
+            case "application/vnd.ms-excel.addin.macroenabled.12":
+            case "application/vnd.ms-excel.sheet.binary.macroenabled.12":
+            case "application/vnd.ms-excel.sheet.macroenabled.12":
+            case "application/vnd.ms-excel.template.macroenabled.12":
+            case "application/vnd.ms-powerpoint":
+            case "application/vnd.ms-powerpoint.addin.macroenabled.12":
+            case "application/vnd.ms-powerpoint.presentation.macroenabled.12":
+            case "application/vnd.ms-powerpoint.slideshow.macroenabled.12":
+            case "application/vnd.ms-powerpoint.template.macroenabled.12":
+            case "application/vnd.ms-word.document.macroenabled.12":
+            case "application/vnd.ms-word.template.macroenabled.12":
+            case "application/vnd.oasis.opendocument.chart":
+            case "application/vnd.oasis.opendocument.database":
+            case "application/vnd.oasis.opendocument.formula":
+            case "application/vnd.oasis.opendocument.graphics":
+            case "application/vnd.oasis.opendocument.graphics-template":
+            case "application/vnd.oasis.opendocument.presentation":
+            case "application/vnd.oasis.opendocument.presentation-template":
+            case "application/vnd.oasis.opendocument.spreadsheet":
+            case "application/vnd.oasis.opendocument.spreadsheet-template":
+            case "application/vnd.oasis.opendocument.text":
+            case "application/vnd.oasis.opendocument.text-master":
+            case "application/vnd.oasis.opendocument.text-template":
+            case "application/vnd.oasis.opendocument.text-web":
+            case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
+            case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
+            case "application/vnd.openxmlformats-officedocument.presentationml.template":
+            case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
+            case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
+            case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
+            case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
+            case "application/vnd.stardivision.calc":
+            case "application/vnd.stardivision.chart":
+            case "application/vnd.stardivision.draw":
+            case "application/vnd.stardivision.impress":
+            case "application/vnd.stardivision.impress-packed":
+            case "application/vnd.stardivision.mail":
+            case "application/vnd.stardivision.math":
+            case "application/vnd.stardivision.writer":
+            case "application/vnd.stardivision.writer-global":
+            case "application/vnd.sun.xml.calc":
+            case "application/vnd.sun.xml.calc.template":
+            case "application/vnd.sun.xml.draw":
+            case "application/vnd.sun.xml.draw.template":
+            case "application/vnd.sun.xml.impress":
+            case "application/vnd.sun.xml.impress.template":
+            case "application/vnd.sun.xml.math":
+            case "application/vnd.sun.xml.writer":
+            case "application/vnd.sun.xml.writer.global":
+            case "application/vnd.sun.xml.writer.template":
+            case "application/x-mspublisher":
+                return true;
+            default:
+                return false;
+        }
+    }
+
+}
diff --git a/legacy/src/com/android/providers/media/util/LegacyStringUtils.java b/legacy/src/com/android/providers/media/util/LegacyStringUtils.java
new file mode 100644
index 000000000..d92fd5808
--- /dev/null
+++ b/legacy/src/com/android/providers/media/util/LegacyStringUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import androidx.annotation.Nullable;
+
+public class LegacyStringUtils {
+
+    /**
+     * Variant of {@link String#startsWith(String)} but which tests with
+     * case-insensitivity.
+     */
+    public static boolean startsWithIgnoreCase(@Nullable String target, @Nullable String other) {
+        if (target == null || other == null) return false;
+        if (other.length() > target.length()) return false;
+        return target.regionMatches(true, 0, other, 0, other.length());
+    }
+
+}
diff --git a/mediaprovider_flags.aconfig b/mediaprovider_flags.aconfig
index bcccc0eba..de617c438 100644
--- a/mediaprovider_flags.aconfig
+++ b/mediaprovider_flags.aconfig
@@ -157,6 +157,15 @@ flag {
     is_fixed_read_only: true
 }
 
+flag {
+    name: "enable_photopicker_datescrubber"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag controls whether to enable datescrubber feature in photopicker"
+    bug: "312640456"
+    is_fixed_read_only: true
+}
+
 flag {
     name: "cloud_media_provider_search"
     is_exported: true
@@ -237,3 +246,66 @@ flag {
     is_fixed_read_only: true
     bug: "294364218"
 }
+
+flag {
+    name: "revoke_access_owned_photos"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag will enable allowing users to revoke access to app created photos."
+    is_fixed_read_only: true
+    bug: "323322157"
+}
+
+flag {
+    name: "enable_exclusion_list_for_default_folders"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag will prevent folders on the exclusion list being created during default folder creation."
+    is_fixed_read_only: true
+    bug: "381310841"
+}
+
+flag {
+    name: "enable_photopicker_expressive_theme"
+    is_exported: false
+    namespace: "mediaprovider"
+    description: "This flag controls the material expressive theme in com.android.photopicker"
+    is_fixed_read_only: true
+    bug: "390142346"
+}
+
+flag {
+    name: "exclude_unreliable_volumes"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag will enable exclusion of unreliable storage volumes in the returned list from MediaStore APIs."
+    is_fixed_read_only: true
+    bug: "391360514"
+}
+
+flag {
+    name: "enable_mime_type_fix_for_android_15"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag enables the fix for MIME type mapping in Android 15, correcting the faulty mime.types entries."
+    is_fixed_read_only: true
+    bug: "376910932"
+}
+
+flag {
+    name: "enable_oem_metadata_update"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "Controls ability to update oem_metadata column"
+    bug: "352528913"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_local_media_provider_capabilities"
+    namespace: "mediaprovider"
+    description: "This flag controls the Capabilities APIs in the local media provider, i.e. PhotoPickerProvider."
+    bug: "402379523"
+    is_fixed_read_only: true
+    is_exported: true
+}
diff --git a/pdf/OWNERS b/pdf/OWNERS
index 40f36b7fd..f8c7cc8d7 100644
--- a/pdf/OWNERS
+++ b/pdf/OWNERS
@@ -1,6 +1,8 @@
 # Bug component: 325029
 
-nishantpanwar@google.com
+gulshansingh@google.com
+anuragadarsh@google.com
+
+# For emergency fixes
 bhavyajain@google.com
-anothermark@google.com
-gulshansingh@google.com
\ No newline at end of file
+guruprasadr@google.com
diff --git a/pdf/framework-v/Android.bp b/pdf/framework-v/Android.bp
index a58040021..10f1ae6a7 100644
--- a/pdf/framework-v/Android.bp
+++ b/pdf/framework-v/Android.bp
@@ -30,6 +30,7 @@ java_sdk_library {
         "modules-utils-preconditions",
         "unsupportedappusage",
         "pdf_viewer_flags_java_lib",
+        "pdf_viewer_flags_readonly_java_lib",
     ],
     stub_only_libs: [
         "framework-pdf.stubs.module_lib",
@@ -45,6 +46,7 @@ java_sdk_library {
     ],
     aconfig_declarations: [
         "pdf_viewer_flags",
+        "pdf_viewer_flags_readonly",
     ],
     impl_library_visibility: [
         "//packages/providers/MediaProvider:__subpackages__",
diff --git a/pdf/framework-v/api/current.txt b/pdf/framework-v/api/current.txt
index 0f5aa7ffb..90cf2e276 100644
--- a/pdf/framework-v/api/current.txt
+++ b/pdf/framework-v/api/current.txt
@@ -20,7 +20,7 @@ package android.graphics.pdf {
   }
 
   public final class PdfRenderer.Page implements java.lang.AutoCloseable {
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public int addPageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @IntRange(from=0xffffffff) public int addPageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
     method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public int addPageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
     method @FlaggedApi("android.graphics.pdf.flags.enable_form_filling") @NonNull public java.util.List<android.graphics.Rect> applyEdit(@NonNull android.graphics.pdf.models.FormEditRecord);
     method public void close();
@@ -33,18 +33,18 @@ package android.graphics.pdf {
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.content.PdfPageImageContent> getImageContents();
     method @IntRange(from=0) public int getIndex();
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.content.PdfPageLinkContent> getLinkContents();
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public java.util.List<android.graphics.pdf.component.PdfAnnotation> getPageAnnotations();
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public java.util.List<android.graphics.pdf.component.PdfPageObject> getPageObjects();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public java.util.List<android.util.Pair<java.lang.Integer,android.graphics.pdf.component.PdfAnnotation>> getPageAnnotations();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public java.util.List<android.util.Pair<java.lang.Integer,android.graphics.pdf.component.PdfPageObject>> getPageObjects();
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.content.PdfPageTextContent> getTextContents();
     method @IntRange(from=0) public int getWidth();
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public android.graphics.pdf.component.PdfAnnotation removePageAnnotation(int);
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public android.graphics.pdf.component.PdfPageObject removePageObject(int);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public void removePageAnnotation(@IntRange(from=0) int);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public void removePageObject(@IntRange(from=0) int);
     method public void render(@NonNull android.graphics.Bitmap, @Nullable android.graphics.Rect, @Nullable android.graphics.Matrix, int);
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") public void render(@NonNull android.graphics.Bitmap, @Nullable android.graphics.Rect, @Nullable android.graphics.Matrix, @NonNull android.graphics.pdf.RenderParams);
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.models.PageMatchBounds> searchText(@NonNull String);
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @Nullable public android.graphics.pdf.models.selection.PageSelection selectContent(@NonNull android.graphics.pdf.models.selection.SelectionBoundary, @NonNull android.graphics.pdf.models.selection.SelectionBoundary);
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public boolean updatePageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public boolean updatePageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public boolean updatePageAnnotation(@IntRange(from=0) int, @NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public boolean updatePageObject(@IntRange(from=0) int, @NonNull android.graphics.pdf.component.PdfPageObject);
     field public static final int RENDER_MODE_FOR_DISPLAY = 1; // 0x1
     field public static final int RENDER_MODE_FOR_PRINT = 2; // 0x2
   }
diff --git a/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java b/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java
index bf0125881..0296fd01d 100644
--- a/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java
+++ b/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java
@@ -51,6 +51,7 @@ import android.os.Build;
 import android.os.ParcelFileDescriptor;
 import android.util.CloseGuard;
 import android.util.Log;
+import android.util.Pair;
 
 import androidx.annotation.RestrictTo;
 
@@ -782,136 +783,142 @@ public final class PdfRenderer implements AutoCloseable {
         }
 
         /**
-         * Return a list of supported {@link PdfAnnotation} present on the
-         * page. See {@link PdfAnnotationType} for the supported types
+         * Returns a list of pairs, where each pair consists of a supported {@link PdfAnnotation}
+         * and its corresponding ID on the specified page. ID of the annotation will be required for
+         * {@link #updatePageAnnotation(int, PdfAnnotation)} and {@link #removePageAnnotation(int)}
+         * and will remain same without mutate operations.
+         *
          * <p>
-         * The list will be empty if there are no supported
-         * annotations present on the page, even if the page
-         * contains other annotation types.
+         * The returned list will be empty if no supported annotations are present on the page,
+         * even if the page contains other annotation types. Refer to {@link PdfAnnotationType} for
+         * the supported annotation types.
          *
-         * @return list of supported annotations present on the page
-         * @throws IllegalStateException if {@link PdfRenderer} or {@link PdfRenderer.Page}
-         *         is closed before invocation.
+         * @return A list of pairs representing the supported annotations and their ids on the page.
+         * @throws IllegalStateException    if {@link PdfRenderer} or
+         *                                  {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
         @NonNull
-        public List<PdfAnnotation> getPageAnnotations() {
+        public List<Pair<Integer, PdfAnnotation>> getPageAnnotations() {
             throwIfDocumentOrPageClosed();
             return mPdfProcessor.getPageAnnotations(mIndex);
-
         }
 
         /**
-         * Adds the given annotation to the page. The annotation should be of
-         * supported type. See {@link PdfAnnotationType} for the supported types
+         * Adds the given annotation to the page. The annotation should be of supported type.
+         * See {@link PdfAnnotationType} for the supported types
+         *
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream
+         * after calling this method. {@link PdfRenderer.Page} instance can be closed before
+         * calling {@link PdfRenderer#write}.
          *
-         * @param annotation the {@link PdfAnnotation} object to
-         *        add
-         * @return id of the added annotation,
-         *         or -1 if the annotation cannot be added. The
-         *         id is guaranteed to be non-negative if
-         *         the annotation is added successfully.
-         * @throws IllegalArgumentException if the provided
-         *         annotation is null or of unsupported type i.e.-
-         *         {@link PdfAnnotationType#UNKNOWN} or if the annotation is already
-         *         added in this page or some other page of the document.
-         * @throws IllegalStateException if {@link PdfRenderer} or {@link PdfRenderer.Page}
-         *         is closed before invocation.
+         * @param annotation the {@link PdfAnnotation} object to add
+         * @return id of the added annotation, or -1 if the annotation cannot be added. The id is
+         *         guaranteed to be non-negative if the annotation is added successfully.
+         * @throws IllegalArgumentException if the provided annotation is null or of unsupported
+         *                                  type i.e.- {@link PdfAnnotationType#UNKNOWN}
+         * @throws IllegalStateException    if {@link PdfRenderer} or {@link PdfRenderer.Page}
+         *                                  is closed before invocation.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
-        public int addPageAnnotation(@androidx.annotation.NonNull PdfAnnotation annotation) {
+        @IntRange(from = -1)
+        public int addPageAnnotation(@NonNull PdfAnnotation annotation) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkNotNull(annotation, "Annotation should not be null");
             Preconditions.checkArgument(
                     annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
                     "Annotation should be of valid type");
-            Preconditions.checkArgument(annotation.getId() != -1,
-                    "Annotation already added");
             return mPdfProcessor.addPageAnnotation(mIndex, annotation);
         }
 
         /**
          * Removes the annotation with the specified id.
          *
-         * @param annotationId id of the annotation to remove from the page
-         * @return the removed annotation
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
+         * @param annotationId id of the annotation to remove from the page
          * @throws IllegalArgumentException if annotationId ie negative
-         *
-         * @throws IllegalStateException if {@link PdfRendererPreV} or
-         *        {@link PdfRendererPreV.Page} is closed before invocation or if
-         *        annotation is failed to get removed from the page.
+         * @throws IllegalStateException    if {@link PdfRenderer} or {@link PdfRenderer.Page} is
+         *                                  closed before invocation or if annotation is failed to
+         *                                  get removed from the page.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
-        @androidx.annotation.NonNull
-        public PdfAnnotation removePageAnnotation(int annotationId) {
+        public void removePageAnnotation(@IntRange(from = 0) int annotationId) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkArgument(annotationId >= 0,
                     "Annotation id should be non-negative");
-            PdfAnnotation removedAnnotation = mPdfProcessor.removePageAnnotation(mIndex,
-                    annotationId);
-            if (removedAnnotation == null) {
-                throw new IllegalStateException(
-                        "Failed to remove annotation with id " + annotationId);
-            }
-            return removedAnnotation;
+            mPdfProcessor.removePageAnnotation(mIndex, annotationId);
         }
 
         /**
          * Update the given {@link PdfAnnotation} to the page.
          *
-         * @param annotation the annotation to update
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
+         * @param annotationId id corresponding to which the annotation is to be updated
+         * @param annotation the annotation to update
          * @return true if annotation is updated, false otherwise
-         *
          * @throws IllegalArgumentException if the provided annotation is null or of
-         *         unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
-         *
-         * @throws IllegalStateException if {@link PdfRendererPreV} or
-         *         {@link PdfRendererPreV.Page}  is closed before invocation
+         *                                  unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
+         *                                  or if the provided annotationId is negative
+         * @throws IllegalStateException    if {@link PdfRenderer} or {@link PdfRenderer.Page}  is
+         *                                  closed before invocation
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
-        public boolean updatePageAnnotation(@androidx.annotation.NonNull PdfAnnotation annotation) {
+        public boolean updatePageAnnotation(@IntRange(from = 0) int annotationId,
+                @NonNull PdfAnnotation annotation) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkNotNull(annotation, "PdfAnnotation should not be null");
             Preconditions.checkArgument(
                     annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
                     "Annotation should be of valid type");
-
-            Preconditions.checkArgument(annotation.getId() >= 0,
-                    "Annotation id should be greater than equal to 0");
-            return mPdfProcessor.updatePageAnnotation(mIndex, annotation);
+            Preconditions.checkArgument(annotationId >= 0,
+                    "Annotation Id should be non-negative");
+            return mPdfProcessor.updatePageAnnotation(mIndex, annotationId, annotation);
         }
 
         /**
-         * Returns list of supported {@link PdfPageObject} present on
-         * the page.
+         * Returns {@link List} of {@link Pair} objects, where each pair contains:
+         * - An {@link Integer} representing the object ID, which is required for
+         * {@link #updatePageObject(int, PdfPageObject)} and {@link #removePageObject(int)}.
+         * Object ID will remain same without mutate operations.
+         * - A {@link PdfPageObject} representing the page object.
+         * <p>
          * The list will be empty if there are no supported page
          * objects present on the page, even if the page contains
          * other page object types.
          *
-         * @return list of page objects present on the page
-         *
-         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
-         *                                  invocation.
+         * @return {@link List} of {@link Pair} objects containing {@link Integer} and
+         * {@link PdfPageObject}.
+         * @throws IllegalStateException if the {@link PdfRenderer.Page} is closed before
+         *                               invocation.
          */
         @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-        public List<PdfPageObject> getPageObjects() {
+        public List<Pair<Integer, PdfPageObject>> getPageObjects() {
             throwIfDocumentOrPageClosed();
             return mPdfProcessor.getPageObjects(mIndex);
         }
 
         /**
          * Adds the given {@link PdfPageObject} to the page.
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
-         * @param pageObject the {@code PdfPageObject} object to
-         *                   add, existing page object cannot be used (i.e. it should not have
-         *                   objectId)
-         * @return object id of added page object, -1 otherwise
-         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown, null
-         *                                  or if the object is already added to a page or an
-         *                                  annotation.
+         * @param pageObject the {@code PdfPageObject} object to add.
+         * @return id of the added page object, or -1 if the page object cannot be added. The
+         * id is guaranteed to be non-negative if the page object is added successfully.
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null
          * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
          *                                  invocation.
          */
@@ -922,57 +929,59 @@ public final class PdfRenderer implements AutoCloseable {
             Preconditions.checkArgument(
                     PdfPageObjectType.isValidType(pageObject.getPdfObjectType()),
                     "PageObject should be of valid type");
-            Preconditions.checkArgument(pageObject.getObjectId() == -1,
-                    "PageObject should not have an object id");
-            Preconditions.checkArgument(!pageObject.isAddedInAnnotation(),
-                    "PageObject already added to an annotation");
             return mPdfProcessor.addPageObject(mIndex, pageObject);
         }
 
         /**
          * Update the given {@link PdfPageObject} to the page.
+         * <p>
+         * Note: This method only updates the parameters of the PageObject whose setters
+         * are available. Attempting to update fields with no corresponding setters will
+         * have no effect.
+         *
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
-         * @param pageObject the {@code PdfPageObject} object to
-         *                   add
-         * @return true if page object is updated, false otherwise
-         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or
+         * @param objectId   The unique identifier of the page object to update.
+         * @param pageObject The {@code PdfPageObject} object to update.
+         * @return true if page object is updated, false otherwise.
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unsupported or
          *                                  null.
          * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
          *                                  invocation.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-        public boolean updatePageObject(@NonNull PdfPageObject pageObject) {
+        public boolean updatePageObject(@IntRange(from = 0) int objectId,
+                @NonNull PdfPageObject pageObject) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkNotNull(pageObject, "PdfPageObject should not be null");
             Preconditions.checkArgument(
                     PdfPageObjectType.isValidType(pageObject.getPdfObjectType()),
                     "PageObject should be of valid type");
-            Preconditions.checkArgument(pageObject.getObjectId() >= 0,
+            Preconditions.checkArgument(objectId >= 0,
                     "Page object id should be greater than equal to 0");
-            return mPdfProcessor.updatePageObject(mIndex, pageObject);
+            return mPdfProcessor.updatePageObject(mIndex, objectId, pageObject);
         }
 
         /**
          * Removes the {@link PdfPageObject} with the specified ID.
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
-         * @param objectId the id of the page object to remove
-         *                 from the page.
-         * @return {@link PdfPageObject} that is removed.
-         * @throws IllegalArgumentException if the provided
-         *                                  objectId doesn't exist.
+         * @param objectId the id of the page object to remove from the page.
+         * @throws IllegalArgumentException if the provided objectId doesn't exist.
          * @throws IllegalStateException    if the page object cannot be removed.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-        @NonNull
-        public PdfPageObject removePageObject(int objectId) {
+        public void removePageObject(@IntRange(from = 0) int objectId) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkArgument(objectId >= 0,
                     "Page object id should be greater than equal to 0");
-            PdfPageObject pageObject = mPdfProcessor.removePageObject(mIndex, objectId);
-            if (pageObject == null) {
-                throw new IllegalStateException("Page object cannot be removed.");
-            }
-            return pageObject;
+            mPdfProcessor.removePageObject(mIndex, objectId);
         }
 
         /**
diff --git a/pdf/framework/Android.bp b/pdf/framework/Android.bp
index 05db621c7..d2d9459e9 100644
--- a/pdf/framework/Android.bp
+++ b/pdf/framework/Android.bp
@@ -29,6 +29,7 @@ java_sdk_library {
     ],
     static_libs: [
         "pdf_viewer_flags_java_lib",
+        "pdf_viewer_flags_readonly_java_lib",
         "pdf-statsd",
     ],
     libs: [
@@ -42,6 +43,7 @@ java_sdk_library {
     ],
     aconfig_declarations: [
         "pdf_viewer_flags",
+        "pdf_viewer_flags_readonly",
     ],
     impl_library_visibility: [
         "//packages/providers/MediaProvider:__subpackages__",
@@ -87,6 +89,30 @@ java_aconfig_library {
         "com.android.mediaprovider",
     ],
     defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    mode: "exported",
+}
+
+aconfig_declarations {
+    name: "pdf_viewer_flags_readonly",
+    package: "android.graphics.pdf.flags.readonly",
+    srcs: [
+        "pdf_viewer_flags_readonly.aconfig",
+    ],
+    container: "com.android.mediaprovider",
+}
+
+java_aconfig_library {
+    name: "pdf_viewer_flags_readonly_java_lib",
+    aconfig_declarations: "pdf_viewer_flags_readonly",
+    visibility: [
+        "//packages/providers/MediaProvider/pdf:__subpackages__",
+    ],
+    min_sdk_version: "31",
+    apex_available: [
+        "com.android.mediaprovider",
+    ],
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    mode: "force-read-only",
 }
 
 // To generate the Stats log classes for the Android Pdf.
@@ -110,6 +136,7 @@ java_library {
     libs: [
         // To add StatsLog as a dependency of the generated file.
         "framework-statsd.stubs.module_lib",
+        "androidx.annotation_annotation",
     ],
     apex_available: [
         "com.android.mediaprovider",
diff --git a/pdf/framework/api/current.txt b/pdf/framework/api/current.txt
index ce0238453..feef20bcf 100644
--- a/pdf/framework/api/current.txt
+++ b/pdf/framework/api/current.txt
@@ -29,7 +29,7 @@ package android.graphics.pdf {
   }
 
   public final class PdfRendererPreV.Page implements java.lang.AutoCloseable {
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public int addPageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @IntRange(from=0xffffffff) public int addPageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
     method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public int addPageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
     method @FlaggedApi("android.graphics.pdf.flags.enable_form_filling") @NonNull public java.util.List<android.graphics.Rect> applyEdit(@NonNull android.graphics.pdf.models.FormEditRecord);
     method public void close();
@@ -42,23 +42,25 @@ package android.graphics.pdf {
     method @NonNull public java.util.List<android.graphics.pdf.content.PdfPageImageContent> getImageContents();
     method @IntRange(from=0) public int getIndex();
     method @NonNull public java.util.List<android.graphics.pdf.content.PdfPageLinkContent> getLinkContents();
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public java.util.List<android.graphics.pdf.component.PdfAnnotation> getPageAnnotations();
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public java.util.List<android.graphics.pdf.component.PdfPageObject> getPageObjects();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public java.util.List<android.util.Pair<java.lang.Integer,android.graphics.pdf.component.PdfAnnotation>> getPageAnnotations();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public java.util.List<android.util.Pair<java.lang.Integer,android.graphics.pdf.component.PdfPageObject>> getPageObjects();
     method @NonNull public java.util.List<android.graphics.pdf.content.PdfPageTextContent> getTextContents();
     method @IntRange(from=0) public int getWidth();
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public android.graphics.pdf.component.PdfAnnotation removePageAnnotation(int);
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public android.graphics.pdf.component.PdfPageObject removePageObject(int);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public void removePageAnnotation(@IntRange(from=0) int);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public void removePageObject(@IntRange(from=0) int);
     method public void render(@NonNull android.graphics.Bitmap, @Nullable android.graphics.Rect, @Nullable android.graphics.Matrix, @NonNull android.graphics.pdf.RenderParams);
     method @NonNull public java.util.List<android.graphics.pdf.models.PageMatchBounds> searchText(@NonNull String);
     method @Nullable public android.graphics.pdf.models.selection.PageSelection selectContent(@NonNull android.graphics.pdf.models.selection.SelectionBoundary, @NonNull android.graphics.pdf.models.selection.SelectionBoundary);
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public boolean updatePageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
-    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public boolean updatePageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public boolean updatePageAnnotation(@IntRange(from=0) int, @NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public boolean updatePageObject(@IntRange(from=0) int, @NonNull android.graphics.pdf.component.PdfPageObject);
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") public final class RenderParams {
     method public int getRenderFlags();
     method public int getRenderMode();
+    field @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_annotations") public static final int FLAG_RENDER_FREETEXT_ANNOTATIONS = 16; // 0x10
     field public static final int FLAG_RENDER_HIGHLIGHT_ANNOTATIONS = 4; // 0x4
+    field @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_stamp_annotations") public static final int FLAG_RENDER_STAMP_ANNOTATIONS = 8; // 0x8
     field public static final int FLAG_RENDER_TEXT_ANNOTATIONS = 2; // 0x2
     field public static final int RENDER_MODE_FOR_DISPLAY = 1; // 0x1
     field public static final int RENDER_MODE_FOR_PRINT = 2; // 0x2
@@ -78,24 +80,25 @@ package android.graphics.pdf.component {
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_annotations") public final class FreeTextAnnotation extends android.graphics.pdf.component.PdfAnnotation {
     ctor public FreeTextAnnotation(@NonNull android.graphics.RectF, @NonNull String);
     method @ColorInt public int getBackgroundColor();
+    method @NonNull public android.graphics.RectF getBounds();
     method @ColorInt public int getTextColor();
     method @NonNull public String getTextContent();
     method public void setBackgroundColor(@ColorInt int);
+    method public void setBounds(@NonNull android.graphics.RectF);
     method public void setTextColor(@ColorInt int);
     method public void setTextContent(@NonNull String);
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public final class HighlightAnnotation extends android.graphics.pdf.component.PdfAnnotation {
-    ctor public HighlightAnnotation(@NonNull android.graphics.RectF);
+    ctor public HighlightAnnotation(@NonNull java.util.List<android.graphics.RectF>);
+    method @NonNull public java.util.List<android.graphics.RectF> getBounds();
     method @ColorInt public int getColor();
+    method public void setBounds(@NonNull java.util.List<android.graphics.RectF>);
     method public void setColor(@ColorInt int);
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public abstract class PdfAnnotation {
-    method @NonNull public android.graphics.RectF getBounds();
-    method public int getId();
     method public int getPdfAnnotationType();
-    method public void setBounds(@NonNull android.graphics.RectF);
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public final class PdfAnnotationType {
@@ -112,16 +115,19 @@ package android.graphics.pdf.component {
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public abstract class PdfPageObject {
-    method @NonNull public android.graphics.RectF getBounds();
     method @NonNull public float[] getMatrix();
-    method public int getObjectId();
     method public int getPdfObjectType();
-    method public boolean isAddedInAnnotation();
-    method public void setBounds(@NonNull android.graphics.RectF);
     method public void setMatrix(@NonNull android.graphics.Matrix);
     method public void transform(float, float, float, float, float, float);
   }
 
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPageObjectRenderMode {
+    field public static final int FILL = 0; // 0x0
+    field public static final int FILL_STROKE = 2; // 0x2
+    field public static final int STROKE = 1; // 0x1
+    field public static final int UNKNOWN = -1; // 0xffffffff
+  }
+
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPageObjectType {
     method public static boolean isValidType(int);
     field public static final int IMAGE = 3; // 0x3
@@ -131,40 +137,59 @@ package android.graphics.pdf.component {
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPagePathObject extends android.graphics.pdf.component.PdfPageObject {
-    ctor public PdfPagePathObject();
-    method @Nullable public android.graphics.Color getFillColor();
-    method @Nullable public android.graphics.PathEffect getLineStyle();
-    method @NonNull public android.graphics.Path getPath();
-    method @NonNull public android.graphics.Color getStrokeColor();
+    ctor public PdfPagePathObject(@NonNull android.graphics.Path);
+    method @ColorInt public int getFillColor();
+    method public int getRenderMode();
+    method @ColorInt public int getStrokeColor();
     method public float getStrokeWidth();
-    method public void setFillColor(@Nullable android.graphics.Color);
-    method public void setLineStyle(int);
-    method public void setPath(@NonNull android.graphics.Path);
-    method public void setStrokeColor(@NonNull android.graphics.Color);
+    method public void setFillColor(@ColorInt int);
+    method public void setRenderMode(int);
+    method public void setStrokeColor(@ColorInt int);
     method public void setStrokeWidth(float);
+    method @NonNull public android.graphics.Path toPath();
   }
 
-  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPageTextObject extends android.graphics.pdf.component.PdfPageObject {
-    ctor @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_objects") public PdfPageTextObject(@NonNull String, @NonNull android.graphics.Typeface, float);
-    method @Nullable public android.graphics.Color getFillColor();
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_objects") public final class PdfPageTextObject extends android.graphics.pdf.component.PdfPageObject {
+    ctor public PdfPageTextObject(@NonNull String, @NonNull android.graphics.pdf.component.PdfPageTextObjectFont, float);
+    method @ColorInt public int getFillColor();
+    method @NonNull public android.graphics.pdf.component.PdfPageTextObjectFont getFont();
     method public float getFontSize();
-    method @NonNull public android.graphics.Color getStrokeColor();
+    method public int getRenderMode();
+    method @ColorInt public int getStrokeColor();
     method public float getStrokeWidth();
     method @NonNull public String getText();
-    method @NonNull public android.graphics.Typeface getTypeface();
-    method public void setFillColor(@Nullable android.graphics.Color);
-    method public void setFontSize(float);
-    method public void setStrokeColor(@NonNull android.graphics.Color);
+    method public void setFillColor(@ColorInt int);
+    method public void setRenderMode(int);
+    method public void setStrokeColor(@ColorInt int);
     method public void setStrokeWidth(float);
     method public void setText(@NonNull String);
-    method public void setTypeface(@NonNull android.graphics.Typeface);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_objects") public class PdfPageTextObjectFont {
+    ctor public PdfPageTextObjectFont(int, boolean, boolean);
+    ctor public PdfPageTextObjectFont(@NonNull android.graphics.pdf.component.PdfPageTextObjectFont);
+    method public int getFontFamily();
+    method public boolean isBold();
+    method public boolean isItalic();
+    method public void setBold(boolean);
+    method public void setFontFamily(int);
+    method public void setItalic(boolean);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_objects") public class PdfPageTextObjectFontFamily {
+    field public static final int COURIER = 0; // 0x0
+    field public static final int HELVETICA = 1; // 0x1
+    field public static final int SYMBOL = 2; // 0x2
+    field public static final int TIMES_NEW_ROMAN = 3; // 0x3
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_stamp_annotations") public final class StampAnnotation extends android.graphics.pdf.component.PdfAnnotation {
     ctor public StampAnnotation(@NonNull android.graphics.RectF);
     method public void addObject(@NonNull android.graphics.pdf.component.PdfPageObject);
+    method @NonNull public android.graphics.RectF getBounds();
     method @NonNull public java.util.List<android.graphics.pdf.component.PdfPageObject> getObjects();
-    method public void removeObject(int);
+    method public void removeObject(@IntRange(from=0) int);
+    method public void setBounds(@NonNull android.graphics.RectF);
   }
 
 }
diff --git a/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java b/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java
index b5b866d50..3a1b065a7 100644
--- a/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java
+++ b/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java
@@ -259,54 +259,57 @@ public class PdfDocumentProxy {
             int pageNum, int annotIndex, int[] selectedIndices);
 
     /**
-     * Gets the list of annotations of supported types (freetext, image, stamp) present
-     * on the page
+     * Returns the list of {@link PdfAnnotation} present on the page.
+     * The list item is non-null for supported types (freetext, image, stamp) and
+     * null for unsupported types.
      *
      * @param pageNum - page number of the page whose annotations list is to be returned
+     * @return A {@link List} of {@link PdfAnnotation}
      */
     public native @NonNull List<PdfAnnotation> getPageAnnotations(
             @IntRange(from = 0) int pageNum);
 
     /**
-     * Adds an annotation to the given page
+     * Adds the given {@link PdfAnnotation} to the given page
      *
      * @param pageNum    - page number of the page to which annotation is to be added
-     * @param annotation - annotation to be added to the given page
-     * @return index of the annotation added and -1 in case of failure
+     * @param annotation - {@link PdfAnnotation} to be added to the given page
+     * @return index of the annotation added, -1 in case of failure
      */
     public native int addPageAnnotation(@IntRange(from = 0) int pageNum,
             @NonNull PdfAnnotation annotation);
 
     /**
-     * Removes an annotation from the given page
+     * Removes the {@link PdfAnnotation} with the specified index from the given page.
      *
-     * @param pageNum         - page number of the page from which annotation is to be removed
-     * @param annotationId - id of the annotation to be removed
+     * @param pageNum      - page number from which {@link PdfAnnotation} is to be removed
+     * @param annotationIndex - index of the {@link PdfAnnotation} to be removed
+     *
+     * @return true if remove was successful, false otherwise
      */
-    public native PdfAnnotation removePageAnnotation(@IntRange(from = 0) int pageNum,
-            @IntRange(from = 0) int annotationId);
+    public native boolean removePageAnnotation(@IntRange(from = 0) int pageNum,
+            @IntRange(from = 0) int annotationIndex);
 
     /**
-     * Updates an annotation on the given page
+     * Update the given {@link PdfAnnotation} on the given page
+     *
+     * @param pageNum    page number on which annotation is to be updated
+     * @param annotationIndex index of the annotation
+     * @param annotation annotation to be updated
      *
-     * @param pageNum     page number of the page on which annotation is to be updated
-     * @param annotation  annotation to be updated
+     * @return true if page object is updated, false otherwise
      */
     public native boolean updatePageAnnotation(@IntRange(from = 0) int pageNum,
-            PdfAnnotation annotation);
+            int annotationIndex, PdfAnnotation annotation);
 
 
     /**
-     * Return list of supported {@link PdfPageObject} present on
-     * the page.
-     * The list will be empty  if there are no supported page
-     * objects present on the page, even if the page contains
-     * other page object types.
+     * Returns the list of {@link PdfPageObject} present on the page.
+     * The list item is non-null for supported types and
+     * null for unsupported types.
      *
-     * @param pageNum - page number of the page whose annotations list is returned
-     * @return list of {@link PdfPageObject} present on the page
-     * @throws IllegalStateException if the document/page is
-     *                               closed before invocation
+     * @param pageNum - page number of the page whose annotations list is to be returned
+     * @return A {@link List} of {@link PdfPageObject}
      */
     public native List<PdfPageObject> getPageObjects(int pageNum);
 
@@ -314,35 +317,30 @@ public class PdfDocumentProxy {
      * Adds the given page object to the page.
      *
      * @param pageNum    - page number of the page to which pageObject is to be added
-     * @param pageObject the {@link PdfPageObject} object to
-     *                   add
-     * @return object id of added page object, -1 otherwise
-     * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
-     * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
+     * @param pageObject - {@link PdfPageObject} to be added to the given page
+     * @return index of added page object, -1 in the case of failure
      */
     public native int addPageObject(int pageNum, @NonNull PdfPageObject pageObject);
 
     /**
-     * Update the given {@link PdfPageObject} to the page.
+     * Update the given {@link PdfPageObject} on the given page
+     *
+     * @param pageNum    page number on which the {@link PdfPageObject} is to be updated
+     * @param objectIndex   index of the pageObject
+     * @param pageObject pageObject to be updated
      *
-     * @param pageObject the {@code PdfPageObject} object to
-     *                   add
      * @return true if page object is updated, false otherwise
-     * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
-     * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
      */
-    public native boolean updatePageObject(int pageNum,
+    public native boolean updatePageObject(int pageNum, int objectIndex,
             @NonNull PdfPageObject pageObject);
 
     /**
-     * Removes the {@link PdfPageObject} with the specified ID.
+     * Removes the {@link PdfPageObject} with the specified Index from the given page.
+     *
+     * @param pageNum  - page number from which {@link PdfPageObject} is to be removed
+     * @param objectIndex the index of the {@link PdfPageObject} to be removed
      *
-     * @param pageNum  - page number of the page from which annotation is to be removed
-     * @param objectId the ID of the page object to remove
-     *                 from the page
-     * @return {@link PdfPageObject} that is removed.
-     * @throws IllegalStateException if the provided
-     *                               objectId doesn't exist.
+     * @return true if remove was successful, false otherwise
      */
-    public native PdfPageObject removePageObject(int pageNum, int objectId);
+    public native boolean removePageObject(int pageNum, int objectIndex);
 }
diff --git a/pdf/framework/java/android/graphics/pdf/PdfPageComponentsIdManager.java b/pdf/framework/java/android/graphics/pdf/PdfPageComponentsIdManager.java
new file mode 100644
index 000000000..8ecbf7447
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/PdfPageComponentsIdManager.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @hide
+ * This class manages Id-Index Mapping for PdfAnnotations and PdfPageObjects.
+ */
+public class PdfPageComponentsIdManager {
+    private final HashMap<Integer, Integer> mIdIndexMap;
+    private HashMap<Integer, Integer> mIndexIdMap;
+    private int mComponentCurrentMaxId;
+
+    public PdfPageComponentsIdManager() {
+        mIdIndexMap = new HashMap<>();
+        mIndexIdMap = new HashMap<>();
+        mComponentCurrentMaxId = -1;
+    }
+
+    void deleteId(int id) {
+        int deletedComponentIndex = mIdIndexMap.get(id);
+        mIdIndexMap.remove(id);
+
+        HashMap<Integer, Integer> updatedIndexIdMap = new HashMap<>();
+        // Iterate and modify values greater than deletedComponentIndex
+        for (Map.Entry<Integer, Integer> entry : mIdIndexMap.entrySet()) {
+            if (entry.getValue() > deletedComponentIndex) {
+                entry.setValue(entry.getValue() - 1);
+            }
+            updatedIndexIdMap.put(entry.getValue(), entry.getKey());
+        }
+        mIndexIdMap = updatedIndexIdMap;
+    }
+
+    int getIndexForId(int id) {
+        if (!mIdIndexMap.containsKey(id)) {
+            return -1;
+        }
+        return mIdIndexMap.get(id);
+    }
+
+    int getIdForIndex(int index) {
+        if (!mIndexIdMap.containsKey(index)) {
+            mComponentCurrentMaxId += 1;
+            mIdIndexMap.put(mComponentCurrentMaxId, index);
+            mIndexIdMap.put(index, mComponentCurrentMaxId);
+            return mComponentCurrentMaxId;
+        }
+        return mIndexIdMap.get(index);
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/PdfProcessor.java b/pdf/framework/java/android/graphics/pdf/PdfProcessor.java
index bf2ece386..960d1cffe 100644
--- a/pdf/framework/java/android/graphics/pdf/PdfProcessor.java
+++ b/pdf/framework/java/android/graphics/pdf/PdfProcessor.java
@@ -49,10 +49,13 @@ import android.system.ErrnoException;
 import android.system.Os;
 import android.system.OsConstants;
 import android.util.Log;
+import android.util.Pair;
 
 import java.io.IOException;
 import java.security.SecureRandom;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.stream.Collectors;
 
@@ -78,6 +81,8 @@ public class PdfProcessor {
     private static final Object sPdfiumLock = new Object();
     private final PdfEventLogger mPdfEventLogger;
     private PdfDocumentProxy mPdfDocument;
+    private final HashMap<Integer, PdfPageComponentsIdManager> mPageObjectIdManagerMap;
+    private final HashMap<Integer, PdfPageComponentsIdManager> mPageAnnotationsIdManagerMap;
 
     public PdfProcessor() {
         PdfDocumentProxy.loadLibPdf();
@@ -85,6 +90,8 @@ public class PdfProcessor {
         mPdfEventLogger = new PdfEventLogger(
                 /* processId = */ Binder.getCallingUid(),
                 /* docId = */ new SecureRandom().nextLong());
+        mPageObjectIdManagerMap = new HashMap<>();
+        mPageAnnotationsIdManagerMap = new HashMap<>();
     }
 
     /**
@@ -370,6 +377,12 @@ public class PdfProcessor {
     public void retainPage(int pageNum) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
+            if (!mPageObjectIdManagerMap.containsKey(pageNum)) {
+                mPageObjectIdManagerMap.put(pageNum, new PdfPageComponentsIdManager());
+            }
+            if (!mPageAnnotationsIdManagerMap.containsKey(pageNum)) {
+                mPageAnnotationsIdManagerMap.put(pageNum, new PdfPageComponentsIdManager());
+            }
             mPdfDocument.retainPage(pageNum);
         }
     }
@@ -378,6 +391,8 @@ public class PdfProcessor {
     public void releasePage(int pageNum) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
+            mPageObjectIdManagerMap.remove(pageNum);
+            mPageAnnotationsIdManagerMap.remove(pageNum);
             mPdfDocument.releasePage(pageNum);
         }
     }
@@ -567,77 +582,110 @@ public class PdfProcessor {
     }
 
     /**
-     * Return list of supported {@link PdfAnnotation} present on the
-     * page. See {@link PdfAnnotationType} for the supported types
+     * Returns a list of pairs, where each pair consists of a supported
+     * {@link PdfAnnotation} and its corresponding ID on the specified page.
+     * Refer to {@link PdfAnnotationType} for the supported annotation types.
+     *
      * <p>
-     * The list will be empty if there are no supported
-     * annotations present on the page, even if the page
-     * contains other annotation types.
+     * The returned list will be empty if no supported annotations are present
+     * on the page, even if the page contains other annotation types.
      *
      * @param pageNum page number whose annotations' list to be retrieved
-     * @return list of supported annotations present on the page
+     * @return A list of pairs representing the supported annotations and their ids on the page.
      */
     @NonNull
-    public List<PdfAnnotation> getPageAnnotations(@IntRange(from = 0) int pageNum) {
+    public List<Pair<Integer, PdfAnnotation>> getPageAnnotations(@IntRange(from = 0) int pageNum) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.getPageAnnotations(pageNum);
+            PdfPageComponentsIdManager pageAnnotationIdManager =
+                    mPageAnnotationsIdManagerMap.get(pageNum);
+            List<PdfAnnotation> pdfAnnotations = mPdfDocument.getPageAnnotations(pageNum);
+            List<Pair<Integer, PdfAnnotation>> pdfAnnotationIdPairs = new ArrayList<>();
+            for (int i = 0; i < pdfAnnotations.size(); i++) {
+                if (pdfAnnotations.get(i) != null) {
+                    pdfAnnotationIdPairs.add(
+                            new Pair<>(pageAnnotationIdManager.getIdForIndex(i),
+                                    pdfAnnotations.get(i)));
+                }
+            }
+            return pdfAnnotationIdPairs;
         }
     }
+
     /**
      * Adds the given annotation to the page. The annotation should be of
      * supported type. See {@link PdfAnnotationType} for the supported types
      *
      * @param annotation the {@link PdfAnnotation} object to
-     *        add
-     * @param pageNum the page number where the annotation to be added
+     *                   add
+     * @param pageNum    the page number where the annotation to be added
      * @return the index of the added annotation,
-     *         or -1 if the annotation cannot be added. The
-     *         index is guaranteed to be non-negative if
-     *         the annotation is added successfully.
+     * or -1 if the annotation cannot be added. The
+     * index is guaranteed to be non-negative if
+     * the annotation is added successfully.
      */
     public int addPageAnnotation(@IntRange(from = 0) int pageNum,
             PdfAnnotation annotation) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.addPageAnnotation(pageNum, annotation);
+            int addedAnnotationIndex = mPdfDocument.addPageAnnotation(pageNum, annotation);
+            if (addedAnnotationIndex == -1) {
+                throw new IllegalArgumentException("Failed to add annotation");
+            }
+            return mPageAnnotationsIdManagerMap.get(pageNum).getIdForIndex(addedAnnotationIndex);
         }
     }
 
     /**
      * Removes the annotation with the specified index.
      *
-     * @param annotationIndex the index of the annotation to remove
-     * from the page
-     * @param pageNum page number from which annotation is to be removed
-     * @return the removed annotation
-     *
+     * @param annotationId the Id of the annotation to remove
+     *                        from the page
+     * @param pageNum         page number from which annotation is to be removed
      */
-    public PdfAnnotation removePageAnnotation(@IntRange(from = 0) int pageNum,
-            int annotationIndex) {
+    public void removePageAnnotation(@IntRange(from = 0) int pageNum,
+            int annotationId) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.removePageAnnotation(pageNum, annotationIndex);
+            PdfPageComponentsIdManager pdfAnnotationsIdManager =
+                    mPageAnnotationsIdManagerMap.get(pageNum);
+            int annotationIndex = pdfAnnotationsIdManager.getIndexForId(annotationId);
+            if (annotationIndex == -1) {
+                throw new IllegalArgumentException("Unknown annotationId. getPageAnnotations() "
+                        + "call never made?");
+            }
+            if (!mPdfDocument.removePageAnnotation(pageNum, annotationIndex)) {
+                throw new IllegalArgumentException("Annotation cannot be removed.");
+            }
+            pdfAnnotationsIdManager.deleteId(annotationId);
         }
     }
 
     /**
      * Update the given {@link PdfAnnotation} to the page.
      *
+     * @param annotationId id corresponding to which the annotation is to be updated
      * @param annotation the annotation to update
-     *
      * @return true if annotation is updated, false otherwise
-     *
      * @throws IllegalArgumentException f the provided annotation is null or of
-     *         unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
-     *
+     *                                  unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
+     *                                  or if the provided annotation id is negative
      **/
     @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-    public boolean updatePageAnnotation(int pageNum,
+    public boolean updatePageAnnotation(int pageNum, int annotationId,
             @NonNull PdfAnnotation annotation) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.updatePageAnnotation(pageNum, annotation);
+            int annotationIndex = mPageAnnotationsIdManagerMap.get(pageNum)
+                    .getIndexForId(annotationId);
+            if (annotationIndex == -1) {
+                throw new IllegalArgumentException("Unknown annotation Id. getPageAnnotations()"
+                        + " call never made?");
+            }
+            if (!mPdfDocument.updatePageAnnotation(pageNum, annotationIndex, annotation)) {
+                throw new IllegalArgumentException("Update Failed");
+            }
+            return true;
         }
     }
 
@@ -648,15 +696,26 @@ public class PdfProcessor {
      * objects present on the page, even if the page contains
      * other page object types.
      *
-     * @return list of page objects present on the page
+     * @return A {@link List} of {@link Pair} objects, where each pair contains:
+     * - An {@link Integer} representing the object ID.
+     * - A {@link PdfPageObject} representing the page object.
      * @throws IllegalStateException if the {@link PdfRenderer.Page} is
      *                               closed before invocation
      */
     @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-    public List<PdfPageObject> getPageObjects(int pageNum) {
+    public List<Pair<Integer, PdfPageObject>> getPageObjects(int pageNum) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.getPageObjects(pageNum);
+            PdfPageComponentsIdManager pageObjectIdManager = mPageObjectIdManagerMap.get(pageNum);
+            List<PdfPageObject> pageObjects = mPdfDocument.getPageObjects(pageNum);
+            List<Pair<Integer, PdfPageObject>> pageObjectIdPairs = new ArrayList<>();
+            for (int i = 0; i < pageObjects.size(); i++) {
+                if (pageObjects.get(i) != null) {
+                    pageObjectIdPairs.add(
+                            new Pair<>(pageObjectIdManager.getIdForIndex(i), pageObjects.get(i)));
+                }
+            }
+            return pageObjectIdPairs;
         }
     }
 
@@ -673,25 +732,37 @@ public class PdfProcessor {
     public int addPageObject(int pageNum, @NonNull PdfPageObject pageObject) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.addPageObject(pageNum, pageObject);
+            int addedObjectIndex = mPdfDocument.addPageObject(pageNum, pageObject);
+            if (addedObjectIndex == -1) {
+                throw new IllegalArgumentException("Failed to add PageObject");
+            }
+            return mPageObjectIdManagerMap.get(pageNum).getIdForIndex(addedObjectIndex);
         }
     }
 
     /**
      * Update the given {@link PdfPageObject} to the page.
      *
-     * @param pageObject the {@link PdfPageObject} object to
-     *                   add
-     * @return true if page object is updated, false otherwise
+     * @param objectId   The unique identifier of the page object to update.
+     * @param pageObject the {@link PdfPageObject} object to add.
+     * @return true if page object is updated, false otherwise.
      * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
      * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
      */
     @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-    public boolean updatePageObject(int pageNum,
+    public boolean updatePageObject(int pageNum, int objectId,
             @NonNull PdfPageObject pageObject) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.updatePageObject(pageNum, pageObject);
+            int objectIndex = mPageObjectIdManagerMap.get(pageNum).getIndexForId(objectId);
+            if (objectIndex == -1) {
+                throw new IllegalArgumentException("Unknown objectId. "
+                        + "getPageObjects() call never made?");
+            }
+            if (!mPdfDocument.updatePageObject(pageNum, objectIndex, pageObject)) {
+                throw new IllegalArgumentException("Update Failed");
+            }
+            return true;
         }
     }
 
@@ -700,15 +771,24 @@ public class PdfProcessor {
      *
      * @param objectId the id of the page object to remove
      *                 from the page
-     * @return {@link PdfPageObject} that is removed.
      * @throws IllegalStateException if the provided
      *                               objectId doesn't exist.
      */
     @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-    public PdfPageObject removePageObject(int pageNum, int objectId) {
+    public void removePageObject(int pageNum, int objectId) {
         synchronized (sPdfiumLock) {
             assertPdfDocumentNotNull();
-            return mPdfDocument.removePageObject(pageNum, objectId);
+            PdfPageComponentsIdManager pageObjectIdManager =
+                    mPageObjectIdManagerMap.get(pageNum);
+            int objectIndex = pageObjectIdManager.getIndexForId(objectId);
+            if (objectIndex == -1) {
+                throw new IllegalArgumentException("Unknown objectId. getPageObjects() "
+                        + "call never made ?");
+            }
+            if (!mPdfDocument.removePageObject(pageNum, objectIndex)) {
+                throw new IllegalArgumentException("Page object cannot be removed.");
+            }
+            pageObjectIdManager.deleteId(objectId);
         }
     }
 
diff --git a/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java b/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java
index 104061a36..2ab35f1f3 100644
--- a/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java
+++ b/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java
@@ -43,6 +43,7 @@ import android.graphics.pdf.models.selection.PageSelection;
 import android.graphics.pdf.models.selection.SelectionBoundary;
 import android.graphics.pdf.utils.Preconditions;
 import android.os.ParcelFileDescriptor;
+import android.util.Pair;
 
 import androidx.annotation.RestrictTo;
 
@@ -613,51 +614,53 @@ public final class PdfRendererPreV implements AutoCloseable {
         }
 
         /**
-         * Return list of supported {@link PdfAnnotation} present on the
-         * page. See {@link PdfAnnotationType} for the supported types
+         * Returns a list of pairs, where each pair consists of a supported {@link PdfAnnotation}
+         * and its corresponding ID on the specified page. ID of the annotation will be required for
+         * {@link #updatePageAnnotation(int, PdfAnnotation)} and {@link #removePageAnnotation(int)}
+         * and will remain same without mutate operations.
+         *
          * <p>
-         * The list will be empty if there are no supported
-         * annotations present on the page, even if the page
-         * contains other annotation types.
+         * The returned list will be empty if no supported annotations are present on the page,
+         * even if the page contains other annotation types. Refer to {@link PdfAnnotationType} for
+         * the supported annotation types.
          *
-         * @return list of supported annotations present on the page
-         * @throws IllegalStateException if {@link PdfRendererPreV} or
-         *         {@link PdfRendererPreV.Page} is closed before invocation.
+         * @return A list of pairs representing the supported annotations and their ids on the page.
+         * @throws IllegalStateException    if {@link PdfRendererPreV} or
+         *                                  {@link PdfRendererPreV.Page} is closed before
+         *                                  invocation.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
         @NonNull
-        public List<PdfAnnotation> getPageAnnotations() {
+        public List<Pair<Integer, PdfAnnotation>> getPageAnnotations() {
             throwIfDocumentOrPageClosed();
             return mPdfProcessor.getPageAnnotations(mIndex);
         }
 
         /**
-         * Adds the given annotation to the page. The annotation should be of
-         * supported type. See {@link PdfAnnotationType} for the supported types
-         *
-         * @param annotation the {@link PdfAnnotation} object to
-         *        add
-         * @return id of the added annotation,
-         *         or -1 if the annotation cannot be added. The
-         *         id is guaranteed to be non-negative if
-         *         the annotation is added successfully.
-         * @throws IllegalArgumentException if the provided
-         *         {@code annotation} is null or of unsupported type i.e.-
-         *         {@link PdfAnnotationType#UNKNOWN} or if the annotation is already
-         *          added in this page or some other page of the document.
-         *
-         * @throws IllegalStateException if {@link PdfRendererPreV} or
-         *         {@link PdfRendererPreV.Page} is closed before invocation.
+         * Adds the given annotation to the page. The annotation should be of supported type.
+         * See {@link PdfAnnotationType} for the supported types
+         *
+         * <p>
+         * {@link PdfRendererPreV#write} needs to be called to get the updated PDF stream
+         * after calling this method. {@link PdfRendererPreV.Page} instance can be closed before
+         * calling {@link PdfRendererPreV#write}.
+         *
+         * @param annotation the {@link PdfAnnotation} object to add
+         * @return id of the added annotation, or -1 if the annotation cannot be added. The id is
+         *         guaranteed to be non-negative if the annotation is added successfully.
+         * @throws IllegalArgumentException if the provided annotation is null or of unsupported
+         *                                  type i.e. {@link PdfAnnotationType#UNKNOWN}
+         * @throws IllegalStateException    if {@link PdfRendererPreV} or
+         *                                  {@link PdfRendererPreV.Page} is closed before invocation
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        @IntRange(from = -1)
         public int addPageAnnotation(@NonNull PdfAnnotation annotation) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkNotNull(annotation, "Annotation should not be null");
             Preconditions.checkArgument(
                     annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
                     "Annotation should be of valid type");
-            Preconditions.checkArgument(annotation.getId() != -1,
-                    "Annotation already added");
             return mPdfProcessor.addPageAnnotation(mIndex, annotation);
 
         }
@@ -665,86 +668,90 @@ public final class PdfRendererPreV implements AutoCloseable {
         /**
          * Removes the annotation with the specified id.
          *
-         * @param annotationId id of the annotation to remove from the page
-         * @return the removed annotation
+         * <p>
+         * {@link PdfRendererPreV#write} needs to be called to get the updated PDF stream after
+         * calling this method. {@link PdfRendererPreV.Page} instance can be closed before calling
+         * {@link PdfRendererPreV#write}.
          *
+         * @param annotationId id of the annotation to remove from the page
          * @throws IllegalArgumentException if annotationId ie negative
-         *
-         * @throws IllegalStateException if {@link PdfRendererPreV} or
-         *        {@link PdfRendererPreV.Page} is closed before invocation or if
-         *        annotation is failed to get removed from the page.
+         * @throws IllegalStateException    if {@link PdfRendererPreV} or
+         *                                  {@link PdfRendererPreV.Page} is closed before invocation
+         *                                  or if annotation is failed to get removed from the page.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
-        @NonNull
-        public PdfAnnotation removePageAnnotation(int annotationId) {
+        public void removePageAnnotation(@IntRange(from = 0) int annotationId) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkArgument(annotationId >= 0,
                     "Annotation id should be non-negative");
-            PdfAnnotation removedAnnotation = mPdfProcessor.removePageAnnotation(mIndex,
-                    annotationId);
-            if (removedAnnotation == null) {
-                throw new IllegalStateException(
-                        "Failed to remove annotation with id " + annotationId);
-            }
-            return removedAnnotation;
+            mPdfProcessor.removePageAnnotation(mIndex, annotationId);
         }
 
-
         /**
          * Update the given {@link PdfAnnotation} to the page.
          *
-         * @param annotation the annotation to update
+         * <p>
+         * {@link PdfRendererPreV#write} needs to be called to get the updated PDF stream after
+         * calling this method. {@link PdfRendererPreV.Page} instance can be closed before calling
+         * {@link PdfRendererPreV#write}.
          *
+         * @param annotationId id corresponding to which the annotation is to be updated
+         * @param annotation the annotation to update
          * @return true if annotation is updated, false otherwise
-         *
-         * @throws IllegalArgumentException f the provided annotation is null or of
-         *         unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
-         *
-         * @throws IllegalStateException if {@link PdfRendererPreV} or
-         *         {@link PdfRendererPreV.Page}  is closed before invocation
+         * @throws IllegalArgumentException if the provided annotation is null or of
+         *                                  unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
+         *                                  or if the provided annotationId is negative
+         * @throws IllegalStateException    if {@link PdfRendererPreV} or
+         *                                  {@link PdfRendererPreV.Page}  is closed before
+         *                                  invocation
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
-        public boolean updatePageAnnotation(@NonNull PdfAnnotation annotation) {
+        public boolean updatePageAnnotation(@IntRange(from = 0) int annotationId,
+                @NonNull PdfAnnotation annotation) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkNotNull(annotation, "PdfAnnotation should not be null");
             Preconditions.checkArgument(
                     annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
                     "Annotation should be of valid type");
-
-            Preconditions.checkArgument(annotation.getId() >= 0,
-                    "Annotation id should be greater than equal to 0");
-            return mPdfProcessor.updatePageAnnotation(mIndex, annotation);
+            Preconditions.checkArgument(annotationId >= 0,
+                    "Annotation Id should be non-negative");
+            return mPdfProcessor.updatePageAnnotation(mIndex, annotationId, annotation);
         }
 
         /**
-         * Return list of supported {@link PdfPageObject} present on
-         * the page.
+         * Returns {@link List} of {@link Pair} objects, where each pair contains:
+         * - An {@link Integer} representing the object ID, which is required for
+         * {@link #updatePageObject(int, PdfPageObject)} and {@link #removePageObject(int)}.
+         * Object ID will remain same without mutate operations.
+         * - A {@link PdfPageObject} representing the page object.
+         * <p>
          * The list will be empty if there are no supported page
          * objects present on the page, even if the page contains
          * other page object types.
          *
-         * @return list of page objects present on the page
-         *
-         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
-         *                                  invocation.
+         * @return {@link List} of {@link Pair} objects containing {@link Integer} and
+         * {@link PdfPageObject}.
+         * @throws IllegalStateException if the {@link PdfRenderer.Page} is closed before
+         *                               invocation.
          */
         @android.annotation.NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-        public List<PdfPageObject> getPageObjects() {
+        public List<Pair<Integer, PdfPageObject>> getPageObjects() {
             throwIfDocumentOrPageClosed();
             return mPdfProcessor.getPageObjects(mIndex);
         }
 
         /**
          * Adds the given {@link PdfPageObject} to the page.
-         *
-         * @param pageObject the {@code PdfPageObject} object to
-         *                   add, existing page object cannot be used (i.e. it should not have
-         *                   objectId).
-         * @return object id of added page object, -1 otherwise
-         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown, null
-         *                                  or if the object is already added to a page or an
-         *                                  annotation.
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
+         *
+         * @param pageObject the {@code PdfPageObject} object to add.
+         * @return id of the added page object, or -1 if the page object cannot be added. The
+         * id is guaranteed to be non-negative if the page object is added successfully.
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null
          * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
          *                                  invocation.
          */
@@ -755,57 +762,59 @@ public final class PdfRendererPreV implements AutoCloseable {
             Preconditions.checkArgument(
                     pageObject.getPdfObjectType() != PdfPageObjectType.UNKNOWN,
                     "PageObject should be of valid type.");
-            Preconditions.checkArgument(pageObject.getObjectId() == -1,
-                    "PageObject should not have an object id.");
-            Preconditions.checkArgument(!pageObject.isAddedInAnnotation(),
-                    "PageObject already added to an annotation");
             return mPdfProcessor.addPageObject(mIndex, pageObject);
         }
 
         /**
          * Update the given {@link PdfPageObject} to the page.
+         * <p>
+         * Note: This method only updates the parameters of the PageObject whose setters
+         * are available. Attempting to update fields with no corresponding setters will
+         * have no effect.
+         *
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
-         * @param pageObject the {@code PdfPageObject} object to
-         *                   add.
+         * @param objectId   The unique identifier of the page object to update.
+         * @param pageObject The {@code PdfPageObject} object to update.
          * @return true if page object is updated, false otherwise.
-         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unsupported or
          *                                  null.
          * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
          *                                  invocation.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-        public boolean updatePageObject(@NonNull PdfPageObject pageObject) {
+        public boolean updatePageObject(@IntRange(from = 0) int objectId,
+                @NonNull PdfPageObject pageObject) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkNotNull(pageObject, "PdfPageObject should not be null");
             Preconditions.checkArgument(
                     pageObject.getPdfObjectType() != PdfPageObjectType.UNKNOWN,
                     "PageObject should be of valid type");
-            Preconditions.checkArgument(pageObject.getObjectId() >= 0,
+            Preconditions.checkArgument(objectId >= 0,
                     "Page object id should be greater than equal to 0.");
-            return mPdfProcessor.updatePageObject(mIndex, pageObject);
+            return mPdfProcessor.updatePageObject(mIndex, objectId, pageObject);
         }
 
         /**
          * Removes the {@link PdfPageObject} with the specified ID.
+         * <p>
+         * {@link PdfRenderer#write} needs to be called to get the updated PDF stream after calling
+         * this method. {@link PdfRenderer.Page} instance can be closed before calling
+         * {@link PdfRenderer#write}.
          *
-         * @param objectId the id of the page object to remove
-         *                 from the page.
-         * @return {@link PdfPageObject} that is removed.
-         * @throws IllegalArgumentException if the provided
-         *                                  objectId doesn't exist.
+         * @param objectId the id of the page object to remove from the page.
+         * @throws IllegalArgumentException if the provided objectId doesn't exist.
          * @throws IllegalStateException    if the page object cannot be removed.
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
-        @NonNull
-        public PdfPageObject removePageObject(int objectId) {
+        public void removePageObject(@IntRange(from = 0) int objectId) {
             throwIfDocumentOrPageClosed();
             Preconditions.checkArgument(objectId >= 0,
                     "Page object id should be greater than equal to 0.");
-            PdfPageObject pageObject = mPdfProcessor.removePageObject(mIndex, objectId);
-            if (pageObject == null) {
-                throw new IllegalStateException("Page object cannot be removed.");
-            }
-            return pageObject;
+            mPdfProcessor.removePageObject(mIndex, objectId);
         }
 
         /**
diff --git a/pdf/framework/java/android/graphics/pdf/RenderParams.java b/pdf/framework/java/android/graphics/pdf/RenderParams.java
index 1489dd30d..afffda19a 100644
--- a/pdf/framework/java/android/graphics/pdf/RenderParams.java
+++ b/pdf/framework/java/android/graphics/pdf/RenderParams.java
@@ -55,12 +55,26 @@ public final class RenderParams {
      * @see RenderParams.Builder#setRenderFlags(int)
      */
     public static final int FLAG_RENDER_HIGHLIGHT_ANNOTATIONS = 1 << 2;
-    // LINT.ThenChange(packages/providers/MediaProvider/pdf/framework/libs/pdfClient/page.h)
 
-    private static final int RENDER_FLAGS_MASK =
-            FLAG_RENDER_TEXT_ANNOTATIONS | FLAG_RENDER_HIGHLIGHT_ANNOTATIONS;
-    private final int mRenderMode;
+    /**
+     * Flag to enable rendering of stamp annotation on the page.
+     *
+     * @see RenderParams#getRenderFlags()
+     * @see RenderParams.Builder#setRenderFlags(int)
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_STAMP_ANNOTATIONS)
+    public static final int FLAG_RENDER_STAMP_ANNOTATIONS = 1 << 3;
 
+    /**
+     * Flag to enable rendering of freetext annotation on the page.
+     *
+     * @see RenderParams#getRenderFlags()
+     * @see RenderParams.Builder#setRenderFlags(int)
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_ANNOTATIONS)
+    public static final int FLAG_RENDER_FREETEXT_ANNOTATIONS = 1 << 4;
+    // LINT.ThenChange(packages/providers/MediaProvider/pdf/framework/libs/pdfClient/page.h)
+    private final int mRenderMode;
     private final int mRenderFlags;
 
     private RenderParams(int renderMode, int renderFlags) {
@@ -68,6 +82,18 @@ public final class RenderParams {
         this.mRenderFlags = renderFlags;
     }
 
+    private static int getRenderMask() {
+
+        int renderMask = FLAG_RENDER_TEXT_ANNOTATIONS | FLAG_RENDER_HIGHLIGHT_ANNOTATIONS;
+        if (android.graphics.pdf.flags.readonly.Flags.enableEditPdfTextAnnotations()) {
+            renderMask |= FLAG_RENDER_FREETEXT_ANNOTATIONS;
+        }
+        if (android.graphics.pdf.flags.readonly.Flags.enableEditPdfStampAnnotations()) {
+            renderMask |= FLAG_RENDER_STAMP_ANNOTATIONS;
+        }
+        return renderMask;
+    }
+
     /**
      * Returns the render mode.
      */
@@ -86,7 +112,7 @@ public final class RenderParams {
 
     /** @hide */
     public int getRenderAnnotations() {
-        return mRenderFlags & RENDER_FLAGS_MASK;
+        return mRenderFlags & getRenderMask();
     }
 
     /** @hide */
@@ -101,7 +127,9 @@ public final class RenderParams {
     /** @hide */
     @IntDef(flag = true, prefix = {"FLAG_"}, value = {
             FLAG_RENDER_TEXT_ANNOTATIONS,
-            FLAG_RENDER_HIGHLIGHT_ANNOTATIONS
+            FLAG_RENDER_HIGHLIGHT_ANNOTATIONS,
+            FLAG_RENDER_STAMP_ANNOTATIONS,
+            FLAG_RENDER_FREETEXT_ANNOTATIONS
     })
     @Retention(RetentionPolicy.SOURCE)
     public @interface RenderFlags {
@@ -137,7 +165,7 @@ public final class RenderParams {
          */
         @NonNull
         public Builder setRenderFlags(@RenderFlags int renderFlags) {
-            setRenderFlags(renderFlags, RENDER_FLAGS_MASK);
+            setRenderFlags(renderFlags, getRenderMask());
             return this;
         }
 
@@ -170,7 +198,7 @@ public final class RenderParams {
         @NonNull
         public Builder setRenderFlags(@RenderFlags int renderFlags, @RenderFlags int mask) {
             // Sanitize the mask
-            mask &= RENDER_FLAGS_MASK;
+            mask &= getRenderMask();
 
             // Mask the flags
             renderFlags &= mask;
diff --git a/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java
index 32d0762f6..303dd3ff0 100644
--- a/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java
+++ b/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java
@@ -22,6 +22,7 @@ import android.annotation.NonNull;
 import android.graphics.Color;
 import android.graphics.RectF;
 import android.graphics.pdf.flags.Flags;
+import android.graphics.pdf.utils.Preconditions;
 
 /**
  * Represents a free text annotation in a PDF document.
@@ -38,6 +39,7 @@ import android.graphics.pdf.flags.Flags;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_ANNOTATIONS)
 public final class FreeTextAnnotation extends PdfAnnotation {
+    @NonNull private RectF mBounds;
     @NonNull private String mTextContent;
     private @ColorInt int mTextColor;
     private @ColorInt int mBackgroundColor;
@@ -51,12 +53,33 @@ public final class FreeTextAnnotation extends PdfAnnotation {
      * @param textContent The text content of the annotation
      */
     public FreeTextAnnotation(@NonNull RectF bounds, @NonNull String textContent) {
-        super(PdfAnnotationType.FREETEXT, bounds);
+        super(PdfAnnotationType.FREETEXT);
+        this.mBounds = bounds;
         this.mTextContent = textContent;
         this.mTextColor = Color.BLACK;
         this.mBackgroundColor = Color.WHITE;
     }
 
+    /**
+     * Sets the bounding rectangle of the freetext annotation.
+     *
+     * @param bounds The new bounding rectangle.
+     * @throws NullPointerException if given bounds is null
+     */
+    public void setBounds(@NonNull RectF bounds) {
+        Preconditions.checkNotNull(bounds, "Bounds should not be null");
+        this.mBounds = bounds;
+    }
+
+    /**
+     * Returns the bounding rectangle of the freetext annotation.
+     *
+     * @return The bounding rectangle.
+     */
+    @NonNull public RectF getBounds() {
+        return mBounds;
+    }
+
     /**
      * Sets the text content of the annotation.
      *
diff --git a/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java
index d3f5d27af..0f2661735 100644
--- a/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java
+++ b/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java
@@ -22,6 +22,9 @@ import android.annotation.NonNull;
 import android.graphics.Color;
 import android.graphics.RectF;
 import android.graphics.pdf.flags.Flags;
+import android.graphics.pdf.utils.Preconditions;
+
+import java.util.List;
 
 /**
  * Represents a highlight annotation in a PDF document.
@@ -31,6 +34,7 @@ import android.graphics.pdf.flags.Flags;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
 public final class HighlightAnnotation extends PdfAnnotation {
+    @NonNull private List<RectF> mBounds;
     private @ColorInt int mColor;
 
     /**
@@ -40,11 +44,35 @@ public final class HighlightAnnotation extends PdfAnnotation {
      *
      * @param bounds The bounding rectangle of the annotation.
      */
-    public HighlightAnnotation(@NonNull RectF bounds) {
-        super(PdfAnnotationType.HIGHLIGHT, bounds);
+    public HighlightAnnotation(@NonNull List<RectF> bounds) {
+        super(PdfAnnotationType.HIGHLIGHT);
+        this.mBounds = bounds;
         this.mColor = Color.YELLOW;
     }
 
+    /**
+     * Sets the bounding rectangles of the highlight annotation. Each rect in the list mBounds
+     * represent an absolute position of highlight inside the page of the document
+     *
+     * @param bounds The new bounding rectangles.
+     * @throws NullPointerException if given bounds is null
+     * @throws IllegalArgumentException if the given bounds list is empty
+     */
+    public void setBounds(@NonNull List<RectF> bounds) {
+        Preconditions.checkNotNull(bounds, "Bounds should not be null");
+        Preconditions.checkArgument(!bounds.isEmpty(), "Bounds should not be empty");
+        this.mBounds = bounds;
+    }
+
+    /**
+     * Returns the bounding rectangles of the highlight annotation.
+     *
+     * @return The bounding rectangles.
+     */
+    @NonNull public List<RectF> getBounds() {
+        return mBounds;
+    }
+
     /**
      * Returns the highlight color of the annotation.
      *
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java
index 73a4d437d..fb4772218 100644
--- a/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java
@@ -17,8 +17,6 @@
 package android.graphics.pdf.component;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.graphics.RectF;
 import android.graphics.pdf.flags.Flags;
 import android.graphics.pdf.utils.Preconditions;
 
@@ -30,54 +28,19 @@ import android.graphics.pdf.utils.Preconditions;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
 public abstract class PdfAnnotation {
-    private int mId;
-    private int mType;
-    @NonNull  private RectF mBounds;
+    private final int mType;
 
     /**
      * Creates a new PDF annotation with the specified type and bounds.
      *
-     * @param type   The type of annotation. See {@link PdfAnnotationType} for possible values.
-     * @param bounds The bounding rectangle of the annotation.
+     * @param type The type of annotation. See {@link PdfAnnotationType} for possible values.
      */
-    PdfAnnotation(@PdfAnnotationType.Type int type, @NonNull RectF bounds) {
-        Preconditions.checkNotNull(bounds, "Bounds cannot be null");
+    PdfAnnotation(@PdfAnnotationType.Type int type) {
         Preconditions.checkArgument(type == PdfAnnotationType.UNKNOWN
                 || type == PdfAnnotationType.FREETEXT
                 || type == PdfAnnotationType.HIGHLIGHT
                 || type == PdfAnnotationType.STAMP, "Invalid Annotation Type");
-
-        this.mId = -1;
         this.mType = type;
-        this.mBounds = bounds;
-    }
-
-    /**
-     * Returns the id of the annotation.
-     * <p>
-     * Id of an annotation will be unique in a page.
-     *
-     * @return The annotation ID.
-     */
-    public int getId() {
-        return mId;
-    }
-
-    /**
-     * Sets the id of the annotation.
-     * <p>
-     * When the annotation is created, it's assigned default id as -1, when it will
-     * added to a page using
-     * {@link  android.graphics.pdf.PdfRenderer.Page#addPageAnnotation(PdfAnnotation)}
-     * or {@link android.graphics.pdf.PdfRendererPreV.Page#addPageAnnotation(PdfAnnotation)},
-     * it will get assigned a unique id in the page.
-     * </p>
-     *
-     * @param id to be assigned to the annotation
-     * @hide
-     */
-    protected void setId(int id) {
-        mId = id;
     }
 
     /**
@@ -88,23 +51,4 @@ public abstract class PdfAnnotation {
     public @PdfAnnotationType.Type int getPdfAnnotationType() {
         return mType;
     }
-
-    /**
-     * Sets the bounding rectangle of the annotation.
-     *
-     * @param bounds The new bounding rectangle.
-     */
-    public void setBounds(@NonNull RectF bounds) {
-        this.mBounds = bounds;
-    }
-
-    /**
-     * Returns the bounding rectangle of the annotation.
-     *
-     * @return The bounding rectangle.
-     */
-    @NonNull public RectF getBounds() {
-        return mBounds;
-    }
-
 }
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java
index 7a2fc6431..890402e50 100644
--- a/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java
@@ -19,7 +19,6 @@ package android.graphics.pdf.component;
 import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.graphics.Matrix;
-import android.graphics.RectF;
 import android.graphics.pdf.flags.Flags;
 
 /**
@@ -32,17 +31,9 @@ public abstract class PdfPageObject {
     // Possible Values are {@link PdfPageObjectType}
     private final int mType;
 
-    // Id of page object
-    private int mObjectId;
-
-    // Bound of page object
-    private RectF mBounds;
-
     // Transformation matrix of page object
     private Matrix mTransform;
 
-    private boolean mIsAddedInAnnotation;
-
     /**
      * Constructor for the PageObject.
      *
@@ -51,8 +42,6 @@ public abstract class PdfPageObject {
     PdfPageObject(int type) {
         this.mType = type;
         this.mTransform = new Matrix(); // Initialize with identity matrix
-        this.mObjectId = -1; // Initialize with -1
-        this.mIsAddedInAnnotation = false;
     }
 
     /**
@@ -64,44 +53,6 @@ public abstract class PdfPageObject {
         return mType;
     }
 
-    /**
-     * Returns the ID of the object.
-     *
-     * @return The ID of the object.
-     */
-    public int getObjectId() {
-        return mObjectId;
-    }
-
-    /**
-     * Sets the objectIndex of the object.
-     *
-     * @param objectId The objectIndex of the object.
-     * @hide
-     */
-    protected void setObjectId(int objectId) {
-        this.mObjectId = objectId;
-    }
-
-    /**
-     * Returns the bounding rectangle of the object.
-     *
-     * @return The bounding rectangle of the object.
-     */
-    @NonNull
-    public RectF getBounds() {
-        return mBounds;
-    }
-
-    /**
-     * Sets the bounding rectangle of the object.
-     *
-     * @param bounds The bounding rectangle of the object.
-     */
-    public void setBounds(@NonNull RectF bounds) {
-        this.mBounds = bounds;
-    }
-
     /**
      * Transform the page object
      * The matrix is composed as:
@@ -113,13 +64,6 @@ public abstract class PdfPageObject {
         Matrix matrix = new Matrix();
         matrix.setValues(new float[]{a, e, d, c, b, f, 0, 0, 1}); // Set the matrix values
         this.mTransform.postConcat(matrix); // Apply the transformation
-
-        // Update the objectRect based on the new transformation
-        if (this.mBounds != null) {
-            RectF newRect = new RectF(this.mBounds);
-            matrix.mapRect(newRect);
-            this.mBounds.set(newRect);
-        }
     }
 
     /**
@@ -142,19 +86,4 @@ public abstract class PdfPageObject {
     public void setMatrix(@NonNull Matrix matrix) {
         this.mTransform = matrix;
     }
-
-    /*
-     * Returns {@code true} if the page object is added to an annotation, else false
-     */
-    public boolean isAddedInAnnotation() {
-        return mIsAddedInAnnotation;
-    }
-
-    /*
-    * Sets that this page object is added to an annotation
-    * @hide
-    */
-    void setAddedInAnnotation() {
-        mIsAddedInAnnotation = true;
-    }
 }
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageObjectRenderMode.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageObjectRenderMode.java
new file mode 100644
index 000000000..c8603bb85
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageObjectRenderMode.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.graphics.pdf.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Defines rendering modes for PDF page objects (fill, stroke, etc.).
+ *
+ * <p>
+ * This final class provides constants for specifying how graphical elements
+ * are rendered on a PDF page. It cannot be instantiated.
+ *
+ * <p>
+ * Rendering modes:
+ * <ul>
+ * <li>{@link #UNKNOWN}: Unknown mode.
+ * <li>{@link #FILL}: Fill object.
+ * <li>{@link #STROKE}: Stroke object.
+ * <li>{@link #FILL_STROKE}: Fill and stroke object. </ul>
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+public final class PdfPageObjectRenderMode {
+    // Private constructor
+    private PdfPageObjectRenderMode() {
+    }
+
+    /**
+     * Unknown Mode
+     */
+    public static final int UNKNOWN = -1;
+
+    /**
+     * Fill Mode
+     */
+    public static final int FILL = 0;
+
+    /**
+     * Stroke Mode
+     */
+    public static final int STROKE = 1;
+
+    /**
+     * FillStroke Mode
+     */
+    public static final int FILL_STROKE = 2;
+
+    /** @hide */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({UNKNOWN, FILL, STROKE, FILL_STROKE})
+    public @interface Type {
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java
index e3d5d8020..d19c37ae9 100644
--- a/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java
@@ -16,74 +16,48 @@
 
 package android.graphics.pdf.component;
 
+import android.annotation.ColorInt;
 import android.annotation.FlaggedApi;
-import android.annotation.IntDef;
 import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.graphics.Color;
-import android.graphics.DashPathEffect;
-import android.graphics.Matrix;
 import android.graphics.Path;
-import android.graphics.PathEffect;
-import android.graphics.RectF;
 import android.graphics.pdf.flags.Flags;
 
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
 /**
  * Represents a path object on a PDF page. This class extends
  * {@link PdfPageObject} and provides methods to access and modify the
- * path's content, such as its shape, fill color, stroke color, line width,
- * and line style.
+ * path's content, such as its shape, fill color, stroke color and line width.
  */
 @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
 public final class PdfPagePathObject extends PdfPageObject {
-    private Path mPath;
-    private PathEffect mLineStyle;
-    private Color mStrokeColor;
+    private final Path mPath;
+    private @ColorInt int mStrokeColor;
     private float mStrokeWidth;
-    private Color mFillColor;
+    private @ColorInt int mFillColor;
+    private @PdfPageObjectRenderMode.Type int mRenderMode;
 
     /**
      * Constructor for the PdfPagePathObject. Sets the object type
      * to {@link PdfPageObjectType#PATH}.
      */
-    public PdfPagePathObject() {
+    public PdfPagePathObject(@NonNull Path path) {
         super(PdfPageObjectType.PATH);
-        this.mPath = new Path();
-        this.mStrokeColor = new Color(); // Default is opaque black in the sRGB color space.
-        this.mStrokeWidth = 1.0f;
+        this.mPath = path;
+        this.mRenderMode = PdfPageObjectRenderMode.FILL;
     }
 
     /**
      * Returns the path of the object.
+     * The returned path object might be an approximation of the one used to
+     * create the original one if the original object has elements with curvature.
+     * <p>
+     * Note: The path is immutable because the underlying library does
+     * not allow modifying the path once it is created.
      *
      * @return The path.
      */
     @NonNull
-    public Path getPath() {
-        return mPath;
-    }
-
-    /**
-     * Sets the path of the object.
-     *
-     * @param path The path to set.
-     */
-    public void setPath(@NonNull Path path) {
-        this.mPath = path;
-    }
-
-    /**
-     * Returns the line style of the object's stroke.
-     *
-     * @return The {@link PathEffect} representing the line style, or null if no
-     * style is set.
-     */
-    @Nullable
-    public PathEffect getLineStyle() {
-        return mLineStyle;
+    public Path toPath() {
+        return new Path(mPath);
     }
 
     /**
@@ -91,8 +65,7 @@ public final class PdfPagePathObject extends PdfPageObject {
      *
      * @return The stroke color of the object.
      */
-    @NonNull
-    public Color getStrokeColor() {
+    public @ColorInt int getStrokeColor() {
         return mStrokeColor;
     }
 
@@ -101,7 +74,7 @@ public final class PdfPagePathObject extends PdfPageObject {
      *
      * @param strokeColor The stroke color of the object.
      */
-    public void setStrokeColor(@NonNull Color strokeColor) {
+    public void setStrokeColor(@ColorInt int strokeColor) {
         this.mStrokeColor = strokeColor;
     }
 
@@ -123,32 +96,12 @@ public final class PdfPagePathObject extends PdfPageObject {
         this.mStrokeWidth = strokeWidth;
     }
 
-    /**
-     * Sets the line style of the object's stroke.
-     *
-     * @param lineStyle An integer representing the line style to set.
-     */
-    public void setLineStyle(int lineStyle) {
-        switch (lineStyle) {
-            case LineStyle.DASHED: // Example: Dashed line
-                this.mLineStyle = new DashPathEffect(new float[]{10, 5}, 0);
-                break;
-            case LineStyle.DOTTED: // Example: Dotted line
-                this.mLineStyle = new DashPathEffect(new float[]{2, 2}, 0);
-                break;
-            default: // Solid line (no effect)
-                this.mLineStyle = null;
-                break;
-        }
-    }
-
     /**
      * Returns the fill color of the object.
      *
      * @return The fill color of the object.
      */
-    @Nullable
-    public Color getFillColor() {
+    public @ColorInt int getFillColor() {
         return mFillColor;
     }
 
@@ -157,46 +110,27 @@ public final class PdfPagePathObject extends PdfPageObject {
      *
      * @param fillColor The fill color of the object.
      */
-    public void setFillColor(@Nullable Color fillColor) {
+    public void setFillColor(@ColorInt int fillColor) {
         this.mFillColor = fillColor;
     }
 
     /**
-     * Overrides the
-     * {@link PdfPageObject#transform(float, float, float, float, float, float)}
-     * method to correctly transform the Path object.
-     *
-     * This method applies the given affine transformation matrix to the path and
-     * also updates the object's bounding rectangle.
+     * Returns the {@link PdfPageObjectRenderMode} of the object.
+     * Returns {@link PdfPageObjectRenderMode#FILL} by default
+     * if {@link PdfPagePathObject#mRenderMode} is not set.
      *
-     * @param a The a value of the transformation matrix.
-     * @param b The b value of the transformation matrix.
-     * @param c The c value of the transformation matrix.
-     * @param d The d value of the transformation matrix.
-     * @param e The e value of the transformation matrix.
-     * @param f The f value of the transformation matrix.
+     * @return The {@link PdfPageObjectRenderMode} of the object.
      */
-    @Override
-    public void transform(float a, float b, float c, float d, float e, float f) {
-        Matrix matrix = new Matrix();
-        matrix.setValues(new float[]{a, c, e, b, d, f, 0, 0, 1});
-        this.mPath.transform(matrix);
-
-        // Also transform the objectRect
-        RectF newRect = new RectF(this.getBounds());
-        matrix.mapRect(newRect);
-        this.getBounds().set(newRect);
+    public @PdfPageObjectRenderMode.Type int getRenderMode() {
+        return mRenderMode;
     }
 
-    /** @hide */
-    @IntDef({LineStyle.SOLID, LineStyle.DASHED, LineStyle.DOTTED})
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface LineStyle {
-        /** Solid line (no effect). */
-        int SOLID = 0;
-        /** Dashed line. */
-        int DASHED = 1;
-        /** Dotted line. */
-        int DOTTED = 2;
+    /**
+     * Sets the {@link PdfPageObjectRenderMode} of the object.
+     *
+     * @param renderMode The {@link PdfPageObjectRenderMode} to be set.
+     */
+    public void setRenderMode(@PdfPageObjectRenderMode.Type int renderMode) {
+        mRenderMode = renderMode;
     }
 }
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java
index c004af2a6..17662308e 100644
--- a/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java
@@ -16,39 +16,41 @@
 
 package android.graphics.pdf.component;
 
+import android.annotation.ColorInt;
 import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.graphics.Color;
-import android.graphics.Typeface;
 import android.graphics.pdf.flags.Flags;
 
 /**
  * Represents a text object on a PDF page.
  * This class extends PageObject and provides methods to access and modify the text content.
  */
-@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_OBJECTS)
 public final class PdfPageTextObject extends PdfPageObject {
     private String mText;
-    private Typeface mTypeface;
-    private float mFontSize;
-    private Color mStrokeColor = new Color(); // Default is opaque black in the sRGB color space.
+    private final PdfPageTextObjectFont mFont;
+    private final float mFontSize;
+    private @ColorInt int mStrokeColor;
     private float mStrokeWidth = 1.0f;
-    private Color mFillColor;
+    private @ColorInt int mFillColor;
+    private @PdfPageObjectRenderMode.Type int mRenderMode;
 
     /**
      * Constructor for the PdfPageTextObject.
      * Sets the object type to TEXT and initializes the text color to black.
      *
-     * @param typeface The font of the text.
+     * @param font The font of the text.
      * @param fontSize The font size of the text.
      */
-    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_OBJECTS)
-    public PdfPageTextObject(@NonNull String text, @NonNull Typeface typeface, float fontSize) {
+    public PdfPageTextObject(@NonNull String text, @NonNull PdfPageTextObjectFont font,
+            float fontSize) {
         super(PdfPageObjectType.TEXT);
         this.mText = text;
-        this.mTypeface = typeface;
+        this.mFont = font;
         this.mFontSize = fontSize;
+        if (Flags.enableEditPdfPageObjects()) {
+            this.mRenderMode = PdfPageObjectRenderMode.FILL;
+        }
     }
 
     /**
@@ -80,31 +82,31 @@ public final class PdfPageTextObject extends PdfPageObject {
     }
 
     /**
-     * Sets the font size of the object.
+     * Returns the font of the text.
      *
-     * @param fontSize The font size to set.
+     * @return A copy of the font object.
      */
-    public void setFontSize(float fontSize) {
-        mFontSize = fontSize;
+    @NonNull
+    public PdfPageTextObjectFont getFont() {
+        return new PdfPageTextObjectFont(mFont);
     }
 
     /**
-     * Returns the stroke color of the object.
+     * Returns the fill color of the object.
      *
-     * @return The stroke color of the object.
+     * @return The fill color of the object.
      */
-    @NonNull
-    public Color getStrokeColor() {
-        return mStrokeColor;
+    public @ColorInt int getFillColor() {
+        return mFillColor;
     }
 
     /**
-     * Sets the stroke color of the object.
+     * Sets the fill color of the object.
      *
-     * @param strokeColor The stroke color of the object.
+     * @param  fillColor The fill color of the object.
      */
-    public void setStrokeColor(@NonNull Color strokeColor) {
-        this.mStrokeColor = strokeColor;
+    public void setFillColor(@ColorInt int fillColor) {
+        this.mFillColor = fillColor;
     }
 
     /**
@@ -122,44 +124,42 @@ public final class PdfPageTextObject extends PdfPageObject {
      * @param strokeWidth The stroke width of the object.
      */
     public void setStrokeWidth(float strokeWidth) {
-        this.mStrokeWidth = strokeWidth;
+        mStrokeWidth = strokeWidth;
     }
 
     /**
-     * Returns the font of the text.
+     * Returns the stroke color of the object.
      *
-     * @return The font.
+     * @return The stroke color of the object.
      */
-    @NonNull
-    public Typeface getTypeface() {
-        return mTypeface;
+    public @ColorInt int getStrokeColor() {
+        return mStrokeColor;
     }
 
     /**
-     * Sets the font of the text.
+     * Sets the stroke color of the object.
      *
-     * @param typeface The font to set.
+     * @param strokeColor The stroke color of the object.
      */
-    public void setTypeface(@NonNull Typeface typeface) {
-        this.mTypeface = typeface;
+    public void setStrokeColor(@ColorInt int strokeColor) {
+        this.mStrokeColor = strokeColor;
     }
 
     /**
-     * Returns the fill color of the object.
+     * Returns the render mode of the object.
      *
-     * @return The fill color of the object.
+     * @return The render mode of the object.
      */
-    @Nullable
-    public Color getFillColor() {
-        return mFillColor;
+    public @PdfPageObjectRenderMode.Type int getRenderMode() {
+        return mRenderMode;
     }
 
     /**
-     * Sets the fill color of the object.
+     * Sets the render mode of the object.
      *
-     * @param fillColor The fill color of the object.
+     * @param renderMode The render mode to be set.
      */
-    public void setFillColor(@Nullable Color fillColor) {
-        this.mFillColor = fillColor;
+    public void setRenderMode(@PdfPageObjectRenderMode.Type int renderMode) {
+        mRenderMode = renderMode;
     }
 }
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObjectFont.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObjectFont.java
new file mode 100644
index 000000000..c38baa156
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObjectFont.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.pdf.flags.Flags;
+
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_OBJECTS)
+public class PdfPageTextObjectFont {
+    private @PdfPageTextObjectFontFamily.Type int mFontFamily;
+    private boolean mIsBold;
+    private boolean mIsItalic;
+
+    public PdfPageTextObjectFont(@PdfPageTextObjectFontFamily.Type int fontFamily,
+            boolean isBold, boolean isItalic) {
+        mFontFamily = fontFamily;
+        mIsBold = isBold;
+        mIsItalic = isItalic;
+    }
+
+    public PdfPageTextObjectFont(@NonNull PdfPageTextObjectFont font) {
+        this.mFontFamily = font.getFontFamily();
+        this.mIsBold = font.isBold();
+        this.mIsItalic = font.isItalic();
+    }
+
+    /**
+     * Returns the font-family which is of type {@link PdfPageTextObjectFontFamily}
+     *
+     * @return The font-family.
+     */
+    public @PdfPageTextObjectFontFamily.Type int getFontFamily() {
+        return mFontFamily;
+    }
+
+    /**
+     * Set the font family of the object.
+     *
+     * @param fontFamily The font family to be set.
+     */
+    public void setFontFamily(@PdfPageTextObjectFontFamily.Type int fontFamily) {
+        mFontFamily = fontFamily;
+    }
+
+    /**
+     * Determines if the text is bold.
+     *
+     * @return true if the text is bold, false otherwise.
+     */
+    public boolean isBold() {
+        return mIsBold;
+    }
+
+    /**
+     * Sets whether the text should be bold or not.
+     *
+     * @param bold true if the text should be bold, false otherwise.
+     */
+    public void setBold(boolean bold) {
+        mIsBold = bold;
+    }
+
+    /**
+     * Determines if the text is italic.
+     *
+     * @return true if the text is italic, false otherwise.
+     */
+    public boolean isItalic() {
+        return mIsItalic;
+    }
+
+    /**
+     * Set whether the text should be italic or not.
+     *
+     * @param italic true if the text should be italic, false otherwise.
+     */
+    public void setItalic(boolean italic) {
+        mIsItalic = italic;
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObjectFontFamily.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObjectFontFamily.java
new file mode 100644
index 000000000..4a40f3df5
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObjectFontFamily.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.graphics.pdf.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * The class holds the set of font families supported by {@link PdfPageTextObject}.
+ * The specified font families are standard font families defined
+ * in the PDF Spec 1.7 - Page 146.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_OBJECTS)
+public class PdfPageTextObjectFontFamily {
+    private PdfPageTextObjectFontFamily() {}
+
+    /**
+     * Courier Font
+     */
+    public static final int COURIER = 0;
+
+    /**
+     * Helvetica Font
+     */
+    public static final int HELVETICA = 1;
+
+    /**
+     * Symbol Font (Note: Renders only symbols)
+     */
+    public static final int SYMBOL = 2;
+
+    /**
+     * TimesNewRoman Font
+     */
+    public static final int TIMES_NEW_ROMAN = 3;
+
+    /** @hide */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({COURIER, HELVETICA, SYMBOL, TIMES_NEW_ROMAN})
+    public @interface Type {
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java
index 70dfbd4a6..3f3279415 100644
--- a/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java
+++ b/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java
@@ -17,6 +17,7 @@
 package android.graphics.pdf.component;
 
 import android.annotation.FlaggedApi;
+import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.graphics.RectF;
 import android.graphics.pdf.flags.Flags;
@@ -34,40 +35,57 @@ import java.util.List;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_STAMP_ANNOTATIONS)
 public final class StampAnnotation extends PdfAnnotation {
+    @NonNull private RectF mBounds;
     @NonNull private List<PdfPageObject> mObjects;
 
     /**
-     * Creates a new stamp annotation with the specified bounds
+     * Creates a new stamp annotation with the specified bounds.
+     * <p>
+     *     The list of page objects inside the stamp annotation will be empty by default
      *
      * @param bounds The bounding rectangle of the annotation.
      */
     public StampAnnotation(@NonNull RectF bounds) {
-        super(PdfAnnotationType.STAMP, bounds);
+        super(PdfAnnotationType.STAMP);
+        mBounds = bounds;
         mObjects = new ArrayList<>();
     }
 
+    /**
+     * Sets the bounding rectangle of the stamp annotation.
+     *
+     * @param bounds The new bounding rectangle.
+     * @throws NullPointerException if given bounds is null
+     */
+    public void setBounds(@NonNull RectF bounds) {
+        Preconditions.checkNotNull(bounds, "Bounds should not be null");
+        this.mBounds = bounds;
+    }
+
+    /**
+     * Returns the bounding rectangle of the stamp annotation.
+     *
+     * @return The bounding rectangle.
+     */
+    @NonNull public RectF getBounds() {
+        return mBounds;
+    }
+
     /**
      * Adds a PDF page object to the stamp annotation.
      * <p>
-     * The page object should be a path, text or an image. The page object which has been
-     * already added to a page can't be added to the annotation and one page object can be added
-     * to one annotation only.
-     * When the annotation will be added to the page using
-     * @link android.graphics.pdf.PdfRenderer.Page#addPageAnnotation(PdfAnnotation)} or
-     * {@link android.graphics.pdf.PdfRendererPreV.Page#addPageAnnotation(PdfAnnotation)}, the
-     * page object will get assigned a unique id.
+     * The page object should be a path, text or an image.
      *
      * @param pageObject The PDF page object to add.
      * @throws IllegalArgumentException if the page object is already added to a page or an
      *         annotation.
      */
     public void addObject(@NonNull PdfPageObject pageObject) {
-        Preconditions.checkArgument(pageObject.getObjectId() == -1,
-                "This page object is already added to the page");
-        Preconditions.checkArgument(pageObject.isAddedInAnnotation(),
-                "This page object is already added to an annotation");
+        Preconditions.checkArgument(pageObject.getPdfObjectType() == PdfPageObjectType.TEXT
+                        || pageObject.getPdfObjectType() == PdfPageObjectType.IMAGE
+                        || pageObject.getPdfObjectType() == PdfPageObjectType.PATH,
+                "Unsupported page object type");
         mObjects.add(pageObject);
-        pageObject.setAddedInAnnotation();
     }
 
 
@@ -82,23 +100,16 @@ public final class StampAnnotation extends PdfAnnotation {
     }
 
     /**
-     * Remove the page object from the stamp annotation.
+     * Remove the page object at the given index inside the stamp annotation. Here index is the
+     * index of the page object in the list of page objects returned by {@link #getObjects()}
      *
-     * @param id - id of the object to be removed
+     * @param index - index of the object to be removed
      * @throws IllegalArgumentException if there is no object in the annotation with the given
      *         id
      */
-    public void removeObject(int id) {
-        throwIfIdNotPresentInAnnotation(id);
-        mObjects.remove(id);
-    }
-
-    private boolean throwIfIdNotPresentInAnnotation(int id) {
-        for (PdfPageObject pageObject : mObjects) {
-            if (pageObject.getObjectId() == id) {
-                return true;
-            }
-        }
-        return false;
+    public void removeObject(@IntRange(from = 0) int index) {
+        Preconditions.checkArgument(index >= 0 && index < mObjects.size(),
+                "Invalid Index");
+        mObjects.remove(index);
     }
 }
diff --git a/pdf/framework/libs/pdfClient/Android.bp b/pdf/framework/libs/pdfClient/Android.bp
index c7aecc196..95272f3c5 100644
--- a/pdf/framework/libs/pdfClient/Android.bp
+++ b/pdf/framework/libs/pdfClient/Android.bp
@@ -108,11 +108,16 @@ cc_test {
 
     static_libs: [
         "libbase_ndk",
+        "libpdfium_static_android_r_compatible",
     ],
 
     shared_libs: [
-        "libpdfium",
         "liblog",
+        "libjnigraphics",
+        "libdl",
+        "libft2",
+        "libjpeg",
+        "libz",
     ],
 
     cflags: [
diff --git a/pdf/framework/libs/pdfClient/annotation.cc b/pdf/framework/libs/pdfClient/annotation.cc
new file mode 100644
index 000000000..653f62ac6
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/annotation.cc
@@ -0,0 +1,352 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "annotation.h"
+
+#include <utils/pdf_strings.h>
+
+#include "image_object.h"
+#include "logging.h"
+#include "path_object.h"
+
+#define LOG_TAG "annotation"
+
+namespace pdfClient {
+
+std::vector<PageObject*> StampAnnotation::GetObjects() const {
+    std::vector<PageObject*> page_objects;
+    for (const auto& page_object : pageObjects_) {
+        page_objects.push_back(page_object.get());
+    }
+
+    return page_objects;
+}
+
+bool updateExistingBounds(FPDF_ANNOTATION fpdf_annot, size_t num_bounds,
+                          std::vector<Rectangle_f> bounds) {
+    for (auto bound_index = 0; bound_index < num_bounds; bound_index++) {
+        Rectangle_f rect = bounds[bound_index];
+        FS_QUADPOINTSF quad_points = {rect.left, rect.top,    rect.right, rect.top,
+                                      rect.left, rect.bottom, rect.right, rect.bottom};
+        if (!FPDFAnnot_SetAttachmentPoints(fpdf_annot, bound_index, &quad_points)) {
+            LOGD("Failed to update the bounds of highlight annotation");
+            return false;
+        }
+    }
+    return true;
+}
+
+bool StampAnnotation::PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) {
+    int num_of_objects = FPDFAnnot_GetObjectCount(fpdf_annot);
+
+    for (int object_index = 0; object_index < num_of_objects; object_index++) {
+        FPDF_PAGEOBJECT page_object = FPDFAnnot_GetObject(fpdf_annot, object_index);
+        int objectType = FPDFPageObj_GetType(page_object);
+
+        std::unique_ptr<PageObject> page_object_;
+
+        switch (objectType) {
+            case FPDF_PAGEOBJ_PATH: {
+                page_object_ = std::make_unique<PathObject>();
+                break;
+            }
+            case FPDF_PAGEOBJ_IMAGE: {
+                page_object_ = std::make_unique<ImageObject>();
+                break;
+            }
+            default: {
+                break;
+            }
+        }
+
+        if (page_object_ && !page_object_->PopulateFromFPDFInstance(page_object, page)) {
+            LOGE("Failed to get all the data corresponding to object with index "
+                 "%d ",
+                 object_index);
+            page_object_ = nullptr;
+        }
+
+        // Add the page_object_ to the stamp annotation even if page_object_ is null
+        // as we are storing empty unique ptr for the unsupported page objects
+        AddObject(std::move(page_object_));
+    }
+    return true;
+}
+
+ScopedFPDFAnnotation StampAnnotation::CreatePdfiumInstance(FPDF_DOCUMENT document, FPDF_PAGE page) {
+    // Create a ScopedFPDFAnnotation, If it will fail to populate this pdfium annot with desired
+    // params, we will return null that will lead to scoped annot getting out of scope and thus
+    // getting destroyed
+    ScopedFPDFAnnotation scoped_annot =
+            ScopedFPDFAnnotation(FPDFPage_CreateAnnot(page, FPDF_ANNOT_STAMP));
+
+    if (!scoped_annot) {
+        LOGE("Failed to create stamp Annotation.");
+        return nullptr;
+    }
+
+    Rectangle_f annotation_bounds = GetBounds();
+    FS_RECTF rect;
+    rect.left = annotation_bounds.left;
+    rect.bottom = annotation_bounds.bottom;
+    rect.right = annotation_bounds.right;
+    rect.top = annotation_bounds.top;
+
+    if (!FPDFAnnot_SetRect(scoped_annot.get(), &rect)) {
+        LOGE("Stamp Annotation bounds couldn't be set");
+        return nullptr;
+    }
+
+    std::vector<PageObject*> pageObjects = GetObjects();
+    for (auto pageObject : pageObjects) {
+        ScopedFPDFPageObject scoped_page_object = pageObject->CreateFPDFInstance(document, page);
+
+        if (!scoped_page_object) {
+            LOGE("Failed to create page object to add in the stamp annotation");
+            return nullptr;
+        }
+
+        if (!FPDFAnnot_AppendObject(scoped_annot.get(), scoped_page_object.release())) {
+            LOGE("Page object couldn't be inserted in the stamp annotation");
+            return nullptr;
+        }
+    }
+
+    return scoped_annot;
+}
+
+bool StampAnnotation::UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                                           FPDF_PAGE page) {
+    if (FPDFAnnot_GetSubtype(fpdf_annot) != FPDF_ANNOT_STAMP) {
+        LOGE("Unsupported operation - can't update a stamp annotation with some other type of "
+             "annotation");
+        return false;
+    }
+
+    Rectangle_f new_bounds = GetBounds();
+    FS_RECTF rect;
+    rect.left = new_bounds.left;
+    rect.bottom = new_bounds.bottom;
+    rect.right = new_bounds.right;
+    rect.top = new_bounds.top;
+    if (!FPDFAnnot_SetRect(fpdf_annot, &rect)) {
+        LOGE("Failed to update the bounds of the stamp annotation at given index");
+        return false;
+    }
+
+    // First Remove all the known existing objects from the stamp annotation, and then rewrite
+    int num_objects = FPDFAnnot_GetObjectCount(fpdf_annot);
+    for (int object_index = num_objects - 1; object_index >= 0; object_index--) {
+        FPDF_PAGEOBJECT pageObject = FPDFAnnot_GetObject(fpdf_annot, object_index);
+        int object_type = FPDFPageObj_GetType(pageObject);
+        if (pageObject != nullptr &&
+            (object_type == FPDF_PAGEOBJ_IMAGE || object_type == FPDF_PAGEOBJ_PATH)) {
+            if (!FPDFAnnot_RemoveObject(fpdf_annot, object_index)) {
+                LOGE("Failed to remove existing object from stamp annotation");
+                return false;
+            }
+        }
+    }
+
+    // Rewrite
+    std::vector<PageObject*> newPageObjects = GetObjects();
+    for (auto pageObject : newPageObjects) {
+        ScopedFPDFPageObject scoped_page_object = pageObject->CreateFPDFInstance(document, page);
+
+        if (!scoped_page_object) {
+            LOGE("Failed to create new page object to add in the stamp annotation");
+            return false;
+        }
+
+        if (!FPDFAnnot_AppendObject(fpdf_annot, scoped_page_object.release())) {
+            LOGE("Page object couldn't be inserted in the stamp annotation");
+            return false;
+        }
+    }
+    return true;
+}
+
+bool HighlightAnnotation::PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) {
+    // Get color
+    unsigned int R;
+    unsigned int G;
+    unsigned int B;
+    unsigned int A;
+
+    if (!FPDFAnnot_GetColor(fpdf_annot, FPDFANNOT_COLORTYPE_Color, &R, &G, &B, &A)) {
+        LOGE("Couldn't get color of highlight annotation");
+        return false;
+    }
+
+    Color color(R, G, B, A);
+    this->SetColor(color);
+    return true;
+}
+
+ScopedFPDFAnnotation HighlightAnnotation::CreatePdfiumInstance(FPDF_DOCUMENT document,
+                                                               FPDF_PAGE page) {
+    ScopedFPDFAnnotation scoped_annot =
+            ScopedFPDFAnnotation(FPDFPage_CreateAnnot(page, FPDF_ANNOT_HIGHLIGHT));
+
+    if (!scoped_annot) {
+        LOGE("Failed to create highlight Annotation.");
+        return nullptr;
+    }
+
+    if (!this->UpdatePdfiumInstance(scoped_annot.get(), document, page)) {
+        LOGE("Failed to create highlight annotation with given parameters");
+    }
+
+    return scoped_annot;
+}
+
+bool HighlightAnnotation::UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                                               FPDF_PAGE page) {
+    if (FPDFAnnot_GetSubtype(fpdf_annot) != FPDF_ANNOT_HIGHLIGHT) {
+        LOGE("Unsupported operation - can't update a highlight annotation with some other type of "
+             "annotation");
+        return false;
+    }
+
+    auto old_num_bounds = FPDFAnnot_CountAttachmentPoints(fpdf_annot);
+    std::vector<Rectangle_f> bounds = GetBounds();
+    auto new_num_bounds = bounds.size();
+
+    if (old_num_bounds == new_num_bounds) {
+        if (!updateExistingBounds(fpdf_annot, old_num_bounds, bounds)) return false;
+    } else if (old_num_bounds < new_num_bounds) {
+        if (!updateExistingBounds(fpdf_annot, old_num_bounds, bounds)) return false;
+        for (auto bound_index = old_num_bounds; bound_index < new_num_bounds; bound_index++) {
+            Rectangle_f rect = bounds[bound_index];
+            FS_QUADPOINTSF quad_points = {rect.left, rect.top,    rect.right, rect.top,
+                                          rect.left, rect.bottom, rect.right, rect.bottom};
+            if (!FPDFAnnot_AppendAttachmentPoints(fpdf_annot, &quad_points)) {
+                LOGD("Failed to update bounds of the highlight annotation");
+                return false;
+            }
+        }
+    } else {
+        if (!updateExistingBounds(fpdf_annot, new_num_bounds, bounds)) return false;
+        for (auto bound_index = new_num_bounds; bound_index < old_num_bounds; bound_index++) {
+            FS_QUADPOINTSF quad_points = {0, 0, 0, 0, 0, 0, 0, 0};
+            if (!FPDFAnnot_SetAttachmentPoints(fpdf_annot, bound_index, &quad_points)) {
+                LOGD("Failed to update bounds of the highlight annotation");
+                return false;
+            }
+        }
+    }
+
+    Color new_color = this->GetColor();
+    if (!FPDFAnnot_SetColor(fpdf_annot, FPDFANNOT_COLORTYPE_Color, new_color.r, new_color.g,
+                            new_color.b, new_color.a)) {
+        LOGE("Highlight Annotation color couldn't be updated");
+        return false;
+    }
+    return true;
+}
+
+bool FreeTextAnnotation::GetTextContentFromPdfium(FPDF_ANNOTATION fpdf_annot,
+                                                  unsigned long text_length, std::wstring& text) {
+    // Create a buffer of the obtained size to store the text contents.
+    ScopedFPDFWChar text_content_buffer = std::make_unique<FPDF_WCHAR[]>(text_length);
+    if (!FPDFAnnot_GetStringValue(fpdf_annot, kContents, text_content_buffer.get(), text_length)) {
+        return false;
+    }
+
+    text = pdfClient_utils::ToWideString(text_content_buffer.get(), text_length);
+    return true;
+}
+
+bool FreeTextAnnotation::PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) {
+    // Pass a empty buffer to get the length of the text contents.
+    unsigned long text_length = FPDFAnnot_GetStringValue(fpdf_annot, kContents, nullptr, 0);
+    if (text_length == 0) {
+        LOGE("Failed to get contents of FreeText Annotation");
+        return false;
+    }
+
+    if (!GetTextContentFromPdfium(fpdf_annot, text_length, text_content_)) {
+        LOGE("GetTextContentFromPdfium Failed.");
+        return false;
+    }
+
+    // Get color
+    if (!FPDFAnnot_GetColor(fpdf_annot, FPDFANNOT_COLORTYPE_Color, &text_color_.r, &text_color_.g,
+                            &text_color_.b, &text_color_.a)) {
+        LOGE("Couldn't get text color of freetext annotation");
+        return false;
+    }
+
+    if (!FPDFAnnot_GetColor(fpdf_annot, FPDFANNOT_COLORTYPE_InteriorColor, &background_color_.r,
+                            &background_color_.g, &background_color_.b, &background_color_.a)) {
+        LOGE("Couldn't get background color of freetext annotation");
+        return false;
+    }
+    return true;
+}
+
+ScopedFPDFAnnotation FreeTextAnnotation::CreatePdfiumInstance(FPDF_DOCUMENT document,
+                                                              FPDF_PAGE page) {
+    ScopedFPDFAnnotation scoped_annot =
+            ScopedFPDFAnnotation(FPDFPage_CreateAnnot(page, FPDF_ANNOT_FREETEXT));
+
+    if (!scoped_annot) {
+        LOGE("Failed to create FreeText Annotation");
+        return nullptr;
+    }
+
+    if (!UpdatePdfiumInstance(scoped_annot.get(), document, page)) {
+        LOGE("Failed to create FreeText Annotation with given parameters");
+    }
+
+    return scoped_annot;
+}
+
+bool FreeTextAnnotation::UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                                              FPDF_PAGE page) {
+    if (FPDFAnnot_GetSubtype(fpdf_annot) != FPDF_ANNOT_FREETEXT) {
+        LOGE("Unsupported operation - can't update a freetext annotation with some other type of "
+             "annotation");
+        return false;
+    }
+
+    Rectangle_f annotation_bounds = GetBounds();
+    if (!FPDFAnnot_SetRect(fpdf_annot, reinterpret_cast<FS_RECTF*>(&annotation_bounds))) {
+        LOGE("FreeText Annotation bounds could not be updated");
+        return false;
+    }
+
+    auto fpdfWideString = pdfClient_utils::ToFPDFWideString(text_content_);
+    if (!FPDFAnnot_SetStringValue(fpdf_annot, kContents, fpdfWideString.get())) {
+        LOGE("FreeText Annotation text content could not be updated");
+    }
+
+    if (!FPDFAnnot_SetColor(fpdf_annot, FPDFANNOT_COLORTYPE_Color, text_color_.r, text_color_.g,
+                            text_color_.b, text_color_.a)) {
+        LOGE("FreeText Annotation text color couldn't be updated");
+        return false;
+    }
+
+    if (!FPDFAnnot_SetColor(fpdf_annot, FPDFANNOT_COLORTYPE_InteriorColor, background_color_.r,
+                            background_color_.g, background_color_.b, background_color_.a)) {
+        LOGE("FreeText Annotation background color couldn't be updated");
+        return false;
+    }
+
+    return true;
+}
+
+}  // namespace pdfClient
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/annotation.h b/pdf/framework/libs/pdfClient/annotation.h
new file mode 100644
index 000000000..518c45c64
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/annotation.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIAPROVIDER_PDF_JNI_PDFCLIENT_ANNOTATION_H_
+#define MEDIAPROVIDER_PDF_JNI_PDFCLIENT_ANNOTATION_H_
+
+#include <map>
+
+#include "fpdf_annot.h"
+#include "fpdfview.h"
+#include "page_object.h"
+#include "rect.h"
+
+using pdfClient::Color;
+using pdfClient::PageObject;
+using pdfClient::Rectangle_f;
+
+namespace pdfClient {
+// Base class for different type of annotations
+class Annotation {
+  public:
+    enum class Type { UNKNOWN = 0, FreeText = 1, Highlight = 2, Stamp = 3 };
+
+    Annotation(Type type) : type_(type) {}
+    virtual ~Annotation() = default;
+
+    Type GetType() const { return type_; }
+
+    virtual bool PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) = 0;
+    virtual ScopedFPDFAnnotation CreatePdfiumInstance(FPDF_DOCUMENT document, FPDF_PAGE page) = 0;
+    virtual bool UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                                      FPDF_PAGE page) = 0;
+
+  private:
+    Type type_;
+};
+
+// This class represents a stamp annotation on a page of the pdf document. It doesn't take the
+// ownership of the pdfium annotation. It takes the ownership of PdfPageObject inside it but not of
+// underlying pdfium page objects
+class StampAnnotation : public Annotation {
+  public:
+    StampAnnotation(const Rectangle_f& bounds) : Annotation(Type::Stamp) { bounds_ = bounds; }
+
+    Rectangle_f GetBounds() const { return bounds_; }
+    void SetBounds(Rectangle_f bounds) { bounds_ = bounds; }
+
+    // Return a const reference to the list
+    // Stamp annotation will have the ownership of the page objects inside it
+    std::vector<PageObject*> GetObjects() const;
+
+    void AddObject(std::unique_ptr<PageObject> pageObject) {
+        // Take ownership of the PageObject
+        pageObjects_.push_back(std::move(pageObject));
+    }
+
+    void RemoveObject(int index) {
+        auto it = pageObjects_.begin();
+        std::advance(it, index);
+        pageObjects_.erase(it);
+    }
+
+    bool PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) override;
+    ScopedFPDFAnnotation CreatePdfiumInstance(FPDF_DOCUMENT document, FPDF_PAGE page) override;
+    bool UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                              FPDF_PAGE page) override;
+
+  private:
+    Rectangle_f bounds_;
+    std::vector<std::unique_ptr<PageObject>> pageObjects_;
+};
+
+class HighlightAnnotation : public Annotation {
+  public:
+    HighlightAnnotation(const std::vector<Rectangle_f>& bounds) : Annotation(Type::Highlight) {
+        bounds_ = bounds;
+    }
+
+    std::vector<Rectangle_f> GetBounds() const { return bounds_; }
+    void SetBounds(std::vector<Rectangle_f> bounds) { bounds_ = bounds; }
+
+    Color GetColor() const { return color_; }
+    void SetColor(Color color) { color_ = color; }
+
+    bool PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) override;
+    ScopedFPDFAnnotation CreatePdfiumInstance(FPDF_DOCUMENT document, FPDF_PAGE page) override;
+    bool UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                              FPDF_PAGE page) override;
+
+  private:
+    std::vector<Rectangle_f> bounds_;
+    Color color_;
+};
+
+class FreeTextAnnotation : public Annotation {
+  public:
+    static constexpr const char* kContents = "Contents";
+    FreeTextAnnotation(const Rectangle_f& bounds) : Annotation(Type::FreeText) { bounds_ = bounds; }
+
+    Rectangle_f GetBounds() const { return bounds_; }
+    void SetBounds(Rectangle_f bounds) { bounds_ = bounds; }
+
+    std::wstring GetTextContent() const { return text_content_; }
+    void SetTextContent(std::wstring textContent) { text_content_ = textContent; }
+
+    Color GetTextColor() const { return text_color_; }
+    void SetTextColor(Color color) { text_color_ = color; }
+
+    Color GetBackgroundColor() const { return background_color_; }
+    void SetBackgroundColor(Color color) { background_color_ = color; }
+
+    bool PopulateFromPdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_PAGE page) override;
+    ScopedFPDFAnnotation CreatePdfiumInstance(FPDF_DOCUMENT document, FPDF_PAGE page) override;
+    bool UpdatePdfiumInstance(FPDF_ANNOTATION fpdf_annot, FPDF_DOCUMENT document,
+                              FPDF_PAGE page) override;
+
+  private:
+    Rectangle_f bounds_;
+    std::wstring text_content_;
+    Color text_color_;
+    Color background_color_;
+    static bool GetTextContentFromPdfium(FPDF_ANNOTATION fpdf_annot, unsigned long text_length,
+                                         std::wstring& text);
+};
+
+}  // namespace pdfClient
+
+#endif
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/document.cc b/pdf/framework/libs/pdfClient/document.cc
index 54636961f..a78677648 100644
--- a/pdf/framework/libs/pdfClient/document.cc
+++ b/pdf/framework/libs/pdfClient/document.cc
@@ -116,7 +116,7 @@ std::shared_ptr<Page> Document::GetPage(int pageNum, bool retain) {
     if (retain) {
         page->InitializeFormFilling();
         pages_.try_emplace(pageNum, page);
-        fpdf_page_index_lookup_.try_emplace(page->page(), pageNum);
+        fpdf_page_index_lookup_.try_emplace(page->Get(), pageNum);
     }
 
     return page;
@@ -136,7 +136,7 @@ void Document::ReleaseRetainedPage(int pageNum) {
         std::shared_ptr<pdfClient::Page> page = pages_.at(pageNum);
         page->TerminateFormFilling();
         pages_.erase(pageNum);
-        fpdf_page_index_lookup_.erase(page->page());
+        fpdf_page_index_lookup_.erase(page->Get());
     }
 }
 
diff --git a/pdf/framework/libs/pdfClient/image_object.cc b/pdf/framework/libs/pdfClient/image_object.cc
new file mode 100644
index 000000000..69dedb0bc
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/image_object.cc
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "image_object.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "fpdf_edit.h"
+#include "logging.h"
+
+#define LOG_TAG "image_object"
+
+namespace pdfClient {
+
+BitmapFormat GetBitmapFormat(int bitmap_format) {
+    switch (bitmap_format) {
+        case FPDFBitmap_BGR: {
+            return BitmapFormat::BGR;
+        }
+        case FPDFBitmap_BGRA: {
+            return BitmapFormat::BGRA;
+        }
+        case FPDFBitmap_BGRx: {
+            return BitmapFormat::BGRx;
+        }
+        default: {
+            return BitmapFormat::Unknown;
+        }
+    }
+}
+
+ImageObject::ImageObject() : PageObject(Type::Image) {}
+
+ScopedFPDFPageObject ImageObject::CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) {
+    // Create a scoped PDFium image object.
+    ScopedFPDFPageObject scoped_image_object(FPDFPageObj_NewImageObj(document));
+    if (!scoped_image_object) {
+        return nullptr;
+    }
+    // Update attributes of PDFium image object.
+    if (!UpdateFPDFInstance(scoped_image_object.get(), page)) {
+        return nullptr;
+    }
+    return scoped_image_object;
+}
+
+bool ImageObject::UpdateFPDFInstance(FPDF_PAGEOBJECT image_object, FPDF_PAGE page) {
+    if (!image_object) {
+        return false;
+    }
+
+    // Check for Type Correctness.
+    if (FPDFPageObj_GetType(image_object) != FPDF_PAGEOBJ_IMAGE) {
+        return false;
+    }
+
+    // Set the updated bitmap.
+    if (!FPDFImageObj_SetBitmap(nullptr, 0, image_object, bitmap_.get())) {
+        return false;
+    }
+
+    // Set the updated matrix.
+    if (!SetDeviceToPageMatrix(image_object, page)) {
+        return false;
+    }
+
+    // Set the updated dimensions.
+    width_ = FPDFBitmap_GetWidth(bitmap_.get());
+    height_ = FPDFBitmap_GetHeight(bitmap_.get());
+
+    // Set the updated bitmap format.
+    bitmap_format_ = GetBitmapFormat(FPDFBitmap_GetFormat(bitmap_.get()));
+
+    return true;
+}
+
+bool ImageObject::PopulateFromFPDFInstance(FPDF_PAGEOBJECT image_object, FPDF_PAGE page) {
+    // Get bitmap.
+    bitmap_ = ScopedFPDFBitmap(FPDFImageObj_GetBitmap(image_object));
+    if (bitmap_.get() == nullptr) {
+        return false;
+    }
+
+    // Get matrix.
+    if (!GetPageToDeviceMatrix(image_object, page)) {
+        return false;
+    }
+
+    // Get dimensions.
+    width_ = FPDFBitmap_GetWidth(bitmap_.get());
+    height_ = FPDFBitmap_GetHeight(bitmap_.get());
+
+    // Get bitmap format.
+    bitmap_format_ = GetBitmapFormat(FPDFBitmap_GetFormat(bitmap_.get()));
+    if (bitmap_format_ == BitmapFormat::Unknown) {
+        LOGE("Bitmap format unknown");
+        return false;
+    }
+    return true;
+}
+
+void* ImageObject::GetBitmapBuffer() const {
+    return FPDFBitmap_GetBuffer(bitmap_.get());
+}
+
+ImageObject::~ImageObject() = default;
+
+}  // namespace pdfClient
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/image_object.h b/pdf/framework/libs/pdfClient/image_object.h
new file mode 100644
index 000000000..e3563ba8e
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/image_object.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIAPROVIDER_PDF_JNI_PDFCLIENT_IMAGE_OBJECT_H_
+#define MEDIAPROVIDER_PDF_JNI_PDFCLIENT_IMAGE_OBJECT_H_
+
+#include <stdint.h>
+
+#include "cpp/fpdf_scopers.h"
+#include "fpdfview.h"
+#include "page_object.h"
+
+typedef unsigned int uint;
+
+namespace pdfClient {
+
+enum class BitmapFormat {
+    Unknown = -1,
+    BGR,
+    BGRA,
+    BGRx,
+};
+
+class ImageObject : public PageObject {
+  public:
+    ImageObject();
+
+    ScopedFPDFPageObject CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) override;
+    bool UpdateFPDFInstance(FPDF_PAGEOBJECT image_object, FPDF_PAGE page) override;
+    bool PopulateFromFPDFInstance(FPDF_PAGEOBJECT image_object, FPDF_PAGE page) override;
+
+    void* GetBitmapBuffer() const;
+
+    ~ImageObject();
+
+    size_t width_ = 0;
+    size_t height_ = 0;
+    BitmapFormat bitmap_format_ = BitmapFormat::Unknown;
+    ScopedFPDFBitmap bitmap_;
+};
+
+}  // namespace pdfClient
+
+#endif  // MEDIAPROVIDER_PDF_JNI_PDFCLIENT_IMAGE_OBJECT_H_
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/jni_conversion.cc b/pdf/framework/libs/pdfClient/jni_conversion.cc
index b77559bb0..46d5b2d9e 100644
--- a/pdf/framework/libs/pdfClient/jni_conversion.cc
+++ b/pdf/framework/libs/pdfClient/jni_conversion.cc
@@ -16,17 +16,39 @@
 
 #include "jni_conversion.h"
 
+#include <android/bitmap.h>
 #include <string.h>
 
+#include "image_object.h"
+#include "logging.h"
 #include "rect.h"
+#include "text_object.h"
 
+using pdfClient::Annotation;
+using pdfClient::BitmapFormat;
+using pdfClient::Color;
 using pdfClient::Document;
+using pdfClient::Font;
+using pdfClient::font_names;
+using pdfClient::FreeTextAnnotation;
+using pdfClient::HighlightAnnotation;
+using pdfClient::ICoordinateConverter;
+using pdfClient::ImageObject;
 using pdfClient::LinuxFileOps;
+using pdfClient::Matrix;
+using pdfClient::PageObject;
+using pdfClient::PathObject;
+using pdfClient::Point_f;
+using pdfClient::Rectangle_f;
 using pdfClient::Rectangle_i;
 using pdfClient::SelectionBoundary;
+using pdfClient::StampAnnotation;
+using pdfClient::TextObject;
 using std::string;
 using std::vector;
 
+#define LOG_TAG "jni_conversion"
+
 namespace convert {
 
 namespace {
@@ -42,7 +64,21 @@ static const char* kChoiceOption = "android/graphics/pdf/models/ListItem";
 static const char* kGotoLinkDestination =
         "android/graphics/pdf/content/PdfPageGotoLinkContent$Destination";
 static const char* kGotoLink = "android/graphics/pdf/content/PdfPageGotoLinkContent";
+static const char* kPageObject = "android/graphics/pdf/component/PdfPageObject";
+static const char* kTextFont = "android/graphics/pdf/component/PdfPageTextObjectFont";
+static const char* kTextObject = "android/graphics/pdf/component/PdfPageTextObject";
+static const char* kPathObject = "android/graphics/pdf/component/PdfPagePathObject";
+static const char* kImageObject = "android/graphics/pdf/component/PdfPageImageObject";
+static const char* kStampAnnotation = "android/graphics/pdf/component/StampAnnotation";
+static const char* kPdfAnnotation = "android/graphics/pdf/component/PdfAnnotation";
+static const char* kHighlightAnnotation = "android/graphics/pdf/component/HighlightAnnotation";
+static const char* kFreeTextAnnotation = "android/graphics/pdf/component/FreeTextAnnotation";
 
+static const char* kBitmap = "android/graphics/Bitmap";
+static const char* kBitmapConfig = "android/graphics/Bitmap$Config";
+static const char* kColor = "android/graphics/Color";
+static const char* kMatrix = "android/graphics/Matrix";
+static const char* kPath = "android/graphics/Path";
 static const char* kRect = "android/graphics/Rect";
 static const char* kRectF = "android/graphics/RectF";
 static const char* kInteger = "java/lang/Integer";
@@ -100,13 +136,41 @@ jobject ToJavaString(JNIEnv* env, const std::string& s) {
     return env->NewStringUTF(s.c_str());
 }
 
+jobject ToJavaString(JNIEnv* env, const std::wstring& ws) {
+    jsize len = ws.length();
+    jchar* jchars = new jchar[len + 1];  // Null Termination
+
+    for (size_t i = 0; i < len; ++i) {
+        jchars[i] = static_cast<jchar>(ws[i]);
+    }
+    jchars[len] = 0;
+
+    jstring result = env->NewString(jchars, len);
+
+    delete[] jchars;
+    return result;
+}
+
+std::wstring ToNativeWideString(JNIEnv* env, jstring java_string) {
+    std::wstring value;
+
+    const jchar* raw = env->GetStringChars(java_string, 0);
+    jsize len = env->GetStringLength(java_string);
+
+    value.assign(raw, raw + len);
+
+    env->ReleaseStringChars(java_string, raw);
+    return value;
+}
+
 // Copy a C++ vector to a java ArrayList, using the given function to convert.
 template <class T>
 jobject ToJavaList(JNIEnv* env, const vector<T>& input,
                    jobject (*ToJavaObject)(JNIEnv* env, const T&)) {
     static jclass arraylist_class = GetPermClassRef(env, kArrayList);
     static jmethodID init = env->GetMethodID(arraylist_class, "<init>", "(I)V");
-    static jmethodID add = env->GetMethodID(arraylist_class, "add", funcsig("Z", kObject).c_str());
+    static jmethodID add = env->GetMethodID(arraylist_class, "add",
+                                                             funcsig("Z", kObject).c_str());
 
     jobject java_list = env->NewObject(arraylist_class, init, input.size());
     for (size_t i = 0; i < input.size(); i++) {
@@ -117,6 +181,40 @@ jobject ToJavaList(JNIEnv* env, const vector<T>& input,
     return java_list;
 }
 
+template <class T>
+jobject ToJavaList(JNIEnv* env, const vector<T>& input, ICoordinateConverter* converter,
+                   jobject (*ToJavaObject)(JNIEnv* env, const T&, ICoordinateConverter* converter)) {
+    static jclass arraylist_class = GetPermClassRef(env, kArrayList);
+    static jmethodID init = env->GetMethodID(arraylist_class, "<init>", "(I)V");
+    static jmethodID add = env->GetMethodID(arraylist_class, "add", funcsig("Z", kObject).c_str());
+
+    jobject java_list = env->NewObject(arraylist_class, init, input.size());
+    for (size_t i = 0; i < input.size(); i++) {
+        jobject java_object = ToJavaObject(env, input[i], converter);
+        env->CallBooleanMethod(java_list, add, java_object);
+        env->DeleteLocalRef(java_object);
+    }
+    return java_list;
+}
+
+// Copy a C++ vector to a java ArrayList, using the given function to convert.
+template <class T>
+jobject ToJavaList(JNIEnv* env, const vector<T*>& input, ICoordinateConverter* converter,
+                   jobject (*ToJavaObject)(JNIEnv* env, const T*,
+                                           ICoordinateConverter* converter)) {
+    static jclass arraylist_class = GetPermClassRef(env, kArrayList);
+    static jmethodID init = env->GetMethodID(arraylist_class, "<init>", "(I)V");
+    static jmethodID add = env->GetMethodID(arraylist_class, "add", funcsig("Z", kObject).c_str());
+
+    jobject java_list = env->NewObject(arraylist_class, init, input.size());
+    for (size_t i = 0; i < input.size(); i++) {
+        jobject java_object = ToJavaObject(env, input[i], converter);
+        env->CallBooleanMethod(java_list, add, java_object);
+        env->DeleteLocalRef(java_object);
+    }
+    return java_list;
+}
+
 }  // namespace
 
 jobject ToJavaPdfDocument(JNIEnv* env, std::unique_ptr<Document> doc) {
@@ -191,6 +289,35 @@ jobject ToJavaRectF(JNIEnv* env, const Rectangle_i& r) {
                           float(r.bottom));
 }
 
+jobject ToJavaRectF(JNIEnv* env, const Rectangle_f& r, ICoordinateConverter* converter) {
+    static jclass rectF_class = GetPermClassRef(env, kRectF);
+    static jmethodID init = env->GetMethodID(rectF_class, "<init>", "(FFFF)V");
+
+    Point_f top_left_corner = converter->PageToDevice({r.left, r.top});
+    Point_f bottom_down_corner = converter->PageToDevice({r.right, r.bottom});
+    return env->NewObject(rectF_class, init, top_left_corner.x, top_left_corner.y,
+                          bottom_down_corner.x, bottom_down_corner.y);
+}
+
+Rectangle_f ToNativeRectF(JNIEnv* env, jobject java_rectF, ICoordinateConverter* converter) {
+    static jclass rectF_class = GetPermClassRef(env, kRectF);
+    static jfieldID left_field = env->GetFieldID(rectF_class, "left", "F");
+    static jfieldID top_field = env->GetFieldID(rectF_class, "top", "F");
+    static jfieldID right_field = env->GetFieldID(rectF_class, "right", "F");
+    static jfieldID bottom_field = env->GetFieldID(rectF_class, "bottom", "F");
+
+    float left = env->GetFloatField(java_rectF, left_field);
+    float top = env->GetFloatField(java_rectF, top_field);
+    float right = env->GetFloatField(java_rectF, right_field);
+    float bottom = env->GetFloatField(java_rectF, bottom_field);
+
+    Point_f top_left_corner = converter->DeviceToPage({left, top});
+    Point_f bottom_down_corner = converter->DeviceToPage({right, bottom});
+
+    return Rectangle_f{top_left_corner.x, top_left_corner.y, bottom_down_corner.x,
+                       bottom_down_corner.y};
+}
+
 jobject ToJavaRects(JNIEnv* env, const vector<Rectangle_i>& rects) {
     return ToJavaList(env, rects, &ToJavaRect);
 }
@@ -324,4 +451,925 @@ jobject ToJavaGotoLinks(JNIEnv* env, const vector<GotoLink>& links) {
     return ToJavaList(env, links, &ToJavaGotoLink);
 }
 
+void ConvertBgrToRgba(uint32_t* rgba_pixel_array, uint8_t* bgr_pixel_array, size_t rgba_stride,
+                      size_t bgr_stride, size_t width, size_t height) {
+    for (size_t y = 0; y < height; y++) {
+        uint32_t* rgba_row_ptr = rgba_pixel_array + y * (rgba_stride / 4);
+        uint8_t* bgr_row_ptr = bgr_pixel_array + y * (bgr_stride);
+        for (size_t x = 0; x < width; x++) {
+            // Extract BGR components stored.
+            uint8_t blue = bgr_row_ptr[x * 3];
+            uint8_t green = bgr_row_ptr[x * 3 + 1];
+            uint8_t red = bgr_row_ptr[x * 3 + 2];
+            // Storing java bitmap components RGBA in little-endian.
+            rgba_row_ptr[x] = (0xFF << 24) | (blue << 16) | (green << 8) | red;
+        }
+    }
+}
+
+void ConvertBgraToRgba(uint32_t* rgba_pixel_array, uint8_t* bgra_pixel_array, size_t rgba_stride,
+                       size_t bgra_stride, size_t width, size_t height, bool ignore_alpha) {
+    for (size_t y = 0; y < height; y++) {
+        uint32_t* rgba_row_ptr = rgba_pixel_array + y * (rgba_stride / 4);
+        uint8_t* bgra_row_ptr = bgra_pixel_array + y * (bgra_stride);
+        for (size_t x = 0; x < width; x++) {
+            // Extract BGR components and determine alpha based on ignore_alpha flag.
+            uint8_t blue = bgra_row_ptr[x * 4];
+            uint8_t green = bgra_row_ptr[x * 4 + 1];
+            uint8_t red = bgra_row_ptr[x * 4 + 2];
+            uint8_t alpha = ignore_alpha ? 0xFF : bgra_row_ptr[x * 4 + 3];
+            // Storing java bitmap components RGBA in little-endian.
+            rgba_row_ptr[x] = (alpha << 24) | (blue << 16) | (green << 8) | red;
+        }
+    }
+}
+
+jobject ToJavaBitmap(JNIEnv* env, void* buffer, BitmapFormat bitmap_format, size_t width,
+                     size_t height, size_t native_stride) {
+    // Find Java Bitmap class
+    static jclass bitmap_class = GetPermClassRef(env, kBitmap);
+
+    // Get createBitmap method ID
+    static jmethodID create_bitmap = env->GetStaticMethodID(
+            bitmap_class, "createBitmap", funcsig(kBitmap, "I", "I", kBitmapConfig).c_str());
+
+    // Get Bitmap.Config.ARGB_8888 field ID
+    static jclass bitmap_config_class = GetPermClassRef(env, kBitmapConfig);
+    static jfieldID argb8888_field =
+            env->GetStaticFieldID(bitmap_config_class, "ARGB_8888", sig(kBitmapConfig).c_str());
+    static jobject argb8888 =
+            env->NewGlobalRef(env->GetStaticObjectField(bitmap_config_class, argb8888_field));
+
+    // Create a Java Bitmap object
+    jobject java_bitmap =
+            env->CallStaticObjectMethod(bitmap_class, create_bitmap, width, height, argb8888);
+
+    // Copy the buffer data into java bitmap.
+    AndroidBitmapInfo bitmap_info;
+    AndroidBitmap_getInfo(env, java_bitmap, &bitmap_info);
+    size_t java_stride = bitmap_info.stride;
+
+    void* bitmap_pixels;
+    if (AndroidBitmap_lockPixels(env, java_bitmap, &bitmap_pixels) < 0) {
+        return NULL;
+    }
+
+    uint32_t* java_pixel_array = static_cast<uint32_t*>(bitmap_pixels);
+    uint8_t* native_pixel_array = static_cast<uint8_t*>(buffer);
+    switch (bitmap_format) {
+        case BitmapFormat::BGR: {
+            ConvertBgrToRgba(java_pixel_array, native_pixel_array, java_stride, native_stride,
+                             width, height);
+            break;
+        }
+        case BitmapFormat::BGRA: {
+            ConvertBgraToRgba(java_pixel_array, native_pixel_array, java_stride, native_stride,
+                              width, height, false);
+            break;
+        }
+        case BitmapFormat::BGRx: {
+            ConvertBgraToRgba(java_pixel_array, native_pixel_array, java_stride, native_stride,
+                              width, height, true);
+            break;
+        }
+        default: {
+            LOGE("Bitmap format unknown!");
+            AndroidBitmap_unlockPixels(env, java_bitmap);
+            return NULL;
+        }
+    }
+
+    AndroidBitmap_unlockPixels(env, java_bitmap);
+
+    return java_bitmap;
+}
+
+int ToJavaColorInt(Color color) {
+    // Get ARGB values from Native Color
+    uint A = color.a;
+    uint R = color.r;
+    uint G = color.g;
+    uint B = color.b;
+
+    // Make ARGB  java color int
+    int java_color_int = (A & 0xFF) << 24 | (R & 0xFF) << 16 | (G & 0xFF) << 8 | (B & 0xFF);
+
+    return java_color_int;
+}
+
+jobject ToJavaColor(JNIEnv* env, Color color) {
+    // Find Java Color class
+    static jclass color_class = GetPermClassRef(env, kColor);
+
+    // Get valueOf method ID
+    static jmethodID value_of =
+            env->GetStaticMethodID(color_class, "valueOf", funcsig(kColor, "I").c_str());
+
+    // Make ARGB  java color int
+    int java_color_int = ToJavaColorInt(color);
+
+    // Create a Java Color Object.
+    jobject java_color = env->CallStaticObjectMethod(color_class, value_of, java_color_int);
+
+    return java_color;
+}
+
+jfloatArray ToJavaFloatArray(JNIEnv* env, const float arr[], size_t length) {
+    // Create Java float Array.
+    jfloatArray java_float_array = env->NewFloatArray(length);
+
+    // Copy data from the C++ float Array to the Java float Array
+    env->SetFloatArrayRegion(java_float_array, 0, length, arr);
+
+    return java_float_array;
+}
+
+jobject ToJavaMatrix(JNIEnv* env, const Matrix matrix) {
+    // Find Java Matrix class
+    static jclass matrix_class = GetPermClassRef(env, kMatrix);
+    // Get the constructor method ID
+    static jmethodID init = env->GetMethodID(matrix_class, "<init>", funcsig("V").c_str());
+
+    // Create Java Matrix object.
+    jobject java_matrix = env->NewObject(matrix_class, init);
+
+    // Create Transform Array.
+    float transform[9] = {matrix.a, matrix.c, matrix.e, matrix.b, matrix.d, matrix.f, 0, 0, 1};
+
+    // Convert to Java floatArray.
+    jfloatArray java_float_array =
+            ToJavaFloatArray(env, transform, sizeof(transform) / sizeof(transform[0]));
+
+    // Matrix setValues.
+    static jmethodID set_values = env->GetMethodID(matrix_class, "setValues", "([F)V");
+    env->CallVoidMethod(java_matrix, set_values, java_float_array);
+
+    return java_matrix;
+}
+
+jobject ToJavaPath(JNIEnv* env, const std::vector<PathObject::Segment>& segments,
+                   ICoordinateConverter* converter) {
+    // Find Java Path class.
+    static jclass path_class = GetPermClassRef(env, kPath);
+    // Get the constructor methodID.
+    static jmethodID init = env->GetMethodID(path_class, "<init>", funcsig("V").c_str());
+
+    // Create Java Path object.
+    jobject java_path = env->NewObject(path_class, init);
+
+    // Set Path Segments in Java.
+    for (auto& segment : segments) {
+        // Get PageToDevice Coordinates
+        Point_f output = converter->PageToDevice({segment.x, segment.y});
+        switch (segment.command) {
+            case PathObject::Segment::Command::Move: {
+                static jmethodID move_to =
+                        env->GetMethodID(path_class, "moveTo", funcsig("V", "F", "F").c_str());
+                env->CallVoidMethod(java_path, move_to, output.x, output.y);
+                break;
+            }
+            case PathObject::Segment::Command::Line: {
+                static jmethodID line_to =
+                        env->GetMethodID(path_class, "lineTo", funcsig("V", "F", "F").c_str());
+                env->CallVoidMethod(java_path, line_to, output.x, output.y);
+                break;
+            }
+            default:
+                break;
+        }
+        // Check if segment isClosed.
+        if (segment.is_closed) {
+            static jmethodID close = env->GetMethodID(path_class, "close", funcsig("V").c_str());
+            env->CallVoidMethod(java_path, close);
+        }
+    }
+
+    return java_path;
+}
+
+jobject ToJavaPdfTextObject(JNIEnv* env, const TextObject* text_object) {
+    // Find Java PdfTextObject Class.
+    static jclass text_object_class = GetPermClassRef(env, kTextObject);
+
+    // Create Java Text String from TextObject Data String.
+    jobject java_string = ToJavaString(env, text_object->text_);
+
+    // Get Native Font Object Data.
+    int font_family = static_cast<int>(text_object->font_.GetFamily());
+    bool bold = text_object->font_.IsBold();
+    bool italic = text_object->font_.IsItalic();
+
+    // Create Java TextObjectFont Instance.
+    static jclass text_font_class = GetPermClassRef(env, kTextFont);
+    static jmethodID init_text_font =
+            env->GetMethodID(text_font_class, "<init>", funcsig("V", "I", "Z", "Z").c_str());
+    jobject java_font = env->NewObject(text_font_class, init_text_font, font_family, bold, italic);
+
+    // Create Java PdfTextObject Instance.
+    static jmethodID init_text_object = env->GetMethodID(
+            text_object_class, "<init>", funcsig("V", kString, kTextFont, "F").c_str());
+    float font_size = text_object->font_size_;
+    jobject java_text_object =
+            env->NewObject(text_object_class, init_text_object, java_string, java_font, font_size);
+
+    // Set Java PdfTextObject Render Mode.
+    int render_mode = static_cast<int>(text_object->render_mode_);
+    static jmethodID set_render_mode = env->GetMethodID(text_object_class, "setRenderMode", "(I)V");
+    env->CallVoidMethod(java_text_object, set_render_mode, render_mode);
+
+    // Set Java PdfTextObject Fill Color.
+    static jmethodID set_fill_color = env->GetMethodID(text_object_class, "setFillColor", "(I)V");
+    env->CallVoidMethod(java_text_object, set_fill_color, ToJavaColorInt(text_object->fill_color_));
+
+    // Set Java PdfTextObject Stroke Color.
+    static jmethodID set_stroke_color =
+            env->GetMethodID(text_object_class, "setStrokeColor", "(I)V");
+    env->CallVoidMethod(java_text_object, set_stroke_color,
+                        ToJavaColorInt(text_object->stroke_color_));
+
+    // Set Java PdfTextObject Stroke Width.
+    static jmethodID set_stroke_width =
+            env->GetMethodID(text_object_class, "setStrokeWidth", "(F)V");
+    env->CallVoidMethod(java_text_object, set_stroke_width, text_object->stroke_width_);
+
+    return java_text_object;
+}
+
+jobject ToJavaPdfPathObject(JNIEnv* env, const PathObject* path_object,
+                            ICoordinateConverter* converter) {
+    // Find Java PdfPathObject Class.
+    static jclass path_object_class = GetPermClassRef(env, kPathObject);
+    // Get Constructor Id.
+    static jmethodID init_path =
+            env->GetMethodID(path_object_class, "<init>", funcsig("V", kPath).c_str());
+
+    // Create Java Path from Native PathSegments.
+    jobject java_path = ToJavaPath(env, path_object->segments_, converter);
+
+    // Create Java PdfPathObject Instance.
+    jobject java_path_object = env->NewObject(path_object_class, init_path, java_path);
+
+    // Set Java PdfPathObject FillColor.
+    if (path_object->is_fill_) {
+        static jmethodID set_fill_color =
+                env->GetMethodID(path_object_class, "setFillColor", funcsig("V", "I").c_str());
+
+        env->CallVoidMethod(java_path_object, set_fill_color,
+                            ToJavaColorInt(path_object->fill_color_));
+    }
+
+    // Set Java PdfPathObject StrokeColor.
+    if (path_object->is_stroke_) {
+        static jmethodID set_stroke_color =
+                env->GetMethodID(path_object_class, "setStrokeColor", funcsig("V", "I").c_str());
+
+        env->CallVoidMethod(java_path_object, set_stroke_color,
+                            ToJavaColorInt(path_object->stroke_color_));
+    }
+
+    // Set Java Stroke Width.
+    static jmethodID set_stroke_width =
+            env->GetMethodID(path_object_class, "setStrokeWidth", "(F)V");
+    env->CallVoidMethod(java_path_object, set_stroke_width, path_object->stroke_width_);
+
+    return java_path_object;
+}
+
+jobject ToJavaPdfImageObject(JNIEnv* env, const ImageObject* image_object) {
+    // Find Java ImageObject Class.
+    static jclass image_object_class = GetPermClassRef(env, kImageObject);
+    // Get Constructor Id.
+    static jmethodID init_image =
+            env->GetMethodID(image_object_class, "<init>", funcsig("V", kBitmap).c_str());
+
+    // Create Java Bitmap from Native Bitmap Buffer.
+    void* buffer = image_object->GetBitmapBuffer();
+    BitmapFormat bitmap_format = image_object->bitmap_format_;
+    size_t width = image_object->width_;
+    size_t height = image_object->height_;
+    int stride = FPDFBitmap_GetStride(image_object->bitmap_.get());
+    jobject java_bitmap = ToJavaBitmap(env, buffer, bitmap_format, width, height, stride);
+    if (java_bitmap == NULL) {
+        LOGE("To java bitmap conversion failed!");
+        return NULL;
+    }
+
+    // Create Java PdfImageObject Instance.
+    jobject java_image_object = env->NewObject(image_object_class, init_image, java_bitmap);
+
+    return java_image_object;
+}
+
+jobject ToJavaPdfPageObject(JNIEnv* env, const PageObject* page_object,
+                            ICoordinateConverter* converter) {
+    // Check for Native Supported Object.
+    if (!page_object) {
+        return NULL;
+    }
+
+    jobject java_page_object = NULL;
+
+    switch (page_object->GetType()) {
+        case PageObject::Type::Path: {
+            const PathObject* path_object = static_cast<const PathObject*>(page_object);
+            java_page_object = ToJavaPdfPathObject(env, path_object, converter);
+            break;
+        }
+        case PageObject::Type::Image: {
+            const ImageObject* image_object = static_cast<const ImageObject*>(page_object);
+            java_page_object = ToJavaPdfImageObject(env, image_object);
+            break;
+        }
+        default:
+            break;
+    }
+
+    // If no PageObject was created, return null
+    if (java_page_object == NULL) {
+        return NULL;
+    }
+
+    // Find Java PageObject Class.
+    static jclass page_object_class = GetPermClassRef(env, kPageObject);
+
+    // Set Java PdfPageObject Matrix.
+    static jmethodID set_matrix =
+            env->GetMethodID(page_object_class, "setMatrix", funcsig("V", kMatrix).c_str());
+    env->CallVoidMethod(java_page_object, set_matrix,
+                        ToJavaMatrix(env, page_object->device_matrix_));
+
+    return java_page_object;
+}
+
+jobject ToJavaPdfPageObjects(JNIEnv* env, const vector<PageObject*>& page_objects,
+                             ICoordinateConverter* converter) {
+    return ToJavaList(env, page_objects, converter, &ToJavaPdfPageObject);
+}
+
+Color ToNativeColor(jint java_color_int) {
+    // Decoding RGBA components
+    unsigned int red = (java_color_int >> 16) & 0xFF;
+    unsigned int green = (java_color_int >> 8) & 0xFF;
+    unsigned int blue = java_color_int & 0xFF;
+    unsigned int alpha = (java_color_int >> 24) & 0xFF;
+
+    return Color(red, green, blue, alpha);
+}
+
+Color ToNativeColor(JNIEnv* env, jobject java_color) {
+    // Find Java Color class
+    static jclass color_class = GetPermClassRef(env, kColor);
+
+    // Get the color as an ARGB integer
+    jmethodID get_color_int = env->GetMethodID(color_class, "toArgb", funcsig("I").c_str());
+    jint java_color_int = env->CallIntMethod(java_color, get_color_int);
+
+    return ToNativeColor(java_color_int);
+}
+
+std::unique_ptr<TextObject> ToNativeTextObject(JNIEnv* env, jobject java_text_object) {
+    // Create TextObject Data Instance.
+    auto text_object = std::make_unique<TextObject>();
+
+    // Get Ref to Java PdfTextObject Class.
+    static jclass text_object_class = GetPermClassRef(env, kTextObject);
+
+    // Get Java PdfTextObject Font.
+    static jmethodID get_text_font =
+            env->GetMethodID(text_object_class, "getFont", funcsig(kTextFont).c_str());
+    jobject java_text_font = env->CallObjectMethod(java_text_object, get_text_font);
+
+    // Find Java PdfTextObjectFont Class.
+    static jclass text_font_class = GetPermClassRef(env, kTextFont);
+
+    // Get the Font Family for the PdfTextObjectFont.
+    static jmethodID get_font_family = env->GetMethodID(text_font_class, "getFontFamily", "()I");
+    jint font_family = env->CallIntMethod(java_text_font, get_font_family);
+
+    // Is PdfTextObjectFont Bold.
+    static jmethodID is_bold = env->GetMethodID(text_font_class, "isBold", "()Z");
+    jboolean bold = env->CallBooleanMethod(java_text_font, is_bold);
+
+    // Is PdfTextObjectFont Italic.
+    static jmethodID is_italic = env->GetMethodID(text_font_class, "isItalic", "()Z");
+    jboolean italic = env->CallBooleanMethod(java_text_font, is_italic);
+
+    // Set TextObject Data Font.
+    if (font_family < 0 || font_family >= font_names.size()) {
+        return nullptr;
+    }
+    text_object->font_ =
+            Font(font_names[font_family], static_cast<Font::Family>(font_family), bold, italic);
+
+    // Get Java PdfTextObject font size.
+    static jmethodID get_font_size = env->GetMethodID(text_object_class, "getFontSize", "()F");
+    jfloat font_size = env->CallFloatMethod(java_text_object, get_font_size);
+
+    // Set TextObject Data font size.
+    text_object->font_size_ = font_size;
+
+    // Get Java PdfTextObject Text.
+    static jmethodID get_text =
+            env->GetMethodID(text_object_class, "getText", funcsig(kString).c_str());
+    jstring java_text = static_cast<jstring>(env->CallObjectMethod(java_text_object, get_text));
+
+    // Set TextObject Data Text.
+    text_object->text_ = ToNativeWideString(env, java_text);
+
+    // Get Java PdfTextObject RenderMode.
+    static jmethodID get_render_mode = env->GetMethodID(text_object_class, "getRenderMode", "()I");
+    jint render_mode = env->CallIntMethod(java_text_object, get_render_mode);
+
+    // Set TextObject Data RenderMode.
+    switch (static_cast<TextObject::RenderMode>(render_mode)) {
+        case TextObject::RenderMode::Fill: {
+            text_object->render_mode_ = TextObject::RenderMode::Fill;
+            break;
+        }
+        case TextObject::RenderMode::Stroke: {
+            text_object->render_mode_ = TextObject::RenderMode::Stroke;
+            break;
+        }
+        case TextObject::RenderMode::FillStroke: {
+            text_object->render_mode_ = TextObject::RenderMode::FillStroke;
+            break;
+        }
+        default: {
+            text_object->render_mode_ = TextObject::RenderMode::Unknown;
+            break;
+        }
+    }
+
+    // Get Java PdfTextObject Fill Color.
+    static jmethodID get_fill_color = env->GetMethodID(text_object_class, "getFillColor", "()I");
+    jint java_fill_color = env->CallIntMethod(java_text_object, get_fill_color);
+
+    // Set TextObject Data Fill Color
+    text_object->fill_color_ = ToNativeColor(java_fill_color);
+
+    // Get Java PdfTextObject Stroke Color.
+    static jmethodID get_stroke_color =
+            env->GetMethodID(text_object_class, "getStrokeColor", "()I");
+    jint java_stroke_color = env->CallIntMethod(java_text_object, get_stroke_color);
+
+    // Set TextObject Data Stroke Color.
+    text_object->stroke_color_ = ToNativeColor(java_stroke_color);
+
+    // Get Java PdfTextObject Stroke Width.
+    static jmethodID get_stroke_width =
+            env->GetMethodID(text_object_class, "getStrokeWidth", "()F");
+    jfloat stroke_width = env->CallFloatMethod(java_text_object, get_stroke_width);
+
+    // Set TextObject Data Stroke Width.
+    text_object->stroke_width_ = stroke_width;
+
+    return text_object;
+}
+
+std::unique_ptr<PathObject> ToNativePathObject(JNIEnv* env, jobject java_path_object,
+                                               ICoordinateConverter* converter) {
+    // Create PathObject Data Instance.
+    auto path_object = std::make_unique<PathObject>();
+
+    // Get Ref to Java PathObject Class.
+    static jclass path_object_class = GetPermClassRef(env, kPathObject);
+
+    // Get Path from Java PathObject.
+    static jmethodID to_path =
+            env->GetMethodID(path_object_class, "toPath", funcsig(kPath).c_str());
+    jobject java_path = env->CallObjectMethod(java_path_object, to_path);
+
+    // Find Java Path Class.
+    static jclass path_class = GetPermClassRef(env, kPath);
+
+    // Get the Approximate Array for the Path.
+    static jmethodID approximate = env->GetMethodID(path_class, "approximate", "(F)[F");
+    // The acceptable error while approximating a Path Curve with a line.
+    static const float acceptable_error = 0.5f;
+    jfloatArray java_approximate =
+            (jfloatArray)env->CallObjectMethod(java_path, approximate, acceptable_error);
+    const jsize size = env->GetArrayLength(java_approximate);
+
+    // Copy Java Array to Native Array
+    float path_approximate[size];
+    env->GetFloatArrayRegion(java_approximate, 0, size, path_approximate);
+
+    // Set PathObject Data PathSegments.
+    auto& segments = path_object->segments_;
+    for (int i = 0; i < size; i += 3) {
+        // Get DeviceToPage Coordinates
+        Point_f output =
+                converter->DeviceToPage({path_approximate[i + 1], path_approximate[i + 2]});
+        if (i == 0 || path_approximate[i] == path_approximate[i - 3]) {
+            segments.emplace_back(PathObject::Segment::Command::Move, output.x, output.y);
+        } else {
+            segments.emplace_back(PathObject::Segment::Command::Line, output.x, output.y);
+        }
+    }
+
+    // Get Java PathObject Fill Color.
+    static jmethodID get_fill_color =
+            env->GetMethodID(path_object_class, "getFillColor", funcsig("I").c_str());
+    jint java_fill_color = env->CallIntMethod(java_path_object, get_fill_color);
+
+    // Set PathObject Data Fill Mode and Fill Color
+    path_object->is_fill_ = (java_fill_color != 0);
+    if (path_object->is_fill_) {
+        path_object->fill_color_ = ToNativeColor(java_fill_color);
+    }
+
+    // Get Java PathObject Stroke Color.
+    static jmethodID get_stroke_color =
+            env->GetMethodID(path_object_class, "getStrokeColor", funcsig("I").c_str());
+    jint java_stroke_color = env->CallIntMethod(java_path_object, get_stroke_color);
+
+    // Set PathObject Data Stroke Mode and Stroke Color.
+    path_object->is_stroke_ = (java_stroke_color != 0);
+    if (path_object->is_stroke_) {
+        path_object->stroke_color_ = ToNativeColor(java_stroke_color);
+    }
+
+    // Get Java PathObject Stroke Width.
+    static jmethodID get_stroke_width =
+            env->GetMethodID(path_object_class, "getStrokeWidth", funcsig("F").c_str());
+    jfloat stroke_width = env->CallFloatMethod(java_path_object, get_stroke_width);
+
+    // Set PathObject Data Stroke Width.
+    path_object->stroke_width_ = stroke_width;
+
+    return path_object;
+}
+
+void CopyRgbaToBgra(uint8_t* rgba_pixel_array, size_t rgba_stride, uint32_t* bgra_pixel_array,
+                    size_t bgra_stride, size_t width, size_t height) {
+    for (size_t y = 0; y < height; y++) {
+        uint8_t* rgba_row_ptr = rgba_pixel_array + y * rgba_stride;
+        uint32_t* bgra_row_ptr = bgra_pixel_array + y * (bgra_stride / 4);
+        for (size_t x = 0; x < width; x++) {
+            // Extract RGBA components stored.
+            uint8_t red = rgba_row_ptr[x * 4];
+            uint8_t green = rgba_row_ptr[x * 4 + 1];
+            uint8_t blue = rgba_row_ptr[x * 4 + 2];
+            uint8_t alpha = rgba_row_ptr[x * 4 + 3];
+            // Storing native bitmap components BGRA in little-endian.
+            bgra_row_ptr[x] = (alpha << 24) | (red << 16) | (green << 8) | blue;
+        }
+    }
+}
+
+std::unique_ptr<ImageObject> ToNativeImageObject(JNIEnv* env, jobject java_image_object) {
+    // Create ImageObject Data Instance.
+    auto image_object = std::make_unique<ImageObject>();
+
+    // Get Ref to Java ImageObject Class.
+    static jclass image_object_class = GetPermClassRef(env, kImageObject);
+
+    // Get the bitmap from the Java ImageObject.
+    static jmethodID get_bitmap =
+            env->GetMethodID(image_object_class, "getBitmap", funcsig(kBitmap).c_str());
+    jobject java_bitmap = env->CallObjectMethod(java_image_object, get_bitmap);
+
+    // Get android bitmap info.
+    AndroidBitmapInfo bitmap_info;
+    AndroidBitmap_getInfo(env, java_bitmap, &bitmap_info);
+    if (bitmap_info.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
+        LOGE("Android bitmap is not in RGBA_8888 format");
+        return nullptr;
+    }
+    size_t bitmap_width = bitmap_info.width;
+    size_t bitmap_height = bitmap_info.height;
+    size_t java_stride = bitmap_info.stride;
+
+    // Create ImageObject data bitmap.
+    image_object->bitmap_ = ScopedFPDFBitmap(FPDFBitmap_Create(bitmap_width, bitmap_height, 1));
+    size_t native_stride = FPDFBitmap_GetStride(image_object->bitmap_.get());
+
+    // Copy pixels from android bitmap.
+    void* bitmap_pixels;
+    if (AndroidBitmap_lockPixels(env, java_bitmap, &bitmap_pixels) < 0) {
+        LOGE("Android bitmap lock pixels failed!");
+        return nullptr;
+    }
+
+    uint8_t* java_pixel_array = static_cast<uint8_t*>(bitmap_pixels);
+    uint32_t* native_pixel_array = static_cast<uint32_t*>(image_object->GetBitmapBuffer());
+
+    CopyRgbaToBgra(java_pixel_array, java_stride, native_pixel_array, native_stride, bitmap_width,
+                   bitmap_height);
+
+    AndroidBitmap_unlockPixels(env, java_bitmap);
+
+    return image_object;
+}
+
+std::unique_ptr<PageObject> ToNativePageObject(JNIEnv* env, jobject java_page_object,
+                                               ICoordinateConverter* converter) {
+    // Find Java PageObject class and GetType
+    static jclass page_object_class = GetPermClassRef(env, kPageObject);
+    static jmethodID get_type = env->GetMethodID(page_object_class, "getPdfObjectType", "()I");
+    jint page_object_type = env->CallIntMethod(java_page_object, get_type);
+
+    // Pointer to PageObject
+    std::unique_ptr<PageObject> page_object = nullptr;
+
+    switch (static_cast<PageObject::Type>(page_object_type)) {
+        case PageObject::Type::Path: {
+            page_object = ToNativePathObject(env, java_page_object, converter);
+            break;
+        }
+        case PageObject::Type::Image: {
+            page_object = ToNativeImageObject(env, java_page_object);
+            break;
+        }
+        default:
+            break;
+    }
+
+    if (!page_object) {
+        return nullptr;
+    }
+
+    // Get Matrix from Java PageObject.
+    static jmethodID get_matrix = env->GetMethodID(page_object_class, "getMatrix", "()[F");
+    jfloatArray java_matrix_array =
+                             (jfloatArray)env->CallObjectMethod(java_page_object, get_matrix);
+
+    // Copy Java Array to Native Array
+    float transform[9];
+    env->GetFloatArrayRegion(java_matrix_array, 0, 9, transform);
+
+    // Set PageObject Data Matrix.
+    page_object->device_matrix_ = {transform[0 /*kMScaleX*/], transform[3 /*kMSkewY*/],
+                                   transform[1 /*kMSkewX*/],  transform[4 /*kMScaleY*/],
+                                   transform[2 /*kMTransX*/], transform[5 /*kMTransY*/]};
+
+    return page_object;
+}
+
+jobject ToJavaPageAnnotations(JNIEnv* env, const vector<Annotation*>& annotations,
+                              ICoordinateConverter* converter) {
+    return ToJavaList(env, annotations, converter, &ToJavaPageAnnotation);
+}
+
+jobject ToJavaStampAnnotation(JNIEnv* env, const Annotation* annotation,
+                              ICoordinateConverter* converter) {
+    // Cast to StampAnnotation
+    const StampAnnotation* stamp_annotation = static_cast<const StampAnnotation*>(annotation);
+    jobject java_bounds = ToJavaRectF(env, stamp_annotation->GetBounds(), converter);
+
+    // Find Java StampAnnotation Class.
+    static jclass stamp_annotation_class = GetPermClassRef(env, kStampAnnotation);
+    // Get Constructor Id.
+    static jmethodID init =
+            env->GetMethodID(stamp_annotation_class, "<init>", funcsig("V", kRectF).c_str());
+
+    // Create Java StampAnnotation Instance.
+    jobject java_annotation = env->NewObject(stamp_annotation_class, init, java_bounds);
+
+    // Add page objects to stamp annotation
+
+    // Get methodId for addObject
+    static jmethodID add_object = env->GetMethodID(stamp_annotation_class, "addObject",
+                                                   funcsig("V", kPageObject).c_str());
+
+    std::vector<PageObject*> page_objects = stamp_annotation->GetObjects();
+
+    for (const auto& page_object : page_objects) {
+        jobject java_page_object = ToJavaPdfPageObject(env, page_object, converter);
+        env->CallVoidMethod(java_annotation, add_object, java_page_object);
+    }
+    return java_annotation;
+}
+
+jobject ToJavaHighlightAnnotation(JNIEnv* env, const Annotation* annotation,
+                                  ICoordinateConverter* converter) {
+    // Cast to HighlightAnnotation
+    const HighlightAnnotation* highlight_annotation =
+            static_cast<const HighlightAnnotation*>(annotation);
+    jobject java_bounds =
+            ToJavaList(env, highlight_annotation->GetBounds(), converter, &ToJavaRectF);
+
+    // Find Java HighlightAnnotation Class.
+    static jclass highlight_annotation_class = GetPermClassRef(env, kHighlightAnnotation);
+    // Get Constructor Id.
+    static jmethodID init =
+            env->GetMethodID(highlight_annotation_class, "<init>", funcsig("V", kList).c_str());
+
+    // Create Java HighlightAnnotation Instance.
+    jobject java_annotation = env->NewObject(highlight_annotation_class, init, java_bounds);
+
+    // Get and set highlight color
+    // Get method Id for setColor.
+    static jmethodID set_color =
+            env->GetMethodID(highlight_annotation_class, "setColor", funcsig("V", "I").c_str());
+    // call setColor
+    env->CallVoidMethod(java_annotation, set_color,
+                        ToJavaColorInt(highlight_annotation->GetColor()));
+
+    return java_annotation;
+}
+
+jobject ToJavaFreeTextAnnotation(JNIEnv* env, const Annotation* annotation,
+                                 ICoordinateConverter* converter) {
+    // Cast to FreeText Annotation
+    const FreeTextAnnotation* freetext_annotation =
+            static_cast<const FreeTextAnnotation*>(annotation);
+
+    jobject java_bounds = ToJavaRectF(env, freetext_annotation->GetBounds(), converter);
+    // Find Java FreeTextAnnotation class.
+    static jclass freetext_annotation_class = GetPermClassRef(env, kFreeTextAnnotation);
+    // Get Constructor Id.
+    static jmethodID init = env->GetMethodID(freetext_annotation_class, "<init>",
+                                             funcsig("V", kRectF, kString).c_str());
+
+    // Get Java String for text content.
+    jobject java_string = ToJavaString(env, freetext_annotation->GetTextContent());
+    // Create Java FreeTextAnnotation Object.
+    jobject java_freetext_annotation =
+            env->NewObject(freetext_annotation_class, init, java_bounds, java_string);
+
+    // Set Text color.
+    static jmethodID set_text_color =
+            env->GetMethodID(freetext_annotation_class, "setTextColor", funcsig("V", "I").c_str());
+    // call setTextColor
+    env->CallVoidMethod(java_freetext_annotation, set_text_color,
+                        ToJavaColorInt(freetext_annotation->GetTextColor()));
+
+    // Set Background color.
+    static jmethodID set_background_color = env->GetMethodID(
+            freetext_annotation_class, "setBackgroundColor", funcsig("V", "I").c_str());
+    // call setBackgroundColor
+    env->CallVoidMethod(java_freetext_annotation, set_background_color,
+                        ToJavaColorInt(freetext_annotation->GetBackgroundColor()));
+
+    return java_freetext_annotation;
+}
+
+jobject ToJavaPageAnnotation(JNIEnv* env, const Annotation* annotation,
+                             ICoordinateConverter* converter) {
+    if (!annotation) {
+        return NULL;
+    }
+
+    jobject java_annotation = nullptr;
+
+    switch (annotation->GetType()) {
+        case Annotation::Type::Stamp: {
+            java_annotation = ToJavaStampAnnotation(env, annotation, converter);
+            break;
+        }
+        case Annotation::Type::Highlight: {
+            java_annotation = ToJavaHighlightAnnotation(env, annotation, converter);
+            break;
+        }
+        case Annotation::Type::FreeText: {
+            java_annotation = ToJavaFreeTextAnnotation(env, annotation, converter);
+            break;
+        }
+        default:
+            break;
+    }
+
+    return java_annotation;
+}
+
+std::unique_ptr<Annotation> ToNativeStampAnnotation(JNIEnv* env, jobject java_annotation,
+                                                    ICoordinateConverter* converter) {
+    // Get Ref to Java StampAnnotation Class.
+    static jclass stamp_annotation_class = GetPermClassRef(env, kStampAnnotation);
+
+    jmethodID get_bounds =
+            env->GetMethodID(stamp_annotation_class, "getBounds", funcsig(kRectF).c_str());
+    jobject java_bounds = env->CallObjectMethod(java_annotation, get_bounds);
+    Rectangle_f native_bounds = ToNativeRectF(env, java_bounds, converter);
+
+    // Create StampAnnotation Instance.
+    auto stamp_annotation = std::make_unique<StampAnnotation>(native_bounds);
+
+    // Get PdfPageObjects from stamp annotation
+    static jmethodID get_objects =
+            env->GetMethodID(stamp_annotation_class, "getObjects", funcsig(kList).c_str());
+    jobject java_page_objects = env->CallObjectMethod(java_annotation, get_objects);
+
+    jclass list_class = env->FindClass(kList);
+    jmethodID size_method = env->GetMethodID(list_class, "size", funcsig("I").c_str());
+    jmethodID get_method = env->GetMethodID(list_class, "get", funcsig(kObject, "I").c_str());
+
+    jint listSize = env->CallIntMethod(java_page_objects, size_method);
+    for (int i = 0; i < listSize; i++) {
+        jobject java_page_object = env->CallObjectMethod(java_page_objects, get_method, i);
+        std::unique_ptr<PageObject> native_page_object =
+                ToNativePageObject(env, java_page_object, converter);
+        stamp_annotation->AddObject(std::move(native_page_object));
+    }
+    return stamp_annotation;
+}
+
+std::unique_ptr<Annotation> ToNativeHighlightAnnotation(JNIEnv* env, jobject java_annotation,
+                                                        ICoordinateConverter* converter) {
+    // Get Ref to Java HighlightAnnotation Class.
+    static jclass highlight_annotation_class = GetPermClassRef(env, kHighlightAnnotation);
+
+    jmethodID get_bounds =
+            env->GetMethodID(highlight_annotation_class, "getBounds", funcsig(kList).c_str());
+    jobject java_bounds = env->CallObjectMethod(java_annotation, get_bounds);
+
+    vector<Rectangle_f> native_bounds;
+
+    jclass list_class = env->FindClass(kList);
+    jmethodID size_method = env->GetMethodID(list_class, "size", funcsig("I").c_str());
+    jmethodID get_method = env->GetMethodID(list_class, "get", funcsig(kObject, "I").c_str());
+
+    jint listSize = env->CallIntMethod(java_bounds, size_method);
+    for (int i = 0; i < listSize; i++) {
+        jobject java_bound = env->CallObjectMethod(java_bounds, get_method, i);
+        Rectangle_f native_bound = ToNativeRectF(env, java_bound, converter);
+        native_bounds.push_back(native_bound);
+    }
+
+    // Create HighlightAnnotation Instance.
+    auto highlight_annotation = std::make_unique<HighlightAnnotation>(native_bounds);
+
+    // Get and set highlight color
+
+    // Get methodId for getColor
+    static jmethodID get_color =
+            env->GetMethodID(highlight_annotation_class, "getColor", funcsig("I").c_str());
+    jint java_color_int = env->CallIntMethod(java_annotation, get_color);
+
+    highlight_annotation->SetColor(ToNativeColor(java_color_int));
+
+    return highlight_annotation;
+}
+
+std::unique_ptr<Annotation> ToNativeFreeTextAnnotation(JNIEnv* env, jobject java_annotation,
+                                                       ICoordinateConverter* converter) {
+    // Get Ref to Java FreeTextAnnotation Class.
+    static jclass freetext_annotation_class = GetPermClassRef(env, kFreeTextAnnotation);
+
+    jmethodID get_bounds =
+            env->GetMethodID(freetext_annotation_class, "getBounds", funcsig(kRectF).c_str());
+    jobject java_bounds = env->CallObjectMethod(java_annotation, get_bounds);
+    Rectangle_f native_bounds = ToNativeRectF(env, java_bounds, converter);
+
+    // Create FreeTextAnnotation Instance.
+    auto freetext_annotation = std::make_unique<FreeTextAnnotation>(native_bounds);
+
+    // Get the TextContent from Java layer.
+    static jmethodID get_text_content =
+            env->GetMethodID(freetext_annotation_class, "getTextContent", funcsig(kString).c_str());
+    auto java_text_content =
+            static_cast<jstring>(env->CallObjectMethod(java_annotation, get_text_content));
+
+    // Set the TextContent
+    std::wstring native_text_content = ToNativeWideString(env, java_text_content);
+    freetext_annotation->SetTextContent(native_text_content);
+
+    // Get the text color
+    static jmethodID get_text_color =
+            env->GetMethodID(freetext_annotation_class, "getTextColor", funcsig("I").c_str());
+    jint java_text_color_int = env->CallIntMethod(java_annotation, get_text_color);
+
+    freetext_annotation->SetTextColor(ToNativeColor(java_text_color_int));
+
+    // Get the background color
+    static jmethodID get_background_color =
+            env->GetMethodID(freetext_annotation_class, "getBackgroundColor", funcsig("I").c_str());
+    jint java_background_color_int = env->CallIntMethod(java_annotation, get_background_color);
+
+    freetext_annotation->SetBackgroundColor(ToNativeColor(java_background_color_int));
+
+    return freetext_annotation;
+}
+
+std::unique_ptr<Annotation> ToNativePageAnnotation(JNIEnv* env, jobject java_annotation,
+                                                   ICoordinateConverter* converter) {
+    // Find Java PdfAnnotation class and GetType
+    static jclass annotation_class = GetPermClassRef(env, kPdfAnnotation);
+    static jmethodID get_type =
+            env->GetMethodID(annotation_class, "getPdfAnnotationType", funcsig("I").c_str());
+    jint annotation_type = env->CallIntMethod(java_annotation, get_type);
+
+    std::unique_ptr<Annotation> annotation = nullptr;
+
+    switch (static_cast<Annotation::Type>(annotation_type)) {
+        case Annotation::Type::Stamp: {
+            annotation = ToNativeStampAnnotation(env, java_annotation, converter);
+            break;
+        }
+        case Annotation::Type::Highlight: {
+            annotation = ToNativeHighlightAnnotation(env, java_annotation, converter);
+            break;
+        }
+        case Annotation::Type::FreeText: {
+            annotation = ToNativeFreeTextAnnotation(env, java_annotation, converter);
+            break;
+        }
+        default:
+            break;
+    }
+
+    return annotation;
+}
+
 }  // namespace convert
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/jni_conversion.h b/pdf/framework/libs/pdfClient/jni_conversion.h
index 51d8a8b57..30b784250 100644
--- a/pdf/framework/libs/pdfClient/jni_conversion.h
+++ b/pdf/framework/libs/pdfClient/jni_conversion.h
@@ -25,13 +25,22 @@
 #include "file.h"
 #include "form_widget_info.h"
 #include "page.h"
+#include "page_object.h"
+#include "path_object.h"
 #include "rect.h"
 
+using pdfClient::Annotation;
+using pdfClient::Color;
 using pdfClient::Document;
 using pdfClient::FormWidgetInfo;
 using pdfClient::GotoLink;
 using pdfClient::GotoLinkDest;
+using pdfClient::ICoordinateConverter;
+using pdfClient::Matrix;
 using pdfClient::Option;
+using pdfClient::PageObject;
+using pdfClient::PathObject;
+using pdfClient::Point_f;
 using pdfClient::Rectangle_i;
 using pdfClient::SelectionBoundary;
 using pdfClient::Status;
@@ -108,6 +117,35 @@ jobject ToJavaGotoLink(JNIEnv* env, const GotoLink link);
 
 jobject ToJavaGotoLinks(JNIEnv* env, const vector<GotoLink>& links);
 
+jobject ToJavaColor(JNIEnv* env, Color color);
+
+jfloatArray ToJavaFloatArray(JNIEnv* env, const float arr[], size_t length);
+
+jobject ToJavaMatrix(JNIEnv* env, const Matrix matrix);
+
+jobject ToJavaPath(JNIEnv* env, const std::vector<PathObject::Segment>& segments,
+                   ICoordinateConverter* converter);
+
+jobject ToJavaPdfPageObject(JNIEnv* env, const PageObject* page_object,
+                            ICoordinateConverter* converter);
+
+jobject ToJavaPdfPageObjects(JNIEnv* env, const vector<PageObject*>& page_objects,
+                             ICoordinateConverter* converter);
+
+Color ToNativeColor(JNIEnv* env, jobject java_color);
+
+std::unique_ptr<PageObject> ToNativePageObject(JNIEnv* env, jobject java_page_object,
+                                               ICoordinateConverter* converter);
+
+jobject ToJavaPageAnnotations(JNIEnv* env, const vector<Annotation*>& annotations,
+                              ICoordinateConverter* converter);
+
+jobject ToJavaPageAnnotation(JNIEnv* env, const Annotation* annotation,
+                             ICoordinateConverter* converter);
+
+std::unique_ptr<Annotation> ToNativePageAnnotation(JNIEnv* env, jobject java_annotation,
+                                                   ICoordinateConverter* converter);
+
 }  // namespace convert
 
 #endif  // MEDIAPROVIDER_PDF_JNI_CONVERSION_H_
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/page.cc b/pdf/framework/libs/pdfClient/page.cc
index b7db016e1..faa84b34b 100644
--- a/pdf/framework/libs/pdfClient/page.cc
+++ b/pdf/framework/libs/pdfClient/page.cc
@@ -32,15 +32,19 @@
 #include "fpdf_doc.h"
 #include "fpdf_text.h"
 #include "fpdfview.h"
+#include "image_object.h"
 #include "logging.h"
 #include "normalize.h"
+#include "path_object.h"
 #include "rect.h"
+#include "text_object.h"
 #include "utf.h"
 #include "utils/annot_hider.h"
 #include "utils/text.h"
 
 #define LOG_TAG "page"
 
+using pdfClient::Rectangle_f;
 using std::vector;
 
 namespace pdfClient {
@@ -137,6 +141,22 @@ Point_d Page::UnapplyPageTransform(const Point_i& input) const {
     return output;
 }
 
+Point_f Page::PageToDevice(const Point_f& in) const {
+    // Get Device Coordinates from Page Coordinates
+    Point_i out;
+    FPDF_PageToDevice(page_.get(), 0, 0, Width(), Height(), 0, in.x, in.y, &out.x, &out.y);
+
+    return {static_cast<float>(out.x), static_cast<float>(out.y)};
+}
+
+Point_f Page::DeviceToPage(const Point_f& in) const {
+    // Get Page Coordinates from Device Coordinates
+    Point_d out;
+    FPDF_DeviceToPage(page_.get(), 0, 0, Width(), Height(), 0, in.x, in.y, &out.x, &out.y);
+
+    return {static_cast<float>(out.x), static_cast<float>(out.y)};
+}
+
 int Page::NumChars() {
     return FPDFText_CountChars(text_page());
 }
@@ -428,10 +448,79 @@ Rectangle_i Page::ConsumeInvalidRect() {
     return copy;
 }
 
-void* Page::page() {
+void* Page::Get() {
     return page_.get();
 }
 
+std::vector<PageObject*> Page::GetPageObjects(bool refetch) {
+    PopulatePageObjects(refetch);
+
+    std::vector<PageObject*> page_objects;
+    for (const auto& page_object : page_objects_) {
+        page_objects.push_back(page_object.get());
+    }
+
+    return page_objects;
+}
+
+int Page::AddPageObject(std::unique_ptr<PageObject> pageObject) {
+    // Create a scoped PDFium page object.
+    ScopedFPDFPageObject scoped_page_object(pageObject->CreateFPDFInstance(document_, page_.get()));
+
+    // Check if a FPDF page object was created.
+    if (!scoped_page_object) {
+        return -1;
+    }
+
+    // Insert the FPDF page object into the FPDF page.
+    FPDFPage_InsertObject(page_.get(), scoped_page_object.release());
+    FPDFPage_GenerateContent(page_.get());
+
+    // Add pageObject in stored list if populated.
+    if (!page_objects_.empty()) {
+        page_objects_.push_back(std::move(pageObject));
+    }
+
+    return FPDFPage_CountObjects(page_.get()) - 1;
+}
+
+bool Page::RemovePageObject(int index) {
+    FPDF_PAGEOBJECT page_object = FPDFPage_GetObject(page_.get(), index);
+    // Remove FPDF PageObject
+    if (!FPDFPage_RemoveObject(page_.get(), page_object)) {
+        return false;
+    }
+
+    FPDFPageObj_Destroy(page_object);
+    FPDFPage_GenerateContent(page_.get());
+
+    // Remove pageObject from stored list if populated.
+    if (!page_objects_.empty()) {
+        page_objects_.erase(page_objects_.begin() + index);
+    }
+
+    return true;
+}
+
+bool Page::UpdatePageObject(int index, std::unique_ptr<PageObject> pageObject) {
+    // Check for valid index
+    if (index < 0 || index >= FPDFPage_CountObjects(page_.get())) {
+        return false;
+    }
+
+    // Get PDFium PageObject.
+    FPDF_PAGEOBJECT page_object = FPDFPage_GetObject(page_.get(), index);
+
+    // Update PDFium PageObject
+    if (!pageObject->UpdateFPDFInstance(page_object, page_.get())) {
+        return false;
+    }
+
+    FPDFPage_GenerateContent(page_.get());
+
+    return true;
+}
+
 FPDF_TEXTPAGE Page::text_page() {
     EnsureTextPageInitialized();
     return text_page_.get();
@@ -455,6 +544,9 @@ void Page::EnsureTextPageInitialized() {
         // Page should never be null but a partner has an unexplained bug b/376796346
         LOGE("Null page (err=%lu). for (page_num=%d)", FPDF_GetLastError(), page_num_);
         // since the text_page_ would not have a page to load from
+        // Initialize variables to -1, otherwise they carry over garbage values.
+        first_printable_char_index_ = -1;
+        last_printable_char_index_ = -1;
         return;
     }
 
@@ -462,6 +554,9 @@ void Page::EnsureTextPageInitialized() {
     if (!text_page_) {
         // This will get into infinite recursion if not returned - b/376796346
         LOGE("Failed to load text (err=%lu). for (page_num=%d)", FPDF_GetLastError(), page_num_);
+        // Initialize variables to -1, otherwise they carry over garbage values.
+        first_printable_char_index_ = -1;
+        last_printable_char_index_ = -1;
         return;
     }
 
@@ -696,4 +791,198 @@ bool Page::IsUrlLink(FPDF_LINK link) const {
     return action != nullptr && FPDFAction_GetType(action) == PDFACTION_URI;
 }
 
+void Page::PopulatePageObjects(bool refetch) {
+    if (!refetch && !page_objects_.empty()) {
+        return;
+    }
+
+    int object_count = FPDFPage_CountObjects(page_.get());
+    // Resize PageObjects
+    page_objects_.resize(object_count);
+
+    for (int index = 0; index < object_count; ++index) {
+        FPDF_PAGEOBJECT page_object = FPDFPage_GetObject(page_.get(), index);
+        int type = FPDFPageObj_GetType(page_object);
+
+        // Pointer to PageObject
+        std::unique_ptr<PageObject> page_object_ = nullptr;
+
+        switch (type) {
+            case FPDF_PAGEOBJ_TEXT: {
+                page_object_ = std::make_unique<TextObject>();
+                break;
+            }
+            case FPDF_PAGEOBJ_PATH: {
+                page_object_ = std::make_unique<PathObject>();
+                break;
+            }
+            case FPDF_PAGEOBJ_IMAGE: {
+                page_object_ = std::make_unique<ImageObject>();
+                break;
+            }
+            default:
+                break;
+        }
+
+        // Populate PageObject From Page
+        if (page_object_ && page_object_->PopulateFromFPDFInstance(page_object, page_.get())) {
+            page_objects_[index] = std::move(page_object_);
+        }
+    }
+}
+
+std::vector<Annotation*> Page::GetPageAnnotations() {
+    PopulateAnnotations();
+
+    std::vector<Annotation*> result;
+
+    result.reserve(annotations_.size());
+    for (const auto& annotation : annotations_) {
+        result.push_back(annotation.get());
+    }
+
+    return result;
+}
+
+void Page::PopulateAnnotations() {
+    // If page_ is null
+    if (!page_) {
+        LOGE("Page is null");
+        return;
+    }
+
+    int num_of_annotations = FPDFPage_GetAnnotCount(page_.get());
+    annotations_.resize(num_of_annotations);
+
+    for (int annotation_index = 0; annotation_index < num_of_annotations; annotation_index++) {
+        ScopedFPDFAnnotation scoped_annot(FPDFPage_GetAnnot(page_.get(), annotation_index));
+        int annotationType = FPDFAnnot_GetSubtype(scoped_annot.get());
+
+        std::unique_ptr<Annotation> annotation = nullptr;
+
+        switch (annotationType) {
+            case FPDF_ANNOT_STAMP: {
+                FS_RECTF rect;
+                if (!FPDFAnnot_GetRect(scoped_annot.get(), &rect)) {
+                    LOGE("Failed to get the bounds of the annotation");
+                    break;
+                }
+                auto bounds = Rectangle_f{rect.left, rect.top, rect.right, rect.bottom};
+                annotation = std::make_unique<StampAnnotation>(bounds);
+                break;
+            }
+            case FPDF_ANNOT_HIGHLIGHT: {
+                vector<Rectangle_f> bounds;
+                auto num_bounds = FPDFAnnot_CountAttachmentPoints(scoped_annot.get());
+                if (num_bounds > 0) {
+                    bounds.resize(num_bounds);
+                    for (auto bound_index = 0; bound_index < num_bounds; bound_index++) {
+                        FS_QUADPOINTSF quad_points;
+                        if (!FPDFAnnot_GetAttachmentPoints(scoped_annot.get(), bound_index,
+                                                           &quad_points)) {
+                            LOGD("Failed to get quad points from pdfium");
+                            break;
+                        }
+
+                        bounds[bound_index] = Rectangle_f(quad_points.x1, quad_points.y1,
+                                                          quad_points.x2, quad_points.y4);
+                    }
+                } else {
+                    LOGD("Failed to find bounds for highlight annotation");
+                }
+                annotation = std::make_unique<HighlightAnnotation>(bounds);
+                break;
+            }
+            case FPDF_ANNOT_FREETEXT: {
+                FS_RECTF rect;
+                if (!FPDFAnnot_GetRect(scoped_annot.get(), &rect)) {
+                    LOGE("Failed to get the bounds of the annotation");
+                    break;
+                }
+                auto bounds = Rectangle_f{rect.left, rect.top, rect.right, rect.bottom};
+                annotation = std::make_unique<FreeTextAnnotation>(bounds);
+                break;
+            }
+            default: {
+                break;
+            }
+        }
+
+        if (!annotation ||
+            !annotation->PopulateFromPdfiumInstance(scoped_annot.get(), page_.get())) {
+            LOGE("Failed to create a pdfClient's instance of annotation using pdfium "
+                 "instance");
+        }
+
+        annotations_[annotation_index] = std::move(annotation);
+    }
+}
+
+int Page::AddPageAnnotation(std::unique_ptr<Annotation> annotation) {
+    ScopedFPDFAnnotation scoped_annot = annotation->CreatePdfiumInstance(document_, page_.get());
+
+    if (!scoped_annot) {
+        LOGE("Failed to add the given annotation to the page");
+        return -1;
+    }
+
+    FPDFPage_GenerateContent(page_.get());
+
+    // Add the object to the annotations_ list
+    annotations_.push_back(std::move(annotation));
+
+    // Return the index of added annotation
+    return FPDFPage_GetAnnotIndex(page_.get(), scoped_annot.get());
+}
+
+bool Page::RemovePageAnnotation(int index) {
+    PopulateAnnotations();
+    if (index >= annotations_.size() || index < 0) {
+        LOGE("Given index is out range for number of annotations on this page");
+        return false;
+    }
+    // Remove the annotation at given index
+    if (!FPDFPage_RemoveAnnot(page_.get(), index)) {
+        LOGE("Failed to remove the annotation at index - %d ", index);
+        return false;
+    }
+
+    FPDFPage_GenerateContent(page_.get());
+
+    // Remove from annotations_ list
+    annotations_.erase(annotations_.begin() + index);
+
+    return true;
+}
+
+bool Page::UpdatePageAnnotation(int index, std::unique_ptr<Annotation> annotation) {
+    PopulateAnnotations();
+    // Check for valid index
+    if (index < 0 || index >= annotations_.size()) {
+        return false;
+    }
+
+    // check if there in an annotation of supported type at given index
+    if (annotations_[index] == nullptr) {
+        return false;
+    }
+
+    // Get the pdfium annotation
+    ScopedFPDFAnnotation scoped_annot = ScopedFPDFAnnotation(FPDFPage_GetAnnot(page_.get(), index));
+
+    if (!scoped_annot) {
+        LOGE("Failed to get pdfium annotation's instance");
+        return false;
+    }
+
+    if (!annotation->UpdatePdfiumInstance(scoped_annot.get(), document_, page_.get())) {
+        LOGE("Failed to update pdfium annotation's instance");
+        return false;
+    }
+
+    FPDFPage_GenerateContent(page_.get());
+
+    return true;
+}
+
 }  // namespace pdfClient
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/page.h b/pdf/framework/libs/pdfClient/page.h
index 02de344c2..cc73a1f52 100644
--- a/pdf/framework/libs/pdfClient/page.h
+++ b/pdf/framework/libs/pdfClient/page.h
@@ -26,10 +26,12 @@
 #include <utility>
 #include <vector>
 
+#include "annotation.h"
 #include "cpp/fpdf_scopers.h"
 #include "form_filler.h"
 #include "form_widget_info.h"
 #include "fpdfview.h"
+#include "page_object.h"
 #include "rect.h"
 
 namespace pdfClient {
@@ -39,12 +41,18 @@ namespace pdfClient {
 // LINT.IfChange
 static const int FLAG_RENDER_TEXT_ANNOTATIONS = 1 << 1;
 static const int FLAG_RENDER_HIGHLIGHT_ANNOTATIONS = 1 << 2;
+static const int FLAG_RENDER_STAMP_ANNOTATIONS = 1 << 3;
+static const int FLAG_RENDER_FREETEXT_ANNOTATIONS = 1 << 4;
 // LINT.ThenChange(packages/providers/MediaProvider/pdf/framework/java/android/graphics/pdf/RenderParams.java)
 
 static const std::unordered_map<int, std::vector<int>> renderFlagsAnnotsMap = {
-        {FLAG_RENDER_TEXT_ANNOTATIONS, std::vector<int>{FPDF_ANNOT_TEXT, FPDF_ANNOT_FREETEXT}},
-        {FLAG_RENDER_HIGHLIGHT_ANNOTATIONS, std::vector<int>{FPDF_ANNOT_HIGHLIGHT}}};
-
+        {FLAG_RENDER_TEXT_ANNOTATIONS,
+         std::vector<int>{
+                 FPDF_ANNOT_TEXT,
+                 FPDF_ANNOT_FREETEXT}},  // TODO Remove FreeText from FLAG_RENDER_TEXT_ANNOTATIONS
+        {FLAG_RENDER_HIGHLIGHT_ANNOTATIONS, std::vector<int>{FPDF_ANNOT_HIGHLIGHT}},
+        {FLAG_RENDER_STAMP_ANNOTATIONS, std::vector<int>{FPDF_ANNOT_STAMP}},
+        {FLAG_RENDER_FREETEXT_ANNOTATIONS, std::vector<int>{FPDF_ANNOT_FREETEXT}}};
 // A start index (inclusive) and a stop index (exclusive) into the string of
 // codepoints that make up a range of text.
 typedef std::pair<int, int> TextRange;
@@ -80,8 +88,20 @@ struct GotoLink {
     GotoLinkDest dest;
 };
 
+// Interface for converting coordinates between two spaces.
+class ICoordinateConverter {
+  public:
+    virtual ~ICoordinateConverter() = default;
+
+    // Convert a point from page coordinates to device coordinates
+    virtual Point_f PageToDevice(const Point_f& in) const = 0;
+
+    // Convert a point from device coordinates to page coordinates
+    virtual Point_f DeviceToPage(const Point_f& in) const = 0;
+};
+
 // Wrapper on a FPDF_PAGE that adds rendering functionality.
-class Page {
+class Page : public ICoordinateConverter {
   public:
     // FPDF_PAGE is opened when constructed.
     Page(FPDF_DOCUMENT doc, int page_num, FormFiller* form_filler);
@@ -114,6 +134,11 @@ class Page {
     // back into the page's internal co-ordinate system.
     Point_d UnapplyPageTransform(const Point_i& input) const;
 
+    // ICoordinate Converter
+    Point_f PageToDevice(const Point_f& in) const override;
+
+    Point_f DeviceToPage(const Point_f& in) const override;
+
     int NumChars();
 
     uint32_t GetUnicode(int char_index);
@@ -184,7 +209,7 @@ class Page {
     // Obtain form widget information for all form field annotations on the page,
     // optionally restricting by |type_ids| and store in |widget_infos|. See
     // fpdf_formfill.h for type constants. If |type_ids| is empty all form
-    // widgets on |page| will be added to |widget_infos|, if any.
+    // widgets on page will be added to |widget_infos|, if any.
     void GetFormWidgetInfos(const std::unordered_set<int>& type_ids,
                             std::vector<FormWidgetInfo>* widget_infos);
 
@@ -219,7 +244,34 @@ class Page {
     // Returns FPDF_PAGE. This Page retains ownership. All operations that wish
     // to access FPDF_PAGE should to call methods of this class instead of
     // requesting the FPDF_PAGE directly through this method.
-    void* page();
+    void* Get();
+
+    // Get all PageObjects on this Page. Ownership of PageObjects is with Page.
+    std::vector<PageObject*> GetPageObjects(bool refetch = false);
+
+    // Add PageObject to Page.
+    int AddPageObject(std::unique_ptr<PageObject> page_object);
+
+    // Remove PageObject on Page.
+    bool RemovePageObject(int index);
+
+    // Update the attributes of the PageObject on the Page. Ownership stays with
+    // the Page, we only modify the PageObject's attributes.
+    bool UpdatePageObject(int index, std::unique_ptr<PageObject> page_object);
+
+    // Get all supported annotations. The list will contain null for the types of annotations
+    // which are not supported. Page will have ownership of annotations
+    std::vector<Annotation*> GetPageAnnotations();
+
+    // Add an annotation to the page
+    int AddPageAnnotation(std::unique_ptr<Annotation> annotation);
+
+    // Remove the annotation from the page at a given index
+    bool RemovePageAnnotation(int index);
+
+    // Update the attributes of the annotation on the Page. Ownership stays with
+    // the Page, we only modify the Annotation's attributes.
+    bool UpdatePageAnnotation(int index, std::unique_ptr<Annotation> annotation);
 
   private:
     // Convenience methods to access the variables dependent on an initialized
@@ -326,6 +378,17 @@ class Page {
 
     // Page number that is opened.
     int page_num_;
+
+    // Page Objects
+    std::vector<std::unique_ptr<PageObject>> page_objects_;
+
+    // Populates page_objects_ with PageObjects on Page.
+    void PopulatePageObjects(bool refetch);
+
+    // Annotations
+    std::vector<std::unique_ptr<Annotation>> annotations_;
+
+    void PopulateAnnotations();
 };
 
 }  // namespace pdfClient
diff --git a/pdf/framework/libs/pdfClient/page_object.cc b/pdf/framework/libs/pdfClient/page_object.cc
new file mode 100644
index 000000000..c8cfd8313
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/page_object.cc
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "page_object.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "cpp/fpdf_scopers.h"
+#include "fpdf_edit.h"
+#include "fpdfview.h"
+#include "logging.h"
+#include "rect.h"
+
+#define LOG_TAG "page_object"
+
+namespace pdfClient {
+
+PageObject::PageObject(Type type) : type_(type) {}
+
+PageObject::Type PageObject::GetType() const {
+    return type_;
+}
+
+bool PageObject::GetPageToDeviceMatrix(FPDF_PAGEOBJECT page_object, FPDF_PAGE page) {
+    Matrix page_matrix;
+    if (!FPDFPageObj_GetMatrix(page_object, reinterpret_cast<FS_MATRIX*>(&page_matrix))) {
+        LOGE("GetPageMatrix failed!");
+        return false;
+    }
+
+    // Set identity transformation for GetBounds.
+    Matrix identity = {1, 0, 0, 1, 0, 0};
+    FPDFPageObj_SetMatrix(page_object, reinterpret_cast<FS_MATRIX*>(&identity));
+
+    // Get Bounds.
+    Rectangle_f bounds;
+    FPDFPageObj_GetBounds(page_object, &bounds.left, &bounds.bottom, &bounds.right, &bounds.top);
+
+    // Reset the original page matrix.
+    FPDFPageObj_SetMatrix(page_object, reinterpret_cast<FS_MATRIX*>(&page_matrix));
+
+    float page_height = FPDF_GetPageHeightF(page);
+
+    // Page to device matrix.
+    device_matrix_.a = page_matrix.a;
+    device_matrix_.b = (page_matrix.b != 0) ? -page_matrix.b : 0;
+    device_matrix_.c = (page_matrix.c != 0) ? -page_matrix.c : 0;
+    device_matrix_.d = page_matrix.d;
+    device_matrix_.e = page_matrix.e + ((bounds.top + bounds.bottom) * page_matrix.c);
+    device_matrix_.f = page_height - page_matrix.f - ((bounds.top + bounds.bottom) * page_matrix.d);
+
+    return true;
+}
+
+bool PageObject::SetDeviceToPageMatrix(FPDF_PAGEOBJECT page_object, FPDF_PAGE page) {
+    // Reset Previous Transformation.
+    Matrix identity = {1, 0, 0, 1, 0, 0};
+    if (!FPDFPageObj_SetMatrix(page_object, reinterpret_cast<FS_MATRIX*>(&identity))) {
+        LOGE("SetMatrix failed!");
+        return false;
+    }
+
+    Rectangle_f bounds;
+    FPDFPageObj_GetBounds(page_object, &bounds.left, &bounds.bottom, &bounds.right, &bounds.top);
+
+    float page_height = FPDF_GetPageHeightF(page);
+
+    FPDFPageObj_Transform(page_object, 1, 0, 0, 1, 0, -(bounds.top + bounds.bottom));
+    FPDFPageObj_Transform(page_object, device_matrix_.a, -device_matrix_.b, -device_matrix_.c,
+                          device_matrix_.d, device_matrix_.e, -device_matrix_.f);
+    FPDFPageObj_Transform(page_object, 1, 0, 0, 1, 0, page_height);
+
+    return true;
+}
+
+PageObject::~PageObject() = default;
+
+}  // namespace pdfClient
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/page_object.h b/pdf/framework/libs/pdfClient/page_object.h
new file mode 100644
index 000000000..50df89616
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/page_object.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIAPROVIDER_PDF_JNI_PDFCLIENT_PAGE_OBJECT_H_
+#define MEDIAPROVIDER_PDF_JNI_PDFCLIENT_PAGE_OBJECT_H_
+
+#include <stdint.h>
+
+#include <algorithm>
+
+#include "cpp/fpdf_scopers.h"
+#include "fpdfview.h"
+
+typedef unsigned int uint;
+
+namespace pdfClient {
+
+struct Color {
+    uint r;
+    uint g;
+    uint b;
+    uint a;
+
+    Color() : Color(0, 0, 0, 255) {}
+    Color(uint r, uint g, uint b, uint a) : r(r), g(g), b(b), a(a) {}
+
+    bool operator==(const Color& other) const {
+        return r == other.r && g == other.g && b == other.b && a == other.a;
+    }
+};
+
+struct Matrix {
+    float a;
+    float b;
+    float c;
+    float d;
+    float e;
+    float f;
+
+    Matrix() {}
+    Matrix(float a, float b, float c, float d, float e, float f)
+        : a(a), b(b), c(c), d(d), e(e), f(f) {}
+
+    bool operator==(const Matrix& other) const {
+        return a == other.a && b == other.b && c == other.c && d == other.d && e == other.e &&
+               f == other.f;
+    }
+
+    float operator-(const Matrix& other) const {
+        return std::max({abs(a - other.a), abs(b - other.b), abs(c - other.c), abs(d - other.d),
+                         abs(e - other.e), abs(f - other.f)});
+    }
+};
+
+class PageObject {
+  public:
+    enum class Type {
+        Unknown = 0,
+        Text = 1,
+        Path = 2,
+        Image = 3,
+    };
+
+    Type GetType() const;
+    // Returns a FPDF Instance for a PageObject.
+    virtual ScopedFPDFPageObject CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) = 0;
+    // Updates the FPDF Instance of PageObject present on Page.
+    virtual bool UpdateFPDFInstance(FPDF_PAGEOBJECT page_object, FPDF_PAGE page) = 0;
+    // Populates data from FPDFInstance of PageObject present on Page.
+    virtual bool PopulateFromFPDFInstance(FPDF_PAGEOBJECT page_object, FPDF_PAGE page) = 0;
+
+    virtual ~PageObject();
+
+    Matrix device_matrix_;  // Matrix used to scale, rotate, shear and translate the page object.
+    Color fill_color_;
+    Color stroke_color_;
+    float stroke_width_ = 1.0f;
+
+  protected:
+    PageObject(Type type = Type::Unknown);
+
+    virtual bool GetPageToDeviceMatrix(FPDF_PAGEOBJECT page_object, FPDF_PAGE page);
+    virtual bool SetDeviceToPageMatrix(FPDF_PAGEOBJECT page_object, FPDF_PAGE page);
+
+  private:
+    Type type_;
+};
+
+}  // namespace pdfClient
+
+#endif  // MEDIAPROVIDER_PDF_JNI_PDFCLIENT_PAGE_OBJECT_H_
diff --git a/pdf/framework/libs/pdfClient/page_test.cc b/pdf/framework/libs/pdfClient/page_test.cc
index 2d1d4ffcb..79dfeea84 100644
--- a/pdf/framework/libs/pdfClient/page_test.cc
+++ b/pdf/framework/libs/pdfClient/page_test.cc
@@ -25,19 +25,40 @@
 
 // Goes first due to conflicts.
 #include "document.h"
+#include "image_object.h"
+#include "page_object.h"
+#include "path_object.h"
 #include "rect.h"
+#include "text_object.h"
 // #include "file/base/path.h"
 #include "cpp/fpdf_scopers.h"
 #include "fpdfview.h"
 
 namespace {
 
+using ::pdfClient::Annotation;
+using ::pdfClient::Color;
+using ::pdfClient::CourierNew;
 using ::pdfClient::Document;
+using ::pdfClient::Font;
+using ::pdfClient::font_names;
+using ::pdfClient::FreeTextAnnotation;
+using ::pdfClient::Helvetica;
+using ::pdfClient::ImageObject;
+using ::pdfClient::Matrix;
 using ::pdfClient::Page;
+using ::pdfClient::PageObject;
+using ::pdfClient::PathObject;
 using ::pdfClient::Rectangle_i;
+using ::pdfClient::StampAnnotation;
+using ::pdfClient::Symbol;
+using ::pdfClient::TextObject;
+using ::pdfClient::TimesNewRoman;
 
 static const std::string kTestdata = "testdata";
 static const std::string kSekretNoPassword = "sekret_no_password.pdf";
+static const std::string kPageObject = "page_object.pdf";
+static const std::string kAnnotation = "annotation.pdf";
 
 std::string GetTestDataDir() {
     return android::base::GetExecutableDirectory();
@@ -180,7 +201,7 @@ TEST(Test, InvalidPageNumberTest) {
     // The above call succeeds and returns a non-null ptr.
     ASSERT_NE(nullptr, page);
     // Even though the underlying pointer is null.
-    ASSERT_EQ(nullptr, page->page());
+    ASSERT_EQ(nullptr, page->Get());
 
     // Rest of the calls should give some default values.
     EXPECT_EQ(-1, page->NumChars());
@@ -199,4 +220,511 @@ TEST(Test, InvalidPageNumberTest) {
     page->TerminateFormFilling();
 }
 
+TEST(Test, GetPageObjectsTest) {
+    Document doc(LoadTestDocument(kPageObject), false);
+
+    std::shared_ptr<Page> page = doc.GetPage(0);
+    std::vector<PageObject*> pageObjects = page->GetPageObjects();
+
+    // Check for PageObjects size.
+    ASSERT_EQ(3, pageObjects.size());
+    // Check for the first PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, pageObjects[0]->GetType());
+    // Check for the second PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, pageObjects[1]->GetType());
+    // Check for the third PageObject to be TextObject.
+    ASSERT_EQ(PageObject::Type::Text, pageObjects[2]->GetType());
+}
+
+TEST(Test, AddImagePageObjectTest) {
+    Document doc(LoadTestDocument(kPageObject), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    // Create Image Object.
+    auto imageObject = std::make_unique<ImageObject>();
+
+    // Create FPDF Bitmap.
+    imageObject->bitmap_ = ScopedFPDFBitmap(FPDFBitmap_Create(100, 100, 1));
+    FPDFBitmap_FillRect(imageObject->bitmap_.get(), 0, 0, 100, 100, 0xFF000000);
+
+    // Set Matrix.
+    imageObject->device_matrix_ = {1.0f, 0, 0, 1.0f, 0, 0};
+
+    // Add the page object.
+    ASSERT_EQ(page->AddPageObject(std::move(imageObject)), initialPageObjects.size());
+
+    // Get Updated PageObjects
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    // Assert that the size has increased by one.
+    ASSERT_EQ(initialPageObjects.size() + 1, updatedPageObjects.size());
+    // Check for the first PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, updatedPageObjects[0]->GetType());
+    // Check for the second PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, updatedPageObjects[1]->GetType());
+    // Check for the third PageObject to be TextObject.
+    ASSERT_EQ(PageObject::Type::Text, updatedPageObjects[2]->GetType());
+    // Check for the fourth PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, updatedPageObjects[3]->GetType());
+}
+
+TEST(Test, AddPathPageObject) {
+    Document doc(LoadTestDocument(kPageObject), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    // Create Path Object.
+    auto pathObject = std::make_unique<PathObject>();
+
+    // Command Simple Path
+    pathObject->segments_.emplace_back(PathObject::Segment::Command::Move, 0.0f, 0.0f);
+    pathObject->segments_.emplace_back(PathObject::Segment::Command::Line, 100.0f, 150.0f);
+    pathObject->segments_.emplace_back(PathObject::Segment::Command::Line, 150.0f, 150.0f);
+
+    // Set Draw Mode
+    pathObject->is_fill_ = false;
+    pathObject->is_stroke_ = true;
+
+    // Set PathObject Matrix.
+    pathObject->device_matrix_ = {1.0f, 0, 0, 1.0f, 0, 0};
+
+    // Add the page object.
+    ASSERT_EQ(page->AddPageObject(std::move(pathObject)), initialPageObjects.size());
+
+    // Get Updated PageObjects
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    // Assert that the size has increased by one.
+    ASSERT_EQ(initialPageObjects.size() + 1, updatedPageObjects.size());
+    // Check for the first PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, updatedPageObjects[0]->GetType());
+    // Check for the second PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, updatedPageObjects[1]->GetType());
+    // Check for the third PageObject to be TextObject.
+    ASSERT_EQ(PageObject::Type::Text, updatedPageObjects[2]->GetType());
+    // Check for the fourth PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, updatedPageObjects[3]->GetType());
+}
+
+TEST(Test, AddTextPageObject) {
+    Document doc(LoadTestDocument(kPageObject), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    int page_objects_size = initialPageObjects.size();
+
+    // Assert font_names vector contains font name as per right order.
+    ASSERT_EQ(font_names[0], CourierNew);
+    ASSERT_EQ(font_names[1], Helvetica);
+    ASSERT_EQ(font_names[2], Symbol);
+    ASSERT_EQ(font_names[3], TimesNewRoman);
+
+    for (int index = 0; index < font_names.size(); index++) {
+        // Create Text Object.
+        auto textObject = std::make_unique<TextObject>();
+
+        // Set Font.
+        textObject->font_ = Font(font_names[index], static_cast<Font::Family>(index), true, true);
+
+        // Set Font Size.
+        textObject->font_size_ = 10.0f;
+
+        // Set Text.
+        textObject->text_ = L"Hello World!";
+
+        // Set Text Render Mode.
+        textObject->render_mode_ = TextObject::RenderMode::Stroke;
+
+        // Set TextObject Color.
+        textObject->fill_color_ = Color(0, 0, 255, 255);
+
+        // Set TextObject Matrix.
+        textObject->device_matrix_ = {1.0f, 0, 0, 1.0f, 0, 0};
+
+        // Add the page object.
+        if (index != 2) {
+            ASSERT_EQ(page->AddPageObject(std::move(textObject)), page_objects_size++);
+        } else {
+            // Symbol-BoldItalic is not a font.
+            ASSERT_EQ(page->AddPageObject(std::move(textObject)), -1);
+        }
+    }
+
+    // Get Updated PageObjects
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    // Assert that the size has increased by three.
+    ASSERT_EQ(initialPageObjects.size() + 3, updatedPageObjects.size());
+    // Check for the first PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, updatedPageObjects[0]->GetType());
+    // Check for the second PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, updatedPageObjects[1]->GetType());
+    // Check for the third PageObject to be TextObject.
+    ASSERT_EQ(PageObject::Type::Text, updatedPageObjects[2]->GetType());
+    // Check for the added PageObjects to be TextObjects.
+    for (int index = 3; index < page_objects_size; index++) {
+        ASSERT_EQ(PageObject::Type::Text, updatedPageObjects[index]->GetType());
+    }
+}
+
+TEST(Test, RemovePageObjectTest) {
+    Document doc(LoadTestDocument(kPageObject), false);
+
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    // Remove a pageObject
+    EXPECT_TRUE(page->RemovePageObject(0));
+    // Get Updated PageObjects after removal
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    ASSERT_EQ(initialPageObjects.size() - 1, updatedPageObjects.size());
+}
+
+TEST(Test, UpdateImagePageObjectTest) {
+    Document doc(LoadTestDocument(kPageObject), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    // Get initial page objects.
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    // Create Image Object.
+    auto imageObject = std::make_unique<ImageObject>();
+
+    // Create FPDF Bitmap.
+    imageObject->bitmap_ = ScopedFPDFBitmap(FPDFBitmap_Create(100, 110, 1));
+    FPDFBitmap_FillRect(imageObject->bitmap_.get(), 0, 0, 100, 110, 0xFF0000FF);
+
+    // Set Matrix.
+    Matrix update_matrix = {2.0f, 3.0f, 4.0f, 2.0f, 1.0f, -2.0f};
+    imageObject->device_matrix_ = update_matrix;
+
+    // Update the page object.
+    EXPECT_TRUE(page->UpdatePageObject(0, std::move(imageObject)));
+
+    // Get the updated page objects.
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    // Check for size equality.
+    ASSERT_EQ(initialPageObjects.size(), updatedPageObjects.size());
+
+    // Check for updated bitmap.
+    ASSERT_EQ(FPDFBitmap_GetWidth(static_cast<ImageObject*>(updatedPageObjects[0])->bitmap_.get()),
+              100);
+    ASSERT_EQ(FPDFBitmap_GetHeight(static_cast<ImageObject*>(updatedPageObjects[0])->bitmap_.get()),
+              110);
+
+    // Check for updated matrix.
+    ASSERT_EQ(updatedPageObjects[0]->device_matrix_, update_matrix);
+}
+
+TEST(Test, UpdatePathPageObjectTest) {
+    Document doc(LoadTestDocument(kPageObject), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    // Get initial page objects.
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    // Create Path Object.
+    auto pathObject = std::make_unique<PathObject>();
+
+    // Update fill Color.
+    Color update_fill_color = Color(255, 0, 0, 255);
+    pathObject->fill_color_ = update_fill_color;
+
+    // Update Draw Mode.
+    pathObject->is_fill_ = true;
+    pathObject->is_stroke_ = false;
+
+    // Set Matrix.
+    Matrix update_matrix = {2.0f, -3.0f, 2.0f, 2.0f, -1.0f, 2.0f};
+    pathObject->device_matrix_ = update_matrix;
+
+    // Update the page object.
+    EXPECT_TRUE(page->UpdatePageObject(1, std::move(pathObject)));
+
+    // Get the updated page objects.
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    // Check for updated fill Color.
+    ASSERT_EQ(updatedPageObjects[1]->fill_color_, update_fill_color);
+
+    // Check for updated Draw Mode.
+    ASSERT_EQ(static_cast<PathObject*>(updatedPageObjects[1])->is_fill_, true);
+    ASSERT_EQ(static_cast<PathObject*>(updatedPageObjects[1])->is_stroke_, false);
+
+    // Check for updated matrix.
+    ASSERT_EQ(updatedPageObjects[1]->device_matrix_, update_matrix);
+}
+
+TEST(Test, UpdateTextPageObjectTest) {
+    Document doc(LoadTestDocument(kPageObject), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    // Get initial page objects.
+    std::vector<PageObject*> initialPageObjects = page->GetPageObjects();
+
+    // Check for third page object to be text object.
+    ASSERT_EQ(PageObject::Type::Text, initialPageObjects[2]->GetType());
+
+    // Check initial text object data.
+    TextObject* initialTextObject = static_cast<TextObject*>(initialPageObjects[2]);
+
+    // Check initial text.
+    ASSERT_EQ(initialTextObject->text_, L"Hello World");
+
+    // Check initial render mode.
+    ASSERT_EQ(initialTextObject->render_mode_, TextObject::RenderMode::Fill);
+
+    // Check for initial matrix.
+    Matrix initial_matrix(1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 759.424f);
+    ASSERT_LT(initialTextObject->device_matrix_ - initial_matrix, 0.01f);
+
+    // Check for initial fill color.
+    ASSERT_EQ(initialTextObject->fill_color_, Color(0, 255, 0, 255));
+
+    // Create Text Object.
+    auto textObject = std::make_unique<TextObject>();
+
+    // Update the text.
+    std::wstring update_text = L"Hello PDF!";
+    textObject->text_ = update_text;
+
+    // Set Text Render Mode.
+    textObject->render_mode_ = TextObject::RenderMode::FillStroke;
+
+    // Update text Color.
+    Color update_fill_color = Color(0, 0, 255, 255);
+    textObject->fill_color_ = update_fill_color;
+
+    // Set Matrix.
+    Matrix update_matrix = {2.0f, 5.0f, -2.0f, 3.0f, -4.0f, 10.0f};
+    textObject->device_matrix_ = update_matrix;
+
+    // Update the page object.
+    EXPECT_TRUE(page->UpdatePageObject(2, std::move(textObject)));
+
+    // Get the updated page objects.
+    std::vector<PageObject*> updatedPageObjects = page->GetPageObjects(true);
+
+    // Check for updated text.
+    ASSERT_EQ(static_cast<TextObject*>(updatedPageObjects[2])->text_, update_text);
+
+    // Check for updated text render mode.
+    ASSERT_EQ(static_cast<TextObject*>(updatedPageObjects[2])->render_mode_,
+              TextObject::RenderMode::FillStroke);
+
+    // Check for updated fill Color.
+    ASSERT_EQ(updatedPageObjects[2]->fill_color_, update_fill_color);
+
+    /*
+     *  TextObject Transformation is dependent upon its bounds values.
+     *  Pdfium calculation for bounds shows a little fluctuation which results
+     *  in return matrix values to be not exactly the same. We should tolerate
+     *  the difference which does not make any visible difference.
+     */
+    ASSERT_LT(updatedPageObjects[2]->device_matrix_ - update_matrix, 0.01f);
+}
+
+TEST(Test, GetPageAnnotationsTest) {
+    Document doc(LoadTestDocument(kAnnotation), false);
+
+    std::shared_ptr<Page> page = doc.GetPage(0);
+    std::vector<Annotation*> annotations = page->GetPageAnnotations();
+
+    // Check for number of annotations
+    ASSERT_EQ(1, annotations.size());
+
+    // Check for the first Annotation to be StampAnnotation.
+    ASSERT_EQ(Annotation::Type::Stamp, annotations[0]->GetType());
+
+    StampAnnotation* stamp_annotation = static_cast<StampAnnotation*>(annotations[0]);
+    std::vector<PageObject*> pageObjects = stamp_annotation->GetObjects();
+
+    // Check for number of page objects inside stamp annotation
+    ASSERT_EQ(2, pageObjects.size());
+
+    // Check for the first PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, pageObjects[0]->GetType());
+    // Check for the second PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, pageObjects[1]->GetType());
+}
+
+TEST(Test, AddStampAnnotationTest) {
+    Document doc(LoadTestDocument(kAnnotation), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<Annotation*> initialAnnotations = page->GetPageAnnotations();
+
+    // Bounds for stamp annotation
+    Rectangle_f bounds = pdfClient::Rectangle_f{0, 300, 200, 0};
+    // Create Stamp Annotation
+    auto stampAnnotation = std::make_unique<StampAnnotation>(bounds);
+
+    // Insert image page object
+    auto imageObject = std::make_unique<ImageObject>();
+
+    // Create FPDF Bitmap.
+    imageObject->bitmap_ = ScopedFPDFBitmap(FPDFBitmap_Create(100, 100, 1));
+    FPDFBitmap_FillRect(imageObject->bitmap_.get(), 0, 0, 100, 100, 0xFF000000);
+
+    // Set Matrix.
+    imageObject->device_matrix_ = {1.0f, 0, 0, 1.0f, 0, 0};
+
+    // Add the page object.
+    stampAnnotation->AddObject(std::move(imageObject));
+
+    // Create Path Object.
+    auto pathObject = std::make_unique<PathObject>();
+
+    // Command Simple Path
+    pathObject->segments_.emplace_back(PathObject::Segment::Command::Move, 0.0f, 0.0f);
+    pathObject->segments_.emplace_back(PathObject::Segment::Command::Line, 100.0f, 150.0f);
+    pathObject->segments_.emplace_back(PathObject::Segment::Command::Line, 150.0f, 150.0f);
+
+    // Set Draw Mode
+    pathObject->is_fill_ = false;
+    pathObject->is_stroke_ = true;
+
+    // Set PathObject Matrix.
+    pathObject->device_matrix_ = {1.0f, 2.0f, 3.0f, 1.0f, 3.0f, 2.0f};
+
+    // Add the page object.
+    stampAnnotation->AddObject(std::move(pathObject));
+
+    // Add the stamp annotation.
+    ASSERT_EQ(page->AddPageAnnotation(std::move(stampAnnotation)), initialAnnotations.size());
+
+    // Get Updated annotations
+    std::vector<Annotation*> updatedAnnotations = page->GetPageAnnotations();
+
+    // Assert that the size has increased by one.
+    ASSERT_EQ(initialAnnotations.size() + 1, updatedAnnotations.size());
+    // Check for the first Annotation to be StampAnnotation
+    ASSERT_EQ(Annotation::Type::Stamp, updatedAnnotations[0]->GetType());
+    // Check for the second Annotation to be StampAnnotation.
+    ASSERT_EQ(Annotation::Type::Stamp, updatedAnnotations[1]->GetType());
+
+    // Check for the page objects inside stamp annotation
+    StampAnnotation* stamp_annotation = static_cast<StampAnnotation*>(updatedAnnotations[1]);
+    std::vector<PageObject*> pageObjects = stamp_annotation->GetObjects();
+
+    // Check for number of page objects inside stamp annotation
+    ASSERT_EQ(2, pageObjects.size());
+
+    // Check for the first PageObject to be ImageObject.
+    ASSERT_EQ(PageObject::Type::Image, pageObjects[0]->GetType());
+    // Check for the second PageObject to be PathObject.
+    ASSERT_EQ(PageObject::Type::Path, pageObjects[1]->GetType());
+}
+
+TEST(Test, RemovePageAnnotationTest) {
+    Document doc(LoadTestDocument(kAnnotation), false);
+
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<Annotation*> initialAnnotations = page->GetPageAnnotations();
+
+    EXPECT_TRUE(initialAnnotations.size() > 0);
+    // Remove an annotation
+    EXPECT_TRUE(page->RemovePageAnnotation(0));
+    // Get Updated annotations after removal
+    std::vector<Annotation*> updatedAnnotations = page->GetPageAnnotations();
+
+    ASSERT_EQ(initialAnnotations.size() - 1, updatedAnnotations.size());
+}
+
+TEST(Test, AddFreeTextAnnotationTest) {
+    Document doc(LoadTestDocument(kAnnotation), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+
+    std::vector<Annotation*> annotations = page->GetPageAnnotations();
+
+    // Check for number of annotations (Pdf contains 1 Stamp Annotation)
+    ASSERT_EQ(1, annotations.size());
+
+    // Create and Add a FreeText Annotation
+    Rectangle_f bounds = pdfClient::Rectangle_f{0, 300, 200, 0};
+    auto freeTextAnnotation = std::make_unique<FreeTextAnnotation>(bounds);
+
+    std::wstring textContent = L"Hello World";
+    Color textColor = Color(255, 0, 0, 255);
+    Color backgroundColor = Color(0, 255, 0, 255);
+    freeTextAnnotation->SetTextContent(textContent);
+    freeTextAnnotation->SetTextColor(textColor);
+    freeTextAnnotation->SetBackgroundColor(backgroundColor);
+
+    ASSERT_EQ(page->AddPageAnnotation(std::move(freeTextAnnotation)), annotations.size());
+
+    annotations = page->GetPageAnnotations();
+    ASSERT_EQ(2, annotations.size());
+
+    ASSERT_EQ(Annotation::Type::Stamp, annotations[0]->GetType());
+    ASSERT_EQ(Annotation::Type::FreeText, annotations[1]->GetType());
+    FreeTextAnnotation* addedFreeTextAnnotation = static_cast<FreeTextAnnotation*>(annotations[1]);
+
+    ASSERT_EQ(addedFreeTextAnnotation->GetTextContent(), textContent);
+    // Assert TextColor
+    ASSERT_EQ(addedFreeTextAnnotation->GetTextColor().r, textColor.r);
+    ASSERT_EQ(addedFreeTextAnnotation->GetTextColor().g, textColor.g);
+    ASSERT_EQ(addedFreeTextAnnotation->GetTextColor().b, textColor.b);
+    ASSERT_EQ(addedFreeTextAnnotation->GetTextColor().a, textColor.a);
+
+    // Assert BackGround Color
+    ASSERT_EQ(addedFreeTextAnnotation->GetBackgroundColor().r, backgroundColor.r);
+    ASSERT_EQ(addedFreeTextAnnotation->GetBackgroundColor().g, backgroundColor.g);
+    ASSERT_EQ(addedFreeTextAnnotation->GetBackgroundColor().b, backgroundColor.b);
+    ASSERT_EQ(addedFreeTextAnnotation->GetBackgroundColor().a, backgroundColor.a);
+}
+
+TEST(Test, UpdateFreeTextAnnotationTest) {
+    Document doc(LoadTestDocument(kAnnotation), false);
+    std::shared_ptr<Page> page = doc.GetPage(0);
+    std::vector<Annotation*> annotations = page->GetPageAnnotations();
+
+    // Create and Add a FreeText Annotation
+    Rectangle_f bounds = pdfClient::Rectangle_f{0, 300, 200, 0};
+    auto freeTextAnnotation = std::make_unique<FreeTextAnnotation>(bounds);
+
+    std::wstring textContent = L"Hello World";
+    Color textColor = Color(255, 0, 0, 255);
+    Color backgroundColor = Color(0, 255, 0, 255);
+    freeTextAnnotation->SetTextContent(textContent);
+    freeTextAnnotation->SetTextColor(textColor);
+    freeTextAnnotation->SetBackgroundColor(backgroundColor);
+
+    ASSERT_EQ(page->AddPageAnnotation(std::move(freeTextAnnotation)), annotations.size());
+
+    freeTextAnnotation = std::make_unique<FreeTextAnnotation>(bounds);
+    std::wstring newTextContent = L"Bye World";
+    Color newTextColor = Color(0, 0, 255, 255);
+    Color newBackgroundColor = Color(255, 255, 255, 255);
+    freeTextAnnotation->SetTextContent(newTextContent);
+    freeTextAnnotation->SetTextColor(newTextColor);
+    freeTextAnnotation->SetBackgroundColor(newBackgroundColor);
+
+    page->UpdatePageAnnotation(1, std::move(freeTextAnnotation));
+
+    annotations = page->GetPageAnnotations();
+    FreeTextAnnotation* updatedAnnotation = static_cast<FreeTextAnnotation*>(annotations[1]);
+
+    ASSERT_EQ(updatedAnnotation->GetTextContent(), newTextContent);
+    // Assert Updated TextColor
+    ASSERT_EQ(updatedAnnotation->GetTextColor().r, newTextColor.r);
+    ASSERT_EQ(updatedAnnotation->GetTextColor().g, newTextColor.g);
+    ASSERT_EQ(updatedAnnotation->GetTextColor().b, newTextColor.b);
+    ASSERT_EQ(updatedAnnotation->GetTextColor().a, newTextColor.a);
+
+    // Assert Updated BackGround Color
+    ASSERT_EQ(updatedAnnotation->GetBackgroundColor().r, newBackgroundColor.r);
+    ASSERT_EQ(updatedAnnotation->GetBackgroundColor().g, newBackgroundColor.g);
+    ASSERT_EQ(updatedAnnotation->GetBackgroundColor().b, newBackgroundColor.b);
+    ASSERT_EQ(updatedAnnotation->GetBackgroundColor().a, newBackgroundColor.a);
+}
+
 }  // namespace
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/path_object.cc b/pdf/framework/libs/pdfClient/path_object.cc
new file mode 100644
index 000000000..a0d68a95e
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/path_object.cc
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "path_object.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "fpdf_edit.h"
+#include "logging.h"
+#include "rect.h"
+
+#define LOG_TAG "path_object"
+
+namespace pdfClient {
+
+PathObject::PathObject() : PageObject(Type::Path) {}
+
+ScopedFPDFPageObject PathObject::CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) {
+    int segment_count = segments_.size();
+    if (segment_count == 0) {
+        return nullptr;
+    }
+    // Get Start Points
+    float x = segments_[0].x;
+    float y = segments_[0].y;
+
+    // Create a scoped PDFium path object.
+    ScopedFPDFPageObject scoped_path_object(FPDFPageObj_CreateNewPath(x, y));
+    if (!scoped_path_object) {
+        return nullptr;
+    }
+
+    // Insert all segments into PDFium Path Object
+    for (int i = 1; i < segment_count; ++i) {
+        // Get EndPoint for current segment.
+        x = segments_[i].x;
+        y = segments_[i].y;
+        switch (segments_[i].command) {
+            case Segment::Command::Move: {
+                FPDFPath_MoveTo(scoped_path_object.get(), x, y);
+                break;
+            }
+            case Segment::Command::Line: {
+                FPDFPath_LineTo(scoped_path_object.get(), x, y);
+                break;
+            }
+            default:
+                break;
+        }
+        if (segments_[i].is_closed) {
+            FPDFPath_Close(scoped_path_object.get());
+        }
+    }
+
+    // Update attributes of PDFium path object.
+    if (!UpdateFPDFInstance(scoped_path_object.get(), page)) {
+        return nullptr;
+    }
+
+    return scoped_path_object;
+}
+
+bool PathObject::UpdateFPDFInstance(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) {
+    if (!path_object) {
+        return false;
+    }
+
+    // Check for Type Correctness.
+    if (FPDFPageObj_GetType(path_object) != FPDF_PAGEOBJ_PATH) {
+        return false;
+    }
+
+    // Set the updated Draw Mode
+    int fill_mode = this->is_fill_ ? FPDF_FILLMODE_WINDING : FPDF_FILLMODE_NONE;
+    if (!FPDFPath_SetDrawMode(path_object, fill_mode, is_stroke_)) {
+        return false;
+    }
+
+    // Set the updated matrix.
+    if (!SetDeviceToPageMatrix(path_object, page)) {
+        return false;
+    }
+
+    // Set the updated Stroke Width
+    FPDFPageObj_SetStrokeWidth(path_object, stroke_width_);
+    // Set the updated Stroke Color
+    FPDFPageObj_SetStrokeColor(path_object, stroke_color_.r, stroke_color_.g, stroke_color_.b,
+                               stroke_color_.a);
+    // Set the updated Fill Color
+    FPDFPageObj_SetFillColor(path_object, fill_color_.r, fill_color_.g, fill_color_.b,
+                             fill_color_.a);
+
+    return true;
+}
+
+bool PathObject::PopulateFromFPDFInstance(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) {
+    // Count the number of segments in the Path
+    int segment_count = FPDFPath_CountSegments(path_object);
+    if (segment_count == 0) {
+        return false;
+    }
+
+    // Get Path segments
+    for (int index = 0; index < segment_count; ++index) {
+        FPDF_PATHSEGMENT path_segment = FPDFPath_GetPathSegment(path_object, index);
+
+        // Get Type for the current Path Segment
+        int type = FPDFPathSegment_GetType(path_segment);
+        if (type == FPDF_SEGMENT_UNKNOWN || type == FPDF_SEGMENT_BEZIERTO) {
+            // Control point extraction of bezier curve is not supported by Pdfium as of now.
+            return false;
+        }
+
+        // Get EndPoint for the current Path Segment
+        float x, y;
+        FPDFPathSegment_GetPoint(path_segment, &x, &y);
+
+        // Get Close for the current Path Segment
+        bool is_closed = FPDFPathSegment_GetClose(path_segment);
+
+        // Add Segment to PageObject Data
+        if (type == FPDF_SEGMENT_LINETO) {
+            segments_.emplace_back(Segment::Command::Line, x, y, is_closed);
+        } else {
+            segments_.emplace_back(Segment::Command::Move, x, y, is_closed);
+        }
+    }
+
+    // Get Draw Mode
+    int fill_mode;
+    FPDF_BOOL stroke;
+    if (!FPDFPath_GetDrawMode(path_object, &fill_mode, &stroke)) {
+        LOGE("Path GetDrawMode Failed!");
+        return false;
+    }
+    is_fill_ = fill_mode;
+    is_stroke_ = stroke;
+
+    // Get Matrix
+    if (!GetPageToDeviceMatrix(path_object, page)) {
+        return false;
+    }
+
+    // Get Fill Color
+    FPDFPageObj_GetFillColor(path_object, &fill_color_.r, &fill_color_.g, &fill_color_.b,
+                             &fill_color_.a);
+    // Get Stroke Color
+    FPDFPageObj_GetStrokeColor(path_object, &stroke_color_.r, &stroke_color_.g, &stroke_color_.b,
+                               &stroke_color_.a);
+    // Get Stroke Width
+    FPDFPageObj_GetStrokeWidth(path_object, &stroke_width_);
+
+    return true;
+}
+
+bool PathObject::GetPageToDeviceMatrix(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) {
+    Matrix page_matrix;
+    if (!FPDFPageObj_GetMatrix(path_object, reinterpret_cast<FS_MATRIX*>(&page_matrix))) {
+        LOGE("GetPageMatrix failed!");
+        return false;
+    }
+
+    float page_height = FPDF_GetPageHeightF(page);
+
+    // Page to device matrix.
+    device_matrix_.a = page_matrix.a;
+    device_matrix_.b = (page_matrix.b != 0) ? -page_matrix.b : 0;
+    device_matrix_.c = (page_matrix.c != 0) ? -page_matrix.c : 0;
+    device_matrix_.d = page_matrix.d;
+    device_matrix_.e = page_matrix.e + (page_height * page_matrix.c);
+    device_matrix_.f = page_height - page_matrix.f - (page_height * page_matrix.d);
+
+    return true;
+}
+
+bool PathObject::SetDeviceToPageMatrix(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) {
+    // Reset Previous Transformation.
+    Matrix identity = {1, 0, 0, 1, 0, 0};
+    if (!FPDFPageObj_SetMatrix(path_object, reinterpret_cast<FS_MATRIX*>(&identity))) {
+        LOGE("SetMatrix failed!");
+        return false;
+    }
+
+    float page_height = FPDF_GetPageHeightF(page);
+
+    FPDFPageObj_Transform(path_object, 1, 0, 0, 1, 0, -page_height);
+    FPDFPageObj_Transform(path_object, device_matrix_.a, -device_matrix_.b, -device_matrix_.c,
+                          device_matrix_.d, device_matrix_.e, -device_matrix_.f);
+    FPDFPageObj_Transform(path_object, 1, 0, 0, 1, 0, page_height);
+
+    return true;
+}
+
+PathObject::~PathObject() = default;
+
+}  // namespace pdfClient
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/path_object.h b/pdf/framework/libs/pdfClient/path_object.h
new file mode 100644
index 000000000..fee76f70e
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/path_object.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIAPROVIDER_PDF_JNI_PDFCLIENT_PATH_OBJECT_H_
+#define MEDIAPROVIDER_PDF_JNI_PDFCLIENT_PATH_OBJECT_H_
+
+#include <stdint.h>
+
+#include <vector>
+
+#include "cpp/fpdf_scopers.h"
+#include "fpdfview.h"
+#include "page_object.h"
+
+typedef unsigned int uint;
+
+namespace pdfClient {
+
+class PathObject : public PageObject {
+  public:
+    PathObject();
+
+    ScopedFPDFPageObject CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) override;
+    bool UpdateFPDFInstance(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) override;
+    bool PopulateFromFPDFInstance(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) override;
+
+    ~PathObject();
+
+    class Segment {
+      public:
+        enum class Command {
+            Unknown = 0,
+            Move,
+            Line,
+        };
+
+        Command command;
+        float x;
+        float y;
+        bool is_closed;  // Checks if the path_segment is closed
+
+        Segment(Command command, float x, float y, bool is_closed = false)
+            : command(command), x(x), y(y), is_closed(is_closed) {}
+    };
+
+    bool is_fill_ = false;
+    bool is_stroke_ = false;
+
+    std::vector<Segment> segments_;
+
+  protected:
+    bool GetPageToDeviceMatrix(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) override;
+    bool SetDeviceToPageMatrix(FPDF_PAGEOBJECT path_object, FPDF_PAGE page) override;
+};
+
+}  // namespace pdfClient
+
+#endif  // MEDIAPROVIDER_PDF_JNI_PDFCLIENT_PATH_OBJECT_H_
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/pdf_document_jni.cc b/pdf/framework/libs/pdfClient/pdf_document_jni.cc
index 01e8c58bb..d6896d2ae 100644
--- a/pdf/framework/libs/pdfClient/pdf_document_jni.cc
+++ b/pdf/framework/libs/pdfClient/pdf_document_jni.cc
@@ -41,10 +41,12 @@
 
 #define LOG_TAG "pdf_document_jni"
 
+using pdfClient::Annotation;
 using pdfClient::Document;
 using pdfClient::FileReader;
 using pdfClient::GotoLink;
 using pdfClient::Page;
+using pdfClient::Point_f;
 using pdfClient::Point_i;
 using pdfClient::Rectangle_i;
 using pdfClient::SelectionBoundary;
@@ -320,7 +322,7 @@ Java_android_graphics_pdf_PdfDocumentProxy_isPdfLinearized(JNIEnv* env, jobject
 }
 
 JNIEXPORT jint JNICALL Java_android_graphics_pdf_PdfDocumentProxy_getFormType(JNIEnv* env,
-                                                                            jobject jPdfDocument) {
+                                                                       jobject jPdfDocument) {
     std::unique_lock<std::mutex> lock(mutex_);
     Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
     return doc->GetFormType();
@@ -446,3 +448,127 @@ JNIEXPORT jobject JNICALL Java_android_graphics_pdf_PdfDocumentProxy_setFormFiel
     doc->ReleaseRetainedPage(pageNum);
     return convert::ToJavaRects(env, invalid_rects);
 }
+
+JNIEXPORT jint JNICALL Java_android_graphics_pdf_PdfDocumentProxy_addPageObject(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jobject jPageObject) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    std::unique_ptr<PageObject> page_object =
+            convert::ToNativePageObject(env, jPageObject, page.get());
+
+    if (!page_object) {
+        return -1;
+    }
+
+    int new_object_index = page->AddPageObject(std::move(page_object));
+
+    doc->ReleaseRetainedPage(pageNum);
+    return new_object_index;
+}
+
+JNIEXPORT jobject JNICALL Java_android_graphics_pdf_PdfDocumentProxy_getPageObjects(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    std::vector<PageObject*> page_objects = page->GetPageObjects();
+
+    doc->ReleaseRetainedPage(pageNum);
+    return convert::ToJavaPdfPageObjects(env, page_objects, page.get());
+}
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_removePageObject(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    bool removed = page->RemovePageObject(index);
+
+    doc->ReleaseRetainedPage(pageNum);
+    return removed;
+}
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_updatePageObject(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index, jobject jPageObject) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    std::unique_ptr<PageObject> page_object =
+            convert::ToNativePageObject(env, jPageObject, page.get());
+
+    if (!page_object) {
+        return false;
+    }
+
+    bool updated = page->UpdatePageObject(index, std::move(page_object));
+
+    doc->ReleaseRetainedPage(pageNum);
+    return updated;
+}
+
+JNIEXPORT jobject JNICALL Java_android_graphics_pdf_PdfDocumentProxy_getPageAnnotations(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    std::vector<Annotation*> annotations = page->GetPageAnnotations();
+
+    doc->ReleaseRetainedPage(pageNum);
+    return convert::ToJavaPageAnnotations(env, annotations, page.get());
+}
+
+JNIEXPORT jint JNICALL Java_android_graphics_pdf_PdfDocumentProxy_addPageAnnotation(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jobject jPageAnnotation) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    std::unique_ptr<Annotation> annotation =
+            convert::ToNativePageAnnotation(env, jPageAnnotation, page.get());
+
+    if (!annotation) {
+        return -1;
+    }
+
+    int new_annotation_index = page->AddPageAnnotation(std::move(annotation));
+
+    doc->ReleaseRetainedPage(pageNum);
+    return new_annotation_index;
+}
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_removePageAnnotation(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    bool removed = page->RemovePageAnnotation(index);
+
+    doc->ReleaseRetainedPage(pageNum);
+    return removed;
+}
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_updatePageAnnotation(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index, jobject jPageAnnotation) {
+    std::unique_lock<std::mutex> lock(mutex_);
+    Document* doc = convert::GetPdfDocPtr(env, jPdfDocument);
+    std::shared_ptr<Page> page = doc->GetPage(pageNum, true);
+
+    std::unique_ptr<Annotation> annotation =
+            convert::ToNativePageAnnotation(env, jPageAnnotation, page.get());
+
+    if (!annotation) {
+        return false;
+    }
+
+    bool updated = page->UpdatePageAnnotation(index, std::move(annotation));
+
+    doc->ReleaseRetainedPage(pageNum);
+    return updated;
+}
diff --git a/pdf/framework/libs/pdfClient/pdf_document_jni.h b/pdf/framework/libs/pdfClient/pdf_document_jni.h
index e6cad3c57..ac7ce191e 100644
--- a/pdf/framework/libs/pdfClient/pdf_document_jni.h
+++ b/pdf/framework/libs/pdfClient/pdf_document_jni.h
@@ -109,6 +109,30 @@ JNIEXPORT jobject JNICALL Java_android_graphics_pdf_PdfDocumentProxy_setFormFiel
         JNIEnv* env, jobject jPdfDocument, jint pageNum, jint annotationIndex,
         jintArray jSelectedIndices);
 
+JNIEXPORT jint JNICALL Java_android_graphics_pdf_PdfDocumentProxy_addPageObject(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jobject jPageObject);
+
+JNIEXPORT jobject JNICALL Java_android_graphics_pdf_PdfDocumentProxy_getPageObjects(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum);
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_removePageObject(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index);
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_updatePageObject(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index, jobject jPageObject);
+
+JNIEXPORT jobject JNICALL Java_android_graphics_pdf_PdfDocumentProxy_getPageAnnotations(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum);
+
+JNIEXPORT jint JNICALL Java_android_graphics_pdf_PdfDocumentProxy_addPageAnnotation(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jobject jPageAnnotation);
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_removePageAnnotation(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index);
+
+JNIEXPORT jboolean JNICALL Java_android_graphics_pdf_PdfDocumentProxy_updatePageAnnotation(
+        JNIEnv* env, jobject jPdfDocument, jint pageNum, jint index, jobject jPageAnnotation);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/pdf/framework/libs/pdfClient/rect.h b/pdf/framework/libs/pdfClient/rect.h
index bb708f76b..d8d28144a 100644
--- a/pdf/framework/libs/pdfClient/rect.h
+++ b/pdf/framework/libs/pdfClient/rect.h
@@ -33,6 +33,12 @@ struct Point_d {
     double y;
 };
 
+// A point with float precision
+struct Point_f {
+    float x;
+    float y;
+};
+
 // A rectangle with integer precision
 struct Rectangle_i {
     // The x-coordinate of the left-top corner (lesser value).
@@ -69,6 +75,24 @@ struct Rectangle_d {
     Point_d Center() const { return Point_d{(left + right) / 2, (top + bottom) / 2}; }
 };
 
+// A rectangle with float precision
+struct Rectangle_f {
+    // The x-coordinate of the left-top corner (lesser value).
+    float left;
+    // The y-coordinate of the left-top corner (lesser value).
+    float top;
+    // The x-coordinate of the right-bottom corner (greater value).
+    float right;
+    // The y-coordinate of the right-bottom corner (greater value).
+    float bottom;
+
+    float Width() const { return right - left; }
+
+    float Height() const { return bottom - top; }
+
+    Point_f Center() const { return Point_f{(left + right) / 2, (top + bottom) / 2}; }
+};
+
 // Check if two points are equal:
 inline bool operator==(const Point_i& lhs, const Point_i& rhs) {
     return lhs.x == rhs.x && lhs.y == rhs.y;
@@ -127,6 +151,8 @@ Rectangle_d Intersect(const Rectangle_d& lhs, const Rectangle_d& rhs);
 Rectangle_i Union(const Rectangle_i& lhs, const Rectangle_i& rhs);
 Rectangle_d Union(const Rectangle_d& lhs, const Rectangle_d& rhs);
 
+Rectangle_f FloatRect(const float x1, const float y1, const float x2, const float y2);
+
 }  // namespace pdfClient
 
 #endif  // MEDIAPROVIDER_PDF_JNI_PDFCLIENT_RECT_H_
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/testdata/annotation.pdf b/pdf/framework/libs/pdfClient/testdata/annotation.pdf
new file mode 100644
index 000000000..e87600e8c
Binary files /dev/null and b/pdf/framework/libs/pdfClient/testdata/annotation.pdf differ
diff --git a/pdf/framework/libs/pdfClient/testdata/page_object.pdf b/pdf/framework/libs/pdfClient/testdata/page_object.pdf
new file mode 100644
index 000000000..46c6ac08f
Binary files /dev/null and b/pdf/framework/libs/pdfClient/testdata/page_object.pdf differ
diff --git a/pdf/framework/libs/pdfClient/text_object.cc b/pdf/framework/libs/pdfClient/text_object.cc
new file mode 100644
index 000000000..ba1e6a599
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/text_object.cc
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "text_object.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <utils/pdf_strings.h>
+
+#include <string>
+
+#include "cpp/fpdf_scopers.h"
+#include "fpdf_edit.h"
+#include "fpdfview.h"
+#include "logging.h"
+
+#define LOG_TAG "text_object"
+
+using FontFamily = pdfClient::Font::Family;
+
+namespace pdfClient {
+
+std::optional<Font> GetFont(FPDF_PAGEOBJECT text_object) {
+    // Get FPDF font.
+    FPDF_FONT font = FPDFTextObj_GetFont(text_object);
+
+    // Get buffer length.
+    unsigned long text_len = FPDFFont_GetBaseFontName(font, nullptr, 0);
+
+    // Get font name.
+    std::unique_ptr<char[]> p_font_name = std::make_unique<char[]>(text_len);
+    if (!FPDFFont_GetBaseFontName(font, p_font_name.get(), text_len)) {
+        LOGE("GetBaseFontName failed");
+        return std::nullopt;
+    }
+
+    // Find font index.
+    std::string font_name(p_font_name.get());
+    if (font_mapper.find(font_name) == font_mapper.end()) {
+        LOGE("Font not found in font_mapper %s", font_name.c_str());
+        return std::nullopt;
+    }
+
+    return font_mapper[font_name];
+}
+
+TextObject::RenderMode GetRenderMode(FPDF_TEXT_RENDERMODE render_mode) {
+    switch (render_mode) {
+        case FPDF_TEXTRENDERMODE_FILL: {
+            return TextObject::RenderMode::Fill;
+        }
+        case FPDF_TEXTRENDERMODE_STROKE: {
+            return TextObject::RenderMode::Stroke;
+        }
+        case FPDF_TEXTRENDERMODE_FILL_STROKE: {
+            return TextObject::RenderMode::FillStroke;
+        }
+        default: {
+            return TextObject::RenderMode::Unknown;
+        }
+    }
+}
+
+FPDF_TEXT_RENDERMODE GetRenderMode(TextObject::RenderMode render_mode) {
+    switch (render_mode) {
+        case TextObject::RenderMode::Fill: {
+            return FPDF_TEXTRENDERMODE_FILL;
+        }
+        case TextObject::RenderMode::Stroke: {
+            return FPDF_TEXTRENDERMODE_STROKE;
+        }
+        case TextObject::RenderMode::FillStroke: {
+            return FPDF_TEXTRENDERMODE_FILL_STROKE;
+        }
+        default: {
+            return FPDF_TEXTRENDERMODE_UNKNOWN;
+        }
+    }
+}
+
+std::optional<std::wstring> GetText(FPDF_PAGEOBJECT text_object, FPDF_PAGE page) {
+    // Get text page.
+    ScopedFPDFTextPage text_page(FPDFText_LoadPage(page));
+    if (!text_page) {
+        return std::nullopt;
+    }
+
+    // Get buffer length.
+    unsigned long text_len = FPDFTextObj_GetText(text_object, text_page.get(), nullptr, 0);
+
+    // Get text.
+    std::unique_ptr<FPDF_WCHAR[]> p_text_buffer = std::make_unique<FPDF_WCHAR[]>(text_len);
+    if (!FPDFTextObj_GetText(text_object, text_page.get(), p_text_buffer.get(), text_len)) {
+        LOGE("GetText failed");
+        return std::nullopt;
+    }
+
+    return pdfClient_utils::ToWideString(p_text_buffer.get(), text_len);
+}
+
+Font::Font(const std::string& font_name, Family family, bool bold, bool italic)
+    : font_name_(font_name), family_(family), bold_(bold), italic_(italic) {}
+
+std::string Font::GetName() {
+    std::string name = font_name_;
+
+    if (bold_ && italic_) {
+        name += BoldItalic;
+    } else if (bold_) {
+        name += Bold;
+    } else if (italic_) {
+        name += Italic;
+    }
+
+    return name;
+}
+
+TextObject::TextObject() : PageObject(Type::Text) {}
+
+ScopedFPDFPageObject TextObject::CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) {
+    // Create a scoped Pdfium font object.
+    ScopedFPDFFont font(FPDFText_LoadStandardFont(document, font_.GetName().c_str()));
+    if (!font) {
+        LOGE("Font creation failed");
+        return nullptr;
+    }
+
+    // Create a scoped Pdfium text object.
+    ScopedFPDFPageObject scoped_text_object(
+            FPDFPageObj_CreateTextObj(document, font.get(), font_size_));
+    if (!scoped_text_object) {
+        LOGE("Object creation failed");
+        return nullptr;
+    }
+
+    // Update attributes of Pdfium text object.
+    if (!UpdateFPDFInstance(scoped_text_object.get(), page)) {
+        LOGE("Create update failed");
+        return nullptr;
+    }
+
+    return scoped_text_object;
+}
+
+bool TextObject::UpdateFPDFInstance(FPDF_PAGEOBJECT text_object, FPDF_PAGE page) {
+    if (!text_object) {
+        LOGE("Object NULL");
+        return false;
+    }
+
+    // Check for type correctness.
+    if (FPDFPageObj_GetType(text_object) != FPDF_PAGEOBJ_TEXT) {
+        LOGE("TypeCast failed");
+        return false;
+    }
+
+    // Set the updated text.
+    auto fpdf_text = pdfClient_utils::ToFPDFWideString(text_);
+    if (text_.size() == 0 || !FPDFText_SetText(text_object, fpdf_text.get())) {
+        LOGE("SetText failed");
+        return false;
+    }
+
+    // Set the updated text render mode.
+    if (!FPDFTextObj_SetTextRenderMode(text_object, GetRenderMode(render_mode_))) {
+        LOGE("SetTextRenderMode failed");
+        return false;
+    }
+
+    // Set the updated device matrix.
+    if (!SetDeviceToPageMatrix(text_object, page)) {
+        LOGE("SetMatrix failed");
+        return false;
+    }
+
+    // Set updated stroke width.
+    if (!FPDFPageObj_SetStrokeWidth(text_object, stroke_width_)) {
+        LOGE("SetStrokeWidth failed");
+        return false;
+    }
+
+    // Set updated stroke color.
+    if (!FPDFPageObj_SetStrokeColor(text_object, stroke_color_.r, stroke_color_.g, stroke_color_.b,
+                                    stroke_color_.a)) {
+        LOGE("SetStrokeColor failed");
+        return false;
+    }
+
+    // Set the updated fill color.
+    if (!FPDFPageObj_SetFillColor(text_object, fill_color_.r, fill_color_.g, fill_color_.b,
+                                  fill_color_.a)) {
+        LOGE("SetFillColor failed");
+        return false;
+    }
+
+    return true;
+}
+
+bool TextObject::PopulateFromFPDFInstance(FPDF_PAGEOBJECT text_object, FPDF_PAGE page) {
+    // Get font.
+    std::optional<Font> fontOpt = GetFont(text_object);
+    if (!fontOpt) {
+        LOGE("GetFont failed");
+        return false;
+    }
+    font_ = *fontOpt;
+
+    // Get font size.
+    if (!FPDFTextObj_GetFontSize(text_object, &font_size_)) {
+        LOGE("GetFontSize failed");
+        return false;
+    }
+
+    // Get text.
+    std::optional<std::wstring> textOpt = GetText(text_object, page);
+    if (!textOpt) {
+        LOGE("GetText failed");
+        return false;
+    }
+    text_ = *textOpt;
+
+    // Get render mode.
+    render_mode_ = GetRenderMode(FPDFTextObj_GetTextRenderMode(text_object));
+    if (render_mode_ == RenderMode::Unknown) {
+        LOGE("GetRenderMode unknown");
+        return false;
+    }
+
+    // Get device matrix.
+    if (!GetPageToDeviceMatrix(text_object, page)) {
+        LOGE("GetMatrix failed");
+        return false;
+    }
+
+    // Get stroke width.
+    if (!FPDFPageObj_GetStrokeWidth(text_object, &stroke_width_)) {
+        LOGE("GetStrokeWidth failed");
+        return false;
+    }
+
+    // Get stroke color.
+    if (!FPDFPageObj_GetStrokeColor(text_object, &stroke_color_.r, &stroke_color_.g,
+                                    &stroke_color_.b, &stroke_color_.a)) {
+        LOGE("GetStrokeColor failed");
+        return false;
+    }
+
+    // Get fill color.
+    if (!FPDFPageObj_GetFillColor(text_object, &fill_color_.r, &fill_color_.g, &fill_color_.b,
+                                  &fill_color_.a)) {
+        LOGE("GetFillColor failed");
+        return false;
+    }
+
+    return true;
+}
+
+TextObject::~TextObject() = default;
+
+// Font Mapper
+std::unordered_map<std::string, Font> font_mapper = {
+        {Courier, Font(Courier, FontFamily::Courier)},
+        {Courier + Bold, Font(Courier, FontFamily::Courier, true)},
+        {Courier + Oblique, Font(Courier, FontFamily::Courier, false, true)},
+        {Courier + BoldOblique, Font(Courier, FontFamily::Courier, true, true)},
+
+        {Helvetica, Font(Helvetica, FontFamily::Helvetica)},
+        {Helvetica + Bold, Font(Helvetica, FontFamily::Helvetica, true)},
+        {Helvetica + Oblique, Font(Helvetica, FontFamily::Helvetica, false, true)},
+        {Helvetica + BoldOblique, Font(Helvetica, FontFamily::Helvetica, true, true)},
+
+        {TimesRoman, Font(TimesRoman, FontFamily::TimesRoman)},
+        {Times + Bold, Font(Times, FontFamily::TimesRoman, true)},
+        {Times + Italic, Font(Times, FontFamily::TimesRoman, false, true)},
+        {Times + BoldItalic, Font(Times, FontFamily::TimesRoman, true, true)},
+
+        {Symbol, Font(Symbol, FontFamily::Symbol)}};
+
+// Standard Font Names.
+std::vector<std::string> font_names = {CourierNew, Helvetica, Symbol, TimesNewRoman};
+
+}  // namespace pdfClient
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/text_object.h b/pdf/framework/libs/pdfClient/text_object.h
new file mode 100644
index 000000000..84a150b6b
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/text_object.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIAPROVIDER_PDF_JNI_PDFCLIENT_TEXT_OBJECT_H_
+#define MEDIAPROVIDER_PDF_JNI_PDFCLIENT_TEXT_OBJECT_H_
+
+#include <stdint.h>
+
+#include <string>
+#include <unordered_map>
+#include <vector>
+
+#include "cpp/fpdf_scopers.h"
+#include "fpdfview.h"
+#include "page_object.h"
+
+namespace pdfClient {
+
+class Font {
+  public:
+    enum class Family {
+        Unknown = -1,
+        Courier,
+        Helvetica,
+        Symbol,
+        TimesRoman,
+    };
+
+    Font() : family_(Family::Unknown), bold_(false), italic_(false) {};
+    Font(const std::string& font_name, Family family = Family::Unknown, bool bold = false,
+         bool italic = false);
+
+    std::string GetName();
+    Family GetFamily() const { return family_; }
+    bool IsBold() const { return bold_; }
+    bool IsItalic() const { return italic_; }
+
+  private:
+    std::string font_name_;
+    Family family_;
+    bool bold_;
+    bool italic_;
+};
+
+class TextObject : public PageObject {
+  public:
+    TextObject();
+
+    ScopedFPDFPageObject CreateFPDFInstance(FPDF_DOCUMENT document, FPDF_PAGE page) override;
+    bool UpdateFPDFInstance(FPDF_PAGEOBJECT text_object, FPDF_PAGE page) override;
+    bool PopulateFromFPDFInstance(FPDF_PAGEOBJECT text_object, FPDF_PAGE page) override;
+
+    ~TextObject();
+
+    enum class RenderMode {
+        Unknown = -1,
+        Fill,
+        Stroke,
+        FillStroke,
+    };
+
+    Font font_;
+    float font_size_;
+    RenderMode render_mode_;
+    std::wstring text_;
+};
+
+// Define font names as constants
+const std::string Courier = "Courier";
+const std::string CourierNew = "CourierNew";
+const std::string Helvetica = "Helvetica";
+const std::string Symbol = "Symbol";
+const std::string Times = "Times";
+const std::string TimesRoman = "Times-Roman";
+const std::string TimesNewRoman = "TimesNewRoman";
+
+// Define font variants as constants
+const std::string Bold = "-Bold";
+const std::string Italic = "-Italic";
+const std::string Oblique = "-Oblique";
+const std::string BoldItalic = "-BoldItalic";
+const std::string BoldOblique = "-BoldOblique";
+
+// Font Mapper
+extern std::unordered_map<std::string, Font> font_mapper;
+
+// Standard Font Names
+extern std::vector<std::string> font_names;
+
+}  // namespace pdfClient
+
+#endif  // MEDIAPROVIDER_PDF_JNI_PDFCLIENT_TEXT_OBJECT_H_
\ No newline at end of file
diff --git a/pdf/framework/libs/pdfClient/utils/pdf_strings.cc b/pdf/framework/libs/pdfClient/utils/pdf_strings.cc
new file mode 100644
index 000000000..f6a4d0db3
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/utils/pdf_strings.cc
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pdf_strings.h"
+
+namespace pdfClient_utils {
+ScopedFPDFWChar ToFPDFWideString(const std::wstring& wstr) {
+    size_t length = wstr.size() + 1;
+    ScopedFPDFWChar result = std::make_unique<FPDF_WCHAR[]>(length);
+
+    size_t i = 0;
+    for (const wchar_t& w : wstr) {
+        result[i++] = static_cast<FPDF_WCHAR>(w);
+    }
+    result[i] = 0;
+    return result;
+}
+
+std::wstring ToWideString(const FPDF_WCHAR* buffer, unsigned long text_length) {
+    std::wstring textContent;
+    size_t textContentSize = (text_length / sizeof(FPDF_WCHAR)) - 1;
+    textContent.reserve(textContentSize);
+    for (int i = 0; i < textContentSize; i++) {
+        textContent.push_back(buffer[i]);
+    }
+    return textContent;
+}
+}  // namespace pdfClient_utils
diff --git a/pdf/framework/libs/pdfClient/utils/pdf_strings.h b/pdf/framework/libs/pdfClient/utils/pdf_strings.h
new file mode 100644
index 000000000..c1a5da898
--- /dev/null
+++ b/pdf/framework/libs/pdfClient/utils/pdf_strings.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIAPROVIDER_PDF_JNI_PDFCLIENT_UTILS_PDF_STRINGS_H
+#define MEDIAPROVIDER_PDF_JNI_PDFCLIENT_UTILS_PDF_STRINGS_H
+
+#include <string>
+
+#include "fpdfview.h"
+
+using ScopedFPDFWChar = std::unique_ptr<FPDF_WCHAR[]>;
+
+namespace pdfClient_utils {
+ScopedFPDFWChar ToFPDFWideString(const std::wstring& wstr);
+std::wstring ToWideString(const FPDF_WCHAR* buffer, unsigned long text_length);
+}  // namespace pdfClient_utils
+
+#endif  // MEDIAPROVIDER_PDF_JNI_PDFCLIENT_UTILS_PDF_STRINGS_H
diff --git a/pdf/framework/pdf_viewer_flags_readonly.aconfig b/pdf/framework/pdf_viewer_flags_readonly.aconfig
new file mode 100644
index 000000000..4b87a5ffe
--- /dev/null
+++ b/pdf/framework/pdf_viewer_flags_readonly.aconfig
@@ -0,0 +1,25 @@
+package: "android.graphics.pdf.flags.readonly"
+container: "com.android.mediaprovider"
+
+# These are the read-only version of the aconfig flags in android.graphics.pdf
+# that will be built with 'force-read-only' mode.
+# See b/368409430 - these flags will be removed once the new aconfig API landed.
+
+flag {
+    name: "enable_edit_pdf_text_annotations"
+    is_exported: false
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable text annotations editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
+
+
+flag {
+    name: "enable_edit_pdf_stamp_annotations"
+    is_exported: false
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable stamp annotations editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
diff --git a/photopicker/AndroidManifest.xml b/photopicker/AndroidManifest.xml
index ff0e86a3d..211db2204 100644
--- a/photopicker/AndroidManifest.xml
+++ b/photopicker/AndroidManifest.xml
@@ -48,11 +48,13 @@
           android:label="@string/photopicker_application_label"
           android:crossProfile="true"
           android:allowBackup="false"
+          android:enableOnBackInvokedCallback="true"
           android:supportsRtl="true">
 
     <activity
       android:name="com.android.photopicker.MainActivity"
       android:enabled="false"
+      android:enableOnBackInvokedCallback="false"
       android:exported="true"
       android:theme="@style/Theme.Photopicker"
       android:label="@string/photopicker_application_label"
diff --git a/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerProviderFactory.java b/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerProviderFactory.java
index e79528042..c9b087b65 100644
--- a/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerProviderFactory.java
+++ b/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerProviderFactory.java
@@ -87,6 +87,7 @@ public class EmbeddedPhotoPickerProviderFactory {
             implements EmbeddedPhotoPickerProvider {
 
         private static final String TAG = "EmbeddedProviderFactory";
+        private static final int OPEN_SESSION_ATTEMPTS_LIMIT = 5;
 
         private static final boolean DEBUG = false;
 
@@ -203,6 +204,7 @@ public class EmbeddedPhotoPickerProviderFactory {
             if (mConnection.isBindRequested()) {
                 // Failure in binding service is terminal error, so add request to queue only if
                 // we were able to successfully send binding request to system.
+                sessionRequest.mTotalOpenSessionAttempts += 1;
                 mPendingOpenSessionRequests.add(sessionRequest);
             }
         }
@@ -223,8 +225,13 @@ public class EmbeddedPhotoPickerProviderFactory {
                 }
                 mConnection.disposeLocked();
                 mEmbeddedPhotopicker = null;
-                // todo(b/359469032): Add retry counter
-                bindServiceAndSaveRequestSerialized(sessionRequest);
+                if (sessionRequest.mTotalOpenSessionAttempts < OPEN_SESSION_ATTEMPTS_LIMIT) {
+                    bindServiceAndSaveRequestSerialized(sessionRequest);
+                } else {
+                    reportSessionErrorLocked(sessionRequest.mClientCallbackWrapper,
+                            /*cause*/ new RuntimeException("Unable to get valid remote delegate."
+                            + "Please request a new session"));
+                }
             } catch (RemoteException e) {
                 reportSessionErrorLocked(sessionRequest.mClientCallbackWrapper,
                         new RemoteException("Remote delegate is Invalid! "
@@ -487,6 +494,7 @@ public class EmbeddedPhotoPickerProviderFactory {
             public final int mHeight;
             public final EmbeddedPhotoPickerClientWrapper mClientCallbackWrapper;
             public final EmbeddedPhotoPickerFeatureInfo mFeatureInfo;
+            public int mTotalOpenSessionAttempts = 0;
 
             private OpenSessionRequest(IBinder hostToken, int displayId, int width,
                     int height, EmbeddedPhotoPickerClientWrapper clientCallbackWrapper,
diff --git a/res/values-v35/photopicker_styles.xml b/photopicker/res/drawable/photopicker_category_icon.xml
similarity index 58%
rename from res/values-v35/photopicker_styles.xml
rename to photopicker/res/drawable/photopicker_category_icon.xml
index 8c3261164..fc6d18f4f 100644
--- a/res/values-v35/photopicker_styles.xml
+++ b/photopicker/res/drawable/photopicker_category_icon.xml
@@ -1,4 +1,3 @@
-<?xml version="1.0" encoding="utf-8"?>
 <!--
   ~ Copyright (C) 2024 The Android Open Source Project
   ~
@@ -15,14 +14,8 @@
   ~ limitations under the License.
   -->
 
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-           xmlns:androidprv="http://schemas.android.com/apk/prv/res/android">
+<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="18dp" android:viewportHeight="12" android:viewportWidth="16" android:width="24dp">
 
-    <!--
-        TODO(b/309578419): Make activities handle insets properly and then remove this.
-    -->
-    <style name="OptOutEdgeToEdgeEnforcement">
-        <item name="android:windowOptOutEdgeToEdgeEnforcement">true</item>
-    </style>
+    <path android:fillColor="@color/icon_foreground" android:pathData="M0.8,11.4V10.05H15.2V11.4H0.8ZM3.05,8.7V3.3H4.4V8.7H3.05ZM5.75,8.7V0.6H7.1V8.7H5.75ZM8.45,8.7V0.6H9.8V8.7H8.45ZM12.65,8.7L10.7,3.806L11.956,3.3L13.906,8.194L12.65,8.7Z"/>
 
-</resources>
+</vector>
\ No newline at end of file
diff --git a/photopicker/res/values-af/feature_category_grid_strings.xml b/photopicker/res/values-af/feature_category_grid_strings.xml
new file mode 100644
index 000000000..bf8e2e320
--- /dev/null
+++ b/photopicker/res/values-af/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Versamelings"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Nog geen mense en troeteldiere nie"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Fotos en videos, gegroepeer volgens soortgelyke gesigte, sal hier verskyn"</string>
+</resources>
diff --git a/photopicker/res/values-af/feature_preview_strings.xml b/photopicker/res/values-af/feature_preview_strings.xml
index 037231690..83af40b1e 100644
--- a/photopicker/res/values-af/feature_preview_strings.xml
+++ b/photopicker/res/values-af/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Onderbreek"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Demp volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ontdemp volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Bladsy <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> van <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-af/feature_privacy_explainer_strings.xml b/photopicker/res/values-af/feature_privacy_explainer_strings.xml
index c6f0850a1..d8f9269d4 100644
--- a/photopicker/res/values-af/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-af/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> sal net toegang h tot die fotos wat jy kies"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Kies fotos en videos waartoe jy <xliff:g id="APP_NAME">%1$s</xliff:g> toegang gee"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Bestuur fotos en videos waartoe <xliff:g id="APP_NAME">%1$s</xliff:g> toegang het"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Hierdie app"</string>
 </resources>
diff --git a/photopicker/res/values-af/feature_search_strings.xml b/photopicker/res/values-af/feature_search_strings.xml
index 0a008ed65..507b48a6a 100644
--- a/photopicker/res/values-af/feature_search_strings.xml
+++ b/photopicker/res/values-af/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Soek"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Deursoek jou fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Deursoek jou video\'s"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Vee soekteks uit"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Geen resultate gekry nie"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Probeer om vir soortgelyke woorde te soek"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Voorstelle"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Soektog gedeaktiveer."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Probeer soortgelyke woorde soek.\n\nSlegs items wat gerugsteun is sal in jou soekresultate verskyn."</string>
 </resources>
diff --git a/photopicker/res/values-am/feature_category_grid_strings.xml b/photopicker/res/values-am/feature_category_grid_strings.xml
new file mode 100644
index 000000000..dc4e348ca
--- /dev/null
+++ b/photopicker/res/values-am/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"       "</string>
+</resources>
diff --git a/photopicker/res/values-am/feature_preview_strings.xml b/photopicker/res/values-am/feature_preview_strings.xml
index 5134f4234..e239960e2 100644
--- a/photopicker/res/values-am/feature_preview_strings.xml
+++ b/photopicker/res/values-am/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  - "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  - "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-am/feature_privacy_explainer_strings.xml b/photopicker/res/values-am/feature_privacy_explainer_strings.xml
index 355eac219..79ce39e9e 100644
--- a/photopicker/res/values-am/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-am/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>      "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>      "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-am/feature_search_strings.xml b/photopicker/res/values-am/feature_search_strings.xml
index 5638946f3..ad731a45e 100644
--- a/photopicker/res/values-am/feature_search_strings.xml
+++ b/photopicker/res/values-am/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   \n\n        "</string>
 </resources>
diff --git a/photopicker/res/values-ar/feature_category_grid_strings.xml b/photopicker/res/values-ar/feature_category_grid_strings.xml
new file mode 100644
index 000000000..7e290a060
--- /dev/null
+++ b/photopicker/res/values-ar/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     \"  \"  "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         "</string>
+</resources>
diff --git a/photopicker/res/values-ar/feature_preview_strings.xml b/photopicker/res/values-ar/feature_preview_strings.xml
index 9efc9a022..6cd614c9c 100644
--- a/photopicker/res/values-ar/feature_preview_strings.xml
+++ b/photopicker/res/values-ar/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ar/feature_privacy_explainer_strings.xml b/photopicker/res/values-ar/feature_privacy_explainer_strings.xml
index e9f23706a..a1e181bfd 100644
--- a/photopicker/res/values-ar/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ar/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"  \"<xliff:g id="APP_NAME">%1$s</xliff:g>\"      "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"      \"<xliff:g id="APP_NAME">%1$s</xliff:g>\"  "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"      \"<xliff:g id="APP_NAME">%1$s</xliff:g>\"  "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ar/feature_search_strings.xml b/photopicker/res/values-ar/feature_search_strings.xml
index b2ac5ad30..6c02bb732 100644
--- a/photopicker/res/values-ar/feature_search_strings.xml
+++ b/photopicker/res/values-ar/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"    "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"     .\n\n           ."</string>
 </resources>
diff --git a/photopicker/res/values-as/feature_category_grid_strings.xml b/photopicker/res/values-as/feature_category_grid_strings.xml
new file mode 100644
index 000000000..25be39553
--- /dev/null
+++ b/photopicker/res/values-as/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"           "</string>
+</resources>
diff --git a/photopicker/res/values-as/feature_preview_strings.xml b/photopicker/res/values-as/feature_preview_strings.xml
index d0b765a87..c4edef05a 100644
--- a/photopicker/res/values-as/feature_preview_strings.xml
+++ b/photopicker/res/values-as/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>   <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-as/feature_privacy_explainer_strings.xml b/photopicker/res/values-as/feature_privacy_explainer_strings.xml
index 72d16f3af..f1096d1ee 100644
--- a/photopicker/res/values-as/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-as/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-as/feature_search_strings.xml b/photopicker/res/values-as/feature_search_strings.xml
index 63ce1d998..8832d0be4 100644
--- a/photopicker/res/values-as/feature_search_strings.xml
+++ b/photopicker/res/values-as/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"    "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    \n\n        "</string>
 </resources>
diff --git a/photopicker/res/values-az/feature_category_grid_strings.xml b/photopicker/res/values-az/feature_category_grid_strings.xml
new file mode 100644
index 000000000..9dc516da0
--- /dev/null
+++ b/photopicker/res/values-az/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kolleksiyalar"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Hl insan v ev heyvanlar yoxdur"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Bnzr zlr sasnda qrupladrlm foto v videolar burada grnck"</string>
+</resources>
diff --git a/photopicker/res/values-az/feature_preview_strings.xml b/photopicker/res/values-az/feature_preview_strings.xml
index 768436689..00311fcbc 100644
--- a/photopicker/res/values-az/feature_preview_strings.xml
+++ b/photopicker/res/values-az/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Durdurun"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Sssiz edin"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ssi an"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Shif <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-az/feature_privacy_explainer_strings.xml b/photopicker/res/values-az/feature_privacy_explainer_strings.xml
index e5a816748..88c2c310b 100644
--- a/photopicker/res/values-az/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-az/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> yalnz sediyiniz fotolara daxil ola bilck"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g> ttbiqin giri imkan verdiyiniz foto v videolar sein"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g> ttbiqinin daxil ola bildiyi foto v videolar idar edin"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Bu ttbiq"</string>
 </resources>
diff --git a/photopicker/res/values-az/feature_search_strings.xml b/photopicker/res/values-az/feature_search_strings.xml
index 94f0f0e2f..de6705ae8 100644
--- a/photopicker/res/values-az/feature_search_strings.xml
+++ b/photopicker/res/values-az/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Axtar"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fotolar axtarn"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Videolar axtarn"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Axtar mtnini silin"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ntic taplmad"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Bnzr szlri axtarmaa aln"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Tkliflr"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Axtar deaktiv edildi."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Bnzr szlri axtarn.\n\nYalnz yedklnmi elementlr axtar nticlrinizd grnck."</string>
 </resources>
diff --git a/photopicker/res/values-b+sr+Latn/feature_category_grid_strings.xml b/photopicker/res/values-b+sr+Latn/feature_category_grid_strings.xml
new file mode 100644
index 000000000..8c4970879
--- /dev/null
+++ b/photopicker/res/values-b+sr+Latn/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kolekcije"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Jo nema ljudi ni kunih ljubimaca"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Ovde e se prikazivati slike i videi grupisani prema slinim licima"</string>
+</resources>
diff --git a/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml b/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml
index 367fa2630..ea9550bfe 100644
--- a/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pauziraj"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Iskljui zvuk"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ukljui zvuk"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>. stranica od <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-b+sr+Latn/feature_privacy_explainer_strings.xml b/photopicker/res/values-b+sr+Latn/feature_privacy_explainer_strings.xml
index 965a66bf9..02e6fc03e 100644
--- a/photopicker/res/values-b+sr+Latn/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> e imati pristup samo slikama koje izaberete"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Izaberite slike i video snimke kojima <xliff:g id="APP_NAME">%1$s</xliff:g> moe da pristupi"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Upravljajte slikama i videima kojima <xliff:g id="APP_NAME">%1$s</xliff:g> moe da pristupi"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ova aplikacija"</string>
 </resources>
diff --git a/photopicker/res/values-b+sr+Latn/feature_search_strings.xml b/photopicker/res/values-b+sr+Latn/feature_search_strings.xml
index 9bdc6550d..5e83c09e1 100644
--- a/photopicker/res/values-b+sr+Latn/feature_search_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pretraite"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pretraite slike"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pretraite video snimke"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Obrii tekst za pretragu"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nije pronaen nijedan rezultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Potraite sline rei"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Predlozi"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pretraga je onemoguena."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Potraite sline rei.\n\nU rezultatima pretrage se prikazuju samo stavke za koje je napravljena rezervna kopija."</string>
 </resources>
diff --git a/photopicker/res/values-be/feature_category_grid_strings.xml b/photopicker/res/values-be/feature_category_grid_strings.xml
new file mode 100644
index 000000000..2f9020cca
--- /dev/null
+++ b/photopicker/res/values-be/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"     ,    "</string>
+</resources>
diff --git a/photopicker/res/values-be/feature_preview_strings.xml b/photopicker/res/values-be/feature_preview_strings.xml
index b513b353a..725e0a25e 100644
--- a/photopicker/res/values-be/feature_preview_strings.xml
+++ b/photopicker/res/values-be/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-be/feature_privacy_explainer_strings.xml b/photopicker/res/values-be/feature_privacy_explainer_strings.xml
index 41f9b1819..9fdc93610 100644
--- a/photopicker/res/values-be/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-be/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">" \"<xliff:g id="APP_NAME">%1$s</xliff:g>\"        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   ,    \"<xliff:g id="APP_NAME">%1$s</xliff:g>\"   "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"   ,      \"<xliff:g id="APP_NAME">%1$s</xliff:g>\""</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-be/feature_search_strings.xml b/photopicker/res/values-be/feature_search_strings.xml
index c90fc7b44..dd86373cc 100644
--- a/photopicker/res/values-be/feature_search_strings.xml
+++ b/photopicker/res/values-be/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n       ,      ."</string>
 </resources>
diff --git a/photopicker/res/values-bg/feature_category_grid_strings.xml b/photopicker/res/values-bg/feature_category_grid_strings.xml
new file mode 100644
index 000000000..5bab8e73a
--- /dev/null
+++ b/photopicker/res/values-bg/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"      ,    "</string>
+</resources>
diff --git a/photopicker/res/values-bg/feature_preview_strings.xml b/photopicker/res/values-bg/feature_preview_strings.xml
index d436dcb51..4cdbcfaf9 100644
--- a/photopicker/res/values-bg/feature_preview_strings.xml
+++ b/photopicker/res/values-bg/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-bg/feature_privacy_explainer_strings.xml b/photopicker/res/values-bg/feature_privacy_explainer_strings.xml
index 33a1653dd..ca552f61a 100644
--- a/photopicker/res/values-bg/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-bg/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   ,       <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"    ,   <xliff:g id="APP_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-bg/feature_search_strings.xml b/photopicker/res/values-bg/feature_search_strings.xml
index 988ab4f53..eecf8ea8c 100644
--- a/photopicker/res/values-bg/feature_search_strings.xml
+++ b/photopicker/res/values-bg/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"    "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n         ,      ."</string>
 </resources>
diff --git a/photopicker/res/values-bn/feature_category_grid_strings.xml b/photopicker/res/values-bn/feature_category_grid_strings.xml
new file mode 100644
index 000000000..0bfd40d7b
--- /dev/null
+++ b/photopicker/res/values-bn/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"            "</string>
+</resources>
diff --git a/photopicker/res/values-bn/feature_preview_strings.xml b/photopicker/res/values-bn/feature_preview_strings.xml
index 0d3f1e018..30bef7683 100644
--- a/photopicker/res/values-bn/feature_preview_strings.xml
+++ b/photopicker/res/values-bn/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  "</string>
 </resources>
diff --git a/photopicker/res/values-bn/feature_privacy_explainer_strings.xml b/photopicker/res/values-bn/feature_privacy_explainer_strings.xml
index b3625eb36..8b86b1475 100644
--- a/photopicker/res/values-bn/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-bn/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"          <xliff:g id="APP_NAME">%1$s</xliff:g>  "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"    <xliff:g id="APP_NAME">%1$s</xliff:g>-     "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-bn/feature_search_strings.xml b/photopicker/res/values-bn/feature_search_strings.xml
index 155d50f33..1ba5f4645 100644
--- a/photopicker/res/values-bn/feature_search_strings.xml
+++ b/photopicker/res/values-bn/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"      "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"      \n\n  -         "</string>
 </resources>
diff --git a/photopicker/res/values-bs/feature_category_grid_strings.xml b/photopicker/res/values-bs/feature_category_grid_strings.xml
new file mode 100644
index 000000000..30d39eed8
--- /dev/null
+++ b/photopicker/res/values-bs/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kolekcije"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Jo uvijek nema osoba ni kunih ljubimaca"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Ovdje e se prikazivati fotografije i videozapisi grupisani prema slinim licima"</string>
+</resources>
diff --git a/photopicker/res/values-bs/feature_preview_strings.xml b/photopicker/res/values-bs/feature_preview_strings.xml
index 2eefc8405..02134e082 100644
--- a/photopicker/res/values-bs/feature_preview_strings.xml
+++ b/photopicker/res/values-bs/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pauziranje"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Iskljuivanje zvuka"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ukljuivanje zvuka"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Stranica <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> od <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-bs/feature_privacy_explainer_strings.xml b/photopicker/res/values-bs/feature_privacy_explainer_strings.xml
index 5713f6dfb..299b6d4b6 100644
--- a/photopicker/res/values-bs/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-bs/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> e imati pristup samo fotografijama koje odaberete"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Odaberite fotografije i videozapise kojima aplikacija <xliff:g id="APP_NAME">%1$s</xliff:g> moe pristupati"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Upravljajte fotografijama i videozapisima kojima aplikacija <xliff:g id="APP_NAME">%1$s</xliff:g> ima pristup"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ova aplikacija"</string>
 </resources>
diff --git a/photopicker/res/values-bs/feature_search_strings.xml b/photopicker/res/values-bs/feature_search_strings.xml
index e10cb46e3..f15506d73 100644
--- a/photopicker/res/values-bs/feature_search_strings.xml
+++ b/photopicker/res/values-bs/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pretraite"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pretraite fotografije"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pretraite videozapise"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Brisanje teksta za pretraivanje"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nije pronaen nijedan rezultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Pokuajte pretraiti sline rijei"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Prijedlozi"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pretraivanje je onemogueno."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Pokuajte pretraiti sline rijei.\n\nU rezultatima pretraivanja e se prikazati samo stavke ija je sigurnosna kopija napravljena."</string>
 </resources>
diff --git a/photopicker/res/values-ca/feature_category_grid_strings.xml b/photopicker/res/values-ca/feature_category_grid_strings.xml
new file mode 100644
index 000000000..caacde428
--- /dev/null
+++ b/photopicker/res/values-ca/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colleccions"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Encara no hi ha persones ni animals de companyia"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Les fotos i els vdeos, agrupats per cares semblants, es mostraran aqu"</string>
+</resources>
diff --git a/photopicker/res/values-ca/feature_cloud_strings.xml b/photopicker/res/values-ca/feature_cloud_strings.xml
index 41950a64a..f83798c2f 100644
--- a/photopicker/res/values-ca/feature_cloud_strings.xml
+++ b/photopicker/res/values-ca/feature_cloud_strings.xml
@@ -26,7 +26,7 @@
     <string name="photopicker_banner_cloud_choose_account_title" msgid="286679907089224434">"Tria un compte de <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_banner_cloud_choose_account_message" msgid="5173210485511611652">"Per incloure les fotos de <xliff:g id="APP_NAME">%1$s</xliff:g> aqu, tria un compte a l\'aplicaci"</string>
     <string name="photopicker_banner_cloud_choose_account_button" msgid="3407910358624445230">"Tria un compte"</string>
-    <string name="photopicker_banner_cloud_choose_provider_title" msgid="992613053341538886">"Tria una aplicaci multimdia amb servei al nvol"</string>
-    <string name="photopicker_banner_cloud_choose_provider_message" msgid="1102889303996108506">"Per incloure una cpia de seguretat de les fotos aqu, a Configuraci, tria una aplicaci multimdia amb servei al nvol"</string>
+    <string name="photopicker_banner_cloud_choose_provider_title" msgid="992613053341538886">"Tria una aplicaci de contingut multimdia al nvol"</string>
+    <string name="photopicker_banner_cloud_choose_provider_message" msgid="1102889303996108506">"Per incloure una cpia de seguretat de les fotos aqu, a Configuraci, tria una aplicaci de contingut multimdia al nvol"</string>
     <string name="photopicker_banner_cloud_choose_app_button" msgid="8228365266860220123">"Tria una aplicaci"</string>
 </resources>
diff --git a/photopicker/res/values-ca/feature_overflow_menu_strings.xml b/photopicker/res/values-ca/feature_overflow_menu_strings.xml
index 824f7907b..42b7bd083 100644
--- a/photopicker/res/values-ca/feature_overflow_menu_strings.xml
+++ b/photopicker/res/values-ca/feature_overflow_menu_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_overflow_menu_description" msgid="6548535301621140571">"Ms"</string>
-    <string name="photopicker_overflow_cloud_media_app" msgid="1790591881463404779">"Aplicaci multimdia al nvol"</string>
+    <string name="photopicker_overflow_cloud_media_app" msgid="1790591881463404779">"App de contingut multimdia al nvol"</string>
     <string name="photopicker_overflow_browse" msgid="6764715084773515122">"Navega"</string>
 </resources>
diff --git a/photopicker/res/values-ca/feature_preview_strings.xml b/photopicker/res/values-ca/feature_preview_strings.xml
index 2139d93e1..943bdb545 100644
--- a/photopicker/res/values-ca/feature_preview_strings.xml
+++ b/photopicker/res/values-ca/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Posa en pausa"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Silencia el volum"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Deixa de silenciar el volum"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pgina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ca/feature_privacy_explainer_strings.xml b/photopicker/res/values-ca/feature_privacy_explainer_strings.xml
index 1829dcceb..cad6298b0 100644
--- a/photopicker/res/values-ca/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ca/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> noms tindr accs a les fotos que seleccionis"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecciona les fotos i els vdeos als quals permets que accedeixi <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Gestiona les fotos i els vdeos a qu t accs <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Aquesta aplicaci"</string>
 </resources>
diff --git a/photopicker/res/values-ca/feature_search_strings.xml b/photopicker/res/values-ca/feature_search_strings.xml
index e10120469..0c7655f27 100644
--- a/photopicker/res/values-ca/feature_search_strings.xml
+++ b/photopicker/res/values-ca/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Cerca"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Cerca a les teves fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Cerca als teus vdeos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Esborra el text del quadre de cerca"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No s\'ha trobat cap resultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prova de cercar paraules similars"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggeriments"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Cerca desactivada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prova de cercar paraules similars.\n\nNoms els elements de qu s\'hagi creat una cpia de seguretat es mostraran als resultats de la cerca."</string>
 </resources>
diff --git a/photopicker/res/values-cs/feature_category_grid_strings.xml b/photopicker/res/values-cs/feature_category_grid_strings.xml
new file mode 100644
index 000000000..586e7557b
--- /dev/null
+++ b/photopicker/res/values-cs/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Sbrky"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Vkategorii Lid ajejich mazlci zatm nic nemte"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Tady se zobraz fotky avidea seskupen podle podobnch obliej"</string>
+</resources>
diff --git a/photopicker/res/values-cs/feature_preview_strings.xml b/photopicker/res/values-cs/feature_preview_strings.xml
index 16a9d3b96..8263914e8 100644
--- a/photopicker/res/values-cs/feature_preview_strings.xml
+++ b/photopicker/res/values-cs/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pozastavit"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Vypnout zvuk"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Zapnout zvuk"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Strana <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> z<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-cs/feature_privacy_explainer_strings.xml b/photopicker/res/values-cs/feature_privacy_explainer_strings.xml
index 488206440..009e0d3cb 100644
--- a/photopicker/res/values-cs/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-cs/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Aplikace <xliff:g id="APP_NAME">%1$s</xliff:g> m pstup jen kfotkm, kter vyberete"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Vyberte fotky avidea, ke kterm aplikaci <xliff:g id="APP_NAME">%1$s</xliff:g> chcete povolit pstup"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Spravujte fotky avidea, ke kterm m aplikace <xliff:g id="APP_NAME">%1$s</xliff:g> pstup"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Tato aplikace"</string>
 </resources>
diff --git a/photopicker/res/values-cs/feature_search_strings.xml b/photopicker/res/values-cs/feature_search_strings.xml
index 07fddb9c5..b23dee5dd 100644
--- a/photopicker/res/values-cs/feature_search_strings.xml
+++ b/photopicker/res/values-cs/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Hledat"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Hledat ve vaich fotkch"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hledat ve vaich videch"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Vymazat hledan text"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"dn vsledky"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Zkuste vyhledat podobn slova"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Nvrhy"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Vyhledvn vypnuto."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Zkuste vyhledat podobn slova.\n\nVe vsledcch vyhledvn se zobraz jen zlohovan poloky."</string>
 </resources>
diff --git a/photopicker/res/values-da/feature_category_grid_strings.xml b/photopicker/res/values-da/feature_category_grid_strings.xml
new file mode 100644
index 000000000..9dbd88be4
--- /dev/null
+++ b/photopicker/res/values-da/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Samlinger"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Der er ingen personer eller kledyr endnu"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Billeder og videoer, der er grupperet efter lignende ansigter, vises her"</string>
+</resources>
diff --git a/photopicker/res/values-da/feature_preview_strings.xml b/photopicker/res/values-da/feature_preview_strings.xml
index 88e46c442..0fba1316b 100644
--- a/photopicker/res/values-da/feature_preview_strings.xml
+++ b/photopicker/res/values-da/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"St p pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Sl lyden fra"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Sl lyden til"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Side <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> af <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-da/feature_privacy_explainer_strings.xml b/photopicker/res/values-da/feature_privacy_explainer_strings.xml
index f427fc24c..ea74af397 100644
--- a/photopicker/res/values-da/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-da/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> tilgr kun de billeder, du vlger"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Vlg de billeder og videoer, som du vil give <xliff:g id="APP_NAME">%1$s</xliff:g> tilladelse til at tilg"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Administrer, hvilke billeder og videoer <xliff:g id="APP_NAME">%1$s</xliff:g> har adgang til"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Denne app"</string>
 </resources>
diff --git a/photopicker/res/values-da/feature_search_strings.xml b/photopicker/res/values-da/feature_search_strings.xml
index 54db9cc6c..91126c49b 100644
--- a/photopicker/res/values-da/feature_search_strings.xml
+++ b/photopicker/res/values-da/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sg"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sg i dine billeder"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sg i dine videoer"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Ryd sgetekst"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ingen resultater fundet"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prv at sge efter lignende ord"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Forslag"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Sgning er deaktiveret."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prv at sge efter lignende ord.\n\nDet er kun elementer, der er sikkerhedskopieret, som vises i dine sgeresultater."</string>
 </resources>
diff --git a/photopicker/res/values-de/feature_category_grid_strings.xml b/photopicker/res/values-de/feature_category_grid_strings.xml
new file mode 100644
index 000000000..e483c9a52
--- /dev/null
+++ b/photopicker/res/values-de/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Sammlungen"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Noch keine Personen&amp; Haustiere"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Hier werden nach hnlichen Gesichtern gruppierte Fotos und Videos angezeigt"</string>
+</resources>
diff --git a/photopicker/res/values-de/feature_preview_strings.xml b/photopicker/res/values-de/feature_preview_strings.xml
index e4ae01d84..95456d98e 100644
--- a/photopicker/res/values-de/feature_preview_strings.xml
+++ b/photopicker/res/values-de/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausieren"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Ton ausschalten"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ton anschalten"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Seite<xliff:g id="PAGE_NUMBER">%1$s</xliff:g> von<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-de/feature_privacy_explainer_strings.xml b/photopicker/res/values-de/feature_privacy_explainer_strings.xml
index 283139ba1..6d37781c6 100644
--- a/photopicker/res/values-de/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-de/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> greift nur auf die von dir ausgewhlten Fotos zu"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Auswhlen, auf welche Fotos und Videos <xliff:g id="APP_NAME">%1$s</xliff:g> zugreifen darf"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Verwalten, auf welche Fotos und Videos <xliff:g id="APP_NAME">%1$s</xliff:g> Zugriff hat"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Diese App"</string>
 </resources>
diff --git a/photopicker/res/values-de/feature_search_strings.xml b/photopicker/res/values-de/feature_search_strings.xml
index cbbeedece..58e9a9c70 100644
--- a/photopicker/res/values-de/feature_search_strings.xml
+++ b/photopicker/res/values-de/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Suchen"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"In Fotos suchen"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Deine Videos durchsuchen"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Sucheingabe lschen"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Keine Ergebnisse gefunden"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Versuche es mit einer Suche anhand hnlicher Wrter"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Vorschlge"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Suche deaktiviert."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Versuche, nach hnlichen Wrtern zu suchen.\n\nIn den Suchergebnissen werden nur gesicherte Elemente angezeigt."</string>
 </resources>
diff --git a/photopicker/res/values-el/feature_category_grid_strings.xml b/photopicker/res/values-el/feature_category_grid_strings.xml
new file mode 100644
index 000000000..ee3e26b89
--- /dev/null
+++ b/photopicker/res/values-el/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"        "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"    ,      ,   "</string>
+</resources>
diff --git a/photopicker/res/values-el/feature_preview_strings.xml b/photopicker/res/values-el/feature_preview_strings.xml
index b523ea8d1..cf5f90e1b 100644
--- a/photopicker/res/values-el/feature_preview_strings.xml
+++ b/photopicker/res/values-el/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-el/feature_privacy_explainer_strings.xml b/photopicker/res/values-el/feature_privacy_explainer_strings.xml
index ab1ffe8ca..354f7fe31 100644
--- a/photopicker/res/values-el/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-el/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"  <xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"            <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"            <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"  "</string>
 </resources>
diff --git a/photopicker/res/values-el/feature_search_strings.xml b/photopicker/res/values-el/feature_search_strings.xml
index 0d735c6f4..c37c1ee8c 100644
--- a/photopicker/res/values-el/feature_search_strings.xml
+++ b/photopicker/res/values-el/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n  ,            ."</string>
 </resources>
diff --git a/photopicker/res/values-en-rAU/feature_category_grid_strings.xml b/photopicker/res/values-en-rAU/feature_category_grid_strings.xml
new file mode 100644
index 000000000..4b9e44baa
--- /dev/null
+++ b/photopicker/res/values-en-rAU/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collections"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"No people and pets yet"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Photos and videos, grouped by similar faces, will appear here"</string>
+</resources>
diff --git a/photopicker/res/values-en-rAU/feature_preview_strings.xml b/photopicker/res/values-en-rAU/feature_preview_strings.xml
index e1979db42..409aa26c2 100644
--- a/photopicker/res/values-en-rAU/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rAU/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Mute volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Unmute volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> of <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-en-rAU/feature_privacy_explainer_strings.xml b/photopicker/res/values-en-rAU/feature_privacy_explainer_strings.xml
index 665ee7b79..3ff45832d 100644
--- a/photopicker/res/values-en-rAU/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-en-rAU/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> will only have access to the photos that you select"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Select photos and videos that you allow <xliff:g id="APP_NAME">%1$s</xliff:g> to access"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Manage photos and videos <xliff:g id="APP_NAME">%1$s</xliff:g> has access to"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"This app"</string>
 </resources>
diff --git a/photopicker/res/values-en-rAU/feature_search_strings.xml b/photopicker/res/values-en-rAU/feature_search_strings.xml
index 48623b657..e38c2af7d 100644
--- a/photopicker/res/values-en-rAU/feature_search_strings.xml
+++ b/photopicker/res/values-en-rAU/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Clear search text"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Try searching for similar words.\n\nOnly items that are backed up will appear in your search results."</string>
 </resources>
diff --git a/photopicker/res/values-en-rCA/feature_category_grid_strings.xml b/photopicker/res/values-en-rCA/feature_category_grid_strings.xml
new file mode 100644
index 000000000..ed8e2ef3f
--- /dev/null
+++ b/photopicker/res/values-en-rCA/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collections"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"No people &amp; pets yet"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Photos and videos, grouped by similar faces, will appear here"</string>
+</resources>
diff --git a/photopicker/res/values-en-rCA/feature_preview_strings.xml b/photopicker/res/values-en-rCA/feature_preview_strings.xml
index 4d7b57613..57f3848d6 100644
--- a/photopicker/res/values-en-rCA/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rCA/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Mute Volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Unmute Volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> of <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-en-rCA/feature_privacy_explainer_strings.xml b/photopicker/res/values-en-rCA/feature_privacy_explainer_strings.xml
index 47f8044d6..d522a52d0 100644
--- a/photopicker/res/values-en-rCA/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-en-rCA/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> will only have access to the photos you select"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Select photos and videos that you allow <xliff:g id="APP_NAME">%1$s</xliff:g> to access"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Manage photos and videos <xliff:g id="APP_NAME">%1$s</xliff:g> has access to"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"This app"</string>
 </resources>
diff --git a/photopicker/res/values-en-rCA/feature_search_strings.xml b/photopicker/res/values-en-rCA/feature_search_strings.xml
index 48623b657..e38c2af7d 100644
--- a/photopicker/res/values-en-rCA/feature_search_strings.xml
+++ b/photopicker/res/values-en-rCA/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Clear search text"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Try searching for similar words.\n\nOnly items that are backed up will appear in your search results."</string>
 </resources>
diff --git a/photopicker/res/values-en-rGB/feature_category_grid_strings.xml b/photopicker/res/values-en-rGB/feature_category_grid_strings.xml
new file mode 100644
index 000000000..4b9e44baa
--- /dev/null
+++ b/photopicker/res/values-en-rGB/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collections"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"No people and pets yet"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Photos and videos, grouped by similar faces, will appear here"</string>
+</resources>
diff --git a/photopicker/res/values-en-rGB/feature_preview_strings.xml b/photopicker/res/values-en-rGB/feature_preview_strings.xml
index e1979db42..409aa26c2 100644
--- a/photopicker/res/values-en-rGB/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rGB/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Mute volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Unmute volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> of <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-en-rGB/feature_privacy_explainer_strings.xml b/photopicker/res/values-en-rGB/feature_privacy_explainer_strings.xml
index 665ee7b79..3ff45832d 100644
--- a/photopicker/res/values-en-rGB/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-en-rGB/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> will only have access to the photos that you select"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Select photos and videos that you allow <xliff:g id="APP_NAME">%1$s</xliff:g> to access"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Manage photos and videos <xliff:g id="APP_NAME">%1$s</xliff:g> has access to"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"This app"</string>
 </resources>
diff --git a/photopicker/res/values-en-rGB/feature_search_strings.xml b/photopicker/res/values-en-rGB/feature_search_strings.xml
index 48623b657..e38c2af7d 100644
--- a/photopicker/res/values-en-rGB/feature_search_strings.xml
+++ b/photopicker/res/values-en-rGB/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Clear search text"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Try searching for similar words.\n\nOnly items that are backed up will appear in your search results."</string>
 </resources>
diff --git a/photopicker/res/values-en-rIN/feature_category_grid_strings.xml b/photopicker/res/values-en-rIN/feature_category_grid_strings.xml
new file mode 100644
index 000000000..4b9e44baa
--- /dev/null
+++ b/photopicker/res/values-en-rIN/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collections"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"No people and pets yet"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Photos and videos, grouped by similar faces, will appear here"</string>
+</resources>
diff --git a/photopicker/res/values-en-rIN/feature_preview_strings.xml b/photopicker/res/values-en-rIN/feature_preview_strings.xml
index e1979db42..409aa26c2 100644
--- a/photopicker/res/values-en-rIN/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rIN/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Mute volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Unmute volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> of <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-en-rIN/feature_privacy_explainer_strings.xml b/photopicker/res/values-en-rIN/feature_privacy_explainer_strings.xml
index 665ee7b79..3ff45832d 100644
--- a/photopicker/res/values-en-rIN/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-en-rIN/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> will only have access to the photos that you select"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Select photos and videos that you allow <xliff:g id="APP_NAME">%1$s</xliff:g> to access"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Manage photos and videos <xliff:g id="APP_NAME">%1$s</xliff:g> has access to"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"This app"</string>
 </resources>
diff --git a/photopicker/res/values-en-rIN/feature_search_strings.xml b/photopicker/res/values-en-rIN/feature_search_strings.xml
index 48623b657..e38c2af7d 100644
--- a/photopicker/res/values-en-rIN/feature_search_strings.xml
+++ b/photopicker/res/values-en-rIN/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Clear search text"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Try searching for similar words.\n\nOnly items that are backed up will appear in your search results."</string>
 </resources>
diff --git a/photopicker/res/values-es-rUS-feminine/core_strings.xml b/photopicker/res/values-es-rUS-feminine/core_strings.xml
new file mode 100644
index 000000000..e93d29d7f
--- /dev/null
+++ b/photopicker/res/values-es-rUS-feminine/core_strings.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+ Copyright 2024 The Android Open Source Project
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> tomada el <xliff:g id="TIME">%2$s</xliff:g>"</string>
+</resources>
diff --git a/photopicker/res/values-es-rUS-masculine/core_strings.xml b/photopicker/res/values-es-rUS-masculine/core_strings.xml
new file mode 100644
index 000000000..48eacb14a
--- /dev/null
+++ b/photopicker/res/values-es-rUS-masculine/core_strings.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+ Copyright 2024 The Android Open Source Project
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> tomado el <xliff:g id="TIME">%2$s</xliff:g>"</string>
+</resources>
diff --git a/photopicker/res/values-es-rUS-neuter/core_strings.xml b/photopicker/res/values-es-rUS-neuter/core_strings.xml
new file mode 100644
index 000000000..48eacb14a
--- /dev/null
+++ b/photopicker/res/values-es-rUS-neuter/core_strings.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+ Copyright 2024 The Android Open Source Project
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> tomado el <xliff:g id="TIME">%2$s</xliff:g>"</string>
+</resources>
diff --git a/photopicker/res/values-es-rUS/feature_category_grid_strings.xml b/photopicker/res/values-es-rUS/feature_category_grid_strings.xml
new file mode 100644
index 000000000..40a13d3d1
--- /dev/null
+++ b/photopicker/res/values-es-rUS/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colecciones"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"An no hay personas ni mascotas"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Aqu aparecern las fotos y los videos agrupados por rostros similares"</string>
+</resources>
diff --git a/photopicker/res/values-es-rUS/feature_preview_strings.xml b/photopicker/res/values-es-rUS/feature_preview_strings.xml
index a3f660ae3..a9a27c3a5 100644
--- a/photopicker/res/values-es-rUS/feature_preview_strings.xml
+++ b/photopicker/res/values-es-rUS/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausar"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Silenciar volumen"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Activar sonido"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pgina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-es-rUS/feature_privacy_explainer_strings.xml b/photopicker/res/values-es-rUS/feature_privacy_explainer_strings.xml
index 36ba9ed57..6503ea82d 100644
--- a/photopicker/res/values-es-rUS/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-es-rUS/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> solo tendr acceso a las fotos que selecciones"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecciona fotos y videos a los que permites que <xliff:g id="APP_NAME">%1$s</xliff:g> acceda"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Administra las fotos y los videos a los que tiene acceso <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Esta app"</string>
 </resources>
diff --git a/photopicker/res/values-es-rUS/feature_search_strings.xml b/photopicker/res/values-es-rUS/feature_search_strings.xml
index 97bc545d4..4de4da21d 100644
--- a/photopicker/res/values-es-rUS/feature_search_strings.xml
+++ b/photopicker/res/values-es-rUS/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Buscar"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Buscar fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Buscar en tus videos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Borrar el texto de la bsqueda"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No se encontraron resultados"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Intenta buscar palabras similares"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugerencias"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Bsqueda inhabilitada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Intenta buscar palabras similares.\n\nSolo los elementos a los que se les haya creado una copia de seguridad aparecern en los resultados de la bsqueda."</string>
 </resources>
diff --git a/photopicker/res/values-es/feature_category_grid_strings.xml b/photopicker/res/values-es/feature_category_grid_strings.xml
new file mode 100644
index 000000000..17585850c
--- /dev/null
+++ b/photopicker/res/values-es/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colecciones"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"An no hay personas ni mascotas"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Las fotos y los vdeos, agrupados por caras similares, aparecern aqu"</string>
+</resources>
diff --git a/photopicker/res/values-es/feature_preview_strings.xml b/photopicker/res/values-es/feature_preview_strings.xml
index 36dd411b3..a2132b584 100644
--- a/photopicker/res/values-es/feature_preview_strings.xml
+++ b/photopicker/res/values-es/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausar"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Silenciar sonido"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Activar volumen"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pgina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-es/feature_privacy_explainer_strings.xml b/photopicker/res/values-es/feature_privacy_explainer_strings.xml
index a30bdda0d..2dd1a1412 100644
--- a/photopicker/res/values-es/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-es/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> solo tendr acceso a las fotos que selecciones"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecciona las fotos y los vdeos a los que <xliff:g id="APP_NAME">%1$s</xliff:g> podr tener acceso"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Gestiona las fotos y los vdeos a los que <xliff:g id="APP_NAME">%1$s</xliff:g> tiene acceso"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Esta aplicacin"</string>
 </resources>
diff --git a/photopicker/res/values-es/feature_search_strings.xml b/photopicker/res/values-es/feature_search_strings.xml
index 4efc06bd5..37c3a7b19 100644
--- a/photopicker/res/values-es/feature_search_strings.xml
+++ b/photopicker/res/values-es/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Buscar"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Buscar en tus fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Buscar en tus vdeos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Borrar el texto de la bsqueda"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No hay resultados"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prueba a buscar palabras similares"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugerencias"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Bsqueda inhabilitada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prueba a buscar palabras similares.\n\nSolo los elementos con copia de seguridad aparecern en los resultados de bsqueda."</string>
 </resources>
diff --git a/photopicker/res/values-et/feature_category_grid_strings.xml b/photopicker/res/values-et/feature_category_grid_strings.xml
new file mode 100644
index 000000000..0e7ed573c
--- /dev/null
+++ b/photopicker/res/values-et/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kogud"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Inimesi ja lemmikloomi veel pole"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Siin kuvatakse sarnaste ngude alusel rhmitatud fotod ja videod"</string>
+</resources>
diff --git a/photopicker/res/values-et/feature_preview_strings.xml b/photopicker/res/values-et/feature_preview_strings.xml
index a2da29b6a..79787ad1d 100644
--- a/photopicker/res/values-et/feature_preview_strings.xml
+++ b/photopicker/res/values-et/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Peata"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Vaigista heli"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Thista heli vaigistus"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Leht <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-et/feature_privacy_explainer_strings.xml b/photopicker/res/values-et/feature_privacy_explainer_strings.xml
index 5dbd864df..5963a4a73 100644
--- a/photopicker/res/values-et/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-et/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> pseb juurde ainult teie valitud fotodele"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Valige fotod ja videod, millele lubate rakendusel <xliff:g id="APP_NAME">%1$s</xliff:g> juurde pseda"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Hallake fotosid ja videoid, millele rakendusel <xliff:g id="APP_NAME">%1$s</xliff:g> on juurdeps"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"See rakendus"</string>
 </resources>
diff --git a/photopicker/res/values-et/feature_search_strings.xml b/photopicker/res/values-et/feature_search_strings.xml
index 924881fea..46bee6d44 100644
--- a/photopicker/res/values-et/feature_search_strings.xml
+++ b/photopicker/res/values-et/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Otsing"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Otsige oma fotosid"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Otsige oma videoid"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Kustuta otsingu tekst"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Tulemusi ei leitud"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Proovige otsida sarnaseid snu"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Soovitused"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Otsing keelatud"</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Proovige otsida sarnaseid snu.\n\nTeie otsingutulemustes kuvatakse ainult varundatud ksused."</string>
 </resources>
diff --git a/photopicker/res/values-eu/feature_category_grid_strings.xml b/photopicker/res/values-eu/feature_category_grid_strings.xml
new file mode 100644
index 000000000..1a147cab9
--- /dev/null
+++ b/photopicker/res/values-eu/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Bildumak"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Oraindik ez dago pertsonarik, ezta konpainia-animaliarik ere"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Antzeko aurpegien arabera taldekatutako argazkiak eta bideoak agertuko dira hemen"</string>
+</resources>
diff --git a/photopicker/res/values-eu/feature_preview_strings.xml b/photopicker/res/values-eu/feature_preview_strings.xml
index c1c21a6f6..b9984ca4f 100644
--- a/photopicker/res/values-eu/feature_preview_strings.xml
+++ b/photopicker/res/values-eu/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausatu"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Desaktibatu bolumena"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Aktibatu bolumena"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g> orritatik <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>garrena"</string>
 </resources>
diff --git a/photopicker/res/values-eu/feature_privacy_explainer_strings.xml b/photopicker/res/values-eu/feature_privacy_explainer_strings.xml
index 9e414c9d5..8e67c1af5 100644
--- a/photopicker/res/values-eu/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-eu/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Hautatzen dituzun argazkiak erabiltzeko baimena baino ez du izango <xliff:g id="APP_NAME">%1$s</xliff:g> aplikazioak"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Hautatu <xliff:g id="APP_NAME">%1$s</xliff:g> erabili ahalko dituen argazki eta bideoak"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Kudeatu <xliff:g id="APP_NAME">%1$s</xliff:g> aplikazioak atzi ditzakeen argazki eta bideoak"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"aplikazio honek"</string>
 </resources>
diff --git a/photopicker/res/values-eu/feature_search_strings.xml b/photopicker/res/values-eu/feature_search_strings.xml
index cf4346e81..298574c31 100644
--- a/photopicker/res/values-eu/feature_search_strings.xml
+++ b/photopicker/res/values-eu/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Bilatu"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Bilatu argazkietan"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Bilatu bideoetan"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Garbitu bilaketa-eremua"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ez da aurkitu emaitzarik"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Bilatu antzeko hitzak"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Iradokizunak"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Bilaketa desgaituta dago."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Bilatu antzeko hitzak.\n\nBabeskopia eginda daukaten elementuak soilik agertuko dira bilaketa-emaitzetan."</string>
 </resources>
diff --git a/photopicker/res/values-fa/core_strings.xml b/photopicker/res/values-fa/core_strings.xml
index dfe7224e0..c78966a0d 100644
--- a/photopicker/res/values-fa/core_strings.xml
+++ b/photopicker/res/values-fa/core_strings.xml
@@ -32,7 +32,7 @@
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
     <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>      "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
-    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
+    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">"   "</string>
     <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"      "</string>
diff --git a/photopicker/res/values-fa/feature_category_grid_strings.xml b/photopicker/res/values-fa/feature_category_grid_strings.xml
new file mode 100644
index 000000000..39a4ffe41
--- /dev/null
+++ b/photopicker/res/values-fa/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"             "</string>
+</resources>
diff --git a/photopicker/res/values-fa/feature_preview_strings.xml b/photopicker/res/values-fa/feature_preview_strings.xml
index d1abcf9c7..3a6965018 100644
--- a/photopicker/res/values-fa/feature_preview_strings.xml
+++ b/photopicker/res/values-fa/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-fa/feature_privacy_explainer_strings.xml b/photopicker/res/values-fa/feature_privacy_explainer_strings.xml
index 57d1fd666..a719b0ff1 100644
--- a/photopicker/res/values-fa/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-fa/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>          "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"        <xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"      <xliff:g id="APP_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-fa/feature_profiles_strings.xml b/photopicker/res/values-fa/feature_profiles_strings.xml
index 301bf4daf..47913d7d9 100644
--- a/photopicker/res/values-fa/feature_profiles_strings.xml
+++ b/photopicker/res/values-fa/feature_profiles_strings.xml
@@ -20,7 +20,7 @@
     <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
-    <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
     <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"     "</string>
diff --git a/photopicker/res/values-fa/feature_search_strings.xml b/photopicker/res/values-fa/feature_search_strings.xml
index 8e2d1cb2e..10c888f38 100644
--- a/photopicker/res/values-fa/feature_search_strings.xml
+++ b/photopicker/res/values-fa/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n          ."</string>
 </resources>
diff --git a/photopicker/res/values-fi/core_strings.xml b/photopicker/res/values-fi/core_strings.xml
index 1915f8625..e5494aaf7 100644
--- a/photopicker/res/values-fi/core_strings.xml
+++ b/photopicker/res/values-fi/core_strings.xml
@@ -35,7 +35,7 @@
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Kuvat"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumit"</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">"Ei viel kuvia"</string>
-    <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"Aloita kuvien ja videoiden tallennus"</string>
+    <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"Aloita kuvaaminen"</string>
     <string name="photopicker_camera_empty_state_body" msgid="858373882699294081">"Kamerasovelluksen ottamat kuvat ja videot nkyvt tll"</string>
     <string name="photopicker_favorites_empty_state_title" msgid="3855048169943856242">"Ei viel suosikkeja"</string>
     <string name="photopicker_favorites_empty_state_body" msgid="4206436541083780797">"Thdell tai suosikeiksi merkityt kuvat ja videot nkyvt tll"</string>
diff --git a/photopicker/res/values-fi/feature_category_grid_strings.xml b/photopicker/res/values-fi/feature_category_grid_strings.xml
new file mode 100644
index 000000000..27df276a8
--- /dev/null
+++ b/photopicker/res/values-fi/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kokoelmat"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ei viel ihmisi ja lemmikkej"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Samanlaisten kasvojen mukaan ryhmitellyt kuvat ja videot nkyvt tll"</string>
+</resources>
diff --git a/photopicker/res/values-fi/feature_preview_strings.xml b/photopicker/res/values-fi/feature_preview_strings.xml
index 1ae9f361f..0382bb357 100644
--- a/photopicker/res/values-fi/feature_preview_strings.xml
+++ b/photopicker/res/values-fi/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Keskeyt"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Mykist net"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Poista nten mykistys"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Sivu <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-fi/feature_privacy_explainer_strings.xml b/photopicker/res/values-fi/feature_privacy_explainer_strings.xml
index a6446f1d5..125344b3c 100644
--- a/photopicker/res/values-fi/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-fi/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> saa psyn vain valitsemiisi kuviin"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Valitse kuvat ja videot, joihin <xliff:g id="APP_NAME">%1$s</xliff:g> saa psyn"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Hallinnoi kuvia ja videoita, joihin <xliff:g id="APP_NAME">%1$s</xliff:g> saa psyn"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Tm sovellus"</string>
 </resources>
diff --git a/photopicker/res/values-fi/feature_search_strings.xml b/photopicker/res/values-fi/feature_search_strings.xml
index 11fe5b16a..082e02afc 100644
--- a/photopicker/res/values-fi/feature_search_strings.xml
+++ b/photopicker/res/values-fi/feature_search_strings.xml
@@ -17,11 +17,13 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Haku"</string>
-    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Etsi kuvistasi"</string>
+    <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Hae"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Hae kuvistasi"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hae omia videoitasi"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Tyhjenn hakuteksti"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ei tuloksia"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Kokeile hakea samankaltaisia sanoja"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Ehdotukset"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Haku poistettu kytst."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Kokeile hakea samankaltaisia sanoja.\n\nVain varmuuskopioidut kohteet nkyvt hakutuloksissa."</string>
 </resources>
diff --git a/photopicker/res/values-fr-rCA/feature_category_grid_strings.xml b/photopicker/res/values-fr-rCA/feature_category_grid_strings.xml
new file mode 100644
index 000000000..063bd5651
--- /dev/null
+++ b/photopicker/res/values-fr-rCA/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collections"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Pas encore de personnes ni d\'animaux"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Les photos et les vidos, regroupes par visages similaires, s\'afficheront ici"</string>
+</resources>
diff --git a/photopicker/res/values-fr-rCA/feature_preview_strings.xml b/photopicker/res/values-fr-rCA/feature_preview_strings.xml
index 9f4f20502..79b988764 100644
--- a/photopicker/res/values-fr-rCA/feature_preview_strings.xml
+++ b/photopicker/res/values-fr-rCA/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Mettre en pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Dsactiver le son"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ractiver le son"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page<xliff:g id="PAGE_NUMBER">%1$s</xliff:g> sur <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-fr-rCA/feature_privacy_explainer_strings.xml b/photopicker/res/values-fr-rCA/feature_privacy_explainer_strings.xml
index c50bd9247..e9e90fd5f 100644
--- a/photopicker/res/values-fr-rCA/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-fr-rCA/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> accdera uniquement aux photos que vous slectionnez"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Slectionnez les photos et les vidos auxquelles vous autorisez <xliff:g id="APP_NAME">%1$s</xliff:g>  accder"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Grer les photos et les vidos auxquelles <xliff:g id="APP_NAME">%1$s</xliff:g> a accs"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Cette appli"</string>
 </resources>
diff --git a/photopicker/res/values-fr-rCA/feature_search_strings.xml b/photopicker/res/values-fr-rCA/feature_search_strings.xml
index 2f4e78c42..7e9c7b336 100644
--- a/photopicker/res/values-fr-rCA/feature_search_strings.xml
+++ b/photopicker/res/values-fr-rCA/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Rechercher"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Rechercher des photos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Rechercher des vidos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Effacer le texte de recherche"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Aucun rsultat trouv"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Essayez de rechercher des mots semblables"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Recherche dsactive."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Essayez de chercher des mots semblables.\n\nSeuls les lments sauvegards apparatront dans vos rsultats de recherche."</string>
 </resources>
diff --git a/photopicker/res/values-fr/feature_category_grid_strings.xml b/photopicker/res/values-fr/feature_category_grid_strings.xml
new file mode 100644
index 000000000..af27cee05
--- /dev/null
+++ b/photopicker/res/values-fr/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collections"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Pas de personnes ni d\'animaux pour l\'instant"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Les photos et vidos, regroupes par visages similaires, s\'afficheront ici"</string>
+</resources>
diff --git a/photopicker/res/values-fr/feature_preview_strings.xml b/photopicker/res/values-fr/feature_preview_strings.xml
index 48c64aa07..f5673f08f 100644
--- a/photopicker/res/values-fr/feature_preview_strings.xml
+++ b/photopicker/res/values-fr/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Mettre en pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Couper le son"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ractiver le son"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page<xliff:g id="PAGE_NUMBER">%1$s</xliff:g> sur<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-fr/feature_privacy_explainer_strings.xml b/photopicker/res/values-fr/feature_privacy_explainer_strings.xml
index 6340fbf9b..e4dd50db7 100644
--- a/photopicker/res/values-fr/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-fr/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> n\'aura accs qu\'aux photos que vous slectionnez"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Slectionnez les photos et les vidos auxquelles vous autorisez <xliff:g id="APP_NAME">%1$s</xliff:g>  accder"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Grer les photos et vidos auxquelles <xliff:g id="APP_NAME">%1$s</xliff:g> a accs"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Cette appli"</string>
 </resources>
diff --git a/photopicker/res/values-fr/feature_search_strings.xml b/photopicker/res/values-fr/feature_search_strings.xml
index a14aa300b..8e58e950e 100644
--- a/photopicker/res/values-fr/feature_search_strings.xml
+++ b/photopicker/res/values-fr/feature_search_strings.xml
@@ -18,10 +18,12 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Rechercher"</string>
-    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Rechercher des photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Rechercher dans vos photos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Rechercher des vidos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Effacer le texte de recherche"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Aucun rsultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Essayez de rechercher des mots similaires"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Recherche dsactive."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Essayez de rechercher des mots similaires.\n\nSeuls les lments sauvegards apparatront dans vos rsultats de recherche."</string>
 </resources>
diff --git a/photopicker/res/values-gl/feature_category_grid_strings.xml b/photopicker/res/values-gl/feature_category_grid_strings.xml
new file mode 100644
index 000000000..fe5fb9e27
--- /dev/null
+++ b/photopicker/res/values-gl/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Coleccins"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Anda non hai ningunha persoa nin mascota"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"As fotos e os vdeos, agrupados por caras similares, aparecern aqu"</string>
+</resources>
diff --git a/photopicker/res/values-gl/feature_preview_strings.xml b/photopicker/res/values-gl/feature_preview_strings.xml
index aeb04b97e..a9e1b8d34 100644
--- a/photopicker/res/values-gl/feature_preview_strings.xml
+++ b/photopicker/res/values-gl/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pr en pausa"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Silenciar"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Activar o son"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pxina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-gl/feature_privacy_explainer_strings.xml b/photopicker/res/values-gl/feature_privacy_explainer_strings.xml
index 48361a6b9..f5b0e21ac 100644
--- a/photopicker/res/values-gl/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-gl/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> s ter acceso s fotos que selecciones"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecciona as fotos e os vdeos aos que pode acceder <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Xestionar as fotos e vdeos aos que ten acceso <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Esta aplicacin"</string>
 </resources>
diff --git a/photopicker/res/values-gl/feature_search_strings.xml b/photopicker/res/values-gl/feature_search_strings.xml
index ecbc5bd17..1db5b507e 100644
--- a/photopicker/res/values-gl/feature_search_strings.xml
+++ b/photopicker/res/values-gl/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Fai buscas"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fai buscas nas tas fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Fai buscas nos teus vdeos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Borrar o texto de busca"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Non se atopou ningn resultado"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Proba a buscar palabras semellantes"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suxestins"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"A busca est desactivada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Proba a buscar palabras similares.\n\nNos resultados da busca s aparecern os elementos dos que se fixesen copias de seguranza."</string>
 </resources>
diff --git a/photopicker/res/values-gu/feature_category_grid_strings.xml b/photopicker/res/values-gu/feature_category_grid_strings.xml
new file mode 100644
index 000000000..dd835947d
--- /dev/null
+++ b/photopicker/res/values-gu/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"       "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         "</string>
+</resources>
diff --git a/photopicker/res/values-gu/feature_preview_strings.xml b/photopicker/res/values-gu/feature_preview_strings.xml
index ca567c000..8b168efad 100644
--- a/photopicker/res/values-gu/feature_preview_strings.xml
+++ b/photopicker/res/values-gu/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-gu/feature_privacy_explainer_strings.xml b/photopicker/res/values-gu/feature_privacy_explainer_strings.xml
index f5f78f0ff..4b0c0dcd3 100644
--- a/photopicker/res/values-gu/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-gu/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>            "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>          "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-gu/feature_search_strings.xml b/photopicker/res/values-gu/feature_search_strings.xml
index a6f7575c7..063f061c7 100644
--- a/photopicker/res/values-gu/feature_search_strings.xml
+++ b/photopicker/res/values-gu/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"    ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"     .\n\n             ."</string>
 </resources>
diff --git a/photopicker/res/values-hi/feature_category_grid_strings.xml b/photopicker/res/values-hi/feature_category_grid_strings.xml
new file mode 100644
index 000000000..cd0125c41
--- /dev/null
+++ b/photopicker/res/values-hi/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"            "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"        -       "</string>
+</resources>
diff --git a/photopicker/res/values-hi/feature_preview_strings.xml b/photopicker/res/values-hi/feature_preview_strings.xml
index d19b8d273..a41c28994 100644
--- a/photopicker/res/values-hi/feature_preview_strings.xml
+++ b/photopicker/res/values-hi/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>   <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-hi/feature_privacy_explainer_strings.xml b/photopicker/res/values-hi/feature_privacy_explainer_strings.xml
index 163028100..3166e9d7b 100644
--- a/photopicker/res/values-hi/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-hi/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>,        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"        <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"         <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"  "</string>
 </resources>
diff --git a/photopicker/res/values-hi/feature_search_strings.xml b/photopicker/res/values-hi/feature_search_strings.xml
index 70628fe72..c2d998746 100644
--- a/photopicker/res/values-hi/feature_search_strings.xml
+++ b/photopicker/res/values-hi/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"       "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"-  "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"       ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"-  .\n\n              ."</string>
 </resources>
diff --git a/photopicker/res/values-hr/feature_category_grid_strings.xml b/photopicker/res/values-hr/feature_category_grid_strings.xml
new file mode 100644
index 000000000..0205ffb28
--- /dev/null
+++ b/photopicker/res/values-hr/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Zbirke"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Jo nema osoba i kunih ljubimaca"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Ovdje se prikazuju fotografije i videozapisi grupirani po slinim licima"</string>
+</resources>
diff --git a/photopicker/res/values-hr/feature_preview_strings.xml b/photopicker/res/values-hr/feature_preview_strings.xml
index c52c37e39..974bdd5c1 100644
--- a/photopicker/res/values-hr/feature_preview_strings.xml
+++ b/photopicker/res/values-hr/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pauziraj"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Iskljui zvuk"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ukljui zvuk"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Stranica <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> od <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-hr/feature_privacy_explainer_strings.xml b/photopicker/res/values-hr/feature_privacy_explainer_strings.xml
index 25256f2d2..5a6b5f0be 100644
--- a/photopicker/res/values-hr/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-hr/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> imat e pristup samo fotografijama koje odaberete"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Odaberite fotografije i videozapise za koje elite da aplikacija <xliff:g id="APP_NAME">%1$s</xliff:g> ima pristup"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Upravljajte fotografijama i videozapisima kojima <xliff:g id="APP_NAME">%1$s</xliff:g> ima pristup"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ova aplikacija"</string>
 </resources>
diff --git a/photopicker/res/values-hr/feature_search_strings.xml b/photopicker/res/values-hr/feature_search_strings.xml
index 0b2b07e73..a66e53b64 100644
--- a/photopicker/res/values-hr/feature_search_strings.xml
+++ b/photopicker/res/values-hr/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pretraivanje"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pretraite fotografije"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pretraivanje videozapisa"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Brisanje teksta pretraivanja"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nema rezultata"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Pokuajte potraiti sline rijei"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Prijedlozi"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pretraivanje je onemogueno."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Pokuajte pretraiti sline rijei.\n\nU rezultatima pretraivanja prikazivat e se samo sigurnosno kopirane stavke."</string>
 </resources>
diff --git a/photopicker/res/values-hu/feature_category_grid_strings.xml b/photopicker/res/values-hu/feature_category_grid_strings.xml
new file mode 100644
index 000000000..aff14f534
--- /dev/null
+++ b/photopicker/res/values-hu/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Gyjtemnyek"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Mg nincsenek szemlyek s hzillatok"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Itt jelennek meg a hasonl arcok alapjn csoportostott fotk s videk"</string>
+</resources>
diff --git a/photopicker/res/values-hu/feature_preview_strings.xml b/photopicker/res/values-hu/feature_preview_strings.xml
index cc1ceca9e..ad9770f1e 100644
--- a/photopicker/res/values-hu/feature_preview_strings.xml
+++ b/photopicker/res/values-hu/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Szneteltets"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Hanger nmtsa"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Hanger nmtsnak feloldsa"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>/<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>. oldal"</string>
 </resources>
diff --git a/photopicker/res/values-hu/feature_privacy_explainer_strings.xml b/photopicker/res/values-hu/feature_privacy_explainer_strings.xml
index 10c1831d6..3e4ae9ed0 100644
--- a/photopicker/res/values-hu/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-hu/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"A(z) <xliff:g id="APP_NAME">%1$s</xliff:g> csak az n ltal kivlasztott fotkhoz frhet majd hozz"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Vlassza ki azokat a fotkat s videkat, amelyekhez engedlyezi a(z) <xliff:g id="APP_NAME">%1$s</xliff:g> szmra a hozzfrst"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"A(z) <xliff:g id="APP_NAME">%1$s</xliff:g> ltal hozzfrhet fotk s videk kezelse"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ez az alkalmazs"</string>
 </resources>
diff --git a/photopicker/res/values-hu/feature_search_strings.xml b/photopicker/res/values-hu/feature_search_strings.xml
index 216f5352a..f11b97b36 100644
--- a/photopicker/res/values-hu/feature_search_strings.xml
+++ b/photopicker/res/values-hu/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Keress"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fotk keresse"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Keress a sajt videk kztt"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Keressi szveg trlse"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nincs tallat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prblkozzon hasonl szavak keressvel"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Javaslatok"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Keress letiltva."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prblkozzon hasonl szavak keressvel.\n\nCsak azok az elemek jelennek meg a keressi tallatok kztt, amelyekrl kszlt biztonsgi msolat."</string>
 </resources>
diff --git a/photopicker/res/values-hy/feature_category_grid_strings.xml b/photopicker/res/values-hy/feature_category_grid_strings.xml
new file mode 100644
index 000000000..dfd35628f
--- /dev/null
+++ b/photopicker/res/values-hy/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"      ,  "</string>
+</resources>
diff --git a/photopicker/res/values-hy/feature_preview_strings.xml b/photopicker/res/values-hy/feature_preview_strings.xml
index d408f4248..fa1b6a2a9 100644
--- a/photopicker/res/values-hy/feature_preview_strings.xml
+++ b/photopicker/res/values-hy/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-hy/feature_privacy_explainer_strings.xml b/photopicker/res/values-hy/feature_privacy_explainer_strings.xml
index cfd0fcd50..c72468034 100644
--- a/photopicker/res/values-hy/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-hy/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   ,      <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"   ,    <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-hy/feature_search_strings.xml b/photopicker/res/values-hy/feature_search_strings.xml
index 3b11e9055..0384f3834 100644
--- a/photopicker/res/values-hy/feature_search_strings.xml
+++ b/photopicker/res/values-hy/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   \n\n      "</string>
 </resources>
diff --git a/photopicker/res/values-in/feature_category_grid_strings.xml b/photopicker/res/values-in/feature_category_grid_strings.xml
new file mode 100644
index 000000000..1b66af533
--- /dev/null
+++ b/photopicker/res/values-in/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Koleksi"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Belum ada orang &amp; hewan peliharaan"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Foto dan video, yang dikelompokkan menurut wajah yang mirip, akan muncul di sini"</string>
+</resources>
diff --git a/photopicker/res/values-in/feature_preview_strings.xml b/photopicker/res/values-in/feature_preview_strings.xml
index 383abe22d..04e326fd6 100644
--- a/photopicker/res/values-in/feature_preview_strings.xml
+++ b/photopicker/res/values-in/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Jeda"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Bisukan Volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Bunyikan Volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Halaman <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> dari <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-in/feature_privacy_explainer_strings.xml b/photopicker/res/values-in/feature_privacy_explainer_strings.xml
index 890312ac1..b03b24529 100644
--- a/photopicker/res/values-in/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-in/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> hanya akan memiliki akses ke foto yang Anda pilih"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Pilih foto dan video yang Anda izinkan untuk diakses <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Mengelola foto dan video yang dapat diakses <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Aplikasi ini"</string>
 </resources>
diff --git a/photopicker/res/values-in/feature_search_strings.xml b/photopicker/res/values-in/feature_search_strings.xml
index 3d61b0a00..e3dfb10f0 100644
--- a/photopicker/res/values-in/feature_search_strings.xml
+++ b/photopicker/res/values-in/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Telusuri"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Telusuri foto Anda"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Telusuri video Anda"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Hapus teks penelusuran"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Tidak ditemukan hasil"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Coba telusuri kata yang serupa"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Saran"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Penelusuran nonaktif."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Coba telusuri kata yang serupa.\n\nHanya item yang dicadangkan yang akan muncul di hasil penelusuran Anda."</string>
 </resources>
diff --git a/photopicker/res/values-is/feature_category_grid_strings.xml b/photopicker/res/values-is/feature_category_grid_strings.xml
new file mode 100644
index 000000000..1ae4d4102
--- /dev/null
+++ b/photopicker/res/values-is/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Sfn"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ekkert flk og gludr enn"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Myndir og vde, flokku eftir svipuum andlitum, birtast hr"</string>
+</resources>
diff --git a/photopicker/res/values-is/feature_preview_strings.xml b/photopicker/res/values-is/feature_preview_strings.xml
index 9de2d72b0..197ed7d2d 100644
--- a/photopicker/res/values-is/feature_preview_strings.xml
+++ b/photopicker/res/values-is/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Gera hl"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Slkkva  hlji"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Kveikja  hlji"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Sa <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> af <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-is/feature_privacy_explainer_strings.xml b/photopicker/res/values-is/feature_privacy_explainer_strings.xml
index b2a04fc43..227f15d6c 100644
--- a/photopicker/res/values-is/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-is/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> fr aeins agang a myndunum sem  velur"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Veldu myndir og vde sem  vilt leyfa <xliff:g id="APP_NAME">%1$s</xliff:g> a hafa agang a"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Stjrnau myndum og vdeum sem <xliff:g id="APP_NAME">%1$s</xliff:g> hefur agang a"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"etta forrit"</string>
 </resources>
diff --git a/photopicker/res/values-is/feature_search_strings.xml b/photopicker/res/values-is/feature_search_strings.xml
index a23c423ea..95b523cac 100644
--- a/photopicker/res/values-is/feature_search_strings.xml
+++ b/photopicker/res/values-is/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Leita"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Leitau  myndasafninu nu"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Leitau  vdeunum num"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Hreinsa leitartexta"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Engar niurstur fundust"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prfau a leita a svipuum orum"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Tillgur"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Slkkt  leit."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prfau a leita a svipuum orum.\n\nEingngu ryggisafritu atrii munu birtast  leitarniurstunum."</string>
 </resources>
diff --git a/photopicker/res/values-it/feature_category_grid_strings.xml b/photopicker/res/values-it/feature_category_grid_strings.xml
new file mode 100644
index 000000000..06e0ce0ea
--- /dev/null
+++ b/photopicker/res/values-it/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Raccolte"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ancora nessuna persona e nessun animale domestico"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Le foto e i video raggruppati per volti simili verranno visualizzati qui"</string>
+</resources>
diff --git a/photopicker/res/values-it/feature_preview_strings.xml b/photopicker/res/values-it/feature_preview_strings.xml
index 3c0d28ac2..978747eec 100644
--- a/photopicker/res/values-it/feature_preview_strings.xml
+++ b/photopicker/res/values-it/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Metti in pausa"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Disattiva volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Riattiva audio del volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pagina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> di <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-it/feature_privacy_explainer_strings.xml b/photopicker/res/values-it/feature_privacy_explainer_strings.xml
index d56287719..6d8e95875 100644
--- a/photopicker/res/values-it/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-it/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> acceder solo alle foto che selezioni"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Seleziona foto e video a cui l\'app <xliff:g id="APP_NAME">%1$s</xliff:g> pu accedere"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Gestisci le foto e i video a cui <xliff:g id="APP_NAME">%1$s</xliff:g> ha accesso"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Questa app"</string>
 </resources>
diff --git a/photopicker/res/values-it/feature_search_strings.xml b/photopicker/res/values-it/feature_search_strings.xml
index 8e435b211..b6d999b6e 100644
--- a/photopicker/res/values-it/feature_search_strings.xml
+++ b/photopicker/res/values-it/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Cerca"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Cerca nelle tue foto"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Cerca nei tuoi video"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Cancella testo della ricerca"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nessun risultato trovato"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prova a cercare parole simili"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggerimenti"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Ricerca disattivata."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prova a cercare parole simili.\n\nNei risultati di ricerca verranno visualizzati solo gli elementi di cui  stato eseguito il backup."</string>
 </resources>
diff --git a/photopicker/res/values-iw/feature_category_grid_strings.xml b/photopicker/res/values-iw/feature_category_grid_strings.xml
new file mode 100644
index 000000000..fc487779b
--- /dev/null
+++ b/photopicker/res/values-iw/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"    "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"       "</string>
+</resources>
diff --git a/photopicker/res/values-iw/feature_preview_strings.xml b/photopicker/res/values-iw/feature_preview_strings.xml
index bdd74ebf4..bd43d5a70 100644
--- a/photopicker/res/values-iw/feature_preview_strings.xml
+++ b/photopicker/res/values-iw/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"   "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"    "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-iw/feature_privacy_explainer_strings.xml b/photopicker/res/values-iw/feature_privacy_explainer_strings.xml
index 61ad525a4..5ee65a1bf 100644
--- a/photopicker/res/values-iw/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-iw/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>     "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"     -<xliff:g id="APP_NAME">%1$s</xliff:g>  "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"    <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-iw/feature_search_strings.xml b/photopicker/res/values-iw/feature_search_strings.xml
index 45c65a9d2..607b6fd97 100644
--- a/photopicker/res/values-iw/feature_search_strings.xml
+++ b/photopicker/res/values-iw/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n     ."</string>
 </resources>
diff --git a/photopicker/res/values-ja/feature_category_grid_strings.xml b/photopicker/res/values-ja/feature_category_grid_strings.xml
new file mode 100644
index 000000000..6343d4ef6
--- /dev/null
+++ b/photopicker/res/values-ja/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">""</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">""</string>
+</resources>
diff --git a/photopicker/res/values-ja/feature_preview_strings.xml b/photopicker/res/values-ja/feature_preview_strings.xml
index bf0b1f5dd..4be2685bc 100644
--- a/photopicker/res/values-ja/feature_preview_strings.xml
+++ b/photopicker/res/values-ja/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-ja/feature_privacy_explainer_strings.xml b/photopicker/res/values-ja/feature_privacy_explainer_strings.xml
index c15fe4849..0102e6371 100644
--- a/photopicker/res/values-ja/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ja/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-ja/feature_search_strings.xml b/photopicker/res/values-ja/feature_search_strings.xml
index 6ff343663..bc075fc8d 100644
--- a/photopicker/res/values-ja/feature_search_strings.xml
+++ b/photopicker/res/values-ja/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"\n\n"</string>
 </resources>
diff --git a/photopicker/res/values-ka/feature_category_grid_strings.xml b/photopicker/res/values-ka/feature_category_grid_strings.xml
new file mode 100644
index 000000000..ff55d1ef4
--- /dev/null
+++ b/photopicker/res/values-ka/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"        "</string>
+</resources>
diff --git a/photopicker/res/values-ka/feature_preview_strings.xml b/photopicker/res/values-ka/feature_preview_strings.xml
index cf6479403..f27ae5397 100644
--- a/photopicker/res/values-ka/feature_preview_strings.xml
+++ b/photopicker/res/values-ka/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> / <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ka/feature_privacy_explainer_strings.xml b/photopicker/res/values-ka/feature_privacy_explainer_strings.xml
index aa5aa6428..79f47af31 100644
--- a/photopicker/res/values-ka/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ka/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>-       "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   ,  <xliff:g id="APP_NAME">%1$s</xliff:g>-   "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>-      "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ka/feature_search_strings.xml b/photopicker/res/values-ka/feature_search_strings.xml
index f84d2f8b2..c712998f5 100644
--- a/photopicker/res/values-ka/feature_search_strings.xml
+++ b/photopicker/res/values-ka/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   .\n\n      ,    ."</string>
 </resources>
diff --git a/photopicker/res/values-kk/feature_category_grid_strings.xml b/photopicker/res/values-kk/feature_category_grid_strings.xml
new file mode 100644
index 000000000..4172b7a23
--- /dev/null
+++ b/photopicker/res/values-kk/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         ."</string>
+</resources>
diff --git a/photopicker/res/values-kk/feature_preview_strings.xml b/photopicker/res/values-kk/feature_preview_strings.xml
index d6694ecd3..baa1d13f1 100644
--- a/photopicker/res/values-kk/feature_preview_strings.xml
+++ b/photopicker/res/values-kk/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>-"</string>
 </resources>
diff --git a/photopicker/res/values-kk/feature_privacy_explainer_strings.xml b/photopicker/res/values-kk/feature_privacy_explainer_strings.xml
index 77e91d579..aca86e6e1 100644
--- a/photopicker/res/values-kk/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-kk/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>       ."</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>        ."</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>        ."</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-kk/feature_search_strings.xml b/photopicker/res/values-kk/feature_search_strings.xml
index bb77223e9..a8c14b978 100644
--- a/photopicker/res/values-kk/feature_search_strings.xml
+++ b/photopicker/res/values-kk/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   ."</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-km/feature_category_grid_strings.xml b/photopicker/res/values-km/feature_category_grid_strings.xml
new file mode 100644
index 000000000..bcafdd23c
--- /dev/null
+++ b/photopicker/res/values-km/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">" "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">" "</string>
+</resources>
diff --git a/photopicker/res/values-km/feature_preview_strings.xml b/photopicker/res/values-km/feature_preview_strings.xml
index 97e11a6fc..8daaaed73 100644
--- a/photopicker/res/values-km/feature_preview_strings.xml
+++ b/photopicker/res/values-km/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-km/feature_privacy_explainer_strings.xml b/photopicker/res/values-km/feature_privacy_explainer_strings.xml
index 5ca1c2007..d3e502c1a 100644
--- a/photopicker/res/values-km/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-km/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"  <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"  <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-km/feature_search_strings.xml b/photopicker/res/values-km/feature_search_strings.xml
index 977d13f42..4aeaf57cf 100644
--- a/photopicker/res/values-km/feature_search_strings.xml
+++ b/photopicker/res/values-km/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"\n\n"</string>
 </resources>
diff --git a/photopicker/res/values-kn/feature_category_grid_strings.xml b/photopicker/res/values-kn/feature_category_grid_strings.xml
new file mode 100644
index 000000000..0e62e45bf
--- /dev/null
+++ b/photopicker/res/values-kn/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"    "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"          "</string>
+</resources>
diff --git a/photopicker/res/values-kn/feature_preview_strings.xml b/photopicker/res/values-kn/feature_preview_strings.xml
index 78701c441..786cbee64 100644
--- a/photopicker/res/values-kn/feature_preview_strings.xml
+++ b/photopicker/res/values-kn/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"   "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-kn/feature_privacy_explainer_strings.xml b/photopicker/res/values-kn/feature_privacy_explainer_strings.xml
index 2c8c5d28f..311b2b6b6 100644
--- a/photopicker/res/values-kn/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-kn/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"     <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>      "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-kn/feature_search_strings.xml b/photopicker/res/values-kn/feature_search_strings.xml
index b9e4a7342..b4260c172 100644
--- a/photopicker/res/values-kn/feature_search_strings.xml
+++ b/photopicker/res/values-kn/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-ko/feature_category_grid_strings.xml b/photopicker/res/values-ko/feature_category_grid_strings.xml
new file mode 100644
index 000000000..2e891ade0
--- /dev/null
+++ b/photopicker/res/values-ko/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"    "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"       ."</string>
+</resources>
diff --git a/photopicker/res/values-ko/feature_preview_strings.xml b/photopicker/res/values-ko/feature_preview_strings.xml
index 28fe75cee..3cf76fbf4 100644
--- a/photopicker/res/values-ko/feature_preview_strings.xml
+++ b/photopicker/res/values-ko/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ko/feature_privacy_explainer_strings.xml b/photopicker/res/values-ko/feature_privacy_explainer_strings.xml
index 76113be8f..913ea10c6 100644
--- a/photopicker/res/values-ko/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ko/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>    ."</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>     "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ko/feature_search_strings.xml b/photopicker/res/values-ko/feature_search_strings.xml
index ba8e91a61..369a6a650 100644
--- a/photopicker/res/values-ko/feature_search_strings.xml
+++ b/photopicker/res/values-ko/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">" "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   ."</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   .\n\n    ."</string>
 </resources>
diff --git a/photopicker/res/values-ky/feature_category_grid_strings.xml b/photopicker/res/values-ky/feature_category_grid_strings.xml
new file mode 100644
index 000000000..dc7f454dc
--- /dev/null
+++ b/photopicker/res/values-ky/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         "</string>
+</resources>
diff --git a/photopicker/res/values-ky/feature_preview_strings.xml b/photopicker/res/values-ky/feature_preview_strings.xml
index 9edcbb843..5482c5b6a 100644
--- a/photopicker/res/values-ky/feature_preview_strings.xml
+++ b/photopicker/res/values-ky/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>   <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>-"</string>
 </resources>
diff --git a/photopicker/res/values-ky/feature_privacy_explainer_strings.xml b/photopicker/res/values-ky/feature_privacy_explainer_strings.xml
index 3c18ce1e1..e17c01e03 100644
--- a/photopicker/res/values-ky/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ky/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>     "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>      "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ky/feature_search_strings.xml b/photopicker/res/values-ky/feature_search_strings.xml
index 18a01a912..5540daff7 100644
--- a/photopicker/res/values-ky/feature_search_strings.xml
+++ b/photopicker/res/values-ky/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-lo/feature_category_grid_strings.xml b/photopicker/res/values-lo/feature_category_grid_strings.xml
new file mode 100644
index 000000000..7794c330f
--- /dev/null
+++ b/photopicker/res/values-lo/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"  "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"  "</string>
+</resources>
diff --git a/photopicker/res/values-lo/feature_preview_strings.xml b/photopicker/res/values-lo/feature_preview_strings.xml
index 8fc826f63..ddae64e91 100644
--- a/photopicker/res/values-lo/feature_preview_strings.xml
+++ b/photopicker/res/values-lo/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-lo/feature_privacy_explainer_strings.xml b/photopicker/res/values-lo/feature_privacy_explainer_strings.xml
index 79a2caee3..1ff41416c 100644
--- a/photopicker/res/values-lo/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-lo/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"   <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-lo/feature_search_strings.xml b/photopicker/res/values-lo/feature_search_strings.xml
index ab12d63aa..e093b72f7 100644
--- a/photopicker/res/values-lo/feature_search_strings.xml
+++ b/photopicker/res/values-lo/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">".\n\n."</string>
 </resources>
diff --git a/photopicker/res/values-lt/feature_category_grid_strings.xml b/photopicker/res/values-lt/feature_category_grid_strings.xml
new file mode 100644
index 000000000..61bf620f0
--- /dev/null
+++ b/photopicker/res/values-lt/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Rinkiniai"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Dar nra moni ir augintini"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"ia bus rodomos pagal panaius veidus sugrupuotos nuotraukos ir vaizdo raai"</string>
+</resources>
diff --git a/photopicker/res/values-lt/feature_preview_strings.xml b/photopicker/res/values-lt/feature_preview_strings.xml
index f596811c2..3de74df31 100644
--- a/photopicker/res/values-lt/feature_preview_strings.xml
+++ b/photopicker/res/values-lt/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pristabdyti"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Nutildyti garsum"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"jungti garsum"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g> psl. i <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-lt/feature_privacy_explainer_strings.xml b/photopicker/res/values-lt/feature_privacy_explainer_strings.xml
index 94868fab6..88d01df35 100644
--- a/photopicker/res/values-lt/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-lt/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> gali pasiekti tik js pasirinktas nuotraukas"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Pasirinkite nuotraukas ir vaizdo raus, kuriuos gals pasiekti <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Tvarkyti, kurias nuotraukas ir vaizdo raus programa <xliff:g id="APP_NAME">%1$s</xliff:g> gali pasiekti"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"i programa"</string>
 </resources>
diff --git a/photopicker/res/values-lt/feature_search_strings.xml b/photopicker/res/values-lt/feature_search_strings.xml
index 2333566c5..3b46c609d 100644
--- a/photopicker/res/values-lt/feature_search_strings.xml
+++ b/photopicker/res/values-lt/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Paieka"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Iekokite nuotraukose"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Iekokite savo vaizdo ra"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Ivalyti paiekos tekst"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nerasta joki rezultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Pabandykite iekoti panai odi"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Pasilymai"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Paieka ijungta."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Pabandykite iekoti panai odi.\n\nPaiekos rezultatuose bus rodomi tik tie elementai, kuri atsargins kopijos yra sukurtos."</string>
 </resources>
diff --git a/photopicker/res/values-lv/feature_category_grid_strings.xml b/photopicker/res/values-lv/feature_category_grid_strings.xml
new file mode 100644
index 000000000..7dfe600e8
--- /dev/null
+++ b/photopicker/res/values-lv/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kolekcijas"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Vl nav nevienas personas un mjdzvnieka"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"eit bs redzami fotoattli un videoklipi, kas sagrupti pc ldzgm sejm."</string>
+</resources>
diff --git a/photopicker/res/values-lv/feature_preview_strings.xml b/photopicker/res/values-lv/feature_preview_strings.xml
index 432d8670f..6919d804d 100644
--- a/photopicker/res/values-lv/feature_preview_strings.xml
+++ b/photopicker/res/values-lv/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Prtraukt"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Izslgt skau"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ieslgt skau"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>.lapa no<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-lv/feature_privacy_explainer_strings.xml b/photopicker/res/values-lv/feature_privacy_explainer_strings.xml
index 1f7a848e1..f5bc9ad3e 100644
--- a/photopicker/res/values-lv/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-lv/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Lietotne <xliff:g id="APP_NAME">%1$s</xliff:g> vars piekt tikai jsu atlastajiem fotoattliem."</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Atlasiet fotoattlus un videoklipus, kam <xliff:g id="APP_NAME">%1$s</xliff:g> drkst piekt."</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Prvaldiet, kuriem fotoattliem un videoklipiem lietotne <xliff:g id="APP_NAME">%1$s</xliff:g> var piekt"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" lietotne"</string>
 </resources>
diff --git a/photopicker/res/values-lv/feature_search_strings.xml b/photopicker/res/values-lv/feature_search_strings.xml
index c2fc5b1ce..2a48012fc 100644
--- a/photopicker/res/values-lv/feature_search_strings.xml
+++ b/photopicker/res/values-lv/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Meklt"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Meklt savos fotoattlos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Meklt savos video"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Notrt meklanas vaicjumu"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Netika atrasti rezultti"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Miniet meklt ldzgus vrdus"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Ieteikumi"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Meklana atspjota."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Miniet meklt ldzgus vrdus.\n\nMeklanas rezulttos tiks rdti tikai dublti vienumi."</string>
 </resources>
diff --git a/photopicker/res/values-mk/feature_category_grid_strings.xml b/photopicker/res/values-mk/feature_category_grid_strings.xml
new file mode 100644
index 000000000..ff2a09532
--- /dev/null
+++ b/photopicker/res/values-mk/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"          "</string>
+</resources>
diff --git a/photopicker/res/values-mk/feature_preview_strings.xml b/photopicker/res/values-mk/feature_preview_strings.xml
index fadd2737b..8b74b38a1 100644
--- a/photopicker/res/values-mk/feature_preview_strings.xml
+++ b/photopicker/res/values-mk/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-mk/feature_privacy_explainer_strings.xml b/photopicker/res/values-mk/feature_privacy_explainer_strings.xml
index 2535b901e..d13161012 100644
--- a/photopicker/res/values-mk/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-mk/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>          "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"         <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"         <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-mk/feature_search_strings.xml b/photopicker/res/values-mk/feature_search_strings.xml
index 07ef55612..949ed19d3 100644
--- a/photopicker/res/values-mk/feature_search_strings.xml
+++ b/photopicker/res/values-mk/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"    "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"     "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"     .\n\n             ."</string>
 </resources>
diff --git a/photopicker/res/values-ml/feature_category_grid_strings.xml b/photopicker/res/values-ml/feature_category_grid_strings.xml
new file mode 100644
index 000000000..56bcf3729
--- /dev/null
+++ b/photopicker/res/values-ml/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"   "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"        "</string>
+</resources>
diff --git a/photopicker/res/values-ml/feature_preview_strings.xml b/photopicker/res/values-ml/feature_preview_strings.xml
index 30bc8f024..80eb30165 100644
--- a/photopicker/res/values-ml/feature_preview_strings.xml
+++ b/photopicker/res/values-ml/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>- <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>- "</string>
 </resources>
diff --git a/photopicker/res/values-ml/feature_privacy_explainer_strings.xml b/photopicker/res/values-ml/feature_privacy_explainer_strings.xml
index 04d4917d9..192941f39 100644
--- a/photopicker/res/values-ml/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ml/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"    <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ml/feature_search_strings.xml b/photopicker/res/values-ml/feature_search_strings.xml
index 8720a872c..db3e6c41e 100644
--- a/photopicker/res/values-ml/feature_search_strings.xml
+++ b/photopicker/res/values-ml/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">" "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"  "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"  .\n\n      ."</string>
 </resources>
diff --git a/photopicker/res/values-mn/feature_category_grid_strings.xml b/photopicker/res/values-mn/feature_category_grid_strings.xml
new file mode 100644
index 000000000..99733cd66
--- /dev/null
+++ b/photopicker/res/values-mn/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"   ,   "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"   ,    "</string>
+</resources>
diff --git a/photopicker/res/values-mn/feature_preview_strings.xml b/photopicker/res/values-mn/feature_preview_strings.xml
index 664aa7663..e940503c6 100644
--- a/photopicker/res/values-mn/feature_preview_strings.xml
+++ b/photopicker/res/values-mn/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"   "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"   "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>- <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>- "</string>
 </resources>
diff --git a/photopicker/res/values-mn/feature_privacy_explainer_strings.xml b/photopicker/res/values-mn/feature_privacy_explainer_strings.xml
index 773cc4354..7af32c8d7 100644
--- a/photopicker/res/values-mn/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-mn/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>-       "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>-   ,  "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-mn/feature_search_strings.xml b/photopicker/res/values-mn/feature_search_strings.xml
index cc13ebcc7..75005e67a 100644
--- a/photopicker/res/values-mn/feature_search_strings.xml
+++ b/photopicker/res/values-mn/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">" "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-mr/feature_category_grid_strings.xml b/photopicker/res/values-mr/feature_category_grid_strings.xml
new file mode 100644
index 000000000..b720f9982
--- /dev/null
+++ b/photopicker/res/values-mr/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         "</string>
+</resources>
diff --git a/photopicker/res/values-mr/feature_preview_strings.xml b/photopicker/res/values-mr/feature_preview_strings.xml
index 4109c4a40..b961dbd5d 100644
--- a/photopicker/res/values-mr/feature_preview_strings.xml
+++ b/photopicker/res/values-mr/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-mr/feature_privacy_explainer_strings.xml b/photopicker/res/values-mr/feature_privacy_explainer_strings.xml
index 4bf35929b..1616a7686 100644
--- a/photopicker/res/values-mr/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-mr/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>          "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-mr/feature_search_strings.xml b/photopicker/res/values-mr/feature_search_strings.xml
index e0969983f..86443feef 100644
--- a/photopicker/res/values-mr/feature_search_strings.xml
+++ b/photopicker/res/values-mr/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-ms/feature_category_grid_strings.xml b/photopicker/res/values-ms/feature_category_grid_strings.xml
new file mode 100644
index 000000000..da16254f5
--- /dev/null
+++ b/photopicker/res/values-ms/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Koleksi"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Tiada orang &amp; haiwan kesayangan lagi"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Foto dan video, dikumpulkan mengikut wajah yang serupa, akan dipaparkan di sini"</string>
+</resources>
diff --git a/photopicker/res/values-ms/feature_preview_strings.xml b/photopicker/res/values-ms/feature_preview_strings.xml
index 4c6fb80de..04ca0350a 100644
--- a/photopicker/res/values-ms/feature_preview_strings.xml
+++ b/photopicker/res/values-ms/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Jeda"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Redamkan Kelantangan"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Nyahredamkan Kelantangan"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Halaman <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> daripada <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ms/feature_privacy_explainer_strings.xml b/photopicker/res/values-ms/feature_privacy_explainer_strings.xml
index 2357caca6..f7b32df1b 100644
--- a/photopicker/res/values-ms/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ms/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> hanya akan mengakses foto yang anda pilih"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Pilih foto dan video yang boleh diakses oleh <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Urus foto dan video yang boleh diakses oleh <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Apl ini"</string>
 </resources>
diff --git a/photopicker/res/values-ms/feature_search_strings.xml b/photopicker/res/values-ms/feature_search_strings.xml
index 9f3142b88..c3aecddf0 100644
--- a/photopicker/res/values-ms/feature_search_strings.xml
+++ b/photopicker/res/values-ms/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Carian"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Cari foto anda"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Cari video anda"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Kosongkan teks carian"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Tiada hasil carian ditemukan"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Cuba cari perkataan yang serupa"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Cadangan"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Carian dilumpuhkan."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Cuba cari perkataan yang serupa.\n\nHanya item yang disandarkan akan dipaparkan dalam hasil carian anda."</string>
 </resources>
diff --git a/photopicker/res/values-my/core_strings.xml b/photopicker/res/values-my/core_strings.xml
index da61ae561..74597a6ae 100644
--- a/photopicker/res/values-my/core_strings.xml
+++ b/photopicker/res/values-my/core_strings.xml
@@ -35,7 +35,7 @@
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">" "</string>
-    <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"  "</string>
+    <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"  "</string>
     <string name="photopicker_camera_empty_state_body" msgid="858373882699294081">"     "</string>
     <string name="photopicker_favorites_empty_state_title" msgid="3855048169943856242">" "</string>
     <string name="photopicker_favorites_empty_state_body" msgid="4206436541083780797">" ()      "</string>
diff --git a/photopicker/res/values-my/feature_category_grid_strings.xml b/photopicker/res/values-my/feature_category_grid_strings.xml
new file mode 100644
index 000000000..fc37f2d7b
--- /dev/null
+++ b/photopicker/res/values-my/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"  "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"     "</string>
+</resources>
diff --git a/photopicker/res/values-my/feature_preview_strings.xml b/photopicker/res/values-my/feature_preview_strings.xml
index b9d3b81da..107ff478c 100644
--- a/photopicker/res/values-my/feature_preview_strings.xml
+++ b/photopicker/res/values-my/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-my/feature_privacy_explainer_strings.xml b/photopicker/res/values-my/feature_privacy_explainer_strings.xml
index fc7ef7e51..2b0983250 100644
--- a/photopicker/res/values-my/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-my/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>    "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>     "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>     "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-my/feature_search_strings.xml b/photopicker/res/values-my/feature_search_strings.xml
index 2c2057591..c91973281 100644
--- a/photopicker/res/values-my/feature_search_strings.xml
+++ b/photopicker/res/values-my/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">" "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">" "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">" \n\n   "</string>
 </resources>
diff --git a/photopicker/res/values-nb/feature_category_grid_strings.xml b/photopicker/res/values-nb/feature_category_grid_strings.xml
new file mode 100644
index 000000000..3864780bd
--- /dev/null
+++ b/photopicker/res/values-nb/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Samlinger"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ingen personer eller kjledyr enn"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Bilder og videoer, gruppert etter ansikter som ligner hverandre, vises her"</string>
+</resources>
diff --git a/photopicker/res/values-nb/feature_preview_strings.xml b/photopicker/res/values-nb/feature_preview_strings.xml
index 34991f69b..988de59ae 100644
--- a/photopicker/res/values-nb/feature_preview_strings.xml
+++ b/photopicker/res/values-nb/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Sett p pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Kutt lyden"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Sl p lyden"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Side <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> av <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-nb/feature_privacy_explainer_strings.xml b/photopicker/res/values-nb/feature_privacy_explainer_strings.xml
index 904396ce1..ba1c0e909 100644
--- a/photopicker/res/values-nb/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-nb/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> har bare tilgang til bildene du velger"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Velg bilder og videoer du vil at <xliff:g id="APP_NAME">%1$s</xliff:g> skal kunne bruke"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Administrer bilder og videoer <xliff:g id="APP_NAME">%1$s</xliff:g> har tilgang til"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Denne appen"</string>
 </resources>
diff --git a/photopicker/res/values-nb/feature_search_strings.xml b/photopicker/res/values-nb/feature_search_strings.xml
index ff80a3ea1..bf0e75633 100644
--- a/photopicker/res/values-nb/feature_search_strings.xml
+++ b/photopicker/res/values-nb/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sk"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sk i bildene dine"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sk i videoene dine"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Fjern sketeksten"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Fant ingen resultater"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prv  ske etter lignende ord"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Forslag"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Skefunksjonen er sltt av."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Prv  ske etter lignende ord.\n\nBare elementer som er sikkerhetskopiert, vises i skeresultatene."</string>
 </resources>
diff --git a/photopicker/res/values-ne/feature_category_grid_strings.xml b/photopicker/res/values-ne/feature_category_grid_strings.xml
new file mode 100644
index 000000000..c201c872f
--- /dev/null
+++ b/photopicker/res/values-ne/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"         "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         "</string>
+</resources>
diff --git a/photopicker/res/values-ne/feature_preview_strings.xml b/photopicker/res/values-ne/feature_preview_strings.xml
index b5a0d7ca6..1691d12cf 100644
--- a/photopicker/res/values-ne/feature_preview_strings.xml
+++ b/photopicker/res/values-ne/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  "</string>
 </resources>
diff --git a/photopicker/res/values-ne/feature_privacy_explainer_strings.xml b/photopicker/res/values-ne/feature_privacy_explainer_strings.xml
index e5de14c55..8cb609307 100644
--- a/photopicker/res/values-ne/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ne/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ne/feature_search_strings.xml b/photopicker/res/values-ne/feature_search_strings.xml
index dd8c0b030..a308c94e3 100644
--- a/photopicker/res/values-ne/feature_search_strings.xml
+++ b/photopicker/res/values-ne/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"     "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   \n\n        "</string>
 </resources>
diff --git a/photopicker/res/values-nl/feature_category_grid_strings.xml b/photopicker/res/values-nl/feature_category_grid_strings.xml
new file mode 100644
index 000000000..d386411c4
--- /dev/null
+++ b/photopicker/res/values-nl/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Collecties"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Nog geen mensen en huisdieren"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Hier verschijnen foto\'s en video\'s, gegroepeerd op vergelijkbare gezichten"</string>
+</resources>
diff --git a/photopicker/res/values-nl/feature_preview_strings.xml b/photopicker/res/values-nl/feature_preview_strings.xml
index 90561be79..010d43137 100644
--- a/photopicker/res/values-nl/feature_preview_strings.xml
+++ b/photopicker/res/values-nl/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pauzeren"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Geluid uitzetten"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Geluid aanzetten"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pagina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> van <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-nl/feature_privacy_explainer_strings.xml b/photopicker/res/values-nl/feature_privacy_explainer_strings.xml
index 345f89e58..54f3dcb9b 100644
--- a/photopicker/res/values-nl/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-nl/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> heeft alleen toegang tot de foto\'s die je selecteert"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecteer foto\'s en video\'s waartoe je <xliff:g id="APP_NAME">%1$s</xliff:g> toegang wilt geven"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Foto\'s en video\'s beheren waartoe <xliff:g id="APP_NAME">%1$s</xliff:g> toegang heeft"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Deze app"</string>
 </resources>
diff --git a/photopicker/res/values-nl/feature_search_strings.xml b/photopicker/res/values-nl/feature_search_strings.xml
index 4a21667cc..169550867 100644
--- a/photopicker/res/values-nl/feature_search_strings.xml
+++ b/photopicker/res/values-nl/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Zoeken"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Doorzoek je foto\'s"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Doorzoek je video\'s"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Zoektekst wissen"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Geen resultaten gevonden"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Zoek naar vergelijkbare woorden"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggesties"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Zoekfunctie staat uit"</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Zoek naar vergelijkbare woorden.\n\nAlleen items waarvan een back-up is gemaakt, worden in de zoekresultaten getoond."</string>
 </resources>
diff --git a/photopicker/res/values-or/feature_category_grid_strings.xml b/photopicker/res/values-or/feature_category_grid_strings.xml
new file mode 100644
index 000000000..a74865dd6
--- /dev/null
+++ b/photopicker/res/values-or/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"      "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"         "</string>
+</resources>
diff --git a/photopicker/res/values-or/feature_preview_strings.xml b/photopicker/res/values-or/feature_preview_strings.xml
index 1522d5651..6b9eb72f5 100644
--- a/photopicker/res/values-or/feature_preview_strings.xml
+++ b/photopicker/res/values-or/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>  <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-or/feature_privacy_explainer_strings.xml b/photopicker/res/values-or/feature_privacy_explainer_strings.xml
index 8ee3b1f8c..cd178d46c 100644
--- a/photopicker/res/values-or/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-or/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-or/feature_search_strings.xml b/photopicker/res/values-or/feature_search_strings.xml
index b7c035aa2..048fde10e 100644
--- a/photopicker/res/values-or/feature_search_strings.xml
+++ b/photopicker/res/values-or/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"     "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"     \n\n       "</string>
 </resources>
diff --git a/photopicker/res/values-pa/feature_category_grid_strings.xml b/photopicker/res/values-pa/feature_category_grid_strings.xml
new file mode 100644
index 000000000..c0db732b4
--- /dev/null
+++ b/photopicker/res/values-pa/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"            "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"-          "</string>
+</resources>
diff --git a/photopicker/res/values-pa/feature_preview_strings.xml b/photopicker/res/values-pa/feature_preview_strings.xml
index 141780458..0992fafe3 100644
--- a/photopicker/res/values-pa/feature_preview_strings.xml
+++ b/photopicker/res/values-pa/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>   <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-pa/feature_privacy_explainer_strings.xml b/photopicker/res/values-pa/feature_privacy_explainer_strings.xml
index f9358a6f0..3ba6dfa31 100644
--- a/photopicker/res/values-pa/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-pa/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"    ,    <xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"      ,   <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-pa/feature_search_strings.xml b/photopicker/res/values-pa/feature_search_strings.xml
index 0b75aae3d..277650aba 100644
--- a/photopicker/res/values-pa/feature_search_strings.xml
+++ b/photopicker/res/values-pa/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"-    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"-    \n\n              "</string>
 </resources>
diff --git a/photopicker/res/values-pl/feature_category_grid_strings.xml b/photopicker/res/values-pl/feature_category_grid_strings.xml
new file mode 100644
index 000000000..bace04b3f
--- /dev/null
+++ b/photopicker/res/values-pl/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Kolekcje"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Brak osb izwierzt"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Wtym miejscu bd widoczne zdjcia ifilmy pogrupowane wedug podobnych twarzy"</string>
+</resources>
diff --git a/photopicker/res/values-pl/feature_preview_strings.xml b/photopicker/res/values-pl/feature_preview_strings.xml
index 1e392c181..4fadb0f35 100644
--- a/photopicker/res/values-pl/feature_preview_strings.xml
+++ b/photopicker/res/values-pl/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Wstrzymaj"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Wycisz dwik"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Wycz wyciszenie dwiku."</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Strona <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>z<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-pl/feature_privacy_explainer_strings.xml b/photopicker/res/values-pl/feature_privacy_explainer_strings.xml
index b0d3add3e..21ccdc57f 100644
--- a/photopicker/res/values-pl/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-pl/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Aplikacja <xliff:g id="APP_NAME">%1$s</xliff:g> ma dostp tylko do wybranych przez Ciebie zdj"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Wybierz zdjcia ifilmy, ktre chcesz udostpni aplikacji <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Zarzdzaj zdjciami ifilmami, do ktrych dostp ma aplikacja <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ta aplikacja"</string>
 </resources>
diff --git a/photopicker/res/values-pl/feature_search_strings.xml b/photopicker/res/values-pl/feature_search_strings.xml
index 97f2406b4..dfc32774b 100644
--- a/photopicker/res/values-pl/feature_search_strings.xml
+++ b/photopicker/res/values-pl/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Szukaj"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Przeszukaj swoje zdjcia"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Przeszukaj swoje filmy"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Wyczy wyszukiwany tekst"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Brak wynikw"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Sprbuj wyszuka podobne sowa"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestie"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Wyszukiwanie wyczone."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Sprbuj wyszuka podobne sowa.\n\nWwynikach wyszukiwania bd wywietlane tylko elementy zutworzon kopi zapasow."</string>
 </resources>
diff --git a/photopicker/res/values-pt-rBR/feature_category_grid_strings.xml b/photopicker/res/values-pt-rBR/feature_category_grid_strings.xml
new file mode 100644
index 000000000..3e3c4fb8a
--- /dev/null
+++ b/photopicker/res/values-pt-rBR/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colees"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ainda no h pessoas e animais de estimao"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Fotos e vdeos agrupados por reconhecimento facial vo aparecer aqui"</string>
+</resources>
diff --git a/photopicker/res/values-pt-rBR/feature_preview_strings.xml b/photopicker/res/values-pt-rBR/feature_preview_strings.xml
index 655fd9e4c..5e212c737 100644
--- a/photopicker/res/values-pt-rBR/feature_preview_strings.xml
+++ b/photopicker/res/values-pt-rBR/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausar"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Desativar som"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ativar som"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pgina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-pt-rBR/feature_privacy_explainer_strings.xml b/photopicker/res/values-pt-rBR/feature_privacy_explainer_strings.xml
index 097af5b89..68eb6e0ed 100644
--- a/photopicker/res/values-pt-rBR/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-pt-rBR/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"O app <xliff:g id="APP_NAME">%1$s</xliff:g> s ter acesso s fotos que voc selecionar"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecione fotos e vdeos que o app <xliff:g id="APP_NAME">%1$s</xliff:g> pode acessar"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Gerenciar fotos e vdeos aos quais o app <xliff:g id="APP_NAME">%1$s</xliff:g> tem acesso"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Este app"</string>
 </resources>
diff --git a/photopicker/res/values-pt-rBR/feature_search_strings.xml b/photopicker/res/values-pt-rBR/feature_search_strings.xml
index 6b59fa098..3754dbfba 100644
--- a/photopicker/res/values-pt-rBR/feature_search_strings.xml
+++ b/photopicker/res/values-pt-rBR/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pesquisar"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pesquise nas suas fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pesquise nos seus vdeos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Limpar texto da pesquisa"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nenhum resultado encontrado"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Tente pesquisar palavras semelhantes"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestes"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pesquisa desativada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Tente pesquisar palavras semelhantes.\n\nApenas os itens salvos em backup vo aparecer nos resultados da pesquisa."</string>
 </resources>
diff --git a/photopicker/res/values-pt-rPT/feature_category_grid_strings.xml b/photopicker/res/values-pt-rPT/feature_category_grid_strings.xml
new file mode 100644
index 000000000..868dc0a70
--- /dev/null
+++ b/photopicker/res/values-pt-rPT/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colees"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ainda no existem pessoas nem animais de estimao"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"As fotos e os vdeos, agrupados por caras semelhantes, so apresentados aqui"</string>
+</resources>
diff --git a/photopicker/res/values-pt-rPT/feature_preview_strings.xml b/photopicker/res/values-pt-rPT/feature_preview_strings.xml
index f2152e974..737b6295c 100644
--- a/photopicker/res/values-pt-rPT/feature_preview_strings.xml
+++ b/photopicker/res/values-pt-rPT/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausar"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Desativar volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Reativar volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pgina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-pt-rPT/feature_privacy_explainer_strings.xml b/photopicker/res/values-pt-rPT/feature_privacy_explainer_strings.xml
index afb43db56..5bd07ec0f 100644
--- a/photopicker/res/values-pt-rPT/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-pt-rPT/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"A app <xliff:g id="APP_NAME">%1$s</xliff:g> s vai ter acesso s fotos selecionadas por si"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecione as fotos e os vdeos aos quais a app <xliff:g id="APP_NAME">%1$s</xliff:g> pode aceder"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Faa a gesto das fotos e dos vdeos a que a app <xliff:g id="APP_NAME">%1$s</xliff:g> tem acesso"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Esta app"</string>
 </resources>
diff --git a/photopicker/res/values-pt-rPT/feature_search_strings.xml b/photopicker/res/values-pt-rPT/feature_search_strings.xml
index c2bfdba41..c8d5374c4 100644
--- a/photopicker/res/values-pt-rPT/feature_search_strings.xml
+++ b/photopicker/res/values-pt-rPT/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pesquisar"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pesquise as suas fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pesquise os seus vdeos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Limpar texto de pesquisa"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No foram encontrados resultados"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Experimente pesquisar palavras semelhantes"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestes"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pesquisa desativada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Experimente pesquisar palavras semelhantes.\n\nApenas os itens com cpia de segurana aparecem nos resultados da pesquisa."</string>
 </resources>
diff --git a/photopicker/res/values-pt/feature_category_grid_strings.xml b/photopicker/res/values-pt/feature_category_grid_strings.xml
new file mode 100644
index 000000000..3e3c4fb8a
--- /dev/null
+++ b/photopicker/res/values-pt/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colees"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ainda no h pessoas e animais de estimao"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Fotos e vdeos agrupados por reconhecimento facial vo aparecer aqui"</string>
+</resources>
diff --git a/photopicker/res/values-pt/feature_preview_strings.xml b/photopicker/res/values-pt/feature_preview_strings.xml
index 655fd9e4c..5e212c737 100644
--- a/photopicker/res/values-pt/feature_preview_strings.xml
+++ b/photopicker/res/values-pt/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausar"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Desativar som"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ativar som"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pgina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> de <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-pt/feature_privacy_explainer_strings.xml b/photopicker/res/values-pt/feature_privacy_explainer_strings.xml
index 097af5b89..68eb6e0ed 100644
--- a/photopicker/res/values-pt/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-pt/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"O app <xliff:g id="APP_NAME">%1$s</xliff:g> s ter acesso s fotos que voc selecionar"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecione fotos e vdeos que o app <xliff:g id="APP_NAME">%1$s</xliff:g> pode acessar"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Gerenciar fotos e vdeos aos quais o app <xliff:g id="APP_NAME">%1$s</xliff:g> tem acesso"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Este app"</string>
 </resources>
diff --git a/photopicker/res/values-pt/feature_search_strings.xml b/photopicker/res/values-pt/feature_search_strings.xml
index 6b59fa098..3754dbfba 100644
--- a/photopicker/res/values-pt/feature_search_strings.xml
+++ b/photopicker/res/values-pt/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pesquisar"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pesquise nas suas fotos"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pesquise nos seus vdeos"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Limpar texto da pesquisa"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nenhum resultado encontrado"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Tente pesquisar palavras semelhantes"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestes"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pesquisa desativada."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Tente pesquisar palavras semelhantes.\n\nApenas os itens salvos em backup vo aparecer nos resultados da pesquisa."</string>
 </resources>
diff --git a/photopicker/res/values-ro/feature_category_grid_strings.xml b/photopicker/res/values-ro/feature_category_grid_strings.xml
new file mode 100644
index 000000000..b4e43fbd3
--- /dev/null
+++ b/photopicker/res/values-ro/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Colecii"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"nc nu exist persoane i animale de companie"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Fotografiile i videoclipurile, grupate dup chipuri similare, vor aprea aici"</string>
+</resources>
diff --git a/photopicker/res/values-ro/feature_preview_strings.xml b/photopicker/res/values-ro/feature_preview_strings.xml
index 4da5d0179..c2b881050 100644
--- a/photopicker/res/values-ro/feature_preview_strings.xml
+++ b/photopicker/res/values-ro/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"ntrerupe"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Dezactiveaz sunetul"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Activeaz sunetul"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Pagina <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> din <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ro/feature_privacy_explainer_strings.xml b/photopicker/res/values-ro/feature_privacy_explainer_strings.xml
index 1fb5f5bac..cf7cb2a53 100644
--- a/photopicker/res/values-ro/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ro/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> poate accesa numai fotografiile selectate de tine"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Selecteaz fotografiile i videoclipurile la care <xliff:g id="APP_NAME">%1$s</xliff:g> poate avea acces"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"S gestioneze fotografiile i videoclipurile la care are acces <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Aceast aplicaie"</string>
 </resources>
diff --git a/photopicker/res/values-ro/feature_search_strings.xml b/photopicker/res/values-ro/feature_search_strings.xml
index 436899085..6a285041a 100644
--- a/photopicker/res/values-ro/feature_search_strings.xml
+++ b/photopicker/res/values-ro/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Caut"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Caut n fotografii"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Caut n videoclipuri"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"terge textul cutrii"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Niciun rezultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"ncearc s caui cuvinte similare"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestii"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Cutarea a fost dezactivat."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"ncearc s caui cuvinte similare.\n\nDoar elementele pentru care s-a fcut backup vor aprea n rezultatele cutrii."</string>
 </resources>
diff --git a/photopicker/res/values-ru/feature_category_grid_strings.xml b/photopicker/res/values-ru/feature_category_grid_strings.xml
new file mode 100644
index 000000000..8d2be0e94
--- /dev/null
+++ b/photopicker/res/values-ru/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"  \"   \"  "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"     ,    ."</string>
+</resources>
diff --git a/photopicker/res/values-ru/feature_preview_strings.xml b/photopicker/res/values-ru/feature_preview_strings.xml
index 75758c3c3..545016d34 100644
--- a/photopicker/res/values-ru/feature_preview_strings.xml
+++ b/photopicker/res/values-ru/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ru/feature_privacy_explainer_strings.xml b/photopicker/res/values-ru/feature_privacy_explainer_strings.xml
index 7c2b3c74c..890ae8334 100644
--- a/photopicker/res/values-ru/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ru/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>       ."</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   ,   <xliff:g id="APP_NAME">%1$s</xliff:g>   ."</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">",      \"<xliff:g id="APP_NAME">%1$s</xliff:g>\"  "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ru/feature_search_strings.xml b/photopicker/res/values-ru/feature_search_strings.xml
index 5d5c6db5e..6c3ec2f1b 100644
--- a/photopicker/res/values-ru/feature_search_strings.xml
+++ b/photopicker/res/values-ru/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-si/feature_category_grid_strings.xml b/photopicker/res/values-si/feature_category_grid_strings.xml
new file mode 100644
index 000000000..bfc5dad6c
--- /dev/null
+++ b/photopicker/res/values-si/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"        ,    "</string>
+</resources>
diff --git a/photopicker/res/values-si/feature_preview_strings.xml b/photopicker/res/values-si/feature_preview_strings.xml
index 48e59e742..238446c76 100644
--- a/photopicker/res/values-si/feature_preview_strings.xml
+++ b/photopicker/res/values-si/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"   "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g> <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  "</string>
 </resources>
diff --git a/photopicker/res/values-si/feature_privacy_explainer_strings.xml b/photopicker/res/values-si/feature_privacy_explainer_strings.xml
index b43c88511..f035691b1 100644
--- a/photopicker/res/values-si/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-si/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>           "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">" <xliff:g id="APP_NAME">%1$s</xliff:g>         "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-si/feature_search_strings.xml b/photopicker/res/values-si/feature_search_strings.xml
index eb5c9b021..f42d15a31 100644
--- a/photopicker/res/values-si/feature_search_strings.xml
+++ b/photopicker/res/values-si/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n          ."</string>
 </resources>
diff --git a/photopicker/res/values-sk/feature_category_grid_strings.xml b/photopicker/res/values-sk/feature_category_grid_strings.xml
new file mode 100644
index 000000000..fd40f3e2a
--- /dev/null
+++ b/photopicker/res/values-sk/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Zbierky"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Zatia iadni udia ani zvierat"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Tu sa bud zobrazova fotky avide zoskupen poda podobnch tvr"</string>
+</resources>
diff --git a/photopicker/res/values-sk/feature_preview_strings.xml b/photopicker/res/values-sk/feature_preview_strings.xml
index 040f59773..b4f97a667 100644
--- a/photopicker/res/values-sk/feature_preview_strings.xml
+++ b/photopicker/res/values-sk/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pozastavi"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Vypn zvuk"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Zapn zvuk"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>.strana z<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-sk/feature_privacy_explainer_strings.xml b/photopicker/res/values-sk/feature_privacy_explainer_strings.xml
index 327db51d9..1886bec11 100644
--- a/photopicker/res/values-sk/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-sk/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Aplikcia <xliff:g id="APP_NAME">%1$s</xliff:g> bude ma prstup iba kfotkm, ktor vyberiete"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Vyberte fotky avide, ku ktorm m ma aplikcia <xliff:g id="APP_NAME">%1$s</xliff:g> prstup"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Spravujte fotky avide, ku ktorm m aplikcia <xliff:g id="APP_NAME">%1$s</xliff:g> prstup"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Tto aplikcia"</string>
 </resources>
diff --git a/photopicker/res/values-sk/feature_search_strings.xml b/photopicker/res/values-sk/feature_search_strings.xml
index d7dac5ccf..b3b88ea09 100644
--- a/photopicker/res/values-sk/feature_search_strings.xml
+++ b/photopicker/res/values-sk/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Hada"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Hadajte vo fotkch"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hadajte vo videch"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Vymaza text vyhadvania"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nenali sa iadne vsledky"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Skste vyhada podobn slov"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Nvrhy"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Vyhadvanie je zakzan."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Skste vyhada podobn slov.\n\nVo vsledkoch vyhadvania sa zobrazia iba poloky, ktor s zlohovan."</string>
 </resources>
diff --git a/photopicker/res/values-sl/feature_category_grid_strings.xml b/photopicker/res/values-sl/feature_category_grid_strings.xml
new file mode 100644
index 000000000..d066f304e
--- /dev/null
+++ b/photopicker/res/values-sl/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Zbirke"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Ni e oseb in hinih ljubljenkov"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Tukaj bodo prikazane fotografije in videoposnetki, razvreni po podobnih obrazih"</string>
+</resources>
diff --git a/photopicker/res/values-sl/feature_preview_strings.xml b/photopicker/res/values-sl/feature_preview_strings.xml
index dc753c29e..416fd8d8d 100644
--- a/photopicker/res/values-sl/feature_preview_strings.xml
+++ b/photopicker/res/values-sl/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Zaasna zaustavitev"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Izklop zvoka"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Vklop zvoka"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Stran <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> od <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-sl/feature_privacy_explainer_strings.xml b/photopicker/res/values-sl/feature_privacy_explainer_strings.xml
index 7a9ed4db4..a817e41e1 100644
--- a/photopicker/res/values-sl/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-sl/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Aplikacija <xliff:g id="APP_NAME">%1$s</xliff:g> bo lahko dostopala samo do fotografij, ki jih izberete"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Izberite fotografije in videoposnetke, do katerih lahko dostopa aplikacija <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Upravljajte fotografije in videoposnetke, do katerih ima aplikacija <xliff:g id="APP_NAME">%1$s</xliff:g> dostop"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ta aplikacija"</string>
 </resources>
diff --git a/photopicker/res/values-sl/feature_search_strings.xml b/photopicker/res/values-sl/feature_search_strings.xml
index b1f8ac518..93ba8ef09 100644
--- a/photopicker/res/values-sl/feature_search_strings.xml
+++ b/photopicker/res/values-sl/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Iskanje"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Iite po svojih fotografijah"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Iite po svojih videoposnetkih"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Poisti besedilo v iskalni vrstici"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ni rezultatov"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Poskusite poiskati podobne besede"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Predlogi"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Iskanje je onemogoeno."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Poskusite poiskati podobne besede.\n\nV rezultatih iskanja bodo prikazani samo elementi, ki so varnostno kopirani."</string>
 </resources>
diff --git a/photopicker/res/values-sq/feature_category_grid_strings.xml b/photopicker/res/values-sq/feature_category_grid_strings.xml
new file mode 100644
index 000000000..9ee7a1389
--- /dev/null
+++ b/photopicker/res/values-sq/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Koleksionet"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Nuk ka ende persona dhe kafsh shtpiake"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Fotografit dhe videot, t grupuara sipas fytyrave t ngjashme, do t shfaqen ktu"</string>
+</resources>
diff --git a/photopicker/res/values-sq/feature_preview_strings.xml b/photopicker/res/values-sq/feature_preview_strings.xml
index a4db9754a..b9407a0c5 100644
--- a/photopicker/res/values-sq/feature_preview_strings.xml
+++ b/photopicker/res/values-sq/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Vendos n pauz"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"aktivizo volumin"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Aktivizo volumin"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Faqja <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> nga <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-sq/feature_privacy_explainer_strings.xml b/photopicker/res/values-sq/feature_privacy_explainer_strings.xml
index 754bf3f6f..a0d982898 100644
--- a/photopicker/res/values-sq/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-sq/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"\"<xliff:g id="APP_NAME">%1$s</xliff:g>\" do t ket qasje vetm te fotografit q zgjedh ti"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Zgjidh fotografit dhe videot q lejon q t qaset \"<xliff:g id="APP_NAME">%1$s</xliff:g>\""</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Menaxho fotografit dhe videot te t cilat ka qasje \"<xliff:g id="APP_NAME">%1$s</xliff:g>\""</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Ky aplikacion"</string>
 </resources>
diff --git a/photopicker/res/values-sq/feature_search_strings.xml b/photopicker/res/values-sq/feature_search_strings.xml
index 53752c22e..d77245492 100644
--- a/photopicker/res/values-sq/feature_search_strings.xml
+++ b/photopicker/res/values-sq/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Krko"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Krko te fotografit e tua"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Krko te videot e tua"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Pastro tekstin e krkimit"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nuk u gjet asnj rezultat"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Provo t krkosh pr fjal t ngjashme"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugjerime"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Krkimi sht aktivizuar."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Provo t krkosh pr fjal t ngjashme.\n\nN rezultatet e tua t krkimit do t shfaqen vetm artikujt q jan rezervuar."</string>
 </resources>
diff --git a/photopicker/res/values-sr/feature_category_grid_strings.xml b/photopicker/res/values-sr/feature_category_grid_strings.xml
new file mode 100644
index 000000000..e66bd20f3
--- /dev/null
+++ b/photopicker/res/values-sr/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"          "</string>
+</resources>
diff --git a/photopicker/res/values-sr/feature_preview_strings.xml b/photopicker/res/values-sr/feature_preview_strings.xml
index 553e34ff8..e2811c2e1 100644
--- a/photopicker/res/values-sr/feature_preview_strings.xml
+++ b/photopicker/res/values-sr/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="PAGE_NUMBER">%1$s</xliff:g>.   <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-sr/feature_privacy_explainer_strings.xml b/photopicker/res/values-sr/feature_privacy_explainer_strings.xml
index 56e0cc428..503b5f9a7 100644
--- a/photopicker/res/values-sr/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-sr/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"      <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"     <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-sr/feature_search_strings.xml b/photopicker/res/values-sr/feature_search_strings.xml
index 7a3cdaf82..2749c8a5b 100644
--- a/photopicker/res/values-sr/feature_search_strings.xml
+++ b/photopicker/res/values-sr/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"  "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"  .\n\n            ."</string>
 </resources>
diff --git a/photopicker/res/values-sv/feature_category_grid_strings.xml b/photopicker/res/values-sv/feature_category_grid_strings.xml
new file mode 100644
index 000000000..2147b8a80
--- /dev/null
+++ b/photopicker/res/values-sv/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Samlingar"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Inga personer eller husdjur n"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Foton och videor, grupperade efter liknande ansikten, visas hr"</string>
+</resources>
diff --git a/photopicker/res/values-sv/feature_preview_strings.xml b/photopicker/res/values-sv/feature_preview_strings.xml
index 3f7a339a9..ac89838d9 100644
--- a/photopicker/res/values-sv/feature_preview_strings.xml
+++ b/photopicker/res/values-sv/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pausa"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Stng av ljudet"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Sl p ljudet"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Sida <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> av <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-sv/feature_privacy_explainer_strings.xml b/photopicker/res/values-sv/feature_privacy_explainer_strings.xml
index 9304ec9e6..9ebf8816e 100644
--- a/photopicker/res/values-sv/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-sv/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> fr endast tkomst till fotona du vljer"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Vlj foton och videor som du ger <xliff:g id="APP_NAME">%1$s</xliff:g> tkomst till"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Hantera foton och videor som <xliff:g id="APP_NAME">%1$s</xliff:g> har tkomst till"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Den hr appen"</string>
 </resources>
diff --git a/photopicker/res/values-sv/feature_search_strings.xml b/photopicker/res/values-sv/feature_search_strings.xml
index b2b179617..d21e0a6b1 100644
--- a/photopicker/res/values-sv/feature_search_strings.xml
+++ b/photopicker/res/values-sv/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sk"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sk bland dina foton"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sk bland dina videor"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Rensa sktext"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Inga resultat hittades"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Testa att ska efter liknande ord"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Frslag"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Skning inaktiverad."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Testa att ska efter liknande ord.\n\nEndast objekt som har skerhetskopierats visas i skresultaten."</string>
 </resources>
diff --git a/photopicker/res/values-sw/feature_category_grid_strings.xml b/photopicker/res/values-sw/feature_category_grid_strings.xml
new file mode 100644
index 000000000..0f222cf9f
--- /dev/null
+++ b/photopicker/res/values-sw/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Mikusanyiko"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Bado hakuna watu na wanyama vipenzi"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Picha na video, zilizopangwa kulingana na nyuso zinazofanana, zitaonekana hapa"</string>
+</resources>
diff --git a/photopicker/res/values-sw/feature_cloud_strings.xml b/photopicker/res/values-sw/feature_cloud_strings.xml
index 137b47c06..36790b6df 100644
--- a/photopicker/res/values-sw/feature_cloud_strings.xml
+++ b/photopicker/res/values-sw/feature_cloud_strings.xml
@@ -26,7 +26,7 @@
     <string name="photopicker_banner_cloud_choose_account_title" msgid="286679907089224434">"Chagua akaunti ya <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_banner_cloud_choose_account_message" msgid="5173210485511611652">"Ili ujumuishe picha zilizotoka <xliff:g id="APP_NAME">%1$s</xliff:g> hapa, chagua akaunti kwenye programu"</string>
     <string name="photopicker_banner_cloud_choose_account_button" msgid="3407910358624445230">"Chagua akaunti"</string>
-    <string name="photopicker_banner_cloud_choose_provider_title" msgid="992613053341538886">"Chagua programu ya maudhui ya wingu"</string>
+    <string name="photopicker_banner_cloud_choose_provider_title" msgid="992613053341538886">"Chagua programu ya maudhui kwenye wingu"</string>
     <string name="photopicker_banner_cloud_choose_provider_message" msgid="1102889303996108506">"Ili ujumuishe picha zilizohifadhiwa nakala hapa, chagua programu ya maudhui ya wingu kwenye Mipangilio"</string>
     <string name="photopicker_banner_cloud_choose_app_button" msgid="8228365266860220123">"Chagua programu"</string>
 </resources>
diff --git a/photopicker/res/values-sw/feature_preview_strings.xml b/photopicker/res/values-sw/feature_preview_strings.xml
index f493a2e23..19669abeb 100644
--- a/photopicker/res/values-sw/feature_preview_strings.xml
+++ b/photopicker/res/values-sw/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Sitisha"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Zima Sauti"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Rejesha Sauti"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Ukurasa wa <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> kati ya <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-sw/feature_privacy_explainer_strings.xml b/photopicker/res/values-sw/feature_privacy_explainer_strings.xml
index d57b030ec..5376eba02 100644
--- a/photopicker/res/values-sw/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-sw/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> itaweza tu kufikia picha utakazochagua"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Chagua picha na video unazoiruhusu <xliff:g id="APP_NAME">%1$s</xliff:g> kufikia"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Dhibiti picha na video ambazo <xliff:g id="APP_NAME">%1$s</xliff:g> inaweza kufikia"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Programu hii"</string>
 </resources>
diff --git a/photopicker/res/values-sw/feature_search_strings.xml b/photopicker/res/values-sw/feature_search_strings.xml
index 054dc3e49..5ead2c8ec 100644
--- a/photopicker/res/values-sw/feature_search_strings.xml
+++ b/photopicker/res/values-sw/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Tafuta"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Tafuta picha zako"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Tafuta video zako"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Futa maandishi ya utafutaji"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Hakuna matokeo yaliyopatikana"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Jaribu kutafuta maneno yanayofanana"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Mapendekezo"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Umezima kipengele cha utafutaji."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Jaribu kutafuta maneno yanayofanana.\n\nVipengee ulivyohifadhia nakala pekee ndivyo vitaonekana kwenye matokeo yako ya utafutaji."</string>
 </resources>
diff --git a/photopicker/res/values-ta/feature_category_grid_strings.xml b/photopicker/res/values-ta/feature_category_grid_strings.xml
new file mode 100644
index 000000000..4b60590cf
--- /dev/null
+++ b/photopicker/res/values-ta/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"   "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"        "</string>
+</resources>
diff --git a/photopicker/res/values-ta/feature_preview_strings.xml b/photopicker/res/values-ta/feature_preview_strings.xml
index 0b02fa2a1..88571cfef 100644
--- a/photopicker/res/values-ta/feature_preview_strings.xml
+++ b/photopicker/res/values-ta/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ta/feature_privacy_explainer_strings.xml b/photopicker/res/values-ta/feature_privacy_explainer_strings.xml
index a742ce013..53d3a987a 100644
--- a/photopicker/res/values-ta/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ta/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"    <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"    <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ta/feature_search_strings.xml b/photopicker/res/values-ta/feature_search_strings.xml
index 2e0f629a1..4937cb30d 100644
--- a/photopicker/res/values-ta/feature_search_strings.xml
+++ b/photopicker/res/values-ta/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">" "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"   .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-te/feature_category_grid_strings.xml b/photopicker/res/values-te/feature_category_grid_strings.xml
new file mode 100644
index 000000000..f41809f41
--- /dev/null
+++ b/photopicker/res/values-te/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"  &amp;    "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"      ,   "</string>
+</resources>
diff --git a/photopicker/res/values-te/feature_preview_strings.xml b/photopicker/res/values-te/feature_preview_strings.xml
index 7e9a242c6..13bf3ce51 100644
--- a/photopicker/res/values-te/feature_preview_strings.xml
+++ b/photopicker/res/values-te/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"  "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"<xliff:g id="TOTAL_PAGES">%2$s</xliff:g> <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-te/feature_privacy_explainer_strings.xml b/photopicker/res/values-te/feature_privacy_explainer_strings.xml
index 9e75f9a4b..4e2797cb0 100644
--- a/photopicker/res/values-te/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-te/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>      "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>     ,  "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>   ,   "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-te/feature_search_strings.xml b/photopicker/res/values-te/feature_search_strings.xml
index 1de73c3ee..5a523a736 100644
--- a/photopicker/res/values-te/feature_search_strings.xml
+++ b/photopicker/res/values-te/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"   "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"       "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"     .\n\n       ."</string>
 </resources>
diff --git a/photopicker/res/values-th/feature_category_grid_strings.xml b/photopicker/res/values-th/feature_category_grid_strings.xml
new file mode 100644
index 000000000..500bf6d9c
--- /dev/null
+++ b/photopicker/res/values-th/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">""</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">""</string>
+</resources>
diff --git a/photopicker/res/values-th/feature_preview_strings.xml b/photopicker/res/values-th/feature_preview_strings.xml
index d955920fd..a69514099 100644
--- a/photopicker/res/values-th/feature_preview_strings.xml
+++ b/photopicker/res/values-th/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-th/feature_privacy_explainer_strings.xml b/photopicker/res/values-th/feature_privacy_explainer_strings.xml
index ad8cb30cf..9d1f78499 100644
--- a/photopicker/res/values-th/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-th/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">" <xliff:g id="APP_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-th/feature_search_strings.xml b/photopicker/res/values-th/feature_search_strings.xml
index 1bde329ae..c0bece863 100644
--- a/photopicker/res/values-th/feature_search_strings.xml
+++ b/photopicker/res/values-th/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"\n\n"</string>
 </resources>
diff --git a/photopicker/res/values-tl/feature_category_grid_strings.xml b/photopicker/res/values-tl/feature_category_grid_strings.xml
new file mode 100644
index 000000000..7825d65de
--- /dev/null
+++ b/photopicker/res/values-tl/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Mga Koleksyon"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Wala pang tao at alagang hayop"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Lalabas dito ang mga larawan at video na nakagrupo ayon sa magkakahawig na mukha"</string>
+</resources>
diff --git a/photopicker/res/values-tl/feature_preview_strings.xml b/photopicker/res/values-tl/feature_preview_strings.xml
index 0f81bfe5a..15a81acf5 100644
--- a/photopicker/res/values-tl/feature_preview_strings.xml
+++ b/photopicker/res/values-tl/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"I-pause"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"I-mute ang Volume"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"I-unmute ang Volume"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Page <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> ng <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-tl/feature_privacy_explainer_strings.xml b/photopicker/res/values-tl/feature_privacy_explainer_strings.xml
index 7e53c88ea..633f83137 100644
--- a/photopicker/res/values-tl/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-tl/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"Magkakaroon lang ng access ang <xliff:g id="APP_NAME">%1$s</xliff:g> sa mga larawang pipiliin mo"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Pumili ng mga larawan at video na pinapayagan mong ma-access ng <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Pamahalaan ang mga larawan at video na naa-access ng <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"App na ito"</string>
 </resources>
diff --git a/photopicker/res/values-tl/feature_search_strings.xml b/photopicker/res/values-tl/feature_search_strings.xml
index 69d537ee3..e132f3e5d 100644
--- a/photopicker/res/values-tl/feature_search_strings.xml
+++ b/photopicker/res/values-tl/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Maghanap"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Maghanap sa iyong mga larawan"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hanapin ang iyong mga video"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"I-clear ang text para sa paghahanap"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Walang nakitang resulta"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Subukang maghanap ng mga katulad na salita"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Mga Suhestyon"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Naka-disable ang paghahanap"</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Subukang maghanap ng mga katulad na salita.\n\nAng mga item lang na na-back up ang lalabas sa iyong mga resulta ng paghahanap."</string>
 </resources>
diff --git a/photopicker/res/values-tr/feature_category_grid_strings.xml b/photopicker/res/values-tr/feature_category_grid_strings.xml
new file mode 100644
index 000000000..73800fa33
--- /dev/null
+++ b/photopicker/res/values-tr/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Koleksiyonlar"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Henz kii ve evcil hayvan yok"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Benzer yzlere gre gruplandrlm fotoraf ve videolar burada gsterilir"</string>
+</resources>
diff --git a/photopicker/res/values-tr/feature_preview_strings.xml b/photopicker/res/values-tr/feature_preview_strings.xml
index 1a482149b..a8a65baf2 100644
--- a/photopicker/res/values-tr/feature_preview_strings.xml
+++ b/photopicker/res/values-tr/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Duraklat"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Sesi kapat"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Sesi a"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Sayfa <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>/<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-tr/feature_privacy_explainer_strings.xml b/photopicker/res/values-tr/feature_privacy_explainer_strings.xml
index 74afb1779..1002cc30d 100644
--- a/photopicker/res/values-tr/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-tr/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> yalnzca setiiniz fotoraflara eriebilir"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g> uygulamasnn erimesine izin verdiiniz fotoraf ve videolar sein"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g> uygulamasnn eriebilecei fotoraflar ve videolar belirleyin"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Bu uygulama"</string>
 </resources>
diff --git a/photopicker/res/values-tr/feature_search_strings.xml b/photopicker/res/values-tr/feature_search_strings.xml
index b31569881..ad2445dd6 100644
--- a/photopicker/res/values-tr/feature_search_strings.xml
+++ b/photopicker/res/values-tr/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Ara"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fotoraflarnzda arama yapn"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Videolarnzda arayma yapn"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Arama metnini temizle"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Sonu bulunamad"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Benzer kelimeleri aramay deneyin"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"neriler"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Arama devre d brakld"</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Benzer kelimeleri aramay deneyin.\n\nYalnzca yedeklenen eler arama sonularnzda gsterilir."</string>
 </resources>
diff --git a/photopicker/res/values-uk/feature_category_grid_strings.xml b/photopicker/res/values-uk/feature_category_grid_strings.xml
new file mode 100644
index 000000000..b8fd25981
--- /dev/null
+++ b/photopicker/res/values-uk/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"     "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"    ,    "</string>
+</resources>
diff --git a/photopicker/res/values-uk/feature_preview_strings.xml b/photopicker/res/values-uk/feature_preview_strings.xml
index 55884c9fd..e221fd06e 100644
--- a/photopicker/res/values-uk/feature_preview_strings.xml
+++ b/photopicker/res/values-uk/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">" "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">" "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-uk/feature_privacy_explainer_strings.xml b/photopicker/res/values-uk/feature_privacy_explainer_strings.xml
index a22c8cfdf..0fe46abb6 100644
--- a/photopicker/res/values-uk/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-uk/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">" <xliff:g id="APP_NAME">%1$s</xliff:g>       "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"   ,    <xliff:g id="APP_NAME">%1$s</xliff:g>   "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"   <xliff:g id="APP_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-uk/feature_search_strings.xml b/photopicker/res/values-uk/feature_search_strings.xml
index 76a1bf936..5cdaa9882 100644
--- a/photopicker/res/values-uk/feature_search_strings.xml
+++ b/photopicker/res/values-uk/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"  "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"    .\n\n     ,     ."</string>
 </resources>
diff --git a/photopicker/res/values-ur/feature_category_grid_strings.xml b/photopicker/res/values-ur/feature_category_grid_strings.xml
new file mode 100644
index 000000000..479875c1a
--- /dev/null
+++ b/photopicker/res/values-ur/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"       "</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"              "</string>
+</resources>
diff --git a/photopicker/res/values-ur/feature_preview_strings.xml b/photopicker/res/values-ur/feature_preview_strings.xml
index 094f1fb29..11cbb56e3 100644
--- a/photopicker/res/values-ur/feature_preview_strings.xml
+++ b/photopicker/res/values-ur/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">" "</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"  "</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"   "</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-ur/feature_privacy_explainer_strings.xml b/photopicker/res/values-ur/feature_privacy_explainer_strings.xml
index 9d00a5212..ca80643c6 100644
--- a/photopicker/res/values-ur/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-ur/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>           "</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"         <xliff:g id="APP_NAME">%1$s</xliff:g>        "</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"         <xliff:g id="APP_NAME">%1$s</xliff:g>     "</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">" "</string>
 </resources>
diff --git a/photopicker/res/values-ur/feature_search_strings.xml b/photopicker/res/values-ur/feature_search_strings.xml
index 186fdd20e..0e7210e91 100644
--- a/photopicker/res/values-ur/feature_search_strings.xml
+++ b/photopicker/res/values-ur/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"    "</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"       "</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   "</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"       \n\n                  "</string>
 </resources>
diff --git a/photopicker/res/values-uz/feature_category_grid_strings.xml b/photopicker/res/values-uz/feature_category_grid_strings.xml
new file mode 100644
index 000000000..fcd277dd7
--- /dev/null
+++ b/photopicker/res/values-uz/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Termalar"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Hozircha odamlar va hayvonlar yoq"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Oxshash yuzlar orqali guruhlangan surat va videolar bu yerda chiqadi"</string>
+</resources>
diff --git a/photopicker/res/values-uz/feature_preview_strings.xml b/photopicker/res/values-uz/feature_preview_strings.xml
index 9c8980b4b..680eb8f26 100644
--- a/photopicker/res/values-uz/feature_preview_strings.xml
+++ b/photopicker/res/values-uz/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Pauza"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Ovozsiz qilish"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Ovozni yoqish"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Sahifa: <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> / <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-uz/feature_privacy_explainer_strings.xml b/photopicker/res/values-uz/feature_privacy_explainer_strings.xml
index 8de1375b0..f5e129512 100644
--- a/photopicker/res/values-uz/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-uz/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> faqat siz tanlagan suratlarga kira oladi"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g> ilovasi kira olishi uchun video va suratlarni tanlang"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g> ilovasining ruxsati bor suratlar va videolarni boshqarish"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Bu ilova"</string>
 </resources>
diff --git a/photopicker/res/values-uz/feature_search_strings.xml b/photopicker/res/values-uz/feature_search_strings.xml
index 1824a3302..e29647eff 100644
--- a/photopicker/res/values-uz/feature_search_strings.xml
+++ b/photopicker/res/values-uz/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Qidiruv"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Suratlardan qidirish"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Videolardan qidiring"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Qidiruv maydonini tozalash"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Hech narsa topilmadi"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Oxshash sozlarni qidiring"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Takliflar"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Qidiruv faolsizlantirildi."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Oxshash sozlarni qidiring.\n\nQidiruv natijalarida faqat zaxiralanganlar chiqadi."</string>
 </resources>
diff --git a/photopicker/res/values-vi/feature_category_grid_strings.xml b/photopicker/res/values-vi/feature_category_grid_strings.xml
new file mode 100644
index 000000000..cff75dd83
--- /dev/null
+++ b/photopicker/res/values-vi/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"B su tp"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Cha c ngi v th cng"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"nh v video c nhm theo cc khun mt tng t s xut hin  y"</string>
+</resources>
diff --git a/photopicker/res/values-vi/feature_preview_strings.xml b/photopicker/res/values-vi/feature_preview_strings.xml
index 48da89c91..108a3bfce 100644
--- a/photopicker/res/values-vi/feature_preview_strings.xml
+++ b/photopicker/res/values-vi/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Tm dng"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Tt ting"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Bt ting"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Trang <xliff:g id="PAGE_NUMBER">%1$s</xliff:g> trong s <xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-vi/feature_privacy_explainer_strings.xml b/photopicker/res/values-vi/feature_privacy_explainer_strings.xml
index cc470c4b0..58291141c 100644
--- a/photopicker/res/values-vi/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-vi/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g> s ch c quyn truy cp vo nhng nh bn chn"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Chn nhng nh v video m bn cho php <xliff:g id="APP_NAME">%1$s</xliff:g> truy cp"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Qun l nh v video m <xliff:g id="APP_NAME">%1$s</xliff:g> c quyn truy cp"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"ng dng ny"</string>
 </resources>
diff --git a/photopicker/res/values-vi/feature_search_strings.xml b/photopicker/res/values-vi/feature_search_strings.xml
index 27b4277d5..56bddff83 100644
--- a/photopicker/res/values-vi/feature_search_strings.xml
+++ b/photopicker/res/values-vi/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Tm kim"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Tm kim nh ca bn"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Tm kim video ca bn"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Xo ni dung tm kim"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Khng tm thy kt qu"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Hy th tm nhng t tng t"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Ni dung  xut"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Tnh nng tm kim  tt."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Hy th tm cc t tng t.\n\nCh nhng mc  c sao lu mi xut hin trong kt qu tm kim ca bn."</string>
 </resources>
diff --git a/photopicker/res/values-zh-rCN/feature_category_grid_strings.xml b/photopicker/res/values-zh-rCN/feature_category_grid_strings.xml
new file mode 100644
index 000000000..65416012a
--- /dev/null
+++ b/photopicker/res/values-zh-rCN/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">""</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">""</string>
+</resources>
diff --git a/photopicker/res/values-zh-rCN/feature_preview_strings.xml b/photopicker/res/values-zh-rCN/feature_preview_strings.xml
index 79fb6ec97..2613492dc 100644
--- a/photopicker/res/values-zh-rCN/feature_preview_strings.xml
+++ b/photopicker/res/values-zh-rCN/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-zh-rCN/feature_privacy_explainer_strings.xml b/photopicker/res/values-zh-rCN/feature_privacy_explainer_strings.xml
index ce0ec7759..18d674534 100644
--- a/photopicker/res/values-zh-rCN/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-zh-rCN/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-zh-rCN/feature_search_strings.xml b/photopicker/res/values-zh-rCN/feature_search_strings.xml
index c4cb150af..df13cc878 100644
--- a/photopicker/res/values-zh-rCN/feature_search_strings.xml
+++ b/photopicker/res/values-zh-rCN/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"\n\n"</string>
 </resources>
diff --git a/photopicker/res/values-zh-rHK/feature_category_grid_strings.xml b/photopicker/res/values-zh-rHK/feature_category_grid_strings.xml
new file mode 100644
index 000000000..8e1a28276
--- /dev/null
+++ b/photopicker/res/values-zh-rHK/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">""</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">""</string>
+</resources>
diff --git a/photopicker/res/values-zh-rHK/feature_preview_strings.xml b/photopicker/res/values-zh-rHK/feature_preview_strings.xml
index f156f794b..07cf69cfc 100644
--- a/photopicker/res/values-zh-rHK/feature_preview_strings.xml
+++ b/photopicker/res/values-zh-rHK/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-zh-rHK/feature_privacy_explainer_strings.xml b/photopicker/res/values-zh-rHK/feature_privacy_explainer_strings.xml
index 473ad61a8..742e0e8ac 100644
--- a/photopicker/res/values-zh-rHK/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-zh-rHK/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-zh-rHK/feature_search_strings.xml b/photopicker/res/values-zh-rHK/feature_search_strings.xml
index 48aa842e1..f3627ea96 100644
--- a/photopicker/res/values-zh-rHK/feature_search_strings.xml
+++ b/photopicker/res/values-zh-rHK/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"\n\n"</string>
 </resources>
diff --git a/photopicker/res/values-zh-rTW/feature_category_grid_strings.xml b/photopicker/res/values-zh-rTW/feature_category_grid_strings.xml
new file mode 100644
index 000000000..bd505c5b3
--- /dev/null
+++ b/photopicker/res/values-zh-rTW/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">""</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">""</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">""</string>
+</resources>
diff --git a/photopicker/res/values-zh-rTW/feature_preview_strings.xml b/photopicker/res/values-zh-rTW/feature_preview_strings.xml
index 21de10b04..308d6119c 100644
--- a/photopicker/res/values-zh-rTW/feature_preview_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">""</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">""</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">""</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">" <xliff:g id="PAGE_NUMBER">%1$s</xliff:g>  <xliff:g id="TOTAL_PAGES">%2$s</xliff:g> "</string>
 </resources>
diff --git a/photopicker/res/values-zh-rTW/feature_privacy_explainer_strings.xml b/photopicker/res/values-zh-rTW/feature_privacy_explainer_strings.xml
index 4d71eb132..b4354540f 100644
--- a/photopicker/res/values-zh-rTW/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"<xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">""</string>
 </resources>
diff --git a/photopicker/res/values-zh-rTW/feature_profiles_strings.xml b/photopicker/res/values-zh-rTW/feature_profiles_strings.xml
index 3492d8276..5b9029630 100644
--- a/photopicker/res/values-zh-rTW/feature_profiles_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_profiles_strings.xml
@@ -17,7 +17,7 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
+    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
diff --git a/photopicker/res/values-zh-rTW/feature_search_strings.xml b/photopicker/res/values-zh-rTW/feature_search_strings.xml
index c9d5b2cc6..373ff67bd 100644
--- a/photopicker/res/values-zh-rTW/feature_search_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">""</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"\n\n"</string>
 </resources>
diff --git a/photopicker/res/values-zu/feature_category_grid_strings.xml b/photopicker/res/values-zu/feature_category_grid_strings.xml
new file mode 100644
index 000000000..3f4eee13a
--- /dev/null
+++ b/photopicker/res/values-zu/feature_category_grid_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+   -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="photopicker_categories_nav_button_label" msgid="988315710756227148">"Amaqoqo"</string>
+    <string name="photopicker_people_category_empty_state_title" msgid="3099829676185479658">"Okwamanje abekho abantu nezilwane ezifuywayo"</string>
+    <string name="photopicker_people_category_empty_state_body" msgid="6240429033719283301">"Izithombe namavidiyo, ezihlelwe ngeqembu lobuso obufanayo, zizovela lapha"</string>
+</resources>
diff --git a/photopicker/res/values-zu/feature_preview_strings.xml b/photopicker/res/values-zu/feature_preview_strings.xml
index 29c6581dd..b18d7c9d5 100644
--- a/photopicker/res/values-zu/feature_preview_strings.xml
+++ b/photopicker/res/values-zu/feature_preview_strings.xml
@@ -29,4 +29,5 @@
     <string name="photopicker_video_pause_button_description" msgid="7283388320356598588">"Misa"</string>
     <string name="photopicker_video_mute_button_description" msgid="982357994508317757">"Thulisa Ivolumu"</string>
     <string name="photopicker_video_unmute_button_description" msgid="8194626942498103715">"Susa Ukuthula Kwevolumu"</string>
+    <string name="pohtopicker_horizontal_pager_description" msgid="7701816075322699545">"Ikhasi elingu-<xliff:g id="PAGE_NUMBER">%1$s</xliff:g> kwangu-<xliff:g id="TOTAL_PAGES">%2$s</xliff:g>"</string>
 </resources>
diff --git a/photopicker/res/values-zu/feature_privacy_explainer_strings.xml b/photopicker/res/values-zu/feature_privacy_explainer_strings.xml
index 35224e752..c2979d4a1 100644
--- a/photopicker/res/values-zu/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values-zu/feature_privacy_explainer_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_privacy_explainer" msgid="4607406928962678061">"I-<xliff:g id="APP_NAME">%1$s</xliff:g> izokwazi ukufinyelela kuphela izithombe ozikhethayo"</string>
-    <string name="photopicker_privacy_explainer_permission_mode" msgid="2329456210808751436">"Khetha izithombe namavidiyo avumela i-<xliff:g id="APP_NAME">%1$s</xliff:g> ukuba ifinyelele"</string>
+    <string name="photopicker_privacy_explainer_permission_mode" msgid="6875197264505249268">"Phatha izithombe namavidiyo i-<xliff:g id="APP_NAME">%1$s</xliff:g> enokufinyelela kuwo"</string>
     <string name="photopicker_privacy_explainer_generic_app_name" msgid="765602231395858098">"Le app"</string>
 </resources>
diff --git a/photopicker/res/values-zu/feature_search_strings.xml b/photopicker/res/values-zu/feature_search_strings.xml
index c28fb27bd..a58bb89d1 100644
--- a/photopicker/res/values-zu/feature_search_strings.xml
+++ b/photopicker/res/values-zu/feature_search_strings.xml
@@ -20,8 +20,10 @@
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sesha"</string>
     <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sesha izithombe zakho"</string>
     <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sesha amavidiyo akho"</string>
+    <string name="photopicker_search_clear_text" msgid="864128584605615045">"Sula umbhalo wosesho"</string>
     <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Akunamiphumela etholakele"</string>
     <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Zama ukusesha amagama afanayo"</string>
     <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Iziphakamiso"</string>
     <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Usesho lukhutshaziwe."</string>
+    <string name="photopicker_search_result_empty_state_message" msgid="2834353361038395730">"Zama ukusesha amagama afanayo.\n\nYizinto ezenzelwe ikhophi kuphela ezizovela emiphumeleni yakho yosesho."</string>
 </resources>
diff --git a/photopicker/res/values/feature_category_grid_strings.xml b/photopicker/res/values/feature_category_grid_strings.xml
new file mode 100644
index 000000000..3d8a74c3f
--- /dev/null
+++ b/photopicker/res/values/feature_category_grid_strings.xml
@@ -0,0 +1,26 @@
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- Button label for the category navigation button -->
+    <string name="photopicker_categories_nav_button_label" translation_description="Button label that gives the user the option to navigate to a grid of their collections.">Collections</string>
+
+    <!-- Empty state title when the People & pets Category has no media set to show-->
+    <string name="photopicker_people_category_empty_state_title" translation_description="Title of the message shown to the user when there is nothing to show in People and Pets category">No people &amp; pets yet</string>
+
+    <!-- Empty state message when the People & pet category has no media set to show -->
+    <string name="photopicker_people_category_empty_state_body" translation_description="Message shown to the user when when there are no media set to show in People and Pets category underneath the primary message title">Photos and videos, grouped by similar faces, will appear here</string>
+</resources>
diff --git a/photopicker/res/values/feature_preview_strings.xml b/photopicker/res/values/feature_preview_strings.xml
index 560d68c16..f15d29e37 100644
--- a/photopicker/res/values/feature_preview_strings.xml
+++ b/photopicker/res/values/feature_preview_strings.xml
@@ -52,4 +52,6 @@
   <!-- A11y description for the Unmute button -->
   <string name="photopicker_video_unmute_button_description" translation_description="Accessibility description for a video player volume Unmute button">Unmute Volume</string>
 
+  <!-- A11y description for a page in horizontal pager -->
+  <string name="pohtopicker_horizontal_pager_description" translation_description="Accessibility description for a page in horizontal pager">Page <xliff:g id="page_number" example="1">%1$s</xliff:g> of <xliff:g id="total_pages" example="2">%2$s</xliff:g></string>
 </resources>
diff --git a/photopicker/res/values/feature_privacy_explainer_strings.xml b/photopicker/res/values/feature_privacy_explainer_strings.xml
index 384d03338..c94486af6 100644
--- a/photopicker/res/values/feature_privacy_explainer_strings.xml
+++ b/photopicker/res/values/feature_privacy_explainer_strings.xml
@@ -19,7 +19,7 @@
 	<!-- The standard PRIVACY_EXPLAINER banner message. -->
 	<string name="photopicker_privacy_explainer" translation_description="A privacy banner message that is shown to the user when photopicker is opened by the application"><xliff:g id="app_name" example="Calculator">%1$s</xliff:g> will only have access to the photos you select</string>
 	<!-- The permission mode PRIVACY_EXPLAINER banner message. -->
-	<string name="photopicker_privacy_explainer_permission_mode" translation_description="A privacy banner message that is shown to the user when photopicker is used in permission mode.">Select photos and videos that you allow <xliff:g id="app_name" example="Calendar">%1$s</xliff:g> to access</string>
+	<string name="photopicker_privacy_explainer_permission_mode" translation_description="A privacy banner message that is shown to the user when photopicker is used in permission mode.">Manage photos and videos <xliff:g id="app_name" example="Calendar">%1$s</xliff:g> has access to</string>
 
 	<!-- A Generic app name if callingPackageLabel can't be determined at runtime. -->
 	<string name="photopicker_privacy_explainer_generic_app_name" translation_description="A generic identifier of an application that is used in place of the Apps name if one is not defined or can not be fetched.">This app</string>
diff --git a/photopicker/res/values/feature_search_strings.xml b/photopicker/res/values/feature_search_strings.xml
index 09fde82ae..dacf372f7 100644
--- a/photopicker/res/values/feature_search_strings.xml
+++ b/photopicker/res/values/feature_search_strings.xml
@@ -24,6 +24,9 @@
     <!-- Search view placeholder text when videos MIME type filter is applied-->
     <string name="photopicker_search_videos_placeholder_text" translation_description="Place holder text shown in Search Bar for videos MIME type filter">Search your videos</string>
 
+    <!-- Search Bar trailing icon description text-->
+    <string name="photopicker_search_clear_text" translation_description="Description for trailing icon to clear search text in Search Bar">Clear search text</string>
+
     <!-- Empty state title when the search has no results -->
     <string name="photopicker_search_result_empty_state_title" translation_description="Title of the message shown to the user when there are no search results to show">No results found</string>
 
@@ -35,4 +38,7 @@
 
     <!-- Search disabled hint message -->
     <string name="photopicker_search_disabled_hint" translation_description="Hint message shown on search bar click when search state is not enabled">Search disabled.</string>
+
+    <!-- Empty state search message to show for search when cloud search has no results -->
+    <string name="photopicker_search_result_empty_state_message" translation_description="Message shown to the user when no search results are able to be shown underneath the primary message title informing only backed up items will be shown in search results">Try searching for similar words.\n\nOnly items that are backed up will appear in your search results.</string>
 </resources>
diff --git a/photopicker/src/com/android/photopicker/MainActivity.kt b/photopicker/src/com/android/photopicker/MainActivity.kt
index 0d35f0c50..8b148df60 100644
--- a/photopicker/src/com/android/photopicker/MainActivity.kt
+++ b/photopicker/src/com/android/photopicker/MainActivity.kt
@@ -56,6 +56,7 @@ import com.android.photopicker.core.events.Telemetry
 import com.android.photopicker.core.events.dispatchReportPhotopickerApiInfoEvent
 import com.android.photopicker.core.events.dispatchReportPhotopickerMediaItemStatusEvent
 import com.android.photopicker.core.events.dispatchReportPhotopickerSessionInfoEvent
+import com.android.photopicker.core.events.dispatchReportPickerAppMediaCapabilities
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.selection.GrantsAwareSelectionImpl
@@ -287,6 +288,13 @@ class MainActivity : Hilt_MainActivity() {
             lazyEvents = events,
             photopickerConfiguration = configurationManager.configuration.value,
             pickerIntentAction = intentAction,
+            lazyFeatureManager = featureManager,
+        )
+
+        dispatchReportPickerAppMediaCapabilities(
+                coroutineScope = lifecycleScope,
+                lazyEvents = events,
+                photopickerConfiguration = configurationManager.configuration.value,
         )
     }
 
diff --git a/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt b/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt
index 881270e34..72ba4179b 100644
--- a/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt
+++ b/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt
@@ -29,12 +29,11 @@ import androidx.compose.foundation.layout.PaddingValues
 import androidx.compose.foundation.layout.WindowInsets
 import androidx.compose.foundation.layout.WindowInsetsSides
 import androidx.compose.foundation.layout.fillMaxHeight
-import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.offset
 import androidx.compose.foundation.layout.only
 import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.statusBars
+import androidx.compose.foundation.layout.systemBars
 import androidx.compose.foundation.layout.windowInsetsPadding
 import androidx.compose.material3.BottomSheetScaffold
 import androidx.compose.material3.ExperimentalMaterial3Api
@@ -52,6 +51,7 @@ import androidx.compose.runtime.rememberCoroutineScope
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.input.pointer.PointerEventPass
 import androidx.compose.ui.platform.LocalConfiguration
 import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.dp
@@ -186,7 +186,7 @@ fun PhotopickerAppWithBottomSheet(
                 // Apply WindowInsets to this wrapping column to prevent the Bottom Sheet
                 // from drawing over the status bars.
                 Modifier.windowInsetsPadding(
-                    WindowInsets.statusBars.only(WindowInsetsSides.Vertical)
+                    WindowInsets.systemBars.only(WindowInsetsSides.Vertical)
                 )
         ) {
             BottomSheetScaffold(
@@ -327,7 +327,18 @@ fun PhotopickerMain(disruptiveDataNotification: Flow<Int>, onSearchBarClicked: (
         LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
     val isExpanded = LocalEmbeddedState.current?.isExpanded ?: false
     val host = LocalEmbeddedState.current?.host
-    Box(modifier = Modifier.fillMaxSize()) {
+    Box(
+        modifier =
+            if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                // Transfer touch gestures to host in embedded in the [PointerEventPass.Final] pass.
+                // This will ensure that if no UI elements in Photopicker can consume the touch
+                // gesture, then the touch gesture will automatically be transferred to the host.
+                Modifier.fillMaxWidth()
+                    .transferTouchesToHostInEmbedded(host = host, pass = PointerEventPass.Final)
+            } else {
+                Modifier.fillMaxWidth()
+            }
+    ) {
         Column {
             // The navigation bar and banners are drawn above the navigation graph
             hideWhenState(
@@ -341,12 +352,7 @@ fun PhotopickerMain(disruptiveDataNotification: Flow<Int>, onSearchBarClicked: (
                 LocalFeatureManager.current.composeLocation(
                     Location.NAVIGATION_BAR,
                     maxSlots = 1,
-                    modifier =
-                        if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
-                            Modifier.fillMaxWidth().transferTouchesToHostInEmbedded(host = host)
-                        } else {
-                            Modifier.fillMaxWidth()
-                        },
+                    modifier = Modifier.fillMaxWidth(),
                     params = LocationParams.WithClickAction { onSearchBarClicked() },
                 )
             }
diff --git a/photopicker/src/com/android/photopicker/core/banners/BannerDefinitions.kt b/photopicker/src/com/android/photopicker/core/banners/BannerDefinitions.kt
index ef2976a8e..dd35ffd81 100644
--- a/photopicker/src/com/android/photopicker/core/banners/BannerDefinitions.kt
+++ b/photopicker/src/com/android/photopicker/core/banners/BannerDefinitions.kt
@@ -32,7 +32,7 @@ package com.android.photopicker.core.banners
  */
 enum class BannerDefinitions(
     override val id: String,
-    override val dismissableStrategy: DismissStrategy
+    override val dismissableStrategy: DismissStrategy,
 ) : BannerDeclaration {
 
     // keep-sorted start
@@ -41,7 +41,7 @@ enum class BannerDefinitions(
     CLOUD_MEDIA_AVAILABLE("cloud_media_available", DismissStrategy.ONCE),
     CLOUD_UPDATED_ACCOUNT("cloud_updated_account", DismissStrategy.ONCE),
     PRIVACY_EXPLAINER("privacy_explainer", DismissStrategy.PER_UID),
-    SWITCH_PROFILE("switch_profile", DismissStrategy.SESSION);
+    SWITCH_PROFILE("switch_profile", DismissStrategy.PER_UID);
 
     // keep-sorted end
 
diff --git a/photopicker/src/com/android/photopicker/core/banners/BannerManager.kt b/photopicker/src/com/android/photopicker/core/banners/BannerManager.kt
index 69fb9874c..e1cb4c826 100644
--- a/photopicker/src/com/android/photopicker/core/banners/BannerManager.kt
+++ b/photopicker/src/com/android/photopicker/core/banners/BannerManager.kt
@@ -21,11 +21,11 @@ import kotlinx.coroutines.flow.StateFlow
 /**
  * The [BannerManager] is responsible for managing the global state of banners across various
  * Photopicker activities, recalling that state, and providing a [Banner] implementation to the
- * compose UI for each banner declared in [BannerDefinition].
+ * compose UI for each banner declared in [BannerDeclaration].
  *
  * Banners must be declared in a [PhotopickerUiFeature] and the implementation is provided by the
  * owning feature. BannerManager coordinates the implementation with each active feature at runtime,
- * and provides access to the persisted [BannerState] for each [BannerDefinition] in the current
+ * and provides access to the persisted [BannerState] for each [BannerDeclaration] in the current
  * [PhotopickerConfiguration] context. Individual features fully control their respective banner's
  * implementation, and display priority. BannerManager just provides persisted state and
  * orchestrates / enforces the correct call structure to generate banners during runtime.
@@ -33,7 +33,7 @@ import kotlinx.coroutines.flow.StateFlow
  * Additionally, a set of APIs to show, hide and mark banners as dismissed in the persisted state
  * are available for use. Individual [BannerState] can also be set and retrieved.
  *
- * @see [Banner] and [BannerDefinition] for implementing banners.
+ * @see [Banner] and [BannerDeclaration] for implementing banners.
  * @see [PhotopickerUiFeature] for adding a banner to a feature's registration.
  */
 interface BannerManager {
@@ -42,13 +42,13 @@ interface BannerManager {
     val flow: StateFlow<Banner?>
 
     /**
-     * Set the currently shown banner to a banner which implements the provided [BannerDefinition]
+     * Set the currently shown banner to a banner which implements the provided [BannerDeclaration]
      *
-     * This method will attempt to locate a factory for the provided [BannerDefinition]
+     * This method will attempt to locate a factory for the provided [BannerDeclaration]
      *
-     * @param banner The [BannerDefinition] to build.
+     * @param banner The [BannerDeclaration] to build.
      */
-    suspend fun showBanner(banner: BannerDefinitions)
+    suspend fun showBanner(banner: BannerDeclaration)
 
     /**
      * Immediately hides any shown banners.
@@ -58,15 +58,15 @@ interface BannerManager {
     fun hideBanners()
 
     /**
-     * Mark the [BannerDefinition] as dismissed in the current runtime context.
+     * Mark the [BannerDeclaration] as dismissed in the current runtime context.
      *
-     * This will be handled differently based on the [BannerDefinition.DismissStrategy] of the
-     * provided BannerDefinition. If the [BannerDefinition.dismissable] is FALSE, this has no effect
-     * on internal [BannerState].
+     * This will be handled differently based on the [BannerDeclaration.DismissStrategy] of the
+     * provided BannerDeclaration. If the [BannerDeclaration.dismissable] is FALSE, this has no
+     * effect on internal [BannerState].
      *
-     * @param banner The BannerDefinition to mark as dismissed.
+     * @param banner The BannerDeclaration to mark as dismissed.
      */
-    suspend fun markBannerAsDismissed(banner: BannerDefinitions)
+    suspend fun markBannerAsDismissed(banner: BannerDeclaration)
 
     /**
      * Refresh the current banner state by evaluating all enabled banners again. The banner with the
@@ -74,22 +74,22 @@ interface BannerManager {
      * are ignored. This method is time-limited, but can result in external data calls depending on
      * the enabled banners implementation.
      *
-     * If no BannerDefinition has a valid priority, this method clears the existing banner.
+     * If no BannerDeclaration has a valid priority, this method clears the existing banner.
      */
     suspend fun refreshBanners()
 
     /**
-     * Retrieve the persisted [BannerState] for the requested [BannerDefinition].
+     * Retrieve the persisted [BannerState] for the requested [BannerDeclaration].
      *
      * Note: This will only return a [BannerState] that matches the current
      * [PhotopickerConfiguration] constraints, specifically the callingPackageUid in the case of
-     * banners that are using the [BannerDefinition.DismissStrategy.PER_UID].
+     * banners that are using the [BannerDeclaration.DismissStrategy.PER_UID].
      *
-     * @return The persisted [BannerState] for the [BannerDefinition] in the current runtime
+     * @return The persisted [BannerState] for the [BannerDeclaration] in the current runtime
      *   context. This returns null when there is no persisted [BannerState] for the current runtime
      *   context.
      */
-    suspend fun getBannerState(banner: BannerDefinitions): BannerState?
+    suspend fun getBannerState(banner: BannerDeclaration): BannerState?
 
     /**
      * Persists a [BannerState] to be retrieved later. This persistence out lives any individual
diff --git a/photopicker/src/com/android/photopicker/core/banners/BannerManagerImpl.kt b/photopicker/src/com/android/photopicker/core/banners/BannerManagerImpl.kt
index df2fe76f3..00a512382 100644
--- a/photopicker/src/com/android/photopicker/core/banners/BannerManagerImpl.kt
+++ b/photopicker/src/com/android/photopicker/core/banners/BannerManagerImpl.kt
@@ -47,7 +47,7 @@ class BannerManagerImpl(
     private val featureManager: FeatureManager,
     private val dataService: DataService,
     private val userMonitor: UserMonitor,
-    private val processOwnerHandle: UserHandle
+    private val processOwnerHandle: UserHandle,
 ) : BannerManager {
 
     companion object {
@@ -62,7 +62,7 @@ class BannerManagerImpl(
      * Keeps track of any banners with [DismissStrategy.SESSION] that were dismissed during the
      * current Photopicker session.
      */
-    private val bannersDismissedInSession: MutableSet<BannerDefinitions> = mutableSetOf()
+    private val bannersDismissedInSession: MutableSet<BannerDeclaration> = mutableSetOf()
 
     init {
         // Observe Profile switches and always force banner refresh when the
@@ -82,7 +82,7 @@ class BannerManagerImpl(
      * Unless a specific banner is needed, it is better to use [refreshBanners] to allow the banner
      * with the highest priority to be shown.
      */
-    override suspend fun showBanner(banner: BannerDefinitions) {
+    override suspend fun showBanner(banner: BannerDeclaration) {
         try {
             _flow.updateAndGet { generateBanner(banner) }
         } catch (ex: RuntimeException) {
@@ -99,7 +99,7 @@ class BannerManagerImpl(
     }
 
     /** Attempt to mark the banner as dismissed in current context. */
-    override suspend fun markBannerAsDismissed(banner: BannerDefinitions) {
+    override suspend fun markBannerAsDismissed(banner: BannerDeclaration) {
 
         if (banner.dismissable) {
 
@@ -124,7 +124,7 @@ class BannerManagerImpl(
                                         Log.w(
                                             TAG,
                                             "Cannot mark ${banner.id} as dismissed for UID," +
-                                                " no UID present in configuration."
+                                                " no UID present in configuration.",
                                         )
                                         return@markBannerAsDismissed
                                     }
@@ -137,14 +137,14 @@ class BannerManagerImpl(
                                 return@markBannerAsDismissed
                             }
                         },
-                    dismissed = true
+                    dismissed = true,
                 )
             )
         }
     }
 
     /** Retrieve the requested banner state from the database */
-    override suspend fun getBannerState(banner: BannerDefinitions): BannerState? {
+    override suspend fun getBannerState(banner: BannerDeclaration): BannerState? {
 
         // No need to check the database if the banner cannot be dismissed.
         if (banner.dismissableStrategy == DismissStrategy.NONE) {
@@ -177,13 +177,14 @@ class BannerManagerImpl(
                                     }
                                 DismissStrategy.ONCE -> 0
                                 else -> 0
-                            }
+                            },
                     )
             } catch (ex: IllegalStateException) {
                 Log.w(
+                    TAG,
                     "Attempted to retrieve a PER_UID banner state and no uid was present in the" +
                         " configuration.",
-                    ex
+                    ex,
                 )
                 null
             }
@@ -209,7 +210,7 @@ class BannerManagerImpl(
         ) {
             Log.d(
                 TAG,
-                "User profile has been changed and is no longer owner, banners will be cleared."
+                "User profile has been changed and is no longer owner, banners will be cleared.",
             )
             _flow.updateAndGet { null }
             return
@@ -220,9 +221,9 @@ class BannerManagerImpl(
 
             // Acquire all possible active banners and their relative priority from
             // the enabled ui features.
-            val allAvailableBanners: MutableList<Pair<BannerDefinitions, Int>> =
+            val allAvailableBanners: MutableList<Pair<BannerDeclaration, Int>> =
                 featureManager.enabledUiFeatures
-                    // FlatMap from List<List<Pair<PhotopickerUiFeature,BannerDefinition>>> to a
+                    // FlatMap from List<List<Pair<PhotopickerUiFeature,BannerDeclaration>>> to a
                     // single Iterable list so the work can be run in parallel in the next step.
                     .flatMap { feature -> feature.ownedBanners.map { Pair(feature, it) } }
                     // Use [pmap] to launch these in parallel, so each banner checked
@@ -273,18 +274,24 @@ class BannerManagerImpl(
     }
 
     /**
-     * Locates the [PhotopickerUiFeature] responsible for building the [BannerDefinition] and calls
+     * Locates the [PhotopickerUiFeature] responsible for building the [BannerDeclaration] and calls
      * the factory builder.
      *
-     * @param [BannerDefinition] to acquire an implementation for.
-     * @return a [Banner] implementation for the provided [BannerDefinition]
+     * @param [BannerDeclaration] to acquire an implementation for.
+     * @return a [Banner] implementation for the provided [BannerDeclaration]
      */
-    private suspend fun generateBanner(banner: BannerDefinitions): Banner {
+    private suspend fun generateBanner(banner: BannerDeclaration): Banner {
         val feature: PhotopickerUiFeature? =
             featureManager.enabledUiFeatures
                 .filter { it.ownedBanners.contains(banner) }
                 .firstOrNull()
         checkNotNull(feature) { "Could not find an enabled builder for $banner" }
-        return feature.buildBanner(banner, dataService, userMonitor)
+        return feature.buildBanner(
+            checkNotNull(banner as? BannerDefinitions) {
+                "Could not cast declaration to valid banner definition"
+            },
+            dataService,
+            userMonitor,
+        )
     }
 }
diff --git a/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt b/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt
index c3a94ba88..57112daa2 100644
--- a/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt
+++ b/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt
@@ -31,6 +31,7 @@ import androidx.compose.animation.scaleIn
 import androidx.compose.animation.scaleOut
 import androidx.compose.foundation.background
 import androidx.compose.foundation.border
+import androidx.compose.foundation.focusable
 import androidx.compose.foundation.gestures.animateScrollBy
 import androidx.compose.foundation.gestures.detectTapGestures
 import androidx.compose.foundation.layout.Arrangement
@@ -75,6 +76,8 @@ import androidx.compose.ui.AbsoluteAlignment
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.draw.clip
+import androidx.compose.ui.focus.FocusRequester
+import androidx.compose.ui.focus.focusRequester
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.vector.ImageVector
 import androidx.compose.ui.input.pointer.pointerInput
@@ -100,20 +103,23 @@ import com.android.photopicker.core.components.MediaGridItem.Companion.defaultBu
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
 import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
 import com.android.photopicker.core.embedded.LocalEmbeddedState
+import com.android.photopicker.core.glide.ParcelableGlideLoadable
 import com.android.photopicker.core.glide.Resolution
 import com.android.photopicker.core.glide.loadMedia
 import com.android.photopicker.core.theme.CustomAccentColorScheme
+import com.android.photopicker.data.model.CategoryType
 import com.android.photopicker.data.model.Group.Album
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.circleBackground
 import com.android.photopicker.extensions.insertMonthSeparators
 import com.android.photopicker.extensions.toMediaGridItemFromAlbum
 import com.android.photopicker.extensions.toMediaGridItemFromMedia
-import com.android.photopicker.extensions.transferGridTouchesToHostInEmbedded
+import com.android.photopicker.extensions.transferScrollableTouchesToHostInEmbedded
 import com.android.photopicker.util.LocalLocalizationHelper
 import com.android.photopicker.util.getMediaContentDescription
 import java.text.DateFormat
 import java.text.NumberFormat
+import kotlinx.coroutines.delay
 
 /** The number of grid cells per row for Phone / narrow layouts */
 private val CELLS_PER_ROW: Int = 3
@@ -181,6 +187,7 @@ val MEASUREMENT_DEFAULT_ALBUM_LABEL_SPACER_SIZE = 12.dp
  *
  * @param items The LazyPagingItems that have been collected. See [collectAsLazyPagingItems] to
  *   transform a PagingData flow into the correct format for this composable.
+ * @param focusItem Optional item that needs to request focus when the media grid is drawn.
  * @param isExpandedScreen Whether the device is using an expanded screen size. This impacts the
  *   default number of cells shown per row. Has no effect if columns parameter is set directly.
  * @param columns number of cells per row.
@@ -195,10 +202,12 @@ val MEASUREMENT_DEFAULT_ALBUM_LABEL_SPACER_SIZE = 12.dp
  * @param contentItemFactory Optional custom implementation for composing individual grid items.
  * @param contentSeparatorFactory Optional custom implementation for composing individual grid
  *   separators.
+ * @param bannerContent Optional custom implementation for banner content to displayed
  */
 @Composable
 fun mediaGrid(
     items: LazyPagingItems<MediaGridItem>,
+    focusItem: MediaGridItem? = null,
     selection: Set<Media>,
     onItemClick: (item: MediaGridItem) -> Unit,
     onItemLongPress: (item: MediaGridItem) -> Unit = {},
@@ -231,9 +240,13 @@ fun mediaGrid(
                         onClick = onClick,
                         onLongPress = onLongPress,
                         dateFormat = dateFormat,
+                        focusItem = focusItem,
                     )
 
-                is MediaGridItem.AlbumItem -> defaultBuildAlbumItem(item, onClick)
+                is MediaGridItem.AlbumItem -> defaultBuildAlbumItem(item, onClick, focusItem)
+                is MediaGridItem.CategoryItem -> defaultBuildCategoryItem(item, onClick, focusItem)
+                is MediaGridItem.PersonMediaSetItem -> defaultBuildPersonMediaSetItem(item, onClick)
+                is MediaGridItem.MediaSetItem -> defaultBuildMediaSetItem(item, onClick)
                 else -> {}
             }
         },
@@ -261,7 +274,7 @@ fun mediaGrid(
         columns = columns,
         modifier =
             if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
-                modifier.transferGridTouchesToHostInEmbedded(state, isExpanded, host)
+                modifier.transferScrollableTouchesToHostInEmbedded(state, isExpanded, host)
             } else {
                 modifier
             },
@@ -304,7 +317,10 @@ fun mediaGrid(
                             dateFormat,
                         )
 
-                    is MediaGridItem.AlbumItem ->
+                    is MediaGridItem.AlbumItem,
+                    is MediaGridItem.CategoryItem,
+                    is MediaGridItem.MediaSetItem,
+                    is MediaGridItem.PersonMediaSetItem ->
                         contentItemFactory(
                             item,
                             /* isSelected */ false,
@@ -312,7 +328,6 @@ fun mediaGrid(
                             onItemLongPress,
                             dateFormat,
                         )
-
                     is MediaGridItem.SeparatorItem -> contentSeparatorFactory(item)
                 }
             }
@@ -374,6 +389,7 @@ private fun defaultBuildMediaItem(
     onClick: ((item: MediaGridItem) -> Unit)?,
     onLongPress: ((item: MediaGridItem) -> Unit)?,
     dateFormat: DateFormat,
+    focusItem: MediaGridItem?,
 ) {
     when (item) {
         is MediaGridItem.MediaItem -> {
@@ -393,7 +409,20 @@ private fun defaultBuildMediaItem(
                 )
 
             // Modifier for the image itself, which uses the animated padding defined above.
-            val baseModifier = Modifier.fillMaxSize().padding(padding)
+            var baseModifier = Modifier.fillMaxSize().padding(padding)
+
+            // If the caller has specified an item to receive focus,
+            // apply the focus requester modifier to it.
+            if (focusItem != null) {
+                val focusRequester = remember { FocusRequester() }
+                baseModifier = baseModifier.focusRequester(focusRequester).focusable(true)
+                LaunchedEffect(Unit) {
+                    if (item == focusItem) {
+                        delay(150)
+                        focusRequester.requestFocus()
+                    }
+                }
+            }
 
             // Additionally, selected items get rounded corners, so that is added to the
             // baseModifier
@@ -609,12 +638,15 @@ private fun SelectedIconOverlay(isSelected: Boolean, selectedIndex: Int) {
  * GridCell, and provides a text title for it just below the thumbnail.
  */
 @Composable
-private fun defaultBuildAlbumItem(item: MediaGridItem, onClick: ((item: MediaGridItem) -> Unit)?) {
+private fun defaultBuildAlbumItem(
+    item: MediaGridItem,
+    onClick: ((item: MediaGridItem) -> Unit)?,
+    focusItem: MediaGridItem? = null,
+) {
     when (item) {
         is MediaGridItem.AlbumItem -> {
-
-            Column(
-                // Apply semantics for the click handlers
+            // Apply semantics for the click handlers
+            var baseModifier =
                 Modifier.semantics(mergeDescendants = true) {
                         onClick(
                             action = {
@@ -625,7 +657,21 @@ private fun defaultBuildAlbumItem(item: MediaGridItem, onClick: ((item: MediaGri
                     }
                     .pointerInput(Unit) { detectTapGestures(onTap = { onClick?.invoke(item) }) }
                     .padding(bottom = MEASUREMENT_DEFAULT_ALBUM_BOTTOM_PADDING)
-            ) {
+
+            // If the caller has specified an item to receive focus,
+            // apply the focus requester modifier to it.
+            if (focusItem != null) {
+                val focusRequester = remember { FocusRequester() }
+                baseModifier = baseModifier.focusRequester(focusRequester).focusable(true)
+                LaunchedEffect(Unit) {
+                    if (item == focusItem) {
+                        delay(150)
+                        focusRequester.requestFocus()
+                    }
+                }
+            }
+
+            Column(modifier = baseModifier) {
                 // In the current implementation for AlbumsGrid, favourites and videos are
                 // 2 mandatory albums and are shown even when they contain no data. For this
                 // case they have special thumbnails associated with them.
@@ -669,11 +715,236 @@ private fun defaultBuildAlbumItem(item: MediaGridItem, onClick: ((item: MediaGri
                 )
             } // Album cell column
         }
-
         else -> {}
     }
 }
 
+/** Default [MediaGridItem.PersonMediaSetItem] builder that loads People and pets mediaset. */
+@Composable
+private fun defaultBuildPersonMediaSetItem(
+    item: MediaGridItem.PersonMediaSetItem,
+    onClick: ((item: MediaGridItem) -> Unit)?,
+) {
+    Box(
+        // Apply semantics for the click handlers
+        Modifier.semantics(mergeDescendants = true) {
+                contentDescription = item.mediaSet.displayName ?: ""
+                onClick(
+                    action = {
+                        onClick?.invoke(item)
+                        /* eventHandled= */ true
+                    }
+                )
+            }
+            .pointerInput(Unit) { detectTapGestures(onTap = { onClick?.invoke(item) }) }
+    ) {
+        with(item.mediaSet) {
+            val modifier = Modifier.fillMaxWidth().aspectRatio(1f)
+            loadMedia(media = icon, resolution = Resolution.THUMBNAIL, modifier = modifier)
+            Surface(color = Color.Black.copy(alpha = 0.2f), contentColor = Color.White) {
+                Box(modifier = modifier) {
+                    Text(
+                        text = displayName ?: "",
+                        overflow = TextOverflow.Ellipsis,
+                        maxLines = 1,
+                        style = MaterialTheme.typography.labelLarge,
+                        modifier = Modifier.align(Alignment.BottomCenter).padding(8.dp),
+                    )
+                }
+            }
+        }
+    }
+}
+
+/** Default [MediaGridItem.MediaSetItem] builder that loads mediaset. */
+@Composable
+private fun defaultBuildMediaSetItem(
+    item: MediaGridItem.MediaSetItem,
+    onClick: ((item: MediaGridItem) -> Unit)?,
+) {
+    Column(
+        // Apply semantics for the click handlers
+        Modifier.semantics(mergeDescendants = true) {
+                contentDescription = item.mediaSet.displayName ?: ""
+                onClick(
+                    action = {
+                        onClick?.invoke(item)
+                        /* eventHandled= */ true
+                    }
+                )
+            }
+            .pointerInput(Unit) { detectTapGestures(onTap = { onClick?.invoke(item) }) }
+            .padding(bottom = MEASUREMENT_DEFAULT_ALBUM_BOTTOM_PADDING)
+    ) {
+        with(item.mediaSet) {
+            val modifier =
+                Modifier.fillMaxWidth()
+                    .clip(RoundedCornerShape(MEASUREMENT_SELECTED_CORNER_RADIUS_FOR_ALBUMS))
+                    .aspectRatio(1f)
+            DefaultAlbumIcon(/* icon */ Icons.Outlined.PhotoCamera, modifier)
+            Spacer(Modifier.size(MEASUREMENT_DEFAULT_ALBUM_LABEL_SPACER_SIZE))
+            // Media set title shown on the media set grid.
+            Text(
+                text = displayName ?: "",
+                overflow = TextOverflow.Ellipsis,
+                maxLines = 1,
+                style = MaterialTheme.typography.labelLarge,
+                color = MaterialTheme.colorScheme.onSurface,
+            )
+        }
+    }
+}
+
+/**
+ * Default [MediaGridItem.CategoryItem] builder that loads category into a square (1:1) aspect ratio
+ * GridCell with icons in square grid and provides a text title below it.
+ */
+@Composable
+private fun defaultBuildCategoryItem(
+    item: MediaGridItem.CategoryItem,
+    onClick: ((item: MediaGridItem) -> Unit)?,
+    focusItem: MediaGridItem?,
+) {
+    // Apply semantics for the click handlers
+    var baseModifier =
+        Modifier.semantics(mergeDescendants = true) {
+                contentDescription = item.category.displayName ?: ""
+                onClick(
+                    action = {
+                        onClick?.invoke(item)
+                        /* eventHandled */ true
+                    }
+                )
+            }
+            .pointerInput(Unit) { detectTapGestures(onTap = { onClick?.invoke(item) }) }
+            .padding(bottom = MEASUREMENT_DEFAULT_ALBUM_BOTTOM_PADDING)
+
+    // If the caller has specified an item to receive focus,
+    // apply the focus requester modifier to it.
+    if (focusItem != null) {
+        val focusRequester = remember { FocusRequester() }
+        baseModifier = baseModifier.focusRequester(focusRequester).focusable(true)
+        LaunchedEffect(Unit) {
+            if (item == focusItem) {
+                delay(150)
+                focusRequester.requestFocus()
+            }
+        }
+    }
+
+    Column(modifier = baseModifier) {
+        with(item.category) {
+            val modifier =
+                Modifier.fillMaxWidth()
+                    .clip(RoundedCornerShape(MEASUREMENT_SELECTED_CORNER_RADIUS_FOR_ALBUMS))
+                    .aspectRatio(1f)
+            IconGrid(icons, modifier = modifier, categoryType)
+            Spacer(Modifier.size(MEASUREMENT_DEFAULT_ALBUM_LABEL_SPACER_SIZE))
+            // Category title shown below the category grid.
+            Text(
+                text = displayName ?: "",
+                overflow = TextOverflow.Ellipsis,
+                maxLines = 1,
+                style = MaterialTheme.typography.labelLarge,
+                color = MaterialTheme.colorScheme.onSurface,
+            )
+        }
+    }
+}
+
+@Composable
+fun IconGrid(
+    icons: List<ParcelableGlideLoadable>,
+    modifier: Modifier,
+    categoryType: CategoryType,
+    maxIcon: Int = 4,
+    iconPerRow: Int = 2,
+) {
+    Surface(modifier = modifier, color = MaterialTheme.colorScheme.surfaceContainerHighest) {
+        Column(
+            modifier = Modifier.fillMaxSize().padding(12.dp),
+            horizontalAlignment = Alignment.CenterHorizontally,
+            verticalArrangement = Arrangement.spacedBy(8.dp),
+        ) {
+            // Pad the list to ensure we required icons per row
+            val paddedIcons = (icons + List(maxIcon) { null }).take(maxIcon)
+            val iconsInRow = paddedIcons.chunked(iconPerRow)
+
+            iconsInRow.forEachIndexed { rowIndex, rowItem ->
+                Row(
+                    horizontalArrangement = Arrangement.spacedBy(8.dp),
+                    modifier = Modifier.fillMaxWidth(),
+                ) {
+                    rowItem.forEachIndexed { colIndex, icon ->
+                        Box(modifier = Modifier.weight(1f).aspectRatio(1f)) {
+                            if (icons.isNotEmpty() && icon is ParcelableGlideLoadable) {
+                                CategoryIcon(icon, Modifier.fillMaxSize(), categoryType)
+                            } else {
+                                if (
+                                    icons.isEmpty() &&
+                                        !(rowIndex == iconsInRow.lastIndex &&
+                                            colIndex == rowItem.lastIndex)
+                                ) {
+                                    CategoryIconPlaceholder(Modifier.fillMaxSize(), categoryType)
+                                } else {
+                                    CategoryIconPlaceholder(
+                                        Modifier.fillMaxSize(),
+                                        categoryType,
+                                        false,
+                                    )
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+@Composable
+fun CategoryIconPlaceholder(
+    modifier: Modifier,
+    categoryType: CategoryType,
+    showPlaceholder: Boolean = true,
+) {
+    Box(
+        modifier =
+            if (categoryType == CategoryType.PEOPLE_AND_PETS) {
+                when (showPlaceholder) {
+                    true ->
+                        modifier
+                            .size(48.dp)
+                            .clip(CircleShape)
+                            .background(MaterialTheme.colorScheme.surfaceContainer)
+                    false -> modifier.size(48.dp)
+                }
+            } else {
+                modifier
+                    .size(48.dp)
+                    .clip(RoundedCornerShape(MEASUREMENT_SELECTED_CORNER_RADIUS_FOR_ALBUMS))
+                    .background(MaterialTheme.colorScheme.surface)
+            }
+    )
+}
+
+@Composable
+fun CategoryIcon(icon: ParcelableGlideLoadable, modifier: Modifier, categoryType: CategoryType) {
+    loadMedia(
+        media = icon,
+        resolution = Resolution.THUMBNAIL,
+        modifier =
+            if (categoryType == CategoryType.PEOPLE_AND_PETS) {
+                modifier.size(48.dp).clip(CircleShape).background(MaterialTheme.colorScheme.surface)
+            } else {
+                modifier
+                    .size(48.dp)
+                    .clip(RoundedCornerShape(MEASUREMENT_SELECTED_CORNER_RADIUS_FOR_ALBUMS))
+                    .background(MaterialTheme.colorScheme.surface)
+            },
+    )
+}
+
 /**
  * Default [MediaGridItem.SeparatorItem] that creates a full width divider using the provided text
  * label.
diff --git a/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGridItem.kt b/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGridItem.kt
index 8b4ee5947..3d9a5dd09 100644
--- a/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGridItem.kt
+++ b/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGridItem.kt
@@ -17,6 +17,8 @@
 package com.android.photopicker.core.components
 
 import com.android.photopicker.data.model.Group.Album
+import com.android.photopicker.data.model.Group.Category
+import com.android.photopicker.data.model.Group.MediaSet
 import com.android.photopicker.data.model.Media
 
 /**
@@ -40,16 +42,34 @@ sealed class MediaGridItem {
     data class AlbumItem(val album: Album) : MediaGridItem()
 
     /**
-     * Represents a separator in the [MediaGrid]. (Such as a month separator.)
+     * Represents a [CategoryItem] in the [MediaGrid].
      *
-     * @property label A label that can be used to represent this separator in the UI.
+     * @property mediaCategory The media category that this item represents.
      */
-    data class SeparatorItem(val label: String) : MediaGridItem()
+    data class CategoryItem(val category: Category) : MediaGridItem()
 
+    /**
+     * Represents a [MediaSet] for People and Pets media category in the [MediaGrid].
+     *
+     * @property mediaSet The media set that this item represents.
+     */
+    data class PersonMediaSetItem(val mediaSet: MediaSet) : MediaGridItem()
 
     /**
-     * Handles operations that requires customized output based on the type of [MediaGridItem].
+     * Represents a [MediaSet] for all categories other than People and Pets in the [MediaGrid].
+     *
+     * @property mediaSet The media set that this item represents.
      */
+    data class MediaSetItem(val mediaSet: MediaSet) : MediaGridItem()
+
+    /**
+     * Represents a separator in the [MediaGrid]. (Such as a month separator.)
+     *
+     * @property label A label that can be used to represent this separator in the UI.
+     */
+    data class SeparatorItem(val label: String) : MediaGridItem()
+
+    /** Handles operations that requires customized output based on the type of [MediaGridItem]. */
     companion object {
         /**
          * Assembles a key for a [MediaGridItem]. This key must be always be stable and unique in
@@ -62,6 +82,9 @@ sealed class MediaGridItem {
                 is MediaItem -> "${item.media.pickerId}"
                 is SeparatorItem -> "${item.label}_$index"
                 is AlbumItem -> "${item.album.pickerId}" // check if this should be id or pickerId
+                is CategoryItem -> "${item.category.pickerId}"
+                is PersonMediaSetItem -> "${item.mediaSet.pickerId}"
+                is MediaSetItem -> "${item.mediaSet.pickerId}"
                 null -> "$index"
             }
         }
@@ -80,6 +103,9 @@ sealed class MediaGridItem {
                 is MediaItem -> 1
                 is SeparatorItem -> 2
                 is AlbumItem -> 3
+                is CategoryItem -> 4
+                is PersonMediaSetItem -> 5
+                is MediaSetItem -> 6
                 null -> 0
             }
         }
diff --git a/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt b/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt
index 5054f17c7..d333f4b20 100644
--- a/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt
+++ b/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt
@@ -330,6 +330,7 @@ class ConfigurationManager(
                     /* defaultValue= */ FEATURE_PICKER_CHOICE_MANAGED_SELECTION.second,
                 ),
             PICKER_SEARCH_ENABLED = Flags.enablePhotopickerSearch(),
+            PICKER_DATESCRUBBER_ENABLED = Flags.enablePhotopickerDatescrubber(),
             PICKER_TRANSCODING_ENABLED = Flags.enablePhotopickerTranscoding(),
         )
     }
diff --git a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt
index 2b169311e..4cd6037b8 100644
--- a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt
+++ b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt
@@ -22,6 +22,7 @@ import android.content.pm.ResolveInfo
 import android.media.ApplicationMediaCapabilities
 import android.net.Uri
 import android.os.SystemProperties
+import android.os.UserHandle
 import android.provider.MediaStore
 import android.util.Log
 import com.android.photopicker.core.navigation.PhotopickerDestinations
@@ -88,16 +89,22 @@ data class PhotopickerConfiguration(
 
     /**
      * Use the internal Intent to see if the Intent can be resolved as a
-     * CrossProfileIntentForwarderActivity
+     * CrossProfileIntentForwarderActivity for the target user.
      *
      * This method exists to limit the visibility of the intent field, but [UserMonitor] requires
      * the intent to check for CrossProfileIntentForwarder's. Rather than exposing intent as a
      * public field, this method can be called to do the check, if an Intent exists.
      *
+     * @param packageManager the PM of the "from" user
+     * @param targetUserHandle the [UserHandle] of the target user
      * @return Whether the current Intent Photopicker may be running under has a matching
      *   CrossProfileIntentForwarderActivity
      */
-    fun doesCrossProfileIntentForwarderExists(packageManager: PackageManager): Boolean {
+    fun doesCrossProfileIntentForwarderExists(
+        packageManager: PackageManager,
+        fromUserHandle: UserHandle,
+        targetUserHandle: UserHandle,
+    ): Boolean {
 
         val intentToCheck: Intent? =
             when (runtimeEnv) {
@@ -118,12 +125,68 @@ data class PhotopickerConfiguration(
             it.setPackage(null)
 
             for (info: ResolveInfo? in
-                packageManager.queryIntentActivities(it, PackageManager.MATCH_DEFAULT_ONLY)) {
+                packageManager.queryIntentActivitiesAsUser(
+                    it,
+                    PackageManager.MATCH_DEFAULT_ONLY,
+                    fromUserHandle,
+                )) {
                 info?.let {
                     if (it.isCrossProfileIntentForwarderActivity()) {
-                        // This profile can handle cross profile content
-                        // from the current context profile
-                        return true
+
+                        /*
+                         * IMPORTANT: This is a reflection based hack to ensure the profile is actually
+                         * the installer of the CrossProfileIntentForwardingActivity.
+                         *
+                         * ResolveInfo.targetUserId exists, but is a hidden API not available to
+                         * mainline modules, and no such API exists, so it is accessed via reflection
+                         * below. All exceptions are caught to protect against reflection related
+                         * issues such as:
+                         * NoSuchFieldException / IllegalAccessException / SecurityException.
+                         *
+                         * In the event of an exception, the code fails "closed" for the current
+                         * profile to avoid showing content that should not be visible.
+                         */
+                        val activityTargetUserId =
+                            try {
+                                val property =
+                                    it::class.java.getDeclaredField("targetUserId").apply {
+                                        isAccessible = true
+                                    }
+                                property.get(it) as? Int
+                            } catch (e: Exception) {
+                                when (e) {
+                                    is NoSuchFieldException,
+                                    is IllegalAccessException,
+                                    is SecurityException -> {
+                                        Log.e(
+                                            ConfigurationManager.TAG,
+                                            "Could not reflect targetUserId field for cross " +
+                                                "profile checks.",
+                                        )
+                                        // Any time we are unable to obtain the cross profile
+                                        // targetUserId, fail closed by returning false.
+                                        return@doesCrossProfileIntentForwarderExists false
+                                    }
+                                    else -> {
+                                        Log.e(
+                                            ConfigurationManager.TAG,
+                                            "Exception occurred during cross profile checks",
+                                            e,
+                                        )
+                                        null
+                                    }
+                                }
+                            }
+                        if (activityTargetUserId == targetUserHandle.getIdentifier()) {
+                            Log.d(
+                                ConfigurationManager.TAG,
+                                "Found matching CrossProfileIntentForwarderActivity for " +
+                                    "targetUserId ${targetUserHandle.getIdentifier()}",
+                            )
+                            // This profile can handle cross profile content
+                            // from the current context profile
+                            return true
+                        }
                     }
                 }
             }
@@ -134,6 +197,7 @@ data class PhotopickerConfiguration(
                 "No intent available for checking cross-profile access.",
             )
 
+        // Nothing left to check
         return false
     }
 
diff --git a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt
index e28fa83a8..dc5a9aff7 100644
--- a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt
+++ b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt
@@ -45,7 +45,10 @@ data class PhotopickerFlags(
     val PRIVATE_SPACE_ENABLED: Boolean = FEATURE_PRIVATE_SPACE_ENABLED.second,
     val MANAGED_SELECTION_ENABLED: Boolean = FEATURE_PICKER_CHOICE_MANAGED_SELECTION.second,
     val PICKER_SEARCH_ENABLED: Boolean = Flags.enablePhotopickerSearch(),
+    val PICKER_DATESCRUBBER_ENABLED: Boolean = Flags.enablePhotopickerDatescrubber(),
     val PICKER_TRANSCODING_ENABLED: Boolean = Flags.enablePhotopickerTranscoding(),
+    val OWNED_PHOTOS_ENABLED: Boolean = Flags.revokeAccessOwnedPhotos(),
+    val EXPRESSIVE_THEME_ENABLED: Boolean = Flags.enablePhotopickerExpressiveTheme(),
 ) {
     /**
      * Implement a custom equals method to correctly check the equality of the Array member
@@ -60,6 +63,7 @@ data class PhotopickerFlags(
         if (PRIVATE_SPACE_ENABLED != other.PRIVATE_SPACE_ENABLED) return false
         if (MANAGED_SELECTION_ENABLED != other.MANAGED_SELECTION_ENABLED) return false
         if (PICKER_SEARCH_ENABLED != other.PICKER_SEARCH_ENABLED) return false
+        if (PICKER_DATESCRUBBER_ENABLED != other.PICKER_DATESCRUBBER_ENABLED) return false
         if (PICKER_TRANSCODING_ENABLED != other.PICKER_TRANSCODING_ENABLED) return false
 
         return true
@@ -77,6 +81,7 @@ data class PhotopickerFlags(
             PRIVATE_SPACE_ENABLED,
             MANAGED_SELECTION_ENABLED,
             PICKER_SEARCH_ENABLED,
+            PICKER_DATESCRUBBER_ENABLED,
             PICKER_TRANSCODING_ENABLED,
         )
 }
diff --git a/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt b/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt
index 37fa6fa8a..0ecb2e48f 100644
--- a/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt
+++ b/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt
@@ -27,6 +27,8 @@ import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.albumgrid.AlbumGridViewModel
+import com.android.photopicker.features.categorygrid.CategoryGridViewModel
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
 import com.android.photopicker.features.photogrid.PhotoGridViewModel
 import com.android.photopicker.features.preparemedia.MediaPreparerViewModel
 import com.android.photopicker.features.preview.PreviewViewModel
@@ -69,6 +71,7 @@ class EmbeddedViewModelFactory(
     val bannerManager: Lazy<BannerManager>,
     val dataService: Lazy<DataService>,
     val searchDataService: Lazy<SearchDataService>,
+    val categoryDataService: Lazy<CategoryDataService>,
     val events: Lazy<Events>,
     val featureManager: Lazy<FeatureManager>,
     val selection: Lazy<Selection<Media>>,
@@ -122,11 +125,21 @@ class EmbeddedViewModelFactory(
                         null,
                         backgroundDispatcher,
                         searchDataService.get(),
+                        dataService.get(),
                         selection.get(),
                         events.get(),
                         configurationManager.get(),
                     )
                         as T
+                isAssignableFrom(CategoryGridViewModel::class.java) ->
+                    CategoryGridViewModel(
+                        null,
+                        selection.get(),
+                        categoryDataService.get(),
+                        dataService.get(),
+                        events.get(),
+                    )
+                        as T
                 else ->
                     throw IllegalArgumentException(
                         "Unknown ViewModel class: ${modelClass.simpleName}"
diff --git a/photopicker/src/com/android/photopicker/core/embedded/Session.kt b/photopicker/src/com/android/photopicker/core/embedded/Session.kt
index b02da977f..62d1b2a27 100644
--- a/photopicker/src/com/android/photopicker/core/embedded/Session.kt
+++ b/photopicker/src/com/android/photopicker/core/embedded/Session.kt
@@ -30,6 +30,8 @@ import android.widget.photopicker.EmbeddedPhotoPickerFeatureInfo
 import android.widget.photopicker.IEmbeddedPhotoPickerClient
 import android.widget.photopicker.IEmbeddedPhotoPickerSession
 import android.widget.photopicker.ParcelableException
+import android.window.OnBackInvokedCallback
+import android.window.OnBackInvokedDispatcher
 import androidx.activity.compose.LocalOnBackPressedDispatcherOwner
 import androidx.annotation.RequiresApi
 import androidx.compose.runtime.CompositionLocalProvider
@@ -203,8 +205,9 @@ open class Session(
     private val _host: SurfaceControlViewHost
     private val _view: ComposeView
     private val _stateManager: EmbeddedStateManager
+    private val _onBackInvokedCallback: OnBackInvokedCallback
 
-    fun getView() = _view
+    fun getView(): ComposeView = _view
 
     open val surfacePackage: SurfaceControlViewHost.SurfacePackage
         get() {
@@ -266,6 +269,7 @@ open class Session(
         startListeningToTelemetryEvents()
 
         _view = createPhotopickerComposeView(context)
+        _onBackInvokedCallback = setupBackInvokedCallback()
         _host = createSurfaceControlViewHost(context, displayId, hostToken)
         // This initialization should happen only after receiving the [_host]
         _stateManager =
@@ -310,6 +314,9 @@ open class Session(
         // Mark the [EmbeddedLifecycle] associated with the session as destroyed when this class is
         // closed. Block until the call is complete to ensure the lifecycle is marked as destroyed.
         runBlocking(_main) {
+            _view
+                .findOnBackInvokedDispatcher()
+                ?.unregisterOnBackInvokedCallback(_onBackInvokedCallback)
             _host.release()
             _embeddedViewLifecycle.onDestroy()
         }
@@ -600,6 +607,16 @@ open class Session(
         }
     }
 
+    private fun setupBackInvokedCallback(): OnBackInvokedCallback {
+        val callback = OnBackInvokedCallback { clientCallback.onSelectionComplete() }
+        runBlocking(_main) {
+            _view
+                .findOnBackInvokedDispatcher()
+                ?.registerOnBackInvokedCallback(OnBackInvokedDispatcher.PRIORITY_DEFAULT, callback)
+        }
+        return callback
+    }
+
     // ---------- Begin Telemetry event functions ----------
 
     /** Picker event logger starts listening for events dispatched throughout the session */
@@ -619,6 +636,7 @@ open class Session(
             lazyEvents = _dependencies.events(),
             photopickerConfiguration =
                 _dependencies.configurationManager().get().configuration.value,
+            lazyFeatureManager = _dependencies.featureManager(),
         )
     }
 
diff --git a/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt b/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt
index a349d181f..e27cb75fd 100644
--- a/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt
+++ b/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt
@@ -16,9 +16,12 @@
 
 package com.android.photopicker.core.events
 
+import android.media.ApplicationMediaCapabilities
+import android.media.MediaFeature
 import android.provider.MediaStore
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.selection.Selection
@@ -29,6 +32,7 @@ import com.android.photopicker.data.DataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.extensions.getUserProfilesVisibleToPhotopicker
+import com.android.photopicker.features.search.SearchFeature
 import dagger.Lazy
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.flow.first
@@ -41,23 +45,24 @@ fun dispatchReportPhotopickerApiInfoEvent(
     photopickerConfiguration: PhotopickerConfiguration,
     pickerIntentAction: Telemetry.PickerIntentAction =
         Telemetry.PickerIntentAction.UNSET_PICKER_INTENT_ACTION,
+    lazyFeatureManager: Lazy<FeatureManager>,
 ) {
     val dispatcherToken = FeatureToken.CORE.token
     val sessionId = photopickerConfiguration.sessionId
     // We always launch the picker in collapsed state. We track the state change as UI event.
     val pickerSize = Telemetry.PickerSize.COLLAPSED
-    val mediaFilters =
-        photopickerConfiguration.mimeTypes
-            .map { mimeType ->
-                when {
-                    mimeType.contains("image") && mimeType.contains("video") ->
-                        Telemetry.MediaType.PHOTO_VIDEO
-                    mimeType.startsWith("image/") -> Telemetry.MediaType.PHOTO
-                    mimeType.startsWith("video/") -> Telemetry.MediaType.VIDEO
-                    else -> Telemetry.MediaType.UNSET_MEDIA_TYPE
-                }
-            }
-            .ifEmpty { listOf(Telemetry.MediaType.UNSET_MEDIA_TYPE) }
+    val mimeTypes = photopickerConfiguration.mimeTypes
+    val mediaFilter =
+        when {
+            mimeTypes.size > 1 &&
+                mimeTypes.any { it.startsWith("image/") } &&
+                mimeTypes.any { it.startsWith("video/") } -> Telemetry.MediaType.PHOTO_VIDEO
+            mimeTypes.size == 1 && mimeTypes.first().startsWith("image/") ->
+                Telemetry.MediaType.PHOTO
+            mimeTypes.size == 1 && mimeTypes.first().startsWith("video/") ->
+                Telemetry.MediaType.VIDEO
+            else -> Telemetry.MediaType.UNSET_MEDIA_TYPE
+        }
     val maxPickedItemsCount = photopickerConfiguration.selectionLimit
     val selectedTab =
         when (photopickerConfiguration.startDestination) {
@@ -74,32 +79,88 @@ fun dispatchReportPhotopickerApiInfoEvent(
             .isValidAccentColorSet()
     val isDefaultTabSet =
         photopickerConfiguration.startDestination != PhotopickerDestinations.DEFAULT
+    val isCloudSearchEnabled = lazyFeatureManager.get().isFeatureEnabled(SearchFeature::class.java)
     // TODO(b/376822503): Update when search is added
-    val isCloudSearchEnabled = false
     val isLocalSearchEnabled = false
-    for (mediaFilter in mediaFilters) {
-        coroutineScope.launch {
-            lazyEvents
-                .get()
-                .dispatch(
-                    Event.ReportPhotopickerApiInfo(
-                        dispatcherToken = dispatcherToken,
-                        sessionId = sessionId,
-                        pickerIntentAction = pickerIntentAction,
-                        pickerSize = pickerSize,
-                        mediaFilter = mediaFilter,
-                        maxPickedItemsCount = maxPickedItemsCount,
-                        selectedTab = selectedTab,
-                        selectedAlbum = selectedAlbum,
-                        isOrderedSelectionSet = isOrderedSelectionSet,
-                        isAccentColorSet = isAccentColorSet,
-                        isDefaultTabSet = isDefaultTabSet,
-                        isCloudSearchEnabled = isCloudSearchEnabled,
-                        isLocalSearchEnabled = isLocalSearchEnabled,
-                    )
+    val isTranscodingRequested: Boolean =
+        photopickerConfiguration.callingPackageMediaCapabilities != null
+    coroutineScope.launch {
+        lazyEvents
+            .get()
+            .dispatch(
+                Event.ReportPhotopickerApiInfo(
+                    dispatcherToken = dispatcherToken,
+                    sessionId = sessionId,
+                    pickerIntentAction = pickerIntentAction,
+                    pickerSize = pickerSize,
+                    mediaFilter = mediaFilter,
+                    maxPickedItemsCount = maxPickedItemsCount,
+                    selectedTab = selectedTab,
+                    selectedAlbum = selectedAlbum,
+                    isOrderedSelectionSet = isOrderedSelectionSet,
+                    isAccentColorSet = isAccentColorSet,
+                    isDefaultTabSet = isDefaultTabSet,
+                    isCloudSearchEnabled = isCloudSearchEnabled,
+                    isLocalSearchEnabled = isLocalSearchEnabled,
+                    isTranscodingRequested = isTranscodingRequested,
                 )
+            )
+    }
+}
+
+/** Dispatches an event to log App transcoding media capabilities if advertised by the app */
+fun dispatchReportPickerAppMediaCapabilities(
+    coroutineScope: CoroutineScope,
+    lazyEvents: Lazy<Events>,
+    photopickerConfiguration: PhotopickerConfiguration,
+) {
+    val dispatcherToken = FeatureToken.CORE.token
+    val sessionId = photopickerConfiguration.sessionId
+    val appMediaCapabilities: ApplicationMediaCapabilities? =
+        photopickerConfiguration.callingPackageMediaCapabilities
+    if (appMediaCapabilities != null) {
+        with(appMediaCapabilities) {
+            val supportedHdrTypes: IntArray = getEnumsForTypes(true, getSupportedHdrTypes())
+            val unsupportedHdrTypes: IntArray = getEnumsForTypes(false, getUnsupportedHdrTypes())
+            coroutineScope.launch {
+                lazyEvents
+                    .get()
+                    .dispatch(
+                        Event.ReportPickerAppMediaCapabilities(
+                            dispatcherToken = dispatcherToken,
+                            sessionId = sessionId,
+                            supportedHdrTypes = supportedHdrTypes,
+                            unsupportedHdrTypes = unsupportedHdrTypes,
+                        )
+                    )
+            }
+        }
+    }
+}
+
+private fun getEnumsForTypes(supported: Boolean, hdrTypesList: List<String>): IntArray {
+    var array: MutableList<Int> = mutableListOf()
+    for (type in hdrTypesList) {
+        when (type) {
+            MediaFeature.HdrType.DOLBY_VISION -> {
+                if (supported) array.add(Telemetry.HdrTypes.DOLBY_SUPPORTED.type)
+                else array.add(Telemetry.HdrTypes.DOLBY_UNSUPPORTED.type)
+            }
+            MediaFeature.HdrType.HDR10 -> {
+                if (supported) array.add(Telemetry.HdrTypes.HDR10_SUPPORTED.type)
+                else array.add(Telemetry.HdrTypes.HDR10_UNSUPPORTED.type)
+            }
+            MediaFeature.HdrType.HDR10_PLUS -> {
+                if (supported) array.add(Telemetry.HdrTypes.HDR10PLUS_SUPPORTED.type)
+                else array.add(Telemetry.HdrTypes.HDR10PLUS_UNSUPPORTED.type)
+            }
+            MediaFeature.HdrType.HLG -> {
+                if (supported) array.add(Telemetry.HdrTypes.HLG_SUPPORTED.type)
+                else array.add(Telemetry.HdrTypes.HLG_UNSUPPORTED.type)
+            }
         }
     }
+    return array.toIntArray()
 }
 
 /** Dispatches an event to log all the final state details of the picker */
diff --git a/photopicker/src/com/android/photopicker/core/events/Event.kt b/photopicker/src/com/android/photopicker/core/events/Event.kt
index 8426a55bb..c6b674c90 100644
--- a/photopicker/src/com/android/photopicker/core/events/Event.kt
+++ b/photopicker/src/com/android/photopicker/core/events/Event.kt
@@ -96,6 +96,7 @@ interface Event {
         val isDefaultTabSet: Boolean,
         val isCloudSearchEnabled: Boolean,
         val isLocalSearchEnabled: Boolean,
+        val isTranscodingRequested: Boolean,
     ) : Event
 
     /**
@@ -225,6 +226,24 @@ interface Event {
         val surfacePackageDeliveryStartTime: Int,
         val surfacePackageDeliveryEndTime: Int,
     ) : Event
+
+    /** Logs media capabilities of the App requesting transcoding */
+    data class ReportPickerAppMediaCapabilities(
+        override val dispatcherToken: String,
+        val sessionId: Int,
+        val supportedHdrTypes: IntArray,
+        val unsupportedHdrTypes: IntArray,
+    ) : Event
+
+    /** Logs information about the transcoding video */
+    data class ReportTranscodingVideoDetails(
+        override val dispatcherToken: String,
+        val sessionId: Int,
+        val duration: Int,
+        val colorTransfer: Int,
+        val colorStandard: Int,
+        val mimeType: Int,
+    ) : Event
 }
 
 /**
@@ -382,6 +401,57 @@ interface Telemetry {
         ),
     }
 
+    /*
+    Different supported and unsupported HDR types
+    */
+    enum class HdrTypes(val type: Int) {
+        HDR10_SUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__SUPPORTED_HDR_TYPES__TYPE_HDR10
+        ),
+        HDR10PLUS_SUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__SUPPORTED_HDR_TYPES__TYPE_HDR10_PLUS
+        ),
+        HLG_SUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__SUPPORTED_HDR_TYPES__TYPE_HLG
+        ),
+        DOLBY_SUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__SUPPORTED_HDR_TYPES__TYPE_DOLBY_VISION
+        ),
+        HDR10_UNSUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__UNSUPPORTED_HDR_TYPES__TYPE_HDR10
+        ),
+        HDR10PLUS_UNSUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__UNSUPPORTED_HDR_TYPES__TYPE_HDR10_PLUS
+        ),
+        HLG_UNSUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__UNSUPPORTED_HDR_TYPES__TYPE_HLG
+        ),
+        DOLBY_UNSUPPORTED(
+            MediaProviderStatsLog
+                .PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED__UNSUPPORTED_HDR_TYPES__TYPE_DOLBY_VISION
+        ),
+    }
+
+    /*
+    Different Video mime types
+    */
+    enum class VideoMimeType(val type: Int) {
+        DOLBY(
+            MediaProviderStatsLog
+                .PHOTOPICKER_VIDEO_TRANSCODING_DETAILS_LOGGED__MIME_TYPE__MIME_DOLBY
+        ),
+        HEVC(
+            MediaProviderStatsLog.PHOTOPICKER_VIDEO_TRANSCODING_DETAILS_LOGGED__MIME_TYPE__MIME_HEVC
+        ),
+    }
+
     /*
     Different picker tabs
     */
@@ -522,7 +592,49 @@ interface Telemetry {
         SELECT_SEARCH_CATEGORY(
             MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__SELECT_SEARCH_CATEGORY
         ),
+        SELECT_SEARCH_RESULT(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__SELECT_SEARCH_RESULT
+        ),
+        PICKER_CATEGORIES_INTERACTION(
+            MediaProviderStatsLog
+                .PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__PICKER_CATEGORIES_INTERACTION
+        ),
+        CATEGORY_PEOPLEPET_OPEN(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__CATEGORIES_PEOPLEPET_OPEN
+        ),
+        CATEGORY_MEDIA_SETS_OPEN(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__CATEGORIES_MEDIA_SETS_OPEN
+        ),
+        UI_LOADED_CATEGORIES_AND_ALBUMS(
+            MediaProviderStatsLog
+                .PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UI_LOADED_CATEGORIES_AND_ALBUMS
+        ),
+        UI_LOADED_MEDIA_SETS(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UI_LOADED_MEDIA_SETS
+        ),
+        UI_LOADED_MEDIA_SETS_CONTENTS(
+            MediaProviderStatsLog
+                .PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UI_LOADED_MEDIA_SETS_CONTENTS
+        ),
+        UI_LOADED_SEARCH_SUGGESTIONS(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UI_LOADED_SEARCH_SUGGESTIONS
+        ),
+        UI_LOADED_SEARCH_RESULTS(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UI_LOADED_SEARCH_RESULTS
+        ),
+        UI_LOADED_EMPTY_STATE(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UI_LOADED_EMPTY_STATE
+        ),
         UNSET_UI_EVENT(MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UNSET_UI_EVENT),
+        PICKER_TRANSCODING_START(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__PICKER_TRANSCODING_STARTED
+        ),
+        PICKER_TRANSCODING_SUCCESS(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__PICKER_TRANSCODING_FINISHED
+        ),
+        PICKER_TRANSCODING_FAILED(
+            MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__PICKER_TRANSCODING_FAILED
+        ),
     }
 
     /*
diff --git a/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt b/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt
index 6b81b426c..5f3787d76 100644
--- a/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt
+++ b/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt
@@ -100,6 +100,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             /* is_search_enabled */ false,
                             event.isCloudSearchEnabled,
                             event.isLocalSearchEnabled,
+                            event.isTranscodingRequested,
                         )
                     }
                     is Event.LogPhotopickerUIEvent -> {
@@ -228,7 +229,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                     }
                     is Event.ReportPhotopickerSearchInfo -> {
                         MediaProviderStatsLog.write(
-                            MediaProviderStatsLog.PHOTOPICKER_SESSION_INFO_REPORTED,
+                            MediaProviderStatsLog.PHOTOPICKER_SEARCH_INFO_REPORTED,
                             event.sessionId,
                             event.searchMethod.method,
                             /* picked_items */ 0,
@@ -256,6 +257,24 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.surfacePackageDeliveryEndTime,
                         )
                     }
+                    is Event.ReportPickerAppMediaCapabilities -> {
+                        MediaProviderStatsLog.write(
+                            MediaProviderStatsLog.PHOTOPICKER_APP_MEDIA_CAPABILITIES_REPORTED,
+                            event.sessionId,
+                            event.supportedHdrTypes,
+                            event.unsupportedHdrTypes,
+                        )
+                    }
+                    is Event.ReportTranscodingVideoDetails -> {
+                        MediaProviderStatsLog.write(
+                            MediaProviderStatsLog.PHOTOPICKER_VIDEO_TRANSCODING_DETAILS_LOGGED,
+                            event.sessionId,
+                            event.duration,
+                            event.colorStandard,
+                            event.colorTransfer,
+                            event.mimeType,
+                        )
+                    }
                 }
             }
         }
diff --git a/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt b/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt
index e3bf347fd..c1ff94c45 100644
--- a/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt
+++ b/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt
@@ -25,6 +25,7 @@ import com.android.photopicker.core.events.RegisteredEventClass
 import com.android.photopicker.data.PrefetchDataService
 import com.android.photopicker.features.albumgrid.AlbumGridFeature
 import com.android.photopicker.features.browse.BrowseFeature
+import com.android.photopicker.features.categorygrid.CategoryGridFeature
 import com.android.photopicker.features.cloudmedia.CloudMediaFeature
 import com.android.photopicker.features.navigationbar.NavigationBarFeature
 import com.android.photopicker.features.overflowmenu.OverflowMenuFeature
@@ -37,6 +38,7 @@ import com.android.photopicker.features.search.SearchFeature
 import com.android.photopicker.features.selectionbar.SelectionBarFeature
 import com.android.photopicker.features.snackbar.SnackbarFeature
 import com.android.photopicker.util.mapOfDeferredWithTimeout
+import java.util.concurrent.CopyOnWriteArraySet
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Deferred
@@ -94,6 +96,7 @@ class FeatureManager(
                 BrowseFeature.Registration,
                 SearchFeature.Registration,
                 PrepareMediaFeature.Registration,
+                CategoryGridFeature.Registration,
             )
 
         /* The list of events that the core library consumes. */
@@ -118,11 +121,17 @@ class FeatureManager(
                 Event.ReportPhotopickerSearchInfo::class.java,
                 Event.ReportSearchDataExtractionDetails::class.java,
                 Event.ReportEmbeddedPhotopickerInfo::class.java,
+                Event.ReportPickerAppMediaCapabilities::class.java,
+                Event.ReportTranscodingVideoDetails::class.java,
             )
     }
 
     // The internal mutable set of enabled features.
-    private val _enabledFeatures: MutableSet<PhotopickerFeature> = mutableSetOf()
+    // This field is read in the public method [isFeatureEnabled] which can be called from both the
+    // main thread as well as various background threads, so ensure concurrency by using a slower,
+    // but thread safe data structure. This list is fairly small (roughly the size of
+    // KNOWN_FEATURE_REGISTRATIONS), and it's access is retrieval heavy rather than mutation heavy.
+    private val _enabledFeatures: CopyOnWriteArraySet<PhotopickerFeature> = CopyOnWriteArraySet()
 
     // The internal map of claimed [FeatureToken] to the claiming [PhotopickerFeature]
     private val _tokenMap: HashMap<String, PhotopickerFeature> = HashMap()
@@ -229,7 +238,9 @@ class FeatureManager(
                 mapOfDeferredWithTimeout<PrefetchResultKey, PrefetchDataService>(
                     inputMap = prefetchRequestMap,
                     input = prefetchDataService,
-                    timeoutMillis = 200L,
+                    timeoutMillis = 250L,
+                    backgroundScope = scope,
+                    dispatcher = dispatcher,
                 )
             }
 
diff --git a/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt b/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt
index dc9287f0a..a8ab6d11a 100644
--- a/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt
+++ b/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt
@@ -24,6 +24,7 @@ enum class FeatureToken(val token: String) {
     // keep-sorted start
     ALBUM_GRID("ALBUM_GRID"),
     BROWSE("BROWSE"),
+    CATEGORY_GRID("CATEGORY_GRID"),
     CLOUD_MEDIA("CLOUD_MEDIA"),
     CORE("CORE"),
     MEDIA_PREPARE("MEDIA_PREPARE"),
diff --git a/photopicker/src/com/android/photopicker/core/features/Priority.kt b/photopicker/src/com/android/photopicker/core/features/Priority.kt
index ea7434ec9..51fae40e2 100644
--- a/photopicker/src/com/android/photopicker/core/features/Priority.kt
+++ b/photopicker/src/com/android/photopicker/core/features/Priority.kt
@@ -32,4 +32,5 @@ enum class Priority(val priority: Int) {
     LOW(25),
     MEDIUM(50),
     HIGH(90),
+    HIGHEST(100),
 }
diff --git a/photopicker/src/com/android/photopicker/core/glide/GlideLoadable.kt b/photopicker/src/com/android/photopicker/core/glide/GlideLoadable.kt
index 5b08183ee..eb48dc358 100644
--- a/photopicker/src/com/android/photopicker/core/glide/GlideLoadable.kt
+++ b/photopicker/src/com/android/photopicker/core/glide/GlideLoadable.kt
@@ -62,9 +62,4 @@ interface GlideLoadable {
     fun getMimeTypeForGlide(): String {
         return DEFAULT_IMAGE_MIME_TYPE
     }
-
-    /**
-     * Provide a timestamp for ordering this GlideLoadable within a list of other GlideLoadables.
-     */
-    fun getTimestamp(): Long
 }
diff --git a/photopicker/src/com/android/photopicker/core/glide/ParcelableGlideLoadable.kt b/photopicker/src/com/android/photopicker/core/glide/ParcelableGlideLoadable.kt
new file mode 100644
index 000000000..6a0890444
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/core/glide/ParcelableGlideLoadable.kt
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.core.glide
+
+import android.os.Parcelable
+
+/**
+ * Any object that implements this interface can be loaded with Glide and can also be written to and
+ * restored from a Parcel.
+ */
+interface ParcelableGlideLoadable : Parcelable, GlideLoadable
diff --git a/photopicker/src/com/android/photopicker/core/navigation/PhotopickerDestinations.kt b/photopicker/src/com/android/photopicker/core/navigation/PhotopickerDestinations.kt
index 92c6fb7ae..fb997fdd6 100644
--- a/photopicker/src/com/android/photopicker/core/navigation/PhotopickerDestinations.kt
+++ b/photopicker/src/com/android/photopicker/core/navigation/PhotopickerDestinations.kt
@@ -35,4 +35,10 @@ enum class PhotopickerDestinations(val route: String) {
 
     // The route used to navigate to album media grid.
     ALBUM_MEDIA_GRID("albummediagrid"),
+
+    // The route which shows a grid of the user's media set.
+    MEDIA_SET_GRID("mediasetgrid"),
+
+    // The route which shows a grid of the user's media set content.
+    MEDIA_SET_CONTENT_GRID("mediasetcontentgrid"),
 }
diff --git a/photopicker/src/com/android/photopicker/core/theme/PhotopickerTheme.kt b/photopicker/src/com/android/photopicker/core/theme/PhotopickerTheme.kt
index 44c3ebd25..b8f0e5653 100644
--- a/photopicker/src/com/android/photopicker/core/theme/PhotopickerTheme.kt
+++ b/photopicker/src/com/android/photopicker/core/theme/PhotopickerTheme.kt
@@ -16,7 +16,10 @@
 
 package com.android.photopicker.core.theme
 
+import android.os.Build
 import androidx.compose.foundation.isSystemInDarkTheme
+import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
+import androidx.compose.material3.MaterialExpressiveTheme
 import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.darkColorScheme
 import androidx.compose.material3.dynamicDarkColorScheme
@@ -44,10 +47,11 @@ import com.android.photopicker.core.theme.typography.photopickerTypography
  * composables downstream to react to WindowSize changes.
  */
 @Composable
+@OptIn(ExperimentalMaterial3ExpressiveApi::class)
 fun PhotopickerTheme(
     isDarkTheme: Boolean = isSystemInDarkTheme(),
     config: PhotopickerConfiguration,
-    content: @Composable () -> Unit
+    content: @Composable () -> Unit,
 ) {
     val context = LocalContext.current
     val accentColorHelper = AccentColorHelper(config.accentColor ?: -1)
@@ -84,7 +88,7 @@ fun PhotopickerTheme(
                         // in the theme to use the accent color.
                         darkTheme.copy(
                             primary = accentColorHelper.getAccentColor(),
-                            onPrimary = accentColorHelper.getTextColorForAccentComponents()
+                            onPrimary = accentColorHelper.getTextColorForAccentComponents(),
                         )
                     }
                 false ->
@@ -95,7 +99,7 @@ fun PhotopickerTheme(
                             // When an accent color has been specified, set primary and onPrimary
                             // in the theme to use the accent color.
                             primary = accentColorHelper.getAccentColor(),
-                            onPrimary = accentColorHelper.getTextColorForAccentComponents()
+                            onPrimary = accentColorHelper.getTextColorForAccentComponents(),
                         )
                     }
             }
@@ -113,17 +117,30 @@ fun PhotopickerTheme(
     // Calculate the current screen size
     val windowSizeClass: WindowSizeClass = calculateWindowSizeClass()
 
-    MaterialTheme(
-        colorScheme = colorScheme,
-        typography = typography,
+    if (
+        config.flags.EXPRESSIVE_THEME_ENABLED &&
+            Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA
     ) {
-        CompositionLocalProvider(
-            LocalWindowSizeClass provides windowSizeClass,
-            LocalFixedAccentColors provides fixedAccentColors,
-            CustomAccentColorScheme provides
-                AccentColorScheme(accentColorHelper = accentColorHelper),
-        ) {
-            content()
+        MaterialExpressiveTheme(colorScheme = colorScheme, typography = typography) {
+            CompositionLocalProvider(
+                LocalWindowSizeClass provides windowSizeClass,
+                LocalFixedAccentColors provides fixedAccentColors,
+                CustomAccentColorScheme provides
+                    AccentColorScheme(accentColorHelper = accentColorHelper),
+            ) {
+                content()
+            }
+        }
+    } else {
+        MaterialTheme(colorScheme = colorScheme, typography = typography) {
+            CompositionLocalProvider(
+                LocalWindowSizeClass provides windowSizeClass,
+                LocalFixedAccentColors provides fixedAccentColors,
+                CustomAccentColorScheme provides
+                    AccentColorScheme(accentColorHelper = accentColorHelper),
+            ) {
+                content()
+            }
         }
     }
 }
diff --git a/photopicker/src/com/android/photopicker/core/user/UserMonitor.kt b/photopicker/src/com/android/photopicker/core/user/UserMonitor.kt
index 0f00a0986..3c6402697 100644
--- a/photopicker/src/com/android/photopicker/core/user/UserMonitor.kt
+++ b/photopicker/src/com/android/photopicker/core/user/UserMonitor.kt
@@ -100,11 +100,21 @@ class UserMonitor(
                                 properties.getShowInSharingSurfaces() ==
                                     UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE
                             } else {
-                                true
+                                when {
+                                    processOwnerUserHandle.identifier == it.identifier -> true
+                                    // For SDK < V, accept all managed profiles, and the parent
+                                    // of the current process owner. Ignore all others.
+                                    userManager.isManagedProfile(it.identifier) -> true
+                                    it.identifier ==
+                                        userManager
+                                            .getProfileParent(processOwnerUserHandle)
+                                            ?.identifier -> true
+                                    else -> false
+                                }
                             }
                         }
                         .map { getUserProfileFromHandle(it, context) },
-                activeContentResolver = getContentResolver(context, processOwnerUserHandle)
+                activeContentResolver = getContentResolver(context, processOwnerUserHandle),
             )
         )
 
@@ -116,7 +126,7 @@ class UserMonitor(
         _userStatus.stateIn(
             scope,
             SharingStarted.WhileSubscribed(),
-            initialValue = _userStatus.value
+            initialValue = _userStatus.value,
         )
 
     /** Setup a BroadcastReceiver to receive broadcasts for profile availability changes */
@@ -190,7 +200,7 @@ class UserMonitor(
      */
     suspend fun requestSwitchActiveUserProfile(
         requested: UserProfile,
-        context: Context
+        context: Context,
     ): SwitchUserProfileResult {
 
         // Attempt to find the requested profile amongst the profiles known.
@@ -205,7 +215,7 @@ class UserMonitor(
                     it.copy(
                         activeUserProfile = profile,
                         activeContentResolver =
-                            getContentResolver(context, UserHandle.of(profile.identifier))
+                            getContentResolver(context, UserHandle.of(profile.identifier)),
                     )
                 }
                 return SwitchUserProfileResult.SUCCESS
@@ -230,7 +240,7 @@ class UserMonitor(
         handle?.let {
             Log.d(
                 TAG,
-                "Received a profile update for ${handle.getIdentifier()} from intent $intent"
+                "Received a profile update for ${handle.getIdentifier()} from intent $intent",
             )
 
             // Assemble a new UserProfile from the updated UserHandle.
@@ -244,7 +254,7 @@ class UserMonitor(
                         .filterNot { it.identifier == profile.identifier }
                         .toTypedArray(),
                     // Replace the matching profile with the updated one.
-                    profile
+                    profile,
                 )
 
             // Check and see if the profile we just updated is still enabled, and if it is the
@@ -255,8 +265,7 @@ class UserMonitor(
             ) {
                 Log.i(
                     TAG,
-                    "The active profile is no longer enabled, transitioning back to the process" +
-                        " owner's profile."
+                    "The active profile is no longer enabled, transitioning back to the process owner's profile.",
                 )
 
                 // The current profile is disabled, we need to transition back to the process
@@ -269,7 +278,9 @@ class UserMonitor(
                     _userStatus.update {
                         it.copy(
                             activeUserProfile = processOwnerProfile,
-                            allProfiles = newProfilesList
+                            allProfiles = newProfilesList,
+                            activeContentResolver =
+                                getContentResolver(context, processOwnerProfile.handle),
                         )
                     }
                 }
@@ -279,8 +290,7 @@ class UserMonitor(
                     ?: run {
                         Log.w(
                             TAG,
-                            "Could not find the process owner's profile to switch to when the" +
-                                " active profile was disabled."
+                            "Could not find the process owner's profile to switch to when the active profile was disabled.",
                         )
 
                         // Still attempt to update the list of profiles.
@@ -297,7 +307,7 @@ class UserMonitor(
             ?: run {
                 Log.w(
                     TAG,
-                    "Received intent: $intent but could not find matching UserHandle. Ignoring."
+                    "Received intent: $intent but could not find matching UserHandle. Ignoring.",
                 )
             }
     }
@@ -305,32 +315,103 @@ class UserMonitor(
     /**
      * Determines if the current handle supports CrossProfile content sharing.
      *
+     * This method accepts a pair of user handles (from/to) and determines if CrossProfile access is
+     * permitted between those two profiles.
+     *
+     * There are differences is on how the access is determined based on the platform SDK:
+     * - For Platform SDK < V:
+     *
+     *   A check for CrossProfileIntentForwarders in the origin (from) profile that target the
+     *   destination (to) profile. If such a forwarder exists, then access is allowed, and denied
+     *   otherwise.
+     * - For Platform SDK >= V:
+     *
+     *   The method now takes into account access delegation, which was first added in Android V.
+     *
+     *   For profiles that set the [CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT] property in
+     *   its [UserProperties], its parent profile will be substituted in for its side of the check.
+     *
+     *   ex. For access checks between a Managed (from) and Private (to) profile, where:
+     *     - Managed does not delegate to its parent
+     *     - Private delegates to its parent
+     *
+     *   The following logic is performed: Managed -> parent(Private)
+     *
+     *   The same check in the other direction would yield: parent(Private) -> Managed
+     *
+     *   Note how the private profile is never actually used for either side of the check, since it
+     *   is delegating its access check to the parent. And thus, if Managed can access the parent,
+     *   it can also access the private.
+     *
+     * @param context Current context object, for switching user contexts.
+     * @param fromUser The Origin profile, where the user is coming from
+     * @param toUser The destination profile, where the user is attempting to go to.
      * @return Whether CrossProfile content sharing is supported in this handle.
      */
     private fun getIsCrossProfileAllowedForHandle(
-        handle: UserHandle,
+        context: Context,
+        fromUser: UserHandle,
+        toUser: UserHandle,
     ): Boolean {
 
-        // First, check if cross profile is delegated to parent profile
-        if (SdkLevel.isAtLeastV()) {
-            val properties: UserProperties = userManager.getUserProperties(handle)
-            if (
-                /*
-                 * All user profiles with user property
-                 * [UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT]
-                 * can access each other including its parent.
-                 */
-                properties.getCrossProfileContentSharingStrategy() ==
-                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
-            ) {
-                return true
+        /**
+         * Determine if the provided [UserHandle] delegates its cross profile content sharing (both
+         * to / from this profile) to its parent's access.
+         *
+         * @return True if the profile delegates to its parent, false otherwise.
+         */
+        fun profileDelegatesToParent(handle: UserHandle): Boolean {
+
+            // Early exit, this check only exists on V+
+            if (!SdkLevel.isAtLeastV()) {
+                return false
             }
+
+            val props = userManager.getUserProperties(handle)
+            return props.getCrossProfileContentSharingStrategy() ==
+                UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
+        }
+
+        // Early exit conditions, accessing self.
+        // NOTE: It is also possible to reach this state if this method is recursively checking
+        // from: parent(A) to:parent(B) where A and B are both children of the same parent.
+        if (fromUser.identifier == toUser.identifier) {
+            return true
+        }
+
+        // Decide if we should use actual from or parent(from)
+        val currentFromUser: UserHandle =
+            if (profileDelegatesToParent(fromUser)) {
+                userManager.getProfileParent(fromUser) ?: fromUser
+            } else {
+                fromUser
+            }
+
+        // Decide if we should use actual to or parent(to)
+        val currentToUser: UserHandle =
+            if (profileDelegatesToParent(toUser)) {
+                userManager.getProfileParent(toUser) ?: toUser
+            } else {
+                toUser
+            }
+
+        // When the from/to has changed from the original parameters, recursively restart the checks
+        // with the new from/to handles.
+        if (
+            fromUser.identifier != currentFromUser.identifier ||
+                toUser.identifier != currentToUser.identifier
+        ) {
+            return getIsCrossProfileAllowedForHandle(context, currentFromUser, currentToUser)
         }
 
         // As a last resort, no applicable cross profile information found, so inspect the current
         // configuration and if there is an intent set, try to see
         // if there is a matching CrossProfileIntentForwarder
-        return configuration.value.doesCrossProfileIntentForwarderExists(packageManager)
+        return configuration.value.doesCrossProfileIntentForwarderExists(
+            packageManager,
+            fromUser,
+            toUser,
+        )
     }
 
     /**
@@ -343,30 +424,43 @@ class UserMonitor(
         val isParentProfile = userManager.getProfileParent(handle) == null
         val isManaged = userManager.isManagedProfile(handle.getIdentifier())
         val isQuietModeEnabled = userManager.isQuietModeEnabled(handle)
-        var isCrossProfileSupported = getIsCrossProfileAllowedForHandle(handle)
-
-        val userContext = context.createContextAsUser(handle, /* flags= */ 0)
-        val localUserManager: UserManager = userContext.requireSystemService()
+        var isCrossProfileSupported =
+            getIsCrossProfileAllowedForHandle(context, processOwnerUserHandle, handle)
 
         val (icon, label) =
-            with(localUserManager) {
-                if (SdkLevel.isAtLeastV()) {
-                    try {
+            try {
+
+                val userContext = context.createContextAsUser(handle, /* flags= */ 0)
+                val localUserManager: UserManager = userContext.requireSystemService()
+
+                with(localUserManager) {
+                    if (SdkLevel.isAtLeastV()) {
                         // Since these require an external call to generate, create them once
                         // and cache them in the profile that is getting passed to the UI to
                         // speed things up!
                         Pair(getUserBadge().toBitmap().asImageBitmap(), getProfileLabel())
-                    } catch (exception: Resources.NotFoundException) {
+                    } else {
+                        // For Pre-V the UI will use pre-compiled resources and mappings to generate
+                        // the icon.
+                        Pair(null, null)
+                    }
+                }
+            } catch (ex: Exception) {
+                when (ex) {
+                    is IllegalStateException -> {
+                        Log.w(TAG, "IllegalState encountered while fetching icon and label.", ex)
+                    }
+                    is Resources.NotFoundException -> {
                         // If either resource is not defined by the system, fall back to the
                         // pre-compiled options to ensure that the UI doesn't end up in a weird
                         // state.
-                        Pair(null, null)
+                        Log.w(TAG, "Expected profile resources could not be found", ex)
+                    }
+                    else -> {
+                        Log.w(TAG, "Encountered exception during profile initialization: ", ex)
                     }
-                } else {
-                    // For Pre-V the UI will use pre-compiled resources and mappings to generate the
-                    // icon.
-                    Pair(null, null)
                 }
+                Pair(null, null)
             }
 
         return UserProfile(
@@ -386,8 +480,6 @@ class UserMonitor(
                     processOwnerUserHandle -> emptySet()
                     else ->
                         buildSet {
-                            if (isParentProfile)
-                                return@buildSet // Parent profile can always be accessed by children
                             if (isQuietModeEnabled) {
                                 add(UserProfile.DisabledReason.QUIET_MODE)
 
@@ -406,7 +498,7 @@ class UserMonitor(
                             if (!isCrossProfileSupported)
                                 add(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
                         }
-                }
+                },
         )
     }
 
diff --git a/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt b/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt
index c413b7f73..a7537b004 100644
--- a/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt
+++ b/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt
@@ -426,7 +426,7 @@ class DataServiceImpl(
 
                     Log.v(
                         DataService.TAG,
-                        "Created an album media paging source that queries " + "$availableProviders",
+                        "Created an album media paging source that queries $availableProviders",
                     )
 
                     albumMap[album.id] = albumMediaPagingSource
@@ -454,7 +454,7 @@ class DataServiceImpl(
 
             Log.v(
                 DataService.TAG,
-                "Created an album paging source that queries " + "$availableProviders",
+                "Created an album paging source that queries $availableProviders",
             )
 
             albumPagingSources.add(albumPagingSource)
@@ -512,7 +512,7 @@ class DataServiceImpl(
 
             Log.v(
                 DataService.TAG,
-                "Created a media paging source that queries database for" + "preview items.",
+                "Created a media paging source that queries database for preview items.",
             )
             mediaPagingSources.add(mediaPagingSource)
             mediaPagingSource
diff --git a/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt b/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt
index e24ad579f..360e90f57 100644
--- a/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt
+++ b/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt
@@ -24,28 +24,34 @@ import android.os.Bundle
 import android.os.CancellationSignal
 import android.util.Log
 import androidx.core.os.bundleOf
-import androidx.core.util.Preconditions.checkNotNull
 import androidx.paging.PagingSource.LoadResult
 import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.data.model.CollectionInfo
 import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Icon
+import com.android.photopicker.data.model.KeyToCategoryType
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.search.model.KeyToSearchSuggestionType
 import com.android.photopicker.features.search.model.SearchRequest
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
 
 /**
- * A client class that is reponsible for holding logic required to interact with [MediaProvider].
+ * A client class that is responsible for holding logic required to interact with [MediaProvider].
  *
  * It typically fetches data from [MediaProvider] using content queries and call methods.
  */
 open class MediaProviderClient {
     companion object {
         private const val TAG = "MediaProviderClient"
-        private const val MEDIA_INIT_CALL_METHOD: String = "picker_media_init"
-        private const val SEARCH_REQUEST_INIT_CALL_METHOD = "picker_internal_search_media_init"
+        private const val MEDIA_SETS_INIT_CALL_METHOD: String = "picker_media_sets_init_call"
+        private const val MEDIA_SET_CONTENTS_INIT_CALL_METHOD: String =
+            "picker_media_in_media_set_init"
         private const val EXTRA_MIME_TYPES = "mime_types"
         private const val EXTRA_INTENT_ACTION = "intent_action"
         private const val EXTRA_PROVIDERS = "providers"
@@ -54,6 +60,10 @@ open class MediaProviderClient {
         private const val EXTRA_ALBUM_AUTHORITY = "album_authority"
         private const val COLUMN_GRANTS_COUNT = "grants_count"
         private const val PRE_SELECTION_URIS = "pre_selection_uris"
+        const val MEDIA_INIT_CALL_METHOD: String = "picker_media_init"
+        const val SEARCH_REQUEST_INIT_CALL_METHOD = "picker_internal_search_media_init"
+        const val GET_SEARCH_PROVIDERS_CALL_METHOD = "picker_internal_get_search_providers"
+        const val SEARCH_PROVIDER_AUTHORITIES = "search_provider_authorities"
         const val SEARCH_REQUEST_ID = "search_request_id"
     }
 
@@ -73,11 +83,30 @@ open class MediaProviderClient {
         ALBUM_AUTHORITY("album_authority")
     }
 
-    private enum class SearchRequestInitRequest(val key: String) {
-        SEARCH_TEXT("search_text"),
-        MEDIA_SET_ID("media_set_id"),
-        AUTHORITY("authority"),
-        TYPE("search_suggestion_type"),
+    /**
+     * Contains all mandatory keys required to make a Category and Album query that are not present
+     * in [MediaQuery] already.
+     */
+    private enum class CategoryAndAlbumQuery(val key: String) {
+        PARENT_CATEGORY_ID("parent_category_id")
+    }
+
+    /**
+     * Contains all mandatory keys required to make a Media Set query that are not present in
+     * [MediaQuery] already.
+     */
+    private enum class MediaSetsQuery(val key: String) {
+        PARENT_CATEGORY_ID("parent_category_id"),
+        PARENT_CATEGORY_AUTHORITY("parent_category_authority"),
+    }
+
+    /**
+     * Contains all mandatory keys required to make a Media Set contents query that are not present
+     * in [MediaQuery] already.
+     */
+    private enum class MediaSetContentsQuery(val key: String) {
+        PARENT_MEDIA_SET_PICKER_ID("media_set_picker_id"),
+        PARENT_MEDIA_SET_AUTHORITY("media_set_picker_authority"),
     }
 
     /**
@@ -139,6 +168,50 @@ open class MediaProviderClient {
         IS_FIRST_PAGE("is_first_page"),
     }
 
+    enum class SearchRequestInitRequest(val key: String) {
+        SEARCH_TEXT("search_text"),
+        MEDIA_SET_ID("media_set_id"),
+        AUTHORITY("authority"),
+        TYPE("search_suggestion_type"),
+    }
+
+    enum class SearchSuggestionsQuery(val key: String) {
+        LIMIT("limit"),
+        HISTORY_LIMIT("history_limit"),
+        PREFIX("prefix"),
+        PROVIDERS("providers"),
+    }
+
+    enum class SearchSuggestionsResponse(val key: String) {
+        AUTHORITY("authority"),
+        MEDIA_SET_ID("media_set_id"),
+        SEARCH_TEXT("display_text"),
+        COVER_MEDIA_URI("cover_media_uri"),
+        SUGGESTION_TYPE("suggestion_type"),
+    }
+
+    enum class GroupResponse(val key: String) {
+        MEDIA_GROUP("media_group"),
+        /** Identifier received from CMP. This cannot be null. */
+        GROUP_ID("group_id"),
+        /** Identifier used in Picker Backend, if any. */
+        PICKER_ID("picker_id"),
+        DISPLAY_NAME("display_name"),
+        AUTHORITY("authority"),
+        UNWRAPPED_COVER_URI("unwrapped_cover_uri"),
+        ADDITIONAL_UNWRAPPED_COVER_URI_1("additional_cover_uri_1"),
+        ADDITIONAL_UNWRAPPED_COVER_URI_2("additional_cover_uri_2"),
+        ADDITIONAL_UNWRAPPED_COVER_URI_3("additional_cover_uri_3"),
+        CATEGORY_TYPE("category_type"),
+        IS_LEAF_CATEGORY("is_leaf_category"),
+    }
+
+    enum class GroupType() {
+        CATEGORY,
+        MEDIA_SET,
+        ALBUM,
+    }
+
     /** Fetch available [Provider]-s from the Media Provider process. */
     fun fetchAvailableProviders(contentResolver: ContentResolver): List<Provider> {
         try {
@@ -161,7 +234,7 @@ open class MediaProviderClient {
     }
 
     /** Ensure that available providers are up to date. */
-    fun ensureProviders(contentResolver: ContentResolver) {
+    suspend fun ensureProviders(contentResolver: ContentResolver) {
         try {
             contentResolver.call(
                 MEDIA_PROVIDER_AUTHORITY,
@@ -175,7 +248,7 @@ open class MediaProviderClient {
     }
 
     /** Fetch a list of [Media] from MediaProvider for the given page key. */
-    fun fetchMedia(
+    open suspend fun fetchMedia(
         pageKey: MediaPageKey,
         pageSize: Int,
         contentResolver: ContentResolver,
@@ -208,8 +281,8 @@ open class MediaProviderClient {
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfMedia(),
-                            prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey(),
+                            prevKey = cursor.getPrevMediaPageKey(),
+                            nextKey = cursor.getNextMediaPageKey(),
                             itemsBefore =
                                 cursor.getItemsBeforeCount() ?: LoadResult.Page.COUNT_UNDEFINED,
                         )
@@ -224,7 +297,7 @@ open class MediaProviderClient {
     }
 
     /** Fetch search results as a list of [Media] from MediaProvider for the given page key. */
-    fun fetchSearchResults(
+    suspend fun fetchSearchResults(
         searchRequestId: Int,
         pageKey: MediaPageKey,
         pageSize: Int,
@@ -259,8 +332,8 @@ open class MediaProviderClient {
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfMedia(),
-                            prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey(),
+                            prevKey = cursor.getPrevMediaPageKey(),
+                            nextKey = cursor.getNextMediaPageKey(),
                             itemsBefore =
                                 cursor.getItemsBeforeCount() ?: LoadResult.Page.COUNT_UNDEFINED,
                         )
@@ -275,7 +348,7 @@ open class MediaProviderClient {
     }
 
     /** Fetch a list of [Media] from MediaProvider for the given page key. */
-    fun fetchPreviewMedia(
+    suspend fun fetchPreviewMedia(
         pageKey: MediaPageKey,
         pageSize: Int,
         contentResolver: ContentResolver,
@@ -314,8 +387,8 @@ open class MediaProviderClient {
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfMedia(),
-                            prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey(),
+                            prevKey = cursor.getPrevMediaPageKey(),
+                            nextKey = cursor.getNextMediaPageKey(),
                         )
                     }
                         ?: throw IllegalStateException(
@@ -328,7 +401,7 @@ open class MediaProviderClient {
     }
 
     /** Fetch a list of [Group.Album] from MediaProvider for the given page key. */
-    fun fetchAlbums(
+    open suspend fun fetchAlbums(
         pageKey: MediaPageKey,
         pageSize: Int,
         contentResolver: ContentResolver,
@@ -360,8 +433,8 @@ open class MediaProviderClient {
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfAlbums(),
-                            prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey(),
+                            prevKey = cursor.getPrevMediaPageKey(),
+                            nextKey = cursor.getNextMediaPageKey(),
                         )
                     }
                         ?: throw IllegalStateException(
@@ -374,7 +447,7 @@ open class MediaProviderClient {
     }
 
     /** Fetch a list of [Media] from MediaProvider for the given page key. */
-    fun fetchAlbumMedia(
+    open suspend fun fetchAlbumMedia(
         albumId: String,
         albumAuthority: String,
         pageKey: MediaPageKey,
@@ -410,8 +483,8 @@ open class MediaProviderClient {
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfMedia(),
-                            prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey(),
+                            prevKey = cursor.getPrevMediaPageKey(),
+                            nextKey = cursor.getNextMediaPageKey(),
                         )
                     }
                         ?: throw IllegalStateException(
@@ -525,6 +598,184 @@ open class MediaProviderClient {
         }
     }
 
+    /**
+     * Fetches a list of search suggestions from MediaProvider filtered by the input prefix string.
+     */
+    suspend fun fetchSearchSuggestions(
+        resolver: ContentResolver,
+        prefix: String,
+        limit: Int,
+        historyLimit: Int,
+        availableProviders: List<Provider>,
+        cancellationSignal: CancellationSignal?,
+    ): List<SearchSuggestion> {
+        try {
+            val input: Bundle =
+                bundleOf(
+                    SearchSuggestionsQuery.PREFIX.key to prefix,
+                    SearchSuggestionsQuery.LIMIT.key to limit,
+                    SearchSuggestionsQuery.HISTORY_LIMIT.key to historyLimit,
+                    MediaQuery.PROVIDERS.key to
+                        ArrayList<String>().apply {
+                            availableProviders.forEach { provider -> add(provider.authority) }
+                        },
+                )
+
+            return resolver
+                .query(SEARCH_SUGGESTIONS_URI, /* projection */ null, input, cancellationSignal)
+                ?.getListOfSearchSuggestions(availableProviders) ?: ArrayList()
+        } catch (e: RuntimeException) {
+            throw RuntimeException("Could not fetch search suggestions", e)
+        }
+    }
+
+    /**
+     * Fetches a list of categories and albums from MediaProvider filtered by the input list of
+     * available providers, mime types and parent category id.
+     */
+    suspend fun fetchCategoriesAndAlbums(
+        pageKey: GroupPageKey,
+        pageSize: Int,
+        contentResolver: ContentResolver,
+        availableProviders: List<Provider>,
+        parentCategoryId: String?,
+        config: PhotopickerConfiguration,
+        cancellationSignal: CancellationSignal?,
+    ): LoadResult<GroupPageKey, Group> {
+        val input: Bundle =
+            bundleOf(
+                MediaQuery.PICKER_ID.key to pageKey.pickerId,
+                MediaQuery.PAGE_SIZE.key to pageSize,
+                MediaQuery.PROVIDERS.key to
+                    ArrayList<String>().apply {
+                        availableProviders.forEach { provider -> add(provider.authority) }
+                    },
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                EXTRA_INTENT_ACTION to config.action,
+                Intent.EXTRA_UID to config.callingPackageUid,
+                CategoryAndAlbumQuery.PARENT_CATEGORY_ID.key to parentCategoryId,
+            )
+        try {
+            return contentResolver
+                .query(
+                    getCategoryUri(parentCategoryId),
+                    /* projection */ null,
+                    input,
+                    cancellationSignal,
+                )
+                .use { cursor ->
+                    cursor?.let {
+                        LoadResult.Page(
+                            data = cursor.getListOfCategoriesAndAlbums(availableProviders),
+                            prevKey = cursor.getPrevGroupPageKey(),
+                            nextKey = cursor.getNextGroupPageKey(),
+                        )
+                    }
+                        ?: throw IllegalStateException(
+                            "Received a null response from Content Provider"
+                        )
+                }
+        } catch (e: RuntimeException) {
+            throw RuntimeException(
+                "Could not fetch categories and albums for parent category $parentCategoryId",
+                e,
+            )
+        }
+    }
+
+    /**
+     * Fetches a list of media sets from MediaProvider filtered by the input list of available
+     * providers, mime types and parent category id.
+     */
+    suspend fun fetchMediaSets(
+        pageKey: GroupPageKey,
+        pageSize: Int,
+        contentResolver: ContentResolver,
+        availableProviders: List<Provider>,
+        parentCategory: Group.Category,
+        config: PhotopickerConfiguration,
+        cancellationSignal: CancellationSignal?,
+    ): LoadResult<GroupPageKey, Group.MediaSet> {
+        val input: Bundle =
+            bundleOf(
+                MediaQuery.PICKER_ID.key to pageKey.pickerId,
+                MediaQuery.PAGE_SIZE.key to pageSize,
+                MediaQuery.PROVIDERS.key to arrayListOf(parentCategory.authority),
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                EXTRA_INTENT_ACTION to config.action,
+                MediaSetsQuery.PARENT_CATEGORY_ID.key to parentCategory.id,
+                MediaSetsQuery.PARENT_CATEGORY_AUTHORITY.key to parentCategory.authority,
+            )
+        try {
+            return contentResolver
+                .query(MEDIA_SETS_URI, /* projection */ null, input, cancellationSignal)
+                .use { cursor ->
+                    cursor?.let {
+                        LoadResult.Page(
+                            data = cursor.getListOfMediaSets(availableProviders),
+                            prevKey = cursor.getPrevGroupPageKey(),
+                            nextKey = cursor.getNextGroupPageKey(),
+                        )
+                    }
+                        ?: throw IllegalStateException(
+                            "Received a null response from Content Provider"
+                        )
+                }
+        } catch (e: RuntimeException) {
+            throw RuntimeException(
+                "Could not fetch media sets for parent category ${parentCategory.id}",
+                e,
+            )
+        }
+    }
+
+    /**
+     * Fetches a list of media items in a media set from MediaProvider filtered by the input list of
+     * available providers, mime types and parent media set id.
+     */
+    suspend fun fetchMediaSetContents(
+        pageKey: MediaPageKey,
+        pageSize: Int,
+        contentResolver: ContentResolver,
+        parentMediaSet: Group.MediaSet,
+        config: PhotopickerConfiguration,
+        cancellationSignal: CancellationSignal?,
+    ): LoadResult<MediaPageKey, Media> {
+        val input: Bundle =
+            bundleOf(
+                MediaQuery.PICKER_ID.key to pageKey.pickerId,
+                MediaQuery.DATE_TAKEN.key to pageKey.dateTakenMillis,
+                MediaQuery.PAGE_SIZE.key to pageSize,
+                MediaQuery.PROVIDERS.key to arrayListOf(parentMediaSet.authority),
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                EXTRA_INTENT_ACTION to config.action,
+                Intent.EXTRA_UID to config.callingPackageUid,
+                MediaSetContentsQuery.PARENT_MEDIA_SET_PICKER_ID.key to parentMediaSet.pickerId,
+                MediaSetContentsQuery.PARENT_MEDIA_SET_AUTHORITY.key to parentMediaSet.authority,
+            )
+        try {
+            return contentResolver
+                .query(MEDIA_SET_CONTENTS_URI, /* projection */ null, input, cancellationSignal)
+                .use { cursor ->
+                    cursor?.let {
+                        LoadResult.Page(
+                            data = cursor.getListOfMedia(),
+                            prevKey = cursor.getPrevMediaPageKey(),
+                            nextKey = cursor.getNextMediaPageKey(),
+                        )
+                    }
+                        ?: throw IllegalStateException(
+                            "Received a null response from Content Provider"
+                        )
+                }
+        } catch (e: RuntimeException) {
+            throw RuntimeException(
+                "Could not fetch media set contents for parent media set ${parentMediaSet.id}",
+                e,
+            )
+        }
+    }
+
     /**
      * Send a refresh media request to MediaProvider. This is a signal for MediaProvider to refresh
      * its cache, if required.
@@ -553,7 +804,7 @@ open class MediaProviderClient {
      * Send a refresh album media request to MediaProvider. This is a signal for MediaProvider to
      * refresh its cache for the given album media, if required.
      */
-    fun refreshAlbumMedia(
+    suspend fun refreshAlbumMedia(
         albumId: String,
         albumAuthority: String,
         providers: List<Provider>,
@@ -571,6 +822,77 @@ open class MediaProviderClient {
         refreshMedia(extras, resolver)
     }
 
+    /**
+     * Send a refresh media sets request to MediaProvider. This is a signal for MediaProvider to
+     * refresh its cache for the given parent category id and authority, if required.
+     */
+    suspend fun refreshMediaSets(
+        contentResolver: ContentResolver,
+        category: Group.Category,
+        config: PhotopickerConfiguration,
+        providers: List<Provider>,
+    ) {
+        val extras =
+            bundleOf(
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                MediaSetsQuery.PARENT_CATEGORY_ID.key to category.id,
+                MediaSetsQuery.PARENT_CATEGORY_AUTHORITY.key to category.authority,
+                MediaQuery.PROVIDERS.key to
+                    ArrayList<String>().apply {
+                        providers.forEach { provider -> add(provider.authority) }
+                    },
+            )
+
+        try {
+            contentResolver.call(
+                MEDIA_PROVIDER_AUTHORITY,
+                MEDIA_SETS_INIT_CALL_METHOD,
+                /* arg */ null,
+                extras,
+            )
+        } catch (e: RuntimeException) {
+            Log.e(TAG, "Could not send refresh media sets call to Media Provider $extras", e)
+        }
+    }
+
+    /**
+     * Send a refresh media set contents request to MediaProvider. This is a signal for
+     * MediaProvider to refresh its cache for the given parent media set id and authority, if
+     * required.
+     */
+    suspend fun refreshMediaSetContents(
+        contentResolver: ContentResolver,
+        mediaSet: Group.MediaSet,
+        config: PhotopickerConfiguration,
+        providers: List<Provider>,
+    ) {
+        val extras =
+            bundleOf(
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                MediaSetContentsQuery.PARENT_MEDIA_SET_PICKER_ID.key to mediaSet.pickerId,
+                MediaSetContentsQuery.PARENT_MEDIA_SET_AUTHORITY.key to mediaSet.authority,
+                MediaQuery.PROVIDERS.key to
+                    ArrayList<String>().apply {
+                        providers.forEach { provider -> add(provider.authority) }
+                    },
+            )
+
+        try {
+            contentResolver.call(
+                MEDIA_PROVIDER_AUTHORITY,
+                MEDIA_SET_CONTENTS_INIT_CALL_METHOD,
+                /* arg */ null,
+                extras,
+            )
+        } catch (e: RuntimeException) {
+            Log.e(
+                TAG,
+                "Could not send refresh media set contents call to Media Provider $extras",
+                e,
+            )
+        }
+    }
+
     /**
      * Creates a search request with the data source.
      *
@@ -582,12 +904,73 @@ open class MediaProviderClient {
      * request and the backend should prepare to handle search results queries for the given search
      * request.
      */
-    fun createSearchRequest(
+    suspend fun createSearchRequest(
         searchRequest: SearchRequest,
         providers: List<Provider>,
         resolver: ContentResolver,
         config: PhotopickerConfiguration,
     ): Int {
+        val extras: Bundle =
+            prepareSearchResultsExtras(
+                searchRequest = searchRequest,
+                providers = providers,
+                config = config,
+            )
+
+        val result: Bundle? =
+            resolver.call(
+                MEDIA_PROVIDER_AUTHORITY,
+                SEARCH_REQUEST_INIT_CALL_METHOD,
+                /* arg */ null,
+                extras,
+            )
+        return checkNotNull(result?.getInt(SEARCH_REQUEST_ID)) {
+            "Search request ID cannot be null"
+        }
+    }
+
+    /**
+     * Notifies the Data Source that the previously known search query is performed again by the
+     * user in the same session.
+     *
+     * This call lets [MediaProvider] know that the user has triggered a known search request again
+     * and the backend should prepare to handle search results queries for the given search request.
+     */
+    suspend fun ensureSearchResults(
+        searchRequest: SearchRequest,
+        searchRequestId: Int,
+        providers: List<Provider>,
+        resolver: ContentResolver,
+        config: PhotopickerConfiguration,
+    ) {
+        val extras: Bundle =
+            prepareSearchResultsExtras(
+                searchRequest = searchRequest,
+                searchRequestId = searchRequestId,
+                providers = providers,
+                config = config,
+            )
+
+        resolver.call(
+            MEDIA_PROVIDER_AUTHORITY,
+            SEARCH_REQUEST_INIT_CALL_METHOD,
+            /* arg */ null,
+            extras,
+        )
+    }
+
+    /**
+     * Creates an extras [Bundle] with the required args for MediaProvider's
+     * [SEARCH_REQUEST_INIT_CALL_METHOD].
+     *
+     * See [createSearchRequest] and [ensureSearchResults].
+     */
+    private fun prepareSearchResultsExtras(
+        searchRequest: SearchRequest,
+        searchRequestId: Int? = null,
+        providers: List<Provider>,
+        config: PhotopickerConfiguration,
+    ): Bundle {
         val extras =
             bundleOf(
                 EXTRA_MIME_TYPES to config.mimeTypes,
@@ -598,6 +981,10 @@ open class MediaProviderClient {
                     },
             )
 
+        if (searchRequestId != null) {
+            extras.putInt(SEARCH_REQUEST_ID, searchRequestId)
+        }
+
         when (searchRequest) {
             is SearchRequest.SearchTextRequest ->
                 extras.putString(SearchRequestInitRequest.SEARCH_TEXT.key, searchRequest.searchText)
@@ -621,14 +1008,44 @@ open class MediaProviderClient {
             }
         }
 
-        val result: Bundle? =
-            resolver.call(
-                MEDIA_PROVIDER_AUTHORITY,
-                SEARCH_REQUEST_INIT_CALL_METHOD,
-                /* arg */ null,
-                extras,
-            )
-        return checkNotNull(result?.getInt(SEARCH_REQUEST_ID), "Search request ID cannot be null")
+        return extras
+    }
+
+    /**
+     * Get available search providers from the Media Provider client using the available
+     * [ContentResolver].
+     *
+     * If the available providers are known at the time of the query, this method will filter the
+     * results of the call so that search providers are a subset of the available providers.
+     *
+     * @param resolver The [ContentResolver] that resolves to the desired instance of MediaProvider.
+     *   (This may resolve in a cross profile instance of MediaProvider).
+     * @param availableProviders
+     */
+    suspend fun fetchSearchProviderAuthorities(
+        resolver: ContentResolver,
+        availableProviders: List<Provider>? = null,
+    ): List<String>? {
+        try {
+            val availableProviderAuthorities: Set<String>? =
+                availableProviders?.map { it.authority }?.toSet()
+            val result: Bundle? =
+                resolver.call(
+                    MEDIA_PROVIDER_AUTHORITY,
+                    GET_SEARCH_PROVIDERS_CALL_METHOD,
+                    /* arg */ null,
+                    /* extras */ null,
+                )
+            return result?.getStringArrayList(SEARCH_PROVIDER_AUTHORITIES)?.filter {
+                availableProviderAuthorities?.contains(it) ?: true
+            }
+        } catch (e: RuntimeException) {
+            // If we can't fetch the available providers, basic functionality of photopicker does
+            // not work. In order to catch this earlier in testing, throw an error instead of
+            // silencing it.
+            Log.e(TAG, "Could not fetch providers with search enabled", e)
+            return null
+        }
     }
 
     /** Creates a list of [Provider] from the given [Cursor]. */
@@ -788,10 +1205,10 @@ open class MediaProviderClient {
     }
 
     /**
-     * Extracts the previous page key from the given [Cursor]. In case the cursor contains the
+     * Extracts the previous media page key from the given [Cursor]. In case the cursor contains the
      * contents of the first page, the previous page key will be null.
      */
-    private fun Cursor.getPrevPageKey(): MediaPageKey? {
+    private fun Cursor.getPrevMediaPageKey(): MediaPageKey? {
         val id: Long = extras.getLong(MediaResponseExtras.PREV_PAGE_ID.key, Long.MIN_VALUE)
         val date: Long =
             extras.getLong(MediaResponseExtras.PREV_PAGE_DATE_TAKEN.key, Long.MIN_VALUE)
@@ -803,10 +1220,10 @@ open class MediaProviderClient {
     }
 
     /**
-     * Extracts the next page key from the given [Cursor]. In case the cursor contains the contents
-     * of the last page, the next page key will be null.
+     * Extracts the next media page key from the given [Cursor]. In case the cursor contains the
+     * contents of the last page, the next page key will be null.
      */
-    private fun Cursor.getNextPageKey(): MediaPageKey? {
+    private fun Cursor.getNextMediaPageKey(): MediaPageKey? {
         val id: Long = extras.getLong(MediaResponseExtras.NEXT_PAGE_ID.key, Long.MIN_VALUE)
         val date: Long =
             extras.getLong(MediaResponseExtras.NEXT_PAGE_DATE_TAKEN.key, Long.MIN_VALUE)
@@ -817,6 +1234,32 @@ open class MediaProviderClient {
         }
     }
 
+    /**
+     * Extracts the previous group page key from the given [Cursor]. In case the cursor contains the
+     * contents of the first page, the previous page key will be null.
+     */
+    private fun Cursor.getPrevGroupPageKey(): GroupPageKey? {
+        val id: Long = extras.getLong(MediaResponseExtras.PREV_PAGE_ID.key, Long.MIN_VALUE)
+        return if (id == Long.MIN_VALUE) {
+            null
+        } else {
+            GroupPageKey(pickerId = id)
+        }
+    }
+
+    /**
+     * Extracts the next group page key from the given [Cursor]. In case the cursor contains the
+     * contents of the last page, the next page key will be null.
+     */
+    private fun Cursor.getNextGroupPageKey(): GroupPageKey? {
+        val id: Long = extras.getLong(MediaResponseExtras.NEXT_PAGE_ID.key, Long.MAX_VALUE)
+        return if (id == Long.MAX_VALUE) {
+            null
+        } else {
+            GroupPageKey(pickerId = id)
+        }
+    }
+
     /**
      * Extracts the before items count from the given [Cursor]. In case the cursor does not contain
      * this value, return null.
@@ -835,6 +1278,8 @@ open class MediaProviderClient {
         if (this.moveToFirst()) {
             do {
                 val albumId = getString(getColumnIndexOrThrow(AlbumResponse.ALBUM_ID.key))
+                val coverUriString =
+                    getString(getColumnIndexOrThrow(AlbumResponse.UNWRAPPED_COVER_URI.key))
                 result.add(
                     Group.Album(
                         id = albumId,
@@ -845,12 +1290,7 @@ open class MediaProviderClient {
                             getLong(getColumnIndexOrThrow(AlbumResponse.DATE_TAKEN.key)),
                         displayName =
                             getString(getColumnIndexOrThrow(AlbumResponse.ALBUM_NAME.key)),
-                        coverUri =
-                            Uri.parse(
-                                getString(
-                                    getColumnIndexOrThrow(AlbumResponse.UNWRAPPED_COVER_URI.key)
-                                )
-                            ),
+                        coverUri = coverUriString?.let { Uri.parse(it) } ?: Uri.parse(""),
                         coverMediaSource =
                             MediaSource.valueOf(
                                 getString(
@@ -865,6 +1305,244 @@ open class MediaProviderClient {
         return result
     }
 
+    /** Creates a list of [SearchSuggestion]-s from the given [Cursor]. */
+    private fun Cursor.getListOfSearchSuggestions(
+        availableProviders: List<Provider>
+    ): List<SearchSuggestion> {
+        val result: MutableList<SearchSuggestion> = mutableListOf<SearchSuggestion>()
+        val authorityToSourceMap: Map<String, MediaSource> =
+            availableProviders.associate { provider -> provider.authority to provider.mediaSource }
+
+        if (this.moveToFirst()) {
+            do {
+                try {
+                    result.add(
+                        SearchSuggestion(
+                            mediaSetId =
+                                getString(
+                                    getColumnIndexOrThrow(
+                                        SearchSuggestionsResponse.MEDIA_SET_ID.key
+                                    )
+                                ),
+                            authority =
+                                getString(
+                                    getColumnIndexOrThrow(SearchSuggestionsResponse.AUTHORITY.key)
+                                ),
+                            displayText =
+                                getString(
+                                    getColumnIndexOrThrow(SearchSuggestionsResponse.SEARCH_TEXT.key)
+                                ),
+                            type =
+                                getSearchSuggestionType(
+                                    getString(
+                                        getColumnIndexOrThrow(
+                                            SearchSuggestionsResponse.SUGGESTION_TYPE.key
+                                        )
+                                    )
+                                ),
+                            icon =
+                                this.getIcon(
+                                    authorityToSourceMap,
+                                    SearchSuggestionsResponse.COVER_MEDIA_URI.key,
+                                ),
+                        )
+                    )
+                } catch (e: RuntimeException) {
+                    Log.e(TAG, "Received an invalid search suggestion. Skipping it.", e)
+                }
+            } while (moveToNext())
+        }
+
+        return result
+    }
+
+    /** Creates a list of [Group.Category]-s and [Group.Album]-s from the given [Cursor]. */
+    private fun Cursor.getListOfCategoriesAndAlbums(
+        availableProviders: List<Provider>
+    ): List<Group> {
+        val result: MutableList<Group> = mutableListOf<Group>()
+        val authorityToSourceMap: Map<String, MediaSource> =
+            availableProviders.associate { provider -> provider.authority to provider.mediaSource }
+
+        if (this.moveToFirst()) {
+            do {
+                try {
+                    val groupType = getString(getColumnIndexOrThrow(GroupResponse.MEDIA_GROUP.key))
+                    when (groupType) {
+                        GroupType.CATEGORY.name -> {
+                            val icons: List<Icon> =
+                                listOf<Icon?>(
+                                        this.getIcon(
+                                            authorityToSourceMap,
+                                            GroupResponse.UNWRAPPED_COVER_URI.key,
+                                        ),
+                                        this.getIcon(
+                                            authorityToSourceMap,
+                                            GroupResponse.ADDITIONAL_UNWRAPPED_COVER_URI_1.key,
+                                        ),
+                                        this.getIcon(
+                                            authorityToSourceMap,
+                                            GroupResponse.ADDITIONAL_UNWRAPPED_COVER_URI_2.key,
+                                        ),
+                                        this.getIcon(
+                                            authorityToSourceMap,
+                                            GroupResponse.ADDITIONAL_UNWRAPPED_COVER_URI_3.key,
+                                        ),
+                                    )
+                                    .filterNotNull()
+
+                            result.add(
+                                Group.Category(
+                                    id =
+                                        getString(
+                                            getColumnIndexOrThrow(GroupResponse.GROUP_ID.key)
+                                        ),
+                                    pickerId =
+                                        getLong(getColumnIndexOrThrow(GroupResponse.PICKER_ID.key)),
+                                    authority =
+                                        getString(
+                                            getColumnIndexOrThrow(GroupResponse.AUTHORITY.key)
+                                        ),
+                                    displayName =
+                                        getString(
+                                            getColumnIndexOrThrow(GroupResponse.DISPLAY_NAME.key)
+                                        ),
+                                    categoryType =
+                                        KeyToCategoryType[
+                                            getString(
+                                                getColumnIndexOrThrow(
+                                                    GroupResponse.CATEGORY_TYPE.key
+                                                )
+                                            )]
+                                            ?: throw IllegalArgumentException(
+                                                "Could not recognize category type"
+                                            ),
+                                    icons = icons,
+                                    isLeafCategory =
+                                        getInt(
+                                            getColumnIndexOrThrow(
+                                                GroupResponse.IS_LEAF_CATEGORY.key
+                                            )
+                                        ) == 1,
+                                )
+                            )
+                        }
+
+                        GroupType.ALBUM.name -> {
+                            val coverUriString =
+                                getString(
+                                    getColumnIndexOrThrow(GroupResponse.UNWRAPPED_COVER_URI.key)
+                                )
+                            val coverUri = coverUriString?.let { Uri.parse(it) } ?: Uri.parse("")
+
+                            result.add(
+                                Group.Album(
+                                    id =
+                                        getString(
+                                            getColumnIndexOrThrow(GroupResponse.GROUP_ID.key)
+                                        ),
+                                    pickerId =
+                                        getLong(getColumnIndexOrThrow(GroupResponse.PICKER_ID.key)),
+                                    authority =
+                                        getString(
+                                            getColumnIndexOrThrow(GroupResponse.AUTHORITY.key)
+                                        ),
+                                    dateTakenMillisLong =
+                                        Long.MAX_VALUE, // This is not used and will soon be
+                                    // obsolete
+                                    displayName =
+                                        getString(
+                                            getColumnIndexOrThrow(GroupResponse.DISPLAY_NAME.key)
+                                        ),
+                                    coverUri = coverUri,
+                                    coverMediaSource =
+                                        coverUri?.let {
+                                            authorityToSourceMap[coverUri.getAuthority()]
+                                        } ?: MediaSource.LOCAL,
+                                )
+                            )
+                        }
+
+                        else -> {
+                            Log.w(TAG, "Invalid group type: $groupType")
+                        }
+                    }
+                } catch (e: RuntimeException) {
+                    Log.w(TAG, "Could not extract category or album from cursor, skipping it", e)
+                }
+            } while (moveToNext())
+        }
+
+        return result
+    }
+
+    /** Creates a list of [Group.MediaSet]-s from the given [Cursor]. */
+    private fun Cursor.getListOfMediaSets(
+        availableProviders: List<Provider>
+    ): List<Group.MediaSet> {
+        val result: MutableList<Group.MediaSet> = mutableListOf<Group.MediaSet>()
+        val authorityToSourceMap: Map<String, MediaSource> =
+            availableProviders.associate { provider -> provider.authority to provider.mediaSource }
+
+        if (this.moveToFirst()) {
+            do {
+                try {
+                    result.add(
+                        Group.MediaSet(
+                            id = getString(getColumnIndexOrThrow(GroupResponse.GROUP_ID.key)),
+                            pickerId = getLong(getColumnIndexOrThrow(GroupResponse.PICKER_ID.key)),
+                            authority =
+                                getString(getColumnIndexOrThrow(GroupResponse.AUTHORITY.key)),
+                            displayName =
+                                getString(getColumnIndexOrThrow(GroupResponse.DISPLAY_NAME.key)),
+                            icon =
+                                this.getIcon(
+                                    authorityToSourceMap,
+                                    GroupResponse.UNWRAPPED_COVER_URI.key,
+                                ) ?: Icon(uri = Uri.parse(""), mediaSource = MediaSource.LOCAL),
+                        )
+                    )
+                } catch (e: RuntimeException) {
+                    Log.w(TAG, "Could not extract media set from cursor, skipping it", e)
+                }
+            } while (moveToNext())
+        }
+
+        return result
+    }
+
+    /** Creates an [Icon] object from the current [Cursor] row. If an error occurs, returns null. */
+    private fun Cursor.getIcon(
+        authorityToSourceMap: Map<String, MediaSource>,
+        columnName: String,
+    ): Icon? {
+        var unwrappedUriString: String? = null
+
+        try {
+            unwrappedUriString = getString(getColumnIndexOrThrow(columnName))
+        } catch (e: RuntimeException) {
+            Log.e(TAG, "Could not get unwrapped uri $unwrappedUriString from cursor", e)
+        }
+
+        return unwrappedUriString?.let {
+            val unwrappedUri: Uri = Uri.parse(unwrappedUriString)
+            val authority: String? = unwrappedUri.getAuthority()
+            val mediaSource: MediaSource = authorityToSourceMap[authority] ?: MediaSource.LOCAL
+            val icon = Icon(unwrappedUri, mediaSource)
+            icon
+        }
+    }
+
+    /** Convert the input search suggestion type string to enum */
+    private fun getSearchSuggestionType(stringSuggestionType: String?): SearchSuggestionType {
+        requireNotNull(stringSuggestionType) { "Suggestion type is null" }
+
+        return KeyToSearchSuggestionType[stringSuggestionType]
+            ?: throw IllegalArgumentException(
+                "Unrecognized search suggestion type $stringSuggestionType"
+            )
+    }
+
     /**
      * Send a refresh [Media] request to MediaProvider with the prepared input args. This is a
      * signal for MediaProvider to refresh its cache, if required.
diff --git a/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt b/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt
index a23b139a2..a151b70b4 100644
--- a/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt
+++ b/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt
@@ -16,7 +16,7 @@
 
 package com.android.photopicker.data
 
-import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.GlobalSearchState
 
 /** Class responsible to fetch all the required data before feature initialization */
 interface PrefetchDataService {
@@ -24,5 +24,9 @@ interface PrefetchDataService {
         val TAG: String = "PrefetchDataService"
     }
 
-    suspend fun getSearchState(): SearchEnabledState
+    /**
+     * Get the global search state from the Data Source. The global search state refers to the
+     * search state of all providers in all user profiles.
+     */
+    suspend fun getGlobalSearchState(): GlobalSearchState
 }
diff --git a/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt b/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt
index 2d2044ba5..732cd2c16 100644
--- a/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt
+++ b/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt
@@ -16,11 +16,80 @@
 
 package com.android.photopicker.data
 
-import com.android.photopicker.features.search.model.SearchEnabledState
+import android.content.Context
+import android.util.Log
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.core.user.UserProfile
+import com.android.photopicker.features.search.model.GlobalSearchState
+import com.android.photopicker.features.search.model.GlobalSearchStateInfo
+import com.android.photopicker.util.mapOfDeferredWithTimeout
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
 
-class PrefetchDataServiceImpl() : PrefetchDataService {
+/** Implementation of [PrefetchDataService] that typically fetches data from MediaProvider. */
+class PrefetchDataServiceImpl(
+    val mediaProviderClient: MediaProviderClient,
+    val userMonitor: UserMonitor,
+    val context: Context,
+    val dispatcher: CoroutineDispatcher,
+    val scope: CoroutineScope,
+) : PrefetchDataService {
 
-    override suspend fun getSearchState(): SearchEnabledState {
-        return SearchEnabledState.DISABLED
+    override suspend fun getGlobalSearchState(): GlobalSearchState {
+        // Create a map of user id to lambda that fetches search provider authorities for that
+        // user.
+        val inputMap: Map<Int, suspend (MediaProviderClient) -> Any?> =
+            userMonitor.userStatus.value.allProfiles
+                .map { profile: UserProfile ->
+                    val lambda: suspend (MediaProviderClient) -> Any? =
+                        { mediaProviderClient: MediaProviderClient ->
+                            mediaProviderClient.fetchSearchProviderAuthorities(
+                                context
+                                    .createPackageContextAsUser(
+                                        context.packageName, /* flags */
+                                        0,
+                                        profile.handle,
+                                    )
+                                    .contentResolver
+                            )
+                        }
+                    profile.identifier to lambda
+                }
+                .toMap()
+
+        // Get a map of user id to Deferred task that fetches search provider authorities for
+        // that user in parallel with a timeout.
+        val deferredMap: Map<Int, Deferred<Any?>> =
+            mapOfDeferredWithTimeout(
+                inputMap = inputMap,
+                input = mediaProviderClient,
+                timeoutMillis = 150L,
+                backgroundScope = scope,
+                dispatcher = dispatcher,
+            )
+
+        // Await all the deferred tasks and create a map of user id to the search provider
+        // authorities.
+        @Suppress("UNCHECKED_CAST")
+        val globalSearchProviders: Map<Int, List<String>?> =
+            deferredMap
+                .map {
+                    val searchProviders: Any? = it.value.await()
+                    it.key to if (searchProviders is List<*>?) searchProviders else null
+                }
+                .toMap() as Map<Int, List<String>?>
+
+        val globalSearchStateInfo =
+            GlobalSearchStateInfo(
+                globalSearchProviders,
+                userMonitor.userStatus.value.activeUserProfile.identifier,
+            )
+        Log.d(
+            PrefetchDataService.TAG,
+            "Global search providers available are $globalSearchProviders. " +
+                "Search state is $globalSearchStateInfo.state",
+        )
+        return globalSearchStateInfo.state
     }
 }
diff --git a/photopicker/src/com/android/photopicker/data/UriHelper.kt b/photopicker/src/com/android/photopicker/data/UriHelper.kt
index b8312d7c0..8e1a3dffa 100644
--- a/photopicker/src/com/android/photopicker/data/UriHelper.kt
+++ b/photopicker/src/com/android/photopicker/data/UriHelper.kt
@@ -23,14 +23,18 @@ import android.provider.MediaStore
 /** Provides URI constants and helper functions. */
 internal const val MEDIA_PROVIDER_AUTHORITY = MediaStore.AUTHORITY
 private const val UPDATE_PATH_SEGMENT = "update"
-private const val AVAILABLE_PROVIDERS_PATH_SEGMENT = "available_providers"
-private const val COLLECTION_INFO_SEGMENT = "collection_info"
-private const val MEDIA_PATH_SEGMENT = "media"
-private const val ALBUM_PATH_SEGMENT = "album"
-private const val MEDIA_GRANTS_COUNT_PATH_SEGMENT = "media_grants_count"
+const val AVAILABLE_PROVIDERS_PATH_SEGMENT = "available_providers"
+const val COLLECTION_INFO_SEGMENT = "collection_info"
+const val MEDIA_PATH_SEGMENT = "media"
+const val ALBUM_PATH_SEGMENT = "album"
+const val MEDIA_GRANTS_COUNT_PATH_SEGMENT = "media_grants_count"
 private const val PREVIEW_PATH_SEGMENT = "preview"
-private const val PRE_SELECTION_URI_PATH_SEGMENT = "pre_selection"
-private const val SEARCH_MEDIA_PATH_SEGMENT = "search_media"
+const val PRE_SELECTION_URI_PATH_SEGMENT = "pre_selection"
+const val SEARCH_MEDIA_PATH_SEGMENT = "search_media"
+const val SEARCH_SUGGESTIONS_PATH_SEGMENT = "search_suggestions"
+const val CATEGORIES_PATH_SEGMENT = "categories"
+const val MEDIA_SETS_PATH_SEGMENT = "media_sets"
+const val MEDIA_SET_CONTENTS_PATH_SEGMENT = "media_set_contents"
 
 const val PICKER_SEGMENT = "picker"
 const val PICKER_TRANSCODED_SEGMENT = "picker_transcoded"
@@ -105,6 +109,19 @@ fun getAlbumMediaUri(albumId: String): Uri {
     return ALBUM_URI.buildUpon().apply { appendPath(albumId) }.build()
 }
 
+val SEARCH_SUGGESTIONS_URI: Uri =
+    pickerUri.buildUpon().apply { appendPath(SEARCH_SUGGESTIONS_PATH_SEGMENT) }.build()
+
+/** URI that receives [ContentProvider] change notifications for search result updates. */
+val SEARCH_RESULTS_UPDATE_URI: Uri =
+    pickerUri
+        .buildUpon()
+        .apply {
+            appendPath(SEARCH_MEDIA_PATH_SEGMENT)
+            appendPath(UPDATE_PATH_SEGMENT)
+        }
+        .build()
+
 fun getSearchResultsMediaUri(searchRequestId: Int): Uri {
     return pickerUri
         .buildUpon()
@@ -114,3 +131,34 @@ fun getSearchResultsMediaUri(searchRequestId: Int): Uri {
         }
         .build()
 }
+
+fun getCategoryUri(parentCategoryId: String?): Uri {
+    return pickerUri
+        .buildUpon()
+        .apply {
+            appendPath(CATEGORIES_PATH_SEGMENT)
+            parentCategoryId?.let { appendPath(parentCategoryId) }
+        }
+        .build()
+}
+
+val MEDIA_SETS_URI = pickerUri.buildUpon().appendPath(MEDIA_SETS_PATH_SEGMENT).build()
+val MEDIA_SETS_UPDATE_URI =
+    pickerUri
+        .buildUpon()
+        .apply {
+            appendPath(MEDIA_SETS_PATH_SEGMENT)
+            appendPath(UPDATE_PATH_SEGMENT)
+        }
+        .build()
+
+val MEDIA_SET_CONTENTS_URI =
+    pickerUri.buildUpon().appendPath(MEDIA_SET_CONTENTS_PATH_SEGMENT).build()
+val MEDIA_SET_CONTENT_UPDATE_URI =
+    pickerUri
+        .buildUpon()
+        .apply {
+            appendPath(MEDIA_SET_CONTENTS_PATH_SEGMENT)
+            appendPath(UPDATE_PATH_SEGMENT)
+        }
+        .build()
diff --git a/photopicker/src/com/android/photopicker/data/model/CategoryType.kt b/photopicker/src/com/android/photopicker/data/model/CategoryType.kt
new file mode 100644
index 000000000..c84d113e1
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/data/model/CategoryType.kt
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data.model
+
+import android.provider.CloudMediaProviderContract
+
+/** Contains all the category types that are handled by the Picker UI. */
+enum class CategoryType(val key: String) {
+    PEOPLE_AND_PETS(CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS),
+    USER_ABLUMS(CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_USER_ALBUMS),
+}
+
+/** A map of all Key -> [CategoryType] available. */
+val KeyToCategoryType: Map<String, CategoryType> =
+    CategoryType.entries.associateBy { enum -> enum.key }
diff --git a/photopicker/src/com/android/photopicker/data/model/Group.kt b/photopicker/src/com/android/photopicker/data/model/Group.kt
index b3791f452..d88b4214c 100644
--- a/photopicker/src/com/android/photopicker/data/model/Group.kt
+++ b/photopicker/src/com/android/photopicker/data/model/Group.kt
@@ -20,12 +20,13 @@ import android.net.Uri
 import android.os.Parcel
 import android.os.Parcelable
 import com.android.photopicker.core.glide.GlideLoadable
+import com.android.photopicker.core.glide.ParcelableGlideLoadable
 import com.android.photopicker.core.glide.Resolution
 import com.bumptech.glide.load.DataSource
 import com.bumptech.glide.signature.ObjectKey
 
 /** Holds metadata for a group of media items. */
-sealed interface Group : GlideLoadable, Parcelable {
+sealed interface Group : Parcelable {
     /** Unique identifier for this group */
     val id: String
 
@@ -44,7 +45,7 @@ sealed interface Group : GlideLoadable, Parcelable {
         val displayName: String,
         val coverUri: Uri,
         val coverMediaSource: MediaSource,
-    ) : Group {
+    ) : Group, GlideLoadable {
         override fun getSignature(resolution: Resolution): ObjectKey {
             return ObjectKey("${coverUri}_$resolution")
         }
@@ -60,10 +61,6 @@ sealed interface Group : GlideLoadable, Parcelable {
             }
         }
 
-        override fun getTimestamp(): Long {
-            return dateTakenMillisLong
-        }
-
         override fun describeContents(): Int {
             return 0
         }
@@ -102,4 +99,120 @@ sealed interface Group : GlideLoadable, Parcelable {
             }
         }
     }
+
+    /**
+     * Holds metadata for a category item. It is a type of a [Group] object which can either hold
+     * other categories or media sets.
+     */
+    data class Category(
+        /** This is the ID provided by the [Provider] of this data */
+        override val id: String,
+
+        /** This is the Picker ID generated in Picker Backend */
+        val pickerId: Long,
+        /** Authority of the source [Provider]. */
+        val authority: String,
+        val displayName: String?,
+        val categoryType: CategoryType,
+        val icons: List<ParcelableGlideLoadable>,
+        val isLeafCategory: Boolean,
+    ) : Group {
+
+        override fun describeContents(): Int {
+            return 0
+        }
+
+        /** Implemented for [Parcelable], and handles all the common attributes. */
+        override fun writeToParcel(out: Parcel, flags: Int) {
+            out.writeString(id)
+            out.writeLong(pickerId)
+            out.writeString(authority)
+            out.writeString(displayName)
+            out.writeString(categoryType.name)
+            out.writeParcelableList(icons, /* flags */ 0)
+            out.writeBoolean(isLeafCategory)
+        }
+
+        companion object CREATOR : Parcelable.Creator<Category> {
+
+            override fun createFromParcel(parcel: Parcel): Category {
+                @Suppress("DEPRECATION") // For backward-compatibility
+                return Category(
+                    id = parcel.readString() ?: "",
+                    pickerId = parcel.readLong(),
+                    authority = parcel.readString() ?: "",
+                    displayName = parcel.readString(),
+                    categoryType =
+                        CategoryType.valueOf(
+                            parcel.readString() ?: CategoryType.PEOPLE_AND_PETS.name
+                        ),
+                    icons =
+                        arrayListOf<ParcelableGlideLoadable>().apply {
+                            parcel.readParcelableList(
+                                this,
+                                ParcelableGlideLoadable::class.java.classLoader,
+                            )
+                        },
+                    isLeafCategory = parcel.readBoolean(),
+                )
+            }
+
+            override fun newArray(size: Int): Array<Category?> {
+                return arrayOfNulls(size)
+            }
+        }
+    }
+
+    /**
+     * Holds metadata for a media set item. It is a type of a [Group] object which contains media
+     * items.
+     *
+     * It is very similar to albums because they both contain media items, but it's a bit more
+     * generic and meant to handle a wide range of use cases.
+     */
+    data class MediaSet(
+        /** This is the ID provided by the [Provider] of this data */
+        override val id: String,
+
+        /** This is the Picker ID generated in Picker Backend */
+        val pickerId: Long,
+        /** Authority of the source [Provider]. */
+        val authority: String,
+        val displayName: String?,
+        val icon: ParcelableGlideLoadable,
+    ) : Group {
+
+        override fun describeContents(): Int {
+            return 0
+        }
+
+        /** Implemented for [Parcelable], and handles all the common attributes. */
+        override fun writeToParcel(out: Parcel, flags: Int) {
+            out.writeString(id)
+            out.writeLong(pickerId)
+            out.writeString(authority)
+            out.writeString(displayName)
+            out.writeParcelable(icon, /* flags */ 0)
+        }
+
+        companion object CREATOR : Parcelable.Creator<MediaSet> {
+
+            override fun createFromParcel(parcel: Parcel): MediaSet {
+                @Suppress("DEPRECATION") // For backward-compatibility
+                return MediaSet(
+                    id = parcel.readString() ?: "",
+                    pickerId = parcel.readLong(),
+                    authority = parcel.readString() ?: "",
+                    displayName = parcel.readString(),
+                    icon =
+                        parcel.readParcelable(ParcelableGlideLoadable::class.java.classLoader)
+                            ?: Icon(uri = Uri.parse(""), mediaSource = MediaSource.LOCAL),
+                )
+            }
+
+            override fun newArray(size: Int): Array<MediaSet?> {
+                return arrayOfNulls(size)
+            }
+        }
+    }
 }
diff --git a/photopicker/src/com/android/photopicker/data/model/GroupPageKey.kt b/photopicker/src/com/android/photopicker/data/model/GroupPageKey.kt
new file mode 100644
index 000000000..3b3223b1a
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/data/model/GroupPageKey.kt
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data.model
+
+/**
+ * Defined a page key for [Group]. Page key should be able to uniquely identify a page of results in
+ * the data source.
+ */
+data class GroupPageKey(
+    /**
+     * This is the Picker ID auto-generated in the data source (which is likely Picker DB). The
+     * default values represent the values of the first page key.
+     */
+    val pickerId: Long = Long.MIN_VALUE
+)
diff --git a/photopicker/src/com/android/photopicker/data/model/Icon.kt b/photopicker/src/com/android/photopicker/data/model/Icon.kt
new file mode 100644
index 000000000..202ba3f37
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/data/model/Icon.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data.model
+
+import android.net.Uri
+import android.os.Parcel
+import android.os.Parcelable
+import com.android.photopicker.core.glide.GlideLoadable
+import com.android.photopicker.core.glide.ParcelableGlideLoadable
+import com.android.photopicker.core.glide.Resolution
+import com.bumptech.glide.load.DataSource
+import com.bumptech.glide.signature.ObjectKey
+
+/**
+ * An icon is a simple object which points to a media resource can be loaded by [Glide] because it
+ * implements the [GlideLoadable] interface.
+ */
+data class Icon(val uri: Uri, val mediaSource: MediaSource) : ParcelableGlideLoadable {
+    override fun getSignature(resolution: Resolution): ObjectKey {
+        return ObjectKey("${uri}_$resolution")
+    }
+
+    override fun getLoadableUri(): Uri {
+        return uri
+    }
+
+    override fun getDataSource(): DataSource {
+        return when (mediaSource) {
+            MediaSource.LOCAL -> DataSource.LOCAL
+            MediaSource.REMOTE -> DataSource.REMOTE
+        }
+    }
+
+    override fun describeContents(): Int {
+        return 0
+    }
+
+    override fun writeToParcel(out: Parcel, flags: Int) {
+        out.writeString(uri.toString())
+        out.writeString(mediaSource.name)
+    }
+
+    companion object CREATOR : Parcelable.Creator<Icon> {
+
+        override fun createFromParcel(parcel: Parcel): Icon {
+            return Icon(
+                uri = Uri.parse(parcel.readString() ?: ""),
+                mediaSource = MediaSource.valueOf(parcel.readString() ?: "LOCAL"),
+            )
+        }
+
+        override fun newArray(size: Int): Array<Icon?> {
+            return arrayOfNulls(size)
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/data/model/Media.kt b/photopicker/src/com/android/photopicker/data/model/Media.kt
index 65f227a54..efd5728eb 100644
--- a/photopicker/src/com/android/photopicker/data/model/Media.kt
+++ b/photopicker/src/com/android/photopicker/data/model/Media.kt
@@ -65,6 +65,11 @@ sealed interface Media : GlideLoadable, Grantable, Parcelable, Selectable {
         }
     }
 
+    /** Provide a timestamp for ordering this Media item within a list of other Media items. */
+    fun getTimestamp(): Long {
+        return dateTakenMillisLong
+    }
+
     override fun getSignature(resolution: Resolution): ObjectKey {
         return ObjectKey("${mediaUri}_$resolution")
     }
@@ -80,10 +85,6 @@ sealed interface Media : GlideLoadable, Grantable, Parcelable, Selectable {
         }
     }
 
-    override fun getTimestamp(): Long {
-        return dateTakenMillisLong
-    }
-
     /** Implemented for [Parcelable], but always returns 0 since Media is never a FileDescriptor. */
     override fun describeContents(): Int {
         return 0
diff --git a/photopicker/src/com/android/photopicker/data/paging/AlbumMediaPagingSource.kt b/photopicker/src/com/android/photopicker/data/paging/AlbumMediaPagingSource.kt
index ab63e0567..3b3856764 100644
--- a/photopicker/src/com/android/photopicker/data/paging/AlbumMediaPagingSource.kt
+++ b/photopicker/src/com/android/photopicker/data/paging/AlbumMediaPagingSource.kt
@@ -71,7 +71,7 @@ class AlbumMediaPagingSource(
                         pageSize,
                         contentResolver,
                         availableProviders,
-                        configuration
+                        configuration,
                     )
                 } catch (e: Exception) {
                     Log.e(TAG, "Could not fetch page from MediaProvider for album $albumId", e)
@@ -86,9 +86,14 @@ class AlbumMediaPagingSource(
                     FeatureToken.CORE.token,
                     configuration.sessionId,
                     /* pageNumber */ 0,
-                    pageSize
+                    pageSize,
                 )
             )
+
+            Log.d(
+                TAG,
+                "Received ${albumMediaFetchResult.data.size} album media items from the data source.",
+            )
         }
 
         return albumMediaFetchResult
diff --git a/photopicker/src/com/android/photopicker/data/paging/AlbumPagingSource.kt b/photopicker/src/com/android/photopicker/data/paging/AlbumPagingSource.kt
index 60c5dc34d..31bc33d6f 100644
--- a/photopicker/src/com/android/photopicker/data/paging/AlbumPagingSource.kt
+++ b/photopicker/src/com/android/photopicker/data/paging/AlbumPagingSource.kt
@@ -65,7 +65,7 @@ class AlbumPagingSource(
                         pageSize,
                         contentResolver,
                         availableProviders,
-                        configuration
+                        configuration,
                     )
                 } catch (e: Exception) {
                     Log.e(TAG, "Could not fetch page from Media provider", e)
@@ -81,9 +81,11 @@ class AlbumPagingSource(
                     FeatureToken.CORE.token,
                     configuration.sessionId,
                     /* pageNumber */ 0,
-                    pageSize
+                    pageSize,
                 )
             )
+
+            Log.d(TAG, "Received ${albumFetchResult.data.size} album items from the data source.")
         }
         return albumFetchResult
     }
diff --git a/photopicker/src/com/android/photopicker/data/paging/MediaPagingSource.kt b/photopicker/src/com/android/photopicker/data/paging/MediaPagingSource.kt
index d8bf7bcde..5cf60ab32 100644
--- a/photopicker/src/com/android/photopicker/data/paging/MediaPagingSource.kt
+++ b/photopicker/src/com/android/photopicker/data/paging/MediaPagingSource.kt
@@ -72,7 +72,7 @@ class MediaPagingSource(
                             currentSelection,
                             currentDeSelection,
                             // only true for first page or refreshes.
-                            /* isFirstPage */ (params.key == null)
+                            /* isFirstPage */ (params.key == null),
                         )
                     } else {
                         mediaProviderClient.fetchMedia(
@@ -80,7 +80,7 @@ class MediaPagingSource(
                             pageSize,
                             contentResolver,
                             availableProviders,
-                            configuration
+                            configuration,
                         )
                     }
                 } catch (e: Exception) {
@@ -97,9 +97,11 @@ class MediaPagingSource(
                     FeatureToken.CORE.token,
                     configuration.sessionId,
                     /* pageNumber */ 0,
-                    pageSize
+                    pageSize,
                 )
             )
+
+            Log.d(TAG, "Received ${mediaFetchResult.data.size} media items from the data source.")
         }
         return mediaFetchResult
     }
diff --git a/photopicker/src/com/android/photopicker/extensions/Flow.kt b/photopicker/src/com/android/photopicker/extensions/Flow.kt
index 11ead4b64..3072de565 100644
--- a/photopicker/src/com/android/photopicker/extensions/Flow.kt
+++ b/photopicker/src/com/android/photopicker/extensions/Flow.kt
@@ -22,6 +22,7 @@ import androidx.paging.map
 import com.android.photopicker.core.components.MediaGridItem
 import com.android.photopicker.core.user.UserProfile
 import com.android.photopicker.core.user.UserStatus
+import com.android.photopicker.data.model.CategoryType
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.data.model.Media
 import java.time.LocalDateTime
@@ -52,6 +53,58 @@ fun Flow<PagingData<Group.Album>>.toMediaGridItemFromAlbum(): Flow<PagingData<Me
     return this.map { pagingData -> pagingData.map { MediaGridItem.AlbumItem(it) } }
 }
 
+/**
+ * An extension function to prepare a flow of [PagingData<MediaSet>] to be provided to the
+ * [MediaGrid] composable, by wrapping all of the [MediaSet] objects in a [MediaGridItem].
+ *
+ * @return A [PagingData<MediaGridItem>] that can be processed further, or provided to the
+ *   [MediaGrid].
+ */
+fun Flow<PagingData<Group.MediaSet>>.toMediaGridItemFromMediaSet():
+    Flow<PagingData<MediaGridItem>> {
+    return this.map { pagingData -> pagingData.map { MediaGridItem.MediaSetItem(it) } }
+}
+
+/**
+ * An extension function to prepare a flow of [PagingData<MediaSet>] for People & Pets category to
+ * be provided to the [MediaGrid] composable, by wrapping all of the [MediaSet] objects in a
+ * [MediaGridItem].
+ *
+ * @return A [PagingData<MediaGridItem>] that can be processed further, or provided to the
+ *   [MediaGrid].
+ */
+fun Flow<PagingData<Group.MediaSet>>.toMediaGridItemFromPeopleMediaSet():
+    Flow<PagingData<MediaGridItem>> {
+    return this.map { pagingData -> pagingData.map { MediaGridItem.PersonMediaSetItem(it) } }
+}
+
+/**
+ * An extension function to prepare a flow of [PagingData<Category>] to be provided to the
+ * [MediaGrid] composable, by wrapping all of the [Category] objects in a [MediaGridItem].
+ *
+ * @return A [PagingData<MediaGridItem>] that can be processed further, or provided to the
+ *   [MediaGrid].
+ */
+fun Flow<PagingData<Group>>.toMediaGridItemFromCategory(
+    category: Group.Category? = null
+): Flow<PagingData<MediaGridItem>> {
+    return this.map { pagingData ->
+        pagingData.map { group ->
+            when (group) {
+                is Group.MediaSet -> {
+                    if (category != null && category.categoryType == CategoryType.PEOPLE_AND_PETS) {
+                        MediaGridItem.PersonMediaSetItem(group)
+                    } else {
+                        MediaGridItem.MediaSetItem(group)
+                    }
+                }
+                is Group.Category -> MediaGridItem.CategoryItem(group)
+                is Group.Album -> MediaGridItem.AlbumItem(group)
+            }
+        }
+    }
+}
+
 /**
  * An extension function which accepts a flow of [PagingData<MediaGridItem.MediaItem>] (the actual
  * [Media] grid representation wrappers) and processes them inserting month separators in between
@@ -92,7 +145,7 @@ fun Flow<PagingData<MediaGridItem.MediaItem>>.insertMonthSeparators(
                 val format =
                     // If the current calendar year is different from the items year, append the
                     // year to to the month string.
-                    if (afterLocalDateTime.getYear() != LocalDateTime.now().getYear()) "MMMM YYYY"
+                    if (afterLocalDateTime.getYear() != LocalDateTime.now().getYear()) "MMMM yyyy"
 
                     // The year is the same, so just use the month's name.
                     else "MMMM"
diff --git a/photopicker/src/com/android/photopicker/extensions/Modifier.kt b/photopicker/src/com/android/photopicker/extensions/Modifier.kt
index a29b5e70e..bb16cb758 100644
--- a/photopicker/src/com/android/photopicker/extensions/Modifier.kt
+++ b/photopicker/src/com/android/photopicker/extensions/Modifier.kt
@@ -20,9 +20,9 @@ import android.os.Build
 import android.view.SurfaceControlViewHost
 import androidx.annotation.RequiresApi
 import androidx.compose.foundation.gestures.Orientation
+import androidx.compose.foundation.gestures.ScrollableState
 import androidx.compose.foundation.gestures.awaitEachGesture
 import androidx.compose.foundation.gestures.awaitFirstDown
-import androidx.compose.foundation.lazy.grid.LazyGridState
 import androidx.compose.runtime.State
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.draw.drawBehind
@@ -94,18 +94,17 @@ fun Modifier.circleBackground(
 }
 
 /**
- * Transfer necessary touch events occurred on Photos/Albums grid to host at runtime in Embedded
- * Photopicker
+ * Transfer necessary touch events on scrollable objects like a grid or list to host at runtime in
+ * Embedded Photopicker
  *
- * @param state the state of Photos/albums grid. If state is null means Photos/Albums grid has not
- *   requested the custom modifier
+ * @param state the state of a scrollable object.
  * @param isExpanded the updates on current status of embedded photopicker
  * @param host the instance of [SurfaceControlViewHost]
  * @return a [Modifier] to transfer the touch gestures at runtime in Embedded photopicker
  */
 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
-fun Modifier.transferGridTouchesToHostInEmbedded(
-    state: LazyGridState,
+fun Modifier.transferScrollableTouchesToHostInEmbedded(
+    state: ScrollableState,
     isExpanded: State<Boolean>,
     host: SurfaceControlViewHost,
 ): Modifier {
@@ -114,38 +113,60 @@ fun Modifier.transferGridTouchesToHostInEmbedded(
 }
 
 /**
- * Transfer necessary touch events occurred outside of Photos/Albums grid to host on runtime in
+ * Transfer necessary touch events occurred outside of scrollable objects to host on runtime in
  * Embedded Photopicker
  *
  * @param host the instance of [SurfaceControlViewHost]
+ * @param pass the PointerEventPass where the gesture needs to be handled. The default
+ *   [PointerEventPass] is set as [PointerEventPass.Initial].
  * @return a [Modifier] to transfer the touch gestures at runtime in Embedded photopicker
  */
 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
-fun Modifier.transferTouchesToHostInEmbedded(host: SurfaceControlViewHost): Modifier {
+fun Modifier.transferTouchesToHostInEmbedded(
+    host: SurfaceControlViewHost,
+    pass: PointerEventPass = PointerEventPass.Initial,
+): Modifier {
     return this then
-        transferTouchesToSurfaceControlViewHost(state = null, isExpanded = null, host = host)
+        transferTouchesToSurfaceControlViewHost(
+            state = null,
+            isExpanded = null,
+            host = host,
+            pass = pass,
+        )
 }
 
 /**
  * Transfer necessary touch events to host on runtime in Embedded Photopicker.
  *
- * This custom modifier has been explicitly applied to four different components - the navigation
- * bar, Album media grid's empty state, Photos grid's empty state and media grid.
- *
- * Todo(b/368021407): Touches should also be transferred into the empty spaces left within the
- * embedded
+ * This custom modifier has been explicitly applied to the box that wraps [PhotopickerMain]
+ * composable and the [mediaGrid] composable that backs all media and group grids in Photopicker
+ * like [PhotoGrid], [SearchResultsGrid] etc.
  *
- * @param state the state of Photos/albums grid. If state is null means Photos/Albums grid has not
- *   requested the custom modifier
+ * @param state the state of the scrollable object like lazy grid or lazy list. If state is null
+ *   means a scrollable object has not requested the custom modifier
  * @param isExpanded the updates on current status of embedded photopicker
  * @param host the instance of [SurfaceControlViewHost]
+ * @param pass the PointerEventPass where the gesture needs to be handled.
+ *
+ * PointerInputChanges traverse though the UI tree in the following passes, in the same order:
+ * 1. Initial: Down the tree from ancestor to descendant. Any touch gestures that need to be
+ *    transferred to the host in the parent, before a child element consumes it, should be handled
+ *    in this pass.
+ * 2. Main: Up the tree from descendant to ancestor. This is the primary path where descendants will
+ *    interact with PointerInputChanges before parents.
+ * 3. Final: Down the tree from ancestor to descendant. Handling any unconsumed touch gestures after
+ *    the Initial and Main pass should happen here.
+ *
+ * The default [PointerEventPass] is set as [PointerEventPass.Initial].
+ *
  * @return a [Modifier] to transfer the touch gestures at runtime in Embedded photopicker
  */
 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
 private fun Modifier.transferTouchesToSurfaceControlViewHost(
-    state: LazyGridState?,
+    state: ScrollableState?,
     isExpanded: State<Boolean>?,
     host: SurfaceControlViewHost,
+    pass: PointerEventPass = PointerEventPass.Initial,
 ): Modifier {
 
     val pointerInputModifier =
@@ -154,31 +175,27 @@ private fun Modifier.transferTouchesToSurfaceControlViewHost(
                 val touchSlop = viewConfiguration.touchSlop
                 val touchSlopDetector = TouchSlopDetector(Orientation.Vertical)
 
-                // This needs to run in the [PointerEventPass.Initial] to ensure that the event
-                // can be handled in the parent, rather than the child.
-                //
-                // This touch handler is a parent of the touch handler the grid is using to monitor
-                // clicks & scroll, so these touches are processed in the first pass, and if they
-                // aren't transferred to the host they will be processed by the grid in the
-                // [PointerEventPass.Main]
-                val down =
-                    awaitFirstDown(requireUnconsumed = false, pass = PointerEventPass.Initial)
+                // Wait for the first pointer touch.
+                val down = awaitFirstDown(requireUnconsumed = false, pass = pass)
                 val pointerId = down.id
 
                 // Now that a down exists set up a loop which processes the touch input and
                 // evaluates if it should be sent to the host.
                 do {
-                    val event = awaitPointerEvent(pass = PointerEventPass.Initial)
+                    // Check if the initial pointer input change was part of a drag gesture.
+                    val event = awaitPointerEvent(pass = pass)
                     val dragEvent = event.changes.firstOrNull { it.id == pointerId }
 
                     // If the dragEvent cannot be found for the pointer, or is consumed elsewhere
                     // cancel this gesture.
                     val canceled = dragEvent?.isConsumed ?: true
 
+                    // If the event is not a dragEvent or it was already consumed,
+                    // stop handling the event.
+                    if (canceled) break
+
                     val postSlopOffset =
-                        if (dragEvent != null)
-                            touchSlopDetector.addPointerInputChange(dragEvent, touchSlop)
-                        else Offset.Unspecified
+                        touchSlopDetector.addPointerInputChange(dragEvent, touchSlop)
 
                     // Once pastTouchSlop check to see if the touch meets the conditions to be
                     // transferred to the host.
@@ -191,21 +208,18 @@ private fun Modifier.transferTouchesToSurfaceControlViewHost(
                         val shouldTransferToHost =
                             when {
 
-                                // When this isn't attached to a grid, all vertical gestures should
-                                // be transferred.
+                                // When this isn't attached to a scrollable object, all vertical
+                                // gestures should be transferred.
                                 state == null -> true
 
-                                // If the grid is collapsed and vertical touchSlop has been passed,
-                                // touches should be transferred.
+                                // If the scrollable object is collapsed and vertical touchSlop has
+                                // been passed, touches should be transferred.
                                 isGridCollapsed -> true
 
-                                // If the grid isExpanded, scrolled to the first item and the
-                                // gesture
-                                // direction was up (to collapse the Photopicker)
+                                // If the scrollable object isExpanded, scrolled to the first item
+                                // and the gesture direction was up (to collapse the Photopicker)
                                 isGridExpanded &&
-                                    (state.firstVisibleItemIndex == 0 &&
-                                        state.firstVisibleItemScrollOffset == 0 &&
-                                        postSlopOffset.y > 0F) -> true
+                                    (!state.canScrollBackward && postSlopOffset.y > 0F) -> true
 
                                 // Otherwise don't transfer
                                 else -> false
diff --git a/photopicker/src/com/android/photopicker/extensions/NavController.kt b/photopicker/src/com/android/photopicker/extensions/NavController.kt
index e5e6c662a..d11f5b479 100644
--- a/photopicker/src/com/android/photopicker/extensions/NavController.kt
+++ b/photopicker/src/com/android/photopicker/extensions/NavController.kt
@@ -25,6 +25,7 @@ import com.android.photopicker.core.navigation.PhotopickerDestinations.PREVIEW_S
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.albumgrid.AlbumGridFeature
+import com.android.photopicker.features.categorygrid.CategoryGridFeature
 import com.android.photopicker.features.preview.PreviewFeature
 
 /**
@@ -40,13 +41,9 @@ fun NavController.navigateToPhotoGrid(navOptions: NavOptions? = null) {
         // Nothing to do. Return early to prevent navigation animations from triggering.
         return
     } else if (
-    // Try to return to the entry that is already on the backstack, so the user's
-    // previous state and scroll position is restored.
-        !this.popBackStack(
-            PHOTO_GRID.route,
-            /* inclusive= */ false,
-            /* saveState = */ false,
-        )
+        // Try to return to the entry that is already on the backstack, so the user's
+        // previous state and scroll position is restored.
+        !this.popBackStack(PHOTO_GRID.route, /* inclusive= */ false, /* saveState= */ false)
     ) {
         // Last resort; PHOTO_GRID isn't on the backstack, then navigate directly.
         this.navigate(PHOTO_GRID.route, navOptions)
@@ -66,10 +63,7 @@ fun NavController.navigateToPreviewSelection(navOptions: NavOptions? = null) {
  *
  * @param media The media item that should be previewed in full resolution.
  */
-fun NavController.navigateToPreviewMedia(
-    media: Media,
-    navOptions: NavOptions? = null,
-) {
+fun NavController.navigateToPreviewMedia(media: Media, navOptions: NavOptions? = null) {
     this.navigate(PREVIEW_MEDIA.route, navOptions)
     // Media object must be parcellized and passed to the new route so it can be loaded.
     // This back stack entry is guaranteed to exist since it was just navigated to.
@@ -91,8 +85,8 @@ fun NavController.navigateToAlbumGrid(navOptions: NavOptions? = null) {
         // Nothing to do. Return early to prevent navigation animations from triggering.
         return
     } else if (
-    // Try to return to the entry that is already on the backstack, so the user's
-    // previous state and scroll position is restored.
+        // Try to return to the entry that is already on the backstack, so the user's
+        // previous state and scroll position is restored.
         !this.popBackStack(
             PhotopickerDestinations.ALBUM_GRID.route,
             /* inclusive= */ false,
@@ -109,7 +103,49 @@ fun NavController.navigateToAlbumGrid(navOptions: NavOptions? = null) {
  *
  * @param album The album for which the media needs to be displayed.
  */
-fun NavController.navigateToAlbumMediaGrid(
+fun NavController.navigateToAlbumMediaGrid(navOptions: NavOptions? = null, album: Group.Album) {
+    this.navigate(PhotopickerDestinations.ALBUM_MEDIA_GRID.route, navOptions)
+
+    // Album object must be parcellized and passed to the new route so it can be loaded.
+    // This back stack entry is guaranteed to exist since it was just navigated to.
+    this.getBackStackEntry(PhotopickerDestinations.ALBUM_MEDIA_GRID.route)
+        .savedStateHandle
+        .set(AlbumGridFeature.ALBUM_KEY, album)
+}
+
+/**
+ * Utility function for navigating to the [PhotopickerDestinations.ALBUM_GRID] route.
+ *
+ * This attempts to reclaim an existing BackStack entry, preserving any previous state that existed.
+ *
+ * If the route is not currently on the BackStack, then this will navigate directly.
+ */
+fun NavController.navigateToCategoryGrid(navOptions: NavOptions? = null) {
+    // First, check to see if the destination is already the current route.
+    if (this.currentDestination?.route == PhotopickerDestinations.ALBUM_GRID.route) {
+        // Nothing to do. Return early to prevent navigation animations from triggering.
+        return
+    } else if (
+        // Try to return to the entry that is already on the backstack, so the user's
+        // previous state and scroll position is restored.
+        !this.popBackStack(
+            PhotopickerDestinations.ALBUM_GRID.route,
+            /* inclusive= */ false,
+            /* saveState = */ true,
+        )
+    ) {
+        // Last resort; ALBUM_GRID for Category isn't on the backstack, then navigate directly.
+        this.navigate(PhotopickerDestinations.ALBUM_GRID.route, navOptions)
+    }
+}
+
+/**
+ * Utility function for navigating to the [PhotopickerDestinations.ALBUM_MEDIA_GRID] route for
+ * categories.
+ *
+ * @param album The album for which the media needs to be displayed.
+ */
+fun NavController.navigateToAlbumMediaGridForCategories(
     navOptions: NavOptions? = null,
     album: Group.Album,
 ) {
@@ -119,5 +155,56 @@ fun NavController.navigateToAlbumMediaGrid(
     // This back stack entry is guaranteed to exist since it was just navigated to.
     this.getBackStackEntry(PhotopickerDestinations.ALBUM_MEDIA_GRID.route)
         .savedStateHandle
-        .set(AlbumGridFeature.ALBUM_KEY, album)
+        .set(CategoryGridFeature.GROUP_KEY, album)
+}
+
+/**
+ * Utility function for navigating to the [PhotopickerDestinations.MEDIA_SET_CONTENT_GRID] route for
+ * categories.
+ *
+ * @param mediaSet The media set for which the media needs to be displayed.
+ */
+fun NavController.navigateToMediaSetContentGrid(
+    navOptions: NavOptions? = null,
+    mediaSet: Group.MediaSet,
+) {
+    this.navigate(PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route, navOptions)
+
+    // Album object must be parcellized and passed to the new route so it can be loaded.
+    // This back stack entry is guaranteed to exist since it was just navigated to.
+    this.getBackStackEntry(PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route)
+        .savedStateHandle
+        .set(CategoryGridFeature.GROUP_KEY, mediaSet)
+}
+
+/**
+ * Utility function for navigating to the [PhotopickerDestinations.MEDIA_SET_GRID] route for
+ * categories.
+ *
+ * @param category The category for which the media set needs to be displayed.
+ */
+fun NavController.navigateToMediaSetGrid(
+    navOptions: NavOptions? = null,
+    category: Group.Category? = null,
+) {
+    if (this.currentDestination?.route == PhotopickerDestinations.MEDIA_SET_GRID.route) {
+        // Nothing to do. Return early to prevent navigation animations from triggering.
+        return
+    } else if (
+        // Try to return to the entry that is already on the backstack, so the user's
+        // previous state and scroll position is restored.
+        !this.popBackStack(
+            PhotopickerDestinations.MEDIA_SET_GRID.route,
+            /* inclusive= */ false,
+            /* saveState = */ true,
+        )
+    ) {
+        // Last resort; MEDIA_SET_GRID isn't on the backstack, then navigate directly.
+        this.navigate(PhotopickerDestinations.MEDIA_SET_GRID.route, navOptions)
+        // Category object must be parcellized and passed to the new route so it can be loaded.
+        // This back stack entry is guaranteed to exist since it was just navigated to.
+        this.getBackStackEntry(PhotopickerDestinations.MEDIA_SET_GRID.route)
+            .savedStateHandle
+            .set(CategoryGridFeature.GROUP_KEY, category)
+    }
 }
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt
index 30bd76dab..a281c5944 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt
@@ -26,20 +26,18 @@ import androidx.compose.material3.Text
 import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
 import androidx.compose.runtime.rememberCoroutineScope
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.semantics
 import androidx.compose.ui.unit.dp
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.paging.compose.collectAsLazyPagingItems
 import com.android.photopicker.R
 import com.android.photopicker.core.components.MediaGridItem
 import com.android.photopicker.core.components.mediaGrid
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
-import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
-import com.android.photopicker.core.embedded.LocalEmbeddedState
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.Telemetry
@@ -81,10 +79,6 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
     val events = LocalEvents.current
     val scope = rememberCoroutineScope()
 
-    val isEmbedded =
-        LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
-    val isExpanded = LocalEmbeddedState.current?.isExpanded ?: false
-
     // Use the expanded layout any time the Width is Medium or larger.
     val isExpandedScreen: Boolean =
         when (LocalWindowSizeClass.current.widthSizeClass) {
@@ -93,6 +87,7 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
             else -> false
         }
 
+    val previouslySelectedItem by viewModel.previouslySelectedItem.collectAsStateWithLifecycle()
     Column(
         modifier =
             Modifier.fillMaxSize().pointerInput(Unit) {
@@ -126,11 +121,7 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
         // the album content for the album that is selected by the user.
         mediaGrid(
             items = items,
-            userScrollEnabled =
-                when (isEmbedded) {
-                    true -> isExpanded
-                    false -> true
-                },
+            focusItem = previouslySelectedItem,
             onItemClick = { item ->
                 if (item is MediaGridItem.AlbumItem) {
                     // Dispatch events to log album related details
@@ -152,6 +143,8 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
                             )
                         )
                     }
+                    // store the album that is being navigated into
+                    viewModel.setPreviouslySelectedItem(item)
                     navController.navigateToAlbumMediaGrid(album = item.album)
                 }
             },
@@ -193,7 +186,6 @@ fun AlbumGridNavButton(modifier: Modifier) {
     val events = LocalEvents.current
     val sessionId = LocalPhotopickerConfiguration.current.sessionId
     val packageUid = LocalPhotopickerConfiguration.current.callingPackageUid ?: -1
-    val contentDescriptionString = stringResource(R.string.photopicker_albums_nav_button_label)
 
     NavigationBarButton(
         onClick = {
@@ -210,7 +202,7 @@ fun AlbumGridNavButton(modifier: Modifier) {
             }
             navController.navigateToAlbumGrid()
         },
-        modifier = modifier.semantics { contentDescription = contentDescriptionString },
+        modifier = modifier,
         isCurrentRoute = { route -> route == PhotopickerDestinations.ALBUM_GRID.route },
     ) {
         Text(stringResource(R.string.photopicker_albums_nav_button_label))
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt
index 8d213df44..7ee75a7e3 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt
@@ -57,7 +57,7 @@ class AlbumGridFeature : PhotopickerUiFeature {
         override fun isEnabled(
             config: PhotopickerConfiguration,
             deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
-        ) = true
+        ) = !config.flags.PICKER_SEARCH_ENABLED
 
         override fun build(featureManager: FeatureManager) = AlbumGridFeature()
 
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridViewModel.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridViewModel.kt
index 2ef86432e..a5be199a2 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridViewModel.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridViewModel.kt
@@ -39,6 +39,8 @@ import dagger.hilt.android.lifecycle.HiltViewModel
 import javax.inject.Inject
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.launch
 
 /**
@@ -71,6 +73,22 @@ constructor(
     // Keep up to 10 pages loaded in memory before unloading pages.
     private val ALBUM_GRID_MAX_ITEMS_IN_MEMORY = ALBUM_GRID_PAGE_SIZE * 10
 
+    private val _previouslySelectedItem = MutableStateFlow<MediaGridItem?>(null)
+    val previouslySelectedItem: StateFlow<MediaGridItem?> = _previouslySelectedItem
+
+    /**
+     * Sets the previously selected album grid item.
+     *
+     * This function updates the [_previouslySelectedItem] with the provided item. The stored item
+     * is used to request focus to that album's cell in the album grid when the user navigates back
+     * from the album media grid.
+     *
+     * @param item The media grid item to store as the previously selected item, or null to reset
+     */
+    fun setPreviouslySelectedItem(item: MediaGridItem?) {
+        _previouslySelectedItem.value = item
+    }
+
     /**
      * Returns [PagingData] of type [MediaGridItem] as a [Flow] containing media for the album
      * represented by [albumId].
@@ -81,7 +99,7 @@ constructor(
                 PagingConfig(
                     pageSize = ALBUM_GRID_PAGE_SIZE,
                     maxSize = ALBUM_GRID_MAX_ITEMS_IN_MEMORY,
-                ),
+                )
             ) {
                 // pagingSource
                 dataService.albumMediaPagingSource(album)
@@ -109,7 +127,7 @@ constructor(
                 PagingConfig(
                     pageSize = ALBUM_GRID_PAGE_SIZE,
                     maxSize = ALBUM_GRID_MAX_ITEMS_IN_MEMORY,
-                ),
+                )
             ) {
                 dataService.albumPagingSource()
             }
@@ -133,7 +151,7 @@ constructor(
     fun handleAlbumMediaGridItemSelection(
         item: Media,
         selectionLimitExceededMessage: String,
-        album: Group.Album
+        album: Group.Album,
     ) {
         // Update the selectable values in the received media item.
         val updatedMediaItem =
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt
index ca112202a..215939dae 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt
@@ -64,7 +64,6 @@ import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.theme.LocalWindowSizeClass
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.extensions.navigateToPreviewMedia
-import com.android.photopicker.extensions.transferTouchesToHostInEmbedded
 import com.android.photopicker.features.preview.PreviewFeature
 import com.android.photopicker.util.LocalLocalizationHelper
 import kotlinx.coroutines.flow.Flow
@@ -137,7 +136,6 @@ private fun AlbumMediaGrid(
     val state = rememberLazyGridState()
     val isEmbedded =
         LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
-    val isExpanded = LocalEmbeddedState.current?.isExpanded ?: false
 
     val host = LocalEmbeddedState.current?.host
     // Container encapsulating the album title followed by the album content in the form of a
@@ -159,7 +157,7 @@ private fun AlbumMediaGrid(
                         if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
                             // In embedded no need to give extra top padding to make empty
                             // state title and body clearly visible in collapse mode (small view)
-                            Modifier.fillMaxWidth().transferTouchesToHostInEmbedded(host = host)
+                            Modifier.fillMaxWidth()
                         } else {
                             // Provide 20% of screen height as empty space above
                             Modifier.fillMaxWidth().padding(top = emptyStatePadding)
@@ -174,11 +172,6 @@ private fun AlbumMediaGrid(
                 mediaGrid(
                     // Album content grid
                     items = items,
-                    userScrollEnabled =
-                        when (isEmbedded) {
-                            true -> isExpanded
-                            false -> true
-                        },
                     isExpandedScreen = isExpandedScreen,
                     selection = selection,
                     onItemClick = { item ->
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/AlbumMediaGrid.kt b/photopicker/src/com/android/photopicker/features/categorygrid/AlbumMediaGrid.kt
new file mode 100644
index 000000000..609772ca1
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/AlbumMediaGrid.kt
@@ -0,0 +1,262 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_CAMERA
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.lazy.grid.rememberLazyGridState
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.outlined.Image
+import androidx.compose.material.icons.outlined.PhotoCamera
+import androidx.compose.material.icons.outlined.PlayCircleOutline
+import androidx.compose.material.icons.outlined.StarOutline
+import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.unit.dp
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.paging.LoadState
+import androidx.paging.PagingData
+import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.modules.utils.build.SdkLevel
+import com.android.photopicker.R
+import com.android.photopicker.core.components.EmptyState
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.components.mediaGrid
+import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.embedded.LocalEmbeddedState
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.features.LocalFeatureManager
+import com.android.photopicker.core.navigation.LocalNavController
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.obtainViewModel
+import com.android.photopicker.core.selection.LocalSelection
+import com.android.photopicker.core.theme.LocalWindowSizeClass
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.extensions.navigateToPreviewMedia
+import com.android.photopicker.features.preview.PreviewFeature
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.launch
+
+/**
+ * Primary composable for drawing the Album content grid on
+ * [PhotopickerDestinations.ALBUM_MEDIA_GRID]
+ *
+ * @param viewModel - A viewModel override for the composable. Normally, this is fetched via hilt
+ *   from the backstack entry by using obtainViewModel()
+ * @param flow - stateflow holding the album for which the media needs to be presented.
+ */
+@Composable
+fun AlbumMediaGrid(
+    flow: StateFlow<Group.Album?>,
+    viewModel: CategoryGridViewModel = obtainViewModel(),
+) {
+    val albumState by flow.collectAsStateWithLifecycle(initialValue = null)
+    val album = albumState
+
+    Column(modifier = Modifier.fillMaxSize()) {
+        when (album) {
+            null -> {}
+            else -> {
+                val albumItems = remember(album) { viewModel.getAlbumMedia(album) }
+                AlbumMediaGrid(album = album, albumItems = albumItems)
+            }
+        }
+    }
+}
+
+/** Initialises all the states and media source required to load media for the input [album]. */
+@Composable
+private fun AlbumMediaGrid(
+    album: Group.Album,
+    albumItems: Flow<PagingData<MediaGridItem>>,
+    viewModel: CategoryGridViewModel = obtainViewModel(),
+) {
+    val featureManager = LocalFeatureManager.current
+    val isPreviewEnabled = remember { featureManager.isFeatureEnabled(PreviewFeature::class.java) }
+
+    val navController = LocalNavController.current
+
+    val items = albumItems.collectAsLazyPagingItems()
+
+    // Collect the selection to notify the mediaGrid of selection changes.
+    val selection by LocalSelection.current.flow.collectAsStateWithLifecycle()
+
+    val selectionLimit = LocalPhotopickerConfiguration.current.selectionLimit
+    val selectionLimitExceededMessage =
+        stringResource(R.string.photopicker_selection_limit_exceeded_snackbar, selectionLimit)
+    val scope = rememberCoroutineScope()
+    val events = LocalEvents.current
+    val configuration = LocalPhotopickerConfiguration.current
+
+    // Use the expanded layout any time the Width is Medium or larger.
+    val isExpandedScreen: Boolean =
+        when (LocalWindowSizeClass.current.widthSizeClass) {
+            WindowWidthSizeClass.Medium -> true
+            WindowWidthSizeClass.Expanded -> true
+            else -> false
+        }
+
+    val state = rememberLazyGridState()
+    val isEmbedded =
+        LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
+
+    val host = LocalEmbeddedState.current?.host
+    // Container encapsulating the album title followed by the album content in the form of a
+    // grid, the content also includes date and month separators.
+    Column(modifier = Modifier.fillMaxSize()) {
+        val isEmptyAndNoMorePages =
+            items.itemCount == 0 &&
+                items.loadState.source.append is LoadState.NotLoading &&
+                items.loadState.source.append.endOfPaginationReached
+
+        when {
+            isEmptyAndNoMorePages -> {
+                val localConfig = LocalConfiguration.current
+                val emptyStatePadding =
+                    remember(localConfig) { (localConfig.screenHeightDp * .20).dp }
+                val (title, body, icon) = getEmptyStateContentForAlbum(album)
+                EmptyState(
+                    modifier =
+                        if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                            // In embedded no need to give extra top padding to make empty
+                            // state title and body clearly visible in collapse mode (small view)
+                            Modifier.fillMaxWidth()
+                        } else {
+                            // Provide 20% of screen height as empty space above
+                            Modifier.fillMaxWidth().padding(top = emptyStatePadding)
+                        },
+                    icon = icon,
+                    title = title,
+                    body = body,
+                )
+            }
+            else -> {
+
+                mediaGrid(
+                    // Album content grid
+                    items = items,
+                    isExpandedScreen = isExpandedScreen,
+                    selection = selection,
+                    onItemClick = { item ->
+                        if (item is MediaGridItem.MediaItem) {
+                            viewModel.handleAlbumMediaGridItemSelection(
+                                item.media,
+                                selectionLimitExceededMessage,
+                                album,
+                            )
+                        }
+                    },
+                    onItemLongPress = { item ->
+                        // If the [PreviewFeature] is enabled, launch the preview route.
+                        if (isPreviewEnabled && item is MediaGridItem.MediaItem) {
+                            // Dispatch UI event to log long pressing the media item
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.PREVIEW.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.PICKER_LONG_SELECT_MEDIA_ITEM,
+                                    )
+                                )
+                            }
+                            // Dispatch UI event to log entry into preview mode
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.PREVIEW.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE,
+                                    )
+                                )
+                            }
+                            navController.navigateToPreviewMedia(item.media)
+                        }
+                    },
+                    state = state,
+                )
+                LaunchedEffect(Unit) {
+                    // Dispatch UI event to log loading of album contents
+                    events.dispatch(
+                        Event.LogPhotopickerUIEvent(
+                            FeatureToken.PHOTO_GRID.token,
+                            configuration.sessionId,
+                            configuration.callingPackageUid ?: -1,
+                            Telemetry.UiEvent.UI_LOADED_ALBUM_CONTENTS,
+                        )
+                    )
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Matches the correct empty state title, message and icon to an album based on it's ID. If the
+ * album's id is not explicitly handled, it will return a generic content for the empty state.
+ *
+ * @return a [Triple] that contains the [Title, Body, Icon] for the empty state.
+ */
+@Composable
+private fun getEmptyStateContentForAlbum(album: Group.Album): Triple<String, String, ImageVector> {
+    return when (album.id) {
+        ALBUM_ID_FAVORITES ->
+            Triple(
+                stringResource(R.string.photopicker_favorites_empty_state_title),
+                stringResource(R.string.photopicker_favorites_empty_state_body),
+                Icons.Outlined.StarOutline,
+            )
+        ALBUM_ID_VIDEOS ->
+            Triple(
+                stringResource(R.string.photopicker_videos_empty_state_title),
+                stringResource(R.string.photopicker_videos_empty_state_body),
+                Icons.Outlined.PlayCircleOutline,
+            )
+        ALBUM_ID_CAMERA ->
+            Triple(
+                stringResource(R.string.photopicker_photos_empty_state_title),
+                stringResource(R.string.photopicker_camera_empty_state_body),
+                Icons.Outlined.PhotoCamera,
+            )
+        // Use the empty state messages of the main photo grid in all other cases.
+        else ->
+            Triple(
+                stringResource(R.string.photopicker_photos_empty_state_title),
+                stringResource(R.string.photopicker_photos_empty_state_body),
+                Icons.Outlined.Image,
+            )
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGrid.kt b/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGrid.kt
new file mode 100644
index 000000000..f6703268c
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGrid.kt
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import androidx.compose.foundation.gestures.detectHorizontalDragGestures
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.lazy.grid.GridCells
+import androidx.compose.foundation.lazy.grid.rememberLazyGridState
+import androidx.compose.material3.Icon
+import androidx.compose.material3.Text
+import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.input.pointer.pointerInput
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.res.vectorResource
+import androidx.compose.ui.semantics.contentDescription
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.photopicker.R
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.components.mediaGrid
+import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.features.LocalFeatureManager
+import com.android.photopicker.core.navigation.LocalNavController
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.obtainViewModel
+import com.android.photopicker.core.theme.LocalWindowSizeClass
+import com.android.photopicker.extensions.navigateToAlbumMediaGridForCategories
+import com.android.photopicker.extensions.navigateToCategoryGrid
+import com.android.photopicker.extensions.navigateToMediaSetGrid
+import com.android.photopicker.extensions.navigateToPhotoGrid
+import com.android.photopicker.features.navigationbar.NavigationBarButton
+import com.android.photopicker.features.photogrid.PhotoGridFeature
+import com.android.photopicker.features.search.SearchFeature
+import kotlinx.coroutines.launch
+
+/** The number of grid cells per row for Phone / narrow layouts */
+private val CELLS_PER_ROW_FOR_CATEGORY_GRID = 2
+
+/** The number of grid cells per row for Tablet / expanded layouts */
+private val CELLS_PER_ROW_EXPANDED_FOR_CATEGORY_GRID = 3
+
+/** The amount of padding to use around each cell in the categories grid. */
+private val MEASUREMENT_HORIZONTAL_CELL_SPACING_CATEGORY_GRID = 16.dp
+
+/**
+ * Primary composable for drawing the main Category Grid on [PhotopickerDestinations.ALBUM_GRID]
+ *
+ * @param viewModel - A viewModel override for the composable. Normally, this is fetched via hilt
+ *   from the backstack entry by using obtainViewModel()
+ */
+@Composable
+fun CategoryGrid(viewModel: CategoryGridViewModel = obtainViewModel()) {
+    val items = viewModel.getCategoriesAndAlbums().collectAsLazyPagingItems()
+    val state = rememberLazyGridState()
+    val navController = LocalNavController.current
+    val featureManager = LocalFeatureManager.current
+    val configuration = LocalPhotopickerConfiguration.current
+    val events = LocalEvents.current
+    val scope = rememberCoroutineScope()
+
+    // Use the expanded layout any time the Width is Medium or larger.
+    val isExpandedScreen: Boolean =
+        when (LocalWindowSizeClass.current.widthSizeClass) {
+            WindowWidthSizeClass.Medium -> true
+            WindowWidthSizeClass.Expanded -> true
+            else -> false
+        }
+
+    val previouslySelectedItem by viewModel.previouslySelectedItem.collectAsStateWithLifecycle()
+    Column(
+        modifier =
+            Modifier.fillMaxSize().pointerInput(Unit) {
+                detectHorizontalDragGestures(
+                    onHorizontalDrag = { _, dragAmount ->
+                        // This may need some additional fine tuning by looking at a certain
+                        // distance in dragAmount, but initial testing suggested this worked
+                        // pretty well as is.
+                        if (dragAmount > 0) {
+                            // Positive is a right swipe
+                            if (featureManager.isFeatureEnabled(PhotoGridFeature::class.java)) {
+                                navController.navigateToPhotoGrid()
+                                // Dispatch UI event to indicate switching to photos tab
+                                scope.launch {
+                                    events.dispatch(
+                                        Event.LogPhotopickerUIEvent(
+                                            FeatureToken.CATEGORY_GRID.token,
+                                            configuration.sessionId,
+                                            configuration.callingPackageUid ?: -1,
+                                            Telemetry.UiEvent.SWITCH_PICKER_TAB,
+                                        )
+                                    )
+                                }
+                            }
+                        }
+                    }
+                )
+            }
+    ) {
+        // Invoke the composable for Category Grid. OnClick uses the navController to navigate to
+        // the category content for the category that is selected by the user.
+        mediaGrid(
+            items = items,
+            focusItem = previouslySelectedItem,
+            onItemClick = { item ->
+                if (item is MediaGridItem.AlbumItem) {
+                    // Dispatch events to log album related details
+                    scope.launch {
+                        events.dispatch(
+                            Event.LogPhotopickerAlbumOpenedUIEvent(
+                                FeatureToken.CATEGORY_GRID.token,
+                                configuration.sessionId,
+                                configuration.callingPackageUid ?: -1,
+                                item.album,
+                            )
+                        )
+                        events.dispatch(
+                            Event.LogPhotopickerUIEvent(
+                                FeatureToken.CATEGORY_GRID.token,
+                                configuration.sessionId,
+                                configuration.callingPackageUid ?: -1,
+                                Telemetry.UiEvent.PICKER_ALBUMS_INTERACTION,
+                            )
+                        )
+                    }
+                    viewModel.setPreviouslySelectedItem(item)
+                    navController.navigateToAlbumMediaGridForCategories(album = item.album)
+                } else if (item is MediaGridItem.CategoryItem) {
+                    scope.launch {
+                        events.dispatch(
+                            Event.LogPhotopickerUIEvent(
+                                FeatureToken.CATEGORY_GRID.token,
+                                configuration.sessionId,
+                                configuration.callingPackageUid ?: -1,
+                                Telemetry.UiEvent.CATEGORY_MEDIA_SETS_OPEN,
+                            )
+                        )
+                    }
+                    viewModel.setPreviouslySelectedItem(item)
+                    navController.navigateToMediaSetGrid(category = item.category)
+                }
+            },
+            isExpandedScreen = isExpandedScreen,
+            columns =
+                when (isExpandedScreen) {
+                    true -> GridCells.Fixed(CELLS_PER_ROW_EXPANDED_FOR_CATEGORY_GRID)
+                    false -> GridCells.Fixed(CELLS_PER_ROW_FOR_CATEGORY_GRID)
+                },
+            selection = emptySet(),
+            gridCellPadding = MEASUREMENT_HORIZONTAL_CELL_SPACING_CATEGORY_GRID,
+            contentPadding = PaddingValues(MEASUREMENT_HORIZONTAL_CELL_SPACING_CATEGORY_GRID),
+            state = state,
+        )
+        LaunchedEffect(Unit) {
+            // Dispatch UI event to denote loading of media categories and albums
+            scope.launch {
+                events.dispatch(
+                    Event.LogPhotopickerUIEvent(
+                        FeatureToken.CATEGORY_GRID.token,
+                        configuration.sessionId,
+                        configuration.callingPackageUid ?: -1,
+                        Telemetry.UiEvent.UI_LOADED_CATEGORIES_AND_ALBUMS,
+                    )
+                )
+            }
+        }
+    }
+}
+
+/**
+ * The navigation button for the main category grid. Composable for
+ * [Location.NAVIGATION_BAR_NAV_BUTTON]
+ */
+@Composable
+fun CategoryButton(modifier: Modifier) {
+    val navController = LocalNavController.current
+    val scope = rememberCoroutineScope()
+    val events = LocalEvents.current
+    val sessionId = LocalPhotopickerConfiguration.current.sessionId
+    val packageUid = LocalPhotopickerConfiguration.current.callingPackageUid ?: -1
+    val featureManager = LocalFeatureManager.current
+    val searchFeatureEnabled = featureManager.isFeatureEnabled(SearchFeature::class.java)
+
+    NavigationBarButton(
+        onClick = {
+            // Dispatch UI event to denote switching to category tab
+            scope.launch {
+                events.dispatch(
+                    Event.LogPhotopickerUIEvent(
+                        FeatureToken.CATEGORY_GRID.token,
+                        sessionId,
+                        packageUid,
+                        Telemetry.UiEvent.SWITCH_PICKER_TAB,
+                    )
+                )
+            }
+            navController.navigateToCategoryGrid()
+        },
+        modifier = modifier,
+        isCurrentRoute = { route -> route == PhotopickerDestinations.ALBUM_GRID.route },
+    ) {
+        when {
+            searchFeatureEnabled -> {
+                Row(verticalAlignment = Alignment.CenterVertically) {
+                    Icon(
+                        imageVector =
+                            ImageVector.vectorResource(R.drawable.photopicker_category_icon),
+                        contentDescription = null,
+                        modifier = Modifier.size(18.dp),
+                    )
+                    Spacer(Modifier.width(8.dp))
+                    Text(
+                        stringResource(R.string.photopicker_categories_nav_button_label),
+                        maxLines = 1, // Limit the text to a single line
+                        overflow = TextOverflow.Ellipsis,
+                    )
+                }
+            }
+            else ->
+                Text(
+                    stringResource(R.string.photopicker_categories_nav_button_label),
+                    maxLines = 1, // Limit the text to a single line
+                    overflow = TextOverflow.Ellipsis,
+                )
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGridFeature.kt b/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGridFeature.kt
new file mode 100644
index 000000000..6bcbddf65
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGridFeature.kt
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import androidx.compose.animation.AnimatedContentTransitionScope
+import androidx.compose.animation.EnterTransition
+import androidx.compose.animation.ExitTransition
+import androidx.compose.animation.slideInHorizontally
+import androidx.compose.animation.slideOutHorizontally
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.navigation.NamedNavArgument
+import androidx.navigation.NavBackStackEntry
+import androidx.navigation.NavDeepLink
+import com.android.photopicker.core.animations.springDefaultEffectOffset
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.RegisteredEventClass
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.features.FeatureRegistration
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.features.Location
+import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
+import com.android.photopicker.core.features.Priority
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.navigation.PhotopickerDestinations.ALBUM_GRID
+import com.android.photopicker.core.navigation.PhotopickerDestinations.ALBUM_MEDIA_GRID
+import com.android.photopicker.core.navigation.PhotopickerDestinations.PHOTO_GRID
+import com.android.photopicker.core.navigation.Route
+import com.android.photopicker.data.model.Group
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.flow.StateFlow
+
+/**
+ * Feature class for the Photopicker's main category grid.
+ *
+ * This feature adds the [CategoryGrid] route and [MediaSet] route.
+ */
+class CategoryGridFeature : PhotopickerUiFeature {
+    companion object Registration : FeatureRegistration {
+        override val TAG: String = "PhotoPickerCategoryGridFeature"
+
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = config.flags.PICKER_SEARCH_ENABLED
+
+        override fun build(featureManager: FeatureManager) = CategoryGridFeature()
+
+        const val GROUP_KEY = "selected_group"
+    }
+
+    override val token = FeatureToken.CATEGORY_GRID.token
+
+    /** Events consumed by the Category grid */
+    override val eventsConsumed = emptySet<RegisteredEventClass>()
+
+    /** Events produced by the Category grid */
+    override val eventsProduced =
+        setOf(
+            Event.ShowSnackbarMessage::class.java,
+            Event.LogPhotopickerUIEvent::class.java,
+            Event.LogPhotopickerAlbumOpenedUIEvent::class.java,
+            Event.LogPhotopickerPageInfo::class.java,
+        )
+
+    override fun registerLocations(): List<Pair<Location, Int>> {
+        return listOf(Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGHEST.priority))
+    }
+
+    override fun registerNavigationRoutes(): Set<Route> {
+        return setOf(
+            // The main grid of the user's category.
+            object : Route {
+                override val route = ALBUM_GRID.route
+                override val initialRoutePriority = Priority.HIGH.priority
+                override val arguments = emptyList<NamedNavArgument>()
+                override val deepLinks = emptyList<NavDeepLink>()
+                override val isDialog = false
+                override val dialogProperties = null
+
+                /*
+                Animations for ALBUM_GRID for CategoryGridFeature
+                - When navigating directly, content will slide IN from the left edge.
+                - When navigating away, content will slide OUT towards the left edge.
+                - When returning from the backstack, content will slide IN from the right edge.
+                - When popping to another route on the backstack, content will slide OUT towards
+                  the left edge.
+                 */
+                override val enterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        if (initialState.destination.route == PHOTO_GRID.route) {
+                            // Positive value to slide left-to-right
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            // Negative value to slide right-to-left
+                            // if previous route was not from PHOTO_GRID.
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+                override val exitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        if (targetState.destination.route == PHOTO_GRID.route) {
+                            // Positive value to slide left-to-right
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            // Negative value to slide right-to-left
+                            // if target route is not PHOTO_GRID
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+                override val popEnterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        if (initialState.destination.route == PHOTO_GRID.route) {
+                            // Positive value to slide left-to-right
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            // Negative value to slide right-to-left
+                            // if previous route was not from PHOTO_GRID.
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+                override val popExitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        if (targetState.destination.route == PHOTO_GRID.route) {
+                            // Positive value to slide left-to-right
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            // Negative value to slide right-to-left
+                            // if target route is not PHOTO_GRID
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+
+                @Composable
+                override fun composable(navBackStackEntry: NavBackStackEntry?) {
+                    CategoryGrid()
+                }
+            },
+            // Grid to show the media sets for the category selected by the user.
+            object : Route {
+                override val route = PhotopickerDestinations.MEDIA_SET_GRID.route
+                override val initialRoutePriority = Priority.MEDIUM.priority
+                override val arguments = emptyList<NamedNavArgument>()
+                override val deepLinks = emptyList<NavDeepLink>()
+                override val isDialog = false
+                override val dialogProperties = null
+
+                /**
+                 * Animations for MEDIA_SET_GRID are by default [EnterTransition.None] for entering
+                 * into view and [ExitTransition.None] while exiting.
+                 */
+                override val enterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        if (
+                            initialState.destination.route !=
+                                PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route
+                        ) {
+                            // Positive value to slide left-to-right
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+                override val exitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        if (
+                            targetState.destination.route !=
+                                PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route
+                        ) {
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+                override val popEnterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        if (
+                            initialState.destination.route !=
+                                PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route
+                        ) {
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+                override val popExitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        if (
+                            targetState.destination.route !=
+                                PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route
+                        ) {
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                        } else {
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
+                        }
+                    }
+
+                @Composable
+                override fun composable(navBackStackEntry: NavBackStackEntry?) {
+                    val flow: StateFlow<Group.Category?> =
+                        checkNotNull(
+                            navBackStackEntry
+                                ?.savedStateHandle
+                                ?.getStateFlow<Group.Category?>(GROUP_KEY, null)
+                        ) {
+                            "Unable to get a savedStateHandle for media set grid"
+                        }
+                    MediaSetGrid(flow)
+                }
+            },
+            // Grid to show the album content for the album selected by the user.
+            object : Route {
+                override val route = ALBUM_MEDIA_GRID.route
+                override val initialRoutePriority = Priority.MEDIUM.priority
+                override val arguments = emptyList<NamedNavArgument>()
+                override val deepLinks = emptyList<NavDeepLink>()
+                override val isDialog = false
+                override val dialogProperties = null
+
+                /**
+                 * Animations for CATEGORY_CONTENT_GRID are by default [EnterTransition.None] for
+                 * entering into view and [ExitTransition.None] while exiting.
+                 */
+                override val enterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        // Positive value to slide left-to-right
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+                override val exitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+                override val popEnterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+                override val popExitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+
+                @Composable
+                override fun composable(navBackStackEntry: NavBackStackEntry?) {
+                    val flow: StateFlow<Group.Album?> =
+                        checkNotNull(
+                            navBackStackEntry
+                                ?.savedStateHandle
+                                ?.getStateFlow<Group.Album?>(GROUP_KEY, null)
+                        ) {
+                            "Unable to get a savedStateHandle for album content grid"
+                        }
+                    AlbumMediaGrid(flow)
+                }
+            },
+            // Grid to show the media set content for the media set selected by the user.
+            object : Route {
+                override val route = PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route
+                override val initialRoutePriority = Priority.MEDIUM.priority
+                override val arguments = emptyList<NamedNavArgument>()
+                override val deepLinks = emptyList<NavDeepLink>()
+                override val isDialog = false
+                override val dialogProperties = null
+
+                /**
+                 * Animations for CATEGORY_CONTENT_GRID are by default [EnterTransition.None] for
+                 * entering into view and [ExitTransition.None] while exiting.
+                 */
+                override val enterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        // Positive value to slide left-to-right
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+                override val exitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+                override val popEnterTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
+                    {
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+                override val popExitTransition:
+                    (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
+                    {
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
+                    }
+
+                @Composable
+                override fun composable(navBackStackEntry: NavBackStackEntry?) {
+                    val flow: StateFlow<Group.MediaSet?> =
+                        checkNotNull(
+                            navBackStackEntry
+                                ?.savedStateHandle
+                                ?.getStateFlow<Group.MediaSet?>(GROUP_KEY, null)
+                        ) {
+                            "Unable to get a savedStateHandle for album content grid"
+                        }
+                    MediaSetContentGrid(flow)
+                }
+            },
+        )
+    }
+
+    @Composable
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
+        when (location) {
+            Location.NAVIGATION_BAR_NAV_BUTTON -> CategoryButton(modifier)
+            else -> {}
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGridViewModel.kt b/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGridViewModel.kt
new file mode 100644
index 000000000..f2cd64c42
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/CategoryGridViewModel.kt
@@ -0,0 +1,249 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.viewModelScope
+import androidx.paging.Pager
+import androidx.paging.PagingConfig
+import androidx.paging.PagingData
+import androidx.paging.cachedIn
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken.CATEGORY_GRID
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.core.selection.SelectionModifiedResult.FAILURE_SELECTION_LIMIT_EXCEEDED
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.model.CategoryType
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.extensions.insertMonthSeparators
+import com.android.photopicker.extensions.toMediaGridItemFromCategory
+import com.android.photopicker.extensions.toMediaGridItemFromMedia
+import com.android.photopicker.extensions.toMediaGridItemFromMediaSet
+import com.android.photopicker.extensions.toMediaGridItemFromPeopleMediaSet
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+import dagger.hilt.android.lifecycle.HiltViewModel
+import javax.inject.Inject
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.launch
+
+/**
+ * The view model for the primary album grid.
+ *
+ * This view model collects the data from [DataService] and caches it in its scope so that loaded
+ * data is saved between navigations so that the composable can maintain list positions when
+ * navigating back and forth between routes.
+ */
+@HiltViewModel
+class CategoryGridViewModel
+@Inject
+constructor(
+    private val scopeOverride: CoroutineScope?,
+    private val selection: Selection<Media>,
+    private val categoryDataService: CategoryDataService,
+    private val dataService: DataService,
+    private val events: Events,
+) : ViewModel() {
+    // Check if a scope override was injected before using the default [viewModelScope]
+    private val scope: CoroutineScope =
+        if (scopeOverride == null) {
+            this.viewModelScope
+        } else {
+            scopeOverride
+        }
+
+    // Request Media in batches of 50 items
+    private val CATEGORY_GRID_PAGE_SIZE = 50
+
+    // Keep up to 10 pages loaded in memory before unloading pages.
+    private val CATEGORY_GRID_MAX_ITEMS_IN_MEMORY = CATEGORY_GRID_PAGE_SIZE * 10
+
+    private val _previouslySelectedItem = MutableStateFlow<MediaGridItem?>(null)
+    val previouslySelectedItem: StateFlow<MediaGridItem?> = _previouslySelectedItem
+
+    /**
+     * Sets the previously selected category grid item.
+     *
+     * This function updates the [_previouslySelectedItem] with the provided item. The stored item
+     * is used to request focus to that album's cell in the album grid when the user navigates back
+     * from the album media grid.
+     *
+     * @param item The media grid item to store as the previously selected item, or null to reset
+     */
+    fun setPreviouslySelectedItem(item: MediaGridItem?) {
+        _previouslySelectedItem.value = item
+    }
+
+    /**
+     * Returns [PagingData] of type [MediaGridItem] as a [Flow] containing media for the album
+     * represented by [albumId].
+     */
+    fun getAlbumMedia(album: Group.Album): Flow<PagingData<MediaGridItem>> {
+        val pagerForAlbumMedia =
+            Pager(
+                PagingConfig(
+                    pageSize = CATEGORY_GRID_PAGE_SIZE,
+                    maxSize = CATEGORY_GRID_MAX_ITEMS_IN_MEMORY,
+                )
+            ) {
+                // pagingSource
+                dataService.albumMediaPagingSource(album)
+            }
+
+        /** Export the data from the pager and prepare it for use in the [AlbumMediaGrid] */
+        val albumMedia =
+            pagerForAlbumMedia.flow
+                .toMediaGridItemFromMedia()
+                .insertMonthSeparators()
+                // After the load and transformations, cache the data in the viewModelScope.
+                // This ensures that the list position and state will be remembered by the MediaGrid
+                // when navigating back to the AlbumGrid route.
+                .cachedIn(scope)
+
+        return albumMedia
+    }
+
+    /**
+     * Returns [PagingData] of type [MediaGridItem] as a [Flow] containing data for user's albums.
+     */
+    fun getCategoriesAndAlbums(category: Group.Category? = null): Flow<PagingData<MediaGridItem>> {
+        val pagerForCategories =
+            Pager(
+                PagingConfig(
+                    pageSize = CATEGORY_GRID_PAGE_SIZE,
+                    maxSize = CATEGORY_GRID_MAX_ITEMS_IN_MEMORY,
+                )
+            ) {
+                when {
+                    category != null -> {
+                        categoryDataService.getCategories(parentCategory = category)
+                    }
+                    else -> {
+                        categoryDataService.getCategories()
+                    }
+                }
+            }
+
+        /** Export the data from the pager and prepare it for use in the [CategoryGrid] */
+        val group =
+            pagerForCategories.flow
+                .toMediaGridItemFromCategory(category)
+                // After the load and transformations, cache the data in the viewModelScope.
+                // This ensures that the list position and state will be remembered by the MediaGrid
+                // when navigating back to the AlbumGrid route.
+                .cachedIn(scope)
+        return group
+    }
+
+    /**
+     * Returns [PagingData] of type [MediaGridItem] as a [Flow] containing media for the mediaset
+     * represented by [mediaset].
+     */
+    fun getMediaSetContent(mediaset: Group.MediaSet): Flow<PagingData<MediaGridItem>> {
+        val pagerForMediaSetContents =
+            Pager(
+                PagingConfig(
+                    pageSize = CATEGORY_GRID_PAGE_SIZE,
+                    maxSize = CATEGORY_GRID_MAX_ITEMS_IN_MEMORY,
+                )
+            ) {
+                categoryDataService.getMediaSetContents(mediaset)
+            }
+
+        return pagerForMediaSetContents.flow
+            .toMediaGridItemFromMedia()
+            .insertMonthSeparators()
+            // After the load and transformations, cache the data in the viewModelScope.
+            // This ensures that the list position and state will be remembered by the MediaGrid
+            // when navigating back to the AlbumGrid route.
+            .cachedIn(scope)
+    }
+
+    /**
+     * Returns [PagingData] of type [MediaGridItem] as a [Flow] containing media for the category
+     * represented by [categoryId].
+     */
+    fun getMediaSets(category: Group.Category): Flow<PagingData<MediaGridItem>> {
+        val pagerForMediaSets =
+            Pager(
+                PagingConfig(
+                    pageSize = CATEGORY_GRID_PAGE_SIZE,
+                    maxSize = CATEGORY_GRID_MAX_ITEMS_IN_MEMORY,
+                )
+            ) {
+                categoryDataService.getMediaSets(category)
+            }
+
+        /** Export the data from the pager and prepare it for use in the [CategoryGrid] */
+        val mediaSets =
+            if (category.categoryType == CategoryType.PEOPLE_AND_PETS) {
+                pagerForMediaSets.flow
+                    .toMediaGridItemFromPeopleMediaSet()
+                    // data should always be cached after all transformations are applied
+                    .cachedIn(scope)
+            } else {
+                pagerForMediaSets.flow
+                    .toMediaGridItemFromMediaSet()
+                    // data should always be cached after all transformations are applied
+                    .cachedIn(scope)
+            }
+        return mediaSets
+    }
+
+    /**
+     * Click handler that is called when items in the grid are clicked. Selection updates are made
+     * in the viewModelScope to ensure they aren't cancelled if the user navigates away from the
+     * AlbumMediaGrid composable.
+     */
+    fun handleAlbumMediaGridItemSelection(
+        item: Media,
+        selectionLimitExceededMessage: String,
+        album: Group.Album,
+    ) {
+        // Update the selectable values in the received media item.
+        val updatedMediaItem =
+            Media.withSelectable(item, /* selectionSource */ Telemetry.MediaLocation.ALBUM, album)
+        scope.launch {
+            val result = selection.toggle(updatedMediaItem)
+            if (result == FAILURE_SELECTION_LIMIT_EXCEEDED) {
+                events.dispatch(
+                    Event.ShowSnackbarMessage(CATEGORY_GRID.token, selectionLimitExceededMessage)
+                )
+            }
+        }
+    }
+
+    fun handleMediaSetItemSelection(item: Media, selectionLimitExceededMessage: String) {
+        // Update the selectable values in the received media item.
+        val updatedMediaItem =
+            Media.withSelectable(item, /* selectionSource */ Telemetry.MediaLocation.CATEGORY, null)
+        scope.launch {
+            val result = selection.toggle(updatedMediaItem)
+            if (result == FAILURE_SELECTION_LIMIT_EXCEEDED) {
+                events.dispatch(
+                    Event.ShowSnackbarMessage(CATEGORY_GRID.token, selectionLimitExceededMessage)
+                )
+            }
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/MediaSetContentGrid.kt b/photopicker/src/com/android/photopicker/features/categorygrid/MediaSetContentGrid.kt
new file mode 100644
index 000000000..683903383
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/MediaSetContentGrid.kt
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.lazy.grid.rememberLazyGridState
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.outlined.Image
+import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.unit.dp
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.paging.LoadState
+import androidx.paging.PagingData
+import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.modules.utils.build.SdkLevel
+import com.android.photopicker.R
+import com.android.photopicker.core.components.EmptyState
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.components.mediaGrid
+import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.embedded.LocalEmbeddedState
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.features.LocalFeatureManager
+import com.android.photopicker.core.navigation.LocalNavController
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.obtainViewModel
+import com.android.photopicker.core.selection.LocalSelection
+import com.android.photopicker.core.theme.LocalWindowSizeClass
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.extensions.navigateToPreviewMedia
+import com.android.photopicker.features.preview.PreviewFeature
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.launch
+
+/**
+ * Primary composable for drawing the Mediaset content grid on
+ * [PhotopickerDestinations.MEDIASET_CONTENT_GRID]
+ *
+ * @param viewModel - A viewModel override for the composable. Normally, this is fetched via hilt
+ *   from the backstack entry by using obtainViewModel()
+ * @param flow - stateflow holding the mediaset for which the media needs to be presented.
+ */
+@Composable
+fun MediaSetContentGrid(
+    flow: StateFlow<Group.MediaSet?>,
+    viewModel: CategoryGridViewModel = obtainViewModel(),
+) {
+    val mediasetState by flow.collectAsStateWithLifecycle(initialValue = null)
+    val mediaset = mediasetState
+    Column(modifier = Modifier.fillMaxSize()) {
+        when (mediaset) {
+            null -> {}
+            else -> {
+                val mediasetItems = remember(mediaset) { viewModel.getMediaSetContent(mediaset) }
+                MediasetContentGrid(mediasetItems = mediasetItems)
+            }
+        }
+    }
+}
+
+/** Initialises all the states and media source required to load media for the input [mediaset]. */
+@Composable
+private fun MediasetContentGrid(
+    mediasetItems: Flow<PagingData<MediaGridItem>>,
+    viewModel: CategoryGridViewModel = obtainViewModel(),
+) {
+    val featureManager = LocalFeatureManager.current
+    val isPreviewEnabled = remember { featureManager.isFeatureEnabled(PreviewFeature::class.java) }
+    val navController = LocalNavController.current
+    val items = mediasetItems.collectAsLazyPagingItems()
+    // Collect the selection to notify the mediaGrid of selection changes.
+    val selection by LocalSelection.current.flow.collectAsStateWithLifecycle()
+    val selectionLimit = LocalPhotopickerConfiguration.current.selectionLimit
+    val selectionLimitExceededMessage =
+        stringResource(R.string.photopicker_selection_limit_exceeded_snackbar, selectionLimit)
+    // Use the expanded layout any time the Width is Medium or larger.
+    val isExpandedScreen: Boolean =
+        when (LocalWindowSizeClass.current.widthSizeClass) {
+            WindowWidthSizeClass.Medium -> true
+            WindowWidthSizeClass.Expanded -> true
+            else -> false
+        }
+    val state = rememberLazyGridState()
+    val isEmbedded =
+        LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
+    val host = LocalEmbeddedState.current?.host
+    val scope = rememberCoroutineScope()
+    val events = LocalEvents.current
+    val configuration = LocalPhotopickerConfiguration.current
+    // Container encapsulating the mediaset title followed by its content in the form of a
+    // grid, the content also includes date and month separators.
+    Column(modifier = Modifier.fillMaxSize()) {
+        val isEmptyAndNoMorePages =
+            items.itemCount == 0 &&
+                items.loadState.source.append is LoadState.NotLoading &&
+                items.loadState.source.append.endOfPaginationReached
+        when {
+            isEmptyAndNoMorePages -> {
+                val localConfig = LocalConfiguration.current
+                val emptyStatePadding =
+                    remember(localConfig) { (localConfig.screenHeightDp * .20).dp }
+                val (title, body, icon) = getEmptyStateContentForMediaset()
+                EmptyState(
+                    modifier =
+                        if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                            // In embedded no need to give extra top padding to make empty
+                            // state title and body clearly visible in collapse mode (small view)
+                            Modifier.fillMaxWidth()
+                        } else {
+                            // Provide 20% of screen height as empty space above
+                            Modifier.fillMaxWidth().padding(top = emptyStatePadding)
+                        },
+                    icon = icon,
+                    title = title,
+                    body = body,
+                )
+                LaunchedEffect(Unit) {
+                    events.dispatch(
+                        Event.LogPhotopickerUIEvent(
+                            FeatureToken.CATEGORY_GRID.token,
+                            configuration.sessionId,
+                            configuration.callingPackageUid ?: -1,
+                            Telemetry.UiEvent.UI_LOADED_EMPTY_STATE,
+                        )
+                    )
+                }
+            }
+            else -> {
+                mediaGrid(
+                    items = items,
+                    isExpandedScreen = isExpandedScreen,
+                    selection = selection,
+                    onItemClick = { item ->
+                        if (item is MediaGridItem.MediaItem) {
+                            viewModel.handleMediaSetItemSelection(
+                                item.media,
+                                selectionLimitExceededMessage,
+                            )
+                        }
+                    },
+                    onItemLongPress = { item ->
+                        // If the [PreviewFeature] is enabled, launch the preview route.
+                        if (isPreviewEnabled && item is MediaGridItem.MediaItem) {
+                            // Dispatch UI event to log long pressing the media item
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.PREVIEW.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.PICKER_LONG_SELECT_MEDIA_ITEM,
+                                    )
+                                )
+                            }
+                            // Dispatch UI event to log entry into preview mode
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.PREVIEW.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE,
+                                    )
+                                )
+                            }
+                            navController.navigateToPreviewMedia(item.media)
+                        }
+                    },
+                    state = state,
+                )
+                LaunchedEffect(Unit) {
+                    // Dispatch UI event to log loading of meadia set contents
+                    events.dispatch(
+                        Event.LogPhotopickerUIEvent(
+                            FeatureToken.CATEGORY_GRID.token,
+                            configuration.sessionId,
+                            configuration.callingPackageUid ?: -1,
+                            Telemetry.UiEvent.UI_LOADED_MEDIA_SETS_CONTENTS,
+                        )
+                    )
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Return a generic content for the empty state.
+ *
+ * @return a [Triple] that contains the [Title, Body, Icon] for the empty state.
+ */
+@Composable
+private fun getEmptyStateContentForMediaset(): Triple<String, String, ImageVector> {
+    return Triple(
+        stringResource(R.string.photopicker_photos_empty_state_title),
+        stringResource(R.string.photopicker_photos_empty_state_body),
+        Icons.Outlined.Image,
+    )
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/MediaSetGrid.kt b/photopicker/src/com/android/photopicker/features/categorygrid/MediaSetGrid.kt
new file mode 100644
index 000000000..2890eae74
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/MediaSetGrid.kt
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.lazy.grid.GridCells
+import androidx.compose.foundation.lazy.grid.rememberLazyGridState
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.outlined.Group
+import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.unit.dp
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.paging.LoadState
+import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.modules.utils.build.SdkLevel
+import com.android.photopicker.R
+import com.android.photopicker.core.components.EmptyState
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.components.mediaGrid
+import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.embedded.LocalEmbeddedState
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.navigation.LocalNavController
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.obtainViewModel
+import com.android.photopicker.core.theme.LocalWindowSizeClass
+import com.android.photopicker.data.model.CategoryType
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.extensions.navigateToMediaSetContentGrid
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.launch
+
+/** The number of grid cells per row for Phone / narrow layouts */
+private val CELLS_PER_ROW_FOR_MEDIASET_GRID = 3
+/** The number of grid cells per row for Tablet / expanded layouts */
+private val CELLS_PER_ROW_EXPANDED_FOR_MEDIASET_GRID = 4
+/** The amount of padding to use around each cell in the mediaset grid. */
+private val MEASUREMENT_HORIZONTAL_CELL_SPACING_MEDIASET_GRID = 1.dp
+
+/**
+ * Primary composable for drawing the main MediasetGrid on [PhotopickerDestinations.MEDIASET_GRID]
+ *
+ * @param viewModel - A viewModel override for the composable. Normally, this is fetched via hilt
+ *   from the backstack entry by using obtainViewModel()
+ */
+@Composable
+fun MediaSetGrid(
+    flow: StateFlow<Group.Category?>,
+    viewModel: CategoryGridViewModel = obtainViewModel(),
+) {
+    val categoryState by flow.collectAsStateWithLifecycle(initialValue = null)
+    val category = categoryState
+    when (category) {
+        null -> {}
+        else -> {
+            val items = remember(category) { viewModel.getMediaSets(category) }
+            val state = rememberLazyGridState()
+            val navController = LocalNavController.current
+            val scope = rememberCoroutineScope()
+            val events = LocalEvents.current
+            val configuration = LocalPhotopickerConfiguration.current
+
+            val isEmbedded =
+                LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
+            val host = LocalEmbeddedState.current?.host
+            // Use the expanded layout any time the Width is Medium or larger.
+            val isExpandedScreen: Boolean =
+                when (LocalWindowSizeClass.current.widthSizeClass) {
+                    WindowWidthSizeClass.Medium -> true
+                    WindowWidthSizeClass.Expanded -> true
+                    else -> false
+                }
+            val mediaSetItems = items.collectAsLazyPagingItems()
+            Column(modifier = Modifier.fillMaxSize()) {
+                val isEmptyAndNoMorePages =
+                    mediaSetItems.itemCount == 0 &&
+                        mediaSetItems.loadState.source.append is LoadState.NotLoading &&
+                        mediaSetItems.loadState.source.append.endOfPaginationReached
+                when {
+                    isEmptyAndNoMorePages -> {
+                        val localConfig = LocalConfiguration.current
+                        val emptyStatePadding =
+                            remember(localConfig) { (localConfig.screenHeightDp * .20).dp }
+                        val (title, body, icon) =
+                            getEmptyStateContentForMediaset(category.categoryType)
+                        EmptyState(
+                            modifier =
+                                if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                                    // In embedded no need to give extra top padding to make empty
+                                    // state title and body clearly visible in collapse mode (small
+                                    // view)
+                                    Modifier.fillMaxWidth()
+                                } else {
+                                    // Provide 20% of screen height as empty space above
+                                    Modifier.fillMaxWidth().padding(top = emptyStatePadding)
+                                },
+                            icon = icon,
+                            title = title,
+                            body = body,
+                        )
+                        LaunchedEffect(Unit) {
+                            events.dispatch(
+                                Event.LogPhotopickerUIEvent(
+                                    FeatureToken.CATEGORY_GRID.token,
+                                    configuration.sessionId,
+                                    configuration.callingPackageUid ?: -1,
+                                    Telemetry.UiEvent.UI_LOADED_EMPTY_STATE,
+                                )
+                            )
+                        }
+                    }
+
+                    else -> {
+                        // Invoke the composable for MediasetGrid. OnClick uses the navController to
+                        // navigate to the mediaset content for the mediaset that is selected by the
+                        // user.
+                        mediaGrid(
+                            items = mediaSetItems,
+                            onItemClick = { item ->
+                                if (item is MediaGridItem.PersonMediaSetItem) {
+                                    scope.launch {
+                                        events.dispatch(
+                                            Event.LogPhotopickerUIEvent(
+                                                FeatureToken.CATEGORY_GRID.token,
+                                                configuration.sessionId,
+                                                configuration.callingPackageUid ?: -1,
+                                                Telemetry.UiEvent.CATEGORY_PEOPLEPET_OPEN,
+                                            )
+                                        )
+                                    }
+                                    navController.navigateToMediaSetContentGrid(
+                                        mediaSet = item.mediaSet
+                                    )
+                                } else if (item is MediaGridItem.MediaSetItem) {
+                                    scope.launch {
+                                        events.dispatch(
+                                            Event.LogPhotopickerUIEvent(
+                                                FeatureToken.CATEGORY_GRID.token,
+                                                configuration.sessionId,
+                                                configuration.callingPackageUid ?: -1,
+                                                Telemetry.UiEvent.PICKER_CATEGORIES_INTERACTION,
+                                            )
+                                        )
+                                    }
+                                    navController.navigateToMediaSetContentGrid(
+                                        mediaSet = item.mediaSet
+                                    )
+                                }
+                            },
+                            isExpandedScreen = isExpandedScreen,
+                            columns =
+                                when (isExpandedScreen) {
+                                    true ->
+                                        GridCells.Fixed(CELLS_PER_ROW_EXPANDED_FOR_MEDIASET_GRID)
+                                    false -> GridCells.Fixed(CELLS_PER_ROW_FOR_MEDIASET_GRID)
+                                },
+                            selection = emptySet(),
+                            gridCellPadding = MEASUREMENT_HORIZONTAL_CELL_SPACING_MEDIASET_GRID,
+                            contentPadding =
+                                PaddingValues(MEASUREMENT_HORIZONTAL_CELL_SPACING_MEDIASET_GRID),
+                            state = state,
+                        )
+                        LaunchedEffect(Unit) {
+                            // Dispatch UI event to log loading of category contents
+                            events.dispatch(
+                                Event.LogPhotopickerUIEvent(
+                                    FeatureToken.CATEGORY_GRID.token,
+                                    configuration.sessionId,
+                                    configuration.callingPackageUid ?: -1,
+                                    Telemetry.UiEvent.UI_LOADED_MEDIA_SETS,
+                                )
+                            )
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Return a generic content for the empty state.
+ *
+ * @return a [Triple] that contains the [Title, Body, Icon] for the empty state.
+ */
+@Composable
+private fun getEmptyStateContentForMediaset(
+    categoryType: CategoryType
+): Triple<String, String, ImageVector> {
+    return if (categoryType == CategoryType.PEOPLE_AND_PETS) {
+        Triple(
+            stringResource(R.string.photopicker_people_category_empty_state_title),
+            stringResource(R.string.photopicker_people_category_empty_state_body),
+            Icons.Outlined.Group,
+        )
+    } else {
+        Triple(
+            stringResource(R.string.photopicker_photos_empty_state_title),
+            stringResource(R.string.photopicker_photos_empty_state_body),
+            Icons.Outlined.Group,
+        )
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/data/CategoryDataService.kt b/photopicker/src/com/android/photopicker/features/categorygrid/data/CategoryDataService.kt
new file mode 100644
index 000000000..e22843c4d
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/data/CategoryDataService.kt
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.data
+
+import android.os.CancellationSignal
+import androidx.paging.PagingSource
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+
+/**
+ * Powers UI with data for the category feature which includes the category grid, media sets grid,
+ * and media set content grid. This class owns the responsibility to:
+ * - fetch categories, albums, media sets and media on demand
+ * - cache data if required
+ * - keep track of data updates in the data source
+ * - detect and refresh stale data
+ */
+interface CategoryDataService {
+    companion object {
+        const val TAG: String = "PhotopickerSearchCategoryService"
+    }
+
+    /**
+     * Creates a paging source that can load categories and albums.
+     *
+     * @param category the parent [Category]. If the parent category is null then the method returns
+     *   root categories.
+     * @param cancellationSignal An optional [CancellationSignal] that can be marked as cancelled
+     *   when the query results are no longer required.
+     * @return The [PagingSource] that fetches a page using [GroupPageKey]. A page in the paging
+     *   source contains a [List] of [Group.Category] items.
+     */
+    fun getCategories(
+        parentCategory: Group.Category? = null,
+        cancellationSignal: CancellationSignal? = null,
+    ): PagingSource<GroupPageKey, Group>
+
+    /**
+     * Creates a paging source that can load media sets. Leaf categories contain [MediaSet]-s. A
+     * [MediaSet] can only contain media items.
+     *
+     * @param category the parent [Category].
+     * @param cancellationSignal An optional [CancellationSignal] that can be marked as cancelled
+     *   when the query results are no longer required.
+     * @return The [PagingSource] that fetches a page using [GroupPageKey]. A page in the paging
+     *   source contains a [List] of [Group.MediaSet] items.
+     */
+    fun getMediaSets(
+        category: Group.Category,
+        cancellationSignal: CancellationSignal? = null,
+    ): PagingSource<GroupPageKey, Group.MediaSet>
+
+    /**
+     * Creates a paging source that can load media items of a media set.
+     *
+     * @param mediaSet the parent [MediaSet].
+     * @param cancellationSignal An optional [CancellationSignal] that can be marked as cancelled
+     *   when the query results are no longer required.
+     * @return The [PagingSource] that fetches a page using [MediaPageKey]. A page in the paging
+     *   source contains a [List] of [Media] items.
+     */
+    fun getMediaSetContents(
+        mediaSet: Group.MediaSet,
+        cancellationSignal: CancellationSignal? = null,
+    ): PagingSource<MediaPageKey, Media>
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/data/CategoryDataServiceImpl.kt b/photopicker/src/com/android/photopicker/features/categorygrid/data/CategoryDataServiceImpl.kt
new file mode 100644
index 000000000..f7b242aa2
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/data/CategoryDataServiceImpl.kt
@@ -0,0 +1,478 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.data
+
+import android.content.ContentResolver
+import android.database.ContentObserver
+import android.net.Uri
+import android.os.CancellationSignal
+import android.util.Log
+import androidx.paging.PagingSource
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MEDIA_SETS_UPDATE_URI
+import com.android.photopicker.data.MEDIA_SET_CONTENT_UPDATE_URI
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.NotificationService
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.categorygrid.paging.CategoryAndAlbumPagingSource
+import com.android.photopicker.features.categorygrid.paging.MediaSetContentsPagingSource
+import com.android.photopicker.features.categorygrid.paging.MediaSetsPagingSource
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.channels.awaitClose
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.callbackFlow
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
+
+/**
+ * Provides category feature data to the Photo Picker UI. The data comes from a [ContentProvider]
+ * called [MediaProvider].
+ *
+ * Underlying data changes in [MediaProvider] are observed using [ContentObservers]. When a change
+ * in data is observed, the data is re-fetched from the [MediaProvider] process and the new data is
+ * emitted to the [StateFlows]-s.
+ *
+ * @param dataService Core Picker's data service that provides data related to core functionality.
+ * @param config A [StateFlow] that emits [PhotopickerConfiguration] changes.
+ * @param scope The [CoroutineScope] the data flows will be shared in.
+ * @param dispatcher A [CoroutineDispatcher] to run the coroutines in.
+ * @param notificationService An instance of [NotificationService] responsible to listen to data
+ *   change notifications.
+ * @param mediaProviderClient An instance of [MediaProviderClient] responsible to get data from
+ *   MediaProvider.
+ * @param events Event bus for the current session.
+ */
+class CategoryDataServiceImpl(
+    private val dataService: DataService,
+    private val config: StateFlow<PhotopickerConfiguration>,
+    private val scope: CoroutineScope,
+    private val dispatcher: CoroutineDispatcher,
+    private val notificationService: NotificationService,
+    private val mediaProviderClient: MediaProviderClient,
+    private val events: Events,
+) : CategoryDataService {
+    private val cachedPagingSourceMutex = Mutex()
+    private var rootCategoryAndAlbumPagingSource: PagingSource<GroupPageKey, Group>? = null
+    private val childCategoryPagingSources:
+        MutableMap<Group.Category, PagingSource<GroupPageKey, Group>> =
+        mutableMapOf()
+    private val mediaSetPagingSources:
+        MutableMap<Group.Category, PagingSource<GroupPageKey, Group.MediaSet>> =
+        mutableMapOf()
+    private val mediaSetContentPagingSources:
+        MutableMap<Group.MediaSet, PagingSource<MediaPageKey, Media>> =
+        mutableMapOf()
+    // Callback flow that listens to changes in media set content changes and emits the mediaset id
+    // when a change is observed.
+    private var mediaSetContentUpdateCallbackFlow: Flow<String>? = null
+
+    // Saves the current job that collects the [mediaSetContentUpdateCallbackFlow].
+    // Cancel this job when there is a change in the current profile's content resolver.
+    private var mediaSetContentUpdateCollectJob: Job? = null
+
+    // Callback flow that listens to changes in media sets and emits the category id when
+    // a change is observed.
+    private var mediaSetsUpdateCallbackFlow: Flow<String>? = null
+
+    // Saves the current job that collects the [mediaSetsUpdateCallbackFlow].
+    // Cancel this job when there is a change in the current profile's content resolver.
+    private var mediaSetsUpdateCollectJob: Job? = null
+
+    init {
+        // Listen to available provider changes and clear category cache when required.
+        scope.launch(dispatcher) {
+            dataService.availableProviders.collect { providers: List<Provider> ->
+                Log.d(
+                    CategoryDataService.TAG,
+                    "Available providers have changed to $providers. " +
+                        "Clearing category results cache.",
+                )
+
+                cachedPagingSourceMutex.withLock {
+                    rootCategoryAndAlbumPagingSource?.invalidate()
+                    childCategoryPagingSources.values.forEach { pagingSource ->
+                        pagingSource.invalidate()
+                    }
+                    childCategoryPagingSources.clear()
+
+                    mediaSetPagingSources.values.forEach { pagingSource ->
+                        pagingSource.invalidate()
+                    }
+                    mediaSetPagingSources.clear()
+
+                    mediaSetContentPagingSources.values.forEach { pagingSource ->
+                        pagingSource.invalidate()
+                    }
+                    mediaSetContentPagingSources.clear()
+                }
+            }
+        }
+
+        scope.launch(dispatcher) {
+            dataService.activeContentResolver.collect { activeContentResolver: ContentResolver ->
+                Log.d(CategoryDataService.TAG, "Active content resolver has changed")
+
+                // Stop collecting media sets from previously initialised callback flow
+                mediaSetsUpdateCollectJob?.cancel()
+                mediaSetsUpdateCallbackFlow = initMediaSetsCallbackFlow(activeContentResolver)
+
+                mediaSetsUpdateCollectJob =
+                    scope.launch(dispatcher) {
+                        mediaSetsUpdateCallbackFlow?.collect { categoryId: String ->
+                            Log.d(
+                                CategoryDataService.TAG,
+                                "MediaSets update notification " +
+                                    "received for category id " +
+                                    categoryId,
+                            )
+                            cachedPagingSourceMutex.withLock {
+                                getMediaSetPagingSourceForCategoryId(categoryId)?.invalidate()
+                            }
+                        }
+                    }
+                scope.launch(dispatcher) {
+                    // Stop collecting media set content from previously initialised callback flow
+                    mediaSetContentUpdateCollectJob?.cancel()
+                    mediaSetContentUpdateCallbackFlow =
+                        initMediaSetContentCallbackFlow(activeContentResolver)
+
+                    mediaSetContentUpdateCollectJob =
+                        scope.launch(dispatcher) {
+                            mediaSetContentUpdateCallbackFlow?.collect { mediaSetId ->
+                                Log.d(
+                                    CategoryDataService.TAG,
+                                    "MediaSet content update notification " +
+                                        "received for mediaset id " +
+                                        mediaSetId,
+                                )
+                                cachedPagingSourceMutex.withLock {
+                                    getMediaSetPagingSourceForMediaSetId(mediaSetId)?.invalidate()
+                                }
+                            }
+                        }
+                }
+            }
+        }
+    }
+
+    private fun initMediaSetsCallbackFlow(resolver: ContentResolver): Flow<String> = callbackFlow {
+        val observer =
+            object : ContentObserver(/* handler */ null) {
+                override fun onChange(selfChange: Boolean, uri: Uri?) {
+                    // Verify that the categoryId is present in the uri
+                    if (uri?.pathSegments?.size == (MEDIA_SETS_UPDATE_URI.pathSegments.size + 1)) {
+                        val categoryId: String = uri.lastPathSegment ?: "-1"
+                        trySend(categoryId)
+                    }
+                }
+            }
+
+        // Register the content observer callback.
+        notificationService.registerContentObserverCallback(
+            resolver,
+            MEDIA_SETS_UPDATE_URI,
+            /*notifyForDescendants*/ true,
+            observer,
+        )
+
+        // Unregister when the flow is closed.
+        awaitClose { notificationService.unregisterContentObserverCallback(resolver, observer) }
+    }
+
+    private fun getMediaSetPagingSourceForCategoryId(
+        categoryId: String
+    ): PagingSource<GroupPageKey, Group.MediaSet>? {
+        for (category in mediaSetPagingSources.keys) {
+            if (category.id == categoryId) {
+                return mediaSetPagingSources[category]
+            }
+        }
+        return null
+    }
+
+    private fun initMediaSetContentCallbackFlow(resolver: ContentResolver): Flow<String> =
+        callbackFlow {
+            val observer =
+                object : ContentObserver(/*handler*/ null) {
+                    override fun onChange(selfChange: Boolean, uri: Uri?) {
+                        // Verify that the mediaSetId is present in the uri
+                        if (
+                            uri?.pathSegments?.size ==
+                                (MEDIA_SET_CONTENT_UPDATE_URI.pathSegments.size + 1)
+                        ) {
+                            val mediaSetId: String = uri.lastPathSegment ?: "-1"
+                            trySend(mediaSetId)
+                        }
+                    }
+                }
+            // Register the content observer callback.
+            notificationService.registerContentObserverCallback(
+                resolver,
+                MEDIA_SET_CONTENT_UPDATE_URI,
+                /*notifyForDescendants*/ true,
+                observer,
+            )
+
+            // Unregister when the flow is closed.
+            awaitClose { notificationService.unregisterContentObserverCallback(resolver, observer) }
+        }
+
+    private fun getMediaSetPagingSourceForMediaSetId(
+        mediaSetId: String
+    ): PagingSource<MediaPageKey, Media>? {
+        for (mediaSet in mediaSetContentPagingSources.keys) {
+            if (mediaSet.id == mediaSetId) {
+                return mediaSetContentPagingSources[mediaSet]
+            }
+        }
+        return null
+    }
+
+    override fun getCategories(
+        parentCategory: Group.Category?,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<GroupPageKey, Group> = runBlocking {
+        return@runBlocking cachedPagingSourceMutex.withLock {
+            return@withLock when {
+                parentCategory == null &&
+                    rootCategoryAndAlbumPagingSource != null &&
+                    !rootCategoryAndAlbumPagingSource!!.invalid -> {
+                    Log.d(
+                        CategoryDataService.TAG,
+                        "A valid paging source is available for root categories and albums. " +
+                            "Not creating a new paging source.",
+                    )
+
+                    val pagingSource = rootCategoryAndAlbumPagingSource!!
+                    // Register the new cancellation signal to be cancelled in the callback.
+                    pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+                    pagingSource
+                }
+
+                parentCategory != null &&
+                    childCategoryPagingSources.containsKey(parentCategory) &&
+                    !childCategoryPagingSources[parentCategory]!!.invalid -> {
+                    Log.d(
+                        CategoryDataService.TAG,
+                        "A valid paging source is available for category ${parentCategory.categoryType}. " +
+                            "Not creating a new paging source.",
+                    )
+
+                    val pagingSource = childCategoryPagingSources[parentCategory]!!
+                    // Register the new cancellation signal to be cancelled in the callback.
+                    pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+                    pagingSource
+                }
+
+                else -> {
+                    val availableProviders: List<Provider> = dataService.availableProviders.value
+                    val contentResolver: ContentResolver = dataService.activeContentResolver.value
+                    val pagingSource =
+                        CategoryAndAlbumPagingSource(
+                            contentResolver = contentResolver,
+                            availableProviders = availableProviders,
+                            parentCategoryId = parentCategory?.id,
+                            mediaProviderClient = mediaProviderClient,
+                            dispatcher = dispatcher,
+                            configuration = config.value,
+                            events = events,
+                            cancellationSignal = cancellationSignal,
+                        )
+                    // Ensure that cancellation get propagated to the data source when the paging
+                    // source is invalidated.
+                    pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+
+                    Log.v(
+                        CategoryDataService.TAG,
+                        "Created a category paging source that queries $availableProviders for " +
+                            "parent category id $parentCategory",
+                    )
+
+                    // Update paging source cache.
+                    when {
+                        parentCategory == null -> rootCategoryAndAlbumPagingSource = pagingSource
+                        else -> childCategoryPagingSources[parentCategory] = pagingSource
+                    }
+
+                    pagingSource
+                }
+            }
+        }
+    }
+
+    override fun getMediaSets(
+        category: Group.Category,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<GroupPageKey, Group.MediaSet> = runBlocking {
+        return@runBlocking cachedPagingSourceMutex.withLock {
+            if (
+                mediaSetPagingSources.containsKey(category) &&
+                    !mediaSetPagingSources[category]!!.invalid
+            ) {
+                Log.d(
+                    CategoryDataService.TAG,
+                    "A valid paging source is available for media sets ${category.categoryType}. " +
+                        "Not creating a new paging source.",
+                )
+                val pagingSource = mediaSetPagingSources[category]!!
+                // Register the new cancellation signal to be cancelled in the callback.
+                pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+                pagingSource
+            } else {
+                refreshMediaSets(category)
+
+                val availableProviders: List<Provider> = dataService.availableProviders.value
+                val contentResolver: ContentResolver = dataService.activeContentResolver.value
+                val pagingSource =
+                    MediaSetsPagingSource(
+                        contentResolver = contentResolver,
+                        availableProviders = availableProviders,
+                        parentCategory = category,
+                        mediaProviderClient = mediaProviderClient,
+                        dispatcher = dispatcher,
+                        configuration = config.value,
+                        events = events,
+                        cancellationSignal = cancellationSignal,
+                    )
+                // Ensure that cancellation get propagated to the data source when the paging source
+                // is invalidated.
+                pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+
+                Log.v(
+                    CategoryDataService.TAG,
+                    "Created a media source paging source that queries $availableProviders for " +
+                        "parent category id $category",
+                )
+
+                mediaSetPagingSources[category] = pagingSource
+                pagingSource
+            }
+        }
+    }
+
+    override fun getMediaSetContents(
+        mediaSet: Group.MediaSet,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> = runBlocking {
+        return@runBlocking cachedPagingSourceMutex.withLock {
+            refreshMediaSetContents(mediaSet)
+            if (
+                mediaSetContentPagingSources.containsKey(mediaSet) &&
+                    !mediaSetContentPagingSources[mediaSet]!!.invalid
+            ) {
+                Log.d(
+                    CategoryDataService.TAG,
+                    "A valid paging source is available for media set content ${mediaSet.id}. " +
+                        "Not creating a new paging source.",
+                )
+                val pagingSource = mediaSetContentPagingSources[mediaSet]!!
+                // Register the new cancellation signal to be cancelled in the callback.
+                pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+                pagingSource
+            } else {
+                val availableProviders: List<Provider> = dataService.availableProviders.value
+                val contentResolver: ContentResolver = dataService.activeContentResolver.value
+                val pagingSource =
+                    MediaSetContentsPagingSource(
+                        contentResolver = contentResolver,
+                        parentMediaSet = mediaSet,
+                        mediaProviderClient = mediaProviderClient,
+                        dispatcher = dispatcher,
+                        configuration = config.value,
+                        events = events,
+                        cancellationSignal = cancellationSignal,
+                    )
+                // Ensure that cancellation get propagated to the data source when the paging source
+                // is invalidated.
+                pagingSource.registerInvalidatedCallback { cancellationSignal?.cancel() }
+
+                Log.v(
+                    CategoryDataService.TAG,
+                    "Created a media source paging source that queries $availableProviders for " +
+                        "parent media set id ${mediaSet.id}",
+                )
+
+                mediaSetContentPagingSources[mediaSet] = pagingSource
+                pagingSource
+            }
+        }
+    }
+
+    private suspend fun refreshMediaSets(category: Group.Category) {
+        val providers = dataService.availableProviders.value
+        val contentResolver = dataService.activeContentResolver.value
+        val isCategoryProviderAvailable =
+            providers.any { provider -> provider.authority == category.authority }
+
+        if (isCategoryProviderAvailable) {
+            Log.d(
+                CategoryDataService.TAG,
+                "Sending media sets refresh request to the data source" +
+                    " for parent category ${category.categoryType}",
+            )
+
+            mediaProviderClient.refreshMediaSets(contentResolver, category, config.value, providers)
+        } else {
+            Log.e(
+                CategoryDataService.TAG,
+                "Available providers $providers " +
+                    "does not contain category authority ${category.authority}. " +
+                    "Skip sending refresh media sets request.",
+            )
+        }
+    }
+
+    private suspend fun refreshMediaSetContents(mediaSet: Group.MediaSet) {
+        val providers = dataService.availableProviders.value
+        val contentResolver = dataService.activeContentResolver.value
+        val isMediaSetProviderAvailable =
+            providers.any { provider -> provider.authority == mediaSet.authority }
+
+        if (isMediaSetProviderAvailable) {
+            Log.d(
+                CategoryDataService.TAG,
+                "Sending media set contents refresh request to the data source" +
+                    " for parent media set ${mediaSet.id}",
+            )
+
+            mediaProviderClient.refreshMediaSetContents(
+                contentResolver,
+                mediaSet,
+                config.value,
+                providers,
+            )
+        } else {
+            Log.e(
+                CategoryDataService.TAG,
+                "Available providers $providers " +
+                    "does not contain media set authority ${mediaSet.authority}. " +
+                    "Skip sending refresh media set contents request.",
+            )
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/inject/CategoryActivityRetainedModule.kt b/photopicker/src/com/android/photopicker/features/categorygrid/inject/CategoryActivityRetainedModule.kt
new file mode 100644
index 000000000..59e34f073
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/inject/CategoryActivityRetainedModule.kt
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.inject
+
+import android.util.Log
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.NotificationService
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+import com.android.photopicker.features.categorygrid.data.CategoryDataServiceImpl
+import dagger.Module
+import dagger.Provides
+import dagger.hilt.InstallIn
+import dagger.hilt.android.components.ActivityRetainedComponent
+import dagger.hilt.android.scopes.ActivityRetainedScoped
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+
+/**
+ * Injection Module for category feature specific dependencies, that provides access to objects
+ * bound to the ActivityRetainedScope.
+ *
+ * These can be injected by requesting the type with the [@ActivityRetainedScoped] qualifier.
+ *
+ * The module outlives the individual activities (and survives configuration changes), but is bound
+ * to a single Photopicker session.
+ *
+ * Note: Jobs that are launched in the [CoroutineScope] provided by this module will be
+ * automatically cancelled when the ActivityRetainedScope is ended.
+ */
+@Module
+@InstallIn(ActivityRetainedComponent::class)
+class CategoryActivityRetainedModule {
+    companion object {
+        val TAG: String = "CategoryActivityModule"
+    }
+
+    // Avoid initialization until it's actually needed.
+    private lateinit var categoryDataService: CategoryDataService
+
+    /** Provider for an implementation of [CategoryDataService]. */
+    @Provides
+    @ActivityRetainedScoped
+    fun provideCategoryDataService(
+        dataService: DataService,
+        configurationManager: ConfigurationManager,
+        @Background scope: CoroutineScope,
+        @Background dispatcher: CoroutineDispatcher,
+        mediaProviderClient: MediaProviderClient,
+        notificationService: NotificationService,
+        events: Events,
+    ): CategoryDataService {
+        if (::categoryDataService.isInitialized) {
+            return categoryDataService
+        } else {
+            Log.d(
+                CategoryDataService.TAG,
+                "CategoryDataService requested but not yet initialized." +
+                    " Initializing CategoryDataService.",
+            )
+
+            categoryDataService =
+                CategoryDataServiceImpl(
+                    dataService,
+                    configurationManager.configuration,
+                    scope,
+                    dispatcher,
+                    notificationService,
+                    mediaProviderClient,
+                    events,
+                )
+            return categoryDataService
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/inject/CategoryEmbeddedServiceModule.kt b/photopicker/src/com/android/photopicker/features/categorygrid/inject/CategoryEmbeddedServiceModule.kt
new file mode 100644
index 000000000..503badaec
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/inject/CategoryEmbeddedServiceModule.kt
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.inject
+
+import android.util.Log
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.EmbeddedServiceComponent
+import com.android.photopicker.core.SessionScoped
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.NotificationService
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+import com.android.photopicker.features.categorygrid.data.CategoryDataServiceImpl
+import dagger.Module
+import dagger.Provides
+import dagger.hilt.InstallIn
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+
+/**
+ * Injection Module for category feature specific dependencies, that provides access to objects
+ * bound to a single [EmbeddedServiceComponent].
+ *
+ * The module is bound to a single instance of the embedded Photopicker, and first obtained in the
+ * [Session].
+ *
+ * Note: Jobs that are launched in the [CoroutineScope] provided by this module will be
+ * automatically cancelled when the [EmbeddedLifecycle] provided by this module ends.
+ */
+@Module
+@InstallIn(EmbeddedServiceComponent::class)
+class CategoryEmbeddedServiceModule {
+    companion object {
+        val TAG: String = "CategoryEmbeddedModule"
+    }
+
+    // Avoid initialization until it's actually needed.
+    private lateinit var categoryDataService: CategoryDataService
+
+    /** Provider for an implementation of [CategoryDataService]. */
+    @Provides
+    @SessionScoped
+    fun provideCategoryDataService(
+        dataService: DataService,
+        configurationManager: ConfigurationManager,
+        @Background scope: CoroutineScope,
+        @Background dispatcher: CoroutineDispatcher,
+        mediaProviderClient: MediaProviderClient,
+        notificationService: NotificationService,
+        events: Events,
+    ): CategoryDataService {
+        if (::categoryDataService.isInitialized) {
+            return categoryDataService
+        } else {
+            Log.d(
+                CategoryDataService.TAG,
+                "CategoryDataService requested but not yet initialized." +
+                    " Initializing CategoryDataService.",
+            )
+
+            categoryDataService =
+                CategoryDataServiceImpl(
+                    dataService,
+                    configurationManager.configuration,
+                    scope,
+                    dispatcher,
+                    notificationService,
+                    mediaProviderClient,
+                    events,
+                )
+            return categoryDataService
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/paging/CategoryAndAlbumPagingSource.kt b/photopicker/src/com/android/photopicker/features/categorygrid/paging/CategoryAndAlbumPagingSource.kt
new file mode 100644
index 000000000..e04c25078
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/paging/CategoryAndAlbumPagingSource.kt
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.paging
+
+import android.content.ContentResolver
+import android.os.CancellationSignal
+import android.util.Log
+import androidx.paging.PagingSource
+import androidx.paging.PagingState
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Provider
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.withContext
+
+/**
+ * This [PagingSource] class is responsible to providing paginated category and album data from
+ * Picker Backend by serving requests from Paging library. It sources data from a [ContentProvider]
+ * called [MediaProvider].
+ */
+class CategoryAndAlbumPagingSource(
+    private val contentResolver: ContentResolver,
+    private val availableProviders: List<Provider>,
+    private val parentCategoryId: String?,
+    private val mediaProviderClient: MediaProviderClient,
+    private val dispatcher: CoroutineDispatcher,
+    private val configuration: PhotopickerConfiguration,
+    private val events: Events,
+    private val cancellationSignal: CancellationSignal?,
+) : PagingSource<GroupPageKey, Group>() {
+    companion object {
+        val TAG: String = "PickerCategoryPagingSource"
+    }
+
+    override suspend fun load(params: LoadParams<GroupPageKey>): LoadResult<GroupPageKey, Group> {
+        val pageKey = params.key ?: GroupPageKey()
+        val pageSize = params.loadSize
+
+        // Switch to the background thread from the main thread using [withContext].
+        val result =
+            withContext(dispatcher) {
+                try {
+                    if (availableProviders.isEmpty()) {
+                        throw IllegalArgumentException("No available providers found.")
+                    }
+
+                    mediaProviderClient.fetchCategoriesAndAlbums(
+                        pageKey,
+                        pageSize,
+                        contentResolver,
+                        availableProviders,
+                        parentCategoryId,
+                        configuration,
+                        cancellationSignal,
+                    )
+                } catch (e: Exception) {
+                    Log.e(TAG, "Could not fetch page from Media provider", e)
+                    LoadResult.Error(e)
+                }
+            }
+
+        if (result is LoadResult.Page) {
+            // Dispatch a pageInfo event to log paging details for fetching albums
+            // Keeping page number as 0 for all dispatched events for now for simplicity
+            events.dispatch(
+                Event.LogPhotopickerPageInfo(
+                    FeatureToken.CATEGORY_GRID.token,
+                    configuration.sessionId,
+                    /* pageNumber */ 0,
+                    pageSize,
+                )
+            )
+            Log.d(
+                TAG,
+                "Received ${result.data.size} category and album items from the data source.",
+            )
+        }
+
+        return result
+    }
+
+    override fun getRefreshKey(state: PagingState<GroupPageKey, Group>): GroupPageKey? = null
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/paging/MediaSetContentsPagingSource.kt b/photopicker/src/com/android/photopicker/features/categorygrid/paging/MediaSetContentsPagingSource.kt
new file mode 100644
index 000000000..daf7ce6c8
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/paging/MediaSetContentsPagingSource.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.paging
+
+import android.content.ContentResolver
+import android.os.CancellationSignal
+import android.util.Log
+import androidx.paging.PagingSource
+import androidx.paging.PagingState
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.withContext
+
+/**
+ * This [PagingSource] class is responsible to providing paginated media items in media set Picker
+ * Backend by serving requests from Paging library. It sources data from a [ContentProvider] called
+ * [MediaProvider].
+ */
+class MediaSetContentsPagingSource(
+    val contentResolver: ContentResolver,
+    private val parentMediaSet: Group.MediaSet,
+    private val mediaProviderClient: MediaProviderClient,
+    private val dispatcher: CoroutineDispatcher,
+    private val configuration: PhotopickerConfiguration,
+    private val events: Events,
+    private val cancellationSignal: CancellationSignal?,
+) : PagingSource<MediaPageKey, Media>() {
+    companion object {
+        val TAG: String = "PickerMediaSetContentPagingSource"
+    }
+
+    override suspend fun load(params: LoadParams<MediaPageKey>): LoadResult<MediaPageKey, Media> {
+        val pageKey = params.key ?: MediaPageKey()
+        val pageSize = params.loadSize
+        // Switch to the background thread from the main thread using [withContext].
+        val result =
+            withContext(dispatcher) {
+                try {
+                    mediaProviderClient.fetchMediaSetContents(
+                        pageKey,
+                        pageSize,
+                        contentResolver,
+                        parentMediaSet,
+                        configuration,
+                        cancellationSignal,
+                    )
+                } catch (e: Exception) {
+                    Log.e(TAG, "Could not fetch page from Media provider", e)
+                    LoadResult.Error(e)
+                }
+            }
+
+        if (result is LoadResult.Page) {
+            Log.d(TAG, "Received ${result.data.size} media set contents from the data source.")
+        }
+
+        return result
+    }
+
+    override fun getRefreshKey(state: PagingState<MediaPageKey, Media>): MediaPageKey? = null
+}
diff --git a/photopicker/src/com/android/photopicker/features/categorygrid/paging/MediaSetsPagingSource.kt b/photopicker/src/com/android/photopicker/features/categorygrid/paging/MediaSetsPagingSource.kt
new file mode 100644
index 000000000..472a41595
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/categorygrid/paging/MediaSetsPagingSource.kt
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid.paging
+
+import android.content.ContentResolver
+import android.os.CancellationSignal
+import android.util.Log
+import androidx.paging.PagingSource
+import androidx.paging.PagingState
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Provider
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.withContext
+
+/**
+ * This [PagingSource] class is responsible to providing paginated media sets data from Picker
+ * Backend by serving requests from Paging library. It sources data from a [ContentProvider] called
+ * [MediaProvider].
+ */
+class MediaSetsPagingSource(
+    val contentResolver: ContentResolver,
+    private val availableProviders: List<Provider>,
+    private val parentCategory: Group.Category,
+    private val mediaProviderClient: MediaProviderClient,
+    private val dispatcher: CoroutineDispatcher,
+    private val configuration: PhotopickerConfiguration,
+    private val events: Events,
+    private val cancellationSignal: CancellationSignal?,
+) : PagingSource<GroupPageKey, Group.MediaSet>() {
+    companion object {
+        val TAG: String = "PickerMediaSetPagingSource"
+    }
+
+    override suspend fun load(
+        params: LoadParams<GroupPageKey>
+    ): LoadResult<GroupPageKey, Group.MediaSet> {
+        val pageKey = params.key ?: GroupPageKey()
+        val pageSize = params.loadSize
+        // Switch to the background thread from the main thread using [withContext].
+        val result =
+            withContext(dispatcher) {
+                try {
+                    if (availableProviders.isEmpty()) {
+                        throw IllegalArgumentException("No available providers found.")
+                    }
+
+                    mediaProviderClient.fetchMediaSets(
+                        pageKey,
+                        pageSize,
+                        contentResolver,
+                        availableProviders,
+                        parentCategory,
+                        configuration,
+                        cancellationSignal,
+                    )
+                } catch (e: Exception) {
+                    Log.e(TAG, "Could not fetch page from Media provider", e)
+                    LoadResult.Error(e)
+                }
+            }
+
+        if (result is LoadResult.Page) {
+            Log.d(TAG, "Received ${result.data.size} media set items from the data source.")
+        }
+
+        return result
+    }
+
+    override fun getRefreshKey(state: PagingState<GroupPageKey, Group.MediaSet>): GroupPageKey? =
+        null
+}
diff --git a/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt b/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt
index 7327e346a..4670be84d 100644
--- a/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt
+++ b/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt
@@ -26,6 +26,7 @@ import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.heightIn
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.layout.widthIn
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.automirrored.filled.ArrowBack
 import androidx.compose.material3.ButtonDefaults
@@ -58,7 +59,10 @@ import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.theme.CustomAccentColorScheme
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.extensions.navigateToAlbumGrid
+import com.android.photopicker.extensions.navigateToCategoryGrid
+import com.android.photopicker.extensions.navigateToMediaSetGrid
 import com.android.photopicker.features.albumgrid.AlbumGridFeature
+import com.android.photopicker.features.categorygrid.CategoryGridFeature
 import com.android.photopicker.features.overflowmenu.OverflowMenuFeature
 import com.android.photopicker.features.profileselector.ProfileSelectorFeature
 import com.android.photopicker.features.search.SearchFeature
@@ -118,8 +122,21 @@ fun NavigationBar(modifier: Modifier = Modifier, params: LocationParams) {
 
             // When inside an album display the album title and a back button,
             // instead of the normal navigation bar contents.
-            currentRoute == PhotopickerDestinations.ALBUM_MEDIA_GRID.route ->
-                NavigationBarForAlbum(modifier)
+            currentRoute == PhotopickerDestinations.ALBUM_MEDIA_GRID.route -> {
+                if (featureManager.isFeatureEnabled(AlbumGridFeature::class.java)) {
+                    NavigationBarForAlbum(modifier)
+                } else {
+                    NavigationBarForGroup(modifier)
+                }
+            }
+
+            currentRoute == PhotopickerDestinations.MEDIA_SET_GRID.route -> {
+                NavigationBarForGroup(modifier)
+            }
+
+            currentRoute == PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route -> {
+                NavigationBarForGroup(modifier)
+            }
 
             // When search feature is enabled then display search bar along with profile selector,
             // overflow menu and the navigation buttons below it.
@@ -153,11 +170,20 @@ fun NavigationBarButton(
     val navController = LocalNavController.current
     val navBackStackEntry by navController.currentBackStackEntryAsState()
     val currentRoute = navBackStackEntry?.destination?.route
+    val featureManager = LocalFeatureManager.current
+    val categoryGridFeatureEnabled =
+        featureManager.isFeatureEnabled(CategoryGridFeature::class.java)
 
     FilledTonalButton(
         onClick = onClick,
-        modifier = modifier,
+        modifier =
+            if (categoryGridFeatureEnabled) {
+                modifier.widthIn(min = 120.dp, max = 120.dp)
+            } else {
+                modifier
+            },
         shape = MaterialTheme.shapes.medium,
+        contentPadding = ButtonDefaults.TextButtonContentPadding,
         colors =
             if (isCurrentRoute(currentRoute ?: "")) {
                 ButtonDefaults.filledTonalButtonColors(
@@ -188,9 +214,18 @@ fun NavigationBarButton(
  */
 @Composable
 private fun NavigationBarButtons(modifier: Modifier) {
+    val featureManager = LocalFeatureManager.current
+    val categoryGridFeatureEnabled =
+        featureManager.isFeatureEnabled(CategoryGridFeature::class.java)
+    val searchFeatureEnabled = featureManager.isFeatureEnabled(SearchFeature::class.java)
     Row(
         // Consume the incoming modifier to get the correct positioning.
-        modifier = modifier,
+        modifier =
+            if (categoryGridFeatureEnabled) {
+                modifier.padding(start = 8.dp, end = 8.dp)
+            } else {
+                modifier
+            },
         horizontalArrangement = Arrangement.Center,
     ) {
         Row(
@@ -201,15 +236,13 @@ private fun NavigationBarButtons(modifier: Modifier) {
                     alignment = Alignment.CenterHorizontally,
                 )
         ) {
-            val featureManager = LocalFeatureManager.current
-            val searchFeatureEnabled = featureManager.isFeatureEnabled(SearchFeature::class.java)
             // Buttons are provided by registered features, so request for the features to fill
             // this content.
             LocalFeatureManager.current.composeLocation(
                 Location.NAVIGATION_BAR_NAV_BUTTON,
                 maxSlots = 2,
                 modifier =
-                    if (searchFeatureEnabled) {
+                    if (searchFeatureEnabled && categoryGridFeatureEnabled) {
                         Modifier.weight(1f)
                     } else {
                         Modifier // No modifier needed when search not enabled
@@ -283,6 +316,122 @@ private fun NavigationBarForAlbum(modifier: Modifier) {
     }
 }
 
+/**
+ * Composable that provides Navigation Bar when inside a group displays the album or media set title
+ * and a back button
+ *
+ * @param modifier Modifier used to configure the layout of the navigation bar.
+ */
+@Composable
+private fun NavigationBarForGroup(modifier: Modifier) {
+    val navController = LocalNavController.current
+    val navBackStackEntry by navController.currentBackStackEntryAsState()
+    Row(modifier = modifier.fillMaxWidth()) {
+        val flow =
+            navBackStackEntry
+                ?.savedStateHandle
+                ?.getStateFlow<Group?>(CategoryGridFeature.GROUP_KEY, null)
+        val group = flow?.value
+        when (group) {
+            is Group.Album -> {
+                Row(verticalAlignment = Alignment.CenterVertically) {
+                    // back button
+                    IconButton(
+                        modifier =
+                            Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
+                                .padding(horizontal = MEASUREMENT_ICON_BUTTON_OUTSIDE_PADDING),
+                        onClick = { navController.navigateToCategoryGrid() },
+                    ) {
+                        Icon(
+                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                            // For accessibility
+                            contentDescription = stringResource(R.string.photopicker_back_option),
+                            tint = MaterialTheme.colorScheme.onSurface,
+                        )
+                    }
+                    // Album name
+                    Text(
+                        text = group.displayName,
+                        overflow = TextOverflow.Ellipsis,
+                        maxLines = 1,
+                        style = MaterialTheme.typography.titleLarge,
+                        // Traversal index -1 forces TalkBack to focus on the album title first.
+                        modifier = Modifier.semantics { traversalIndex = -1f },
+                    )
+                }
+            }
+            is Group.Category -> {
+                Row(verticalAlignment = Alignment.CenterVertically) {
+                    // back button
+                    IconButton(
+                        modifier =
+                            Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
+                                .padding(horizontal = MEASUREMENT_ICON_BUTTON_OUTSIDE_PADDING),
+                        onClick = { navController.navigateToCategoryGrid() },
+                    ) {
+                        Icon(
+                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                            // For accessibility
+                            contentDescription = stringResource(R.string.photopicker_back_option),
+                            tint = MaterialTheme.colorScheme.onSurface,
+                        )
+                    }
+                    Text(
+                        text = group.displayName ?: "",
+                        overflow = TextOverflow.Ellipsis,
+                        maxLines = 1,
+                        style = MaterialTheme.typography.titleLarge,
+                        // Traversal index -1 forces TalkBack to focus on the mediaset title first.
+                        modifier = Modifier.semantics { traversalIndex = -1f },
+                    )
+                }
+            }
+            is Group.MediaSet -> {
+                Row(verticalAlignment = Alignment.CenterVertically) {
+                    // back button
+                    IconButton(
+                        modifier =
+                            Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
+                                .padding(horizontal = MEASUREMENT_ICON_BUTTON_OUTSIDE_PADDING),
+                        onClick = { navController.navigateToMediaSetGrid() },
+                    ) {
+                        Icon(
+                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                            // For accessibility
+                            contentDescription = stringResource(R.string.photopicker_back_option),
+                            tint = MaterialTheme.colorScheme.onSurface,
+                        )
+                    }
+                    Text(
+                        text = group.displayName ?: "",
+                        overflow = TextOverflow.Ellipsis,
+                        maxLines = 1,
+                        style = MaterialTheme.typography.titleLarge,
+                        // Traversal index -1 forces TalkBack to focus on the mediaset title first.
+                        modifier = Modifier.semantics { traversalIndex = -1f },
+                    )
+                }
+            }
+            else -> {}
+        }
+        val featureManager = LocalFeatureManager.current
+        val overFlowMenuEnabled =
+            remember(featureManager) {
+                featureManager.isFeatureEnabled(OverflowMenuFeature::class.java)
+            }
+        Row(modifier = Modifier.weight(1f), horizontalArrangement = Arrangement.End) {
+            if (overFlowMenuEnabled) {
+                featureManager.composeLocation(
+                    Location.OVERFLOW_MENU,
+                    modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH),
+                )
+            } else {
+                Spacer(Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH))
+            }
+        }
+    }
+}
+
 /**
  * A composable function that displays a Navigation Bar with an integrated search bar which is
  * called when the search feature is enabled.
@@ -299,7 +448,7 @@ private fun NavigationBarWithSearch(modifier: Modifier, params: LocationParams)
         verticalArrangement = Arrangement.Top,
         horizontalAlignment = Alignment.Start,
     ) {
-        Row(verticalAlignment = Alignment.CenterVertically, modifier = modifier) {
+        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth()) {
             featureManager.composeLocation(
                 Location.SEARCH_BAR,
                 maxSlots = 1,
@@ -329,7 +478,7 @@ private fun NavigationBarWithSearch(modifier: Modifier, params: LocationParams)
                 }
             }
         }
-        NavigationBarButtons(Modifier.padding(start = 8.dp, end = 8.dp))
+        NavigationBarButtons(Modifier)
     }
 }
 
diff --git a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt
index a84b71ac0..b61675737 100644
--- a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt
+++ b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt
@@ -23,13 +23,18 @@ import androidx.compose.foundation.gestures.detectHorizontalDragGestures
 import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.Column
 import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
 import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
 import androidx.compose.foundation.lazy.grid.GridCells
 import androidx.compose.foundation.lazy.grid.rememberLazyGridState
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.outlined.Image
+import androidx.compose.material3.Icon
 import androidx.compose.material3.Text
 import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
 import androidx.compose.runtime.Composable
@@ -37,12 +42,13 @@ import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.remember
 import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.platform.LocalConfiguration
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.text.style.TextOverflow
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.paging.LoadState
@@ -74,12 +80,14 @@ import com.android.photopicker.core.obtainViewModel
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.theme.LocalWindowSizeClass
 import com.android.photopicker.extensions.navigateToAlbumGrid
+import com.android.photopicker.extensions.navigateToCategoryGrid
 import com.android.photopicker.extensions.navigateToPhotoGrid
 import com.android.photopicker.extensions.navigateToPreviewMedia
-import com.android.photopicker.extensions.transferTouchesToHostInEmbedded
 import com.android.photopicker.features.albumgrid.AlbumGridFeature
+import com.android.photopicker.features.categorygrid.CategoryGridFeature
 import com.android.photopicker.features.navigationbar.NavigationBarButton
 import com.android.photopicker.features.preview.PreviewFeature
+import com.android.photopicker.features.search.SearchFeature
 import com.android.photopicker.util.LocalLocalizationHelper
 import kotlinx.coroutines.launch
 
@@ -159,6 +167,21 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
                                 )
                             }
                             navController.navigateToAlbumGrid()
+                        } else if (
+                            featureManager.isFeatureEnabled(CategoryGridFeature::class.java)
+                        ) {
+                            // Dispatch UI event to indicate switching to collections tab
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.CATEGORY_GRID.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.SWITCH_PICKER_TAB,
+                                    )
+                                )
+                            }
+                            navController.navigateToCategoryGrid()
                         }
                     }
                 }
@@ -193,7 +216,7 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
                         if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
                             // In embedded no need to give extra top padding to make empty
                             // state title and body clearly visible in collapse mode (small view)
-                            Modifier.fillMaxWidth().transferTouchesToHostInEmbedded(host = host)
+                            Modifier.fillMaxWidth()
                         } else {
                             // Provide 20% of screen height as empty space above
                             Modifier.fillMaxWidth().padding(top = emptyStatePadding)
@@ -213,11 +236,6 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
                 mediaGrid(
                     items = items,
                     isExpandedScreen = isExpandedScreen,
-                    userScrollEnabled =
-                        when (isEmbedded) {
-                            true -> isExpanded
-                            false -> true
-                        },
                     selection = selection,
                     bannerContent = {
                         hideWhenState(
@@ -342,7 +360,9 @@ fun PhotoGridNavButton(modifier: Modifier) {
     val scope = rememberCoroutineScope()
     val events = LocalEvents.current
     val configuration = LocalPhotopickerConfiguration.current
-    val contentDescriptionString = stringResource(R.string.photopicker_photos_nav_button_label)
+    val featureManager = LocalFeatureManager.current
+    val categoryFeatureEnabled = featureManager.isFeatureEnabled(CategoryGridFeature::class.java)
+    val searchFeatureEnabled = featureManager.isFeatureEnabled(SearchFeature::class.java)
 
     NavigationBarButton(
         onClick = {
@@ -359,9 +379,26 @@ fun PhotoGridNavButton(modifier: Modifier) {
             }
             navController.navigateToPhotoGrid()
         },
-        modifier = modifier.semantics { contentDescription = contentDescriptionString },
+        modifier = modifier,
         isCurrentRoute = { route -> route == PHOTO_GRID.route },
     ) {
-        Text(stringResource(R.string.photopicker_photos_nav_button_label))
+        when {
+            categoryFeatureEnabled && searchFeatureEnabled -> {
+                Row(verticalAlignment = Alignment.CenterVertically) {
+                    Icon(
+                        imageVector = Icons.Outlined.Image,
+                        contentDescription = null,
+                        modifier = Modifier.size(18.dp),
+                    )
+                    Spacer(Modifier.width(8.dp))
+                    Text(
+                        stringResource(R.string.photopicker_photos_nav_button_label),
+                        maxLines = 1, // Limit the text to a single line
+                        overflow = TextOverflow.Ellipsis,
+                    )
+                }
+            }
+            else -> Text(stringResource(R.string.photopicker_photos_nav_button_label))
+        }
     }
 }
diff --git a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt
index 75edcba66..cd38379b7 100644
--- a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt
@@ -69,7 +69,7 @@ class PhotoGridFeature : PhotopickerUiFeature {
         setOf(Event.ShowSnackbarMessage::class.java, Event.LogPhotopickerUIEvent::class.java)
 
     override fun registerLocations(): List<Pair<Location, Int>> {
-        return listOf(Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGH.priority))
+        return listOf(Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGHEST.priority))
     }
 
     override fun registerNavigationRoutes(): Set<Route> {
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt b/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt
index 41753b265..df626b1a9 100644
--- a/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt
@@ -474,6 +474,31 @@ constructor(
                 // Trigger transcoding.
                 val transcodeStatus =
                     if (transcoder.isTranscodeRequired(context, mediaCapabilities, item)) {
+                        val transcodingVideoInfo: Transcoder.VideoInfo? =
+                            transcoder.getTranscodingVideoInfo()
+                        scope.launch {
+                            val configuration = configurationManager.configuration.value
+                            if (transcodingVideoInfo != null) {
+                                events.dispatch(
+                                    Event.ReportTranscodingVideoDetails(
+                                        dispatcherToken = FeatureToken.CORE.token,
+                                        sessionId = configuration.sessionId,
+                                        duration = transcodingVideoInfo.duration,
+                                        colorTransfer = transcodingVideoInfo.colorTransfer,
+                                        colorStandard = transcodingVideoInfo.colorStandard,
+                                        mimeType = transcodingVideoInfo.mimeType,
+                                    )
+                                )
+                            }
+                            events.dispatch(
+                                Event.LogPhotopickerUIEvent(
+                                    FeatureToken.CORE.token,
+                                    configuration.sessionId,
+                                    configuration.callingPackageUid ?: -1,
+                                    Telemetry.UiEvent.PICKER_TRANSCODING_START,
+                                )
+                            )
+                        }
                         val uri = item.mediaUri
                         val resultBundle =
                             contentResolver.call(
@@ -485,9 +510,31 @@ constructor(
 
                         if (resultBundle?.getBoolean(PICKER_TRANSCODE_RESULT, false) == true) {
                             Log.v(PrepareMediaFeature.TAG, "Transcode successful: $item")
+                            scope.launch {
+                                val configuration = configurationManager.configuration.value
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.CORE.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.PICKER_TRANSCODING_SUCCESS,
+                                    )
+                                )
+                            }
                             TranscodeStatus.SUCCEED
                         } else {
                             Log.w(PrepareMediaFeature.TAG, "Not able to transcode: $item")
+                            scope.launch {
+                                val configuration = configurationManager.configuration.value
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.CORE.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.PICKER_TRANSCODING_FAILED,
+                                    )
+                                )
+                            }
                             TranscodeStatus.NOT_APPLIED
                         }
                     } else {
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt b/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt
index f2f82e89e..5b1bb38fd 100644
--- a/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt
@@ -26,6 +26,14 @@ import com.android.photopicker.data.model.Media
 /** Provides methods to help video transcode. */
 interface Transcoder {
 
+    /** Data class to hold details of the transcoding video. */
+    data class VideoInfo(
+        val duration: Int,
+        val colorStandard: Int,
+        val colorTransfer: Int,
+        val mimeType: Int,
+    )
+
     /**
      * Checks if a transcode is required for the given video.
      *
@@ -39,6 +47,9 @@ interface Transcoder {
         video: Media.Video,
     ): Boolean
 
+    /** Returns details of the video that needs transcoding */
+    fun getTranscodingVideoInfo(): VideoInfo?
+
     companion object {
 
         /**
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt b/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt
index 547440037..bf48ed34f 100644
--- a/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt
@@ -31,11 +31,14 @@ import androidx.annotation.VisibleForTesting
 import androidx.media3.common.util.MediaFormatUtil.createFormatFromMediaFormat
 import androidx.media3.common.util.MediaFormatUtil.isVideoFormat
 import androidx.media3.exoplayer.MediaExtractorCompat
+import com.android.photopicker.core.events.Telemetry
 import com.android.photopicker.data.model.Media
 
 /** A class that help video transcode. */
 class TranscoderImpl : Transcoder {
 
+    private var needsTranscodingVideoInfo: Transcoder.VideoInfo? = null
+
     override fun isTranscodeRequired(
         context: Context,
         mediaCapabilities: ApplicationMediaCapabilities?,
@@ -53,7 +56,7 @@ class TranscoderImpl : Transcoder {
         // Check if any video tracks need to be transcoded.
         val videoTrackMediaFormats = getVideoTrackMediaFormats(context, video)
         for (mediaFormat in videoTrackMediaFormats) {
-            if (isTranscodeRequired(mediaFormat, mediaCapabilities)) {
+            if (isTranscodeRequired(mediaFormat, mediaCapabilities, video.duration)) {
                 return true
             }
         }
@@ -98,6 +101,7 @@ class TranscoderImpl : Transcoder {
     fun isTranscodeRequired(
         mediaFormat: MediaFormat,
         mediaCapabilities: ApplicationMediaCapabilities,
+        duration: Int = 0,
     ): Boolean {
         val format = createFormatFromMediaFormat(mediaFormat)
         val mimeType = format.sampleMimeType
@@ -111,6 +115,13 @@ class TranscoderImpl : Transcoder {
                 // what the caller intended.
 
                 if (isHlg10(colorStandard, colorTransfer) && !isHdrTypeSupported(HdrType.HLG)) {
+                    needsTranscodingVideoInfo =
+                        Transcoder.VideoInfo(
+                            duration,
+                            colorStandard ?: 0,
+                            colorTransfer ?: 0,
+                            Telemetry.VideoMimeType.HEVC.type,
+                        )
                     return true
                 }
 
@@ -119,6 +130,13 @@ class TranscoderImpl : Transcoder {
                         (!isHdrTypeSupported(HdrType.HDR10) ||
                             !isHdrTypeSupported(HdrType.HDR10_PLUS))
                 ) {
+                    needsTranscodingVideoInfo =
+                        Transcoder.VideoInfo(
+                            duration,
+                            colorStandard ?: 0,
+                            colorTransfer ?: 0,
+                            Telemetry.VideoMimeType.HEVC.type,
+                        )
                     return true
                 }
             }
@@ -127,13 +145,24 @@ class TranscoderImpl : Transcoder {
                 isHdrDolbyVision(mimeType, colorStandard, colorTransfer) &&
                     !isHdrTypeSupported(HdrType.DOLBY_VISION)
             ) {
+                needsTranscodingVideoInfo =
+                    Transcoder.VideoInfo(
+                        duration,
+                        colorStandard ?: 0,
+                        colorTransfer ?: 0,
+                        Telemetry.VideoMimeType.DOLBY.type,
+                    )
                 return true
             }
         }
-
         return false
     }
 
+    /** Returns details of the video that needs transcoding */
+    override fun getTranscodingVideoInfo(): Transcoder.VideoInfo? {
+        return needsTranscodingVideoInfo
+    }
+
     companion object {
         private const val TAG = "Transcoder"
         @VisibleForTesting const val DURATION_LIMIT_MS = 60_000L // 1 min
diff --git a/photopicker/src/com/android/photopicker/features/preview/Preview.kt b/photopicker/src/com/android/photopicker/features/preview/Preview.kt
index 90b1b3e9b..62acf2f8e 100644
--- a/photopicker/src/com/android/photopicker/features/preview/Preview.kt
+++ b/photopicker/src/com/android/photopicker/features/preview/Preview.kt
@@ -17,6 +17,7 @@
 package com.android.photopicker.features.preview
 
 import androidx.compose.foundation.background
+import androidx.compose.foundation.focusable
 import androidx.compose.foundation.layout.Arrangement
 import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.Column
@@ -29,7 +30,7 @@ import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.only
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.size
-import androidx.compose.foundation.layout.statusBars
+import androidx.compose.foundation.layout.systemBars
 import androidx.compose.foundation.layout.windowInsetsPadding
 import androidx.compose.foundation.pager.HorizontalPager
 import androidx.compose.foundation.pager.PagerState
@@ -58,13 +59,14 @@ import androidx.compose.runtime.rememberCoroutineScope
 import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.focus.focusRequester
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.vector.ImageVector
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.res.vectorResource
-import androidx.compose.ui.semantics.contentDescription
 import androidx.compose.ui.semantics.onClick
 import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.semantics.traversalIndex
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.paging.compose.LazyPagingItems
@@ -91,7 +93,11 @@ import com.android.photopicker.core.theme.CustomAccentColorScheme
 import com.android.photopicker.core.theme.LocalFixedAccentColors
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.navigateToPreviewSelection
+import com.android.photopicker.util.HierarchicalFocusCoordinator
 import com.android.photopicker.util.LocalLocalizationHelper
+import com.android.photopicker.util.getMediaContentDescription
+import com.android.photopicker.util.rememberActiveFocusRequester
+import java.text.DateFormat
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.launch
 
@@ -146,6 +152,11 @@ fun PreviewSelection(
         }
 
     if (selection != null) {
+        val dateFormat =
+            LocalLocalizationHelper.current.getLocalizedDateTimeFormatter(
+                DateFormat.MEDIUM,
+                DateFormat.SHORT,
+            )
         // Only snapshot the selection once when the composable is created.
         LaunchedEffect(Unit) { viewModel.takeNewSelectionSnapshot() }
         val navController = LocalNavController.current
@@ -156,7 +167,7 @@ fun PreviewSelection(
                     // This is inside an edge-to-edge dialog, so apply padding to ensure the
                     // UI buttons stay above the navigation bar.
                     Modifier.windowInsetsPadding(
-                        WindowInsets.statusBars.only(WindowInsetsSides.Vertical)
+                        WindowInsets.systemBars.only(WindowInsetsSides.Vertical)
                     )
             ) {
                 Row(
@@ -189,6 +200,7 @@ fun PreviewSelection(
                             state,
                             snackbarHostState,
                             /* singleItemPreview */ previewSingleItem,
+                            dateFormat,
                         )
 
                         // Only show the selection button if not in single select.
@@ -378,23 +390,41 @@ private fun PreviewPager(
     state: PagerState,
     snackbarHostState: SnackbarHostState,
     singleItemPreview: Boolean,
+    dateFormat: DateFormat,
 ) {
     // Preview session state to keep track if the video player's audio is muted.
     var audioIsMuted by remember { mutableStateOf(true) }
 
-    HorizontalPager(state = state, modifier = modifier) { page ->
-        val media = selection.get(page)
-        if (media != null) {
-            when (media) {
-                is Media.Image -> ImageUi(media, singleItemPreview)
-                is Media.Video ->
-                    VideoUi(
-                        media,
-                        audioIsMuted,
-                        { audioIsMuted = it },
-                        snackbarHostState,
-                        singleItemPreview,
-                    )
+    HorizontalPager(
+        state = state,
+        modifier = modifier.semantics(mergeDescendants = true) { traversalIndex = -1f },
+    ) { page ->
+        HierarchicalFocusCoordinator(requiresFocus = { state.currentPage == page }) {
+            val focusRequester = rememberActiveFocusRequester()
+            val media = selection.get(page)
+            if (media != null) {
+                Box(modifier = Modifier.focusRequester(focusRequester).focusable(true)) {
+                    val pageDescription =
+                        stringResource(
+                            R.string.pohtopicker_horizontal_pager_description,
+                            state.currentPage + 1,
+                            state.pageCount,
+                        )
+                    val mediaDescription = getMediaContentDescription(media, dateFormat)
+                    val contentDescription = mediaDescription + pageDescription
+                    when (media) {
+                        is Media.Image -> ImageUi(media, singleItemPreview, contentDescription)
+                        is Media.Video ->
+                            VideoUi(
+                                media,
+                                audioIsMuted,
+                                { audioIsMuted = it },
+                                snackbarHostState,
+                                singleItemPreview,
+                                contentDescription,
+                            )
+                    }
+                }
             }
         }
     }
@@ -406,7 +436,7 @@ private fun PreviewPager(
  * @param image
  */
 @Composable
-private fun ImageUi(image: Media.Image, singleItemPreview: Boolean) {
+private fun ImageUi(image: Media.Image, singleItemPreview: Boolean, contentDescription: String) {
     if (singleItemPreview) {
         val events = LocalEvents.current
         val scope = rememberCoroutineScope()
@@ -436,6 +466,7 @@ private fun ImageUi(image: Media.Image, singleItemPreview: Boolean) {
         media = image,
         resolution = Resolution.FULL,
         modifier = Modifier.fillMaxSize(),
+        contentDescription = contentDescription,
         // by default loadMedia center crops, so use a custom request builder
         requestBuilderTransformation = { media, resolution, builder ->
             builder.set(RESOLUTION_REQUESTED, resolution).signature(media.getSignature(resolution))
diff --git a/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt b/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt
index 6dd71d25a..f81688ef9 100644
--- a/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt
+++ b/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt
@@ -37,7 +37,6 @@ import androidx.compose.foundation.clickable
 import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.aspectRatio
 import androidx.compose.foundation.layout.fillMaxSize
-import androidx.compose.foundation.layout.height
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.size
 import androidx.compose.material.icons.Icons
@@ -67,6 +66,8 @@ import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.semantics.contentDescription
+import androidx.compose.ui.semantics.semantics
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.viewinterop.AndroidView
 import androidx.core.os.bundleOf
@@ -80,7 +81,6 @@ import com.android.photopicker.core.obtainViewModel
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.requireSystemService
 import kotlinx.coroutines.delay
-import kotlinx.coroutines.flow.collect
 import kotlinx.coroutines.flow.filter
 import kotlinx.coroutines.launch
 
@@ -123,6 +123,7 @@ fun VideoUi(
     onRequestAudioMuteChange: (Boolean) -> Unit,
     snackbarHostState: SnackbarHostState,
     singleItemPreview: Boolean,
+    contentDescriptionString: String,
     viewModel: PreviewViewModel = obtainViewModel(),
 ) {
 
@@ -219,7 +220,7 @@ fun VideoUi(
     // Finally! Now the actual VideoPlayer can be created! \0/
     // This is the top level box of the player, and all of its children are drawn on-top
     // of each other.
-    Box {
+    Box(Modifier.semantics { contentDescription = contentDescriptionString }) {
         VideoPlayer(
             aspectRatio = aspectRatio,
             playbackInfo = playbackInfo,
diff --git a/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt b/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt
index 2e6374fe4..fee117d82 100644
--- a/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt
+++ b/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt
@@ -167,12 +167,12 @@ fun ProfileSelector(
                             else -> MaterialTheme.colorScheme.surfaceContainerHigh
                         }
                     val surfaceContentColor = contentColorFor(surfaceColor)
+                    val profileLabel = profile.label ?: getLabelForProfile(profile)
                     val selectedProfileDescription =
                         stringResource(
                             R.string.photopicker_selected_profile_description,
-                            currentProfileLabel,
+                            profileLabel,
                         )
-                    val profileLabel = profile.label ?: getLabelForProfile(profile)
 
                     // The background color behind the text
                     Surface(
@@ -216,6 +216,7 @@ fun ProfileSelector(
                             text = {
                                 Text(
                                     text = profileLabel,
+                                    color = surfaceContentColor,
                                     style = MaterialTheme.typography.bodyLarge,
                                     modifier =
                                         Modifier.semantics {
diff --git a/photopicker/src/com/android/photopicker/features/search/Search.kt b/photopicker/src/com/android/photopicker/features/search/Search.kt
index 400d13c83..9cd927e09 100644
--- a/photopicker/src/com/android/photopicker/features/search/Search.kt
+++ b/photopicker/src/com/android/photopicker/features/search/Search.kt
@@ -17,6 +17,7 @@
 package com.android.photopicker.features.search
 
 import android.util.Log
+import androidx.activity.compose.BackHandler
 import androidx.compose.foundation.background
 import androidx.compose.foundation.clickable
 import androidx.compose.foundation.layout.Arrangement
@@ -29,13 +30,16 @@ import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.height
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
 import androidx.compose.foundation.lazy.LazyColumn
 import androidx.compose.foundation.lazy.grid.rememberLazyGridState
 import androidx.compose.foundation.lazy.items
+import androidx.compose.foundation.lazy.rememberLazyListState
 import androidx.compose.foundation.shape.CircleShape
 import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material.icons.filled.Close
 import androidx.compose.material.icons.filled.Today
 import androidx.compose.material.icons.outlined.HideImage
 import androidx.compose.material.icons.outlined.History
@@ -66,12 +70,14 @@ import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.remember
 import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.runtime.rememberUpdatedState
 import androidx.compose.runtime.saveable.rememberSaveable
 import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.draw.clip
-import androidx.compose.ui.graphics.ImageBitmap
+import androidx.compose.ui.focus.FocusRequester
+import androidx.compose.ui.focus.focusRequester
 import androidx.compose.ui.graphics.Shape
 import androidx.compose.ui.graphics.vector.ImageVector
 import androidx.compose.ui.platform.LocalConfiguration
@@ -83,42 +89,50 @@ import androidx.compose.ui.unit.IntSize
 import androidx.compose.ui.unit.LayoutDirection
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.window.PopupPositionProvider
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.compose.LocalLifecycleOwner
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.lifecycle.repeatOnLifecycle
 import androidx.paging.LoadState
 import androidx.paging.PagingData
 import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.R
 import com.android.photopicker.core.components.EmptyState
 import com.android.photopicker.core.components.MediaGridItem
 import com.android.photopicker.core.components.mediaGrid
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.embedded.LocalEmbeddedState
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.Telemetry
 import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.glide.Resolution
+import com.android.photopicker.core.glide.loadMedia
 import com.android.photopicker.core.navigation.LocalNavController
 import com.android.photopicker.core.obtainViewModel
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.theme.LocalWindowSizeClass
 import com.android.photopicker.extensions.navigateToPreviewMedia
+import com.android.photopicker.extensions.transferScrollableTouchesToHostInEmbedded
 import com.android.photopicker.features.preview.PreviewFeature
-import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.SearchViewModel.Companion.ZERO_STATE_SEARCH_QUERY
 import com.android.photopicker.features.search.model.SearchSuggestion
 import com.android.photopicker.features.search.model.SearchSuggestionType
-import com.android.photopicker.util.rememberBitmapFromUri
+import com.android.photopicker.features.search.model.UserSearchState
 import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.flow
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
 
-private val MEASUREMENT_SEARCH_BAR_HEIGHT = 56.dp
 private val MEASUREMENT_SEARCH_BAR_PADDING =
     PaddingValues(start = 8.dp, end = 8.dp, top = 8.dp, bottom = 16.dp)
 
-private val FETCH_SUGGESTION_DEBOUNCE_DELAY = 300L // in milliseconds
+private val FETCH_SUGGESTION_DEBOUNCE_DELAY = 50L // in milliseconds
 
 private val SUGGESTION_TITLE_PADDING =
     PaddingValues(start = 32.dp, end = 32.dp, top = 12.dp, bottom = 12.dp)
@@ -161,9 +175,9 @@ fun Search(
     params: LocationParams,
     viewModel: SearchViewModel = obtainViewModel(),
 ) {
-    val searchEnabled by viewModel.searchEnabled.collectAsStateWithLifecycle()
+    val userSearchStateInfo by viewModel.userSearchStateInfo.collectAsStateWithLifecycle()
     when {
-        searchEnabled == SearchEnabledState.ENABLED -> {
+        userSearchStateInfo.state == UserSearchState.ENABLED -> {
             SearchBarEnabled(params, viewModel, modifier)
         }
         else -> {
@@ -185,10 +199,11 @@ fun SearchBarEnabled(params: LocationParams, viewModel: SearchViewModel, modifie
     val focused = rememberSaveable { mutableStateOf(false) }
     val searchTerm = rememberSaveable { mutableStateOf("") }
     val searchState by viewModel.searchState.collectAsStateWithLifecycle()
-    val suggestionLists by viewModel.suggestionLists.collectAsStateWithLifecycle()
+    val suggestionLists by viewModel.searchSuggestions.collectAsStateWithLifecycle()
     val scope = rememberCoroutineScope()
     val events = LocalEvents.current
     val configuration = LocalPhotopickerConfiguration.current
+
     SearchBar(
         inputField = {
             SearchInputContent(
@@ -259,7 +274,7 @@ fun SearchBarEnabled(params: LocationParams, viewModel: SearchViewModel, modifie
                     if (suggestionLists.totalSuggestions > 0) {
                         val focusManager = LocalFocusManager.current
                         ShowSuggestions(
-                            suggestionLists = suggestionLists,
+                            searchSuggestions = suggestionLists,
                             isZeroSearchState = searchTerm.value.isEmpty(),
                             onSuggestionClick = { suggestion ->
                                 focusManager.clearFocus()
@@ -290,58 +305,62 @@ fun SearchBarEnabled(params: LocationParams, viewModel: SearchViewModel, modifie
 fun SearchBarWithTooltip(modifier: Modifier) {
     val tooltipState = rememberTooltipState()
     val scope = rememberCoroutineScope()
-    TooltipBox(
-        positionProvider =
-            remember {
-                object : PopupPositionProvider {
-                    override fun calculatePosition(
-                        anchorBounds: IntRect,
-                        windowSize: IntSize,
-                        layoutDirection: LayoutDirection,
-                        popupContentSize: IntSize,
-                    ): IntOffset {
-                        return IntOffset(
-                            x =
-                                anchorBounds.left +
-                                    (anchorBounds.width - popupContentSize.width) / 2,
-                            y = anchorBounds.bottom - popupContentSize.height,
-                        )
+    // Applying here the passed modifier to Box allowing the caller of the SearchBarWithTooltip
+    // function to control the appearance and layout of the entire search bar and tooltip unit so
+    // that the tooltip with disabled search bar can be modified to fill width of the box.
+    Box(modifier = modifier) {
+        TooltipBox(
+            positionProvider =
+                remember {
+                    object : PopupPositionProvider {
+                        override fun calculatePosition(
+                            anchorBounds: IntRect,
+                            windowSize: IntSize,
+                            layoutDirection: LayoutDirection,
+                            popupContentSize: IntSize,
+                        ): IntOffset {
+                            return IntOffset(
+                                x =
+                                    anchorBounds.left +
+                                        (anchorBounds.width - popupContentSize.width) / 2,
+                                y = anchorBounds.bottom - popupContentSize.height,
+                            )
+                        }
                     }
+                },
+            tooltip = {
+                PlainTooltip {
+                    Text(text = stringResource(R.string.photopicker_search_disabled_hint))
                 }
             },
-        tooltip = {
-            PlainTooltip { Text(text = stringResource(R.string.photopicker_search_disabled_hint)) }
-        },
-        state = tooltipState,
-    ) {
-        SearchBar(
-            inputField = {
-                SearchBarDefaults.InputField(
-                    query = "",
-                    enabled = false,
-                    placeholder = { SearchBarPlaceHolder(false) },
-                    colors = TextFieldDefaults.colors(MaterialTheme.colorScheme.surface),
-                    onQueryChange = {},
-                    onSearch = {},
-                    expanded = false,
-                    onExpandedChange = {},
-                    leadingIcon = { SearchBarIcon(false, {}, {}, searchDisabled = true) },
-                    modifier =
-                        modifier.height(MEASUREMENT_SEARCH_BAR_HEIGHT).clickable {
-                            scope.launch { tooltipState.show() }
-                        },
-                )
-            },
-            expanded = false,
-            onExpandedChange = {},
-            colors =
-                SearchBarDefaults.colors(
-                    containerColor = MaterialTheme.colorScheme.surfaceContainer,
-                    dividerColor = MaterialTheme.colorScheme.outlineVariant,
-                ),
-            modifier = modifier.padding(MEASUREMENT_SEARCH_BAR_PADDING),
-            content = {},
-        )
+            state = tooltipState,
+        ) {
+            SearchBar(
+                inputField = {
+                    SearchBarDefaults.InputField(
+                        query = "",
+                        enabled = false,
+                        placeholder = { SearchBarPlaceHolder(false) },
+                        colors = TextFieldDefaults.colors(MaterialTheme.colorScheme.surface),
+                        onQueryChange = {},
+                        onSearch = {},
+                        expanded = false,
+                        onExpandedChange = {},
+                        leadingIcon = { SearchBarIcon(false, {}, {}, searchDisabled = true) },
+                        modifier = Modifier.clickable { scope.launch { tooltipState.show() } },
+                    )
+                },
+                expanded = false,
+                onExpandedChange = {},
+                colors =
+                    SearchBarDefaults.colors(
+                        containerColor = MaterialTheme.colorScheme.surfaceContainer,
+                        dividerColor = MaterialTheme.colorScheme.outlineVariant,
+                    ),
+                modifier = Modifier.fillMaxWidth().padding(MEASUREMENT_SEARCH_BAR_PADDING),
+                content = {},
+            )
+        }
     }
 }
 
@@ -371,17 +390,18 @@ fun SearchInputContent(
     searchState: SearchState,
     modifier: Modifier,
 ) {
+    // BackHandler to intercept the system back button press when focused
+    BackHandler(enabled = focused) {
+        onFocused(false)
+        onSearchQueryChanged("")
+    }
     when (
-        searchState is SearchState.Active.SuggestionSearch &&
+        focused &&
+            searchState is SearchState.Active.SuggestionSearch &&
             searchState.suggestion.type == SearchSuggestionType.FACE
     ) {
         true -> {
-            ShowSearchInputWithCustomIcon(
-                searchState.suggestion,
-                onFocused,
-                onSearchQueryChanged,
-                viewModel,
-            )
+            ShowSearchInputWithCustomIcon(searchState.suggestion, onFocused, onSearchQueryChanged)
         }
         else -> {
             SearchInput(
@@ -410,16 +430,12 @@ fun SearchInputContent(
  * @param searchQuery The current text entered in search bar input field.
  * @param focused A boolean value indicating whether the search input field is currently focused.
  * @param onSearchQueryChanged A callback function that is invoked when the search query text
- *   changes.
- *     * This function receives the updated search query as a parameter.
- *
+ *   changes. This function receives the updated search query as a parameter.
  * @param onFocused A callback function that is invoked when the focus state of the search field
- *   changes.
- *     * This function receives a boolean value indicating the new focus state.
- *
+ *   changes. This function receives a boolean value indicating the new focus state.
  * @param onSearch A callback function to be invoked when a text is searched.
  * @param modifier A Modifier that can be applied to the SearchInput composable to customize its
- *     * appearance and behavior.
+ *   appearance and behavior.
  */
 @Composable
 @OptIn(ExperimentalMaterial3Api::class)
@@ -432,6 +448,7 @@ private fun SearchInput(
     modifier: Modifier,
 ) {
     val focusManager = LocalFocusManager.current
+    val focusRequester = remember { FocusRequester() }
     SearchBarDefaults.InputField(
         query = searchQuery,
         placeholder = { SearchBarPlaceHolder(focused) },
@@ -454,8 +471,60 @@ private fun SearchInput(
         expanded = focused,
         onExpandedChange = onFocused,
         leadingIcon = { SearchBarIcon(focused, onFocused, onSearchQueryChanged) },
-        modifier = modifier.height(MEASUREMENT_SEARCH_BAR_HEIGHT),
+        trailingIcon = {
+            SearchBarTrailingIcon(
+                focused && !searchQuery.equals(ZERO_STATE_SEARCH_QUERY),
+                onSearchQueryChanged,
+            )
+        },
+        modifier = modifier.focusRequester(focusRequester),
     )
+    RequestFocusOnResume(focusRequester = focusRequester, focused)
+}
+
+/**
+ * A composable function that displays the trailing icon in a SearchBar. The icon is shown when
+ * query is typed clicking on which clears the typed text.
+ *
+ * @param showClearIcon A boolean value indicating whether clear icon is to be shown
+ * @param onSearchQueryChanged A callback function that is invoked when the search query text
+ *   changes. This function receives the updated search query as a parameter.
+ * @param viewModel The `SearchViewModel` providing the search logic and state.
+ */
+@Composable
+private fun SearchBarTrailingIcon(
+    showClearIcon: Boolean,
+    onSearchQueryChanged: (String) -> Unit,
+    viewModel: SearchViewModel = obtainViewModel(),
+) {
+    val searchState by viewModel.searchState.collectAsStateWithLifecycle()
+    if (showClearIcon && searchState is SearchState.Inactive) {
+        IconButton(onClick = { onSearchQueryChanged("") }) {
+            Icon(
+                Icons.Filled.Close,
+                contentDescription = stringResource(R.string.photopicker_search_clear_text),
+            )
+        }
+    }
+}
+
+@Composable
+private fun RequestFocusOnResume(
+    focusRequester: FocusRequester,
+    focused: Boolean,
+    viewModel: SearchViewModel = obtainViewModel(),
+) {
+    val lifecycleOwner = LocalLifecycleOwner.current
+    val searchState by viewModel.searchState.collectAsStateWithLifecycle()
+    LaunchedEffect(Unit) {
+        when (focused && searchState is SearchState.Inactive) {
+            true ->
+                lifecycleOwner.repeatOnLifecycle(state = Lifecycle.State.RESUMED) {
+                    focusRequester.requestFocus()
+                }
+            false -> {}
+        }
+    }
 }
 
 /**
@@ -475,14 +544,12 @@ private fun SearchInput(
  * @param onFocused A callback function to be invoked when the focus state of the search field
  *   changes.
  * @param onSearchQueryChanged A callback function to be invoked when the search query text changes.
- * @param viewModel The `SearchViewModel` providing the search logic and state.
  */
 @Composable
 fun ShowSearchInputWithCustomIcon(
     suggestion: SearchSuggestion,
     onFocused: (Boolean) -> Unit,
     onSearchQueryChanged: (String) -> Unit,
-    viewModel: SearchViewModel = obtainViewModel(),
 ) {
     Row(
         modifier = Modifier.padding(MEASUREMENT_SMALL_PADDING).fillMaxWidth(),
@@ -493,11 +560,8 @@ fun ShowSearchInputWithCustomIcon(
             onFocused = onFocused,
             onSearchQueryChanged = { onSearchQueryChanged("") },
         )
-        val imageBitmap =
-            suggestion.iconUri?.let { rememberBitmapFromUri(it, viewModel.backgroundDispatcher) }
         ShowSuggestionIcon(
             suggestion,
-            imageBitmap,
             modifier = Modifier.clip(CircleShape).size(MEASUREMENT_FACE_RESULT_ICON),
         )
         Text(
@@ -595,30 +659,48 @@ fun EmptySearchResult(modifier: Modifier = Modifier) {
         modifier = modifier.fillMaxWidth().padding(top = emptyStatePadding),
         icon = Icons.Outlined.HideImage,
         title = stringResource(R.string.photopicker_search_result_empty_state_title),
-        body = stringResource(R.string.photopicker_search_result_empty_state_body),
+        body = stringResource(R.string.photopicker_search_result_empty_state_message),
     )
 }
 
 /**
  * Composable function that shows suggestion in the search view.
  *
- * @param suggestionLists A `SuggestionLists` object containing the search suggestions to display.
+ * @param searchSuggestions A `SearchSuggestions` object containing the different types of
+ *   suggestions to be displayed.
  * @param isZeroSearchState A boolean value indicating if the search query is empty.
  * @param modifier A Modifier that can be applied to the suggestions list.
  * @param onSuggestionClick A callback function to be invoked when a suggestion is clicked.
  */
 @Composable
 private fun ShowSuggestions(
-    suggestionLists: SuggestionLists,
+    searchSuggestions: SearchSuggestions,
     isZeroSearchState: Boolean,
     modifier: Modifier,
     onSuggestionClick: (SearchSuggestion) -> Unit,
 ) {
-    val historySuggestions = suggestionLists.history
-    val faceSuggestions = suggestionLists.face
-    val otherSuggestions = suggestionLists.other
+    val isEmbedded =
+        LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
+    val host = LocalEmbeddedState.current?.host
+    val isExpanded = rememberUpdatedState(LocalEmbeddedState.current?.isExpanded ?: false)
+    val events = LocalEvents.current
+    val configuration = LocalPhotopickerConfiguration.current
+
+    val historySuggestions = searchSuggestions.history
+    val faceSuggestions = searchSuggestions.face
+    val otherSuggestions = searchSuggestions.other
+
+    val state = rememberLazyListState()
     Box(modifier = modifier.padding(MEASUREMENT_LARGE_PADDING)) {
-        LazyColumn {
+        LazyColumn(
+            modifier =
+                if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                    modifier.transferScrollableTouchesToHostInEmbedded(state, isExpanded, host)
+                } else {
+                    modifier
+                },
+            state = state,
+        ) {
             item { Spacer(modifier = Modifier.height(MEASUREMENT_MEDIUM_PADDING)) }
             items(historySuggestions.take(SearchViewModel.HISTORY_SUGGESTION_MAX_LIMIT)) {
                 suggestion ->
@@ -633,11 +715,13 @@ private fun ShowSuggestions(
                     onSuggestionClick,
                 )
             }
-            item {
-                Text(
-                    text = stringResource(R.string.photopicker_search_suggestions_text),
-                    modifier = Modifier.padding(SUGGESTION_TITLE_PADDING),
-                )
+            if (faceSuggestions.isNotEmpty() || otherSuggestions.isNotEmpty()) {
+                item {
+                    Text(
+                        text = stringResource(R.string.photopicker_search_suggestions_text),
+                        modifier = Modifier.padding(SUGGESTION_TITLE_PADDING),
+                    )
+                }
             }
             if (faceSuggestions.size > 0) {
                 item {
@@ -657,6 +741,16 @@ private fun ShowSuggestions(
                 )
             }
         }
+        LaunchedEffect(Unit) {
+            events.dispatch(
+                Event.LogPhotopickerUIEvent(
+                    FeatureToken.SEARCH.token,
+                    configuration.sessionId,
+                    configuration.callingPackageUid ?: -1,
+                    Telemetry.UiEvent.UI_LOADED_SEARCH_SUGGESTIONS,
+                )
+            )
+        }
     }
 }
 
@@ -707,34 +801,35 @@ private fun ShowSuggestionCard(
  * Composable that displays the actual suggestion item within a suggestion card
  *
  * @param suggestion The search suggestion item to display.
- * @param viewModel The `SearchViewModel` providing the search logic and state.
  */
 @Composable
-fun SuggestionItem(suggestion: SearchSuggestion, viewModel: SearchViewModel = obtainViewModel()) {
+fun SuggestionItem(suggestion: SearchSuggestion) {
     Row(
         verticalAlignment = Alignment.CenterVertically,
         modifier = Modifier.fillMaxWidth().padding(MEASUREMENT_SUGGESTION_ITEM_PADDING),
     ) {
-        Box(
-            modifier =
-                Modifier.background(MaterialTheme.colorScheme.surface, CircleShape).padding(6.dp)
-        ) {
-            Icon(
-                imageVector = getImageVector(suggestion.type),
-                contentDescription = suggestion.displayText ?: "",
-            )
+        if (suggestion.type == SearchSuggestionType.FACE) {
+            ShowSuggestionIcon(suggestion, Modifier.size(MEASUREMENT_OTHER_ICON).clip(CircleShape))
+        } else {
+            Box(
+                modifier =
+                    Modifier.background(MaterialTheme.colorScheme.surface, CircleShape)
+                        .padding(6.dp)
+            ) {
+                Icon(
+                    imageVector = getImageVector(suggestion.type),
+                    contentDescription = suggestion.displayText ?: "",
+                )
+            }
         }
         val text = suggestion.displayText ?: ""
         Text(text = text, modifier = Modifier.padding(start = MEASUREMENT_LARGE_PADDING).weight(1f))
-        if (suggestion.type != SearchSuggestionType.FACE && suggestion.iconUri != null) {
-            rememberBitmapFromUri(suggestion.iconUri, viewModel.backgroundDispatcher)?.let {
-                imageBitmap ->
-                ShowSuggestionIcon(
-                    suggestion,
-                    imageBitmap,
-                    modifier = Modifier.size(MEASUREMENT_OTHER_ICON),
-                )
-            }
+        if (
+            suggestion.type != SearchSuggestionType.FACE &&
+                suggestion.type != SearchSuggestionType.HISTORY &&
+                suggestion.icon != null
+        ) {
+            ShowSuggestionIcon(suggestion, Modifier.size(MEASUREMENT_OTHER_ICON).clip(CircleShape))
         }
     }
 }
@@ -745,14 +840,12 @@ fun SuggestionItem(suggestion: SearchSuggestion, viewModel: SearchViewModel = ob
  * @param list The list of `SearchSuggestion` objects of type FACE to be displayed.
  * @param onSuggestionClick A callback function to be invoked when a suggestion is clicked.
  * @param otherTypeCount The number of suggestions of other type in search suggestions list.
- * @param viewModel The `SearchViewModel` providing the search logic and state.
  */
 @Composable
 fun ShowFaceSuggestions(
     list: List<SearchSuggestion>,
     onSuggestionClick: (SearchSuggestion) -> Unit,
     otherTypeCount: Int,
-    viewModel: SearchViewModel = obtainViewModel(),
 ) {
     Card(
         modifier = Modifier.fillMaxWidth().padding(MEASUREMENT_EXTRA_SMALL_PADDING),
@@ -771,13 +864,8 @@ fun ShowFaceSuggestions(
             horizontalArrangement = Arrangement.spacedBy(MEASUREMENT_ITEM_GAP_PADDING),
         ) {
             list.take(SearchViewModel.FACE_SUGGESTION_MAX_LIMIT).forEach { suggestion ->
-                val imageBitmap =
-                    suggestion.iconUri?.let {
-                        rememberBitmapFromUri(it, viewModel.backgroundDispatcher)
-                    }
                 ShowSuggestionIcon(
                     suggestion,
-                    imageBitmap,
                     modifier =
                         Modifier.size(MEASUREMENT_FACE_SUGGESTION_ICON)
                             .clip(CircleShape)
@@ -796,19 +884,18 @@ fun ShowFaceSuggestions(
  * icon.
  *
  * @param suggestion The `SearchSuggestion` object containing the icon URI and suggestion type.
- * @param imageBitmap Bitmap for the suggestion icon to be shown.
  * @param modifier Modifiers to be applied to the Icon composable.
  */
 @Composable
-fun ShowSuggestionIcon(
-    suggestion: SearchSuggestion,
-    imageBitmap: ImageBitmap?,
-    modifier: Modifier,
-) {
+fun ShowSuggestionIcon(suggestion: SearchSuggestion, modifier: Modifier) {
     val imageDescription = suggestion.displayText ?: ""
     when {
-        imageBitmap != null -> {
-            Icon(bitmap = imageBitmap, contentDescription = imageDescription, modifier = modifier)
+        suggestion.icon != null -> {
+            loadMedia(
+                media = suggestion.icon,
+                resolution = Resolution.THUMBNAIL,
+                modifier = modifier.background(MaterialTheme.colorScheme.surface),
+            )
         }
         else -> {
             Icon(
@@ -870,7 +957,7 @@ private fun ResultMediaGrid(
                 delay(1000)
                 if (items.itemCount == 0) {
                     resultsState = ResultsState.LOADING_WITH_INDICATOR
-                    delay(4000)
+                    delay(10000)
                     if (resultsState == ResultsState.LOADING_WITH_INDICATOR)
                         resultsState = ResultsState.EMPTY
                 }
@@ -882,6 +969,16 @@ private fun ResultMediaGrid(
     when (resultsState) {
         ResultsState.EMPTY -> {
             EmptySearchResult()
+            LaunchedEffect(Unit) {
+                events.dispatch(
+                    Event.LogPhotopickerUIEvent(
+                        FeatureToken.SEARCH.token,
+                        configuration.sessionId,
+                        configuration.callingPackageUid ?: -1,
+                        Telemetry.UiEvent.UI_LOADED_EMPTY_STATE,
+                    )
+                )
+            }
         }
         ResultsState.LOADING_WITH_INDICATOR -> {
             Box(modifier = Modifier.fillMaxSize()) {
@@ -900,7 +997,16 @@ private fun ResultMediaGrid(
                                 item = item.media,
                                 selectionLimitExceededMessage = selectionLimitExceededMessage,
                             )
-                            // TODO: (b/381876944) Log Ui Event after adding search enum
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.SEARCH.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.SELECT_SEARCH_RESULT,
+                                    )
+                                )
+                            }
                         }
                     },
                     onItemLongPress = { item ->
@@ -934,6 +1040,17 @@ private fun ResultMediaGrid(
                     state = state,
                 )
             }
+            LaunchedEffect(Unit) {
+                // Dispatch UI event to log loading of search result contents
+                events.dispatch(
+                    Event.LogPhotopickerUIEvent(
+                        FeatureToken.SEARCH.token,
+                        configuration.sessionId,
+                        configuration.callingPackageUid ?: -1,
+                        Telemetry.UiEvent.UI_LOADED_SEARCH_RESULTS,
+                    )
+                )
+            }
         }
         else -> {}
     }
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt b/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt
index 26ed22801..9bb71a0d7 100644
--- a/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt
@@ -31,7 +31,7 @@ import com.android.photopicker.core.features.PhotopickerUiFeature
 import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.data.PrefetchDataService
-import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.GlobalSearchState
 import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.runBlocking
 
@@ -51,7 +51,7 @@ class SearchFeature : PhotopickerUiFeature {
                 mapOf(
                     PrefetchResultKey.SEARCH_STATE to
                         { prefetchDataService ->
-                            prefetchDataService.getSearchState()
+                            prefetchDataService.getGlobalSearchState()
                         }
                 )
             } else {
@@ -72,7 +72,9 @@ class SearchFeature : PhotopickerUiFeature {
                 val searchStatus: Any? =
                     deferredPrefetchResultsMap[PrefetchResultKey.SEARCH_STATE]?.await()
                 when (searchStatus) {
-                    is SearchEnabledState -> searchStatus == SearchEnabledState.ENABLED
+                    is GlobalSearchState ->
+                        searchStatus == GlobalSearchState.ENABLED ||
+                            searchStatus == GlobalSearchState.ENABLED_IN_OTHER_PROFILES_ONLY
                     else -> false // prefetch may have timed out
                 }
             }
@@ -103,5 +105,6 @@ class SearchFeature : PhotopickerUiFeature {
             Event.ShowSnackbarMessage::class.java,
             Event.LogPhotopickerUIEvent::class.java,
             Event.ReportPhotopickerSearchInfo::class.java,
+            Event.LogPhotopickerPageInfo::class.java,
         )
 }
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt b/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt
index 9d31c0f25..ab6822594 100644
--- a/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt
+++ b/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt
@@ -16,32 +16,110 @@
 
 package com.android.photopicker.features.search
 
+import android.util.Log
+import com.android.photopicker.features.search.SearchViewModel.Companion.ZERO_STATE_SEARCH_QUERY
 import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import java.util.Collections
+import java.util.LinkedHashSet
 
 /**
  * Class that implements cache for SearchSuggestions that stores a list of suggestions for a given
  * prefix
  */
 class SearchSuggestionCache {
-    private var cacheSuggestion: HashMap<String, List<SearchSuggestion>> = java.util.HashMap()
+    private val TAG = "SearchSuggestionCache"
+    private var cachedSuggestions: MutableMap<String, MutableSet<SearchSuggestion>> =
+        Collections.synchronizedMap(HashMap())
 
     /**
      * Retrieves suggestions for a given prefix from the cache.
      *
+     * If you need to iterate over the returned collection, please wrap it with
+     * [synchronized(collection) { ... }] to ensure thread safety.
+     *
      * @param query The prefix to search for.
-     * @return A list of suggestions for the prefix, or null if no suggestions are found.
+     * @return An ordered collection of suggestions for the prefix, or null if no suggestions are
+     *   found.
      */
-    fun getSuggestions(query: String): List<SearchSuggestion>? {
-        return cacheSuggestion.get(query)
+    fun getSuggestions(query: String): Collection<SearchSuggestion>? {
+        return cachedSuggestions[query]
     }
 
     /**
      * Adds suggestions for a given prefix to the cache.
      *
      * @param query The prefix to add suggestions for.
-     * @param suggestions The list of suggestions to add.
+     * @param suggestions [SearchSuggestions] object containing different types of suggestions.
+     */
+    fun addSuggestions(query: String, suggestions: SearchSuggestions) {
+        val cachedSuggestionSet = Collections.synchronizedSet(LinkedHashSet<SearchSuggestion>())
+        cachedSuggestionSet.addAll(suggestions.history)
+        cachedSuggestionSet.addAll(suggestions.face)
+        cachedSuggestionSet.addAll(suggestions.other)
+        cachedSuggestions[query] = cachedSuggestionSet
+    }
+
+    /** Clears the cached suggestions from the map. */
+    fun clearSuggestions() {
+        Log.d(TAG, "Clearing search suggestions cache.")
+        cachedSuggestions.clear()
+    }
+
+    /**
+     * Update zero-state history suggestions in cache. It creates a HISTORY suggestion from the
+     * input search text query and adds it to the top of the zero-state suggestions cache.
+     *
+     * @param query Input search text query.
+     */
+    fun updateHistorySuggestion(query: String) {
+        try {
+            val newHistorySuggestion =
+                SearchSuggestion(
+                    mediaSetId = null,
+                    authority = null,
+                    displayText = query.trim(),
+                    type = SearchSuggestionType.HISTORY,
+                    icon = null,
+                )
+
+            updateHistorySuggestion(newHistorySuggestion)
+        } catch (e: RuntimeException) {
+            Log.e(TAG, "Could not update search cache with search query $query", e)
+        }
+    }
+
+    /**
+     * Update zero-state history suggestions in cache. It creates a HISTORY suggestion from the
+     * input search suggestions query and adds it to the front of the zero-state suggestions cache.
+     *
+     * @param suggestion Input search suggestion query.
      */
-    fun addSuggestions(query: String, suggestions: List<SearchSuggestion>) {
-        cacheSuggestion.put(query, suggestions)
+    fun updateHistorySuggestion(suggestion: SearchSuggestion) {
+        try {
+            if (suggestion.displayText == null) {
+                Log.d(TAG, "Skip adding search suggestion with no display text in history")
+                return
+            }
+
+            val historySuggestion =
+                when (suggestion.type) {
+                    SearchSuggestionType.HISTORY -> suggestion
+                    else -> suggestion.copy(type = SearchSuggestionType.HISTORY)
+                }
+
+            val newCachedSuggestions =
+                Collections.synchronizedSet(LinkedHashSet<SearchSuggestion>())
+            newCachedSuggestions.add(historySuggestion)
+
+            synchronized(cachedSuggestions) {
+                val zeroStateSuggestions = cachedSuggestions[ZERO_STATE_SEARCH_QUERY]
+                zeroStateSuggestions?.let { newCachedSuggestions.addAll(zeroStateSuggestions) }
+            }
+
+            cachedSuggestions[ZERO_STATE_SEARCH_QUERY] = newCachedSuggestions
+        } catch (e: RuntimeException) {
+            Log.e(TAG, "Could not update search cache with suggestion $suggestion", e)
+        }
     }
 }
diff --git a/photopicker/src/com/android/photopicker/features/search/SuggestionLists.kt b/photopicker/src/com/android/photopicker/features/search/SearchSuggestions.kt
similarity index 97%
rename from photopicker/src/com/android/photopicker/features/search/SuggestionLists.kt
rename to photopicker/src/com/android/photopicker/features/search/SearchSuggestions.kt
index 237674b3c..c264d9ff9 100644
--- a/photopicker/src/com/android/photopicker/features/search/SuggestionLists.kt
+++ b/photopicker/src/com/android/photopicker/features/search/SearchSuggestions.kt
@@ -28,7 +28,7 @@ import com.android.photopicker.features.search.model.SearchSuggestion
  * @property face List of face type search suggestions.
  * @property other List of other types of search suggestions.
  */
-data class SuggestionLists(
+data class SearchSuggestions(
     val history: List<SearchSuggestion> = emptyList(),
     val face: List<SearchSuggestion> = emptyList(),
     val other: List<SearchSuggestion> = emptyList(),
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt b/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt
index e55bd7cd0..146e044d4 100644
--- a/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt
+++ b/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt
@@ -31,13 +31,15 @@ import com.android.photopicker.core.events.Telemetry
 import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.core.selection.SelectionModifiedResult
+import com.android.photopicker.data.DataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.insertMonthSeparators
 import com.android.photopicker.extensions.toMediaGridItemFromMedia
 import com.android.photopicker.features.search.data.SearchDataService
-import com.android.photopicker.features.search.model.SearchEnabledState
 import com.android.photopicker.features.search.model.SearchSuggestion
 import com.android.photopicker.features.search.model.SearchSuggestionType
+import com.android.photopicker.features.search.model.UserSearchStateInfo
+import com.google.common.annotations.VisibleForTesting
 import dagger.hilt.android.lifecycle.HiltViewModel
 import javax.inject.Inject
 import kotlinx.coroutines.CoroutineDispatcher
@@ -45,6 +47,7 @@ import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.update
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
 
@@ -66,17 +69,19 @@ constructor(
     private val scopeOverride: CoroutineScope?,
     @Background val backgroundDispatcher: CoroutineDispatcher,
     private val searchDataService: SearchDataService,
+    private val dataService: DataService,
     private val selection: Selection<Media>,
     private val events: Events,
     private val configurationManager: ConfigurationManager,
 ) : ViewModel() {
 
     companion object {
+        private const val SEARCH_RESULT_GRID_PAGE_SIZE = 50
+        private const val SEARCH_RESULT_GRID_MAX_ITEMS_IN_MEMORY = SEARCH_RESULT_GRID_PAGE_SIZE * 10
+        const val ZERO_STATE_SEARCH_QUERY = ""
         const val HISTORY_SUGGESTION_MAX_LIMIT = 3
         const val FACE_SUGGESTION_MAX_LIMIT = 6
         const val ALL_SUGGESTION_MAX_LIMIT = 6
-        const val SEARCH_RESULT_GRID_PAGE_SIZE = 50
-        const val SEARCH_RESULT_GRID_MAX_ITEMS_IN_MEMORY = SEARCH_RESULT_GRID_PAGE_SIZE * 10
     }
 
     // Check if a scope override was injected before using the default [viewModelScope]
@@ -101,20 +106,27 @@ constructor(
      * This `StateFlow` emits updates whenever the list of search suggestions changes. It provides
      * various types of suggestions (e.g., history, face, others).
      */
-    private val _suggestionLists = MutableStateFlow(SuggestionLists())
-    val suggestionLists: StateFlow<SuggestionLists> = _suggestionLists
+    private val _searchSuggestions = MutableStateFlow(SearchSuggestions())
+    val searchSuggestions: StateFlow<SearchSuggestions> = _searchSuggestions
 
     /**
      * Holds the value of the current profile's search enabled state
      *
      * This `StateFlow` emits updates whenever the search enabled state of a profile changes.
      */
-    val searchEnabled: StateFlow<SearchEnabledState> = searchDataService.isSearchEnabled
+    val userSearchStateInfo: StateFlow<UserSearchStateInfo> = searchDataService.userSearchStateInfo
 
     private val suggestionCache = SearchSuggestionCache()
 
     init {
-        fetchSuggestions("")
+        fetchSuggestions(ZERO_STATE_SEARCH_QUERY)
+        // Listen to available provider changes and clear search suggestions cache.
+        scope.launch(backgroundDispatcher) {
+            dataService.availableProviders.collect {
+                suggestionCache.clearSuggestions()
+                fetchSuggestions(ZERO_STATE_SEARCH_QUERY)
+            }
+        }
     }
 
     /**
@@ -127,10 +139,14 @@ constructor(
     fun fetchSuggestions(query: String) {
         searchJob?.cancel()
 
-        val cachedSuggestion: List<SearchSuggestion>? = suggestionCache.getSuggestions(query)
+        val cachedSuggestion: Collection<SearchSuggestion>? = suggestionCache.getSuggestions(query)
         when (cachedSuggestion != null) {
             true -> {
-                getSuggestionTypeLists(cachedSuggestion, query.isEmpty())
+                synchronized(cachedSuggestion) {
+                    val transformedSuggestions =
+                        getTransformedSuggestions(cachedSuggestion, query.isEmpty())
+                    _searchSuggestions.update { transformedSuggestions }
+                }
             }
 
             else -> {
@@ -143,9 +159,10 @@ constructor(
                                     query,
                                     cancellationSignal = job.cancellationSignal,
                                 )
-                            val refactoredSuggestionList: List<SearchSuggestion> =
-                                getSuggestionTypeLists(newSuggestions, query.isEmpty())
-                            suggestionCache.addSuggestions(query, refactoredSuggestionList)
+                            val transformedSuggestions: SearchSuggestions =
+                                getTransformedSuggestions(newSuggestions, query.isEmpty())
+                            suggestionCache.addSuggestions(query, transformedSuggestions)
+                            _searchSuggestions.update { transformedSuggestions }
                         }
                     }
                 }
@@ -221,6 +238,7 @@ constructor(
      */
     fun performSearch(suggestion: SearchSuggestion) {
         _searchState.value = SearchState.Active.SuggestionSearch(suggestion)
+        suggestionCache.updateHistorySuggestion(suggestion)
     }
 
     /**
@@ -230,6 +248,7 @@ constructor(
      */
     fun performSearch(query: String) {
         _searchState.value = SearchState.Active.QuerySearch(query)
+        suggestionCache.updateHistorySuggestion(query)
     }
 
     /**
@@ -263,53 +282,55 @@ constructor(
      * Method that updates the list for each type of suggestion from the suggestions result and
      * returns a trimmed list of search suggestions to show on UI
      *
-     * @param suggestions The original list of `SearchSuggestion` objects.
+     * @param suggestions The original collection of ordered `SearchSuggestion` objects.
      * @param isZeroSearchState A boolean value indicating if the search query is empty.
+     * @return [SearchSuggestions] object with different types of suggestions that need to be
+     *   displayed on the UI.
      */
-    private fun getSuggestionTypeLists(
-        suggestions: List<SearchSuggestion>,
+    private fun getTransformedSuggestions(
+        suggestions: Collection<SearchSuggestion>,
         isZeroSearchState: Boolean,
-    ): List<SearchSuggestion> {
+    ): SearchSuggestions {
         val history = mutableListOf<SearchSuggestion>()
         val face = mutableListOf<SearchSuggestion>()
         val other = mutableListOf<SearchSuggestion>()
-        val result = mutableListOf<SearchSuggestion>()
-        var (historyCount, faceCount, otherCount) = listOf(0, 0, 0)
 
         for (suggestion in suggestions) {
             when (suggestion.type) {
                 SearchSuggestionType.HISTORY ->
-                    if (historyCount++ < HISTORY_SUGGESTION_MAX_LIMIT) {
+                    if (history.size < HISTORY_SUGGESTION_MAX_LIMIT) {
                         history.add(suggestion)
-                        result.add(suggestion)
                     }
+
                 SearchSuggestionType.FACE ->
                     if (isZeroSearchState) {
-                        if (faceCount++ < FACE_SUGGESTION_MAX_LIMIT) {
+                        if (face.size < FACE_SUGGESTION_MAX_LIMIT) {
                             face.add(suggestion)
-                            result.add(suggestion)
                         }
                     } else {
-                        if (otherCount++ < ALL_SUGGESTION_MAX_LIMIT) {
+                        if (other.size < ALL_SUGGESTION_MAX_LIMIT) {
                             other.add(suggestion)
-                            result.add(suggestion)
                         }
                     }
+
                 else ->
-                    if (otherCount++ < ALL_SUGGESTION_MAX_LIMIT) {
+                    if (other.size < ALL_SUGGESTION_MAX_LIMIT) {
                         other.add(suggestion)
-                        result.add(suggestion)
                     }
             }
             if (
-                historyCount >= HISTORY_SUGGESTION_MAX_LIMIT &&
-                    faceCount >= FACE_SUGGESTION_MAX_LIMIT &&
-                    otherCount >= ALL_SUGGESTION_MAX_LIMIT
+                history.size >= HISTORY_SUGGESTION_MAX_LIMIT &&
+                    face.size >= FACE_SUGGESTION_MAX_LIMIT &&
+                    other.size >= ALL_SUGGESTION_MAX_LIMIT
             )
                 break // Early exit
         }
-        _suggestionLists.value = SuggestionLists(history, face, other)
-        return result
+        return SearchSuggestions(history, face, other)
+    }
+
+    @VisibleForTesting
+    fun getCachedSuggestions(): SearchSuggestionCache {
+        return suggestionCache
     }
 }
 
diff --git a/photopicker/src/com/android/photopicker/features/search/data/FakeSearchDataServiceImpl.kt b/photopicker/src/com/android/photopicker/features/search/data/FakeSearchDataServiceImpl.kt
deleted file mode 100644
index 3e6adbeea..000000000
--- a/photopicker/src/com/android/photopicker/features/search/data/FakeSearchDataServiceImpl.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.photopicker.features.search.data
-
-import android.net.Uri
-import android.os.CancellationSignal
-import androidx.paging.PagingSource
-import com.android.photopicker.data.DataService
-import com.android.photopicker.data.model.Media
-import com.android.photopicker.data.model.MediaPageKey
-import com.android.photopicker.features.search.model.SearchEnabledState
-import com.android.photopicker.features.search.model.SearchSuggestion
-import com.android.photopicker.features.search.model.SearchSuggestionType
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.coroutines.flow.StateFlow
-
-/**
- * Placeholder for the actual [SearchDataService] implementation class. This class can be used to
- * unblock and test UI development till we have the actual implementation in ready.
- */
-// TODO(b/361043596) Clean up once we have the implementation for [SearchDataService] class.
-class FakeSearchDataServiceImpl(private val dataService: DataService) : SearchDataService {
-    // Use the internal flow of type StateFlow<Map<UserProfile, Boolean>> which would cache
-    // the result for all profiles, to populate this flow for the current profile.
-    override val isSearchEnabled: StateFlow<SearchEnabledState> =
-        MutableStateFlow(SearchEnabledState.ENABLED)
-
-    /** Returns a few static suggestions to unblock UI development. */
-    override suspend fun getSearchSuggestions(
-        prefix: String,
-        limit: Int,
-        cancellationSignal: CancellationSignal?,
-    ): List<SearchSuggestion> {
-        if (prefix == "testempty") {
-            return emptyList()
-        }
-        return listOf(
-            SearchSuggestion("1", "authority", "France", SearchSuggestionType.LOCATION, null),
-            SearchSuggestion(
-                "2",
-                "authority",
-                "Favorites",
-                SearchSuggestionType.FAVORITES_ALBUM,
-                Uri.parse("xyz"),
-            ),
-            SearchSuggestion(
-                "8",
-                "authority",
-                "Album",
-                SearchSuggestionType.ALBUM,
-                Uri.parse("xyz"),
-            ),
-            SearchSuggestion("2", "authority", "Videos", SearchSuggestionType.VIDEOS_ALBUM, null),
-            SearchSuggestion(null, "authority", "france", SearchSuggestionType.HISTORY, null),
-            SearchSuggestion(null, "authority", "paris", SearchSuggestionType.HISTORY, null),
-            SearchSuggestion("3", "authority", "March", SearchSuggestionType.DATE, null),
-            SearchSuggestion(
-                "3",
-                "authority",
-                "Screenshot",
-                SearchSuggestionType.SCREENSHOTS_ALBUM,
-                null,
-            ),
-            SearchSuggestion("4", "authority", "Emma", SearchSuggestionType.FACE, Uri.parse("xyz")),
-            SearchSuggestion("5", "authority", "Bob", SearchSuggestionType.FACE, Uri.parse("xyz")),
-            SearchSuggestion("6", "authority", "April", SearchSuggestionType.DATE, null),
-            SearchSuggestion("7", "authority", null, SearchSuggestionType.FACE, Uri.parse("xyz")),
-        )
-    }
-
-    /** Returns all media to unblock UI development. */
-    override fun getSearchResults(
-        suggestion: SearchSuggestion,
-        cancellationSignal: CancellationSignal?,
-    ): PagingSource<MediaPageKey, Media> = dataService.mediaPagingSource()
-
-    /** Returns all media to unblock UI development. */
-    override fun getSearchResults(
-        searchText: String,
-        cancellationSignal: CancellationSignal?,
-    ): PagingSource<MediaPageKey, Media> = dataService.mediaPagingSource()
-}
diff --git a/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt b/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt
index d04aac74b..9bb5691e5 100644
--- a/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt
+++ b/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt
@@ -20,8 +20,8 @@ import android.os.CancellationSignal
 import androidx.paging.PagingSource
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
-import com.android.photopicker.features.search.model.SearchEnabledState
 import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.UserSearchStateInfo
 import kotlinx.coroutines.flow.StateFlow
 
 /**
@@ -37,11 +37,11 @@ interface SearchDataService {
     }
 
     /**
-     * A [StateFlow] that emits a value when current profile changes or search config in the data
-     * source changes. It hold that value of the current profile's search enabled state
-     * [SearchEnabledState].
+     * A [StateFlow] that emits a value when current profile changes or the current profile's
+     * available provider changes. It hold that value of the current profile's search enabled state
+     * [UserSearchStateInfo].
      */
-    val isSearchEnabled: StateFlow<SearchEnabledState>
+    val userSearchStateInfo: StateFlow<UserSearchStateInfo>
 
     /**
      * Get search suggestions for the user in zero state and as the user is typing.
diff --git a/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt b/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt
index 78ebc1e9e..338319dd7 100644
--- a/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt
+++ b/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt
@@ -17,6 +17,8 @@
 package com.android.photopicker.features.search.data
 
 import android.content.ContentResolver
+import android.database.ContentObserver
+import android.net.Uri
 import android.os.CancellationSignal
 import android.util.Log
 import androidx.paging.PagingSource
@@ -26,20 +28,29 @@ import com.android.photopicker.core.user.UserStatus
 import com.android.photopicker.data.DataService
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.NotificationService
+import com.android.photopicker.data.SEARCH_RESULTS_UPDATE_URI
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.Provider
-import com.android.photopicker.features.search.model.SearchEnabledState
 import com.android.photopicker.features.search.model.SearchRequest
 import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.UserSearchStateInfo
+import java.util.concurrent.TimeoutException
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.channels.awaitClose
+import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.callbackFlow
+import kotlinx.coroutines.flow.update
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.runBlocking
 import kotlinx.coroutines.sync.Mutex
 import kotlinx.coroutines.sync.withLock
+import kotlinx.coroutines.withContext
+import kotlinx.coroutines.withTimeout
 
 /**
  * Provides search feature data to the Photo Picker UI. The data comes from a [ContentProvider]
@@ -70,6 +81,11 @@ class SearchDataServiceImpl(
     private val mediaProviderClient: MediaProviderClient,
     private val events: Events,
 ) : SearchDataService {
+    companion object {
+        // Timeout for receiving suggestions from the data source in milli seconds.
+        private const val SUGGESTIONS_TIMEOUT: Long = 3000
+    }
+
     // An internal lock to allow thread-safe updates to the search request and results cache.
     private val searchResultsPagingSourceMutex = Mutex()
 
@@ -80,6 +96,20 @@ class SearchDataServiceImpl(
     private val searchResultsPagingSources: MutableMap<Int, PagingSource<MediaPageKey, Media>> =
         mutableMapOf()
 
+    // Callback flow that listens to changes in search results and emits the search request id when
+    // change is observed.
+    private var searchResultsUpdateCallbackFlow: Flow<Int>? = null
+
+    // Saves the current job that collects the [searchResultsUpdateCallbackFlow].
+    // Cancel this job when there is a change in the current profile's content resolver.
+    private var searchResultsUpdateCollectJob: Job? = null
+
+    // Internal mutable flow of the current user's search state info.
+    private val _userSearchStateInfo: MutableStateFlow<UserSearchStateInfo> =
+        MutableStateFlow(UserSearchStateInfo(null))
+
+    override val userSearchStateInfo: StateFlow<UserSearchStateInfo> = _userSearchStateInfo
+
     init {
         // Listen to available provider changes and clear search cache when required.
         scope.launch(dispatcher) {
@@ -98,20 +128,77 @@ class SearchDataServiceImpl(
                     searchResultsPagingSources.clear()
                     searchRequestIdMap.clear()
                 }
+
+                _userSearchStateInfo.update { fetchSearchStateInfo() }
             }
         }
-    }
 
-    // TODO(b/381819838)
-    override val isSearchEnabled: StateFlow<SearchEnabledState> =
-        MutableStateFlow(SearchEnabledState.ENABLED)
+        scope.launch(dispatcher) {
+            // Only observe the changes in the active content resolver
+            dataService.activeContentResolver.collect { activeContentResolver: ContentResolver ->
+                Log.d(SearchDataService.TAG, "Active content resolver has changed.")
+
+                // Stop collecting search results updates from previously initialized callback flow.
+                searchResultsUpdateCollectJob?.cancel()
+                searchResultsUpdateCallbackFlow = initSearchResultsUpdateFlow(activeContentResolver)
 
-    // TODO(b/381820020)
+                searchResultsUpdateCollectJob =
+                    scope.launch(dispatcher) {
+                        searchResultsUpdateCallbackFlow?.collect { searchRequestId: Int ->
+                            Log.d(
+                                SearchDataService.TAG,
+                                "Search results update notification " +
+                                    "received for search request id $searchRequestId ",
+                            )
+                            searchResultsPagingSourceMutex.withLock {
+                                searchResultsPagingSources[searchRequestId]?.invalidate()
+                            }
+                        }
+                    }
+            }
+        }
+    }
+
+    /**
+     * Try to get a list fo search suggestions from Media Provider in the background thread with a
+     * time limit.
+     */
     override suspend fun getSearchSuggestions(
         prefix: String,
         limit: Int,
         cancellationSignal: CancellationSignal?,
-    ): List<SearchSuggestion> = emptyList()
+    ): List<SearchSuggestion> {
+        // Switch to a background thread.
+        return withContext(dispatcher) {
+            try {
+                // Apply a timeout on getSearchSuggestions API
+                withTimeout(SUGGESTIONS_TIMEOUT) {
+                    mediaProviderClient.fetchSearchSuggestions(
+                        resolver = dataService.activeContentResolver.value,
+                        prefix = prefix,
+                        limit = limit,
+                        historyLimit = 3,
+                        availableProviders = dataService.availableProviders.value,
+                        cancellationSignal = cancellationSignal,
+                    )
+                }
+            } catch (e: TimeoutException) {
+                Log.w(SearchDataService.TAG, "Search suggestions timed out for prefix $prefix", e)
+
+                cancellationSignal?.cancel()
+                emptyList<SearchSuggestion>()
+            } catch (e: RuntimeException) {
+                Log.w(
+                    SearchDataService.TAG,
+                    "An error occurred while fetching search suggestions for prefix $prefix",
+                    e,
+                )
+
+                cancellationSignal?.cancel()
+                emptyList<SearchSuggestion>()
+            }
+        }
+    }
 
     /**
      * Returns an instance of [SearchResultsPagingSource] that can source search results for the
@@ -160,7 +247,7 @@ class SearchDataServiceImpl(
             searchResultsPagingSourceMutex.withLock {
                 if (
                     searchResultsPagingSources.containsKey(searchRequestId) &&
-                        searchResultsPagingSources[searchRequestId]!!.invalid
+                        !searchResultsPagingSources[searchRequestId]!!.invalid
                 ) {
                     Log.d(
                         SearchDataService.TAG,
@@ -181,6 +268,7 @@ class SearchDataServiceImpl(
                             dispatcher = dispatcher,
                             configuration = config,
                             cancellationSignal = cancellationSignal,
+                            events = events,
                         )
 
                     // Ensure that sync is cancelled when the paging source gets invalidated.
@@ -189,8 +277,9 @@ class SearchDataServiceImpl(
                     }
 
                     Log.d(
-                        DataService.TAG,
-                        "Created a search results paging source that queries $availableProviders",
+                        SearchDataService.TAG,
+                        "Created a search results paging source that queries $availableProviders " +
+                            "for search request id $searchRequestId",
                     )
 
                     searchResultsPagingSources[searchRequestId] = searchResultsPagingSource
@@ -211,6 +300,7 @@ class SearchDataServiceImpl(
                 dispatcher = dispatcher,
                 configuration = config,
                 cancellationSignal = null,
+                events = events,
             )
         }
     }
@@ -219,9 +309,12 @@ class SearchDataServiceImpl(
      * Checks if this is a new search request in the current session.
      * 1. If this is a new search requests, [MediaProvider] is notified with the new search request
      *    and it creates and returns a search request id.
-     * 2. If this is not a new search request, previously caches search request id is returned.
+     * 2. If this is not a new search request, previously cached search request id is returned.
+     *
+     * In both scenarios, this notifies the backend to refresh search results cache for the given
+     * search request id.
      */
-    private fun getSearchRequestId(
+    private suspend fun getSearchRequestId(
         searchRequest: SearchRequest,
         availableProviders: List<Provider>,
         contentResolver: ContentResolver,
@@ -234,15 +327,89 @@ class SearchDataServiceImpl(
                     "Search request id is available for search request $searchRequest. " +
                         "Not creating a new search request id.",
                 )
-                searchRequestIdMap[searchRequest]!!
+
+                val searchRequestId = searchRequestIdMap[searchRequest]!!
+
+                try {
+                    // Ensure search results data in data source is ready for the search query.
+                    mediaProviderClient.ensureSearchResults(
+                        searchRequest,
+                        searchRequestId,
+                        availableProviders,
+                        contentResolver,
+                        config,
+                    )
+                } catch (e: RuntimeException) {
+                    Log.e(SearchDataService.TAG, "Could not ensure search results", e)
+                }
+
+                searchRequestId
             } else {
-                mediaProviderClient.createSearchRequest(
-                    searchRequest,
-                    availableProviders,
-                    contentResolver,
-                    config,
+                Log.d(
+                    SearchDataService.TAG,
+                    "Search request id is not available for search request $searchRequest. " +
+                        "Creating a new search request id.",
                 )
+
+                val newSearchRequestId =
+                    mediaProviderClient.createSearchRequest(
+                        searchRequest,
+                        availableProviders,
+                        contentResolver,
+                        config,
+                    )
+
+                searchRequestIdMap[searchRequest] = newSearchRequestId
+                newSearchRequestId
             }
         }
     }
+
+    /** Get search state info for the current user. */
+    private suspend fun fetchSearchStateInfo(): UserSearchStateInfo {
+        val contentResolver: ContentResolver = dataService.activeContentResolver.value
+        val searchProviderAuthorities: List<String>? =
+            mediaProviderClient.fetchSearchProviderAuthorities(
+                contentResolver,
+                dataService.availableProviders.value,
+            )
+        val userSearchStateInfo = UserSearchStateInfo(searchProviderAuthorities)
+        Log.d(
+            SearchDataService.TAG,
+            "Available search providers for current user $searchProviderAuthorities. " +
+                "Search state is ${userSearchStateInfo.state}",
+        )
+        return userSearchStateInfo
+    }
+
+    /**
+     * Creates a callback flow that emits search request id when an update in search results is
+     * observed using [ContentObserver] notifications.
+     */
+    private fun initSearchResultsUpdateFlow(resolver: ContentResolver): Flow<Int> = callbackFlow {
+        val observer =
+            object : ContentObserver(/* handler */ null) {
+                override fun onChange(selfChange: Boolean, uri: Uri?) {
+                    // Verify that search request id is present in the URI
+                    if (
+                        uri?.pathSegments?.size == (1 + SEARCH_RESULTS_UPDATE_URI.pathSegments.size)
+                    ) {
+                        val searchRequestId: Int =
+                            Integer.parseInt(uri.pathSegments[uri.pathSegments.size - 1] ?: "-1")
+                        trySend(searchRequestId)
+                    }
+                }
+            }
+
+        // Register the content observer callback.
+        notificationService.registerContentObserverCallback(
+            resolver,
+            SEARCH_RESULTS_UPDATE_URI,
+            /* notifyForDescendants */ true,
+            observer,
+        )
+
+        // Unregister when the flow is closed.
+        awaitClose { notificationService.unregisterContentObserverCallback(resolver, observer) }
+    }
 }
diff --git a/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt b/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt
index 12938b520..4108040b7 100644
--- a/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt
+++ b/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt
@@ -22,6 +22,9 @@ import android.util.Log
 import androidx.paging.PagingSource
 import androidx.paging.PagingState
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
@@ -43,6 +46,7 @@ class SearchResultsPagingSource(
     private val dispatcher: CoroutineDispatcher,
     private val configuration: PhotopickerConfiguration,
     private val cancellationSignal: CancellationSignal?,
+    private val events: Events,
 ) : PagingSource<MediaPageKey, Media>() {
     companion object {
         val TAG: String = "PickerSearchPagingSource"
@@ -61,15 +65,35 @@ class SearchResultsPagingSource(
 
                     checkNotNull(searchRequestId) { "Search request id is invalid" }
 
-                    mediaProviderClient.fetchSearchResults(
-                        searchRequestId,
-                        pageKey,
-                        pageSize,
-                        contentResolver,
-                        availableProviders,
-                        configuration,
-                        cancellationSignal,
-                    )
+                    val searchResults =
+                        mediaProviderClient.fetchSearchResults(
+                            searchRequestId,
+                            pageKey,
+                            pageSize,
+                            contentResolver,
+                            availableProviders,
+                            configuration,
+                            cancellationSignal,
+                        )
+
+                    if (searchResults is LoadResult.Page) {
+                        // Dispatch a pageInfo event to log paging details for fetching albums
+                        // Keeping page number as 0 for all dispatched events for now for simplicity
+                        events.dispatch(
+                            Event.LogPhotopickerPageInfo(
+                                FeatureToken.SEARCH.token,
+                                configuration.sessionId,
+                                /* pageNumber */ 0,
+                                pageSize,
+                            )
+                        )
+                        Log.d(
+                            TAG,
+                            "Received ${searchResults.data.count()} search results from MP for $searchRequestId",
+                        )
+                    }
+
+                    searchResults
                 } catch (e: Exception) {
                     Log.e(TAG, "Could not fetch search results page from Media provider", e)
                     LoadResult.Error(e)
diff --git a/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt b/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt
index 409a40c23..b50d72f19 100644
--- a/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt
+++ b/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt
@@ -63,6 +63,7 @@ class SearchEmbeddedServiceModule {
         configurationManager: ConfigurationManager,
         @Background scope: CoroutineScope,
         @Background dispatcher: CoroutineDispatcher,
+        mediaProviderClient: MediaProviderClient,
         notificationService: NotificationService,
         events: Events,
     ): SearchDataService {
@@ -83,7 +84,7 @@ class SearchEmbeddedServiceModule {
                     scope,
                     dispatcher,
                     notificationService,
-                    MediaProviderClient(),
+                    mediaProviderClient,
                     events,
                 )
             return searchDataService
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchEnabledState.kt b/photopicker/src/com/android/photopicker/features/search/model/GlobalSearchState.kt
similarity index 77%
rename from photopicker/src/com/android/photopicker/features/search/model/SearchEnabledState.kt
rename to photopicker/src/com/android/photopicker/features/search/model/GlobalSearchState.kt
index f969e62d3..1718a21cb 100644
--- a/photopicker/src/com/android/photopicker/features/search/model/SearchEnabledState.kt
+++ b/photopicker/src/com/android/photopicker/features/search/model/GlobalSearchState.kt
@@ -16,13 +16,18 @@
 
 package com.android.photopicker.features.search.model
 
-/** This represents the search enabled states the current profile could have. */
-enum class SearchEnabledState {
+/**
+ * This represents valid global search states.
+ *
+ * Global search state refers to the search state of all user profiles available on the device.
+ */
+enum class GlobalSearchState() {
     /* Search is enabled for the current profile */
     ENABLED,
-    /* Search is disabled in the current profile but enabled in other profiles */
+    /* Search is disabled in the current profile but enabled in at least one of the
+     * other profiles */
     ENABLED_IN_OTHER_PROFILES_ONLY,
-    /* Search is disabled in all profiles */
+    /* Search is disabled in current profile and other profiles */
     DISABLED,
     /* Either the state of the current profile is unknown, or the current profile has search
      * disabled and the state of other profile(s) is unknown. */
diff --git a/photopicker/src/com/android/photopicker/features/search/model/GlobalSearchStateInfo.kt b/photopicker/src/com/android/photopicker/features/search/model/GlobalSearchStateInfo.kt
new file mode 100644
index 000000000..eb3326384
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/GlobalSearchStateInfo.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+/** Holds search state info for all user profiles on the device. */
+data class GlobalSearchStateInfo(
+    // Map of all available profiles to the provider authorities that have search feature
+    // enabled. If no providers have search enabled, tha value in map should be an empty string.
+    // If the information is unknown for a given profile, the value in map should be null.
+    val providersWithSearchEnabled: Map<Int, List<String>?>,
+    val currentUserId: Int,
+) {
+    val state: GlobalSearchState =
+        when {
+            // Check if search is enabled in current profile
+            providersWithSearchEnabled[currentUserId]?.isNotEmpty() ?: false ->
+                GlobalSearchState.ENABLED
+
+            // Check if search is enabled in any other profile
+            providersWithSearchEnabled.values.any { providers ->
+                providers?.isNotEmpty() ?: false
+            } -> GlobalSearchState.ENABLED_IN_OTHER_PROFILES_ONLY
+
+            // Check if there is missing information
+            providersWithSearchEnabled.values.any { providers -> providers == null } ->
+                GlobalSearchState.UNKNOWN
+
+            // If we have all information and search is not enabled in any profile,
+            // search is disabled.
+            else -> GlobalSearchState.DISABLED
+        }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt
index 3a1669546..32f38c91e 100644
--- a/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt
@@ -16,8 +16,22 @@
 
 package com.android.photopicker.features.search.model
 
+import com.android.photopicker.util.hashCodeOf
+
 sealed interface SearchRequest {
-    data class SearchTextRequest(val searchText: String) : SearchRequest
+    data class SearchTextRequest(val searchText: String) : SearchRequest {
+        override fun hashCode(): Int = hashCodeOf(searchText)
+
+        override fun equals(other: Any?): Boolean {
+            return other is SearchTextRequest && other.searchText == searchText
+        }
+    }
+
+    data class SearchSuggestionRequest(val suggestion: SearchSuggestion) : SearchRequest {
+        override fun hashCode(): Int = hashCodeOf(suggestion)
 
-    data class SearchSuggestionRequest(val suggestion: SearchSuggestion) : SearchRequest
+        override fun equals(other: Any?): Boolean {
+            return other is SearchSuggestionRequest && other.suggestion == suggestion
+        }
+    }
 }
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt
index 6ec8deb0b..d7e0ca440 100644
--- a/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt
@@ -16,7 +16,8 @@
 
 package com.android.photopicker.features.search.model
 
-import android.net.Uri
+import com.android.photopicker.core.glide.GlideLoadable
+import com.android.photopicker.util.hashCodeOf
 
 /**
  * A data class that holds a Search Suggestion. Search suggestions could be suggestions shown to the
@@ -29,20 +30,30 @@ data class SearchSuggestion(
      * suggestions that don't have a media set ID. */
     val mediaSetId: String?,
     /* The authority of the source ContentProvider that provided this Search Suggestion. */
-    val authority: String,
+    val authority: String?,
     /* Display text could be null sometimes for instance, if the suggestion type is a face */
     val displayText: String?,
     val type: SearchSuggestionType,
-    /* Unwrapped URI of the icon shown to the user along with the suggestion. If this is null,
+    /* GlideLoadable icon shown to the user along with the suggestion. If this is null,
     please fallback to default icons based on the [SearchSuggestionType] of the suggestion. */
-    val iconUri: Uri?,
+    val icon: GlideLoadable?,
 ) {
     init {
-        require(type != SearchSuggestionType.FACE || iconUri != null) {
+        require(type != SearchSuggestionType.FACE || icon != null) {
             "Icon cannot be null for FACE type search suggestion"
         }
         require(type == SearchSuggestionType.FACE || displayText != null) {
             "Display text cannot be null except for FACE type search suggestion"
         }
     }
+
+    override fun hashCode(): Int = hashCodeOf(mediaSetId, authority, displayText, type)
+
+    override fun equals(other: Any?): Boolean {
+        return other is SearchSuggestion &&
+            other.mediaSetId == mediaSetId &&
+            other.authority == authority &&
+            other.displayText == displayText &&
+            other.type == type
+    }
 }
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt
index 7e5d06396..4af9b17d9 100644
--- a/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt
@@ -16,24 +16,30 @@
 
 package com.android.photopicker.features.search.model
 
+import android.provider.CloudMediaProviderContract
+
 /**
  * This enum holds all valid values of a search suggestion type. Search suggestion types could be
  * decided by the cloud media provider or by the photo picker backend.
  */
-enum class SearchSuggestionType {
-    TEXT,
-    FACE,
-    LOCATION,
-    DATE,
+enum class SearchSuggestionType(val key: String) {
+    TEXT(CloudMediaProviderContract.SEARCH_SUGGESTION_TEXT),
+    FACE(CloudMediaProviderContract.SEARCH_SUGGESTION_FACE),
+    LOCATION(CloudMediaProviderContract.SEARCH_SUGGESTION_LOCATION),
+    DATE(CloudMediaProviderContract.SEARCH_SUGGESTION_DATE),
     /* Suggestion saved in history. History suggestions could be based on searches that are
      * triggered by selecting a CMP suggestion or by entering search text. */
-    HISTORY,
+    HISTORY(CloudMediaProviderContract.SEARCH_SUGGESTION_HISTORY),
     /* Suggestion for the Screenshots album */
-    SCREENSHOTS_ALBUM,
+    SCREENSHOTS_ALBUM(CloudMediaProviderContract.SEARCH_SUGGESTION_SCREENSHOTS_ALBUM),
     /* Suggestion for the Favorites album */
-    FAVORITES_ALBUM,
+    FAVORITES_ALBUM(CloudMediaProviderContract.SEARCH_SUGGESTION_FAVORITES_ALBUM),
     /* Suggestion for the Videos album */
-    VIDEOS_ALBUM,
+    VIDEOS_ALBUM(CloudMediaProviderContract.SEARCH_SUGGESTION_VIDEOS_ALBUM),
     /* All other albums */
-    ALBUM,
+    ALBUM(CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM),
 }
+
+/** A map of all Key -> [SearchSuggestionType] available. */
+val KeyToSearchSuggestionType: Map<String, SearchSuggestionType> =
+    SearchSuggestionType.entries.associateBy { enum -> enum.key }
diff --git a/photopicker/src/com/android/photopicker/features/search/model/UserSearchState.kt b/photopicker/src/com/android/photopicker/features/search/model/UserSearchState.kt
new file mode 100644
index 000000000..c9bfaf3d2
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/UserSearchState.kt
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+/**
+ * This represents valid user search states.
+ *
+ * User search state refers to the search state of the current selected profile in a Picker session.
+ */
+enum class UserSearchState() {
+    /* Search is enabled in the current profile */
+    ENABLED,
+    /* Search is disabled in the current profile */
+    DISABLED,
+    /* Search state for the current profile is unknown */
+    UNKNOWN,
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/model/UserSearchStateInfo.kt b/photopicker/src/com/android/photopicker/features/search/model/UserSearchStateInfo.kt
new file mode 100644
index 000000000..885cbf218
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/UserSearchStateInfo.kt
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+/** Holds search state info for the current selected profile in a Picker session. */
+data class UserSearchStateInfo(val searchProviderAuthorities: List<String>?) {
+    val state: UserSearchState =
+        when {
+            searchProviderAuthorities == null -> UserSearchState.UNKNOWN
+            searchProviderAuthorities.isEmpty() -> UserSearchState.DISABLED
+            else -> UserSearchState.ENABLED
+        }
+}
diff --git a/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt b/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt
index 37c552fd9..3951f3aeb 100644
--- a/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt
+++ b/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt
@@ -68,6 +68,7 @@ import kotlinx.coroutines.launch
 /* The size of spacers between elements on the bar */
 private val MEASUREMENT_BUTTONS_SPACER_SIZE = 8.dp
 private val MEASUREMENT_DESELECT_SPACER_SIZE = 4.dp
+private val MEASUREMENT_DESELECT_DISABLED_SPACER_SIZE = 16.dp
 
 /* Corner radius of the selection bar */
 private val MEASUREMENT_SELECTION_BAR_CORNER_SIZE = 100
@@ -94,6 +95,10 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
             MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(
                 LocalPhotopickerConfiguration.current.action
             )
+    val disableClearAllButton =
+        MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(
+            LocalPhotopickerConfiguration.current.action
+        ) && LocalPhotopickerConfiguration.current.flags.OWNED_PHOTOS_ENABLED
     val configuration = LocalPhotopickerConfiguration.current
     val events = LocalEvents.current
     val scope = rememberCoroutineScope()
@@ -123,17 +128,22 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
 
                 // Deselect all button [Left side]
                 Row(verticalAlignment = Alignment.CenterVertically) {
-                    IconButton(onClick = { scope.launch { selection.clear() } }) {
-                        Icon(
-                            Icons.Filled.Close,
-                            contentDescription =
-                                stringResource(
-                                    R.string.photopicker_clear_selection_button_description
-                                ),
-                            tint = MaterialTheme.colorScheme.onSurface,
-                        )
+                    if (disableClearAllButton) {
+                        Spacer(Modifier.size(MEASUREMENT_DESELECT_DISABLED_SPACER_SIZE))
+                    } else {
+                        IconButton(onClick = { scope.launch { selection.clear() } }) {
+                            Icon(
+                                Icons.Filled.Close,
+                                contentDescription =
+                                    stringResource(
+                                        R.string.photopicker_clear_selection_button_description
+                                    ),
+                                tint = MaterialTheme.colorScheme.onSurface,
+                            )
+                        }
+                        Spacer(Modifier.size(MEASUREMENT_DESELECT_SPACER_SIZE))
                     }
-                    Spacer(Modifier.size(MEASUREMENT_DESELECT_SPACER_SIZE))
+
                     val selectionSizeDescription =
                         stringResource(
                             R.string.photopicker_selection_size_description,
diff --git a/photopicker/src/com/android/photopicker/inject/ActivityModule.kt b/photopicker/src/com/android/photopicker/inject/ActivityModule.kt
index dc69be86a..5acb3ee3f 100644
--- a/photopicker/src/com/android/photopicker/inject/ActivityModule.kt
+++ b/photopicker/src/com/android/photopicker/inject/ActivityModule.kt
@@ -194,6 +194,7 @@ class ActivityModule {
         @Background scope: CoroutineScope,
         @Background dispatcher: CoroutineDispatcher,
         userMonitor: UserMonitor,
+        mediaProviderClient: MediaProviderClient,
         notificationService: NotificationService,
         configurationManager: ConfigurationManager,
         featureManager: FeatureManager,
@@ -212,7 +213,7 @@ class ActivityModule {
                     scope,
                     dispatcher,
                     notificationService,
-                    MediaProviderClient(),
+                    mediaProviderClient,
                     configurationManager.configuration,
                     featureManager,
                     appContext,
@@ -311,7 +312,13 @@ class ActivityModule {
 
     @Provides
     @ActivityRetainedScoped
-    fun providePrefetchDataService(): PrefetchDataService {
+    fun providePrefetchDataService(
+        userMonitor: UserMonitor,
+        @ApplicationContext context: Context,
+        @Background backgroundDispatcher: CoroutineDispatcher,
+        mediaProviderClient: MediaProviderClient,
+        @Background scope: CoroutineScope,
+    ): PrefetchDataService {
 
         if (!::prefetchDataService.isInitialized) {
             Log.d(
@@ -319,7 +326,14 @@ class ActivityModule {
                 "PrefetchDataService requested but not yet initialized. " +
                     "Initializing PrefetchDataService.",
             )
-            prefetchDataService = PrefetchDataServiceImpl()
+            prefetchDataService =
+                PrefetchDataServiceImpl(
+                    mediaProviderClient,
+                    userMonitor,
+                    context,
+                    backgroundDispatcher,
+                    scope,
+                )
         }
         return prefetchDataService
     }
diff --git a/photopicker/src/com/android/photopicker/inject/ApplicationModule.kt b/photopicker/src/com/android/photopicker/inject/ApplicationModule.kt
index cdadb5295..f9f3a45d8 100644
--- a/photopicker/src/com/android/photopicker/inject/ApplicationModule.kt
+++ b/photopicker/src/com/android/photopicker/inject/ApplicationModule.kt
@@ -22,6 +22,7 @@ import android.util.Log
 import com.android.photopicker.core.configuration.DeviceConfigProxy
 import com.android.photopicker.core.configuration.DeviceConfigProxyImpl
 import com.android.photopicker.core.network.NetworkMonitor
+import com.android.photopicker.data.MediaProviderClient
 import dagger.Module
 import dagger.Provides
 import dagger.hilt.InstallIn
@@ -78,6 +79,12 @@ class ApplicationModule {
         return DeviceConfigProxyImpl()
     }
 
+    /** Provider for [MediaProviderClient]. */
+    @Provides
+    fun providerMediaProviderClient(): MediaProviderClient {
+        return MediaProviderClient()
+    }
+
     /**
      * Provider for the [NetworkMonitor]. This is lazily initialized only when requested to save on
      * initialization costs of this module.
@@ -93,7 +100,7 @@ class ApplicationModule {
         } else {
             Log.d(
                 NetworkMonitor.TAG,
-                "NetworkMonitor requested, but not yet initialized. Initializing NetworkMonitor."
+                "NetworkMonitor requested, but not yet initialized. Initializing NetworkMonitor.",
             )
             networkMonitor = NetworkMonitor(context, scope)
             return networkMonitor
diff --git a/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt b/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt
index fd87f4a86..6700b1872 100644
--- a/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt
+++ b/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt
@@ -47,6 +47,7 @@ import com.android.photopicker.data.NotificationServiceImpl
 import com.android.photopicker.data.PrefetchDataService
 import com.android.photopicker.data.PrefetchDataServiceImpl
 import com.android.photopicker.data.model.Media
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
 import com.android.photopicker.features.search.data.SearchDataService
 import dagger.Lazy
 import dagger.Module
@@ -120,6 +121,7 @@ class EmbeddedServiceModule {
         userMonitor: Lazy<UserMonitor>,
         dataService: Lazy<DataService>,
         searchDataService: Lazy<SearchDataService>,
+        categoryDataService: Lazy<CategoryDataService>,
         events: Lazy<Events>,
     ): EmbeddedViewModelFactory {
         if (::embeddedViewModelFactory.isInitialized) {
@@ -133,6 +135,7 @@ class EmbeddedServiceModule {
                     bannerManager,
                     dataService,
                     searchDataService,
+                    categoryDataService,
                     events,
                     featureManager,
                     selection,
@@ -254,6 +257,7 @@ class EmbeddedServiceModule {
         @ApplicationContext appContext: Context,
         events: Events,
         processOwnerHandle: UserHandle,
+        mediaProviderClient: MediaProviderClient,
     ): DataService {
 
         if (!::dataService.isInitialized) {
@@ -267,7 +271,7 @@ class EmbeddedServiceModule {
                     scope,
                     dispatcher,
                     notificationService,
-                    MediaProviderClient(),
+                    mediaProviderClient,
                     configurationManager.configuration,
                     featureManager,
                     appContext,
@@ -389,7 +393,13 @@ class EmbeddedServiceModule {
 
     @Provides
     @SessionScoped
-    fun providePrefetchDataService(): PrefetchDataService {
+    fun providePrefetchDataService(
+        userMonitor: UserMonitor,
+        @ApplicationContext context: Context,
+        @Background backgroundDispatcher: CoroutineDispatcher,
+        mediaProviderClient: MediaProviderClient,
+        @Background scope: CoroutineScope,
+    ): PrefetchDataService {
 
         if (!::prefetchDataService.isInitialized) {
             Log.d(
@@ -397,7 +407,14 @@ class EmbeddedServiceModule {
                 "PrefetchDataService requested but not yet initialized. " +
                     "Initializing PrefetchDataService.",
             )
-            prefetchDataService = PrefetchDataServiceImpl()
+            prefetchDataService =
+                PrefetchDataServiceImpl(
+                    mediaProviderClient,
+                    userMonitor,
+                    context,
+                    backgroundDispatcher,
+                    scope,
+                )
         }
         return prefetchDataService
     }
diff --git a/photopicker/src/com/android/photopicker/util/HierarchicalFocusCoordinator.kt b/photopicker/src/com/android/photopicker/util/HierarchicalFocusCoordinator.kt
new file mode 100644
index 000000000..feb91fd10
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/util/HierarchicalFocusCoordinator.kt
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.CompositionLocalProvider
+import androidx.compose.runtime.DisposableEffect
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.State
+import androidx.compose.runtime.compositionLocalOf
+import androidx.compose.runtime.derivedStateOf
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateListOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberUpdatedState
+import androidx.compose.runtime.snapshots.SnapshotStateList
+import androidx.compose.ui.focus.FocusRequester
+import androidx.compose.ui.platform.LocalFocusManager
+import kotlinx.coroutines.CoroutineScope
+
+/**
+ * Coordinates focus for any composables in [content] and determines which composable will get
+ * focus. [HierarchicalFocusCoordinator]s can be nested, and form a tree, with an implicit root.
+ * Focus-requiring components (i.e. components using [ActiveFocusListener] or
+ * [ActiveFocusRequester]) should only be in the leaf [HierarchicalFocusCoordinator]s, and there
+ * should be at most one per [HierarchicalFocusCoordinator]. For [HierarchicalFocusCoordinator]
+ * elements sharing a parent (or at the top level, sharing the implicit root parent), only one
+ * should have focus enabled. The selected [HierarchicalFocusCoordinator] is the one that has focus
+ * enabled for itself and all ancestors, it will pass focus to its focus-requiring component if it
+ * has one, or call FocusManager#clearFocus() otherwise. If no [HierarchicalFocusCoordinator] is
+ * selected, there will be no change on the focus state.
+ *
+ * Example usage:
+ *
+ * @param requiresFocus a function should return true when the [content] subtree of the composition
+ *   is active and may requires the focus (and false when it's not). For example, a pager can
+ *   enclose each page's content with a call to [HierarchicalFocusCoordinator], marking only the
+ *   current page as requiring focus.
+ * @param content The content of this component.
+ */
+@Composable
+public fun HierarchicalFocusCoordinator(
+    requiresFocus: () -> Boolean,
+    content: @Composable () -> Unit,
+) {
+    val focusManager = LocalFocusManager.current
+    FocusComposableImpl(
+        requiresFocus,
+        onFocusChanged = { if (it) focusManager.clearFocus() },
+        content = content,
+    )
+}
+
+/**
+ * Use as part of a focus-requiring component to register a callback to be notified when the focus
+ * state changes.
+ *
+ * @param onFocusChanged callback to be invoked when the focus state changes, the parameter is the
+ *   new state (if true, we are becoming active and should request focus).
+ */
+@Composable
+public fun ActiveFocusListener(onFocusChanged: CoroutineScope.(Boolean) -> Unit) {
+    FocusComposableImpl(focusEnabled = { true }, onFocusChanged = onFocusChanged, content = {})
+}
+
+/**
+ * Use as part of a focus-requiring component to register a callback to automatically request focus
+ * when this component is active. Note that this may call requestFocus in the provided
+ * FocusRequester, so that focusRequester should be used in a .focusRequester modifier on a
+ * Composable that is part of the composition.
+ *
+ * @param focusRequester The associated [FocusRequester] to request focus on.
+ */
+@Composable
+public fun ActiveFocusRequester(focusRequester: FocusRequester) {
+    ActiveFocusListener { if (it) focusRequester.requestFocus() }
+}
+
+/**
+ * Creates, remembers and returns a new [FocusRequester], that will have .requestFocus called when
+ * the enclosing [HierarchicalFocusCoordinator] becomes active. Note that the location you call this
+ * is important, in particular, which [HierarchicalFocusCoordinator] is enclosing it. Also, this may
+ * call requestFocus in the returned FocusRequester, so that focusRequester should be used in a
+ * .focusRequester modifier on a Composable that is part of the composition.
+ */
+@Composable
+public fun rememberActiveFocusRequester() =
+    remember { FocusRequester() }.also { ActiveFocusRequester(it) }
+
+/**
+ * Implements a node in the Focus control tree (either a [HierarchicalFocusCoordinator] or
+ * [ActiveFocusListener]). Each [FocusComposableImpl] maps to a [FocusNode] in our internal
+ * representation, this is used to:
+ * 1) Check that our parent is focused (or we have no explicit parent), to see if we can be focused.
+ * 2) See if we have children. If not, we are a leaf node and will forward focus status updates to
+ *    the onFocusChanged callback.
+ */
+@Composable
+internal fun FocusComposableImpl(
+    focusEnabled: () -> Boolean,
+    onFocusChanged: CoroutineScope.(Boolean) -> Unit,
+    content: @Composable () -> Unit,
+) {
+    val updatedFocusEnabled by rememberUpdatedState(focusEnabled)
+    val parent by rememberUpdatedState(LocalFocusNodeParent.current)
+
+    // Node in our internal tree representation of the FocusComposableImpl
+    val node = remember {
+        FocusNode(
+            focused = derivedStateOf { (parent?.focused?.value ?: true) && updatedFocusEnabled() }
+        )
+    }
+
+    // Attach our node to our parent's (and remove if we leave the composition).
+    parent?.let {
+        DisposableEffect(it) {
+            it.children.add(node)
+
+            onDispose { it.children.remove(node) }
+        }
+    }
+
+    CompositionLocalProvider(LocalFocusNodeParent provides node, content = content)
+
+    // If we are a leaf node, forward events to the onFocusChanged callback
+    LaunchedEffect(node.focused.value) {
+        if (node.children.isEmpty()) {
+            onFocusChanged(node.focused.value)
+        }
+    }
+}
+
+// Internal class used to represent a node in our tree of focus-aware components.
+internal class FocusNode(
+    val focused: State<Boolean>,
+    var children: SnapshotStateList<FocusNode> = mutableStateListOf(),
+)
+
+// Composition Local used to keep a tree of focus-aware nodes (either controller nodes or
+// focus requesting nodes).
+// Nodes will register into their parent (unless they are the top ones) when they enter the
+// composition and are removed when they leave it.
+internal val LocalFocusNodeParent = compositionLocalOf<FocusNode?> { null }
diff --git a/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt b/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt
index 776e59f60..88a2c3067 100644
--- a/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt
+++ b/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt
@@ -17,7 +17,10 @@
 package com.android.photopicker.util
 
 import android.util.Log
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.async
 import kotlinx.coroutines.coroutineScope
 import kotlinx.coroutines.withTimeout
@@ -30,8 +33,10 @@ private const val TAG = "MapOfDeferredWithTimeout"
  * Each lambda runs in parallel using [async] and a (key -> [Deferred] result) map is returned by
  * this method.
  *
- * If any [async] task runs for longer than the provided timeout, it will automatically be cancelled
- * and the result will be set to null.
+ * If any [async] task runs for longer than the provided timeout, it will automatically be marked as
+ * cancelled and the result will be set to null. However, the task should periodically check if it
+ * was cancelled and terminate processing on its own. This is because coroutine cancellation is
+ * cooperative.
  *
  * If any async task throws an error, it will be swallowed and the result will be set to null.
  */
@@ -39,6 +44,8 @@ suspend fun <A, B> mapOfDeferredWithTimeout(
     inputMap: Map<A, suspend (B) -> Any?>,
     input: B,
     timeoutMillis: Long,
+    backgroundScope: CoroutineScope,
+    dispatcher: CoroutineDispatcher = Dispatchers.IO,
 ): Map<A, Deferred<Any?>> = coroutineScope {
     inputMap
         .map<A, suspend (B) -> Any?, Pair<A, Deferred<Any?>>> { (key, block) ->
@@ -46,13 +53,17 @@ suspend fun <A, B> mapOfDeferredWithTimeout(
                 async {
                     try {
                         withTimeout(timeoutMillis) {
+                            // Coroutine cancellations are cooperative. This means that if the block
+                            // running inside [withTimeout] is non-cooperative, the timeout will
+                            // not be enforced. In order to ensure that the timeout is enforced,
+                            // wrap the call in an [async] block which is cancellation aware.
                             Log.d(TAG, "Fetching result for : $key")
-                            val result = block(input)
+                            val result = backgroundScope.async(dispatcher) { block(input) }.await()
                             Log.d(TAG, "Finished fetching result for : $key val: $result")
                             result
                         }
                     } catch (e: RuntimeException) {
-                        Log.e(TAG, "An error occurred in fetching result for key: $key")
+                        Log.e(TAG, "An error occurred in fetching result for key: $key", e)
                         null
                     }
                 }
diff --git a/photopicker/tests/AndroidManifest.xml b/photopicker/tests/AndroidManifest.xml
index 379d6c204..ba44988bf 100644
--- a/photopicker/tests/AndroidManifest.xml
+++ b/photopicker/tests/AndroidManifest.xml
@@ -49,7 +49,7 @@
     <!-- A test provider to allow the test application to issue uri grants for selected media-->
     <provider
       android:name="com.android.photopicker.util.test.StubProvider"
-      android:authorities="photopickertest"
+      android:authorities="stubprovider"
       android:exported="false"
       android:grantUriPermissions="true"
     />
diff --git a/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt b/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt
index 277af9a9a..6ff37d90f 100644
--- a/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt
@@ -114,7 +114,8 @@ class MainActivityTest {
                 resources.getDrawable(R.drawable.android, /* theme= */ null)
             }
             whenever(mockUserManager.getProfileLabel()) { "label" }
-            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java))) {
+            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java)))
+            @JvmSerializableLambda {
                 UserProperties.Builder().build()
             }
         }
diff --git a/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt b/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt
index 81237c46a..2c1bf8943 100644
--- a/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt
@@ -104,7 +104,8 @@ abstract class PhotopickerFeatureBaseTest {
                     resources.getString(R.string.photopicker_profile_unknown_label),
                 )
             // Return default [UserProperties] for all [UserHandle]
-            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java))) {
+            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java)))
+            @JvmSerializableLambda {
                 UserProperties.Builder().build()
             }
         }
diff --git a/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt b/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt
index 5ce7a6936..0778b6580 100644
--- a/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt
@@ -21,10 +21,15 @@ import android.content.ContentResolver
 import android.content.Context
 import android.content.Intent
 import android.content.pm.PackageManager
+import android.os.Build
 import android.os.UserManager
+import android.platform.test.annotations.DisableFlags
+import android.platform.test.annotations.EnableFlags
+import android.platform.test.flag.junit.SetFlagsRule
 import android.provider.MediaStore
 import android.test.mock.MockContentResolver
 import androidx.compose.ui.test.junit4.createAndroidComposeRule
+import androidx.test.filters.SdkSuppress
 import com.android.photopicker.R
 import com.android.photopicker.core.configuration.ConfigurationManager
 import com.android.photopicker.core.events.Events
@@ -36,12 +41,14 @@ import com.android.photopicker.data.DataService
 import com.android.photopicker.data.TestDataServiceImpl
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.navigateToAlbumGrid
+import com.android.photopicker.extensions.navigateToCategoryGrid
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
 import com.android.photopicker.util.test.MockContentProviderWrapper
 import com.android.photopicker.util.test.StubProvider
 import com.android.photopicker.util.test.whenever
+import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -77,6 +84,7 @@ class PhotopickerAppTest : PhotopickerFeatureBaseTest() {
     @get:Rule(order = 1)
     val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
     @get:Rule(order = 2) val glideRule = GlideTestRule()
+    @get:Rule(order = 3) var setFlagsRule = SetFlagsRule()
 
     val testDispatcher = StandardTestDispatcher()
 
@@ -130,7 +138,9 @@ class PhotopickerAppTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
-    fun testDataDisruptionResetsTheUi() {
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testDataDisruptionResetsTheUi_searchFlagOff() {
         testScope.runTest {
             composeTestRule.setContent {
                 callPhotopickerMain(
@@ -187,4 +197,65 @@ class PhotopickerAppTest : PhotopickerFeatureBaseTest() {
                 .isEqualTo(startDestination)
         }
     }
+
+    @Test
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testDataDisruptionResetsTheUi_searchFlagOn() {
+        testScope.runTest {
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager.get(),
+                    selection = selection.get(),
+                    events = events.get(),
+                    disruptiveDataFlow =
+                        dataService.get().disruptiveDataUpdateChannel.receiveAsFlow().runningFold(
+                            initial = 0
+                        ) { prev, _ ->
+                            prev + 1
+                        },
+                )
+            }
+
+            selection.get().addAll(StubProvider.getTestMediaFromStubProvider(count = 5))
+
+            advanceTimeBy(100)
+
+            assertWithMessage("Expected selection to contain items")
+                .that(selection.get().snapshot().size)
+                .isEqualTo(5)
+
+            val startDestination = navController.currentBackStackEntry?.destination?.route
+            assertWithMessage("Expected the starting destination to not be categories album grid")
+                .that(startDestination)
+                .isNotEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            composeTestRule.runOnUiThread { navController.navigateToCategoryGrid() }
+            composeTestRule.waitForIdle()
+
+            val albumRoute = navController.currentBackStackEntry?.destination?.route
+            assertWithMessage("Expected current route to be Category Album Grid")
+                .that(albumRoute)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            val testDataService =
+                checkNotNull(dataService.get() as? TestDataServiceImpl) {
+                    "Expected a TestDataServiceImpl"
+                }
+
+            testDataService.sendDisruptiveDataUpdateNotification()
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            assertWithMessage("Expected selection to be empty")
+                .that(selection.get().snapshot().size)
+                .isEqualTo(0)
+
+            val endRoute = navController.currentBackStackEntry?.destination?.route
+            assertWithMessage("Expected to return to start destination")
+                .that(endRoute)
+                .isEqualTo(startDestination)
+        }
+    }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt b/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt
index 08de0b7a2..fb47d8a1a 100644
--- a/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt
@@ -65,6 +65,7 @@ import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.Mock
 import org.mockito.Mockito.anyInt
 import org.mockito.Mockito.anyString
+import org.mockito.Mockito.eq
 import org.mockito.Mockito.isNull
 import org.mockito.Mockito.mock
 import org.mockito.Mockito.never
@@ -77,6 +78,17 @@ import org.mockito.MockitoAnnotations
 @OptIn(ExperimentalCoroutinesApi::class)
 class BannerManagerImplTest {
 
+    /**
+     * Class that exposes the @hide api [targetUserId] in order to supply proper values for
+     * reflection based code that is inspecting this field.
+     *
+     * @property targetUserId
+     */
+    private class ReflectedResolveInfo(@JvmField val targetUserId: Int) : ResolveInfo() {
+
+        override fun isCrossProfileIntentForwarderActivity(): Boolean = true
+    }
+
     // Isolate the test device by providing a test wrapper around device config so that the
     // tests can control the flag values that are returned.
     val deviceConfigProxy = TestDeviceConfigProxyImpl()
@@ -149,9 +161,14 @@ class BannerManagerImplTest {
         whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
         whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
 
-        val mockResolveInfo = mock(ResolveInfo::class.java)
-        whenever(mockResolveInfo.isCrossProfileIntentForwarderActivity()) { true }
-        whenever(mockPackageManager.queryIntentActivities(any(Intent::class.java), anyInt())) {
+        val mockResolveInfo = ReflectedResolveInfo(USER_ID_MANAGED)
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                eq(USER_HANDLE_PRIMARY),
+            )
+        ) {
             listOf(mockResolveInfo)
         }
 
@@ -160,11 +177,13 @@ class BannerManagerImplTest {
                 resources.getDrawable(R.drawable.android, /* theme= */ null)
             }
             whenever(mockUserManager.getProfileLabel()) { PLATFORM_PROVIDED_PROFILE_LABEL }
-            whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIMARY)) {
-                UserProperties.Builder().build()
-            }
+            whenever(
+                mockUserManager.getUserProperties(USER_HANDLE_PRIMARY)
+            ) @JvmSerializableLambda { UserProperties.Builder().build() }
             // By default, allow managed profile to be available
-            whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) {
+            whenever(
+                mockUserManager.getUserProperties(USER_HANDLE_MANAGED)
+            ) @JvmSerializableLambda {
                 UserProperties.Builder()
                     .setCrossProfileContentSharingStrategy(
                         UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
@@ -772,11 +791,17 @@ class BannerManagerImplTest {
                 callingPackageUid = 12345,
                 callingPackageLabel = "Test Package",
             )
+            val test_session_banner =
+                object : BannerDeclaration {
+                    override val id = "test_session_banner"
+                    override val dismissableStrategy = BannerDeclaration.DismissStrategy.SESSION
+                    override val dismissable = true
+                }
 
-            bannerManager.markBannerAsDismissed(BannerDefinitions.SWITCH_PROFILE)
+            bannerManager.markBannerAsDismissed(test_session_banner)
 
             assertWithMessage("Expected banner state to be dismissed")
-                .that(bannerManager.getBannerState(BannerDefinitions.SWITCH_PROFILE)?.dismissed)
+                .that(bannerManager.getBannerState(test_session_banner)?.dismissed)
                 .isTrue()
 
             // Ensure no calls to persist the state in the database.
diff --git a/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt b/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt
index e444adabb..4382acead 100644
--- a/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt
@@ -17,6 +17,7 @@
 package com.android.photopicker.core.configuration
 
 import android.content.Intent
+import android.media.ApplicationMediaCapabilities
 import com.android.photopicker.core.events.generatePickerSessionId
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.flow.SharingStarted
@@ -69,6 +70,7 @@ class TestPhotopickerConfiguration {
         private var sessionId: Int = generatePickerSessionId()
         private var flags: PhotopickerFlags = PhotopickerFlags()
         private var mimeTypes: ArrayList<String> = arrayListOf("image/*", "video/*")
+        private var appMediaCapabilities: ApplicationMediaCapabilities? = null
 
         fun action(value: String) = apply { this.action = value }
 
@@ -92,6 +94,10 @@ class TestPhotopickerConfiguration {
 
         fun mimeTypes(value: ArrayList<String>) = apply { this.mimeTypes = value }
 
+        fun appMediaCapabilities(value: ApplicationMediaCapabilities) = apply {
+            this.appMediaCapabilities = value
+        }
+
         fun build(): PhotopickerConfiguration {
             return PhotopickerConfiguration(
                 action = action,
@@ -105,6 +111,7 @@ class TestPhotopickerConfiguration {
                 sessionId = sessionId,
                 flags = flags,
                 mimeTypes = mimeTypes,
+                callingPackageMediaCapabilities = appMediaCapabilities,
             )
         }
     }
diff --git a/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt b/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt
index 36210781b..f2ecc8852 100644
--- a/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt
@@ -25,6 +25,9 @@ import android.os.Build
 import android.os.Parcel
 import android.os.UserHandle
 import android.os.UserManager
+import android.platform.test.annotations.DisableFlags
+import android.platform.test.annotations.EnableFlags
+import android.platform.test.flag.junit.SetFlagsRule
 import android.test.mock.MockContentResolver
 import android.view.SurfaceControlViewHost
 import androidx.activity.compose.LocalOnBackPressedDispatcherOwner
@@ -99,6 +102,7 @@ import com.android.photopicker.tests.HiltTestActivity
 import com.android.photopicker.util.test.MockContentProviderWrapper
 import com.android.photopicker.util.test.nonNullableEq
 import com.android.photopicker.util.test.whenever
+import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -146,6 +150,7 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     @get:Rule(order = 1)
     val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
     @get:Rule(order = 2) val glideRule = GlideTestRule()
+    @get:Rule(order = 3) var setFlagsRule = SetFlagsRule()
 
     /** Setup dependencies for the UninstallModules for the test class. */
     @Module
@@ -272,7 +277,8 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     }
 
     @Test
-    fun testNavigationBarIsNotDisplayedInEmbeddedWhenCollapsed() =
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testNavigationBarIsNotDisplayedInEmbeddedWhenCollapsed_searchFlagOff() =
         testScope.runTest {
             val resources = getTestableContext().getResources()
             val photosGridNavButtonLabel =
@@ -301,7 +307,8 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
         }
 
     @Test
-    fun testNavigationBarIsDisplayedInEmbeddedWhenExpanded() =
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testNavigationBarIsDisplayedInEmbeddedWhenExpanded_searchFlagOff() =
         testScope.runTest {
             val resources = getTestableContext().getResources()
             val photosGridNavButtonLabel =
@@ -332,6 +339,39 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
                 .assert(hasClickAction())
         }
 
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testNavigationBarIsDisplayedInEmbeddedWhenExpanded_searchFlagOn() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val photosGridNavButtonLabel =
+                resources.getString(R.string.photopicker_photos_nav_button_label)
+            val categoryGridNavButtonLabel =
+                resources.getString(R.string.photopicker_categories_nav_button_label)
+            composeTestRule.setContent {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            // Photos Grid Nav Button and Category Grid Nav Button
+            composeTestRule
+                .onNode(hasText(photosGridNavButtonLabel))
+                .assertIsDisplayed()
+                .assert(hasClickAction())
+            composeTestRule
+                .onNode(hasText(categoryGridNavButtonLabel))
+                .assertIsDisplayed()
+                .assert(hasClickAction())
+        }
+
     @Test
     fun testSwipeLeftToNavigateDisabledInEmbeddedWhenCollapsed() =
         testScope.runTest {
@@ -365,7 +405,8 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
         }
 
     @Test
-    fun testSwipeLeftToAlbumWorksInEmbeddedWhenExpanded() =
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSwipeLeftToAlbumWorksInEmbeddedWhenExpanded_searchFlagOff() =
         testScope.runTest {
             composeTestRule.setContent {
                 CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
@@ -396,6 +437,39 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
                 .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
         }
 
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSwipeLeftToCategoryWorksInEmbeddedWhenExpanded_searchFlagOn() =
+        testScope.runTest {
+            composeTestRule.setContent {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            composeTestRule
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
+                .onFirst()
+                .performTouchInput { swipeLeft() }
+            composeTestRule.waitForIdle()
+            val route = navController.currentBackStackEntry?.destination?.route
+            assertWithMessage("Expected swipe to navigate to Categories Album Grid")
+                .that(route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+        }
+
     @Test
     fun testProfileSelectorIsNotDisplayedInEmbeddedWhenCollapsed() =
         testScope.runTest {
diff --git a/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt b/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt
index 15ee6cc89..eb4bc6efb 100644
--- a/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt
@@ -65,8 +65,6 @@ import com.android.photopicker.core.Main
 import com.android.photopicker.core.ViewModelModule
 import com.android.photopicker.core.configuration.ConfigurationManager
 import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
-import com.android.photopicker.core.events.Events
-import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.glide.GlideTestRule
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.data.DataService
@@ -99,7 +97,6 @@ import javax.inject.Inject
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.async
 import kotlinx.coroutines.test.StandardTestDispatcher
 import kotlinx.coroutines.test.TestScope
 import kotlinx.coroutines.test.advanceTimeBy
@@ -173,11 +170,9 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
     @Mock lateinit var mockPackageManager: PackageManager
     @Inject lateinit var mockContext: Context
     @Inject lateinit var embeddedServiceComponentBuilder: EmbeddedServiceComponentBuilder
-    @Inject lateinit var selection: Selection<Media>
-    @Inject lateinit var featureManager: FeatureManager
-    @Inject lateinit var events: Events
+    @Inject lateinit var selection: Lazy<Selection<Media>>
     @Inject override lateinit var configurationManager: Lazy<ConfigurationManager>
-    @Inject lateinit var dataService: DataService
+    @Inject lateinit var dataService: Lazy<DataService>
     @Inject lateinit var embeddedLifecycle: EmbeddedLifecycle
 
     @Captor lateinit var uriCaptor: ArgumentCaptor<Uri>
@@ -331,7 +326,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             // Ensure the click handler correctly ran by checking the selection snapshot.
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(1)
         }
 
@@ -391,14 +386,14 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
                 .that(sessionLifecycle.lifecycle.currentState)
                 .isEqualTo(Lifecycle.State.RESUMED)
 
-            async { session.notifyVisibilityChanged(isVisible = false) }.await()
+            session.notifyVisibilityChanged(isVisible = false)
             advanceTimeBy(100)
 
             assertWithMessage("Expected state to be CREATED")
                 .that(sessionLifecycle.lifecycle.currentState)
                 .isEqualTo(Lifecycle.State.CREATED)
 
-            async { session.notifyVisibilityChanged(isVisible = true) }.await()
+            session.notifyVisibilityChanged(isVisible = true)
             advanceTimeBy(100)
 
             assertWithMessage("Expected final state to be RESUMED")
@@ -461,10 +456,10 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
     fun testURIDebounceOnSelectionOfMediaItems() =
         testScope.runTest {
             val component = embeddedServiceComponentBuilder.build()
-            val session = getSessionUnderTest(component)
 
-            val itemCount = 20
-            setUpTestDataWithStubProvider(itemCount)
+            setUpTestDataWithStubProvider(mediaCount = 20)
+
+            val session = getSessionUnderTest(component)
 
             advanceTimeBy(100)
 
@@ -518,7 +513,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             // Ensure the click handler correctly ran by checking the selection snapshot.
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(2) // Indices {2, 4}
 
             // Verify that grantUriPermission is invoked for all newly selected media.
@@ -560,7 +555,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             // Ensure the click handler correctly ran by checking the selection snapshot.
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(3) // Indices {4, 6, 8}
 
             // Verify that grantUriPermission is invoked for all newly selected media.
@@ -584,10 +579,10 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
     fun testSelectionUpdateGrantsAndRevokesPermissionSuccess() =
         testScope.runTest {
             val component = embeddedServiceComponentBuilder.build()
-            val session = getSessionUnderTest(component)
 
-            val itemCount = 20
-            setUpTestDataWithStubProvider(itemCount)
+            setUpTestDataWithStubProvider(mediaCount = 20)
+
+            val session = getSessionUnderTest(component)
 
             advanceTimeBy(100)
 
@@ -631,7 +626,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             // Ensure the click handler correctly ran by checking the selection snapshot.
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(3)
 
             // Verify that grantUriPermission is invoked for all newly selected media.
@@ -660,7 +655,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
             composeTestRule.waitForIdle()
 
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(1)
 
             // Verify that revokeUriPermission is invoked for all newly deselected media.
@@ -688,7 +683,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
             composeTestRule.waitForIdle()
 
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(3)
 
             // Verify that grantUriPermission is invoked for all newly selected media.
@@ -705,7 +700,9 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
     @Test
     fun testSelectionGrantOrRevokePermissionFailed() =
         testScope.runTest {
-            setUpTestDataWithStubProvider(20)
+            val component = embeddedServiceComponentBuilder.build()
+
+            setUpTestDataWithStubProvider(mediaCount = 20)
 
             // Mark image at node 0 as media item we aren't able to grant permission.
             val grantFailureUri = constructUrisForIndices(setOf(0))[0]
@@ -713,7 +710,6 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
                 EmbeddedService.GrantResult.FAILURE
             }
 
-            val component = embeddedServiceComponentBuilder.build()
             val session = getSessionUnderTest(component)
             advanceTimeBy(100)
 
@@ -757,7 +753,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             // Ensure the click handler correctly ran by checking the selection snapshot.
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(3)
 
             // Verify that client callback is invoked for all uris that were successfully
@@ -792,7 +788,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             // Ensure the click handler correctly ran by checking the selection snapshot.
             assertWithMessage("Expected selection to contain an item, but it did not.")
-                .that(selection.snapshot().size)
+                .that(selection.get().snapshot().size)
                 .isEqualTo(2) // images at indices 0, 4 are still selected
 
             // Verify client callback is never invoked if we failed to revoke permission to uri
@@ -818,7 +814,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
             val newWidth = 2 * initialWidth
             val newHeight = 2 * initialHeight
 
-            async { session.notifyResized(newWidth, newHeight) }.await()
+            session.notifyResized(newWidth, newHeight)
             advanceTimeBy(100)
 
             assertWithMessage("Expected view's width to be resized")
@@ -852,7 +848,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
                 )
             }
 
-            async { session.notifyPhotopickerExpanded(true) }.await()
+            session.notifyPhotopickerExpanded(true)
             advanceTimeBy(100)
 
             val resources = getTestableContext().getResources()
@@ -866,7 +862,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
             // Create new configuration which will update theme to dark
             val newConfig = Configuration()
             newConfig.uiMode = Configuration.UI_MODE_NIGHT_YES
-            async { session.notifyConfigurationChanged(newConfig) }.await()
+            session.notifyConfigurationChanged(newConfig)
             advanceTimeBy(100)
 
             val finalColor = node.extractTextColor()
@@ -904,7 +900,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             composeTestRule.onNodeWithText(photosTabLabel).assertDoesNotExist()
 
-            async { session.notifyPhotopickerExpanded(true) }.await()
+            session.notifyPhotopickerExpanded(true)
             advanceTimeBy(100)
 
             composeTestRule.onNodeWithText(photosTabLabel).assertExists().assertIsDisplayed()
@@ -941,7 +937,7 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
                 displayName = "Stub Provider",
             )
 
-        val testDataService = dataService as? TestDataServiceImpl
+        val testDataService = dataService.get() as? TestDataServiceImpl
         checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
         testDataService.setAvailableProviders(listOf(stubProvider))
         testDataService.collectionInfo.put(
diff --git a/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt b/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt
index fbc4d502e..b63ebc444 100644
--- a/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt
@@ -20,11 +20,15 @@ import android.content.ContentResolver
 import android.content.Context
 import android.content.pm.PackageManager
 import android.content.pm.UserProperties
+import android.media.ApplicationMediaCapabilities
+import android.media.MediaFeature.HdrType
 import android.net.Uri
+import android.os.Build
 import android.os.Parcel
 import android.os.UserHandle
 import android.os.UserManager
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SdkSuppress
 import androidx.test.filters.SmallTest
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.modules.utils.build.SdkLevel
@@ -39,6 +43,7 @@ import com.android.photopicker.core.events.dispatchPhotopickerExpansionStateChan
 import com.android.photopicker.core.events.dispatchReportPhotopickerApiInfoEvent
 import com.android.photopicker.core.events.dispatchReportPhotopickerMediaItemStatusEvent
 import com.android.photopicker.core.events.dispatchReportPhotopickerSessionInfoEvent
+import com.android.photopicker.core.events.dispatchReportPickerAppMediaCapabilities
 import com.android.photopicker.core.events.generatePickerSessionId
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureToken
@@ -51,6 +56,7 @@ import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.features.search.SearchFeature
 import com.android.photopicker.util.test.mockSystemService
 import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertThat
@@ -117,6 +123,7 @@ class DispatchersTest {
     private lateinit var eventsDispatched: MutableList<Event>
     private lateinit var lazyUserMonitor: Lazy<UserMonitor>
     private lateinit var lazyMediaSelection: Lazy<Selection<Media>>
+    private lateinit var lazyFeatureManager: Lazy<FeatureManager>
 
     private fun setup(testScope: TestScope) {
         val backgroundScope = testScope.backgroundScope
@@ -133,6 +140,7 @@ class DispatchersTest {
                 scope = backgroundScope,
                 prefetchDataService = TestPrefetchDataService(),
             )
+        lazyFeatureManager = Lazy { featureManager }
 
         val events =
             Events(
@@ -151,9 +159,9 @@ class DispatchersTest {
         mockSystemService(mockContext, UserManager::class.java) { mockUserManager }
 
         if (SdkLevel.isAtLeastV()) {
-            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java))) {
-                UserProperties.Builder().build()
-            }
+            whenever(
+                mockUserManager.getUserProperties(any(UserHandle::class.java))
+            ) @JvmSerializableLambda { UserProperties.Builder().build() }
             whenever(mockUserManager.getUserBadge()) {
                 InstrumentationRegistry.getInstrumentation()
                     .context
@@ -354,11 +362,23 @@ class DispatchersTest {
     }
 
     @Test
-    fun testDispatchReportPhotopickerApiInfoEvent() = runTest {
+    fun testDispatchReportPhotopickerApiInfoEventWithPhotoMimeType() = runTest {
         // Setup
         setup(testScope = this)
 
+        val mimeTypeList = arrayListOf("image/jpg")
+        val telemetryMimeTypeMapping = Telemetry.MediaType.PHOTO
+
         val pickerIntentAction = Telemetry.PickerIntentAction.ACTION_PICK_IMAGES
+        val cloudSearch = lazyFeatureManager.get().isFeatureEnabled(SearchFeature::class.java)
+        val photopickerConfiguration =
+            TestPhotopickerConfiguration.build {
+                action(value = "")
+                sessionId(value = sessionId)
+                callingPackageUid(value = packageUid)
+                runtimeEnv(value = PhotopickerRuntimeEnv.EMBEDDED)
+                mimeTypes(mimeTypeList)
+            }
 
         val expectedEvent =
             Event.ReportPhotopickerApiInfo(
@@ -366,15 +386,16 @@ class DispatchersTest {
                 sessionId = sessionId,
                 pickerIntentAction = pickerIntentAction,
                 pickerSize = Telemetry.PickerSize.COLLAPSED,
-                mediaFilter = Telemetry.MediaType.PHOTO,
+                mediaFilter = telemetryMimeTypeMapping,
                 maxPickedItemsCount = 1,
                 selectedTab = Telemetry.SelectedTab.UNSET_SELECTED_TAB,
                 selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM,
                 isOrderedSelectionSet = false,
                 isAccentColorSet = false,
                 isDefaultTabSet = false,
-                isCloudSearchEnabled = false,
+                isCloudSearchEnabled = cloudSearch,
                 isLocalSearchEnabled = false,
+                isTranscodingRequested = false,
             )
 
         // Action
@@ -383,10 +404,207 @@ class DispatchersTest {
             lazyEvents = lazyEvents,
             photopickerConfiguration = photopickerConfiguration,
             pickerIntentAction = pickerIntentAction,
+            lazyFeatureManager = lazyFeatureManager,
         )
         advanceTimeBy(delayTimeMillis = 50)
 
         // Assert
         assertThat(eventsDispatched).contains(expectedEvent)
+        assertThat(expectedEvent.mediaFilter).isEqualTo(telemetryMimeTypeMapping)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerApiInfoEventWithVideoMimeType() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val mimeTypeList = arrayListOf("video/jpg")
+        val telemetryMimeTypeMapping = Telemetry.MediaType.VIDEO
+
+        val pickerIntentAction = Telemetry.PickerIntentAction.ACTION_PICK_IMAGES
+        val cloudSearch = lazyFeatureManager.get().isFeatureEnabled(SearchFeature::class.java)
+        val photopickerConfiguration =
+            TestPhotopickerConfiguration.build {
+                action(value = "")
+                sessionId(value = sessionId)
+                callingPackageUid(value = packageUid)
+                runtimeEnv(value = PhotopickerRuntimeEnv.EMBEDDED)
+                mimeTypes(mimeTypeList)
+            }
+
+        val expectedEvent =
+            Event.ReportPhotopickerApiInfo(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                pickerIntentAction = pickerIntentAction,
+                pickerSize = Telemetry.PickerSize.COLLAPSED,
+                mediaFilter = telemetryMimeTypeMapping,
+                maxPickedItemsCount = 1,
+                selectedTab = Telemetry.SelectedTab.UNSET_SELECTED_TAB,
+                selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM,
+                isOrderedSelectionSet = false,
+                isAccentColorSet = false,
+                isDefaultTabSet = false,
+                isCloudSearchEnabled = cloudSearch,
+                isLocalSearchEnabled = false,
+                isTranscodingRequested = false,
+            )
+
+        // Action
+        dispatchReportPhotopickerApiInfoEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            pickerIntentAction = pickerIntentAction,
+            lazyFeatureManager = lazyFeatureManager,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+        assertThat(expectedEvent.mediaFilter).isEqualTo(telemetryMimeTypeMapping)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerApiInfoEventWithBothPhotoAndVideoMimeType() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val mimeTypeList = arrayListOf("image/jpg", "video/mp4")
+        val telemetryMimeTypeMapping = Telemetry.MediaType.PHOTO_VIDEO
+
+        val pickerIntentAction = Telemetry.PickerIntentAction.ACTION_PICK_IMAGES
+        val cloudSearch = lazyFeatureManager.get().isFeatureEnabled(SearchFeature::class.java)
+        val photopickerConfiguration =
+            TestPhotopickerConfiguration.build {
+                action(value = "")
+                sessionId(value = sessionId)
+                callingPackageUid(value = packageUid)
+                runtimeEnv(value = PhotopickerRuntimeEnv.EMBEDDED)
+                mimeTypes(mimeTypeList)
+            }
+
+        val expectedEvent =
+            Event.ReportPhotopickerApiInfo(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                pickerIntentAction = pickerIntentAction,
+                pickerSize = Telemetry.PickerSize.COLLAPSED,
+                mediaFilter = telemetryMimeTypeMapping,
+                maxPickedItemsCount = 1,
+                selectedTab = Telemetry.SelectedTab.UNSET_SELECTED_TAB,
+                selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM,
+                isOrderedSelectionSet = false,
+                isAccentColorSet = false,
+                isDefaultTabSet = false,
+                isCloudSearchEnabled = cloudSearch,
+                isLocalSearchEnabled = false,
+                isTranscodingRequested = false,
+            )
+
+        // Action
+        dispatchReportPhotopickerApiInfoEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            pickerIntentAction = pickerIntentAction,
+            lazyFeatureManager = lazyFeatureManager,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+        assertThat(expectedEvent.mediaFilter).isEqualTo(telemetryMimeTypeMapping)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerApiInfoEventWithDefaultPhotoAndVideoMimeType() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val mimeTypeList = arrayListOf("image/*", "video/*")
+        val telemetryMimeTypeMapping = Telemetry.MediaType.PHOTO_VIDEO
+
+        val pickerIntentAction = Telemetry.PickerIntentAction.ACTION_PICK_IMAGES
+        val cloudSearch = lazyFeatureManager.get().isFeatureEnabled(SearchFeature::class.java)
+        val photopickerConfiguration =
+            TestPhotopickerConfiguration.build {
+                action(value = "")
+                sessionId(value = sessionId)
+                callingPackageUid(value = packageUid)
+                runtimeEnv(value = PhotopickerRuntimeEnv.EMBEDDED)
+                mimeTypes(mimeTypeList)
+            }
+
+        val expectedEvent =
+            Event.ReportPhotopickerApiInfo(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                pickerIntentAction = pickerIntentAction,
+                pickerSize = Telemetry.PickerSize.COLLAPSED,
+                mediaFilter = telemetryMimeTypeMapping,
+                maxPickedItemsCount = 1,
+                selectedTab = Telemetry.SelectedTab.UNSET_SELECTED_TAB,
+                selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM,
+                isOrderedSelectionSet = false,
+                isAccentColorSet = false,
+                isDefaultTabSet = false,
+                isCloudSearchEnabled = cloudSearch,
+                isLocalSearchEnabled = false,
+                isTranscodingRequested = false,
+            )
+
+        // Action
+        dispatchReportPhotopickerApiInfoEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            pickerIntentAction = pickerIntentAction,
+            lazyFeatureManager = lazyFeatureManager,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+        assertThat(expectedEvent.mediaFilter).isEqualTo(telemetryMimeTypeMapping)
+    }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+    @Test
+    fun testDispatchReportPickerAppMediaCapabilities() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val capabilities =
+            ApplicationMediaCapabilities.Builder().addUnsupportedHdrType(HdrType.HDR10).build()
+
+        val photopickerConfiguration =
+            TestPhotopickerConfiguration.build {
+                action(value = "")
+                sessionId(value = sessionId)
+                callingPackageUid(value = packageUid)
+                runtimeEnv(value = PhotopickerRuntimeEnv.EMBEDDED)
+                appMediaCapabilities(capabilities)
+            }
+
+        val expectedEvent =
+            Event.ReportPickerAppMediaCapabilities(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                supportedHdrTypes = intArrayOf(),
+                unsupportedHdrTypes = intArrayOf(Telemetry.HdrTypes.HDR10_UNSUPPORTED.type),
+            )
+
+        // Action
+        dispatchReportPickerAppMediaCapabilities(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched.size).isEqualTo(1)
+        assertThat(eventsDispatched.get(0).toString()).isEqualTo(expectedEvent.toString())
     }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt b/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt
index 6844c8898..89572c40e 100644
--- a/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt
@@ -146,10 +146,6 @@ class LoadMediaTest {
             override fun getDataSource(): DataSource {
                 return DataSource.LOCAL
             }
-
-            override fun getTimestamp(): Long {
-                return 100L
-            }
         }
 
     @Before
diff --git a/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt b/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt
index ec613a5a2..aca667018 100644
--- a/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt
@@ -55,6 +55,7 @@ import org.junit.runner.RunWith
 import org.mockito.ArgumentCaptor
 import org.mockito.ArgumentMatchers.any
 import org.mockito.ArgumentMatchers.anyInt
+import org.mockito.ArgumentMatchers.eq
 import org.mockito.Captor
 import org.mockito.Mock
 import org.mockito.Mockito.mock
@@ -67,6 +68,17 @@ import org.mockito.MockitoAnnotations
 @OptIn(ExperimentalCoroutinesApi::class)
 class UserMonitorTest {
 
+    /**
+     * Class that exposes the @hide api [targetUserId] in order to supply proper values for
+     * reflection based code that is inspecting this field.
+     *
+     * @property targetUserId
+     */
+    private class ReflectedResolveInfo(@JvmField val targetUserId: Int) : ResolveInfo() {
+
+        override fun isCrossProfileIntentForwarderActivity(): Boolean = true
+    }
+
     private val PLATFORM_PROVIDED_PROFILE_LABEL = "Platform Label"
 
     private val USER_HANDLE_PRIMARY: UserHandle
@@ -77,6 +89,10 @@ class UserMonitorTest {
     private val USER_ID_MANAGED: Int = 10
     private val MANAGED_PROFILE_BASE: UserProfile
 
+    private val USER_HANDLE_PRIVATE: UserHandle
+    private val USER_ID_PRIVATE: Int = 11
+    private val PRIVATE_PROFILE_BASE: UserProfile
+
     private val initialExpectedStatus: UserStatus
     private val mockContentResolver: ContentResolver = mock(ContentResolver::class.java)
 
@@ -117,6 +133,19 @@ class UserMonitorTest {
                 label = PLATFORM_PROVIDED_PROFILE_LABEL,
             )
 
+        val parcel3 = Parcel.obtain()
+        parcel2.writeInt(USER_ID_PRIVATE)
+        parcel2.setDataPosition(0)
+        USER_HANDLE_PRIVATE = UserHandle(parcel3)
+        parcel3.recycle()
+
+        PRIVATE_PROFILE_BASE =
+            UserProfile(
+                handle = USER_HANDLE_PRIVATE,
+                profileType = UserProfile.ProfileType.UNKNOWN,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+            )
+
         initialExpectedStatus =
             UserStatus(
                 activeUserProfile = PRIMARY_PROFILE_BASE,
@@ -148,10 +177,16 @@ class UserMonitorTest {
         whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
         whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
 
-        val mockResolveInfo = mock(ResolveInfo::class.java)
-        whenever(mockResolveInfo.isCrossProfileIntentForwarderActivity()) { true }
-        whenever(mockPackageManager.queryIntentActivities(any(Intent::class.java), anyInt())) {
-            listOf(mockResolveInfo)
+        // Fake for a CrossProfileIntentForwarderActivity for the managed profile
+        val resolveInfoForManagedUser = ReflectedResolveInfo(USER_HANDLE_MANAGED.getIdentifier())
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                eq(USER_HANDLE_PRIMARY),
+            )
+        ) {
+            listOf(resolveInfoForManagedUser)
         }
 
         if (SdkLevel.isAtLeastV()) {
@@ -159,11 +194,13 @@ class UserMonitorTest {
                 resources.getDrawable(R.drawable.android, /* theme= */ null)
             }
             whenever(mockUserManager.getProfileLabel()) { PLATFORM_PROVIDED_PROFILE_LABEL }
-            whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIMARY)) {
-                UserProperties.Builder().build()
-            }
+            whenever(
+                mockUserManager.getUserProperties(USER_HANDLE_PRIMARY)
+            ) @JvmSerializableLambda { UserProperties.Builder().build() }
             // By default, allow managed profile to be available
-            whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) {
+            whenever(
+                mockUserManager.getUserProperties(USER_HANDLE_MANAGED)
+            ) @JvmSerializableLambda {
                 UserProperties.Builder()
                     .setCrossProfileContentSharingStrategy(
                         UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
@@ -201,12 +238,253 @@ class UserMonitorTest {
         }
     }
 
+    @Test
+    fun testProfilesForCrossProfileNoDelegationVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV())
+
+        // Add a third profile (private) to the list of profiles
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, USER_HANDLE_PRIVATE)
+        }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIVATE)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIVATE)) { false }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_PRIVATE)) { USER_HANDLE_PRIMARY }
+
+        // The private profile should delegate its access to the parent
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIVATE)) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
+                )
+                .build()
+        }
+
+        runTest { // this: TestScope
+
+            // When the primary profile is the process owner
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            var reportedStatus = userMonitor.userStatus.first()
+            var expectedStatus =
+                UserStatus(
+                    activeUserProfile = PRIMARY_PROFILE_BASE,
+                    allProfiles =
+                        listOf(
+                            PRIMARY_PROFILE_BASE,
+                            MANAGED_PROFILE_BASE,
+                            PRIVATE_PROFILE_BASE.copy(
+                                disabledReasons =
+                                    setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                            ),
+                        ),
+                    activeContentResolver = mockContentResolver,
+                )
+            assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+
+            // Reset user monitor, private user is now the process owner
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIVATE,
+                )
+
+            reportedStatus = userMonitor.userStatus.first()
+            expectedStatus =
+                UserStatus(
+                    activeUserProfile = PRIVATE_PROFILE_BASE,
+                    allProfiles =
+                        listOf(
+                            PRIMARY_PROFILE_BASE.copy(
+                                disabledReasons =
+                                    setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                            ),
+                            MANAGED_PROFILE_BASE.copy(
+                                disabledReasons =
+                                    setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                            ),
+                            PRIVATE_PROFILE_BASE,
+                        ),
+                    activeContentResolver = mockContentResolver,
+                )
+            assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            //
+            // Reset user monitor, managed user is now the process owner
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_MANAGED,
+                )
+
+            reportedStatus = userMonitor.userStatus.first()
+            expectedStatus =
+                UserStatus(
+                    activeUserProfile = MANAGED_PROFILE_BASE,
+                    allProfiles =
+                        listOf(
+                            PRIMARY_PROFILE_BASE,
+                            MANAGED_PROFILE_BASE,
+                            PRIVATE_PROFILE_BASE.copy(
+                                disabledReasons =
+                                    setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                            ),
+                        ),
+                    activeContentResolver = mockContentResolver,
+                )
+            assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+        }
+    }
+
+    @Test
+    fun testProfilesForCrossProfileDelegationVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV())
+
+        // Add a third profile (private) to the list of profiles
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, USER_HANDLE_PRIVATE)
+        }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIVATE)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIVATE)) { false }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_PRIVATE)) { USER_HANDLE_PRIMARY }
+
+        // The private profile should delegate its access to the parent
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIVATE)) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
+                )
+                .build()
+        }
+
+        runTest { // this: TestScope
+
+            // When the primary profile is the process owner
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            var reportedStatus = userMonitor.userStatus.first()
+            var expectedStatus =
+                UserStatus(
+                    activeUserProfile = PRIMARY_PROFILE_BASE,
+                    allProfiles =
+                        listOf(PRIMARY_PROFILE_BASE, MANAGED_PROFILE_BASE, PRIVATE_PROFILE_BASE),
+                    activeContentResolver = mockContentResolver,
+                )
+            assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+
+            // Reset user monitor, private user is now the process owner
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIVATE,
+                )
+
+            reportedStatus = userMonitor.userStatus.first()
+            expectedStatus =
+                UserStatus(
+                    activeUserProfile = PRIVATE_PROFILE_BASE,
+                    allProfiles =
+                        listOf(PRIMARY_PROFILE_BASE, MANAGED_PROFILE_BASE, PRIVATE_PROFILE_BASE),
+                    activeContentResolver = mockContentResolver,
+                )
+            assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            //
+            // Reset user monitor, managed user is now the process owner
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_MANAGED,
+                )
+
+            reportedStatus = userMonitor.userStatus.first()
+            expectedStatus =
+                UserStatus(
+                    activeUserProfile = MANAGED_PROFILE_BASE,
+                    allProfiles =
+                        listOf(PRIMARY_PROFILE_BASE, MANAGED_PROFILE_BASE, PRIVATE_PROFILE_BASE),
+                    activeContentResolver = mockContentResolver,
+                )
+            assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+        }
+    }
+
     /** Ensures profiles with a cross profile forwarding intent are active */
     @Test
     fun testProfilesForCrossProfileIntentForwardingVPlus() {
 
         assumeTrue(SdkLevel.isAtLeastV())
-        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) {
+
+        // Since the UserProperties here will return no delegation, this will
+        // have to rely on CrossProfileIntentForwarderActivity found for the managed
+        // user in order to enable cross profile for this profile.
+        // This is already setup in the base setup method.
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) @JvmSerializableLambda {
             UserProperties.Builder()
                 .setCrossProfileContentSharingStrategy(
                     UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
@@ -214,12 +492,6 @@ class UserMonitorTest {
                 .build()
         }
 
-        val mockResolveInfo = mock(ResolveInfo::class.java)
-        whenever(mockResolveInfo.isCrossProfileIntentForwarderActivity()) { true }
-        whenever(mockPackageManager.queryIntentActivities(any(Intent::class.java), anyInt())) {
-            listOf(mockResolveInfo)
-        }
-
         runTest { // this: TestScope
             userMonitor =
                 UserMonitor(
@@ -247,13 +519,7 @@ class UserMonitorTest {
     /** Ensures profiles with a cross profile forwarding intent are active */
     @Test
     fun testProfilesForCrossProfileIntentForwardingUMinus() {
-
         assumeFalse(SdkLevel.isAtLeastV())
-        val mockResolveInfo = mock(ResolveInfo::class.java)
-        whenever(mockResolveInfo.isCrossProfileIntentForwarderActivity()) { true }
-        whenever(mockPackageManager.queryIntentActivities(any(Intent::class.java), anyInt())) {
-            listOf(mockResolveInfo)
-        }
 
         runTest { // this: TestScope
             userMonitor =
@@ -279,29 +545,46 @@ class UserMonitorTest {
         }
     }
 
-    /**
-     * Ensures that profiles that explicitly request not to be shown in sharing surfaces are not
-     * included
-     */
+    /** Ensures profiles without a cross profile forwarding intent are disabled */
     @Test
-    fun testIgnoresSharingDisabledProfiles() {
-        assumeTrue(SdkLevel.isAtLeastV())
+    fun testProfilesForCrossProfileIntentManagedDoesNotSupportVPlus() {
 
-        val parcel = Parcel.obtain()
-        parcel.writeInt(100)
-        parcel.setDataPosition(0)
-        val disabledSharingProfile = UserHandle(parcel)
-        parcel.recycle()
+        assumeTrue(SdkLevel.isAtLeastV())
 
-        // Initial setup state: Two profiles (Personal/Work), both enabled
-        whenever(mockUserManager.userProfiles) {
-            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, disabledSharingProfile)
-        }
-        whenever(mockUserManager.getUserProperties(disabledSharingProfile)) {
+        // Since the UserProperties here will return no delegation, this will
+        // have to rely on CrossProfileIntentForwarderActivity found for the managed
+        // user in order to enable cross profile for this profile.
+        // This is already setup in the base setup method.
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) @JvmSerializableLambda {
             UserProperties.Builder()
-                .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_NO)
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
+                )
                 .build()
         }
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                any(UserHandle::class.java),
+            )
+        ) {
+            emptyList<ResolveInfo>()
+        }
+
+        val expectedStatus =
+            UserStatus(
+                activeUserProfile = PRIMARY_PROFILE_BASE,
+                allProfiles =
+                    listOf(
+                        PRIMARY_PROFILE_BASE,
+                        MANAGED_PROFILE_BASE.copy(
+                            disabledReasons =
+                                setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                        ),
+                    ),
+                activeContentResolver = mockContentResolver,
+            )
 
         runTest { // this: TestScope
             userMonitor =
@@ -322,15 +605,40 @@ class UserMonitorTest {
 
             launch {
                 val reportedStatus = userMonitor.userStatus.first()
-                assertUserStatusIsEqualIgnoringFields(reportedStatus, initialExpectedStatus)
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
             }
         }
     }
 
-    /** Ensures that displayable content for a profile is fetched from the platform on V+ */
+    /** Ensures profiles without a cross profile forwarding intent are disabled */
     @Test
-    fun testProfileDisplayablesFromPlatformOnV() {
-        assumeTrue(SdkLevel.isAtLeastV())
+    fun testProfilesForCrossProfileIntentManagedDoesNotSupportUMinus() {
+
+        assumeFalse(SdkLevel.isAtLeastV())
+
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                any(UserHandle::class.java),
+            )
+        ) {
+            emptyList<ResolveInfo>()
+        }
+
+        val expectedStatus =
+            UserStatus(
+                activeUserProfile = PRIMARY_PROFILE_BASE,
+                allProfiles =
+                    listOf(
+                        PRIMARY_PROFILE_BASE,
+                        MANAGED_PROFILE_BASE.copy(
+                            disabledReasons =
+                                setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                        ),
+                    ),
+                activeContentResolver = mockContentResolver,
+            )
 
         runTest { // this: TestScope
             userMonitor =
@@ -351,11 +659,500 @@ class UserMonitorTest {
 
             launch {
                 val reportedStatus = userMonitor.userStatus.first()
-                // Just check the value isn't null, since the drawable gets converted to an
-                // ImageBitmap
-                assertThat(reportedStatus.activeUserProfile.icon).isNotNull()
-                assertThat(reportedStatus.activeUserProfile.label)
-                    .isEqualTo(PLATFORM_PROVIDED_PROFILE_LABEL)
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            }
+        }
+    }
+
+    @Test
+    fun testProfilesForCrossProfileMultipleManagedProfilesOneAllowedVPlus() {
+
+        assumeTrue(SdkLevel.isAtLeastV())
+
+        // Create a second managed profile, apparently that's a thing on some devices.
+        val userIdManagedUnknown = 11
+        val parcel1 = Parcel.obtain()
+        parcel1.writeInt(userIdManagedUnknown)
+        parcel1.setDataPosition(0)
+        val userHandleUnknownManaged = UserHandle(parcel1)
+        parcel1.recycle()
+
+        // Initial setup state: Three profiles (Personal/Work/Work???), all enabled
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, userHandleUnknownManaged)
+        }
+
+        // Default responses for relevant UserManager apis
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIMARY)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIMARY)) { false }
+
+        // Managed 1
+        whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { false }
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
+                )
+                .build()
+        }
+
+        // Managed 2
+        whenever(mockUserManager.isManagedProfile(userIdManagedUnknown)) { true }
+        whenever(mockUserManager.getProfileParent(userHandleUnknownManaged)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(userHandleUnknownManaged)) { false }
+
+        whenever(
+            mockUserManager.getUserProperties(userHandleUnknownManaged)
+        ) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
+                )
+                .build()
+        }
+
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                eq(USER_HANDLE_PRIMARY),
+            )
+        ) {
+            listOf(ReflectedResolveInfo(USER_HANDLE_MANAGED.getIdentifier()))
+        }
+
+        val unknownManagedProfileBase =
+            UserProfile(
+                handle = userHandleUnknownManaged,
+                profileType = UserProfile.ProfileType.MANAGED,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+                disabledReasons = setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED),
+            )
+
+        val expectedStatus =
+            UserStatus(
+                activeUserProfile = PRIMARY_PROFILE_BASE,
+                allProfiles =
+                    listOf(PRIMARY_PROFILE_BASE, MANAGED_PROFILE_BASE, unknownManagedProfileBase),
+                activeContentResolver = mockContentResolver,
+            )
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            }
+        }
+    }
+
+    @Test
+    fun testProfilesForCrossProfileMultipleManagedProfilesOneAllowedUMinus() {
+
+        assumeFalse(SdkLevel.isAtLeastV())
+
+        // Create a second managed profile, apparently that's a thing on some devices.
+        val userIdManagedUnknown = 11
+        val parcel1 = Parcel.obtain()
+        parcel1.writeInt(userIdManagedUnknown)
+        parcel1.setDataPosition(0)
+        val userHandleUnknownManaged = UserHandle(parcel1)
+        parcel1.recycle()
+
+        // Initial setup state: Three profiles (Personal/Work/Work???), all enabled
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, userHandleUnknownManaged)
+        }
+
+        // Default responses for relevant UserManager apis
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIMARY)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIMARY)) { false }
+
+        // Managed 1
+        whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { false }
+
+        // Managed 2
+        whenever(mockUserManager.isManagedProfile(userIdManagedUnknown)) { true }
+        whenever(mockUserManager.getProfileParent(userHandleUnknownManaged)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(userHandleUnknownManaged)) { false }
+
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                eq(USER_HANDLE_PRIMARY),
+            )
+        ) {
+            listOf(ReflectedResolveInfo(USER_HANDLE_MANAGED.getIdentifier()))
+        }
+
+        val unknownManagedProfileBase =
+            UserProfile(
+                handle = userHandleUnknownManaged,
+                profileType = UserProfile.ProfileType.MANAGED,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+                disabledReasons = setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED),
+            )
+
+        val expectedStatus =
+            UserStatus(
+                activeUserProfile = PRIMARY_PROFILE_BASE,
+                allProfiles =
+                    listOf(PRIMARY_PROFILE_BASE, MANAGED_PROFILE_BASE, unknownManagedProfileBase),
+                activeContentResolver = mockContentResolver,
+            )
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            }
+        }
+    }
+
+    @Test
+    fun testProfilesForCrossProfileMultipleManagedProfilesAllManagedDisabledVPlus() {
+
+        assumeTrue(SdkLevel.isAtLeastV())
+
+        // Create a second managed profile, apparently that's a thing on some devices.
+        val userIdManagedUnknown = 11
+        val parcel1 = Parcel.obtain()
+        parcel1.writeInt(userIdManagedUnknown)
+        parcel1.setDataPosition(0)
+        val userHandleUnknownManaged = UserHandle(parcel1)
+        parcel1.recycle()
+
+        // Initial setup state: Three profiles (Personal/Work/Work???), all enabled
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, userHandleUnknownManaged)
+        }
+
+        // Default responses for relevant UserManager apis
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIMARY)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIMARY)) { false }
+
+        // Managed 1
+        whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { false }
+
+        // Since the UserProperties here will return no delegation, this will
+        // have to rely on CrossProfileIntentForwarderActivity found for the managed
+        // user in order to enable cross profile for this profile.
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
+                )
+                .build()
+        }
+
+        // Managed 2
+        whenever(mockUserManager.isManagedProfile(userIdManagedUnknown)) { true }
+        whenever(mockUserManager.getProfileParent(userHandleUnknownManaged)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(userHandleUnknownManaged)) { false }
+        whenever(
+            mockUserManager.getUserProperties(userHandleUnknownManaged)
+        ) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setCrossProfileContentSharingStrategy(
+                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION
+                )
+                .build()
+        }
+
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                any(UserHandle::class.java),
+            )
+        ) {
+            emptyList<ResolveInfo>()
+        }
+
+        val unknownManagedProfileBase =
+            UserProfile(
+                handle = userHandleUnknownManaged,
+                profileType = UserProfile.ProfileType.MANAGED,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+                disabledReasons = setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED),
+            )
+
+        val expectedStatus =
+            UserStatus(
+                activeUserProfile = PRIMARY_PROFILE_BASE,
+                allProfiles =
+                    listOf(
+                        PRIMARY_PROFILE_BASE,
+                        MANAGED_PROFILE_BASE.copy(
+                            disabledReasons =
+                                setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                        ),
+                        unknownManagedProfileBase,
+                    ),
+                activeContentResolver = mockContentResolver,
+            )
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            }
+        }
+    }
+
+    @Test
+    fun testProfilesForCrossProfileMultipleManagedProfilesAllManagedDisabledUMinus() {
+
+        assumeFalse(SdkLevel.isAtLeastV())
+
+        // Create a second managed profile, apparently that's a thing on some devices.
+        val userIdManagedUnknown = 11
+        val parcel1 = Parcel.obtain()
+        parcel1.writeInt(userIdManagedUnknown)
+        parcel1.setDataPosition(0)
+        val userHandleUnknownManaged = UserHandle(parcel1)
+        parcel1.recycle()
+
+        // Initial setup state: Three profiles (Personal/Work/Work???), all enabled
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, userHandleUnknownManaged)
+        }
+
+        // Default responses for relevant UserManager apis
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIMARY)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIMARY)) { false }
+
+        // Managed 1
+        whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { false }
+
+        // Managed 2
+        whenever(mockUserManager.isManagedProfile(userIdManagedUnknown)) { true }
+        whenever(mockUserManager.getProfileParent(userHandleUnknownManaged)) { USER_HANDLE_PRIMARY }
+        whenever(mockUserManager.isQuietModeEnabled(userHandleUnknownManaged)) { false }
+
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                any(UserHandle::class.java),
+            )
+        ) {
+            emptyList<ResolveInfo>()
+        }
+
+        val unknownManagedProfileBase =
+            UserProfile(
+                handle = userHandleUnknownManaged,
+                profileType = UserProfile.ProfileType.MANAGED,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+                disabledReasons = setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED),
+            )
+
+        val expectedStatus =
+            UserStatus(
+                activeUserProfile = PRIMARY_PROFILE_BASE,
+                allProfiles =
+                    listOf(
+                        PRIMARY_PROFILE_BASE,
+                        MANAGED_PROFILE_BASE.copy(
+                            disabledReasons =
+                                setOf(UserProfile.DisabledReason.CROSS_PROFILE_NOT_ALLOWED)
+                        ),
+                        unknownManagedProfileBase,
+                    ),
+                activeContentResolver = mockContentResolver,
+            )
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, expectedStatus)
+            }
+        }
+    }
+
+    /**
+     * Ensures that profiles that explicitly request not to be shown in sharing surfaces are not
+     * included
+     */
+    @Test
+    fun testIgnoresSharingDisabledProfiles() {
+        assumeTrue(SdkLevel.isAtLeastV())
+
+        val parcel = Parcel.obtain()
+        parcel.writeInt(100)
+        parcel.setDataPosition(0)
+        val disabledSharingProfile = UserHandle(parcel)
+        parcel.recycle()
+
+        // Initial setup state: Two profiles (Personal/Work), both enabled
+        whenever(mockUserManager.userProfiles) {
+            listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED, disabledSharingProfile)
+        }
+        whenever(mockUserManager.getUserProperties(disabledSharingProfile)) @JvmSerializableLambda {
+            UserProperties.Builder()
+                .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_NO)
+                .build()
+        }
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                assertUserStatusIsEqualIgnoringFields(reportedStatus, initialExpectedStatus)
+            }
+        }
+    }
+
+    /** Ensures that displayable content for a profile is fetched from the platform on V+ */
+    @Test
+    fun testProfileDisplayablesFromPlatformOnV() {
+        assumeTrue(SdkLevel.isAtLeastV())
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                // Just check the value isn't null, since the drawable gets converted to an
+                // ImageBitmap
+                assertThat(reportedStatus.activeUserProfile.icon).isNotNull()
+                assertThat(reportedStatus.activeUserProfile.label)
+                    .isEqualTo(PLATFORM_PROVIDED_PROFILE_LABEL)
+            }
+        }
+    }
+
+    /** Ensures that displayable content for a profile is fetched from the platform on V+ */
+    @Test
+    fun testProfileMisconfigured() {
+
+        whenever(mockContext.createContextAsUser(any(UserHandle::class.java), anyInt())) {
+            throw IllegalStateException("Profile is misconfigured!")
+        }
+
+        runTest { // this: TestScope
+            userMonitor =
+                UserMonitor(
+                    mockContext,
+                    provideTestConfigurationFlow(
+                        scope = this.backgroundScope,
+                        defaultConfiguration =
+                            TestPhotopickerConfiguration.build {
+                                action(MediaStore.ACTION_PICK_IMAGES)
+                                intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                            },
+                    ),
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    USER_HANDLE_PRIMARY,
+                )
+
+            launch {
+                val reportedStatus = userMonitor.userStatus.first()
+                assertThat(reportedStatus.activeUserProfile.icon).isNull()
+                assertThat(reportedStatus.activeUserProfile.label).isNull()
             }
         }
     }
@@ -875,7 +1672,7 @@ class UserMonitorTest {
         assumeTrue(SdkLevel.isAtLeastV())
 
         whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { true }
-        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) {
+        whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED)) @JvmSerializableLambda {
             UserProperties.Builder().setShowInQuietMode(SHOW_IN_QUIET_MODE_HIDDEN).build()
         }
 
diff --git a/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt b/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt
index d74cc8f7e..49540e5e4 100644
--- a/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt
@@ -76,8 +76,6 @@ import org.mockito.Mockito.verify
 @OptIn(ExperimentalCoroutinesApi::class)
 class DataServiceImplTest {
 
-    val testSessionId = generatePickerSessionId()
-
     companion object {
         private fun createUserHandle(userId: Int = 0): UserHandle {
             val parcel = Parcel.obtain()
@@ -191,7 +189,7 @@ class DataServiceImplTest {
                     defaultConfiguration =
                         PhotopickerConfiguration(
                             action = "TEST_ACTION",
-                            sessionId = testSessionId,
+                            sessionId = sessionId,
                             flags =
                                 PhotopickerFlags(
                                     CLOUD_MEDIA_ENABLED = true,
@@ -219,7 +217,7 @@ class DataServiceImplTest {
                         defaultConfiguration =
                             PhotopickerConfiguration(
                                 action = "TEST_ACTION",
-                                sessionId = testSessionId,
+                                sessionId = sessionId,
                                 flags =
                                     PhotopickerFlags(
                                         CLOUD_MEDIA_ENABLED = true,
@@ -358,7 +356,7 @@ class DataServiceImplTest {
                     defaultConfiguration =
                         PhotopickerConfiguration(
                             action = "TEST_ACTION",
-                            sessionId = testSessionId,
+                            sessionId = sessionId,
                             flags =
                                 PhotopickerFlags(
                                     CLOUD_MEDIA_ENABLED = true,
@@ -385,7 +383,7 @@ class DataServiceImplTest {
                         this.backgroundScope,
                         PhotopickerConfiguration(
                             action = "TEST_ACTION",
-                            sessionId = testSessionId,
+                            sessionId = sessionId,
                             flags =
                                 PhotopickerFlags(
                                     CLOUD_MEDIA_ENABLED = true,
@@ -1052,7 +1050,7 @@ class DataServiceImplTest {
                     defaultConfiguration =
                         PhotopickerConfiguration(
                             action = "TEST_ACTION",
-                            sessionId = testSessionId,
+                            sessionId = sessionId,
                             flags =
                                 PhotopickerFlags(
                                     CLOUD_MEDIA_ENABLED = true,
@@ -1080,7 +1078,7 @@ class DataServiceImplTest {
                         defaultConfiguration =
                             PhotopickerConfiguration(
                                 action = "TEST_ACTION",
-                                sessionId = testSessionId,
+                                sessionId = sessionId,
                                 flags =
                                     PhotopickerFlags(
                                         CLOUD_MEDIA_ENABLED = true,
diff --git a/photopicker/tests/src/com/android/photopicker/data/PrefetchDataServiceImplTest.kt b/photopicker/tests/src/com/android/photopicker/data/PrefetchDataServiceImplTest.kt
new file mode 100644
index 000000000..48d882ac5
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/data/PrefetchDataServiceImplTest.kt
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package src.com.android.photopicker.data
+
+import android.content.ContentResolver
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.content.pm.ResolveInfo
+import android.content.pm.UserProperties
+import android.os.Parcel
+import android.os.UserHandle
+import android.os.UserManager
+import android.provider.MediaStore
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import androidx.test.platform.app.InstrumentationRegistry
+import com.android.modules.utils.build.SdkLevel
+import com.android.photopicker.R
+import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
+import com.android.photopicker.core.configuration.provideTestConfigurationFlow
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.core.user.UserProfile
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.PrefetchDataServiceImpl
+import com.android.photopicker.data.TestMediaProvider
+import com.android.photopicker.features.search.model.GlobalSearchState
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
+import com.google.common.truth.Truth.assertWithMessage
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mock
+import org.mockito.Mockito.any
+import org.mockito.Mockito.anyInt
+import org.mockito.MockitoAnnotations
+
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@OptIn(ExperimentalCoroutinesApi::class)
+public class PrefetchDataServiceImplTest {
+    @Mock private lateinit var mockPrimaryUserContext: Context
+    @Mock private lateinit var mockManagedUserContext: Context
+    @Mock private lateinit var mockUserManager: UserManager
+    @Mock private lateinit var mockPackageManager: PackageManager
+    @Mock private lateinit var mockResolveInfo: ResolveInfo
+
+    private lateinit var testPrimaryUserContentProvider: TestMediaProvider
+    private lateinit var testManagedUserContentProvider: TestMediaProvider
+    private lateinit var testPrimaryUserContentResolver: ContentResolver
+    private lateinit var testManagedUserContentResolver: ContentResolver
+
+    private val PLATFORM_PROVIDED_PROFILE_LABEL = "Platform Label"
+
+    private val USER_HANDLE_PRIMARY: UserHandle
+    private val USER_ID_PRIMARY: Int = 0
+    private val PRIMARY_PROFILE_BASE: UserProfile
+
+    private val USER_HANDLE_MANAGED: UserHandle
+    private val USER_ID_MANAGED: Int = 10
+    private val MANAGED_PROFILE_BASE: UserProfile
+
+    init {
+        val parcel1 = Parcel.obtain()
+        parcel1.writeInt(USER_ID_PRIMARY)
+        parcel1.setDataPosition(0)
+        USER_HANDLE_PRIMARY = UserHandle(parcel1)
+        parcel1.recycle()
+
+        PRIMARY_PROFILE_BASE =
+            UserProfile(
+                handle = USER_HANDLE_PRIMARY,
+                profileType = UserProfile.ProfileType.PRIMARY,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+            )
+
+        val parcel2 = Parcel.obtain()
+        parcel2.writeInt(USER_ID_MANAGED)
+        parcel2.setDataPosition(0)
+        USER_HANDLE_MANAGED = UserHandle(parcel2)
+        parcel2.recycle()
+
+        MANAGED_PROFILE_BASE =
+            UserProfile(
+                handle = USER_HANDLE_MANAGED,
+                profileType = UserProfile.ProfileType.MANAGED,
+                label = PLATFORM_PROVIDED_PROFILE_LABEL,
+            )
+    }
+
+    @Before
+    fun setup() {
+        MockitoAnnotations.initMocks(this)
+        val resources = InstrumentationRegistry.getInstrumentation().getContext().getResources()
+
+        testPrimaryUserContentProvider = TestMediaProvider()
+        testPrimaryUserContentResolver = ContentResolver.wrap(testPrimaryUserContentProvider)
+        testManagedUserContentProvider = TestMediaProvider()
+        testManagedUserContentResolver = ContentResolver.wrap(testManagedUserContentProvider)
+
+        mockSystemService(mockPrimaryUserContext, UserManager::class.java) { mockUserManager }
+        mockSystemService(mockManagedUserContext, UserManager::class.java) { mockUserManager }
+
+        whenever(mockPrimaryUserContext.packageManager) { mockPackageManager }
+        whenever(mockPrimaryUserContext.contentResolver) { testPrimaryUserContentResolver }
+        whenever(mockManagedUserContext.contentResolver) { testManagedUserContentResolver }
+        whenever(
+            mockPrimaryUserContext.createPackageContextAsUser(
+                any(),
+                anyInt(),
+                nonNullableEq(USER_HANDLE_PRIMARY),
+            )
+        ) {
+            mockPrimaryUserContext
+        }
+        whenever(
+            mockPrimaryUserContext.createPackageContextAsUser(
+                any(),
+                anyInt(),
+                nonNullableEq(USER_HANDLE_MANAGED),
+            )
+        ) {
+            mockManagedUserContext
+        }
+        whenever(
+            mockManagedUserContext.createPackageContextAsUser(
+                any(),
+                anyInt(),
+                nonNullableEq(USER_HANDLE_PRIMARY),
+            )
+        ) {
+            mockPrimaryUserContext
+        }
+        whenever(
+            mockManagedUserContext.createPackageContextAsUser(
+                any(),
+                anyInt(),
+                nonNullableEq(USER_HANDLE_MANAGED),
+            )
+        ) {
+            mockManagedUserContext
+        }
+        whenever(
+            mockPrimaryUserContext.createContextAsUser(nonNullableEq(USER_HANDLE_PRIMARY), anyInt())
+        ) {
+            mockPrimaryUserContext
+        }
+        whenever(
+            mockPrimaryUserContext.createContextAsUser(nonNullableEq(USER_HANDLE_MANAGED), anyInt())
+        ) {
+            mockManagedUserContext
+        }
+        whenever(
+            mockManagedUserContext.createContextAsUser(nonNullableEq(USER_HANDLE_PRIMARY), anyInt())
+        ) {
+            mockPrimaryUserContext
+        }
+        whenever(
+            mockManagedUserContext.createContextAsUser(nonNullableEq(USER_HANDLE_MANAGED), anyInt())
+        ) {
+            mockManagedUserContext
+        }
+
+        // Initial setup state: Two profiles (Personal/Work), both enabled
+        whenever(mockUserManager.userProfiles) { listOf(USER_HANDLE_PRIMARY, USER_HANDLE_MANAGED) }
+
+        // Default responses for relevant UserManager apis
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_PRIMARY)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_PRIMARY)) { false }
+        whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { false }
+        whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
+        whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
+
+        whenever(mockResolveInfo.isCrossProfileIntentForwarderActivity()) { true }
+        whenever(mockPackageManager.queryIntentActivities(any(Intent::class.java), anyInt())) {
+            listOf(mockResolveInfo)
+        }
+
+        if (SdkLevel.isAtLeastV()) {
+            whenever(mockUserManager.getUserBadge()) {
+                resources.getDrawable(R.drawable.android, /* theme= */ null)
+            }
+            whenever(mockUserManager.getProfileLabel()) { PLATFORM_PROVIDED_PROFILE_LABEL }
+            whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIMARY))
+            @JvmSerializableLambda {
+                UserProperties.Builder().build()
+            }
+            // By default, allow managed profile to be available
+            whenever(mockUserManager.getUserProperties(USER_HANDLE_MANAGED))
+            @JvmSerializableLambda {
+                UserProperties.Builder()
+                    .setCrossProfileContentSharingStrategy(
+                        UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
+                    )
+                    .build()
+            }
+        }
+    }
+
+    @Test
+    fun testGetGlobalSearchStateEnabled() = runTest {
+        testManagedUserContentProvider.searchProviders = listOf()
+
+        val userMonitor =
+            UserMonitor(
+                mockPrimaryUserContext,
+                provideTestConfigurationFlow(
+                    scope = this.backgroundScope,
+                    defaultConfiguration =
+                        TestPhotopickerConfiguration.build {
+                            action(MediaStore.ACTION_PICK_IMAGES)
+                            intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                        },
+                ),
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                USER_HANDLE_PRIMARY,
+            )
+
+        val prefetchDataService =
+            PrefetchDataServiceImpl(
+                MediaProviderClient(),
+                userMonitor,
+                mockPrimaryUserContext,
+                StandardTestDispatcher(this.testScheduler),
+                backgroundScope,
+            )
+
+        val globalSearchState = prefetchDataService.getGlobalSearchState()
+
+        assertWithMessage("Global search state is not enabled")
+            .that(globalSearchState)
+            .isEqualTo(GlobalSearchState.ENABLED)
+    }
+
+    @Test
+    fun testGetGlobalSearchStateEnabledInOtherProfiles() = runTest {
+        val userMonitor =
+            UserMonitor(
+                mockPrimaryUserContext,
+                provideTestConfigurationFlow(
+                    scope = this.backgroundScope,
+                    defaultConfiguration =
+                        TestPhotopickerConfiguration.build {
+                            action(MediaStore.ACTION_PICK_IMAGES)
+                            intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                        },
+                ),
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                USER_HANDLE_PRIMARY,
+            )
+
+        val prefetchDataService =
+            PrefetchDataServiceImpl(
+                MediaProviderClient(),
+                userMonitor,
+                mockPrimaryUserContext,
+                StandardTestDispatcher(this.testScheduler),
+                backgroundScope,
+            )
+
+        testPrimaryUserContentProvider.searchProviders = listOf()
+        val globalSearchState1 = prefetchDataService.getGlobalSearchState()
+        assertWithMessage("Global search state is not enabled in other profiles")
+            .that(globalSearchState1)
+            .isEqualTo(GlobalSearchState.ENABLED_IN_OTHER_PROFILES_ONLY)
+
+        testPrimaryUserContentProvider.searchProviders = null
+        val globalSearchState2 = prefetchDataService.getGlobalSearchState()
+        assertWithMessage("Global search state is not enabled in other profiles")
+            .that(globalSearchState2)
+            .isEqualTo(GlobalSearchState.ENABLED_IN_OTHER_PROFILES_ONLY)
+    }
+
+    @Test
+    fun testGetGlobalSearchStateUnknown() = runTest {
+        val userMonitor =
+            UserMonitor(
+                mockPrimaryUserContext,
+                provideTestConfigurationFlow(
+                    scope = this.backgroundScope,
+                    defaultConfiguration =
+                        TestPhotopickerConfiguration.build {
+                            action(MediaStore.ACTION_PICK_IMAGES)
+                            intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                        },
+                ),
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                USER_HANDLE_PRIMARY,
+            )
+
+        val prefetchDataService =
+            PrefetchDataServiceImpl(
+                MediaProviderClient(),
+                userMonitor,
+                mockPrimaryUserContext,
+                StandardTestDispatcher(this.testScheduler),
+                backgroundScope,
+            )
+
+        testPrimaryUserContentProvider.searchProviders = listOf()
+        testManagedUserContentProvider.searchProviders = null
+        val globalSearchState = prefetchDataService.getGlobalSearchState()
+
+        assertWithMessage("Global search state is not enabled in other profiles")
+            .that(globalSearchState)
+            .isEqualTo(GlobalSearchState.UNKNOWN)
+    }
+
+    @Test
+    fun testGetGlobalSearchStateDisabled() = runTest {
+        testPrimaryUserContentProvider.searchProviders = listOf()
+        testManagedUserContentProvider.searchProviders = listOf()
+
+        val userMonitor =
+            UserMonitor(
+                mockPrimaryUserContext,
+                provideTestConfigurationFlow(
+                    scope = this.backgroundScope,
+                    defaultConfiguration =
+                        TestPhotopickerConfiguration.build {
+                            action(MediaStore.ACTION_PICK_IMAGES)
+                            intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                        },
+                ),
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                USER_HANDLE_PRIMARY,
+            )
+
+        val prefetchDataService =
+            PrefetchDataServiceImpl(
+                MediaProviderClient(),
+                userMonitor,
+                mockPrimaryUserContext,
+                StandardTestDispatcher(this.testScheduler),
+                backgroundScope,
+            )
+
+        val globalSearchState = prefetchDataService.getGlobalSearchState()
+
+        assertWithMessage("Global search state is not enabled in other profiles")
+            .that(globalSearchState)
+            .isEqualTo(GlobalSearchState.DISABLED)
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt b/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt
index 9c5d5fe01..830a8b3ec 100644
--- a/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt
@@ -23,11 +23,15 @@ import android.os.Bundle
 import android.os.CancellationSignal
 import android.test.mock.MockContentProvider
 import androidx.core.os.bundleOf
+import com.android.photopicker.data.model.CategoryType
 import com.android.photopicker.data.model.CollectionInfo
 import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Icon
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
 import java.util.UUID
 import java.util.stream.Collectors
 
@@ -76,6 +80,45 @@ val DEFAULT_ALBUM_MEDIA: Map<String, List<Media>> = mapOf(DEFAULT_ALBUM_NAME to
 
 val DEFAULT_SEARCH_REQUEST_ID: Int = 100
 
+val DEFAULT_SEARCH_SUGGESTIONS: List<SearchSuggestion> =
+    listOf(
+        SearchSuggestion(
+            mediaSetId = null,
+            authority = null,
+            type = SearchSuggestionType.HISTORY,
+            displayText = "Text",
+            icon = null,
+        ),
+        SearchSuggestion(
+            mediaSetId = "media-set-id-1",
+            authority = "cloud.provider",
+            type = SearchSuggestionType.FACE,
+            displayText = null,
+            icon = Icon(Uri.parse("content://cloud.provider/1234"), MediaSource.LOCAL),
+        ),
+        SearchSuggestion(
+            mediaSetId = "media-set-id-1",
+            authority = "local-provider",
+            type = SearchSuggestionType.TEXT,
+            displayText = "Text",
+            icon = null,
+        ),
+    )
+
+val DEFAULT_CATEGORY: Group.Category =
+    createCategory(CategoryType.PEOPLE_AND_PETS, DEFAULT_PROVIDERS[0].authority)
+
+val DEFAULT_CATEGORIES_AND_ALBUMS: List<Group> =
+    listOf(
+        createAlbum("Favorites"),
+        createAlbum("Downloads"),
+        DEFAULT_CATEGORY,
+        createAlbum("CloudAlbum"),
+    )
+
+val DEFAULT_MEDIA_SETS: List<Group.MediaSet> =
+    listOf(createMediaSet("1"), createMediaSet("2"), createMediaSet("3"))
+
 fun createMediaImage(pickerId: Long): Media {
     return Media.Image(
         mediaId = UUID.randomUUID().toString(),
@@ -95,11 +138,33 @@ fun createAlbum(albumId: String): Group.Album {
     return Group.Album(
         id = albumId,
         pickerId = albumId.hashCode().toLong(),
-        authority = "authority",
+        authority = DEFAULT_PROVIDERS[0].authority,
         dateTakenMillisLong = Long.MAX_VALUE,
         displayName = albumId,
-        coverUri = Uri.parse("content://media/picker/authority/media/$albumId"),
-        coverMediaSource = MediaSource.LOCAL,
+        coverUri = Uri.parse("content://test_authority/$albumId"),
+        coverMediaSource = DEFAULT_PROVIDERS[0].mediaSource,
+    )
+}
+
+fun createCategory(type: CategoryType, authority: String): Group.Category {
+    return Group.Category(
+        id = "test_id_" + type.name,
+        pickerId = 0,
+        authority = authority,
+        displayName = type.name,
+        categoryType = type,
+        icons = listOf(Icon(Uri.parse("content://test_authority/id"), MediaSource.LOCAL)),
+        isLeafCategory = true,
+    )
+}
+
+fun createMediaSet(mediaSetId: String): Group.MediaSet {
+    return Group.MediaSet(
+        id = mediaSetId,
+        pickerId = mediaSetId.hashCode().toLong(),
+        authority = DEFAULT_PROVIDERS[0].authority,
+        displayName = mediaSetId,
+        icon = Icon(Uri.parse("content://test_authority/$mediaSetId"), MediaSource.LOCAL),
     )
 }
 
@@ -110,6 +175,11 @@ class TestMediaProvider(
     var albums: List<Group.Album> = DEFAULT_ALBUMS,
     var albumMedia: Map<String, List<Media>> = DEFAULT_ALBUM_MEDIA,
     var searchRequestId: Int = DEFAULT_SEARCH_REQUEST_ID,
+    var searchSuggestions: List<SearchSuggestion> = DEFAULT_SEARCH_SUGGESTIONS,
+    var searchProviders: List<Provider>? = DEFAULT_PROVIDERS,
+    var parentCategory: Group.Category = DEFAULT_CATEGORY,
+    var categoriesAndAlbums: List<Group> = DEFAULT_CATEGORIES_AND_ALBUMS,
+    var mediaSets: List<Group.MediaSet> = DEFAULT_MEDIA_SETS,
 ) : MockContentProvider() {
     var lastRefreshMediaRequest: Bundle? = null
     var TEST_GRANTS_COUNT = 2
@@ -121,18 +191,24 @@ class TestMediaProvider(
         cancellationSignal: CancellationSignal?,
     ): Cursor? {
         return when (uri.lastPathSegment) {
-            "available_providers" -> getAvailableProviders()
-            "collection_info" -> getCollectionInfo()
-            "media" -> getMedia()
-            "album" -> getAlbums()
-            "media_grants_count" -> fetchMediaGrantsCount()
-            "pre_selection" -> fetchFilteredMedia(queryArgs)
+            AVAILABLE_PROVIDERS_PATH_SEGMENT -> getAvailableProviders()
+            COLLECTION_INFO_SEGMENT -> getCollectionInfo()
+            MEDIA_PATH_SEGMENT -> getMedia()
+            ALBUM_PATH_SEGMENT -> getAlbums()
+            MEDIA_GRANTS_COUNT_PATH_SEGMENT -> fetchMediaGrantsCount()
+            PRE_SELECTION_URI_PATH_SEGMENT -> fetchFilteredMedia(queryArgs)
+            SEARCH_SUGGESTIONS_PATH_SEGMENT -> getSearchSuggestions()
+            CATEGORIES_PATH_SEGMENT -> getCategoriesAndAlbums()
+            MEDIA_SETS_PATH_SEGMENT -> getMediaSets()
+            MEDIA_SET_CONTENTS_PATH_SEGMENT -> getMedia()
             else -> {
                 val pathSegments: MutableList<String> = uri.getPathSegments()
-                if (pathSegments.size == 4 && pathSegments[2].equals("album")) {
+                if (pathSegments.size == 4 && pathSegments[2].equals(ALBUM_PATH_SEGMENT)) {
                     // Album media query
                     return getAlbumMedia(pathSegments[3])
-                } else if (pathSegments.size == 4 && pathSegments[2].equals("search_media")) {
+                } else if (
+                    pathSegments.size == 4 && pathSegments[2].equals(SEARCH_MEDIA_PATH_SEGMENT)
+                ) {
                     // Search results media query
                     return getMedia()
                 } else {
@@ -144,13 +220,22 @@ class TestMediaProvider(
 
     override fun call(authority: String, method: String, arg: String?, extras: Bundle?): Bundle? {
         return when (method) {
-            "picker_media_init" -> {
+            MediaProviderClient.MEDIA_INIT_CALL_METHOD -> {
                 initMedia(extras)
                 null
             }
-            "picker_internal_search_media_init" -> {
+            MediaProviderClient.SEARCH_REQUEST_INIT_CALL_METHOD -> {
                 bundleOf(MediaProviderClient.SEARCH_REQUEST_ID to searchRequestId)
             }
+            MediaProviderClient.GET_SEARCH_PROVIDERS_CALL_METHOD ->
+                bundleOf(
+                    MediaProviderClient.SEARCH_PROVIDER_AUTHORITIES to
+                        if (searchProviders == null) null
+                        else
+                            arrayListOf<String>().apply {
+                                searchProviders?.map { it.authority }?.toCollection(this)
+                            }
+                )
             else -> throw UnsupportedOperationException("Could not recognize method $method")
         }
     }
@@ -334,4 +419,112 @@ class TestMediaProvider(
     private fun initMedia(extras: Bundle?) {
         lastRefreshMediaRequest = extras
     }
+
+    private fun getSearchSuggestions(): Cursor {
+        val cursor =
+            MatrixCursor(
+                arrayOf(
+                    MediaProviderClient.SearchSuggestionsResponse.AUTHORITY.key,
+                    MediaProviderClient.SearchSuggestionsResponse.MEDIA_SET_ID.key,
+                    MediaProviderClient.SearchSuggestionsResponse.SEARCH_TEXT.key,
+                    MediaProviderClient.SearchSuggestionsResponse.COVER_MEDIA_URI.key,
+                    MediaProviderClient.SearchSuggestionsResponse.SUGGESTION_TYPE.key,
+                )
+            )
+
+        searchSuggestions.forEach { suggestion ->
+            cursor.addRow(
+                arrayOf(
+                    suggestion.authority,
+                    suggestion.mediaSetId,
+                    suggestion.displayText,
+                    suggestion.icon,
+                    suggestion.type.key,
+                )
+            )
+        }
+        return cursor
+    }
+
+    private fun getCategoriesAndAlbums(): Cursor {
+        val cursor =
+            MatrixCursor(
+                arrayOf(
+                    MediaProviderClient.GroupResponse.MEDIA_GROUP.key,
+                    MediaProviderClient.GroupResponse.GROUP_ID.key,
+                    MediaProviderClient.GroupResponse.PICKER_ID.key,
+                    MediaProviderClient.GroupResponse.DISPLAY_NAME.key,
+                    MediaProviderClient.GroupResponse.AUTHORITY.key,
+                    MediaProviderClient.GroupResponse.UNWRAPPED_COVER_URI.key,
+                    MediaProviderClient.GroupResponse.ADDITIONAL_UNWRAPPED_COVER_URI_1.key,
+                    MediaProviderClient.GroupResponse.ADDITIONAL_UNWRAPPED_COVER_URI_2.key,
+                    MediaProviderClient.GroupResponse.ADDITIONAL_UNWRAPPED_COVER_URI_3.key,
+                    MediaProviderClient.GroupResponse.CATEGORY_TYPE.key,
+                    MediaProviderClient.GroupResponse.IS_LEAF_CATEGORY.key,
+                )
+            )
+        categoriesAndAlbums.forEach { group ->
+            when (group) {
+                is Group.Album ->
+                    cursor.addRow(
+                        arrayOf(
+                            MediaProviderClient.GroupType.ALBUM.name,
+                            group.id,
+                            group.pickerId.toString(),
+                            group.displayName,
+                            group.authority,
+                            group.coverUri.toString(),
+                            /* additional uri */ null,
+                            /* additional uri */ null,
+                            /* additional uri */ null,
+                            /* category type */ null,
+                            /* is leaf category */ null,
+                        )
+                    )
+                is Group.Category ->
+                    cursor.addRow(
+                        arrayOf(
+                            MediaProviderClient.GroupType.CATEGORY.name,
+                            group.id,
+                            group.pickerId.toString(),
+                            group.displayName,
+                            group.authority,
+                            group.icons.getOrNull(0)?.getLoadableUri()?.toString(),
+                            group.icons.getOrNull(1)?.getLoadableUri()?.toString(),
+                            group.icons.getOrNull(2)?.getLoadableUri()?.toString(),
+                            group.icons.getOrNull(3)?.getLoadableUri()?.toString(),
+                            group.categoryType.key,
+                            if (group.isLeafCategory) 1 else null,
+                        )
+                    )
+                else -> {}
+            }
+        }
+        return cursor
+    }
+
+    private fun getMediaSets(): Cursor {
+        val cursor =
+            MatrixCursor(
+                arrayOf(
+                    MediaProviderClient.GroupResponse.GROUP_ID.key,
+                    MediaProviderClient.GroupResponse.PICKER_ID.key,
+                    MediaProviderClient.GroupResponse.DISPLAY_NAME.key,
+                    MediaProviderClient.GroupResponse.AUTHORITY.key,
+                    MediaProviderClient.GroupResponse.UNWRAPPED_COVER_URI.key,
+                )
+            )
+        mediaSets.forEach {
+            cursor.addRow(
+                arrayOf(
+                    it.id,
+                    it.pickerId.toString(),
+                    it.displayName,
+                    it.authority,
+                    it.icon.getLoadableUri().toString(),
+                )
+            )
+        }
+        return cursor
+    }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt b/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt
index c66d25635..a9c377cc5 100644
--- a/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt
@@ -16,12 +16,12 @@
 
 package com.android.photopicker.data
 
-import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.GlobalSearchState
 
 class TestPrefetchDataService() : PrefetchDataService {
-    var searchEnabledState = SearchEnabledState.ENABLED
+    var globalSearchState = GlobalSearchState.ENABLED
 
-    override suspend fun getSearchState(): SearchEnabledState {
-        return searchEnabledState
+    override suspend fun getGlobalSearchState(): GlobalSearchState {
+        return globalSearchState
     }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/data/model/GroupTest.kt b/photopicker/tests/src/com/android/photopicker/data/model/GroupTest.kt
new file mode 100644
index 000000000..e9d256c48
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/data/model/GroupTest.kt
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package src.com.android.photopicker.data.model
+
+import android.net.Uri
+import android.os.Parcel
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import com.android.photopicker.data.model.CategoryType
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Icon
+import com.android.photopicker.data.model.MediaSource
+import com.google.common.truth.Truth.assertWithMessage
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/** Unit tests for the [Group] data models */
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+class GroupTest {
+    /** Write to parcel as a [Group.Album], read back as a [Group.Album] */
+    @Test
+    fun testGroupAlbumIsParcelable() {
+        val testAlbum =
+            Group.Album(
+                id = "album_id",
+                pickerId = 123456789L,
+                authority = "authority",
+                dateTakenMillisLong = 123456789L,
+                displayName = "album name",
+                coverMediaSource = MediaSource.LOCAL,
+                coverUri =
+                    Uri.EMPTY.buildUpon()
+                        .apply {
+                            scheme("content")
+                            authority("authority")
+                            path("image_id")
+                        }
+                        .build(),
+            )
+
+        val parcel = Parcel.obtain()
+        testAlbum.writeToParcel(parcel, /* flags= */ 0)
+        parcel.setDataPosition(0)
+
+        // Unmarshall the parcel and compare the result to the original to ensure they are the same.
+        val resultAlbum = Group.Album.createFromParcel(parcel)
+        assertWithMessage("Album was different when parcelled")
+            .that(resultAlbum)
+            .isEqualTo(testAlbum)
+
+        parcel.recycle()
+    }
+
+    /** Write to parcel as a [Group.Category], read back as a [Group.Category] */
+    @Test
+    fun testGroupCategoryIsParcelable() {
+        val testCategory =
+            Group.Category(
+                id = "category_id",
+                pickerId = 123456789L,
+                authority = "authority",
+                displayName = "category name",
+                categoryType = CategoryType.PEOPLE_AND_PETS,
+                icons =
+                    listOf(
+                        Icon(
+                            uri =
+                                Uri.EMPTY.buildUpon()
+                                    .apply {
+                                        scheme("content")
+                                        authority("authority")
+                                        path("image1")
+                                    }
+                                    .build(),
+                            mediaSource = MediaSource.LOCAL,
+                        ),
+                        Icon(
+                            uri =
+                                Uri.EMPTY.buildUpon()
+                                    .apply {
+                                        scheme("content")
+                                        authority("authority")
+                                        path("image2")
+                                    }
+                                    .build(),
+                            mediaSource = MediaSource.REMOTE,
+                        ),
+                    ),
+                isLeafCategory = true,
+            )
+
+        val parcel = Parcel.obtain()
+        testCategory.writeToParcel(parcel, /* flags= */ 0)
+        parcel.setDataPosition(0)
+
+        // Unmarshall the parcel and compare the result to the original to ensure they are the same.
+        val resultCategory = Group.Category.createFromParcel(parcel)
+        assertWithMessage("Category was different when parcelled")
+            .that(resultCategory)
+            .isEqualTo(testCategory)
+
+        parcel.recycle()
+    }
+
+    /** Write to parcel as a [Group.MediaSet], read back as a [Group.MediaSet] */
+    @Test
+    fun testGroupMediaSetIsParcelable() {
+        val testMediaSet =
+            Group.MediaSet(
+                id = "media_set_id",
+                pickerId = 123456789L,
+                authority = "authority",
+                displayName = "media set name",
+                icon =
+                    Icon(
+                        uri =
+                            Uri.EMPTY.buildUpon()
+                                .apply {
+                                    scheme("content")
+                                    authority("authority")
+                                    path("image1")
+                                }
+                                .build(),
+                        mediaSource = MediaSource.LOCAL,
+                    ),
+            )
+
+        val parcel = Parcel.obtain()
+        testMediaSet.writeToParcel(parcel, /* flags= */ 0)
+        parcel.setDataPosition(0)
+
+        // Unmarshall the parcel and compare the result to the original to ensure they are the same.
+        val resultMediaSet = Group.MediaSet.createFromParcel(parcel)
+        assertWithMessage("Media Set was different when parcelled")
+            .that(resultMediaSet)
+            .isEqualTo(testMediaSet)
+
+        parcel.recycle()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt
index 888555d20..8ee41953d 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt
@@ -32,6 +32,7 @@ import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
 import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.data.paging.AlbumPagingSource
 import kotlinx.coroutines.ExperimentalCoroutinesApi
@@ -54,7 +55,15 @@ class AlbumPagingSourceTest {
     private val testSessionId = generatePickerSessionId()
     private val testContentProvider: TestMediaProvider = TestMediaProvider()
     private val contentResolver: ContentResolver = ContentResolver.wrap(testContentProvider)
-    private val availableProviders: List<Provider> = emptyList()
+    private val availableProviders: List<Provider> =
+        listOf(
+            Provider(
+                authority = "local_authority",
+                mediaSource = MediaSource.LOCAL,
+                uid = 1,
+                displayName = "Local Provider",
+            )
+        )
     private val testPhotopickerConfiguration: PhotopickerConfiguration =
         PhotopickerConfiguration(
             action = MediaStore.ACTION_PICK_IMAGES,
@@ -112,7 +121,7 @@ class AlbumPagingSourceTest {
                 pageKey,
                 pageSize,
                 contentResolver,
-                emptyList(),
+                availableProviders,
                 testPhotopickerConfiguration,
             )
     }
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryCategoryPagingSource.kt b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryCategoryPagingSource.kt
new file mode 100644
index 000000000..528e215fc
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryCategoryPagingSource.kt
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data.paging
+
+import android.net.Uri
+import androidx.paging.PagingSource
+import androidx.paging.PagingSource.LoadParams
+import androidx.paging.PagingSource.LoadResult
+import androidx.paging.PagingState
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.MediaSource
+import java.time.LocalDateTime
+import java.time.ZoneOffset
+import java.time.temporal.ChronoUnit
+
+/**
+ * This [FakeInMemoryCategoryPagingSource] class is responsible to providing paginated data.
+ *
+ * It generates and returns its own fake data.
+ */
+class FakeInMemoryCategoryPagingSource
+private constructor(val DATA_SIZE: Int = DEFAULT_SIZE, private val DATA_LIST: List<Group>? = null) :
+    PagingSource<GroupPageKey, Group>() {
+
+    companion object {
+        const val TEST_ALBUM_NAME_PREFIX = "AlbumNumber_"
+        const val DEFAULT_SIZE = 1_000
+    }
+
+    constructor(dataSize: Int = DEFAULT_SIZE) : this(dataSize, null)
+
+    constructor(dataList: List<Group>) : this(DEFAULT_SIZE, dataList)
+
+    private val currentDateTime = LocalDateTime.now()
+
+    // If a [DATA_LIST] was provided, use it, otherwise generate a list of the requested size.
+    val DATA =
+        DATA_LIST
+            ?: buildList<Group> {
+                for (i in 1..DATA_SIZE) {
+                    add(
+                        Group.Album(
+                            id = "$i",
+                            pickerId = i.toLong(),
+                            authority = "a",
+                            displayName = TEST_ALBUM_NAME_PREFIX + "$i",
+                            coverUri =
+                                Uri.EMPTY.buildUpon()
+                                    .apply {
+                                        scheme("content")
+                                        authority("a")
+                                        path("$i")
+                                    }
+                                    .build(),
+                            dateTakenMillisLong =
+                                currentDateTime
+                                    .minus(i.toLong(), ChronoUnit.DAYS)
+                                    .toEpochSecond(ZoneOffset.UTC) * 1000,
+                            coverMediaSource = MediaSource.LOCAL,
+                        )
+                    )
+                }
+            }
+
+    override suspend fun load(params: LoadParams<GroupPageKey>): LoadResult<GroupPageKey, Group> {
+
+        // Handle a data size of 0 for the first page, and return an empty page with no further
+        // keys.
+        if (DATA.size == 0 && params.key == null) {
+            return LoadResult.Page(data = emptyList(), nextKey = null, prevKey = null)
+        }
+
+        // This is inefficient, but a reliable way to locate the record being requested by the
+        // [MediaPageKey] without having to keep track of offsets.
+        val startIndex =
+            if (params.key == null) {
+                0
+            } else {
+                DATA.indexOfFirst { item ->
+                    when (item) {
+                        is Group.Album -> item.pickerId == (params.key?.pickerId ?: 1)
+                        is Group.Category -> item.pickerId == (params.key?.pickerId ?: 1)
+                        else -> false // Or handle other types if needed
+                    }
+                }
+            }
+
+        // The list is zero-based, and loadSize isn't; so, offset by 1
+        val endIndex = Math.min((startIndex + params.loadSize) - 1, DATA.lastIndex)
+
+        // Item at start position doesn't exist, so this isn't a valid page.
+        if (DATA.getOrNull(startIndex) == null) {
+            return LoadResult.Invalid()
+        }
+
+        val pageData = DATA.slice(startIndex..endIndex)
+
+        // Find the start of the next page and generate a Page key.
+        val nextRow = DATA.getOrNull(endIndex + 1)
+        val nextKey =
+            if (nextRow == null) {
+                null
+            } else {
+                GroupPageKey(
+                    pickerId =
+                        when (nextRow) {
+                            is Group.Album -> nextRow.pickerId
+                            is Group.Category -> nextRow.pickerId
+                            else -> 0
+                        }
+                )
+            }
+
+        // Find the start of the previous page and generate a Page key.
+        val prevPageRow = DATA.getOrNull((startIndex) - params.loadSize)
+        val prevKey =
+            if (prevPageRow == null) {
+                null
+            } else {
+                GroupPageKey(
+                    pickerId =
+                        when (prevPageRow) {
+                            is Group.Album -> prevPageRow.pickerId
+                            is Group.Category -> prevPageRow.pickerId
+                            else -> 0
+                        }
+                )
+            }
+
+        return LoadResult.Page(data = pageData, nextKey = nextKey, prevKey = prevKey)
+    }
+
+    override fun getRefreshKey(state: PagingState<GroupPageKey, Group>): GroupPageKey? {
+        return state.anchorPosition?.let { null }
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaSetPagingSource.kt b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaSetPagingSource.kt
new file mode 100644
index 000000000..320869394
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaSetPagingSource.kt
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data.paging
+
+import android.net.Uri
+import androidx.paging.PagingSource
+import androidx.paging.PagingSource.LoadParams
+import androidx.paging.PagingSource.LoadResult
+import androidx.paging.PagingState
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Icon
+import com.android.photopicker.data.model.MediaSource
+
+/**
+ * This [FakeInMemoryMediaSetPagingSource] class is responsible to providing paginated mediaset data
+ * from Picker Database by serving requests from Paging library.
+ *
+ * It generates and returns its own fake data.
+ */
+class FakeInMemoryMediaSetPagingSource
+private constructor(
+    val DATA_SIZE: Int = DEFAULT_SIZE,
+    private val DATA_LIST: List<Group.MediaSet>? = null,
+) : PagingSource<GroupPageKey, Group.MediaSet>() {
+
+    companion object {
+        const val TEST_MEDIASET_NAME_PREFIX = "MediaSetNumber_"
+        const val DEFAULT_SIZE = 1_000
+    }
+
+    constructor(dataSize: Int = DEFAULT_SIZE) : this(dataSize, null)
+
+    constructor(dataList: List<Group.MediaSet>) : this(DEFAULT_SIZE, dataList)
+
+    // If a [DATA_LIST] was provided, use it, otherwise generate a list of the requested size.
+    val DATA =
+        DATA_LIST
+            ?: buildList<Group.MediaSet> {
+                for (i in 1..DATA_SIZE) {
+                    add(
+                        Group.MediaSet(
+                            id = "$i",
+                            pickerId = i.toLong(),
+                            authority = "a",
+                            displayName = TEST_MEDIASET_NAME_PREFIX + "$i",
+                            icon = Icon(Uri.parse(""), MediaSource.LOCAL),
+                        )
+                    )
+                }
+            }
+
+    override suspend fun load(
+        params: LoadParams<GroupPageKey>
+    ): LoadResult<GroupPageKey, Group.MediaSet> {
+
+        // Handle a data size of 0 for the first page, and return an empty page with no further
+        // keys.
+        if (DATA.size == 0 && params.key == null) {
+            return LoadResult.Page(data = emptyList(), nextKey = null, prevKey = null)
+        }
+
+        // This is inefficient, but a reliable way to locate the record being requested by the
+        // [MediaPageKey] without having to keep track of offsets.
+        val startIndex =
+            if (params.key == null) {
+                0
+            } else {
+                DATA.indexOfFirst({ item -> item.pickerId == params.key?.pickerId ?: 1 })
+            }
+
+        // The list is zero-based, and loadSize isn't; so, offset by 1
+        val endIndex = Math.min((startIndex + params.loadSize) - 1, DATA.lastIndex)
+
+        // Item at start position doesn't exist, so this isn't a valid page.
+        if (DATA.getOrNull(startIndex) == null) {
+            return LoadResult.Invalid()
+        }
+
+        val pageData = DATA.slice(startIndex..endIndex)
+
+        // Find the start of the next page and generate a Page key.
+        val nextRow = DATA.getOrNull(endIndex + 1)
+        val nextKey =
+            if (nextRow == null) {
+                null
+            } else {
+                GroupPageKey(pickerId = nextRow.pickerId)
+            }
+
+        // Find the start of the previous page and generate a Page key.
+        val prevPageRow = DATA.getOrNull((startIndex) - params.loadSize)
+        val prevKey =
+            if (prevPageRow == null) {
+                null
+            } else {
+                GroupPageKey(pickerId = prevPageRow.pickerId)
+            }
+
+        return LoadResult.Page(data = pageData, nextKey = nextKey, prevKey = prevKey)
+    }
+
+    override fun getRefreshKey(state: PagingState<GroupPageKey, Group.MediaSet>): GroupPageKey? {
+        return state.anchorPosition?.let { null }
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt
index ba42eb58a..f188c3347 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt
@@ -32,6 +32,7 @@ import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
 import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.data.paging.MediaPagingSource
 import kotlinx.coroutines.ExperimentalCoroutinesApi
@@ -54,7 +55,15 @@ class MediaPagingSourceTest {
     private val testSessionId = generatePickerSessionId()
     private val testContentProvider: TestMediaProvider = TestMediaProvider()
     private val contentResolver: ContentResolver = ContentResolver.wrap(testContentProvider)
-    private val availableProviders: List<Provider> = emptyList()
+    private val availableProviders: List<Provider> =
+        listOf(
+            Provider(
+                authority = "local_authority",
+                mediaSource = MediaSource.LOCAL,
+                uid = 1,
+                displayName = "Local Provider",
+            )
+        )
     private val testPhotopickerConfiguration: PhotopickerConfiguration =
         PhotopickerConfiguration(
             action = MediaStore.ACTION_PICK_IMAGES,
@@ -112,7 +121,7 @@ class MediaPagingSourceTest {
                 pageKey,
                 pageSize,
                 contentResolver,
-                emptyList(),
+                availableProviders,
                 testPhotopickerConfiguration,
             )
     }
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt
index ae04b290b..721241ce2 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt
@@ -19,6 +19,7 @@ package com.android.photopicker.features.data.paging
 import android.content.ContentResolver
 import android.content.Intent
 import android.net.Uri
+import android.os.CancellationSignal
 import android.provider.MediaStore
 import androidx.paging.PagingSource.LoadResult
 import androidx.test.ext.junit.runners.AndroidJUnit4
@@ -26,15 +27,19 @@ import androidx.test.filters.SmallTest
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
 import com.android.photopicker.core.events.generatePickerSessionId
+import com.android.photopicker.data.DEFAULT_PROVIDERS
 import com.android.photopicker.data.DEFAULT_SEARCH_REQUEST_ID
+import com.android.photopicker.data.DEFAULT_SEARCH_SUGGESTIONS
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
 import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.features.search.model.SearchRequest
+import com.android.photopicker.features.search.model.SearchSuggestion
 import com.google.common.truth.Truth.assertThat
 import kotlinx.coroutines.test.runTest
 import org.junit.Test
@@ -462,4 +467,156 @@ class MediaProviderClientTest {
 
         assertThat(searchRequestId).isEqualTo(DEFAULT_SEARCH_REQUEST_ID)
     }
+
+    @Test
+    fun testFetchSearchSuggestions() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+        val cancellationSignal = CancellationSignal()
+
+        val searchSuggestions: List<SearchSuggestion> =
+            mediaProviderClient.fetchSearchSuggestions(
+                resolver = testContentResolver,
+                prefix = "",
+                limit = 10,
+                historyLimit = 3,
+                availableProviders = listOf(),
+                cancellationSignal = cancellationSignal,
+            )
+
+        assertThat(searchSuggestions.size).isEqualTo(DEFAULT_SEARCH_SUGGESTIONS.size)
+
+        for (index in 0..<DEFAULT_SEARCH_SUGGESTIONS.size) {
+            assertThat(searchSuggestions[index]).isEqualTo(DEFAULT_SEARCH_SUGGESTIONS[index])
+        }
+    }
+
+    @Test
+    fun testFetchSearchProvidersWithAvailableProvidersKnown() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+        val localProvider =
+            Provider(
+                authority = "local_authority",
+                mediaSource = MediaSource.LOCAL,
+                uid = 0,
+                displayName = "",
+            )
+        val cloudProvider =
+            Provider(
+                authority = "cloud_authority",
+                mediaSource = MediaSource.REMOTE,
+                uid = 0,
+                displayName = "",
+            )
+        val testContentProvider: TestMediaProvider =
+            TestMediaProvider(searchProviders = listOf(localProvider, cloudProvider))
+        val testContentResolver: ContentResolver = ContentResolver.wrap(testContentProvider)
+
+        val searchProviderAuthorities =
+            mediaProviderClient.fetchSearchProviderAuthorities(
+                resolver = testContentResolver,
+                availableProviders = listOf(localProvider),
+            )
+
+        assertThat(searchProviderAuthorities).isEqualTo(listOf(localProvider.authority))
+    }
+
+    @Test
+    fun testFetchSearchProviders() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+        val testContentResolver: ContentResolver = ContentResolver.wrap(testContentProvider)
+        val searchProviderAuthorities =
+            mediaProviderClient.fetchSearchProviderAuthorities(resolver = testContentResolver)
+
+        assertThat(searchProviderAuthorities)
+            .isEqualTo(DEFAULT_PROVIDERS.map { it.authority }.toList())
+    }
+
+    @Test
+    fun testFetchCategories() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+
+        val categoriesLoadResult: LoadResult<GroupPageKey, Group> =
+            mediaProviderClient.fetchCategoriesAndAlbums(
+                pageKey = GroupPageKey(),
+                pageSize = 5,
+                contentResolver = testContentResolver,
+                availableProviders = testContentProvider.providers,
+                parentCategoryId = null,
+                config =
+                    PhotopickerConfiguration(
+                        action = MediaStore.ACTION_PICK_IMAGES,
+                        sessionId = sessionId,
+                    ),
+                CancellationSignal(),
+            )
+
+        assertThat(categoriesLoadResult is LoadResult.Page).isTrue()
+
+        val categoriesAndAlbums: List<Group> = (categoriesLoadResult as LoadResult.Page).data
+
+        val expectedCategoriesAndAlbums = testContentProvider.categoriesAndAlbums
+        assertThat(categoriesAndAlbums.count()).isEqualTo(expectedCategoriesAndAlbums.count())
+        for (index in expectedCategoriesAndAlbums.indices) {
+            assertThat(categoriesAndAlbums[index]).isEqualTo(expectedCategoriesAndAlbums[index])
+        }
+    }
+
+    @Test
+    fun testFetchMediaSets() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+
+        val mediaSetsLoadResult: LoadResult<GroupPageKey, Group.MediaSet> =
+            mediaProviderClient.fetchMediaSets(
+                pageKey = GroupPageKey(),
+                pageSize = 5,
+                contentResolver = testContentResolver,
+                availableProviders = testContentProvider.providers,
+                parentCategory = testContentProvider.parentCategory,
+                config =
+                    PhotopickerConfiguration(
+                        action = MediaStore.ACTION_PICK_IMAGES,
+                        sessionId = sessionId,
+                    ),
+                cancellationSignal = CancellationSignal(),
+            )
+
+        assertThat(mediaSetsLoadResult is LoadResult.Page).isTrue()
+
+        val mediaSets: List<Group.MediaSet> = (mediaSetsLoadResult as LoadResult.Page).data
+
+        val expectedMediaSets = testContentProvider.mediaSets
+        assertThat(mediaSets.count()).isEqualTo(expectedMediaSets.count())
+        for (index in expectedMediaSets.indices) {
+            assertThat(mediaSets[index]).isEqualTo(expectedMediaSets[index])
+        }
+    }
+
+    @Test
+    fun testFetchMediaSetContents() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+
+        val mediaSetContentsLoadResult: LoadResult<MediaPageKey, Media> =
+            mediaProviderClient.fetchMediaSetContents(
+                pageKey = MediaPageKey(),
+                pageSize = 5,
+                contentResolver = testContentResolver,
+                parentMediaSet = testContentProvider.mediaSets[0],
+                config =
+                    PhotopickerConfiguration(
+                        action = MediaStore.ACTION_PICK_IMAGES,
+                        sessionId = sessionId,
+                    ),
+                cancellationSignal = CancellationSignal(),
+            )
+
+        assertThat(mediaSetContentsLoadResult is LoadResult.Page).isTrue()
+
+        val media: List<Media> = (mediaSetContentsLoadResult as LoadResult.Page).data
+
+        val expectedMedia = testContentProvider.media
+        assertThat(media.count()).isEqualTo(expectedMedia.count())
+        for (index in expectedMedia.indices) {
+            assertThat(media[index]).isEqualTo(expectedMedia[index])
+        }
+    }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt
index 4305be5bf..3f04838a0 100644
--- a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt
@@ -22,7 +22,11 @@ import android.content.Context
 import android.content.Intent
 import android.content.pm.PackageManager
 import android.net.Uri
+import android.os.Build
 import android.os.UserManager
+import android.platform.test.annotations.DisableFlags
+import android.platform.test.annotations.EnableFlags
+import android.platform.test.flag.junit.SetFlagsRule
 import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_CAMERA
 import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES
 import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS
@@ -31,12 +35,15 @@ import android.test.mock.MockContentResolver
 import androidx.compose.ui.test.ExperimentalTestApi
 import androidx.compose.ui.test.assert
 import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertIsFocused
+import androidx.compose.ui.test.assertIsNotFocused
 import androidx.compose.ui.test.hasClickAction
 import androidx.compose.ui.test.hasText
 import androidx.compose.ui.test.junit4.createAndroidComposeRule
 import androidx.compose.ui.test.performClick
 import androidx.compose.ui.test.performTouchInput
 import androidx.compose.ui.test.swipeRight
+import androidx.test.filters.SdkSuppress
 import com.android.photopicker.R
 import com.android.photopicker.core.ActivityModule
 import com.android.photopicker.core.ApplicationModule
@@ -65,6 +72,7 @@ import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
 import com.android.photopicker.util.test.MockContentProviderWrapper
 import com.android.photopicker.util.test.whenever
+import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -74,6 +82,9 @@ import dagger.hilt.android.testing.HiltAndroidRule
 import dagger.hilt.android.testing.HiltAndroidTest
 import dagger.hilt.android.testing.UninstallModules
 import dagger.hilt.components.SingletonComponent
+import java.time.LocalDateTime
+import java.time.ZoneOffset
+import java.time.temporal.ChronoUnit
 import javax.inject.Inject
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
@@ -98,6 +109,7 @@ import org.mockito.MockitoAnnotations
 )
 @HiltAndroidTest
 @OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
 class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
 
     /* Hilt's rule needs to come first to ensure the DI container is setup for the test. */
@@ -105,6 +117,7 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
     @get:Rule(order = 1)
     val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
     @get:Rule(order = 2) val glideRule = GlideTestRule()
+    @get:Rule(order = 3) var setFlagsRule = SetFlagsRule()
 
     /* Setup dependencies for the UninstallModules for the test class. */
     @Module @InstallIn(SingletonComponent::class) class TestModule : PhotopickerTestModule()
@@ -165,7 +178,8 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
-    fun testAlbumGridIsAlwaysEnabled() {
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testAlbumGridIsEnabledWhenSearchFlagOff() {
         assertWithMessage("AlbumGridFeature is not always enabled for TEST_ACTION")
             .that(
                 AlbumGridFeature.Registration.isEnabled(
@@ -215,6 +229,58 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testAlbumGridIsDisabledWhenSearchFlagOn() {
+        assertWithMessage("AlbumGridFeature is enabled for TEST_ACTION")
+            .that(
+                AlbumGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action("TEST_ACTION")
+                        intent(Intent("TEST_ACTION"))
+                    }
+                )
+            )
+            .isEqualTo(false)
+
+        assertWithMessage("AlbumGridFeature is always enabled")
+            .that(
+                AlbumGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(MediaStore.ACTION_PICK_IMAGES)
+                        intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                    }
+                )
+            )
+            .isEqualTo(false)
+
+        assertWithMessage("AlbumGridFeature is always enabled")
+            .that(
+                AlbumGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(Intent.ACTION_GET_CONTENT)
+                        intent(Intent(Intent.ACTION_GET_CONTENT))
+                    }
+                )
+            )
+            .isEqualTo(false)
+
+        assertWithMessage("AlbumGridFeature is always enabled")
+            .that(
+                AlbumGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP)
+                        intent(Intent(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP))
+                        callingPackage("com.example.test")
+                        callingPackageUid(1234)
+                        callingPackageLabel("test_app")
+                    }
+                )
+            )
+            .isEqualTo(false)
+    }
+
+    @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testNavigateAlbumGridAndAlbumsAreVisible() =
         testScope.runTest {
             composeTestRule.setContent {
@@ -249,6 +315,107 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
         }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testConsistentAlbumFocus() =
+        testScope.runTest {
+            val currentDateTime = LocalDateTime.now()
+            val dataList =
+                buildList<Group.Album> {
+                    for (i in 1..3) {
+                        add(
+                            Group.Album(
+                                id = "$i",
+                                pickerId = i.toLong(),
+                                authority = "a",
+                                displayName = TEST_ALBUM_NAME_PREFIX + "$i",
+                                coverUri =
+                                    Uri.EMPTY.buildUpon()
+                                        .apply {
+                                            scheme("content")
+                                            authority("a")
+                                            path("$i")
+                                        }
+                                        .build(),
+                                dateTakenMillisLong =
+                                    currentDateTime
+                                        .minus(i.toLong(), ChronoUnit.DAYS)
+                                        .toEpochSecond(ZoneOffset.UTC) * 1000,
+                                coverMediaSource = MediaSource.LOCAL,
+                            )
+                        )
+                    }
+                }
+
+            val testDataService = dataService as? TestDataServiceImpl
+            checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+            testDataService.albumsList = dataList
+
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // wait for the composition to finish
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToAlbumGrid() })
+
+            assertWithMessage("Expected route to be albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            composeTestRule.waitForIdle()
+
+            // wait for the album grid to show up
+            advanceTimeBy(100)
+
+            val allAlbumNodes =
+                composeTestRule.onAllNodes(hasText(text = TEST_ALBUM_NAME_PREFIX, substring = true))
+
+            allAlbumNodes[0].assert(hasClickAction()).assertIsDisplayed().performClick()
+
+            assertWithMessage("Expected route to be album media grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_MEDIA_GRID.route)
+
+            composeTestRule.waitForIdle()
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToAlbumGrid() })
+
+            assertWithMessage("Expected route to be albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            composeTestRule.waitForIdle()
+
+            // wait for the album grid to show up
+            advanceTimeBy(150)
+
+            composeTestRule.waitUntil(timeoutMillis = 5_000) {
+                try {
+                    composeTestRule
+                        .onNode(hasText(TEST_ALBUM_NAME_PREFIX + "1", substring = true))
+                        .assertExists()
+                        .assertIsFocused()
+                    true // Condition met
+                } catch (e: AssertionError) {
+                    false // Condition not yet met
+                }
+            }
+
+            allAlbumNodes[0].assertIsFocused()
+            allAlbumNodes[1].assertIsNotFocused()
+            allAlbumNodes[2].assertIsNotFocused()
+        }
+
+    @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testAlbumsCanBeSelected() =
         testScope.runTest {
             composeTestRule.setContent {
@@ -293,6 +460,7 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
         }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testSwipeLeftToNavigateToPhotoGrid() =
         testScope.runTest {
             composeTestRule.setContent {
@@ -328,6 +496,7 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
         }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testAlbumMediaShowsEmptyStateWhenEmpty() {
 
         val testDataService = dataService as? TestDataServiceImpl
@@ -388,6 +557,7 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testEmptyStateContentForFavorites() {
 
         val testDataService = dataService as? TestDataServiceImpl
@@ -469,6 +639,7 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testEmptyStateContentForVideos() {
 
         val testDataService = dataService as? TestDataServiceImpl
@@ -545,6 +716,7 @@ class AlbumGridFeatureTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testEmptyStateContentForCamera() {
 
         val testDataService = dataService as? TestDataServiceImpl
diff --git a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt
index 4674a641b..0ccfadf06 100644
--- a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt
@@ -17,8 +17,12 @@
 package com.android.photopicker.features.albumgrid
 
 import android.net.Uri
+import android.os.Build
+import android.platform.test.annotations.DisableFlags
+import android.platform.test.flag.junit.SetFlagsRule
 import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SdkSuppress
 import androidx.test.filters.SmallTest
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.configuration.provideTestConfigurationFlow
@@ -35,20 +39,25 @@ import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
+import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.toList
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.test.advanceTimeBy
 import kotlinx.coroutines.test.runTest
+import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
 
 @SmallTest
 @RunWith(AndroidJUnit4::class)
 @OptIn(ExperimentalCoroutinesApi::class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
 class AlbumGridViewModelTest {
 
+    @get:Rule var setFlagsRule = SetFlagsRule()
+
     val mediaItem =
         Media.Image(
             mediaId = "id",
@@ -101,6 +110,7 @@ class AlbumGridViewModelTest {
         mediaItem.copy(mediaItemAlbum = album, selectionSource = Telemetry.MediaLocation.ALBUM)
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testAlbumGridItemClickedUpdatesSelection() {
 
         runTest {
@@ -157,6 +167,7 @@ class AlbumGridViewModelTest {
     }
 
     @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testAlbumGridShowsToastWhenSelectionFull() {
 
         runTest {
diff --git a/photopicker/tests/src/com/android/photopicker/features/categorygrid/CategoryGridFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/categorygrid/CategoryGridFeatureTest.kt
new file mode 100644
index 000000000..577bf8710
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/categorygrid/CategoryGridFeatureTest.kt
@@ -0,0 +1,1127 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import android.content.ContentProvider
+import android.content.ContentResolver
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.net.Uri
+import android.os.Build
+import android.os.UserManager
+import android.platform.test.annotations.DisableFlags
+import android.platform.test.annotations.EnableFlags
+import android.platform.test.flag.junit.SetFlagsRule
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_CAMERA
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS
+import android.provider.MediaStore
+import android.test.mock.MockContentResolver
+import androidx.compose.ui.test.ExperimentalTestApi
+import androidx.compose.ui.test.assert
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertIsFocused
+import androidx.compose.ui.test.assertIsNotFocused
+import androidx.compose.ui.test.hasClickAction
+import androidx.compose.ui.test.hasText
+import androidx.compose.ui.test.junit4.createAndroidComposeRule
+import androidx.compose.ui.test.performClick
+import androidx.compose.ui.test.performTouchInput
+import androidx.compose.ui.test.swipeRight
+import androidx.test.filters.SdkSuppress
+import com.android.photopicker.R
+import com.android.photopicker.core.ActivityModule
+import com.android.photopicker.core.ApplicationModule
+import com.android.photopicker.core.ApplicationOwned
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.ConcurrencyModule
+import com.android.photopicker.core.EmbeddedServiceModule
+import com.android.photopicker.core.Main
+import com.android.photopicker.core.ViewModelModule
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.glide.GlideTestRule
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.model.CategoryType
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Icon
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.data.paging.FakeInMemoryAlbumPagingSource
+import com.android.photopicker.data.paging.FakeInMemoryCategoryPagingSource.Companion.TEST_ALBUM_NAME_PREFIX
+import com.android.photopicker.extensions.navigateToCategoryGrid
+import com.android.photopicker.features.PhotopickerFeatureBaseTest
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+import com.android.photopicker.inject.PhotopickerTestModule
+import com.android.photopicker.tests.HiltTestActivity
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.whenever
+import com.android.providers.media.flags.Flags
+import com.google.common.truth.Truth.assertWithMessage
+import dagger.Lazy
+import dagger.Module
+import dagger.hilt.InstallIn
+import dagger.hilt.android.testing.BindValue
+import dagger.hilt.android.testing.HiltAndroidRule
+import dagger.hilt.android.testing.HiltAndroidTest
+import dagger.hilt.android.testing.UninstallModules
+import dagger.hilt.components.SingletonComponent
+import javax.inject.Inject
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.mockito.Mock
+import org.mockito.Mockito.any
+import org.mockito.MockitoAnnotations
+import src.com.android.photopicker.features.categorygrid.data.TestCategoryDataServiceImpl
+
+@UninstallModules(
+    ActivityModule::class,
+    EmbeddedServiceModule::class,
+    ApplicationModule::class,
+    ConcurrencyModule::class,
+    ViewModelModule::class,
+)
+@HiltAndroidTest
+@OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+class CategoryGridFeatureTest : PhotopickerFeatureBaseTest() {
+
+    /* Hilt's rule needs to come first to ensure the DI container is setup for the test. */
+    @get:Rule(order = 0) val hiltRule = HiltAndroidRule(this)
+    @get:Rule(order = 1)
+    val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
+    @get:Rule(order = 2) val glideRule = GlideTestRule()
+    @get:Rule(order = 3) var setFlagsRule = SetFlagsRule()
+
+    /* Setup dependencies for the UninstallModules for the test class. */
+    @Module @InstallIn(SingletonComponent::class) class TestModule : PhotopickerTestModule()
+
+    val testDispatcher = StandardTestDispatcher()
+
+    /* Overrides for ActivityModule */
+    val testScope: TestScope = TestScope(testDispatcher)
+    @BindValue @Main val mainScope: CoroutineScope = testScope
+    @BindValue @Background var testBackgroundScope: CoroutineScope = testScope.backgroundScope
+
+    /* Overrides for ViewModelModule */
+    @BindValue val viewModelScopeOverride: CoroutineScope? = testScope.backgroundScope
+
+    /* Overrides for the ConcurrencyModule */
+    @BindValue @Main val mainDispatcher: CoroutineDispatcher = testDispatcher
+    @BindValue @Background val backgroundDispatcher: CoroutineDispatcher = testDispatcher
+
+    /**
+     * Preview uses Glide for loading images, so we have to mock out the dependencies for Glide
+     * Replace the injected ContentResolver binding in [ApplicationModule] with this test value.
+     */
+    @BindValue @ApplicationOwned lateinit var contentResolver: ContentResolver
+    private lateinit var provider: MockContentProviderWrapper
+    @Mock lateinit var mockContentProvider: ContentProvider
+
+    // Needed for UserMonitor
+    @Mock lateinit var mockUserManager: UserManager
+    @Mock lateinit var mockPackageManager: PackageManager
+
+    @Inject lateinit var mockContext: Context
+    @Inject lateinit var selection: Selection<Media>
+    @Inject lateinit var featureManager: FeatureManager
+    @Inject lateinit var events: Events
+    @Inject override lateinit var configurationManager: Lazy<ConfigurationManager>
+    @Inject lateinit var dataService: DataService
+    @Inject lateinit var categoryDataService: CategoryDataService
+
+    @Before
+    fun setup() {
+        MockitoAnnotations.initMocks(this)
+
+        hiltRule.inject()
+
+        // Stub for MockContentResolver constructor
+        whenever(mockContext.getApplicationInfo()) { getTestableContext().getApplicationInfo() }
+
+        // Stub out the content resolver for Glide
+        val mockContentResolver = MockContentResolver(mockContext)
+        provider = MockContentProviderWrapper(mockContentProvider)
+        mockContentResolver.addProvider(MockContentProviderWrapper.AUTHORITY, provider)
+        contentResolver = mockContentResolver
+
+        // Return a resource png so that glide actually has something to load
+        whenever(mockContentProvider.openTypedAssetFile(any(), any(), any(), any())) {
+            getTestableContext().getResources().openRawResourceFd(R.drawable.android)
+        }
+        setupTestForUserMonitor(mockContext, mockUserManager, contentResolver, mockPackageManager)
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testCategoryGridIsEnabledWhenSearchFlagOn() {
+        assertWithMessage("CategoryGridFeature is not enabled for TEST_ACTION")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action("TEST_ACTION")
+                        intent(Intent("TEST_ACTION"))
+                    }
+                )
+            )
+            .isEqualTo(true)
+
+        assertWithMessage("CategoryGridFeature is not enabled")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(MediaStore.ACTION_PICK_IMAGES)
+                        intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                    }
+                )
+            )
+            .isEqualTo(true)
+
+        assertWithMessage("CategoryGridFeature is not enabled")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(Intent.ACTION_GET_CONTENT)
+                        intent(Intent(Intent.ACTION_GET_CONTENT))
+                    }
+                )
+            )
+            .isEqualTo(true)
+
+        assertWithMessage("AlbumGridFeature is not enabled")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP)
+                        intent(Intent(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP))
+                        callingPackage("com.example.test")
+                        callingPackageUid(1234)
+                        callingPackageLabel("test_app")
+                    }
+                )
+            )
+            .isEqualTo(true)
+    }
+
+    @Test
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testCategoryGridIsDisabledWhenSearchFlagOff() {
+        assertWithMessage("CategoryGridFeature is enabled for TEST_ACTION")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action("TEST_ACTION")
+                        intent(Intent("TEST_ACTION"))
+                    }
+                )
+            )
+            .isEqualTo(false)
+
+        assertWithMessage("CategoryGridFeature is enabled")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(MediaStore.ACTION_PICK_IMAGES)
+                        intent(Intent(MediaStore.ACTION_PICK_IMAGES))
+                    }
+                )
+            )
+            .isEqualTo(false)
+
+        assertWithMessage("CategoryGridFeature is enabled")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(Intent.ACTION_GET_CONTENT)
+                        intent(Intent(Intent.ACTION_GET_CONTENT))
+                    }
+                )
+            )
+            .isEqualTo(false)
+
+        assertWithMessage("AlbumGridFeature is enabled")
+            .that(
+                CategoryGridFeature.Registration.isEnabled(
+                    TestPhotopickerConfiguration.build {
+                        action(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP)
+                        intent(Intent(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP))
+                        callingPackage("com.example.test")
+                        callingPackageUid(1234)
+                        callingPackageLabel("test_app")
+                    }
+                )
+            )
+            .isEqualTo(false)
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testNavigateCategoryGridAndAlbumsAreVisible() =
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            // In the [FakeInMemoryPagingSource] the albums are names using TEST_ALBUM_NAME_PREFIX
+            // appended by a count in their sequence. Verify that an album with the name exists
+            composeTestRule
+                .onNode(hasText(TEST_ALBUM_NAME_PREFIX + "1"))
+                .assert(hasClickAction())
+                .assertIsDisplayed()
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testConsistentCategoryFocus() =
+        testScope.runTest {
+            val dataList =
+                buildList<Group.Category> {
+                    for (i in 1..3) {
+                        add(
+                            Group.Category(
+                                id = "$i",
+                                pickerId = i.toLong(),
+                                authority = "a",
+                                displayName =
+                                    FakeInMemoryAlbumPagingSource.Companion.TEST_ALBUM_NAME_PREFIX +
+                                        "$i",
+                                categoryType = CategoryType.PEOPLE_AND_PETS,
+                                icons = emptyList(),
+                                isLeafCategory = true,
+                            )
+                        )
+                    }
+                }
+
+            val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+            checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+            testCategoryDataService.categoryAlbumList = dataList
+
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // wait for the composition to finish
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            composeTestRule.waitForIdle()
+
+            // wait for the album grid to show up
+            advanceTimeBy(100)
+
+            val allAlbumNodes =
+                composeTestRule.onAllNodes(
+                    hasText(
+                        text = FakeInMemoryAlbumPagingSource.Companion.TEST_ALBUM_NAME_PREFIX,
+                        substring = true,
+                    )
+                )
+
+            allAlbumNodes[0].assert(hasClickAction()).assertIsDisplayed().performClick()
+
+            assertWithMessage("Expected route to be media set grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.MEDIA_SET_GRID.route)
+
+            composeTestRule.waitForIdle()
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            // wait for the album grid to show up
+            advanceTimeBy(150)
+
+            composeTestRule.waitUntil(timeoutMillis = 5_000) {
+                try {
+                    composeTestRule
+                        .onNode(
+                            hasText(
+                                FakeInMemoryAlbumPagingSource.Companion.TEST_ALBUM_NAME_PREFIX +
+                                    "1",
+                                substring = true,
+                            )
+                        )
+                        .assertExists()
+                        .assertIsFocused()
+                    true // Condition met
+                } catch (e: AssertionError) {
+                    false // Condition not yet met
+                }
+            }
+
+            allAlbumNodes[0].assertIsFocused()
+            allAlbumNodes[1].assertIsNotFocused()
+            allAlbumNodes[2].assertIsNotFocused()
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testAlbumsCanBeSelected() =
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            val testAlbumDisplayName = TEST_ALBUM_NAME_PREFIX + "1"
+            // In the [FakeInMemoryPagingSource] the albums are names using TEST_ALBUM_NAME_PREFIX
+            // appended by a count in their sequence. Verify that an album with the name exists
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).assertIsDisplayed()
+
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            assertWithMessage("Expected route to be album media grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_MEDIA_GRID.route)
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSwipeLeftToNavigateToPhotoGrid() =
+        testScope.runTest {
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            advanceTimeBy(100)
+
+            composeTestRule.onNode(hasText(TEST_ALBUM_NAME_PREFIX + "1")).performTouchInput {
+                swipeRight()
+            }
+            composeTestRule.waitForIdle()
+
+            val route = navController.currentBackStackEntry?.destination?.route
+            assertWithMessage("Expected swipe to navigate to Photogrid")
+                .that(route)
+                .isEqualTo(PhotopickerDestinations.PHOTO_GRID.route)
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testAlbumMediaShowsEmptyStateWhenEmpty() {
+
+        val dataService = dataService as? TestDataServiceImpl
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+        checkNotNull(dataService) { "Expected a TestDataServiceImpl" }
+
+        // Force the data service to return no data for all test sources during this test.
+        dataService.albumMediaSetSize = 0
+
+        val resources = getTestableContext().getResources()
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            val testAlbumDisplayName = TEST_ALBUM_NAME_PREFIX + "1"
+            // In the [FakeInMemoryPagingSource] the albums are names using TEST_ALBUM_NAME_PREFIX
+            // appended by a count in their sequence. Verify that an album with the name exists
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).assertIsDisplayed()
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testEmptyStateContentForFavorites() {
+
+        val testDataService = dataService as? TestDataServiceImpl
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.albumMediaSetSize = 0
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Album(
+                    id = ALBUM_ID_FAVORITES,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = "Favorites",
+                    coverUri =
+                        Uri.EMPTY.buildUpon()
+                            .apply {
+                                scheme("content")
+                                authority("a")
+                                path("1234")
+                            }
+                            .build(),
+                    dateTakenMillisLong = 12345678L,
+                    coverMediaSource = MediaSource.LOCAL,
+                )
+            )
+
+        val resources = getTestableContext().getResources()
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            val testAlbumDisplayName = "Favorites"
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(
+                    hasText(resources.getString(R.string.photopicker_favorites_empty_state_title))
+                )
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(
+                    hasText(resources.getString(R.string.photopicker_favorites_empty_state_body))
+                )
+                .assertIsDisplayed()
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testEmptyStateContentForVideos() {
+
+        val testDataService = dataService as? TestDataServiceImpl
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.albumMediaSetSize = 0
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Album(
+                    id = ALBUM_ID_VIDEOS,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = "Videos",
+                    coverUri =
+                        Uri.EMPTY.buildUpon()
+                            .apply {
+                                scheme("content")
+                                authority("a")
+                                path("1234")
+                            }
+                            .build(),
+                    dateTakenMillisLong = 12345678L,
+                    coverMediaSource = MediaSource.LOCAL,
+                )
+            )
+
+        val resources = getTestableContext().getResources()
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            val testAlbumDisplayName = "Videos"
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_videos_empty_state_title)))
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_videos_empty_state_body)))
+                .assertIsDisplayed()
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testEmptyStateContentForCamera() {
+        val testDataService = dataService as? TestDataServiceImpl
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.albumMediaSetSize = 0
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Album(
+                    id = ALBUM_ID_CAMERA,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = "Camera",
+                    coverUri =
+                        Uri.EMPTY.buildUpon()
+                            .apply {
+                                scheme("content")
+                                authority("a")
+                                path("1234")
+                            }
+                            .build(),
+                    dateTakenMillisLong = 12345678L,
+                    coverMediaSource = MediaSource.LOCAL,
+                )
+            )
+
+        val resources = getTestableContext().getResources()
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            val testAlbumDisplayName = "Camera"
+            composeTestRule.onNode(hasText(testAlbumDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_camera_empty_state_body)))
+                .assertIsDisplayed()
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testMediaSetCanBeSelected() {
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+
+        val testCategoryDisplayName = "People & Pets"
+        val testMediaSetname = "mediaset"
+
+        testCategoryDataService.mediaSetContentSize = 0
+        // Force the data service to return no data for all test sources during this test.
+        testCategoryDataService.mediaSetList =
+            listOf(
+                Group.MediaSet(
+                    id = testMediaSetname,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = testMediaSetname,
+                    icon = Icon(Uri.parse(""), MediaSource.LOCAL),
+                )
+            )
+
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Category(
+                    id = testCategoryDisplayName,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = testCategoryDisplayName,
+                    categoryType = CategoryType.PEOPLE_AND_PETS,
+                    icons = emptyList(),
+                    isLeafCategory = true,
+                )
+            )
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            composeTestRule.onNode(hasText(testCategoryDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            assertWithMessage("Expected route to be media set grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.MEDIA_SET_GRID.route)
+
+            composeTestRule.onNode(hasText(testMediaSetname)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+
+            assertWithMessage("Expected route to be mediasetcontentgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.MEDIA_SET_CONTENT_GRID.route)
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testEmptyStateContentForMediaSet() {
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+
+        val testCategoryDisplayName = "People & Pets"
+        val testMediaSetname = "mediaset"
+
+        val resources = getTestableContext().getResources()
+
+        testCategoryDataService.mediaSetContentSize = 0
+        // Force the data service to return no data for all test sources during this test.
+        testCategoryDataService.mediaSetList =
+            listOf(
+                Group.MediaSet(
+                    id = testMediaSetname,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = testMediaSetname,
+                    icon = Icon(Uri.parse(""), MediaSource.LOCAL),
+                )
+            )
+
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Category(
+                    id = testCategoryDisplayName,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = testCategoryDisplayName,
+                    categoryType = CategoryType.PEOPLE_AND_PETS,
+                    icons = emptyList(),
+                    isLeafCategory = true,
+                )
+            )
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            composeTestRule.onNode(hasText(testCategoryDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            assertWithMessage("Expected route to be media set grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.MEDIA_SET_GRID.route)
+
+            composeTestRule.onNode(hasText(testMediaSetname)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            // Allow the PreviewViewModel to collect flows
+            advanceTimeBy(100)
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testEmptyStateContentForPeoplePetsCategory() {
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+
+        val testCategoryDisplayName = "People & Pets"
+
+        val resources = getTestableContext().getResources()
+
+        testCategoryDataService.mediaSetSize = 0
+        // Force the data service to return no data for all test sources during this test.
+        testCategoryDataService.mediaSetList = emptyList()
+
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Category(
+                    id = testCategoryDisplayName,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = testCategoryDisplayName,
+                    categoryType = CategoryType.PEOPLE_AND_PETS,
+                    icons = emptyList(),
+                    isLeafCategory = true,
+                )
+            )
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            composeTestRule.onNode(hasText(testCategoryDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            assertWithMessage("Expected route to be media set grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.MEDIA_SET_GRID.route)
+
+            composeTestRule
+                .onNode(
+                    hasText(
+                        resources.getString(R.string.photopicker_people_category_empty_state_title)
+                    )
+                )
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(
+                    hasText(
+                        resources.getString(R.string.photopicker_people_category_empty_state_body)
+                    )
+                )
+                .assertIsDisplayed()
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testEmptyStateContentForOtherCategory() {
+        val testCategoryDataService = categoryDataService as? TestCategoryDataServiceImpl
+        checkNotNull(testCategoryDataService) { "Expected a TestCategoryDataServiceImpl" }
+
+        val testCategoryDisplayName = "Other Categoreis"
+
+        val resources = getTestableContext().getResources()
+
+        testCategoryDataService.mediaSetSize = 0
+        // Force the data service to return no data for all test sources during this test.
+        testCategoryDataService.mediaSetList = emptyList()
+
+        testCategoryDataService.categoryAlbumList =
+            listOf(
+                Group.Category(
+                    id = testCategoryDisplayName,
+                    pickerId = 1234L,
+                    authority = "a",
+                    displayName = testCategoryDisplayName,
+                    categoryType = CategoryType.USER_ABLUMS,
+                    icons = emptyList(),
+                    isLeafCategory = true,
+                )
+            )
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                // Set an explicit size to prevent errors in glide being unable to measure
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            advanceTimeBy(100)
+
+            // Navigate on the UI thread (similar to a click handler)
+            composeTestRule.runOnUiThread({ navController.navigateToCategoryGrid() })
+
+            assertWithMessage("Expected route to be category albumgrid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            composeTestRule.onNode(hasText(testCategoryDisplayName)).performClick()
+
+            composeTestRule.waitForIdle()
+
+            advanceTimeBy(100)
+
+            assertWithMessage("Expected route to be media set grid")
+                .that(navController.currentBackStackEntry?.destination?.route)
+                .isEqualTo(PhotopickerDestinations.MEDIA_SET_GRID.route)
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+        }
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/categorygrid/CategoryGridViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/categorygrid/CategoryGridViewModelTest.kt
new file mode 100644
index 000000000..da9d3081e
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/categorygrid/CategoryGridViewModelTest.kt
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.categorygrid
+
+import android.net.Uri
+import android.os.Build
+import android.platform.test.annotations.EnableFlags
+import android.platform.test.flag.junit.SetFlagsRule
+import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SdkSuppress
+import androidx.test.filters.SmallTest
+import com.android.photopicker.core.configuration.provideTestConfigurationFlow
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.RegisteredEventClass
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.selection.SelectionImpl
+import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.providers.media.flags.Flags
+import com.google.common.truth.Truth.assertWithMessage
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import src.com.android.photopicker.features.categorygrid.data.TestCategoryDataServiceImpl
+
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@OptIn(ExperimentalCoroutinesApi::class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+@EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+class CategoryGridViewModelTest {
+
+    @get:Rule var setFlagsRule = SetFlagsRule()
+
+    val mediaItem =
+        Media.Image(
+            mediaId = "id",
+            pickerId = 1000L,
+            authority = "a",
+            mediaSource = MediaSource.LOCAL,
+            mediaUri =
+                Uri.EMPTY.buildUpon()
+                    .apply {
+                        scheme("content")
+                        authority("media")
+                        path("picker")
+                        path("a")
+                        path("id")
+                    }
+                    .build(),
+            glideLoadableUri =
+                Uri.EMPTY.buildUpon()
+                    .apply {
+                        scheme("content")
+                        authority("a")
+                        path("id")
+                    }
+                    .build(),
+            dateTakenMillisLong = 123456789L,
+            sizeInBytes = 1000L,
+            mimeType = "image/png",
+            standardMimeTypeExtension = 1,
+        )
+
+    val album =
+        Group.Album(
+            id = ALBUM_ID_VIDEOS,
+            pickerId = 1234L,
+            authority = "a",
+            displayName = "Videos",
+            coverUri =
+                Uri.EMPTY.buildUpon()
+                    .apply {
+                        scheme("content")
+                        authority("a")
+                        path("1234")
+                    }
+                    .build(),
+            dateTakenMillisLong = 12345678L,
+            coverMediaSource = MediaSource.LOCAL,
+        )
+
+    val updatedMediaItem =
+        mediaItem.copy(mediaItemAlbum = album, selectionSource = Telemetry.MediaLocation.ALBUM)
+
+    @Test
+    fun testCategoryGridItemClickedUpdatesSelection() {
+
+        runTest {
+            val selection =
+                SelectionImpl<Media>(
+                    scope = this.backgroundScope,
+                    configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
+                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData,
+                )
+
+            val featureManager =
+                FeatureManager(
+                    configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
+                    scope = this.backgroundScope,
+                    prefetchDataService = TestPrefetchDataService(),
+                    coreEventsConsumed = setOf<RegisteredEventClass>(),
+                    coreEventsProduced = setOf<RegisteredEventClass>(),
+                )
+
+            val events =
+                Events(
+                    scope = this.backgroundScope,
+                    provideTestConfigurationFlow(scope = this.backgroundScope),
+                    featureManager = featureManager,
+                )
+
+            val viewModel =
+                CategoryGridViewModel(
+                    this.backgroundScope,
+                    selection,
+                    TestCategoryDataServiceImpl(),
+                    TestDataServiceImpl(),
+                    events,
+                )
+
+            assertWithMessage("Unexpected selection start size")
+                .that(selection.snapshot().size)
+                .isEqualTo(0)
+
+            // Toggle the item into the selection
+            viewModel.handleAlbumMediaGridItemSelection(mediaItem, "", album)
+
+            // Wait for selection update.
+            advanceTimeBy(100)
+
+            // The selected media item gets updated with the Selectable interface values
+            assertWithMessage("Selection did not contain expected item")
+                .that(selection.snapshot())
+                .contains(updatedMediaItem)
+
+            // Toggle the item out of the selection
+            viewModel.handleAlbumMediaGridItemSelection(mediaItem, "", album)
+
+            advanceTimeBy(100)
+
+            assertWithMessage("Selection contains unexpected item")
+                .that(selection.snapshot())
+                .doesNotContain(updatedMediaItem)
+        }
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/categorygrid/data/CategoryDataServiceImplTest.kt b/photopicker/tests/src/com/android/photopicker/features/categorygrid/data/CategoryDataServiceImplTest.kt
new file mode 100644
index 000000000..0a7658074
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/categorygrid/data/CategoryDataServiceImplTest.kt
@@ -0,0 +1,420 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package src.com.android.photopicker.features.categorygrid.data
+
+import android.content.ContentResolver
+import android.content.Context
+import android.content.pm.PackageManager
+import android.net.Uri
+import android.os.CancellationSignal
+import android.os.Parcel
+import android.os.UserHandle
+import androidx.paging.PagingSource
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import com.android.photopicker.core.configuration.provideTestConfigurationFlow
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.user.UserProfile
+import com.android.photopicker.core.user.UserStatus
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.DataServiceImpl
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.TestMediaProvider
+import com.android.photopicker.data.TestNotificationServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+import com.android.photopicker.features.categorygrid.data.CategoryDataServiceImpl
+import com.google.common.truth.Truth.assertThat
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.toList
+import kotlinx.coroutines.flow.update
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.mock
+
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@OptIn(ExperimentalCoroutinesApi::class)
+class CategoryDataServiceImplTest {
+
+    companion object {
+        private fun createUserHandle(userId: Int = 0): UserHandle {
+            val parcel = Parcel.obtain()
+            parcel.writeInt(userId)
+            parcel.setDataPosition(0)
+            val userHandle = UserHandle(parcel)
+            parcel.recycle()
+            return userHandle
+        }
+
+        private val userProfilePrimary: UserProfile =
+            UserProfile(handle = createUserHandle(0), profileType = UserProfile.ProfileType.PRIMARY)
+
+        private val mediaSetsUpdateUri =
+            Uri.parse("content://media/picker_internal/v2/media_sets/update")
+
+        private val mediaSetContentUpdateUri =
+            Uri.parse("content://media/picker_internal/v2/media_set_contents/update")
+    }
+
+    private lateinit var testFeatureManager: FeatureManager
+    private lateinit var testContentProvider: TestMediaProvider
+    private lateinit var testContentResolver: ContentResolver
+    private lateinit var notificationService: TestNotificationServiceImpl
+    private lateinit var mediaProviderClient: MediaProviderClient
+    private lateinit var mockContext: Context
+    private lateinit var mockPackageManager: PackageManager
+    private lateinit var events: Events
+    private lateinit var userStatusFlow: MutableStateFlow<UserStatus>
+
+    @Before
+    fun setup() {
+        val scope = TestScope()
+        testContentProvider = TestMediaProvider()
+        testContentResolver = ContentResolver.wrap(testContentProvider)
+        notificationService = TestNotificationServiceImpl()
+        mediaProviderClient = MediaProviderClient()
+        mockContext = mock(Context::class.java)
+        mockPackageManager = mock(PackageManager::class.java)
+        val userStatus =
+            UserStatus(
+                activeUserProfile = userProfilePrimary,
+                allProfiles = listOf(userProfilePrimary),
+                activeContentResolver = testContentResolver,
+            )
+        testFeatureManager =
+            FeatureManager(
+                configuration = provideTestConfigurationFlow(scope = scope.backgroundScope),
+                scope = scope,
+                prefetchDataService = TestPrefetchDataService(),
+                registeredFeatures = setOf(),
+                coreEventsConsumed = setOf(),
+                coreEventsProduced = setOf(),
+            )
+        userStatusFlow = MutableStateFlow(userStatus)
+        events =
+            Events(
+                scope = scope.backgroundScope,
+                provideTestConfigurationFlow(scope.backgroundScope),
+                testFeatureManager,
+            )
+    }
+
+    @Test
+    fun testCategoryPagingSourceCacheReuse() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        advanceTimeBy(100)
+
+        val cancellationSignal = CancellationSignal()
+        val firstCategoryAndAlbumPagingSource: PagingSource<GroupPageKey, Group> =
+            categoryDataService.getCategories()
+        assertThat(firstCategoryAndAlbumPagingSource.invalid).isFalse()
+
+        // Check that the older paging source was cached and is reused.
+        val secondCategoryAndAlbumPagingSource: PagingSource<GroupPageKey, Group> =
+            categoryDataService.getCategories(cancellationSignal = cancellationSignal)
+        assertThat(secondCategoryAndAlbumPagingSource).isEqualTo(firstCategoryAndAlbumPagingSource)
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        firstCategoryAndAlbumPagingSource.invalidate()
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+    }
+
+    @Test
+    fun testCategoryPagingSourceInvalidation() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        val emissions = mutableListOf<List<Provider>>()
+        this.backgroundScope.launch { dataService.availableProviders.toList(emissions) }
+        advanceTimeBy(100)
+
+        assertThat(emissions.count()).isEqualTo(1)
+
+        val cancellationSignal = CancellationSignal()
+        val firstCategoryAndAlbumPagingSource: PagingSource<GroupPageKey, Group> =
+            categoryDataService.getCategories(cancellationSignal = cancellationSignal)
+        assertThat(firstCategoryAndAlbumPagingSource.invalid).isFalse()
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        updateActiveContentResolver()
+        advanceTimeBy(1000)
+
+        // Since the active user has changed, this should trigger a re-fetch of the active
+        // providers.
+        assertThat(emissions.count()).isEqualTo(2)
+
+        // Check that the old PagingSource has been invalidated.
+        assertThat(firstCategoryAndAlbumPagingSource.invalid).isTrue()
+
+        // Check that the CancellationSignal has been marked as cancelled.
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+
+        // Check that the new PagingSource instance is valid.
+        val secondCategoryAndAlbumPagingSource: PagingSource<GroupPageKey, Group> =
+            categoryDataService.getCategories()
+        assertThat(secondCategoryAndAlbumPagingSource.invalid).isFalse()
+    }
+
+    @Test
+    fun testMediaSetsPagingSourceCacheReuse() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        advanceTimeBy(100)
+
+        val cancellationSignal = CancellationSignal()
+        val firstMediaSetsPagingSource: PagingSource<GroupPageKey, Group.MediaSet> =
+            categoryDataService.getMediaSets(testContentProvider.parentCategory)
+        assertThat(firstMediaSetsPagingSource.invalid).isFalse()
+
+        // Check that the older paging source was cached and is reused.
+        val secondMediaSetsPagingSource: PagingSource<GroupPageKey, Group.MediaSet> =
+            categoryDataService.getMediaSets(testContentProvider.parentCategory, cancellationSignal)
+        assertThat(secondMediaSetsPagingSource).isEqualTo(firstMediaSetsPagingSource)
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        firstMediaSetsPagingSource.invalidate()
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+    }
+
+    @Test
+    fun testMediaSetsUpdateNotification() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        advanceTimeBy(100)
+
+        val firstMediaSetsPagingSource: PagingSource<GroupPageKey, Group.MediaSet> =
+            categoryDataService.getMediaSets(testContentProvider.parentCategory)
+        assertThat(firstMediaSetsPagingSource.invalid).isFalse()
+
+        val updateUri: Uri =
+            mediaSetsUpdateUri
+                .buildUpon()
+                .apply { appendPath(testContentProvider.parentCategory.id) }
+                .build()
+
+        // Dispatch update notification
+        notificationService.dispatchChangeToObservers(updateUri)
+        advanceTimeBy(100)
+
+        // Check that the first media paging source was marked as invalid
+        assertThat(firstMediaSetsPagingSource.invalid).isTrue()
+
+        val secondMediaSetsPagingSource: PagingSource<GroupPageKey, Group.MediaSet> =
+            categoryDataService.getMediaSets(testContentProvider.parentCategory)
+        assertThat(secondMediaSetsPagingSource).isNotEqualTo(firstMediaSetsPagingSource)
+        assertThat(secondMediaSetsPagingSource.invalid).isFalse()
+    }
+
+    @Test
+    fun testMediaSetsPagingSourceInvalidation() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        val emissions = mutableListOf<List<Provider>>()
+        this.backgroundScope.launch { dataService.availableProviders.toList(emissions) }
+        advanceTimeBy(100)
+
+        assertThat(emissions.count()).isEqualTo(1)
+
+        val cancellationSignal = CancellationSignal()
+        val firstMediaSetsPagingSource: PagingSource<GroupPageKey, Group.MediaSet> =
+            categoryDataService.getMediaSets(testContentProvider.parentCategory, cancellationSignal)
+        assertThat(firstMediaSetsPagingSource.invalid).isFalse()
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        updateActiveContentResolver()
+        advanceTimeBy(1000)
+
+        // Since the active user has changed, this should trigger a re-fetch of the active
+        // providers.
+        assertThat(emissions.count()).isEqualTo(2)
+
+        // Check that the old PagingSource has been invalidated.
+        assertThat(firstMediaSetsPagingSource.invalid).isTrue()
+
+        // Check that the CancellationSignal has been marked as cancelled.
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+
+        // Check that the new PagingSource instance is valid.
+        val secondMediaSetsPagingSource: PagingSource<GroupPageKey, Group.MediaSet> =
+            categoryDataService.getMediaSets(testContentProvider.parentCategory)
+        assertThat(secondMediaSetsPagingSource.invalid).isFalse()
+    }
+
+    @Test
+    fun testMediaSetContentsPagingSourceCacheReuse() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        advanceTimeBy(100)
+
+        val cancellationSignal = CancellationSignal()
+        val firstMediaSetContentsPagingSource: PagingSource<MediaPageKey, Media> =
+            categoryDataService.getMediaSetContents(testContentProvider.mediaSets[0])
+        assertThat(firstMediaSetContentsPagingSource.invalid).isFalse()
+
+        // Check that the older paging source was cached and is reused.
+        val secondMediaSetContentsPagingSource: PagingSource<MediaPageKey, Media> =
+            categoryDataService.getMediaSetContents(
+                testContentProvider.mediaSets[0].copy(),
+                cancellationSignal,
+            )
+        assertThat(secondMediaSetContentsPagingSource).isEqualTo(firstMediaSetContentsPagingSource)
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        firstMediaSetContentsPagingSource.invalidate()
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+    }
+
+    @Test
+    fun testMediaSetContentUpdateNotification() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        advanceTimeBy(100)
+
+        val firstMediaSetContentsPagingSource: PagingSource<MediaPageKey, Media> =
+            categoryDataService.getMediaSetContents(testContentProvider.mediaSets[0])
+        assertThat(firstMediaSetContentsPagingSource.invalid).isFalse()
+
+        val updateUri: Uri =
+            mediaSetContentUpdateUri
+                .buildUpon()
+                .apply { appendPath(testContentProvider.mediaSets[0].id) }
+                .build()
+        // Dispatch update notification
+        notificationService.dispatchChangeToObservers(updateUri)
+        advanceTimeBy(100)
+
+        // Check that the first media paging source was marked as invalid
+        assertThat(firstMediaSetContentsPagingSource.invalid).isTrue()
+
+        // Check that the new PagingSource instance is valid.
+        val secondMediaSetContentsPagingSource: PagingSource<MediaPageKey, Media> =
+            categoryDataService.getMediaSetContents(testContentProvider.mediaSets[0])
+        assertThat(secondMediaSetContentsPagingSource.invalid).isFalse()
+    }
+
+    @Test
+    fun testMediaSetContentsPagingSourceInvalidation() = runTest {
+        val dataService = getDataService(this)
+        val categoryDataService = getCategoryDataService(this, dataService)
+
+        val emissions = mutableListOf<List<Provider>>()
+        this.backgroundScope.launch { dataService.availableProviders.toList(emissions) }
+        advanceTimeBy(100)
+
+        assertThat(emissions.count()).isEqualTo(1)
+
+        val cancellationSignal = CancellationSignal()
+        val firstMediaSetContentsPagingSource: PagingSource<MediaPageKey, Media> =
+            categoryDataService.getMediaSetContents(
+                testContentProvider.mediaSets[0],
+                cancellationSignal,
+            )
+        assertThat(firstMediaSetContentsPagingSource.invalid).isFalse()
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        updateActiveContentResolver()
+        advanceTimeBy(1000)
+
+        // Since the active user has changed, this should trigger a re-fetch of the active
+        // providers.
+        assertThat(emissions.count()).isEqualTo(2)
+
+        // Check that the old PagingSource has been invalidated.
+        assertThat(firstMediaSetContentsPagingSource.invalid).isTrue()
+
+        // Check that the CancellationSignal has been marked as cancelled.
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+
+        // Check that the new PagingSource instance is valid.
+        val secondMediaSetContentsPagingSource: PagingSource<MediaPageKey, Media> =
+            categoryDataService.getMediaSetContents(testContentProvider.mediaSets[0])
+        assertThat(secondMediaSetContentsPagingSource.invalid).isFalse()
+    }
+
+    private fun getDataService(scope: TestScope): DataService {
+        return DataServiceImpl(
+            userStatus = userStatusFlow,
+            scope = scope.backgroundScope,
+            notificationService = notificationService,
+            mediaProviderClient = mediaProviderClient,
+            dispatcher = StandardTestDispatcher(scope.testScheduler),
+            config = provideTestConfigurationFlow(scope.backgroundScope),
+            featureManager = testFeatureManager,
+            appContext = mockContext,
+            events = events,
+            processOwnerHandle = userProfilePrimary.handle,
+        )
+    }
+
+    private fun getCategoryDataService(
+        scope: TestScope,
+        dataService: DataService,
+    ): CategoryDataService {
+        return CategoryDataServiceImpl(
+            dataService = dataService,
+            config = provideTestConfigurationFlow(scope.backgroundScope),
+            scope = scope.backgroundScope,
+            notificationService = notificationService,
+            mediaProviderClient = mediaProviderClient,
+            dispatcher = StandardTestDispatcher(scope.testScheduler),
+            events = events,
+        )
+    }
+
+    private fun updateActiveContentResolver() {
+        val updatedContentProvider = TestMediaProvider()
+        val updatedContentResolver: ContentResolver = ContentResolver.wrap(updatedContentProvider)
+        updatedContentProvider.providers =
+            mutableListOf(
+                Provider(
+                    authority = "local_authority",
+                    mediaSource = MediaSource.LOCAL,
+                    uid = 0,
+                    displayName = "",
+                ),
+                Provider(
+                    authority = "cloud_authority",
+                    mediaSource = MediaSource.REMOTE,
+                    uid = 0,
+                    displayName = "",
+                ),
+            )
+        userStatusFlow.update { it.copy(activeContentResolver = updatedContentResolver) }
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/categorygrid/data/TestCategoryDataServiceImpl.kt b/photopicker/tests/src/com/android/photopicker/features/categorygrid/data/TestCategoryDataServiceImpl.kt
new file mode 100644
index 000000000..1f172215b
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/categorygrid/data/TestCategoryDataServiceImpl.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package src.com.android.photopicker.features.categorygrid.data
+
+import android.os.CancellationSignal
+import androidx.paging.PagingSource
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.GroupPageKey
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.paging.FakeInMemoryCategoryPagingSource
+import com.android.photopicker.data.paging.FakeInMemoryMediaPagingSource
+import com.android.photopicker.data.paging.FakeInMemoryMediaSetPagingSource
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+
+class TestCategoryDataServiceImpl : CategoryDataService {
+
+    // Overrides for CategoryPagingSource
+    var categoryAlbumSize: Int = FakeInMemoryCategoryPagingSource.DEFAULT_SIZE
+    var categoryAlbumList: List<Group>? = null
+
+    // Overrides for AMediaPagingSource
+    var mediaSetSize: Int = FakeInMemoryMediaSetPagingSource.DEFAULT_SIZE
+    var mediaSetList: List<Group.MediaSet>? = null
+
+    var mediaSetContentSize: Int = FakeInMemoryMediaPagingSource.DEFAULT_SIZE
+    var mediaSetContentList: List<Media>? = null
+
+    override fun getCategories(
+        parentCategory: Group.Category?,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<GroupPageKey, Group> {
+        return categoryAlbumList?.let { FakeInMemoryCategoryPagingSource(it) }
+            ?: FakeInMemoryCategoryPagingSource(categoryAlbumSize)
+    }
+
+    override fun getMediaSets(
+        category: Group.Category,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<GroupPageKey, Group.MediaSet> {
+        return mediaSetList?.let { FakeInMemoryMediaSetPagingSource(it) }
+            ?: FakeInMemoryMediaSetPagingSource(mediaSetSize)
+    }
+
+    override fun getMediaSetContents(
+        mediaSet: Group.MediaSet,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> {
+        return mediaSetContentList?.let { FakeInMemoryMediaPagingSource(it) }
+            ?: FakeInMemoryMediaPagingSource(mediaSetContentSize)
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/categorygrid/inject/CategoryTestModule.kt b/photopicker/tests/src/com/android/photopicker/features/categorygrid/inject/CategoryTestModule.kt
new file mode 100644
index 000000000..8229efb46
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/categorygrid/inject/CategoryTestModule.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package src.com.android.photopicker.features.categorygrid.inject
+
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
+import com.android.photopicker.features.categorygrid.inject.CategoryActivityRetainedModule
+import com.android.photopicker.features.categorygrid.inject.CategoryEmbeddedServiceModule
+import dagger.Module
+import dagger.Provides
+import dagger.hilt.components.SingletonComponent
+import dagger.hilt.testing.TestInstallIn
+import javax.inject.Singleton
+import src.com.android.photopicker.features.categorygrid.data.TestCategoryDataServiceImpl
+
+@Module
+@TestInstallIn(
+    components = [SingletonComponent::class],
+    replaces = [CategoryActivityRetainedModule::class, CategoryEmbeddedServiceModule::class],
+)
+class CategoryTestModule {
+
+    @Singleton
+    @Provides
+    fun provideCategoryDataService(): CategoryDataService {
+        return TestCategoryDataServiceImpl()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt
index 759f16d98..24eacb5c6 100644
--- a/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt
@@ -209,7 +209,9 @@ class NavigationBarFeatureTest : PhotopickerFeatureBaseTest() {
 
     /* Verify Navigation Bar contains tabs for both photos and albums grid.*/
     @Test
-    fun testNavigationBarIsVisibleWithFeatureTabs() {
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testNavigationBarIsVisibleWithFeatureTabs_searchFlagOff() {
         // Explicitly create a new feature manager that uses the same production feature
         // registrations to ensure this test will fail if the default production behavior changes.
         featureManager =
@@ -253,9 +255,57 @@ class NavigationBarFeatureTest : PhotopickerFeatureBaseTest() {
         }
     }
 
+    /* Verify Navigation Bar contains tabs for both photos and category grid.*/
+    @Test
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testNavigationBarIsVisibleWithFeatureTabs_searchFlagOn() {
+        // Explicitly create a new feature manager that uses the same production feature
+        // registrations to ensure this test will fail if the default production behavior changes.
+        featureManager =
+            FeatureManager(
+                registeredFeatures = FeatureManager.KNOWN_FEATURE_REGISTRATIONS,
+                scope = testBackgroundScope,
+                prefetchDataService = TestPrefetchDataService(),
+                configuration = provideTestConfigurationFlow(scope = testBackgroundScope),
+            )
+
+        val photosGridNavButtonLabel =
+            getTestableContext()
+                .getResources()
+                .getString(R.string.photopicker_photos_nav_button_label)
+        val categoryGridNavButtonLabel =
+            getTestableContext()
+                .getResources()
+                .getString(R.string.photopicker_categories_nav_button_label)
+
+        testScope.runTest {
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            composeTestRule.waitForIdle()
+
+            // Photos Grid Nav Button and Category Grid Nav Button
+            composeTestRule
+                .onNode(hasText(photosGridNavButtonLabel))
+                .assertIsDisplayed()
+                .assert(hasClickAction())
+
+            composeTestRule
+                .onNode(hasText(categoryGridNavButtonLabel))
+                .assertIsDisplayed()
+                .assert(hasClickAction())
+        }
+    }
+
     /* Verify Navigation Bar when search flag disabled contains tabs for both photos and albums grid.*/
     @Test
-    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
     @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testNavigationBar_withSearchFlagDisabled_IsVisibleWithFeatureTabs() {
         val photosGridNavButtonLabel =
@@ -291,19 +341,19 @@ class NavigationBarFeatureTest : PhotopickerFeatureBaseTest() {
         }
     }
 
-    /* Verify Navigation Bar when search flag enabled contains tabs for both photos and albums grid.*/
+    /* Verify Navigation Bar when search flag enabled contains tabs for both photos and category grid.*/
     @Test
-    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
     @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     fun testNavigationBar_withSearchFlagEnabled_IsVisibleWithFeatureTabs() {
         val photosGridNavButtonLabel =
             getTestableContext()
                 .getResources()
                 .getString(R.string.photopicker_photos_nav_button_label)
-        val albumsGridNavButtonLabel =
+        val categoryGridNavButtonLabel =
             getTestableContext()
                 .getResources()
-                .getString(R.string.photopicker_albums_nav_button_label)
+                .getString(R.string.photopicker_categories_nav_button_label)
 
         testScope.runTest {
             composeTestRule.setContent {
@@ -323,7 +373,7 @@ class NavigationBarFeatureTest : PhotopickerFeatureBaseTest() {
                 .assert(hasClickAction())
 
             composeTestRule
-                .onNode(hasText(albumsGridNavButtonLabel))
+                .onNode(hasText(categoryGridNavButtonLabel))
                 .assertIsDisplayed()
                 .assert(hasClickAction())
         }
diff --git a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt
index 673d5f5d3..28ca56b55 100644
--- a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt
@@ -21,7 +21,11 @@ import android.content.ContentResolver
 import android.content.Context
 import android.content.Intent
 import android.content.pm.PackageManager
+import android.os.Build
 import android.os.UserManager
+import android.platform.test.annotations.DisableFlags
+import android.platform.test.annotations.EnableFlags
+import android.platform.test.flag.junit.SetFlagsRule
 import android.provider.MediaStore
 import android.test.mock.MockContentResolver
 import androidx.compose.ui.test.ExperimentalTestApi
@@ -35,6 +39,7 @@ import androidx.compose.ui.test.onFirst
 import androidx.compose.ui.test.performClick
 import androidx.compose.ui.test.performTouchInput
 import androidx.compose.ui.test.swipeLeft
+import androidx.test.filters.SdkSuppress
 import com.android.photopicker.R
 import com.android.photopicker.core.ActivityModule
 import com.android.photopicker.core.ApplicationModule
@@ -65,6 +70,7 @@ import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
 import com.android.photopicker.util.test.MockContentProviderWrapper
 import com.android.photopicker.util.test.whenever
+import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -101,6 +107,7 @@ import org.mockito.MockitoAnnotations
 )
 @HiltAndroidTest
 @OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
 class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
 
     /* Hilt's rule needs to come first to ensure the DI container is setup for the test. */
@@ -108,6 +115,7 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
     @get:Rule(order = 1)
     val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
     @get:Rule(order = 2) val glideRule = GlideTestRule()
+    @get:Rule(order = 3) var setFlagsRule = SetFlagsRule()
 
     /* Setup dependencies for the UninstallModules for the test class. */
     @Module @InstallIn(SingletonComponent::class) class TestModule : PhotopickerTestModule()
@@ -291,7 +299,8 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
     }
 
     @Test
-    fun testSwipeLeftToNavigateToAlbumGrid() {
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSwipeLeftToNavigateToAlbumGrid_searchFlagOff() {
         testScope.runTest {
             composeTestRule.setContent {
                 callPhotopickerMain(
@@ -322,6 +331,39 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
         }
     }
 
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSwipeLeftToNavigateToCategoryGrid_searchFlagOn() {
+        testScope.runTest {
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
+                .onFirst()
+                .performTouchInput { swipeLeft() }
+            composeTestRule.waitForIdle()
+            val route = navController.currentBackStackEntry?.destination?.route
+            assertWithMessage("Expected swipe to navigate to Album Grid for category")
+                .that(route)
+                .isEqualTo(PhotopickerDestinations.ALBUM_GRID.route)
+        }
+    }
+
     @Test
     fun testShowsEmptyStateWhenEmpty() {
 
diff --git a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt
index bc9a2bd59..16462ba06 100644
--- a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt
@@ -160,7 +160,8 @@ class PhotoGridViewModelTest {
                 resources.getDrawable(R.drawable.android, /* theme= */ null)
             }
             whenever(mockUserManager.getProfileLabel()) { PLATFORM_PROVIDED_PROFILE_LABEL }
-            whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIMARY)) {
+            whenever(mockUserManager.getUserProperties(USER_HANDLE_PRIMARY))
+            @JvmSerializableLambda {
                 UserProperties.Builder().build()
             }
         }
diff --git a/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt
index 6377bec0e..1d4da0cbd 100644
--- a/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt
@@ -225,7 +225,8 @@ class PreviewViewModelTest {
         mockSystemService(mockContext, UserManager::class.java) { mockUserManager }
 
         if (SdkLevel.isAtLeastV()) {
-            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java))) {
+            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java)))
+            @JvmSerializableLambda {
                 UserProperties.Builder().build()
             }
             whenever(mockUserManager.getUserBadge()) {
diff --git a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt
index f86926090..10fd756cd 100644
--- a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt
@@ -261,7 +261,7 @@ class ProfileSelectorFeatureTest : PhotopickerFeatureBaseTest() {
             whenever(mockUserManager.isQuietModeEnabled(otherProfile)) { true }
             whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { userHandle }
             whenever(mockUserManager.getProfileParent(otherProfile)) { userHandle }
-            whenever(mockUserManager.getUserProperties(otherProfile)) {
+            whenever(mockUserManager.getUserProperties(otherProfile)) @JvmSerializableLambda {
                 UserProperties.Builder().setShowInQuietMode(SHOW_IN_QUIET_MODE_HIDDEN).build()
             }
             //
diff --git a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt
index a615b363c..5f52fe3d6 100644
--- a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt
@@ -62,7 +62,7 @@ import org.junit.runner.RunWith
 import org.mockito.Mock
 import org.mockito.Mockito.any
 import org.mockito.Mockito.anyInt
-import org.mockito.Mockito.mock
+import org.mockito.Mockito.eq
 import org.mockito.MockitoAnnotations
 
 @SmallTest
@@ -70,6 +70,17 @@ import org.mockito.MockitoAnnotations
 @OptIn(ExperimentalCoroutinesApi::class)
 class ProfileSelectorViewModelTest {
 
+    /**
+     * Class that exposes the @hide api [targetUserId] in order to supply proper values for
+     * reflection based code that is inspecting this field.
+     *
+     * @property targetUserId
+     */
+    private class ReflectedResolveInfo(@JvmField val targetUserId: Int) : ResolveInfo() {
+
+        override fun isCrossProfileIntentForwarderActivity(): Boolean = true
+    }
+
     @Mock lateinit var mockContext: Context
     @Mock lateinit var mockUserManager: UserManager
     @Mock lateinit var mockPackageManager: PackageManager
@@ -142,7 +153,9 @@ class ProfileSelectorViewModelTest {
         }
 
         if (SdkLevel.isAtLeastV()) {
-            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java))) {
+            whenever(
+                mockUserManager.getUserProperties(any(UserHandle::class.java))
+            ) @JvmSerializableLambda {
                 UserProperties.Builder()
                     .setCrossProfileContentSharingStrategy(
                         UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT
@@ -157,9 +170,14 @@ class ProfileSelectorViewModelTest {
             }
             whenever(mockUserManager.getProfileLabel()) { "label" }
         }
-        val mockResolveInfo = mock(ResolveInfo::class.java)
-        whenever(mockResolveInfo.isCrossProfileIntentForwarderActivity()) { true }
-        whenever(mockPackageManager.queryIntentActivities(any(Intent::class.java), anyInt())) {
+        val mockResolveInfo = ReflectedResolveInfo(USER_ID_MANAGED)
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                eq(USER_HANDLE_PRIMARY),
+            )
+        ) {
             listOf(mockResolveInfo)
         }
     }
diff --git a/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt b/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt
index e69173012..b30286412 100644
--- a/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt
@@ -18,9 +18,12 @@ package com.android.photopicker.features.profileselector
 
 import android.content.ContentResolver
 import android.content.Context
+import android.content.Intent
 import android.content.pm.PackageManager
+import android.content.pm.ResolveInfo
 import android.os.UserHandle
 import android.os.UserManager
+import android.provider.MediaStore
 import android.test.mock.MockContentResolver
 import androidx.compose.ui.test.ExperimentalTestApi
 import androidx.compose.ui.test.assert
@@ -73,6 +76,9 @@ import kotlinx.coroutines.test.runTest
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
+import org.mockito.ArgumentMatchers.any
+import org.mockito.ArgumentMatchers.anyInt
+import org.mockito.ArgumentMatchers.eq
 import org.mockito.Mock
 import org.mockito.MockitoAnnotations
 
@@ -87,6 +93,17 @@ import org.mockito.MockitoAnnotations
 @OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
 class SwitchProfileBannerTest : PhotopickerFeatureBaseTest() {
 
+    /**
+     * Class that exposes the @hide api [targetUserId] in order to supply proper values for
+     * reflection based code that is inspecting this field.
+     *
+     * @property targetUserId
+     */
+    private class ReflectedResolveInfo(@JvmField val targetUserId: Int) : ResolveInfo() {
+
+        override fun isCrossProfileIntentForwarderActivity(): Boolean = true
+    }
+
     companion object {
         val USER_ID_PRIMARY: Int = 0
         val USER_HANDLE_PRIMARY: UserHandle = UserHandle.of(USER_ID_PRIMARY)
@@ -147,6 +164,18 @@ class SwitchProfileBannerTest : PhotopickerFeatureBaseTest() {
         whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { USER_HANDLE_PRIMARY }
         whenever(mockUserManager.getProfileParent(USER_HANDLE_PRIMARY)) { null }
 
+        // Fake for a CrossProfileIntentForwarderActivity for the managed profile
+        val resolveInfoForPrimaryUser = ReflectedResolveInfo(USER_HANDLE_PRIMARY.getIdentifier())
+        whenever(
+            mockPackageManager.queryIntentActivitiesAsUser(
+                any(Intent::class.java),
+                anyInt(),
+                eq(USER_HANDLE_MANAGED),
+            )
+        ) {
+            listOf(resolveInfoForPrimaryUser)
+        }
+
         val resources = getTestableContext().getResources()
         if (SdkLevel.isAtLeastV()) {
             whenever(mockUserManager.getProfileLabel())
@@ -159,6 +188,9 @@ class SwitchProfileBannerTest : PhotopickerFeatureBaseTest() {
                     resources.getString(R.string.photopicker_profile_managed_label),
                 )
         }
+
+        // Ensure an intent is set for cross profile checking
+        configurationManager.get().setIntent(Intent(MediaStore.ACTION_PICK_IMAGES))
     }
 
     @Test
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt
index 92da23322..11c08e9c4 100644
--- a/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt
@@ -19,6 +19,7 @@ package com.android.photopicker.features.search
 import android.content.ContentResolver
 import android.content.Context
 import android.content.pm.PackageManager
+import android.net.Uri
 import android.os.CancellationSignal
 import android.os.Parcel
 import android.os.UserHandle
@@ -65,6 +66,9 @@ import org.mockito.Mockito.mock
 class SearchDataServiceImplTest {
 
     companion object {
+        private val searchMediaUpdateUri =
+            Uri.parse("content://media/picker_internal/v2/search_media/update")
+
         private fun createUserHandle(userId: Int = 0): UserHandle {
             val parcel = Parcel.obtain()
             parcel.writeInt(userId)
@@ -202,4 +206,67 @@ class SearchDataServiceImplTest {
             searchDataService.getSearchResults(searchText)
         assertThat(secondSearchResultsPagingSource.invalid).isFalse()
     }
+
+    @Test
+    fun testOnUpdateSearchResultsNotification() = runTest {
+        val userStatusFlow: MutableStateFlow<UserStatus> = MutableStateFlow(userStatus)
+        events =
+            Events(
+                scope = this.backgroundScope,
+                provideTestConfigurationFlow(this.backgroundScope),
+                testFeatureManager,
+            )
+
+        val dataService: DataService =
+            DataServiceImpl(
+                userStatus = userStatusFlow,
+                scope = this.backgroundScope,
+                notificationService = notificationService,
+                mediaProviderClient = mediaProviderClient,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                config = provideTestConfigurationFlow(this.backgroundScope),
+                featureManager = testFeatureManager,
+                appContext = mockContext,
+                events = events,
+                processOwnerHandle = userProfilePrimary.handle,
+            )
+
+        val searchDataService: SearchDataService =
+            SearchDataServiceImpl(
+                dataService = dataService,
+                userStatus = userStatusFlow,
+                photopickerConfiguration = provideTestConfigurationFlow(this.backgroundScope),
+                scope = this.backgroundScope,
+                notificationService = notificationService,
+                mediaProviderClient = mediaProviderClient,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                events = events,
+            )
+
+        advanceTimeBy(100)
+
+        val searchText: String = "search_query"
+        val cancellationSignal = CancellationSignal()
+        val firstSearchResultsPagingSource: PagingSource<MediaPageKey, Media> =
+            searchDataService.getSearchResults(searchText = searchText, cancellationSignal)
+        assertThat(firstSearchResultsPagingSource.invalid).isFalse()
+
+        val searchResultsUpdateUri: Uri =
+            searchMediaUpdateUri
+                .buildUpon()
+                .apply { appendPath(testContentProvider.searchRequestId.toString()) }
+                .build()
+        // Send an update notification
+        notificationService.dispatchChangeToObservers(searchResultsUpdateUri)
+        advanceTimeBy(100)
+
+        // Check that the first media paging source was marked as invalid
+        assertThat(firstSearchResultsPagingSource.invalid).isTrue()
+
+        // Check that the a new PagingSource instance was created which is still valid
+        val secondSearchResultsPagingSource: PagingSource<MediaPageKey, Media> =
+            searchDataService.getSearchResults(searchText = searchText, cancellationSignal)
+        assertThat(secondSearchResultsPagingSource).isNotEqualTo(firstSearchResultsPagingSource)
+        assertThat(secondSearchResultsPagingSource.invalid).isFalse()
+    }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt
index a0aa0fdba..921b6077d 100644
--- a/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt
@@ -59,7 +59,7 @@ import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
-import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.GlobalSearchState
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
 import com.android.providers.media.flags.Flags
@@ -81,6 +81,7 @@ import kotlinx.coroutines.async
 import kotlinx.coroutines.runBlocking
 import kotlinx.coroutines.test.StandardTestDispatcher
 import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.advanceTimeBy
 import kotlinx.coroutines.test.runTest
 import org.junit.Before
 import org.junit.Rule
@@ -96,7 +97,7 @@ import org.mockito.MockitoAnnotations
     ViewModelModule::class,
 )
 @HiltAndroidTest
-@SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
 @OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
 class SearchFeatureTest : PhotopickerFeatureBaseTest() {
     /* Hilt's rule needs to come first to ensure the DI container is setup for the test. */
@@ -139,7 +140,7 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
             PrefetchResultKey.SEARCH_STATE to
                 runBlocking {
                     async {
-                        return@async SearchEnabledState.ENABLED
+                        return@async GlobalSearchState.ENABLED
                     }
                 }
         )
@@ -360,6 +361,7 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 .assertIsDisplayed()
                 .performClick()
             composeTestRule.waitForIdle()
+            advanceTimeBy(1000)
 
             // Asserts search view page with its placeholder text displayed
             composeTestRule
@@ -378,6 +380,7 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 .assert(hasClickAction())
                 .performClick()
             composeTestRule.waitForIdle()
+            advanceTimeBy(1000)
 
             // Search bar with Search text placeholder is displayed
             composeTestRule
@@ -403,6 +406,7 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 .onNode(hasText(resources.getString(R.string.photopicker_search_placeholder_text)))
                 .performClick()
             composeTestRule.waitForIdle()
+            advanceTimeBy(1000)
 
             // Input test query in search bar and verify it is displayed
             val testQuery = "testquery"
@@ -423,6 +427,7 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 )
                 .performClick()
             composeTestRule.waitForIdle()
+            advanceTimeBy(1000)
 
             // Make sure test query is cleared and Search text placeholder is displayed
             composeTestRule.onNodeWithText(testQuery).assertIsNotDisplayed()
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchSuggestionCacheTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchSuggestionCacheTest.kt
new file mode 100644
index 000000000..d86318d88
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchSuggestionCacheTest.kt
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import android.net.Uri
+import com.android.photopicker.data.model.Icon
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.features.search.SearchViewModel.Companion.ZERO_STATE_SEARCH_QUERY
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+class SearchSuggestionCacheTest {
+    @Test
+    fun testUpdateHistorySuggestion() {
+        val suggestionsCache: SearchSuggestionCache = SearchSuggestionCache()
+
+        val searchSuggestion1 =
+            SearchSuggestion(
+                mediaSetId = null,
+                authority = null,
+                displayText = "Sunny",
+                type = SearchSuggestionType.HISTORY,
+                icon = null,
+            )
+
+        // Update history with a duplicate search text query
+        var actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        suggestionsCache.updateHistorySuggestion("Sunny")
+        actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNotNull()
+        assertThat(listOf(searchSuggestion1)).isEqualTo(actualSuggestionsOrder!!.toList())
+
+        val searchSuggestion2 =
+            SearchSuggestion(
+                mediaSetId = "media-set-id-2",
+                authority = "cloud.authority",
+                displayText = "Vacation",
+                type = SearchSuggestionType.ALBUM,
+                icon = null,
+            )
+
+        // Update history with a duplicate search history suggestion query
+        suggestionsCache.updateHistorySuggestion(searchSuggestion2)
+        actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNotNull()
+        assertThat(actualSuggestionsOrder!!.toList())
+            .isEqualTo(
+                listOf(
+                    searchSuggestion2.copy(type = SearchSuggestionType.HISTORY),
+                    searchSuggestion1,
+                )
+            )
+    }
+
+    @Test
+    fun testUpdateHistoryWithDuplicateSuggestion() {
+        val suggestionsCache: SearchSuggestionCache = SearchSuggestionCache()
+
+        val searchSuggestion1 =
+            SearchSuggestion(
+                mediaSetId = "media-set-id-1",
+                authority = "cloud.authority",
+                displayText = "Beach",
+                type = SearchSuggestionType.HISTORY,
+                icon = null,
+            )
+        val searchSuggestion2 =
+            SearchSuggestion(
+                mediaSetId = null,
+                authority = null,
+                displayText = "Sunny",
+                type = SearchSuggestionType.HISTORY,
+                icon = null,
+            )
+        val searchSuggestion3 =
+            SearchSuggestion(
+                mediaSetId = "media-set-id-3",
+                authority = "cloud.authority",
+                displayText = "Vacation",
+                type = SearchSuggestionType.ALBUM,
+                icon = null,
+            )
+
+        suggestionsCache.addSuggestions(
+            ZERO_STATE_SEARCH_QUERY,
+            SearchSuggestions(
+                listOf(searchSuggestion1, searchSuggestion2),
+                listOf(searchSuggestion3),
+            ),
+        )
+
+        // Add search suggestions to cache
+        var actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNotNull()
+        assertThat(actualSuggestionsOrder!!.toList())
+            .isEqualTo(listOf(searchSuggestion1, searchSuggestion2, searchSuggestion3))
+
+        // Update history with a duplicate search text query
+        suggestionsCache.updateHistorySuggestion("Sunny")
+        actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNotNull()
+        assertThat(actualSuggestionsOrder!!.toList())
+            .isEqualTo(listOf(searchSuggestion2, searchSuggestion1, searchSuggestion3))
+
+        // Update history with a duplicate search history suggestion query
+        suggestionsCache.updateHistorySuggestion(searchSuggestion1)
+        actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNotNull()
+        assertThat(actualSuggestionsOrder!!.toList())
+            .isEqualTo(listOf(searchSuggestion1, searchSuggestion2, searchSuggestion3))
+
+        // Update history with a duplicate search album suggestion query
+        suggestionsCache.updateHistorySuggestion(searchSuggestion3)
+        actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNotNull()
+        assertThat(actualSuggestionsOrder!!.toList())
+            .isEqualTo(
+                listOf(
+                    searchSuggestion3.copy(type = SearchSuggestionType.HISTORY),
+                    searchSuggestion1,
+                    searchSuggestion2,
+                    searchSuggestion3,
+                )
+            )
+    }
+
+    @Test
+    fun testUpdateHistoryWithFaceSuggestion() {
+        val suggestionsCache = SearchSuggestionCache()
+
+        val faceSearchSuggestion =
+            SearchSuggestion(
+                mediaSetId = "media-set-id-1",
+                authority = "cloud.authority",
+                displayText = null,
+                type = SearchSuggestionType.FACE,
+                icon = Icon(uri = Uri.parse(""), mediaSource = MediaSource.LOCAL),
+            )
+
+        // Try to add history suggestion to cache
+        suggestionsCache.updateHistorySuggestion(faceSearchSuggestion)
+
+        // Check that is wasn't added because it has no display text
+        var actualSuggestionsOrder = suggestionsCache.getSuggestions(ZERO_STATE_SEARCH_QUERY)
+        assertThat(actualSuggestionsOrder).isNull()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt
index 94e336848..fc9836914 100644
--- a/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt
@@ -32,6 +32,8 @@ import com.android.photopicker.data.TestDataServiceImpl
 import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.TestSearchDataServiceImpl
 import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.data.model.Provider
 import com.android.photopicker.features.search.model.SearchSuggestion
 import com.android.photopicker.features.search.model.SearchSuggestionType
 import com.android.providers.media.flags.Flags
@@ -71,15 +73,16 @@ class SearchViewModelTest {
                     this.backgroundScope,
                     StandardTestDispatcher(this.testScheduler),
                     TestSearchDataServiceImpl(),
+                    TestDataServiceImpl(),
                     selection,
                     events,
                     configurationManager,
                 )
             viewModel.fetchSuggestions("")
             advanceTimeBy(1000)
-            val suggestionLists = viewModel.suggestionLists.value
+            val suggestionLists = viewModel.searchSuggestions.value
             assertWithMessage("Unexpected total suggestions list size not correct")
-                .that(viewModel.suggestionLists.value.totalSuggestions)
+                .that(viewModel.searchSuggestions.value.totalSuggestions)
                 .isEqualTo(4)
             assertWithMessage("Unexpected history suggestions list size")
                 .that(suggestionLists.history.size)
@@ -111,13 +114,15 @@ class SearchViewModelTest {
                     this.backgroundScope,
                     StandardTestDispatcher(this.testScheduler),
                     TestSearchDataServiceImpl(),
+                    TestDataServiceImpl(),
                     selection,
                     events,
                     configurationManager,
                 )
+            advanceTimeBy(1000)
             viewModel.fetchSuggestions("abc")
             advanceTimeBy(1000)
-            val suggestionLists = viewModel.suggestionLists.value
+            val suggestionLists = viewModel.searchSuggestions.value
             assertWithMessage("Unexpected total suggestions list size not correct")
                 .that(suggestionLists.totalSuggestions)
                 .isEqualTo(4)
@@ -150,6 +155,7 @@ class SearchViewModelTest {
                 this.backgroundScope,
                 StandardTestDispatcher(this.testScheduler),
                 TestSearchDataServiceImpl(),
+                TestDataServiceImpl(),
                 selection,
                 events,
                 configurationManager,
@@ -178,6 +184,7 @@ class SearchViewModelTest {
                 this.backgroundScope,
                 StandardTestDispatcher(this.testScheduler),
                 TestSearchDataServiceImpl(),
+                TestDataServiceImpl(),
                 selection,
                 events,
                 configurationManager,
@@ -213,6 +220,7 @@ class SearchViewModelTest {
                 this.backgroundScope,
                 StandardTestDispatcher(this.testScheduler),
                 TestSearchDataServiceImpl(),
+                TestDataServiceImpl(),
                 selection,
                 events,
                 configurationManager,
@@ -224,6 +232,87 @@ class SearchViewModelTest {
             .isEqualTo(viewModel.searchState.value)
     }
 
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun onSearch_suggestionsAreCached() = runTest {
+        provideSelectionEvents(this.backgroundScope)
+        val configurationManager =
+            ConfigurationManager(
+                runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                scope = this.backgroundScope,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                deviceConfigProxy,
+                generatePickerSessionId(),
+            )
+        val viewModel =
+            SearchViewModel(
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                TestSearchDataServiceImpl(),
+                TestDataServiceImpl(),
+                selection,
+                events,
+                configurationManager,
+            )
+        advanceTimeBy(1000)
+        val query = "test query"
+        assertWithMessage("Initial Cached suggestions is not empty")
+            .that(viewModel.getCachedSuggestions().getSuggestions(query))
+            .isNull()
+        viewModel.fetchSuggestions(query)
+        advanceTimeBy(1000)
+        assertWithMessage("After fetchSuggestions UI cached suggestions is Null")
+            .that(viewModel.getCachedSuggestions().getSuggestions(query))
+            .isNotNull()
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun onProvidersChange_cachedSuggestionsCleared() = runTest {
+        provideSelectionEvents(this.backgroundScope)
+        val configurationManager =
+            ConfigurationManager(
+                runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                scope = this.backgroundScope,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                deviceConfigProxy,
+                generatePickerSessionId(),
+            )
+        val testDataService = TestDataServiceImpl()
+        val viewModel =
+            SearchViewModel(
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                TestSearchDataServiceImpl(),
+                testDataService,
+                selection,
+                events,
+                configurationManager,
+            )
+
+        advanceTimeBy(1000)
+        val query = "test query"
+        viewModel.fetchSuggestions(query)
+        advanceTimeBy(1000)
+        assertWithMessage("UI cached suggestions is Null")
+            .that(viewModel.getCachedSuggestions().getSuggestions(query))
+            .isNotNull()
+        testDataService.setAvailableProviders(
+            listOf(
+                Provider(
+                    authority = "local_authority",
+                    mediaSource = MediaSource.LOCAL,
+                    uid = 1,
+                    displayName = "Local Provider",
+                )
+            )
+        )
+        advanceTimeBy(1000)
+        assertWithMessage("After active provider change cached suggestions is not cleared")
+            .that(viewModel.getCachedSuggestions().getSuggestions(query))
+            .isNull()
+    }
+
     private fun provideSelectionEvents(scope: CoroutineScope) {
         selection =
             SelectionImpl<Media>(
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt b/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt
index f89933d7f..3c42de604 100644
--- a/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt
@@ -19,13 +19,15 @@ package com.android.photopicker.data
 import android.net.Uri
 import android.os.CancellationSignal
 import androidx.paging.PagingSource
+import com.android.photopicker.data.model.Icon
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.paging.FakeInMemoryMediaPagingSource
 import com.android.photopicker.features.search.data.SearchDataService
-import com.android.photopicker.features.search.model.SearchEnabledState
 import com.android.photopicker.features.search.model.SearchSuggestion
 import com.android.photopicker.features.search.model.SearchSuggestionType
+import com.android.photopicker.features.search.model.UserSearchStateInfo
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
 
@@ -37,8 +39,8 @@ class TestSearchDataServiceImpl() : SearchDataService {
     var mediaSetSize: Int = FakeInMemoryMediaPagingSource.DEFAULT_SIZE
     var mediaList: List<Media>? = null
 
-    override val isSearchEnabled: StateFlow<SearchEnabledState> =
-        MutableStateFlow(SearchEnabledState.ENABLED)
+    override val userSearchStateInfo: StateFlow<UserSearchStateInfo> =
+        MutableStateFlow(UserSearchStateInfo(listOf("test_provider")))
 
     override suspend fun getSearchSuggestions(
         prefix: String,
@@ -48,7 +50,13 @@ class TestSearchDataServiceImpl() : SearchDataService {
         return listOf(
             SearchSuggestion("1", "authority", "France", SearchSuggestionType.LOCATION, null),
             SearchSuggestion("2", "authority", "Favorites", SearchSuggestionType.ALBUM, null),
-            SearchSuggestion("3", "authority", "Emma", SearchSuggestionType.FACE, Uri.parse("xyz")),
+            SearchSuggestion(
+                "3",
+                "authority",
+                "Emma",
+                SearchSuggestionType.FACE,
+                Icon(Uri.parse("xyz"), MediaSource.LOCAL),
+            ),
             SearchSuggestion(null, "authority", "paris", SearchSuggestionType.HISTORY, null),
         )
     }
diff --git a/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt b/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt
index 264f09021..e26a717ac 100644
--- a/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt
+++ b/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt
@@ -39,10 +39,12 @@ import com.android.photopicker.core.selection.SelectionStrategy
 import com.android.photopicker.core.selection.SelectionStrategy.Companion.determineSelectionStrategy
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.PrefetchDataService
 import com.android.photopicker.data.TestDataServiceImpl
 import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
+import com.android.photopicker.features.categorygrid.data.CategoryDataService
 import com.android.photopicker.features.search.data.SearchDataService
 import dagger.Lazy
 import dagger.Module
@@ -104,6 +106,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
         userMonitor: Lazy<UserMonitor>,
         dataService: Lazy<DataService>,
         searchDataService: Lazy<SearchDataService>,
+        categoryDataService: Lazy<CategoryDataService>,
         events: Lazy<Events>,
     ): EmbeddedViewModelFactory {
         val embeddedViewModelFactory =
@@ -113,6 +116,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
                 bannerManager,
                 dataService,
                 searchDataService,
+                categoryDataService,
                 events,
                 featureManager,
                 selection,
@@ -231,6 +235,12 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
         )
     }
 
+    @Singleton
+    @Provides
+    fun createMediaProviderClient(): MediaProviderClient {
+        return MediaProviderClient()
+    }
+
     @Singleton
     @Provides
     fun createPrefetchDataService(): PrefetchDataService {
diff --git a/photopicker/tests/src/com/android/photopicker/util/HierarchicalFocusCoordinatorTest.kt b/photopicker/tests/src/com/android/photopicker/util/HierarchicalFocusCoordinatorTest.kt
new file mode 100644
index 000000000..0e0cb82d5
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/util/HierarchicalFocusCoordinatorTest.kt
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import androidx.compose.foundation.focusable
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.size
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.MutableState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.focus.focusRequester
+import androidx.compose.ui.focus.onFocusChanged
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.unit.dp
+import org.junit.Assert
+import org.junit.Rule
+import org.junit.Test
+
+class HierarchicalFocusCoordinatorTest {
+    @get:Rule val rule = createComposeRule()
+
+    @Test fun basic_OnFocusChange_works_1_of_3() = basic_OnFocusChange_works(0, 3)
+
+    @Test fun basic_OnFocusChange_works_2_of_5() = basic_OnFocusChange_works(1, 5)
+
+    @Test fun basic_OnFocusChange_works_4_of_4() = basic_OnFocusChange_works(3, 4)
+
+    private fun basic_OnFocusChange_works(selected: Int, numItems: Int) {
+        var focused = BooleanArray(numItems)
+
+        rule.setContent {
+            repeat(numItems) { ix ->
+                HierarchicalFocusCoordinator({ ix == selected }) {
+                    ActiveFocusListener(onFocusChanged = { focused[ix] = it })
+                }
+            }
+        }
+
+        rule.runOnIdle { checkFocus(selected, focused) }
+    }
+
+    @Test fun basic_selection_works_1_of_3() = basic_selection_works(0, 3)
+
+    @Test fun basic_selection_works_2_of_5() = basic_selection_works(1, 5)
+
+    @Test fun basic_selection_works_4_of_4() = basic_selection_works(3, 4)
+
+    private fun basic_selection_works(selected: Int, numItems: Int) {
+        var focused = BooleanArray(numItems)
+
+        rule.setContent {
+            Box {
+                repeat(numItems) { ix ->
+                    HierarchicalFocusCoordinator({ ix == selected }) {
+                        FocusableTestItem { focused[ix] = it }
+                    }
+                }
+            }
+        }
+
+        rule.runOnIdle { checkFocus(selected, focused) }
+    }
+
+    @Test fun nested_selection_initial() = nested_selection_works(0) { _, _ -> }
+
+    @Test fun nested_selection_switch_top() = nested_selection_works(3) { top, _ -> top.value = 1 }
+
+    @Test
+    fun nested_selection_switch_bottom() =
+        nested_selection_works(1) { _, bottom ->
+            bottom[0].value = 1
+            bottom[1].value = 2
+            bottom[2].value = 0
+        }
+
+    @Test
+    fun nested_selection_switch_both() =
+        nested_selection_works(5) { top, bottom ->
+            bottom[0].value = 1
+            bottom[1].value = 2
+            bottom[2].value = 0
+            top.value = 1
+        }
+
+    /*
+     * We have 3 top FocusControl groups, each having 3 bottom FocusControl groups, and the
+     * leaf focusable items are numbered 0 to 8
+     *
+     * *------*---------*---*
+     * |      | Bottom0 | 0 |
+     * | Top0 | Bottom1 | 1 |
+     * |      | Bottom3 | 2 |
+     * *------*---------*---*
+     * |      | Bottom0 | 3 |
+     * | Top1 | Bottom1 | 4 |
+     * |      | Bottom3 | 5 |
+     * *------*---------*---*
+     * |      | Bottom0 | 6 |
+     * | Top2 | Bottom1 | 7 |
+     * |      | Bottom3 | 8 |
+     * *------*---------*---*
+     */
+    private fun nested_selection_works(
+        expectedSelected: Int,
+        act: (MutableState<Int>, Array<MutableState<Int>>) -> Unit,
+    ) {
+        val numItems = 3
+        var focused = BooleanArray(numItems * numItems)
+        val topSelected = mutableStateOf(0)
+        val bottomSelected = Array<MutableState<Int>>(numItems) { mutableStateOf(0) }
+
+        rule.setContent {
+            Box {
+                repeat(numItems) { topIx ->
+                    HierarchicalFocusCoordinator({ topIx == topSelected.value }) {
+                        Box {
+                            repeat(numItems) { bottomIx ->
+                                HierarchicalFocusCoordinator({
+                                    bottomIx == bottomSelected[topIx].value
+                                }) {
+                                    FocusableTestItem { focused[topIx * numItems + bottomIx] = it }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        rule.runOnIdle { act(topSelected, bottomSelected) }
+
+        rule.runOnIdle { checkFocus(expectedSelected, focused) }
+    }
+
+    @Test
+    public fun release_focus_works() {
+        val selected = mutableStateOf(0)
+        var focused = false
+        rule.setContent {
+            Box(Modifier.focusable()) {
+                HierarchicalFocusCoordinator({ selected.value == 0 }) {
+                    FocusableTestItem { focused = it }
+                }
+                HierarchicalFocusCoordinator({ selected.value == 1 }) {
+                    // Nothing to see here
+                }
+            }
+        }
+
+        rule.runOnIdle {
+            Assert.assertTrue(focused)
+
+            // Select the "empty tab"
+            selected.value = 1
+        }
+
+        rule.runOnIdle { Assert.assertFalse(focused) }
+    }
+
+    @Test
+    public fun add_focusable_works() {
+        var show by mutableStateOf(false)
+        var focused = false
+        rule.setContent {
+            Box {
+                HierarchicalFocusCoordinator({ true }) {
+                    if (show) {
+                        FocusableTestItem { focused = it }
+                    }
+                }
+            }
+        }
+
+        rule.runOnIdle { show = true }
+
+        rule.runOnIdle { Assert.assertTrue(focused) }
+    }
+
+    @Test
+    public fun focus_not_required_reported_correctly() {
+        var focused = false
+        rule.setContent {
+            Box {
+                HierarchicalFocusCoordinator(requiresFocus = { false }) {
+                    FocusableTestItem { focused = it }
+                }
+            }
+        }
+
+        rule.runOnIdle { Assert.assertFalse(focused) }
+    }
+
+    @Test
+    public fun updating_requiresFocus_lambda_works() {
+        var lambdaUpdated by mutableStateOf(false)
+        var focused = false
+        rule.setContent {
+            Box {
+                HierarchicalFocusCoordinator(
+                    // We switch between a lambda that always returns false and one that always
+                    // return true given the state of lambdaUpdated.
+                    requiresFocus =
+                        if (lambdaUpdated) {
+                            { true }
+                        } else {
+                            { false }
+                        }
+                ) {
+                    FocusableTestItem { focused = it }
+                }
+            }
+        }
+
+        rule.runOnIdle { lambdaUpdated = true }
+
+        rule.runOnIdle { Assert.assertTrue(focused) }
+    }
+
+    @Composable
+    private fun FocusableTestItem(onFocusChanged: (Boolean) -> Unit) {
+        val focusRequester = rememberActiveFocusRequester()
+        Box(
+            Modifier.size(10.dp) // View.requestFocus() will not take focus if the view has no size.
+                .focusRequester(focusRequester)
+                .onFocusChanged { onFocusChanged(it.isFocused) }
+                .focusable()
+        )
+    }
+
+    // Ensure that the expected element, and only it, is focused.
+    private fun checkFocus(expectedSelected: Int, actualFocused: BooleanArray) {
+        val focusedSet = actualFocused.indices.filter { actualFocused[it] }.toSet()
+        Assert.assertEquals(setOf(expectedSelected), focusedSet)
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt b/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt
index fcf8038b4..4d4273480 100644
--- a/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt
@@ -20,9 +20,14 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.filters.SmallTest
 import com.google.common.truth.Truth.assertWithMessage
 import kotlin.time.measureTime
+import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.SupervisorJob
 import kotlinx.coroutines.delay
 import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.runTest
 import org.junit.Test
 import org.junit.runner.RunWith
 
@@ -31,26 +36,28 @@ import org.junit.runner.RunWith
 class MapOfDeferredWithTimeoutTest {
 
     @Test
-    fun testTasksRunsInParallel() {
+    fun testTasksRunsInParallel() = runTest {
         val time = measureTime {
-            runBlocking {
-                val inputMap: MutableMap<Int, suspend (Unit) -> Any?> = mutableMapOf()
-                for (i in 1..10) {
-                    inputMap[i] = {
-                        delay(50)
-                        i
-                    }
+            val inputMap: MutableMap<Int, suspend (Unit) -> Any?> = mutableMapOf()
+            for (i in 1..10) {
+                inputMap[i] = {
+                    delay(50)
+                    i
                 }
+            }
 
-                val resultMap: Map<Int, Deferred<Any?>> =
-                    mapOfDeferredWithTimeout(inputMap, Unit, 100)
+            val resultMap: Map<Int, Deferred<Any?>> =
+                mapOfDeferredWithTimeout(
+                    inputMap,
+                    Unit,
+                    100,
+                    backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                )
 
-                for (i in 1..10) {
-                    val result: Any? = resultMap[i]?.await()
-                    assertWithMessage("Expected result type is not Int")
-                        .that(result is Int)
-                        .isTrue()
-                }
+            for (i in 1..10) {
+                val result: Any? = resultMap[i]?.await()
+                assertWithMessage("Expected result type is not Int").that(result is Int).isTrue()
             }
         }
 
@@ -63,6 +70,9 @@ class MapOfDeferredWithTimeoutTest {
 
     @Test
     fun testMapTimeout() {
+        val backgroundDispatcher = Dispatchers.IO
+        val backgroundScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
+
         val time = measureTime {
             runBlocking {
                 val inputMap: Map<String, suspend (Unit) -> Any?> =
@@ -81,7 +91,13 @@ class MapOfDeferredWithTimeoutTest {
                     )
 
                 val resultMap: Map<String, Deferred<Any?>> =
-                    mapOfDeferredWithTimeout(inputMap, Unit, 50)
+                    mapOfDeferredWithTimeout(
+                        inputMap,
+                        Unit,
+                        50,
+                        backgroundScope,
+                        backgroundDispatcher,
+                    )
 
                 assertWithMessage("Task should be timed out. Expected result is null.")
                     .that(resultMap["key1"]?.await())
diff --git a/res/layout/activity_photo_picker.xml b/res/layout/activity_photo_picker.xml
index ce445dd42..6ce4dec90 100644
--- a/res/layout/activity_photo_picker.xml
+++ b/res/layout/activity_photo_picker.xml
@@ -21,6 +21,7 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:app="http://schemas.android.com/apk/res-auto"
     xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/photo_picker_base"
     android:orientation="vertical"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
@@ -147,23 +148,23 @@
                     app:iconGravity="textStart"
                     style="@style/MaterialBorderlessButtonStyle"/>
 
-                <Button
-                    android:id="@+id/button_add"
-                    android:layout_width="0dp"
-                    android:layout_height="wrap_content"
-                    android:layout_weight="1"
-                    android:layout_marginHorizontal="@dimen/picker_bottom_bar_horizontal_gap"
-                    android:gravity="center|center_vertical"
-                    android:paddingVertical="@dimen/picker_bottom_bar_buttons_vertical_gap"
-                    android:text="@string/add"
-                    android:textAllCaps="false"
-                    android:textColor="?attr/pickerHighlightTextColor"
-                    android:maxLines="1"
-                    android:ellipsize="middle"
-                    android:backgroundTint="?attr/pickerHighlightColor"
-                    style="@style/MaterialButtonStyle"/>
-
-            </LinearLayout>
+                    <Button
+                        android:id="@+id/button_add"
+                        android:layout_width="0dp"
+                        android:layout_height="wrap_content"
+                        android:layout_weight="1"
+                        android:layout_marginHorizontal="@dimen/picker_bottom_bar_horizontal_gap"
+                        android:gravity="center|center_vertical"
+                        android:paddingVertical="@dimen/picker_bottom_bar_buttons_vertical_gap"
+                        android:text="@string/add"
+                        android:textAllCaps="false"
+                        android:textColor="?attr/pickerHighlightTextColor"
+                        android:maxLines="1"
+                        android:ellipsize="middle"
+                        android:backgroundTint="?attr/pickerHighlightColor"
+                        style="@style/MaterialButtonStyle"/>
+
+                </LinearLayout>
 
         </FrameLayout>
 
diff --git a/res/layout/activity_photo_picker_settings.xml b/res/layout/activity_photo_picker_settings.xml
index 4988dc22d..2300c8fbd 100644
--- a/res/layout/activity_photo_picker_settings.xml
+++ b/res/layout/activity_photo_picker_settings.xml
@@ -16,37 +16,23 @@
   -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:id="@+id/settings_activity_root"
-              android:background="@color/picker_background_color"
-              android:orientation="vertical"
-              android:layout_height="match_parent"
-              android:layout_width="match_parent">
-
-    <androidx.appcompat.widget.Toolbar
-        android:id="@+id/picker_settings_toolbar"
-        android:layout_width="match_parent"
-        android:layout_height="?attr/actionBarSize" />
+    android:id="@+id/settings_activity_root"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
 
     <TextView
-        android:id="@+id/picker_settings_title"
-        android:text="@string/picker_settings_title"
-        android:textAppearance="@style/PickerHeadingTextAppearance"
-        android:layout_marginTop="@dimen/picker_settings_title_margin_top"
-        android:layout_margin="@dimen/picker_settings_margin_default"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"/>
-
-    <TextView
-        android:id="@+id/picker_settings_description"
         android:text="@string/picker_settings_description"
-        android:layout_margin="@dimen/picker_settings_margin_default"
-        android:textAppearance="@style/PickerBodyTextAppearance"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"/>
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingBottom="@dimen/picker_settings_description_padding_bottom"
+        android:paddingTop="@dimen/picker_settings_description_padding_top"
+        android:paddingStart="@dimen/picker_settings_description_padding_start"
+        android:paddingEnd="@dimen/picker_settings_description_padding_end"
+        android:textAppearance="@style/PickerSettingsDescription" />
 
     <FrameLayout
         android:id="@+id/settings_fragment_container"
         android:layout_width="match_parent"
-        android:layout_height="0dp"
-        android:layout_weight="1" />
-</LinearLayout>
+        android:layout_height="match_parent" />
+</LinearLayout>
\ No newline at end of file
diff --git a/res/layout/pref_settings_cloud_select_title.xml b/res/layout/pref_settings_cloud_select_title.xml
deleted file mode 100644
index ab68815bd..000000000
--- a/res/layout/pref_settings_cloud_select_title.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<!--
-  ~ Copyright (C) 2022 The Android Open Source Project
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content">
-    <TextView android:id="@android:id/title"
-              android:layout_width="match_parent"
-              android:layout_height="wrap_content"
-              android:layout_gravity="start"
-              android:layout_margin="@dimen/picker_settings_cloud_select_title_margin"
-              android:textAppearance="@android:style/TextAppearance.Material.Body1" />
-</FrameLayout>
\ No newline at end of file
diff --git a/res/raw/android_mime_types b/res/raw/android_mime_types
new file mode 100644
index 000000000..d8a2ce8f5
--- /dev/null
+++ b/res/raw/android_mime_types
@@ -0,0 +1,166 @@
+
+###############################################################################
+#
+# Android-specific MIME type <-> extension mappings
+#
+# Each line below defines a mapping from one MIME type to the first of the
+# listed extensions, and from listed extension back to the MIME type.
+# A mapping overrides any previous mapping _from_ that same MIME type or
+# extension (put() semantics), unless that MIME type / extension is prefixed with '?'
+# (putIfAbsent() semantics).
+#
+#
+###############################################################################
+#
+# EXAMPLES
+#
+# A line of the form:
+#
+#    ?mime ext1 ?ext2 ext3
+#
+# affects the current mappings along the lines of the following pseudo code:
+#
+#    mimeToExt.putIfAbsent("mime", "ext1");
+#    extToMime.put("ext1", "mime");
+#    extToMime.putIfAbsent("ext2", "mime");
+#    extToMime.put("ext3", "mime");
+#
+# The line:
+#
+#     ?text/plain txt
+#
+# leaves any earlier mapping for "text/plain" untouched, or maps that MIME type
+# to the file extension ".txt" if there is no earlier mapping. The line also
+# sets the mapping from file extension ".txt" to be the MIME type "text/plain",
+# regardless of whether a previous mapping existed.
+#
+###############################################################################
+
+
+# File extensions that Android wants to override to point to the given MIME type.
+#
+# After processing a line of the form:
+# ?<mimeType> <extension1> <extension2>
+# If <mimeType> was not already mapped to an extension then it will be
+# mapped to <extension1>.
+# <extension1> and <extension2> are mapped (or remapped) to <mimeType>.
+
+?application/epub+zip epub
+?application/lrc lrc
+?application/pkix-cert cer
+?application/rss+xml rss
+?application/sdp sdp
+?application/smil+xml smil
+?application/ttml+xml ttml dfxp
+?application/vnd.android.haptics.vibration+xml ahv
+?application/vnd.android.ota ota
+?application/vnd.apple.mpegurl m3u8
+?application/vnd.apple.pkpass pkpass
+?application/vnd.apple.pkpasses pkpasses
+?application/vnd.ms-pki.stl stl
+?application/vnd.ms-powerpoint pot
+?application/vnd.ms-wpl wpl
+?application/vnd.stardivision.impress sdp
+?application/vnd.stardivision.writer vor
+?application/vnd.youtube.yt yt
+?application/x-android-drm-fl fl
+?application/x-flac flac
+?application/x-font pcf
+?application/x-mobipocket-ebook prc mobi
+?application/x-mpegurl m3u m3u8
+?application/x-pem-file pem
+?application/x-pkcs12 p12 pfx
+?application/x-subrip srt
+?application/x-webarchive webarchive
+?application/x-webarchive-xml webarchivexml
+?application/x-x509-server-cert crt
+?application/x-x509-user-cert crt
+
+?audio/3gpp 3ga 3gpp
+?audio/aac-adts aac
+?audio/ac3 ac3 a52
+?audio/amr amr
+?audio/x-gsm gsm
+?audio/imelody imy
+?audio/midi rtttl xmf
+?audio/mobile-xmf mxmf
+?audio/mp4 m4a m4b m4p f4a f4b f4p
+?audio/mpegurl m3u
+?audio/sp-midi smf
+?audio/x-matroska mka
+?audio/x-pn-realaudio ra
+?audio/x-mpeg mp3
+?audio/mp3 mp3
+
+?image/bmp bmp
+?image/gif gif
+?image/heic heic
+?image/heic-sequence heics
+?image/heif heif hif
+?image/heif-sequence heifs
+?image/avif avif
+?image/ico cur
+?image/webp webp
+?image/x-adobe-dng dng
+?image/x-fuji-raf raf
+?image/x-icon ico
+?image/x-jg art
+?image/x-nikon-nrw nrw
+?image/x-panasonic-rw2 rw2
+?image/x-pentax-pef pef
+?image/x-samsung-srw srw
+?image/x-sony-arw arw
+
+?text/comma-separated-values csv
+?text/plain diff po
+?text/rtf rtf
+?text/text phps
+?text/xml xml
+?text/x-vcard vcf
+
+?video/3gpp2 3gpp2 3gp2 3g2
+?video/3gpp 3gpp 3gp
+?video/avi avi
+?video/m4v m4v
+?video/mp4 m4v f4v mp4v mpeg4
+?video/mp2p mpeg
+?video/mp2t m2ts mts
+?video/mp2ts ts
+?video/vnd.youtube.yt yt
+?video/x-webex wrf
+
+# Optional additions that should not override any previous mapping.
+
+?application/x-wifi-config ?xml
+?multipart/related mht
+
+# Special cases where Android has a strong opinion about mappings, so we
+# define them very last and make them override in both directions (no "?").
+#
+# Lines here are of the form:
+# <mimeType> <extension1> <extension2> ...
+#
+# After processing each line,
+#   <mimeType> is mapped to <extension1>
+#   <extension1>, <extension2>, ... are all mapped to <mimeType>
+# This overrides any mappings for this <mimeType> / for these extensions
+# that may have been defined earlier.
+
+application/pgp-signature pgp
+application/x-x509-ca-cert crt der
+audio/aac aac adts adt
+audio/basic snd
+audio/flac flac
+audio/midi rtx
+audio/mpeg mp3 mp2 mp1 mpa m4a m4r
+audio/x-mpegurl m3u m3u8
+image/jpeg jpg
+image/x-ms-bmp bmp
+image/x-photoshop psd
+text/plain txt
+text/x-c++hdr hpp
+text/x-c++src cpp
+video/3gpp 3gpp
+video/mpeg mpeg mpeg2 mpv2 mp2v m2v m2t mpeg1 mpv1 mp1v m1v
+video/quicktime mov
+video/x-matroska mkv
\ No newline at end of file
diff --git a/res/raw/corrupted_mime_types b/res/raw/corrupted_mime_types
new file mode 100644
index 000000000..dc34a542a
--- /dev/null
+++ b/res/raw/corrupted_mime_types
@@ -0,0 +1,2320 @@
+###############################################################################
+#
+#  Media (MIME) types and the extensions that represent them.
+#
+#  The format of this file is a media type on the left and zero or more
+#  filename extensions on the right.  Programs using this file will map
+#  files ending with those extensions to the associated type.
+#
+#  This file is part of the "media-types" package.  Please report a bug using
+#  the "reportbug" command of the "reportbug" package if you would like new
+#  types or extensions to be added.
+#
+#  The reason that all types are managed by the media-types package instead
+#  allowing individual packages to install types in much the same way as they
+#  add entries in to the mailcap file is so these types can be referenced by
+#  other programs (such as a web server) even if the specific support package
+#  for that type is not installed.
+#
+#  Users can add their own types if they wish by creating a ".mime.types"
+#  file in their home directory.  Definitions included there will take
+#  precedence over those listed here.
+#
+###############################################################################
+
+application/1d-interleaved-parityfec
+application/3gpdash-qoe-report+xml
+application/3gpp-ims+xml
+application/3gppHal+json
+application/3gppHalForms+json
+application/A2L					a2l
+application/ace+cbor
+application/ace+json
+application/activemessage
+application/activity+json
+application/aif+cbor
+application/aif+json
+application/alto-cdni+json
+application/alto-cdnifilter+json
+application/alto-costmap+json
+application/alto-costmapfilter+json
+application/alto-directory+json
+application/alto-endpointcost+json
+application/alto-endpointcostparams+json
+application/alto-endpointprop+json
+application/alto-endpointpropparams+json
+application/alto-error+json
+application/alto-networkmap+json
+application/alto-networkmapfilter+json
+application/alto-propmap+json
+application/alto-propmapparams+json
+application/alto-updatestreamcontrol+json
+application/alto-updatestreamparams+json
+application/AML					aml
+application/andrew-inset			ez
+application/annodex				anx
+application/applefile
+application/at+jwt
+application/ATF					atf
+application/ATFX				atfx
+application/atom+xml				atom
+application/atomcat+xml				atomcat
+application/atomdeleted+xml			atomdeleted
+application/atomicmail
+application/atomserv+xml			atomsrv
+application/atomsvc+xml				atomsvc
+application/atsc-dwd+xml			dwd
+application/atsc-dynamic-event-message
+application/atsc-held+xml			held
+application/atsc-rdt+json
+application/atsc-rsat+xml			rsat
+application/ATXML				atxml
+application/auth-policy+xml			apxml
+application/automationml-aml+xml
+application/automationml-amlx+zip		amlx
+application/bacnet-xdd+zip			xdd
+application/batch-SMTP
+application/bbolin				lin
+application/beep+xml
+application/calendar+json
+application/calendar+xml			xcs
+application/call-completion
+application/CALS-1840
+application/captive+json
+application/cbor				cbor
+application/cbor-seq
+application/cccex				c3ex
+application/ccmp+xml				ccmp
+application/ccxml+xml				ccxml
+application/cda+xml
+application/CDFX+XML				cdfx
+application/cdmi-capability			cdmia
+application/cdmi-container			cdmic
+application/cdmi-domain				cdmid
+application/cdmi-object				cdmio
+application/cdmi-queue				cdmiq
+application/cdni
+application/CEA					cea
+application/cea-2018+xml
+application/cellml+xml				cellml cml
+application/cfw
+application/city+json
+application/clr					1clr
+application/clue+xml
+application/clue_info+xml			clue
+application/cms					cmsc
+application/cnrp+xml
+application/coap-group+json
+application/coap-payload
+application/commonground
+application/concise-problem-details+cbor
+application/conference-info+xml
+application/cose
+application/cose-key
+application/cose-key-set
+application/cose-x509
+application/cpl+xml				cpl
+application/csrattrs				csrattrs
+application/csta+xml
+application/CSTAdata+xml
+application/csvm+json
+application/cu-seeme				cu
+application/cwl					cwl
+application/cwl+json				cwl.json
+application/cwt
+application/cybercash
+application/dash+xml				mpd
+application/dash-patch+xml
+application/dashdelta				mpdd
+application/davmount+xml			davmount
+application/dca-rft
+application/DCD					dcd
+application/dec-dx
+application/dialog-info+xml
+application/dicom				dcm
+application/dicom+json
+application/dicom+xml
+application/DII					dii
+application/DIT					dit
+application/dns
+application/dns+json
+application/dns-message
+application/dots+cbor
+application/dpop+jwt
+application/dskpp+xml				xmls
+application/dsptype				tsp
+application/dssc+der				dssc
+application/dssc+xml				xdssc
+application/dvcs				dvc
+application/EDI-consent
+application/EDI-X12
+application/EDIFACT
+application/efi					efi
+application/elm+json
+application/elm+xml
+application/EmergencyCallData.cap+xml
+application/EmergencyCallData.Comment+xml
+application/EmergencyCallData.Control+xml
+application/EmergencyCallData.DeviceInfo+xml
+application/EmergencyCallData.eCall.MSD
+application/EmergencyCallData.LegacyESN+json
+application/EmergencyCallData.ProviderInfo+xml
+application/EmergencyCallData.ServiceInfo+xml
+application/EmergencyCallData.SubscriberInfo+xml
+application/EmergencyCallData.VEDS+xml
+application/emma+xml				emma
+application/emotionml+xml			emotionml
+application/encaprtp
+application/epp+xml
+application/epub+zip				epub
+application/eshop
+application/example
+application/exi					exi
+application/expect-ct-report+json
+application/express				exp
+application/fastinfoset				finf
+application/fastsoap
+application/fdf					fdf
+application/fdt+xml				fdt
+application/fhir+json
+application/fhir+xml
+application/fits
+application/flexfec
+application/font-tdpfr				pfr
+application/framework-attributes+xml
+application/futuresplash			spl
+application/geo+json				geojson
+application/geo+json-seq
+application/geopackage+sqlite3			gpkg
+application/geoxacml+xml
+application/gltf-buffer				glbin glbuf
+application/gml+xml				gml
+application/gzip				gz
+application/H224
+application/held+xml
+application/hl7v2+xml
+application/hta					hta
+application/http
+application/hyperstudio				stk
+application/ibe-key-request+xml
+application/ibe-pkg-reply+xml
+application/ibe-pp-data
+application/iges
+application/im-iscomposing+xml
+application/index
+application/index.cmd
+application/index.obj
+application/index.response
+application/index.vnd
+application/inkml+xml				ink inkml
+application/IOTP
+application/ipfix				ipfix
+application/ipp
+application/ISUP
+application/its+xml				its
+application/java-archive			jar
+application/java-serialized-object		ser
+application/java-vm				class
+application/jf2feed+json
+application/jose
+application/jose+json
+application/jrd+json				jrd
+application/jscalendar+json
+application/json				json
+application/json-patch+json			json-patch
+application/json-seq
+application/jwk+json
+application/jwk-set+json
+application/jwt
+application/kpml-request+xml
+application/kpml-response+xml
+application/ld+json				jsonld
+application/lgr+xml				lgr
+application/link-format				wlnk
+application/linkset
+application/linkset+json
+application/load-control+xml
+application/logout+jwt
+application/lost+xml				lostxml
+application/lostsync+xml			lostsyncxml
+application/lpf+zip				lpf
+application/LXF					lxf
+application/m3g					m3g
+application/mac-binhex40			hqx
+application/mac-compactpro			cpt
+application/macwriteii
+application/mads+xml				mads
+application/manifest+json			webmanifest
+application/marc				mrc
+application/marcxml+xml				mrcx
+application/mathematica				ma mb
+application/mathml+xml				mml
+application/mathml-content+xml
+application/mathml-presentation+xml
+application/mbms-associated-procedure-description+xml
+application/mbms-deregister+xml
+application/mbms-envelope+xml
+application/mbms-msk+xml
+application/mbms-msk-response+xml
+application/mbms-protection-description+xml
+application/mbms-reception-report+xml
+application/mbms-register+xml
+application/mbms-register-response+xml
+application/mbms-schedule+xml
+application/mbms-user-service-description+xml
+application/mbox				mbox
+application/media-policy-dataset+xml
+application/mediaservercontrol+xml
+application/media_control+xml
+application/merge-patch+json
+application/metalink4+xml			meta4
+application/mets+xml				mets
+application/MF4					mf4
+application/mikey
+application/mipc
+application/missing-blocks+cbor-seq
+application/mmt-aei+xml				maei
+application/mmt-usd+xml				musd
+application/mods+xml				mods
+application/moss-keys
+application/moss-signature
+application/mosskey-data
+application/mosskey-request
+application/mp21				m21 mp21
+application/mp4
+application/mpeg4-generic
+application/mpeg4-iod
+application/mpeg4-iod-xmt
+application/mrb-consumer+xml
+application/mrb-publish+xml
+application/msaccess				mdb
+application/msc-ivr+xml
+application/msc-mixer+xml
+application/msword				doc
+application/mud+json
+application/multipart-core
+application/mxf					mxf
+application/n-quads				nq
+application/n-triples				nt
+application/nasdata
+application/news-checkgroups
+application/news-groupinfo
+application/news-transmission
+application/nlsml+xml
+application/node
+application/nss
+application/oauth-authz-req+jwt
+application/oblivious-dns-message
+application/ocsp-request			orq
+application/ocsp-response			ors
+application/octet-stream			bin deploy msu msp
+application/ODA					oda
+application/odm+xml
+application/ODX					odx
+application/oebps-package+xml			opf
+application/ogg					ogx
+application/ohttp-keys
+application/onenote				one onetoc2 onetmp onepkg
+application/opc-nodeset+xml
+application/oscore
+application/oxps				oxps
+application/p21					p21 stpnc 210 ifc
+application/p21+zip
+application/p2p-overlay+xml			relo
+application/parityfec
+application/passport
+application/patch-ops-error+xml
+application/pdf					pdf
+application/PDX					pdx
+application/pem-certificate-chain		pem
+application/pgp-encrypted			pgp
+application/pgp-keys				asc key
+application/pgp-signature			sig
+application/pics-rules				prf
+application/pidf+xml
+application/pidf-diff+xml
+application/pkcs10				p10
+application/pkcs12				p12 pfx
+application/pkcs7-mime				p7m p7c p7z
+application/pkcs7-signature			p7s
+application/pkcs8				p8
+application/pkcs8-encrypted			p8e
+application/pkix-attr-cert			ac
+application/pkix-cert				cer
+application/pkix-crl				crl
+application/pkix-pkipath			pkipath
+application/pkixcmp				pki
+application/pls+xml
+application/poc-settings+xml
+application/postscript				ps ai eps epsi epsf eps2 eps3
+application/ppsp-tracker+json
+application/problem+json
+application/problem+xml
+application/provenance+xml			provx
+application/prs.alvestrand.titrax-sheet
+application/prs.cww				cw cww
+application/prs.cyn
+application/prs.hpub+zip			hpub
+application/prs.implied-document+xml
+application/prs.implied-executable
+application/prs.implied-structure
+application/prs.nprend				rnd rct
+application/prs.plucker
+application/prs.rdf-xml-crypt			rdf-crypt
+application/prs.xsf+xml				xsf
+application/pskc+xml				pskcxml
+application/pvd+json
+application/QSIG
+application/raptorfec
+application/rdap+json
+application/rdf+xml				rdf
+application/reginfo+xml				rif
+application/relax-ng-compact-syntax		rnc
+application/reputon+json
+application/resource-lists+xml			rl
+application/resource-lists-diff+xml		rld
+application/rfc+xml				rfcxml
+application/riscos
+application/rlmi+xml
+application/rls-services+xml			rs
+application/route-apd+xml			rapd
+application/route-s-tsid+xml			sls
+application/route-usd+xml			rusd
+application/rpki-checklist
+application/rpki-ghostbusters			gbr
+application/rpki-manifest			mft
+application/rpki-publication
+application/rpki-roa				roa
+application/rpki-updown
+application/rtf					rtf
+application/rtploopback
+application/rtx
+application/samlassertion+xml
+application/samlmetadata+xml
+application/sarif+json				sarif sarif.json
+application/sarif-external-properties+json	sarif-external-properties sarif-external-properties.json
+application/sbe
+application/sbml+xml
+application/scaip+xml
+application/scim+json				scim
+application/scvp-cv-request			scq
+application/scvp-cv-response			scs
+application/scvp-vp-request			spq
+application/scvp-vp-response			spp
+application/sdp					sdp
+application/secevent+jwt
+application/senml+cbor				senmlc
+application/senml+json				senml
+application/senml+xml				senmlx
+application/senml-etch+cbor			senml-etchc
+application/senml-etch+json			senml-etchj
+application/senml-exi				senmle
+application/sensml+cbor				sensmlc
+application/sensml+json				sensml
+application/sensml+xml				sensmlx
+application/sensml-exi				sensmle
+application/sep+xml
+application/sep-exi
+application/session-info
+application/set-payment
+application/set-payment-initiation
+application/set-registration
+application/set-registration-initiation
+application/SGML
+application/sgml-open-catalog			soc
+application/shf+xml				shf
+application/sieve				siv sieve
+application/simple-filter+xml			cl
+application/simple-message-summary
+application/simpleSymbolContainer
+application/sipc
+application/slate
+application/smil+xml				smil smi sml
+application/smpte336m
+application/soap+fastinfoset
+application/soap+xml
+application/sparql-query			rq
+application/sparql-results+xml			srx
+application/spdx+json				spdx.json
+application/spirits-event+xml
+application/sql					sql
+application/srgs				gram
+application/srgs+xml				grxml
+application/sru+xml				sru
+application/ssml+xml				ssml
+application/stix+json				stix
+application/swid+cbor				coswid
+application/swid+xml				swidtag
+application/tamp-apex-update			tau
+application/tamp-apex-update-confirm		auc
+application/tamp-community-update		tcu
+application/tamp-community-update-confirm	cuc
+application/tamp-error				ter
+application/tamp-sequence-adjust		tsa
+application/tamp-sequence-adjust-confirm	sac
+application/tamp-status-query
+application/tamp-status-response
+application/tamp-update				tur
+application/tamp-update-confirm			tuc
+application/taxii+json
+application/td+json				jsontd
+application/tei+xml				tei teiCorpus odd
+application/TETRA_ISI
+application/thraud+xml				tfi
+application/timestamp-query			tsq
+application/timestamp-reply			tsr
+application/timestamped-data			tsd
+application/tlsrpt+gzip
+application/tlsrpt+json
+application/tm+json				tm.jsonld tm.json jsontm
+application/tnauthlist
+application/token-introspection+jwt
+application/trickle-ice-sdpfrag
+application/trig				trig
+application/ttml+xml				ttml
+application/tve-trigger
+application/tzif
+application/tzif-leap
+application/ulpfec
+application/urc-grpsheet+xml			gsheet
+application/urc-ressheet+xml			rsheet
+application/urc-targetdesc+xml			td
+application/urc-uisocketdesc+xml		uis
+application/vcard+json
+application/vcard+xml
+application/vemmi
+application/vnd.1000minds.decision-model+xml	1km
+application/vnd.1ob				ob
+application/vnd.3gpp-prose+xml
+application/vnd.3gpp-prose-pc3a+xml
+application/vnd.3gpp-prose-pc3ach+xml
+application/vnd.3gpp-prose-pc3ch+xml
+application/vnd.3gpp-prose-pc8+xml
+application/vnd.3gpp-v2x-local-service-information
+application/vnd.3gpp.5gnas
+application/vnd.3gpp.access-transfer-events+xml
+application/vnd.3gpp.bsf+xml
+application/vnd.3gpp.crs+xml
+application/vnd.3gpp.current-location-discovery+xml
+application/vnd.3gpp.GMOP+xml
+application/vnd.3gpp.gtpc
+application/vnd.3gpp.interworking-data
+application/vnd.3gpp.lpp
+application/vnd.3gpp.mc-signalling-ear
+application/vnd.3gpp.mcdata-affiliation-command+xml
+application/vnd.3gpp.mcdata-info+xml
+application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml
+application/vnd.3gpp.mcdata-payload
+application/vnd.3gpp.mcdata-regroup+xml
+application/vnd.3gpp.mcdata-service-config+xml
+application/vnd.3gpp.mcdata-signalling
+application/vnd.3gpp.mcdata-ue-config+xml
+application/vnd.3gpp.mcdata-user-profile+xml
+application/vnd.3gpp.mcptt-affiliation-command+xml
+application/vnd.3gpp.mcptt-floor-request+xml
+application/vnd.3gpp.mcptt-info+xml
+application/vnd.3gpp.mcptt-location-info+xml
+application/vnd.3gpp.mcptt-mbms-usage-info+xml
+application/vnd.3gpp.mcptt-regroup+xml
+application/vnd.3gpp.mcptt-service-config+xml
+application/vnd.3gpp.mcptt-signed+xml
+application/vnd.3gpp.mcptt-ue-config+xml
+application/vnd.3gpp.mcptt-ue-init-config+xml
+application/vnd.3gpp.mcptt-user-profile+xml
+application/vnd.3gpp.mcvideo-affiliation-command+xml
+application/vnd.3gpp.mcvideo-info+xml
+application/vnd.3gpp.mcvideo-location-info+xml
+application/vnd.3gpp.mcvideo-mbms-usage-info+xml
+application/vnd.3gpp.mcvideo-regroup+xml
+application/vnd.3gpp.mcvideo-service-config+xml
+application/vnd.3gpp.mcvideo-transmission-request+xml
+application/vnd.3gpp.mcvideo-ue-config+xml
+application/vnd.3gpp.mcvideo-user-profile+xml
+application/vnd.3gpp.mid-call+xml
+application/vnd.3gpp.ngap
+application/vnd.3gpp.pfcp
+application/vnd.3gpp.pic-bw-large		plb
+application/vnd.3gpp.pic-bw-small		psb
+application/vnd.3gpp.pic-bw-var			pvb
+application/vnd.3gpp.s1ap
+application/vnd.3gpp.seal-group-doc+xml
+application/vnd.3gpp.seal-info+xml
+application/vnd.3gpp.seal-location-info+xml
+application/vnd.3gpp.seal-mbms-usage-info+xml
+application/vnd.3gpp.seal-network-QoS-management-info+xml
+application/vnd.3gpp.seal-ue-config-info+xml
+application/vnd.3gpp.seal-unicast-info+xml
+application/vnd.3gpp.seal-user-profile-info+xml
+application/vnd.3gpp.sms
+application/vnd.3gpp.sms+xml
+application/vnd.3gpp.srvcc-ext+xml
+application/vnd.3gpp.SRVCC-info+xml
+application/vnd.3gpp.state-and-event-info+xml
+application/vnd.3gpp.ussd+xml
+application/vnd.3gpp.v2x
+application/vnd.3gpp.vae-info+xml
+application/vnd.3gpp2.bcmcsinfo+xml
+application/vnd.3gpp2.sms			sms
+application/vnd.3gpp2.tcap			tcap
+application/vnd.3lightssoftware.imagescal	imgcal
+application/vnd.3M.Post-it-Notes		pwn
+application/vnd.accpac.simply.aso		aso
+application/vnd.accpac.simply.imp		imp
+application/vnd.acm.addressxfer+json
+application/vnd.acucobol			acu
+application/vnd.acucorp				atc acutc
+application/vnd.adobe.flash.movie		swf
+application/vnd.adobe.formscentral.fcdt		fcdt
+application/vnd.adobe.fxp			fxp fxpl
+application/vnd.adobe.partial-upload
+application/vnd.adobe.xdp+xml			xdp
+application/vnd.aether.imp
+application/vnd.afpc.afplinedata
+application/vnd.afpc.afplinedata-pagedef
+application/vnd.afpc.cmoca-cmresource
+application/vnd.afpc.foca-charset
+application/vnd.afpc.foca-codedfont
+application/vnd.afpc.foca-codepage
+application/vnd.afpc.modca			list3820 listafp afp pseg3820
+application/vnd.afpc.modca-formdef
+application/vnd.afpc.modca-mediummap
+application/vnd.afpc.modca-objectcontainer
+application/vnd.afpc.modca-overlay		ovl
+application/vnd.afpc.modca-pagesegment		psg
+application/vnd.age				age
+application/vnd.ah-barcode
+application/vnd.ahead.space			ahead
+application/vnd.airzip.filesecure.azf		azf
+application/vnd.airzip.filesecure.azs		azs
+application/vnd.amadeus+json
+application/vnd.amazon.mobi8-ebook		azw3
+application/vnd.americandynamics.acc		acc
+application/vnd.amiga.ami			ami
+application/vnd.amundsen.maze+xml
+application/vnd.android.ota			ota
+application/vnd.android.package-archive						apk
+application/vnd.anki				apkg
+application/vnd.anser-web-certificate-issue-initiation	cii
+application/vnd.anser-web-funds-transfer-initiation	fti
+application/vnd.antix.game-component
+application/vnd.apache.arrow.file		arrow
+application/vnd.apache.arrow.stream		arrows
+application/vnd.apache.thrift.binary
+application/vnd.apache.thrift.compact
+application/vnd.apache.thrift.json
+application/vnd.apexlang			apexlang apex
+application/vnd.api+json
+application/vnd.aplextor.warrp+json
+application/vnd.apothekende.reservation+json
+application/vnd.apple.installer+xml		dist distz pkg mpkg
+application/vnd.apple.keynote			keynote
+application/vnd.apple.mpegurl			m3u8
+application/vnd.apple.numbers			numbers
+application/vnd.apple.pages			pages
+application/vnd.aristanetworks.swi		swi
+application/vnd.artisan+json			artisan
+application/vnd.artsquare
+application/vnd.astraea-software.iota		iota
+application/vnd.audiograph			aep
+application/vnd.autopackage			package
+application/vnd.avalon+json
+application/vnd.avistar+xml
+application/vnd.balsamiq.bmml+xml		bmml
+application/vnd.balsamiq.bmpr			bmpr
+application/vnd.banana-accounting		ac2
+application/vnd.bbf.usp.error
+application/vnd.bbf.usp.msg
+application/vnd.bbf.usp.msg+json
+application/vnd.bekitzur-stech+json
+application/vnd.belightsoft.lhzd+zip		lhzd
+application/vnd.belightsoft.lhzl+zip		lhzl
+application/vnd.bint.med-content
+application/vnd.biopax.rdf+xml
+application/vnd.blink-idb-value-wrapper
+application/vnd.blueice.multipass		mpm
+application/vnd.bluetooth.ep.oob		ep
+application/vnd.bluetooth.le.oob		le
+application/vnd.bmi				bmi
+application/vnd.bpf
+application/vnd.bpf3
+application/vnd.businessobjects			rep
+application/vnd.byu.uapi+json
+application/vnd.cab-jscript
+application/vnd.canon-cpdl
+application/vnd.canon-lips
+application/vnd.capasystems-pg+json
+application/vnd.cendio.thinlinc.clientconf	tlclient
+application/vnd.century-systems.tcp_stream
+application/vnd.chemdraw+xml			cdxml
+application/vnd.chess-pgn			pgn
+application/vnd.chipnuts.karaoke-mmd		mmd
+application/vnd.ciedi
+application/vnd.cinderella			cdy
+application/vnd.cirpack.isdn-ext
+application/vnd.citationstyles.style+xml	csl
+application/vnd.claymore			cla
+application/vnd.cloanto.rp9			rp9
+application/vnd.clonk.c4group			c4g c4d c4f c4p c4u
+application/vnd.cluetrust.cartomobile-config	c11amc
+application/vnd.cluetrust.cartomobile-config-pkg	c11amz
+application/vnd.cncf.helm.chart.content.v1.tar+gzip
+application/vnd.cncf.helm.chart.provenance.v1.prov
+application/vnd.cncf.helm.config.v1+json
+application/vnd.coffeescript			coffee
+application/vnd.collabio.xodocuments.document	xodt
+application/vnd.collabio.xodocuments.document-template	xott
+application/vnd.collabio.xodocuments.presentation	xodp
+application/vnd.collabio.xodocuments.presentation-template	xotp
+application/vnd.collabio.xodocuments.spreadsheet	xods
+application/vnd.collabio.xodocuments.spreadsheet-template	xots
+application/vnd.collection+json
+application/vnd.collection.doc+json
+application/vnd.collection.next+json
+application/vnd.comicbook+zip			cbz
+application/vnd.comicbook-rar			cbr
+application/vnd.commerce-battelle		icf icd ic0 ic1 ic2 ic3 ic4 ic5 ic6 ic7 ic8
+application/vnd.commonspace			csp cst
+application/vnd.contact.cmsg			cdbcmsg
+application/vnd.coreos.ignition+json		ign ignition
+application/vnd.cosmocaller			cmc
+application/vnd.crick.clicker			clkx
+application/vnd.crick.clicker.keyboard		clkk
+application/vnd.crick.clicker.palette		clkp
+application/vnd.crick.clicker.template		clkt
+application/vnd.crick.clicker.wordbank		clkw
+application/vnd.criticaltools.wbs+xml		wbs
+application/vnd.cryptii.pipe+json
+application/vnd.crypto-shade-file		ssvc
+application/vnd.cryptomator.encrypted		c9r c9s
+application/vnd.cryptomator.vault		cryptomator
+application/vnd.ctc-posml			pml
+application/vnd.ctct.ws+xml
+application/vnd.cups-pdf
+application/vnd.cups-postscript
+application/vnd.cups-ppd			ppd
+application/vnd.cups-raster
+application/vnd.cups-raw
+application/vnd.curl
+application/vnd.cyan.dean.root+xml
+application/vnd.cybank
+application/vnd.cyclonedx+json
+application/vnd.cyclonedx+xml
+application/vnd.d2l.coursepackage1p0+zip
+application/vnd.d3m-dataset
+application/vnd.d3m-problem
+application/vnd.dart				dart
+application/vnd.data-vision.rdz			rdz
+application/vnd.datalog				dl
+application/vnd.datapackage+json
+application/vnd.dataresource+json
+application/vnd.dbf				dbf
+application/vnd.debian.binary-package		deb ddeb udeb
+application/vnd.dece.data			uvf uvvf uvd uvvd
+application/vnd.dece.ttml+xml			uvt uvvt
+application/vnd.dece.unspecified		uvx uvvx
+application/vnd.dece.zip			uvz uvvz
+application/vnd.denovo.fcselayout-link		fe_launch
+application/vnd.desmume.movie			dsm
+application/vnd.dir-bi.plate-dl-nosuffix
+application/vnd.dm.delegation+xml
+application/vnd.dna				dna
+application/vnd.document+json			docjson
+application/vnd.dolby.mobile.1
+application/vnd.dolby.mobile.2
+application/vnd.doremir.scorecloud-binary-document	scld
+application/vnd.dpgraph				dpg mwc dpgraph
+application/vnd.dreamfactory			dfac
+application/vnd.drive+json
+application/vnd.dtg.local
+application/vnd.dtg.local.flash			fla
+application/vnd.dtg.local.html
+application/vnd.dvb.ait				ait
+application/vnd.dvb.dvbisl+xml
+application/vnd.dvb.dvbj
+application/vnd.dvb.esgcontainer
+application/vnd.dvb.ipdcdftnotifaccess
+application/vnd.dvb.ipdcesgaccess
+application/vnd.dvb.ipdcesgaccess2
+application/vnd.dvb.ipdcesgpdd
+application/vnd.dvb.ipdcroaming
+application/vnd.dvb.iptv.alfec-base
+application/vnd.dvb.iptv.alfec-enhancement
+application/vnd.dvb.notif-aggregate-root+xml
+application/vnd.dvb.notif-container+xml
+application/vnd.dvb.notif-generic+xml
+application/vnd.dvb.notif-ia-msglist+xml
+application/vnd.dvb.notif-ia-registration-request+xml
+application/vnd.dvb.notif-ia-registration-response+xml
+application/vnd.dvb.notif-init+xml
+application/vnd.dvb.pfr
+application/vnd.dvb.service			svc
+application/vnd.dxr
+application/vnd.dynageo				geo
+application/vnd.dzr				dzr
+application/vnd.easykaraoke.cdgdownload
+application/vnd.ecdis-update
+application/vnd.ecip.rlp
+application/vnd.eclipse.ditto+json
+application/vnd.ecowin.chart			mag
+application/vnd.ecowin.filerequest
+application/vnd.ecowin.fileupdate
+application/vnd.ecowin.series
+application/vnd.ecowin.seriesrequest
+application/vnd.ecowin.seriesupdate
+application/vnd.efi.img
+application/vnd.efi.iso
+application/vnd.eln+zip				ELN
+application/vnd.emclient.accessrequest+xml
+application/vnd.enliven				nml
+application/vnd.enphase.envoy
+application/vnd.eprints.data+xml
+application/vnd.epson.esf			esf
+application/vnd.epson.msf			msf
+application/vnd.epson.quickanime		qam
+application/vnd.epson.salt			slt
+application/vnd.epson.ssf			ssf
+application/vnd.ericsson.quickcall		qcall qca
+application/vnd.espass-espass+zip		espass
+application/vnd.eszigno3+xml			es3 et3
+application/vnd.etsi.aoc+xml
+application/vnd.etsi.asic-e+zip			asice sce
+application/vnd.etsi.asic-s+zip			asics
+application/vnd.etsi.cug+xml
+application/vnd.etsi.iptvcommand+xml
+application/vnd.etsi.iptvdiscovery+xml
+application/vnd.etsi.iptvprofile+xml
+application/vnd.etsi.iptvsad-bc+xml
+application/vnd.etsi.iptvsad-cod+xml
+application/vnd.etsi.iptvsad-npvr+xml
+application/vnd.etsi.iptvservice+xml
+application/vnd.etsi.iptvsync+xml
+application/vnd.etsi.iptvueprofile+xml
+application/vnd.etsi.mcid+xml
+application/vnd.etsi.mheg5
+application/vnd.etsi.overload-control-policy-dataset+xml
+application/vnd.etsi.pstn+xml
+application/vnd.etsi.sci+xml
+application/vnd.etsi.simservs+xml
+application/vnd.etsi.timestamp-token		tst
+application/vnd.etsi.tsl+xml
+application/vnd.etsi.tsl.der
+application/vnd.eu.kasparian.car+json		carjson
+application/vnd.eudora.data
+application/vnd.evolv.ecig.profile		ecigprofile
+application/vnd.evolv.ecig.settings		ecig
+application/vnd.evolv.ecig.theme		ecigtheme
+application/vnd.exstream-empower+zip		mpw
+application/vnd.exstream-package		pub
+application/vnd.ezpix-album			ez2
+application/vnd.ezpix-package			ez3
+application/vnd.f-secure.mobile
+application/vnd.familysearch.gedcom+zip		gdz
+application/vnd.fastcopy-disk-image		dim
+application/vnd.fdsn.mseed			msd mseed
+application/vnd.fdsn.seed			seed dataless
+application/vnd.ffsns
+application/vnd.ficlab.flb+zip			flb
+application/vnd.filmit.zfc			zfc
+application/vnd.fints
+application/vnd.firemonkeys.cloudcell
+application/vnd.FloGraphIt			gph
+application/vnd.fluxtime.clip			ftc
+application/vnd.font-fontforge-sfd		sfd
+application/vnd.framemaker			fm
+application/vnd.freelog.comic
+application/vnd.fsc.weblaunch			fsc
+application/vnd.fujifilm.fb.docuworks
+application/vnd.fujifilm.fb.docuworks.binder
+application/vnd.fujifilm.fb.docuworks.container
+application/vnd.fujifilm.fb.jfi+xml
+application/vnd.fujitsu.oasys			oas
+application/vnd.fujitsu.oasys2			oa2
+application/vnd.fujitsu.oasys3			oa3
+application/vnd.fujitsu.oasysgp			fg5
+application/vnd.fujitsu.oasysprs		bh2
+application/vnd.fujixerox.ART-EX
+application/vnd.fujixerox.ART4
+application/vnd.fujixerox.ddd			ddd
+application/vnd.fujixerox.HBPL
+application/vnd.fut-misnet
+application/vnd.futoin+cbor
+application/vnd.futoin+json
+application/vnd.fuzzysheet			fzs
+application/vnd.genomatix.tuxedo		txd
+application/vnd.genozip				genozip
+application/vnd.gentics.grd+json		grd
+application/vnd.gentoo.catmetadata+xml
+application/vnd.gentoo.ebuild			ebuild
+application/vnd.gentoo.eclass			eclass
+application/vnd.gentoo.gpkg			gpkg.tar
+application/vnd.gentoo.manifest
+application/vnd.gentoo.pkgmetadata+xml
+application/vnd.gentoo.xpak			xpak
+application/vnd.geogebra.file			ggb
+application/vnd.geogebra.slides			ggs
+application/vnd.geogebra.tool			ggt
+application/vnd.geometry-explorer		gex gre
+application/vnd.geonext				gxt
+application/vnd.geoplan				g2w
+application/vnd.geospace			g3w
+application/vnd.gerber
+application/vnd.globalplatform.card-content-mgt
+application/vnd.globalplatform.card-content-mgt-response
+application/vnd.gnu.taler.exchange+json
+application/vnd.gnu.taler.merchant+json
+application/vnd.google-earth.kml+xml		kml
+application/vnd.google-earth.kmz		kmz
+application/vnd.gov.sk.e-form+xml
+application/vnd.gov.sk.e-form+zip
+application/vnd.gov.sk.xmldatacontainer+xml
+application/vnd.gpxsee.map+xml
+application/vnd.grafeq				gqf gqs
+application/vnd.gridmp
+application/vnd.groove-account			gac
+application/vnd.groove-help			ghf
+application/vnd.groove-identity-message		gim
+application/vnd.groove-injector			grv
+application/vnd.groove-tool-message		gtm
+application/vnd.groove-tool-template		tpl
+application/vnd.groove-vcard			vcg
+application/vnd.hal+json
+application/vnd.hal+xml				hal
+application/vnd.HandHeld-Entertainment+xml	zmm
+application/vnd.hbci				hbci hbc kom upa pkd bpd
+application/vnd.hc+json
+application/vnd.hcl-bireports
+application/vnd.hdt				hdt
+application/vnd.heroku+json
+application/vnd.hhe.lesson-player		les
+application/vnd.hp-HPGL				hpgl
+application/vnd.hp-hpid				hpi hpid
+application/vnd.hp-hps				hps
+application/vnd.hp-jlyt				jlt
+application/vnd.hp-PCL				pcl
+application/vnd.hp-PCLXL
+application/vnd.hsl				hsl
+application/vnd.httphone
+application/vnd.hydrostatix.sof-data		sfd-hdstx
+application/vnd.hyper+json
+application/vnd.hyper-item+json
+application/vnd.hyperdrive+json
+application/vnd.hzn-3d-crossword
+application/vnd.ibm.electronic-media		emm
+application/vnd.ibm.MiniPay			mpy
+application/vnd.ibm.rights-management		irm
+application/vnd.ibm.secure-container		sc
+application/vnd.iccprofile			icc icm
+application/vnd.ieee.1905			1905.1
+application/vnd.igloader			igl
+application/vnd.imagemeter.folder+zip		imf
+application/vnd.imagemeter.image+zip		imi
+application/vnd.immervision-ivp			ivp
+application/vnd.immervision-ivu			ivu
+application/vnd.ims.imsccv1p1			imscc
+application/vnd.ims.imsccv1p2
+application/vnd.ims.imsccv1p3
+application/vnd.ims.lis.v2.result+json
+application/vnd.ims.lti.v2.toolconsumerprofile+json
+application/vnd.ims.lti.v2.toolproxy+json
+application/vnd.ims.lti.v2.toolproxy.id+json
+application/vnd.ims.lti.v2.toolsettings+json
+application/vnd.ims.lti.v2.toolsettings.simple+json
+application/vnd.informedcontrol.rms+xml
+application/vnd.infotech.project
+application/vnd.infotech.project+xml
+application/vnd.innopath.wamp.notification
+application/vnd.insors.igm			igm
+application/vnd.intercon.formnet		xpw xpx
+application/vnd.intergeo			i2g
+application/vnd.intertrust.digibox
+application/vnd.intertrust.nncp
+application/vnd.intu.qbo			qbo
+application/vnd.intu.qfx			qfx
+application/vnd.ipfs.ipns-record		ipns-record
+application/vnd.ipld.car			car
+application/vnd.ipld.dag-cbor
+application/vnd.ipld.dag-json
+application/vnd.ipld.raw
+application/vnd.iptc.g2.catalogitem+xml
+application/vnd.iptc.g2.conceptitem+xml
+application/vnd.iptc.g2.knowledgeitem+xml
+application/vnd.iptc.g2.newsitem+xml
+application/vnd.iptc.g2.newsmessage+xml
+application/vnd.iptc.g2.packageitem+xml
+application/vnd.iptc.g2.planningitem+xml
+application/vnd.ipunplugged.rcprofile		rcprofile
+application/vnd.irepository.package+xml		irp
+application/vnd.is-xpr				xpr
+application/vnd.isac.fcs			fcs
+application/vnd.iso11783-10+zip
+application/vnd.jam				jam
+application/vnd.japannet-directory-service
+application/vnd.japannet-jpnstore-wakeup
+application/vnd.japannet-payment-wakeup
+application/vnd.japannet-registration
+application/vnd.japannet-registration-wakeup
+application/vnd.japannet-setstore-wakeup
+application/vnd.japannet-verification
+application/vnd.japannet-verification-wakeup
+application/vnd.jcp.javame.midlet-rms		rms
+application/vnd.jisp				jisp
+application/vnd.joost.joda-archive		joda
+application/vnd.jsk.isdn-ngn
+application/vnd.kahootz				ktz ktr
+application/vnd.kde.karbon			karbon
+application/vnd.kde.kchart			chrt
+application/vnd.kde.kformula			kfo
+application/vnd.kde.kivio			flw
+application/vnd.kde.kontour			kon
+application/vnd.kde.kpresenter			kpr kpt
+application/vnd.kde.kspread			ksp
+application/vnd.kde.kword			kwd kwt
+application/vnd.kenameaapp			htke
+application/vnd.kidspiration			kia
+application/vnd.Kinar				kne knp sdf
+application/vnd.koan				skp skd skm skt
+application/vnd.kodak-descriptor		sse
+application/vnd.las				las
+application/vnd.las.las+json			lasjson
+application/vnd.las.las+xml			lasxml
+application/vnd.laszip
+application/vnd.leap+json
+application/vnd.liberty-request+xml
+application/vnd.llamagraphics.life-balance.desktop	lbd
+application/vnd.llamagraphics.life-balance.exchange+xml	lbe
+application/vnd.logipipe.circuit+zip		lcs lca
+application/vnd.loom				loom
+application/vnd.lotus-1-2-3			123 wk4 wk3 wk1
+application/vnd.lotus-approach			apr vew
+application/vnd.lotus-freelance			prz pre
+application/vnd.lotus-notes			nsf ntf ndl ns4 ns3 ns2 nsh nsg
+application/vnd.lotus-organizer			or3 or2 org
+application/vnd.lotus-screencam			scm
+application/vnd.lotus-wordpro			lwp sam
+application/vnd.macports.portpkg		portpkg
+application/vnd.mapbox-vector-tile		mvt
+application/vnd.marlin.drm.actiontoken+xml
+application/vnd.marlin.drm.conftoken+xml
+application/vnd.marlin.drm.license+xml
+application/vnd.marlin.drm.mdcf			mdc
+application/vnd.mason+json
+application/vnd.maxar.archive.3tz+zip		3tz
+application/vnd.maxmind.maxmind-db		mmdb
+application/vnd.mcd				mcd
+application/vnd.mdl				mdl
+application/vnd.mdl-mbsdf			mbsdf
+application/vnd.medcalcdata			mc1
+application/vnd.mediastation.cdkey		cdkey
+application/vnd.medicalholodeck.recordxr	rxt
+application/vnd.meridian-slingshot
+application/vnd.MFER				mwf
+application/vnd.mfmp				mfm
+application/vnd.micro+json
+application/vnd.micrografx.flo			flo
+application/vnd.micrografx.igx			igx
+application/vnd.microsoft.portable-executable
+application/vnd.microsoft.windows.thumbnail-cache
+application/vnd.miele+json
+application/vnd.mif				mif
+application/vnd.minisoft-hp3000-save
+application/vnd.mitsubishi.misty-guard.trustweb
+application/vnd.Mobius.DAF			daf
+application/vnd.Mobius.DIS			dis
+application/vnd.Mobius.MBK			mbk
+application/vnd.Mobius.MQY			mqy
+application/vnd.Mobius.MSL			msl
+application/vnd.Mobius.PLC			plc
+application/vnd.Mobius.TXF			txf
+application/vnd.modl				modl
+application/vnd.mophun.application		mpn
+application/vnd.mophun.certificate		mpc
+application/vnd.motorola.flexsuite
+application/vnd.motorola.flexsuite.adsi
+application/vnd.motorola.flexsuite.fis
+application/vnd.motorola.flexsuite.gotap
+application/vnd.motorola.flexsuite.kmr
+application/vnd.motorola.flexsuite.ttc
+application/vnd.motorola.flexsuite.wem
+application/vnd.motorola.iprm
+application/vnd.mozilla.xul+xml			xul
+application/vnd.ms-3mfdocument			3mf
+application/vnd.ms-artgalry			cil
+application/vnd.ms-asf				asf
+application/vnd.ms-cab-compressed		cab
+application/vnd.ms-excel			xls xlm xla xlc xlt xlw
+application/vnd.ms-excel.addin.macroEnabled.12	xlam
+application/vnd.ms-excel.sheet.binary.macroEnabled.12	xlsb
+application/vnd.ms-excel.sheet.macroEnabled.12	xlsm
+application/vnd.ms-excel.template.macroEnabled.12	xltm
+application/vnd.ms-fontobject			eot
+application/vnd.ms-htmlhelp			chm
+application/vnd.ms-ims				ims
+application/vnd.ms-lrm				lrm
+application/vnd.ms-office.activeX+xml
+application/vnd.ms-officetheme			thmx
+application/vnd.ms-pki.seccat			cat
+application/vnd.ms-playready.initiator+xml
+application/vnd.ms-powerpoint							ppt pps
+application/vnd.ms-powerpoint.addin.macroEnabled.12				ppam
+application/vnd.ms-powerpoint.presentation.macroEnabled.12			pptm
+application/vnd.ms-powerpoint.slide.macroEnabled.12				sldm
+application/vnd.ms-powerpoint.slideshow.macroEnabled.12				ppsm
+application/vnd.ms-powerpoint.template.macroEnabled.12				potm
+application/vnd.ms-PrintDeviceCapabilities+xml
+application/vnd.ms-PrintSchemaTicket+xml
+application/vnd.ms-project			mpp mpt
+application/vnd.ms-tnef				tnef tnf
+application/vnd.ms-windows.devicepairing
+application/vnd.ms-windows.nwprinting.oob
+application/vnd.ms-windows.printerpairing
+application/vnd.ms-windows.wsd.oob
+application/vnd.ms-wmdrm.lic-chlg-req
+application/vnd.ms-wmdrm.lic-resp
+application/vnd.ms-wmdrm.meter-chlg-req
+application/vnd.ms-wmdrm.meter-resp
+application/vnd.ms-word.document.macroEnabled.12				docm
+application/vnd.ms-word.template.macroEnabled.12				dotm
+application/vnd.ms-works			wcm wdb wks wps
+application/vnd.ms-wpl				wpl
+application/vnd.ms-xpsdocument			xps
+application/vnd.msa-disk-image			msa
+application/vnd.mseq				mseq
+application/vnd.msign
+application/vnd.multiad.creator			crtr
+application/vnd.multiad.creator.cif		cif
+application/vnd.music-niff
+application/vnd.musician			mus
+application/vnd.muvee.style			msty
+application/vnd.mynfc				taglet
+application/vnd.nacamar.ybrid+json
+application/vnd.ncd.control
+application/vnd.ncd.reference
+application/vnd.nearst.inv+json
+application/vnd.nebumind.line			nebul line
+application/vnd.nervana				entity request bkm kcm
+application/vnd.netfpx
+application/vnd.neurolanguage.nlu		nlu
+application/vnd.nimn				nimn
+application/vnd.nintendo.nitro.rom		nds
+application/vnd.nintendo.snes.rom		sfc smc
+application/vnd.nitf				nitf
+application/vnd.noblenet-directory		nnd
+application/vnd.noblenet-sealer			nns
+application/vnd.noblenet-web			nnw
+application/vnd.nokia.catalogs
+application/vnd.nokia.conml+wbxml
+application/vnd.nokia.conml+xml
+application/vnd.nokia.iptv.config+xml
+application/vnd.nokia.iSDS-radio-presets
+application/vnd.nokia.landmark+wbxml
+application/vnd.nokia.landmark+xml
+application/vnd.nokia.landmarkcollection+xml
+application/vnd.nokia.n-gage.ac+xml
+application/vnd.nokia.n-gage.data		ngdat
+application/vnd.nokia.ncd
+application/vnd.nokia.pcd+wbxml
+application/vnd.nokia.pcd+xml
+application/vnd.nokia.radio-preset		rpst
+application/vnd.nokia.radio-presets		rpss
+application/vnd.novadigm.EDM			edm
+application/vnd.novadigm.EDX			edx
+application/vnd.novadigm.EXT			ext
+application/vnd.ntt-local.content-share
+application/vnd.ntt-local.file-transfer
+application/vnd.ntt-local.ogw_remote-access
+application/vnd.ntt-local.sip-ta_remote
+application/vnd.ntt-local.sip-ta_tcp_stream
+application/vnd.oasis.opendocument.base						odb
+application/vnd.oasis.opendocument.chart					odc
+application/vnd.oasis.opendocument.chart-template				otc
+application/vnd.oasis.opendocument.formula					odf
+application/vnd.oasis.opendocument.formula-template
+application/vnd.oasis.opendocument.graphics					odg
+application/vnd.oasis.opendocument.graphics-template				otg
+application/vnd.oasis.opendocument.image					odi
+application/vnd.oasis.opendocument.image-template				oti
+application/vnd.oasis.opendocument.presentation					odp
+application/vnd.oasis.opendocument.presentation-template			otp
+application/vnd.oasis.opendocument.spreadsheet					ods
+application/vnd.oasis.opendocument.spreadsheet-template				ots
+application/vnd.oasis.opendocument.text						odt
+application/vnd.oasis.opendocument.text-master					odm
+application/vnd.oasis.opendocument.text-master-template				otm
+application/vnd.oasis.opendocument.text-template				ott
+application/vnd.oasis.opendocument.text-web					oth
+application/vnd.obn
+application/vnd.ocf+cbor
+application/vnd.oci.image.manifest.v1+json
+application/vnd.oftn.l10n+json
+application/vnd.oipf.contentaccessdownload+xml
+application/vnd.oipf.contentaccessstreaming+xml
+application/vnd.oipf.cspg-hexbinary
+application/vnd.oipf.dae.svg+xml
+application/vnd.oipf.dae.xhtml+xml
+application/vnd.oipf.mippvcontrolmessage+xml
+application/vnd.oipf.pae.gem
+application/vnd.oipf.spdiscovery+xml
+application/vnd.oipf.spdlist+xml
+application/vnd.oipf.ueprofile+xml
+application/vnd.oipf.userprofile+xml
+application/vnd.olpc-sugar			xo
+application/vnd.oma-scws-config
+application/vnd.oma-scws-http-request
+application/vnd.oma-scws-http-response
+application/vnd.oma.bcast.associated-procedure-parameter+xml
+application/vnd.oma.bcast.drm-trigger+xml
+application/vnd.oma.bcast.imd+xml
+application/vnd.oma.bcast.ltkm
+application/vnd.oma.bcast.notification+xml
+application/vnd.oma.bcast.provisioningtrigger
+application/vnd.oma.bcast.sgboot
+application/vnd.oma.bcast.sgdd+xml
+application/vnd.oma.bcast.sgdu
+application/vnd.oma.bcast.simple-symbol-container
+application/vnd.oma.bcast.smartcard-trigger+xml
+application/vnd.oma.bcast.sprov+xml
+application/vnd.oma.bcast.stkm
+application/vnd.oma.cab-address-book+xml
+application/vnd.oma.cab-feature-handler+xml
+application/vnd.oma.cab-pcc+xml
+application/vnd.oma.cab-subs-invite+xml
+application/vnd.oma.cab-user-prefs+xml
+application/vnd.oma.dcd
+application/vnd.oma.dcdc
+application/vnd.oma.dd2+xml			dd2
+application/vnd.oma.drm.risd+xml
+application/vnd.oma.group-usage-list+xml
+application/vnd.oma.lwm2m+cbor
+application/vnd.oma.lwm2m+json
+application/vnd.oma.lwm2m+tlv
+application/vnd.oma.pal+xml
+application/vnd.oma.poc.detailed-progress-report+xml
+application/vnd.oma.poc.final-report+xml
+application/vnd.oma.poc.groups+xml
+application/vnd.oma.poc.invocation-descriptor+xml
+application/vnd.oma.poc.optimized-progress-report+xml
+application/vnd.oma.push
+application/vnd.oma.scidm.messages+xml
+application/vnd.oma.xcap-directory+xml
+application/vnd.omads-email+xml
+application/vnd.omads-file+xml
+application/vnd.omads-folder+xml
+application/vnd.omaloc-supl-init
+application/vnd.onepager			tam
+application/vnd.onepagertamp			tamp
+application/vnd.onepagertamx			tamx
+application/vnd.onepagertat			tat
+application/vnd.onepagertatp			tatp
+application/vnd.onepagertatx			tatx
+application/vnd.onvif.metadata
+application/vnd.openblox.game+xml		obgx
+application/vnd.openblox.game-binary		obg
+application/vnd.openeye.oeb			oeb
+application/vnd.openofficeorg.extension		oxt
+application/vnd.openstreetmap.data+xml		osm
+application/vnd.opentimestamps.ots
+application/vnd.openxmlformats-officedocument.custom-properties+xml
+application/vnd.openxmlformats-officedocument.customXmlProperties+xml
+application/vnd.openxmlformats-officedocument.drawing+xml
+application/vnd.openxmlformats-officedocument.drawingml.chart+xml
+application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml
+application/vnd.openxmlformats-officedocument.extended-properties+xml
+application/vnd.openxmlformats-officedocument.presentationml.commentAuthors+xml
+application/vnd.openxmlformats-officedocument.presentationml.comments+xml
+application/vnd.openxmlformats-officedocument.presentationml.handoutMaster+xml
+application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml
+application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml
+application/vnd.openxmlformats-officedocument.presentationml.presentation	pptx
+application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml
+application/vnd.openxmlformats-officedocument.presentationml.presProps+xml
+application/vnd.openxmlformats-officedocument.presentationml.slide		sldx
+application/vnd.openxmlformats-officedocument.presentationml.slide+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideshow		ppsx
+application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideUpdateInfo+xml
+application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml
+application/vnd.openxmlformats-officedocument.presentationml.tags+xml
+application/vnd.openxmlformats-officedocument.presentationml.template		potx
+application/vnd.openxmlformats-officedocument.presentationml.template.main+xml
+application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheet		xlsx
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.template		xltx
+application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml
+application/vnd.openxmlformats-officedocument.theme+xml
+application/vnd.openxmlformats-officedocument.themeOverride+xml
+application/vnd.openxmlformats-officedocument.vmlDrawing
+application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.document		docx
+application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.template		dotx
+application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml
+application/vnd.openxmlformats-package.core-properties+xml
+application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml
+application/vnd.openxmlformats-package.relationships+xml
+application/vnd.oracle.resource+json
+application/vnd.orange.indata
+application/vnd.osa.netdeploy			ndc
+application/vnd.osgeo.mapguide.package		mgp
+application/vnd.osgi.bundle
+application/vnd.osgi.dp				dp
+application/vnd.osgi.subsystem			esa
+application/vnd.otps.ct-kip+xml
+application/vnd.oxli.countgraph			oxlicg
+application/vnd.pagerduty+json
+application/vnd.palm				pdb pqa oprc
+application/vnd.panoply				plp
+application/vnd.paos.xml
+application/vnd.patentdive			dive
+application/vnd.patientecommsdoc
+application/vnd.pawaafile			paw
+application/vnd.pcos
+application/vnd.pg.format			str
+application/vnd.pg.osasli			ei6
+application/vnd.piaccess.application-licence	pil
+application/vnd.picsel				efif
+application/vnd.pmi.widget			wg
+application/vnd.poc.group-advertisement+xml
+application/vnd.pocketlearn			plf
+application/vnd.powerbuilder6			pbd
+application/vnd.powerbuilder6-s
+application/vnd.powerbuilder7
+application/vnd.powerbuilder7-s
+application/vnd.powerbuilder75
+application/vnd.powerbuilder75-s
+application/vnd.preminet			preminet
+application/vnd.previewsystems.box		box vbox
+application/vnd.proteus.magazine		mgz
+application/vnd.psfs				psfs
+application/vnd.pt.mundusmundi
+application/vnd.publishare-delta-tree		qps
+application/vnd.pvi.ptid1			ptid
+application/vnd.pwg-multiplexed
+application/vnd.pwg-xhtml-print+xml
+application/vnd.qualcomm.brew-app-res		bar
+application/vnd.quarantainenet
+application/vnd.Quark.QuarkXPress		qxd qxt qwd qwt qxl qxb
+application/vnd.quobject-quoxdocument		quox quiz
+application/vnd.radisys.moml+xml
+application/vnd.radisys.msml+xml
+application/vnd.radisys.msml-audit+xml
+application/vnd.radisys.msml-audit-conf+xml
+application/vnd.radisys.msml-audit-conn+xml
+application/vnd.radisys.msml-audit-dialog+xml
+application/vnd.radisys.msml-audit-stream+xml
+application/vnd.radisys.msml-conf+xml
+application/vnd.radisys.msml-dialog+xml
+application/vnd.radisys.msml-dialog-base+xml
+application/vnd.radisys.msml-dialog-fax-detect+xml
+application/vnd.radisys.msml-dialog-fax-sendrecv+xml
+application/vnd.radisys.msml-dialog-group+xml
+application/vnd.radisys.msml-dialog-speech+xml
+application/vnd.radisys.msml-dialog-transform+xml
+application/vnd.rainstor.data			tree
+application/vnd.rapid
+application/vnd.rar				rar
+application/vnd.realvnc.bed			bed
+application/vnd.recordare.musicxml		mxl
+application/vnd.recordare.musicxml+xml
+application/vnd.RenLearn.rlprint
+application/vnd.resilient.logic			rlm reload
+application/vnd.restful+json
+application/vnd.rig.cryptonote			cryptonote
+application/vnd.rim.cod								cod
+application/vnd.route66.link66+xml		link66
+application/vnd.rs-274x
+application/vnd.ruckus.download
+application/vnd.s3sms
+application/vnd.sailingtracker.track		st
+application/vnd.sar				SAR
+application/vnd.sbm.cid
+application/vnd.sbm.mid2
+application/vnd.scribus				scd sla slaz
+application/vnd.sealed.3df			s3df
+application/vnd.sealed.csf			scsf
+application/vnd.sealed.doc			sdoc sdo s1w
+application/vnd.sealed.eml			seml sem
+application/vnd.sealed.mht			smht smh
+application/vnd.sealed.net
+application/vnd.sealed.ppt			sppt s1p
+application/vnd.sealed.tiff			stif
+application/vnd.sealed.xls			sxls sxl s1e
+application/vnd.sealedmedia.softseal.html	stml s1h
+application/vnd.sealedmedia.softseal.pdf	spdf spd s1a
+application/vnd.seemail				see
+application/vnd.seis+json
+application/vnd.sema				sema
+application/vnd.semd				semd
+application/vnd.semf				semf
+application/vnd.shade-save-file			ssv
+application/vnd.shana.informed.formdata		ifm
+application/vnd.shana.informed.formtemplate	itp
+application/vnd.shana.informed.interchange	iif
+application/vnd.shana.informed.package		ipk
+application/vnd.shootproof+json
+application/vnd.shopkick+json
+application/vnd.shp				shp
+application/vnd.shx				shx
+application/vnd.sigrok.session			sr
+application/vnd.SimTech-MindMapper		twd twds
+application/vnd.siren+json
+application/vnd.smaf				mmf
+application/vnd.smart.notebook			notebook
+application/vnd.smart.teacher			teacher
+application/vnd.smintio.portals.archive		sipa
+application/vnd.snesdev-page-table		ptrom pt
+application/vnd.software602.filler.form+xml	fo
+application/vnd.software602.filler.form-xml-zip	zfo
+application/vnd.solent.sdkm+xml			sdkm sdkd
+application/vnd.spotfire.dxp			dxp
+application/vnd.spotfire.sfs			sfs
+application/vnd.sqlite3				sqlite sqlite3
+application/vnd.sss-cod
+application/vnd.sss-dtf
+application/vnd.sss-ntf
+application/vnd.stardivision.calc						sdc
+application/vnd.stardivision.chart						sds
+application/vnd.stardivision.draw						sda
+application/vnd.stardivision.impress						sdd
+application/vnd.stardivision.math						smf
+application/vnd.stardivision.writer						sdw
+application/vnd.stardivision.writer-global					sgl
+application/vnd.stepmania.package		smzip
+application/vnd.stepmania.stepchart		sm
+application/vnd.street-stream
+application/vnd.sun.wadl+xml			wadl
+application/vnd.sun.xml.calc							sxc
+application/vnd.sun.xml.calc.template						stc
+application/vnd.sun.xml.draw							sxd
+application/vnd.sun.xml.draw.template						std
+application/vnd.sun.xml.impress							sxi
+application/vnd.sun.xml.impress.template					sti
+application/vnd.sun.xml.math							sxm
+application/vnd.sun.xml.writer							sxw
+application/vnd.sun.xml.writer.global						sxg
+application/vnd.sun.xml.writer.template						stw
+application/vnd.sus-calendar			sus susp
+application/vnd.svd
+application/vnd.swiftview-ics
+application/vnd.sybyl.mol2			ml2 mol2 sy2
+application/vnd.sycle+xml			scl
+application/vnd.syft+json			syft.json
+application/vnd.symbian.install							sis
+application/vnd.syncml+xml			xsm
+application/vnd.syncml.dm+wbxml			bdm
+application/vnd.syncml.dm+xml			xdm
+application/vnd.syncml.dm.notification
+application/vnd.syncml.dmddf+wbxml
+application/vnd.syncml.dmddf+xml		ddf
+application/vnd.syncml.dmtnds+wbxml
+application/vnd.syncml.dmtnds+xml
+application/vnd.syncml.ds.notification
+application/vnd.tableschema+json
+application/vnd.tao.intent-module-archive	tao
+application/vnd.tcpdump.pcap			pcap cap dmp
+application/vnd.theqvd				qvd
+application/vnd.think-cell.ppttc+json		ppttc
+application/vnd.tmd.mediaflex.api+xml
+application/vnd.tml				vfr viaframe
+application/vnd.tmobile-livetv			tmo
+application/vnd.tri.onesource
+application/vnd.trid.tpt			tpt
+application/vnd.triscape.mxs			mxs
+application/vnd.trueapp				tra
+application/vnd.truedoc
+application/vnd.ubisoft.webplayer
+application/vnd.ufdl				ufdl ufd frm
+application/vnd.uiq.theme			utz
+application/vnd.umajin				umj
+application/vnd.unity				unityweb
+application/vnd.uoml+xml			uoml uo
+application/vnd.uplanet.alert
+application/vnd.uplanet.alert-wbxml
+application/vnd.uplanet.bearer-choice
+application/vnd.uplanet.bearer-choice-wbxml
+application/vnd.uplanet.cacheop
+application/vnd.uplanet.cacheop-wbxml
+application/vnd.uplanet.channel
+application/vnd.uplanet.channel-wbxml
+application/vnd.uplanet.list
+application/vnd.uplanet.list-wbxml
+application/vnd.uplanet.listcmd
+application/vnd.uplanet.listcmd-wbxml
+application/vnd.uplanet.signal
+application/vnd.uri-map				urim urimap
+application/vnd.valve.source.material		vmt
+application/vnd.vcx				vcx
+application/vnd.vd-study			mxi study-inter model-inter
+application/vnd.vectorworks			vwx
+application/vnd.vel+json
+application/vnd.verimatrix.vcas
+application/vnd.veritone.aion+json		aion vtnstd
+application/vnd.veryant.thin			istc isws
+application/vnd.ves.encrypted			VES
+application/vnd.vidsoft.vidconference		vsc
+application/vnd.visio				vsd vst vsw vss
+application/vnd.visionary			vis
+application/vnd.vividence.scriptfile
+application/vnd.vsf				vsf
+application/vnd.wap.sic				sic
+application/vnd.wap.slc				slc
+application/vnd.wap.wbxml			wbxml
+application/vnd.wap.wmlc			wmlc
+application/vnd.wap.wmlscriptc			wmlsc
+application/vnd.wasmflow.wafl			wafl
+application/vnd.webturbo			wtb
+application/vnd.wfa.dpp
+application/vnd.wfa.p2p				p2p
+application/vnd.wfa.wsc				wsc
+application/vnd.windows.devicepairing
+application/vnd.wmc				wmc
+application/vnd.wmf.bootstrap
+application/vnd.wolfram.mathematica		nb
+application/vnd.wolfram.mathematica.package	m
+application/vnd.wolfram.player			nbp
+application/vnd.wordlift
+application/vnd.wordperfect			wpd
+application/vnd.wqd				wqd
+application/vnd.wrq-hp3000-labelled
+application/vnd.wt.stf				stf
+application/vnd.wv.csp+wbxml			wv
+application/vnd.wv.csp+xml
+application/vnd.wv.ssp+xml
+application/vnd.xacml+json
+application/vnd.xara				xar
+application/vnd.xfdl				xfdl xfd
+application/vnd.xfdl.webform
+application/vnd.xmi+xml
+application/vnd.xmpie.cpkg			cpkg
+application/vnd.xmpie.dpkg			dpkg
+application/vnd.xmpie.plan
+application/vnd.xmpie.ppkg			ppkg
+application/vnd.xmpie.xlim			xlim
+application/vnd.yamaha.hv-dic			hvd
+application/vnd.yamaha.hv-script		hvs
+application/vnd.yamaha.hv-voice			hvp
+application/vnd.yamaha.openscoreformat		osf
+application/vnd.yamaha.openscoreformat.osfpvg+xml
+application/vnd.yamaha.remote-setup
+application/vnd.yamaha.smaf-audio		saf
+application/vnd.yamaha.smaf-phrase		spf
+application/vnd.yamaha.through-ngn
+application/vnd.yamaha.tunnel-udpencap
+application/vnd.yaoweme				yme
+application/vnd.yellowriver-custom-menu		cmp
+application/vnd.zul				zir zirz
+application/vnd.zzazz.deck+xml			zaz
+application/voicexml+xml			vxml
+application/voucher-cms+json			vcj
+application/vq-rtcpxr
+application/wasm				wasm
+application/watcherinfo+xml			wif
+application/webpush-options+json
+application/whoispp-query
+application/whoispp-response
+application/widget				wgt
+application/wita
+application/wordperfect5.1
+application/wsdl+xml				wsdl
+application/wspolicy+xml			wspolicy
+application/x-123				wk
+application/x-7z-compressed			7z
+application/x-abiword				abw
+application/x-apple-diskimage			dmg
+application/x-bcpio				bcpio
+application/x-bittorrent			torrent
+application/x-cdf				cdf cda
+application/x-cdlink				vcd
+application/x-comsol				mph
+application/x-cpio				cpio
+application/x-csh				csh
+application/x-director				dcr dir dxr
+application/x-doom				wad
+application/x-dvi				dvi
+application/x-font				pfa pfb gsf
+application/x-font-pcf				pcf pcf.Z
+application/x-freemind				mm
+application/x-ganttproject			gan
+application/x-gnumeric				gnumeric
+application/x-go-sgf				sgf
+application/x-graphing-calculator		gcf
+application/x-gtar				gtar
+application/x-gtar-compressed			tgz taz
+application/x-hdf				hdf
+application/x-hwp				hwp
+application/x-ica				ica
+application/x-info				info
+application/x-internet-signup			ins isp
+application/x-iphone				iii
+application/x-iso9660-image			iso
+application/x-java-jnlp-file			jnlp
+application/x-jmol				jmz
+application/x-killustrator			kil
+application/x-latex				latex
+application/x-lha				lha
+application/x-lyx				lyx
+application/x-lzh				lzh
+application/x-lzx				lzx
+application/x-maker				frm maker frame fm fb book fbdoc
+application/x-ms-wmd				wmd
+application/x-ms-wmz				wmz
+application/x-msdos-program			com exe bat dll
+application/x-msi				msi
+application/x-netcdf				nc
+application/x-ns-proxy-autoconfig		pac
+application/x-nwc				nwc
+application/x-object				o
+application/x-oz-application			oza
+application/x-pkcs7-certreqresp			p7r
+application/x-pki-message
+application/x-python-code			pyc pyo
+application/x-qgis				qgs shp shx
+application/x-quicktimeplayer			qtl
+application/x-rdp				rdp
+application/x-redhat-package-manager		rpm
+application/x-rss+xml				rss
+application/x-ruby				rb
+application/x-scilab				sci sce
+application/x-scilab-xcos			xcos
+application/x-sh				sh
+application/x-shar				shar
+application/x-silverlight			scr
+application/x-stuffit				sit sitx
+application/x-sv4cpio				sv4cpio
+application/x-sv4crc				sv4crc
+application/x-tar				tar
+application/x-tcl				tcl
+application/x-tex-gf				gf
+application/x-tex-pk				pk
+application/x-texinfo				texinfo texi
+application/x-trash				~ % bak old sik
+application/x-troff-man				man
+application/x-troff-me				me
+application/x-troff-ms				ms
+application/x-ustar				ustar
+application/x-wais-source			src
+application/x-wingz				wz
+application/x-www-form-urlencoded
+application/x-x509-ca-cert			crt
+application/x-x509-ca-ra-cert
+application/x-x509-next-ca-cert
+application/x-xfig				fig
+application/x-xpinstall				xpi
+application/x-xz				xz
+application/x400-bp
+application/xacml+xml
+application/xcap-att+xml			xav
+application/xcap-caps+xml			xca
+application/xcap-diff+xml			xdf
+application/xcap-el+xml				xel
+application/xcap-error+xml			xer
+application/xcap-ns+xml				xns
+application/xcon-conference-info+xml
+application/xcon-conference-info-diff+xml
+application/xenc+xml
+application/xfdf				xfdf
+application/xhtml+xml				xhtml xhtm xht
+application/xliff+xml				xlf
+application/xml					xml
+application/xml-dtd				dtd mod
+application/xml-external-parsed-entity		ent
+application/xml-patch+xml
+application/xmpp+xml
+application/xop+xml				xop
+application/xslt+xml				xsl xslt
+application/xspf+xml				xspf
+application/xv+xml				mxml xhvml xvml xvm
+application/yaml				yaml yml
+application/yang				yang
+application/yang-data+cbor
+application/yang-data+json
+application/yang-data+xml
+application/yang-patch+json
+application/yang-patch+xml
+application/yin+xml				yin
+application/zip					zip
+application/zlib
+application/zstd				zst
+
+audio/1d-interleaved-parityfec
+audio/32kadpcm					726
+audio/3gpp
+audio/3gpp2
+audio/aac					adts aac ass
+audio/ac3					ac3
+audio/AMR					amr AMR
+audio/AMR-WB					awb AWB
+audio/amr-wb+
+audio/annodex					axa
+audio/aptx
+audio/asc					acn
+audio/ATRAC-ADVANCED-LOSSLESS			aal
+audio/ATRAC-X					atx
+audio/ATRAC3					at3 aa3 omg
+audio/basic					au snd
+audio/BV16
+audio/BV32
+audio/clearmode
+audio/CN
+audio/csound					csd orc sco
+audio/DAT12
+audio/dls					dls
+audio/dsr-es201108
+audio/dsr-es202050
+audio/dsr-es202211
+audio/dsr-es202212
+audio/DV
+audio/DVI4
+audio/eac3
+audio/encaprtp
+audio/EVRC					evc
+audio/EVRC-QCP					qcp QCP
+audio/EVRC0
+audio/EVRC1
+audio/EVRCB					evb
+audio/EVRCB0
+audio/EVRCB1
+audio/EVRCNW					enw
+audio/EVRCNW0
+audio/EVRCNW1
+audio/EVRCWB					evw
+audio/EVRCWB0
+audio/EVRCWB1
+audio/EVS
+audio/example
+audio/flac					flac
+audio/flexfec
+audio/fwdred
+audio/G711-0
+audio/G719
+audio/G722
+audio/G7221
+audio/G723
+audio/G726-16
+audio/G726-24
+audio/G726-32
+audio/G726-40
+audio/G728
+audio/G729
+audio/G7291
+audio/G729D
+audio/G729E
+audio/GSM
+audio/GSM-EFR
+audio/GSM-HR-08
+audio/iLBC					lbc
+audio/ip-mr_v2.5
+audio/L16					l16
+audio/L20
+audio/L24
+audio/L8
+audio/LPC
+audio/MELP
+audio/MELP1200
+audio/MELP2400
+audio/MELP600
+audio/mhas					mhas
+audio/mobile-xmf				mxmf
+audio/mp4					m4a
+audio/MP4A-LATM
+audio/MPA
+audio/mpa-robust
+audio/mpeg					mpga mpega mp1 mp2 mp3
+audio/mpeg4-generic
+audio/mpegurl					m3u
+audio/ogg					oga ogg opus spx
+audio/opus
+audio/parityfec
+audio/PCMA
+audio/PCMA-WB
+audio/PCMU
+audio/PCMU-WB
+audio/prs.sid					sid psid
+audio/QCELP
+audio/raptorfec
+audio/RED
+audio/rtp-enc-aescm128
+audio/rtp-midi
+audio/rtploopback
+audio/rtx
+audio/scip
+audio/SMV					smv
+audio/SMV-QCP
+audio/SMV0
+audio/sofa					sofa
+audio/sp-midi					mid
+audio/speex
+audio/t140c
+audio/t38
+audio/telephone-event
+audio/TETRA_ACELP
+audio/TETRA_ACELP_BB
+audio/tone
+audio/TSVCIS
+audio/UEMCLIP
+audio/ulpfec
+audio/usac					loas xhe
+audio/VDVI
+audio/VMR-WB
+audio/vnd.3gpp.iufp
+audio/vnd.4SB
+audio/vnd.audiokoz				koz
+audio/vnd.CELP
+audio/vnd.cisco.nse
+audio/vnd.cmles.radio-events
+audio/vnd.cns.anp1
+audio/vnd.cns.inf1
+audio/vnd.dece.audio				uva uvva
+audio/vnd.digital-winds				eol
+audio/vnd.dlna.adts
+audio/vnd.dolby.heaac.1
+audio/vnd.dolby.heaac.2
+audio/vnd.dolby.mlp				mlp
+audio/vnd.dolby.mps
+audio/vnd.dolby.pl2
+audio/vnd.dolby.pl2x
+audio/vnd.dolby.pl2z
+audio/vnd.dolby.pulse.1
+audio/vnd.dra
+audio/vnd.dts					dts
+audio/vnd.dts.hd				dtshd
+audio/vnd.dts.uhd
+audio/vnd.dvb.file
+audio/vnd.everad.plj				plj
+audio/vnd.hns.audio
+audio/vnd.lucent.voice				lvp
+audio/vnd.ms-playready.media.pya		pya
+audio/vnd.nokia.mobile-xmf
+audio/vnd.nortel.vbk				vbk
+audio/vnd.nuera.ecelp4800			ecelp4800
+audio/vnd.nuera.ecelp7470			ecelp7470
+audio/vnd.nuera.ecelp9600			ecelp9600
+audio/vnd.octel.sbc
+audio/vnd.presonus.multitrack			multitrack
+audio/vnd.rhetorex.32kadpcm
+audio/vnd.rip					rip
+audio/vnd.sealedmedia.softseal.mpeg		smp3 smp s1m
+audio/vnd.vmx.cvsd
+audio/vorbis
+audio/vorbis-config
+audio/x-aiff					aif aiff aifc
+audio/x-gsm					gsm
+audio/x-ms-wax					wax
+audio/x-ms-wma					wma
+audio/x-pn-realaudio				ra rm ram
+audio/x-scpls					pls
+audio/x-sd2					sd2
+audio/x-wav					wav
+
+chemical/x-alchemy				alc
+chemical/x-cache				cac cache
+chemical/x-cache-csf				csf
+chemical/x-cactvs-binary			cbin cascii ctab
+chemical/x-cdx					cdx
+chemical/x-cerius
+chemical/x-chem3d				c3d
+chemical/x-chemdraw				chm
+chemical/x-cif					cif
+chemical/x-cmdf					cmdf
+chemical/x-cml					cml
+chemical/x-compass				cpa
+chemical/x-crossfire				bsd
+chemical/x-csml					csml csm
+chemical/x-ctx					ctx
+chemical/x-cxf					cxf cef
+#chemical/x-daylight-smiles			smi
+chemical/x-embl-dl-nucleotide			emb embl
+chemical/x-galactic-spc				spc
+chemical/x-gamess-input				inp gam gamin
+chemical/x-gaussian-checkpoint			fch fchk
+chemical/x-gaussian-cube			cub
+chemical/x-gaussian-input			gau gjc gjf
+chemical/x-gaussian-log				gal
+chemical/x-gcg8-sequence			gcg
+chemical/x-genbank				gen
+chemical/x-hin					hin
+chemical/x-isostar				istr ist
+chemical/x-jcamp-dx				jdx dx
+chemical/x-kinemage				kin
+chemical/x-macmolecule				mcm
+chemical/x-macromodel-input			mmod
+chemical/x-mdl-molfile				mol
+chemical/x-mdl-rdfile				rd
+chemical/x-mdl-rxnfile				rxn
+chemical/x-mdl-sdfile				sd sdf
+chemical/x-mdl-tgf				tgf
+#chemical/x-mif					mif
+chemical/x-mmcif				mcif
+chemical/x-molconn-Z				b
+chemical/x-mopac-graph				gpt
+chemical/x-mopac-input				mop mopcrt mpc zmt
+chemical/x-mopac-out				moo
+chemical/x-mopac-vib				mvb
+chemical/x-ncbi-asn1				asn
+chemical/x-ncbi-asn1-ascii			prt
+chemical/x-ncbi-asn1-binary			val aso
+chemical/x-ncbi-asn1-spec			asn
+chemical/x-pdb					pdb
+chemical/x-rosdal				ros
+chemical/x-swissprot				sw
+chemical/x-vamas-iso14976			vms
+chemical/x-vmd					vmd
+chemical/x-xtel					xtel
+chemical/x-xyz					xyz
+
+font/collection					ttc
+font/otf					otf
+font/sfnt
+font/ttf					ttf
+font/woff					woff
+font/woff2					woff2
+
+image/aces					exr
+image/apng					apng
+image/avci					avci
+image/avcs					avcs
+image/avif					avif hif
+image/bmp					bmp
+image/cgm					cgm
+image/dicom-rle					drle
+image/dpx					dpx
+image/emf					emf
+image/example
+image/fits					fits fit fts
+image/g3fax
+image/gif					gif
+image/heic					heic
+image/heic-sequence				heics
+image/heif					heif
+image/heif-sequence				heifs
+image/hej2k					hej2
+image/hsj2					hsj2
+image/ief					ief
+image/j2c					j2c J2C j2k J2K
+image/jls					jls
+image/jp2					jp2 jpg2
+image/jpeg					jpeg jpg jpe jfif
+image/jph					jph
+image/jphc					jhc jphc
+image/jpm					jpm jpgm
+image/jpx					jpx jpf
+image/jxl					jxl
+image/jxr					jxr
+image/jxrA					jxra
+image/jxrS					jxrs
+image/jxs					jxs
+image/jxsc					jxsc
+image/jxsi					jxsi
+image/jxss					jxss
+image/ktx					ktx
+image/ktx2					ktx2
+image/naplps
+image/png					png
+image/prs.btif					btif btf
+image/prs.pti					pti
+image/pwg-raster
+image/svg+xml					svg svgz
+image/t38
+image/tiff					tiff tif
+image/tiff-fx					tfx
+image/vnd.adobe.photoshop			psd
+image/vnd.airzip.accelerator.azv		azv
+image/vnd.cns.inf2
+image/vnd.dece.graphic				uvi uvvi uvg uvvg
+image/vnd.djvu					djvu djv
+image/vnd.dvb.subtitle
+image/vnd.dwg					dwg
+image/vnd.dxf					dxf
+image/vnd.fastbidsheet				fbs
+image/vnd.fpx					fpx
+image/vnd.fst					fst
+image/vnd.fujixerox.edmics-mmr			mmr
+image/vnd.fujixerox.edmics-rlc			rlc
+image/vnd.globalgraphics.pgb			PGB pgb
+image/vnd.microsoft.icon			ico
+image/vnd.mix
+image/vnd.ms-modi				mdi
+image/vnd.net-fpx
+image/vnd.pco.b16				b16
+image/vnd.radiance				hdr rgbe xyze
+image/vnd.sealed.png				spng spn s1n
+image/vnd.sealedmedia.softseal.gif		sgif sgi s1g
+image/vnd.sealedmedia.softseal.jpg		sjpg sjp s1j
+image/vnd.svf
+image/vnd.tencent.tap				tap
+image/vnd.valve.source.texture			vtf
+image/vnd.wap.wbmp				wbmp
+image/vnd.xiff					xif
+image/vnd.zbrush.pcx				pcx
+image/webp					webp
+image/wmf					wmf
+image/x-canon-cr2				cr2
+image/x-canon-crw				crw
+image/x-cmu-raster				ras
+image/x-coreldraw				cdr
+image/x-coreldrawpattern			pat
+image/x-coreldrawtemplate			cdt
+image/x-corelphotopaint				cpt
+image/x-epson-erf				erf
+image/x-jg					art
+image/x-jng					jng
+image/x-nikon-nef				nef
+image/x-olympus-orf				orf
+image/x-portable-anymap				pnm
+image/x-portable-bitmap				pbm
+image/x-portable-graymap			pgm
+image/x-portable-pixmap				ppm
+image/x-rgb					rgb
+image/x-xbitmap					xbm
+image/x-xcf					xcf
+image/x-xpixmap					xpm
+image/x-xwindowdump				xwd
+
+inode/blockdevice
+inode/chardevice
+inode/directory
+inode/directory-locked
+inode/fifo
+inode/socket
+
+message/bhttp
+message/CPIM
+message/delivery-status
+message/disposition-notification
+message/example
+message/external-body
+message/feedback-report
+message/global					u8msg
+message/global-delivery-status			u8dsn
+message/global-disposition-notification		u8mdn
+message/global-headers				u8hdr
+message/http
+message/imdn+xml
+message/mls
+message/ohttp-req
+message/ohttp-res
+message/partial
+message/rfc822					eml mail art
+message/s-http
+message/sip
+message/sipfrag
+message/tracking-status
+message/vnd.wfa.wsc
+
+model/3mf
+model/e57
+model/example
+model/gltf+json					gltf
+model/gltf-binary				glb
+model/iges					igs iges
+model/JT					jt
+model/mesh					msh mesh silo
+model/mtl					mtl
+model/obj					obj
+model/prc					prc
+model/step					stp step
+model/step+xml					stpx
+model/step+zip					stpz
+model/step-xml+zip				stpxz
+model/stl					stl
+model/u3d					u3d
+model/vnd.bary					bary
+model/vnd.cld					cld
+model/vnd.collada+xml				dae
+model/vnd.dwf					dwf
+model/vnd.flatland.3dml
+model/vnd.gdl					gdl gsm win dor lmp rsm msm ism
+model/vnd.gs-gdl
+model/vnd.gtw					gtw
+model/vnd.moml+xml				moml
+model/vnd.mts					mts
+model/vnd.opengex				ogex
+model/vnd.parasolid.transmit.binary		x_b xmt_bin
+model/vnd.parasolid.transmit.text		x_t xmt_txt
+model/vnd.pytha.pyox				pyox
+model/vnd.rosette.annotated-data-model
+model/vnd.sap.vds				vds
+model/vnd.usda					usda
+model/vnd.usdz+zip				usdz
+model/vnd.valve.source.compiled-map		bsp
+model/vnd.vtu					vtu
+model/vrml					wrl vrm vrml
+model/x3d+fastinfoset				x3db
+model/x3d+xml					x3d x3dz
+model/x3d-vrml					x3dv x3dvz
+
+multipart/alternative
+multipart/appledouble
+multipart/byteranges
+multipart/digest
+multipart/encrypted
+multipart/example
+multipart/form-data
+multipart/header-set
+multipart/mixed
+multipart/multilingual
+multipart/parallel
+multipart/related
+multipart/report
+multipart/signed
+multipart/vnd.bint.med-plus			bmed
+multipart/voice-message				vpm
+multipart/x-mixed-replace
+
+text/1d-interleaved-parityfec
+text/cache-manifest				appcache manifest
+text/calendar					ics ifb
+text/cql					CQL
+text/cql-extension
+text/cql-identifier
+text/css					css
+text/csv					csv
+text/csv-schema					csvs
+text/dns					soa zone
+text/encaprtp
+text/enriched
+text/example
+text/fhirpath
+text/flexfec
+text/fwdred
+text/gff3					gff3
+text/grammar-ref-list
+text/hl7v2
+text/html					html htm shtml
+text/javascript					es js mjs
+text/jcr-cnd					cnd
+text/markdown					md markdown
+text/mizar					miz
+text/n3						n3
+text/parameters
+text/parityfec
+text/plain					txt text pot brf srt
+text/provenance-notation			provn
+text/prs.fallenstein.rst			rst
+text/prs.lines.tag				tag dsc
+text/prs.prop.logic
+text/raptorfec
+text/RED
+text/rfc822-headers
+text/rtf
+text/rtp-enc-aescm128
+text/rtploopback
+text/rtx
+text/SGML					sgml sgm
+text/shaclc					shaclc shc
+text/shex					shex
+text/spdx					spdx
+text/strings
+text/t140
+text/tab-separated-values			tsv
+text/texmacs					tm
+text/troff					t tr roff
+text/turtle					ttl
+text/ulpfec
+text/uri-list					uris uri
+text/vcard					vcf vcard
+text/vnd.a					a
+text/vnd.abc					abc
+text/vnd.ascii-art				ascii
+text/vnd.curl					curl
+text/vnd.debian.copyright			copyright
+text/vnd.DMClientScript				dms
+text/vnd.dvb.subtitle
+text/vnd.esmertec.theme-descriptor		jtd
+text/vnd.exchangeable				VFK
+text/vnd.familysearch.gedcom			ged
+text/vnd.ficlab.flt				flt
+text/vnd.fly					fly
+text/vnd.fmi.flexstor				flx
+text/vnd.gml
+text/vnd.graphviz				gv dot
+text/vnd.hans					hans
+text/vnd.hgl					hgl
+text/vnd.in3d.3dml				3dml 3dm
+text/vnd.in3d.spot				spot spo
+text/vnd.IPTC.NewsML
+text/vnd.IPTC.NITF
+text/vnd.latex-z
+text/vnd.motorola.reflex
+text/vnd.ms-mediapackage			mpf
+text/vnd.net2phone.commcenter.command		ccc
+text/vnd.radisys.msml-basic-layout
+text/vnd.senx.warpscript			mc2
+text/vnd.sosi					sos
+text/vnd.sun.j2me.app-descriptor		jad
+text/vnd.trolltech.linguist			ts
+text/vnd.wap.si					si
+text/vnd.wap.sl					sl
+text/vnd.wap.wml				wml
+text/vnd.wap.wmlscript				wmls
+text/vtt					vtt
+text/wgsl					wgsl
+text/x-bibtex					bib
+text/x-boo					boo
+text/x-c++hdr					h++ hpp hxx hh
+text/x-c++src					c++ cpp cxx cc
+text/x-chdr					h
+text/x-component				htc
+text/x-csh					csh
+text/x-csrc					c
+text/x-diff					diff patch
+text/x-dsrc					d
+text/x-haskell					hs
+text/x-java					java
+text/x-lilypond					ly
+text/x-literate-haskell				lhs
+text/x-moc					moc
+text/x-pascal					p pas
+text/x-pcs-gcd					gcd
+text/x-perl					pl pm
+text/x-python					py
+text/x-scala					scala
+text/x-setext					etx
+text/x-sfv					sfv
+text/x-sh					sh
+text/x-tcl					tcl tk
+text/x-tex					tex ltx sty cls
+text/x-vcalendar				vcs
+text/xml
+text/xml-dtd
+text/xml-external-parsed-entity
+
+video/1d-interleaved-parityfec
+video/3gpp
+video/3gpp-tt
+video/3gpp2
+video/annodex					axv
+video/AV1
+video/BMPEG
+video/BT656
+video/CelB
+video/DV
+video/dv					dif dv
+video/encaprtp
+video/example
+video/FFV1
+video/flexfec
+video/fli					fli
+video/gl					gl
+video/H261
+video/H263
+video/H263-1998
+video/H263-2000
+video/H264
+video/H264-RCDO
+video/H264-SVC
+video/H265
+video/H266
+video/iso.segment				m4s
+video/JPEG
+video/jpeg2000
+video/jxsv
+video/mj2					mj2 mjp2
+video/MP1S
+video/MP2P
+video/MP2T
+video/mp4					mp4 mpg4 m4v
+video/MP4V-ES
+video/mpeg					mpeg mpg mpe m1v m2v
+video/mpeg4-generic
+video/MPV
+video/nv
+video/ogg					ogv
+video/parityfec
+video/pointer
+video/quicktime					qt mov
+video/raptorfec
+video/raw
+video/rtp-enc-aescm128
+video/rtploopback
+video/rtx
+video/scip
+video/smpte291
+video/SMPTE292M
+video/ulpfec
+video/vc1
+video/vc2
+video/vnd.CCTV
+video/vnd.dece.hd				uvh uvvh
+video/vnd.dece.mobile				uvm uvvm
+video/vnd.dece.mp4				uvu uvvu
+video/vnd.dece.pd				uvp uvvp
+video/vnd.dece.sd				uvs uvvs
+video/vnd.dece.video				uvv uvvv
+video/vnd.directv.mpeg
+video/vnd.directv.mpeg-tts
+video/vnd.dlna.mpeg-tts
+video/vnd.dvb.file				dvb
+video/vnd.fvt					fvt
+video/vnd.hns.video
+video/vnd.iptvforum.1dparityfec-1010
+video/vnd.iptvforum.1dparityfec-2005
+video/vnd.iptvforum.2dparityfec-1010
+video/vnd.iptvforum.2dparityfec-2005
+video/vnd.iptvforum.ttsavc
+video/vnd.iptvforum.ttsmpeg2
+video/vnd.motorola.video
+video/vnd.motorola.videop
+video/vnd.mpegurl				mxu m4u
+video/vnd.ms-playready.media.pyv		pyv
+video/vnd.nokia.interleaved-multimedia		nim
+video/vnd.nokia.mp4vr
+video/vnd.nokia.videovoip
+video/vnd.objectvideo
+video/vnd.radgamettools.bink			bik bk2
+video/vnd.radgamettools.smacker			smk
+video/vnd.sealed.mpeg1				smpg s11
+video/vnd.sealed.mpeg4				s14
+video/vnd.sealed.swf				sswf ssw
+video/vnd.sealedmedia.softseal.mov		smov smo s1q
+video/vnd.uvvu.mp4
+video/vnd.vivo					viv
+video/vnd.youtube.yt				yt
+video/VP8
+video/VP9
+video/webm					webm
+video/x-flv					flv
+video/x-la-asf					lsf lsx
+video/x-matroska				mpv mkv
+video/x-mng					mng
+video/x-ms-wm					wm
+video/x-ms-wmv					wmv
+video/x-ms-wmx					wmx
+video/x-ms-wvx					wvx
+video/x-msvideo					avi
+video/x-sgi-movie				movie
\ No newline at end of file
diff --git a/res/raw/mime_types b/res/raw/mime_types
new file mode 100644
index 000000000..57fa013c2
--- /dev/null
+++ b/res/raw/mime_types
@@ -0,0 +1,846 @@
+###############################################################################
+#
+#  MIME media types and the extensions that represent them.
+#
+#  The format of this file is a media type on the left and zero or more
+#  filename extensions on the right.  Programs using this file will map
+#  files ending with those extensions to the associated type.
+#
+#  This file is part of the "mime-support" package.  Please report a bug using
+#  the "reportbug" command of the "reportbug" package if you would like new
+#  types or extensions to be added.
+#
+#  The reason that all types are managed by the mime-support package instead
+#  allowing individual packages to install types in much the same way as they
+#  add entries in to the mailcap file is so these types can be referenced by
+#  other programs (such as a web server) even if the specific support package
+#  for that type is not installed.
+#
+#  Users can add their own types if they wish by creating a ".mime.types"
+#  file in their home directory.  Definitions included there will take
+#  precedence over those listed here.
+#
+###############################################################################
+
+
+application/activemessage
+application/andrew-inset			ez
+application/annodex				anx
+application/applefile
+application/atom+xml				atom
+application/atomcat+xml				atomcat
+application/atomicmail
+application/atomserv+xml			atomsrv
+application/batch-SMTP
+application/bbolin				lin
+application/beep+xml
+application/cals-1840
+application/commonground
+application/cu-seeme				cu
+application/cybercash
+application/davmount+xml			davmount
+application/dca-rft
+application/dec-dx
+application/dicom				dcm
+application/docbook+xml
+application/dsptype				tsp
+application/dvcs
+application/ecmascript				es
+application/edi-consent
+application/edi-x12
+application/edifact
+application/epub+zip				epub
+application/eshop
+application/font-sfnt				otf ttf
+application/font-tdpfr				pfr
+application/font-woff				woff
+application/futuresplash			spl
+application/ghostview
+application/gzip				gz
+application/hta					hta
+application/http
+application/hyperstudio
+application/iges
+application/index
+application/index.cmd
+application/index.obj
+application/index.response
+application/index.vnd
+application/iotp
+application/ipp
+application/isup
+application/java-archive			jar
+application/java-serialized-object		ser
+application/java-vm				class
+application/javascript				js mjs
+application/json				json
+application/ld+json				jsonld
+application/m3g					m3g
+application/mac-binhex40			hqx
+application/mac-compactpro			cpt
+application/macwriteii
+application/marc
+application/mathematica				nb nbp
+application/mbox				mbox
+application/ms-tnef
+application/msaccess				mdb
+application/msword				doc dot
+application/mxf					mxf
+application/news-message-id
+application/news-transmission
+application/ocsp-request
+application/ocsp-response
+application/octet-stream			bin deploy msu msp
+application/oda					oda
+application/oebps-package+xml			opf
+application/ogg					ogx
+application/onenote				one onetoc2 onetmp onepkg
+application/parityfec
+application/pdf					pdf
+application/pgp-encrypted			pgp
+application/pgp-keys				key
+application/pgp-signature			sig
+application/pics-rules				prf
+application/pkcs10
+application/pkcs7-mime
+application/pkcs7-signature
+application/pkix-cert
+application/pkix-crl
+application/pkixcmp
+application/postscript				ps ai eps epsi epsf eps2 eps3
+application/prs.alvestrand.titrax-sheet
+application/prs.cww
+application/prs.nprend
+application/qsig
+application/rar					rar
+application/rdf+xml				rdf
+application/remote-printing
+application/riscos
+application/rtf					rtf
+application/sdp
+application/set-payment
+application/set-payment-initiation
+application/set-registration
+application/set-registration-initiation
+application/sgml
+application/sgml-open-catalog
+application/sieve
+application/sla					stl
+application/slate
+application/smil+xml				smi smil
+application/timestamp-query
+application/timestamp-reply
+application/vemmi
+application/wasm                                wasm
+application/whoispp-query
+application/whoispp-response
+application/wita
+application/x400-bp
+application/xhtml+xml				xhtml xht
+application/xml					xml xsd
+application/xml-dtd
+application/xml-external-parsed-entity
+application/xslt+xml				xsl xslt
+application/xspf+xml				xspf
+application/zip					zip
+application/vnd.3M.Post-it-Notes
+application/vnd.accpac.simply.aso
+application/vnd.accpac.simply.imp
+application/vnd.acucobol
+application/vnd.aether.imp
+application/vnd.android.package-archive						apk
+application/vnd.anser-web-certificate-issue-initiation
+application/vnd.anser-web-funds-transfer-initiation
+application/vnd.audiograph
+application/vnd.bmi
+application/vnd.businessobjects
+application/vnd.canon-cpdl
+application/vnd.canon-lips
+application/vnd.cinderella							cdy
+application/vnd.claymore
+application/vnd.commerce-battelle
+application/vnd.commonspace
+application/vnd.comsocaller
+application/vnd.contact.cmsg
+application/vnd.cosmocaller
+application/vnd.ctc-posml
+application/vnd.cups-postscript
+application/vnd.cups-raster
+application/vnd.cups-raw
+application/vnd.cybank
+application/vnd.debian.binary-package						deb ddeb udeb
+application/vnd.dna
+application/vnd.dpgraph
+application/vnd.dxr
+application/vnd.ecdis-update
+application/vnd.ecowin.chart
+application/vnd.ecowin.filerequest
+application/vnd.ecowin.fileupdate
+application/vnd.ecowin.series
+application/vnd.ecowin.seriesrequest
+application/vnd.ecowin.seriesupdate
+application/vnd.enliven
+application/vnd.epson.esf
+application/vnd.epson.msf
+application/vnd.epson.quickanime
+application/vnd.epson.salt
+application/vnd.epson.ssf
+application/vnd.ericsson.quickcall
+application/vnd.eudora.data
+application/vnd.fdf
+application/vnd.ffsns
+application/vnd.flographit
+application/vnd.font-fontforge-sfd						sfd
+application/vnd.framemaker
+application/vnd.fsc.weblaunch
+application/vnd.fujitsu.oasys
+application/vnd.fujitsu.oasys2
+application/vnd.fujitsu.oasys3
+application/vnd.fujitsu.oasysgp
+application/vnd.fujitsu.oasysprs
+application/vnd.fujixerox.ddd
+application/vnd.fujixerox.docuworks
+application/vnd.fujixerox.docuworks.binder
+application/vnd.fut-misnet
+application/vnd.google-earth.kml+xml						kml
+application/vnd.google-earth.kmz						kmz
+application/vnd.grafeq
+application/vnd.groove-account
+application/vnd.groove-identity-message
+application/vnd.groove-injector
+application/vnd.groove-tool-message
+application/vnd.groove-tool-template
+application/vnd.groove-vcard
+application/vnd.hhe.lesson-player
+application/vnd.hp-HPGL
+application/vnd.hp-PCL
+application/vnd.hp-PCLXL
+application/vnd.hp-hpid
+application/vnd.hp-hps
+application/vnd.httphone
+application/vnd.hzn-3d-crossword
+application/vnd.ibm.MiniPay
+application/vnd.ibm.afplinedata
+application/vnd.ibm.modcap
+application/vnd.informix-visionary
+application/vnd.intercon.formnet
+application/vnd.intertrust.digibox
+application/vnd.intertrust.nncp
+application/vnd.intu.qbo
+application/vnd.intu.qfx
+application/vnd.irepository.package+xml
+application/vnd.is-xpr
+application/vnd.japannet-directory-service
+application/vnd.japannet-jpnstore-wakeup
+application/vnd.japannet-payment-wakeup
+application/vnd.japannet-registration
+application/vnd.japannet-registration-wakeup
+application/vnd.japannet-setstore-wakeup
+application/vnd.japannet-verification
+application/vnd.japannet-verification-wakeup
+application/vnd.koan
+application/vnd.lotus-1-2-3
+application/vnd.lotus-approach
+application/vnd.lotus-freelance
+application/vnd.lotus-notes
+application/vnd.lotus-organizer
+application/vnd.lotus-screencam
+application/vnd.lotus-wordpro
+application/vnd.mcd
+application/vnd.mediastation.cdkey
+application/vnd.meridian-slingshot
+application/vnd.mif
+application/vnd.minisoft-hp3000-save
+application/vnd.mitsubishi.misty-guard.trustweb
+application/vnd.mobius.daf
+application/vnd.mobius.dis
+application/vnd.mobius.msl
+application/vnd.mobius.plc
+application/vnd.mobius.txf
+application/vnd.motorola.flexsuite
+application/vnd.motorola.flexsuite.adsi
+application/vnd.motorola.flexsuite.fis
+application/vnd.motorola.flexsuite.gotap
+application/vnd.motorola.flexsuite.kmr
+application/vnd.motorola.flexsuite.ttc
+application/vnd.motorola.flexsuite.wem
+application/vnd.mozilla.xul+xml							xul
+application/vnd.ms-artgalry
+application/vnd.ms-asf
+application/vnd.ms-excel							xls xlb xlt
+application/vnd.ms-excel.addin.macroEnabled.12					xlam
+application/vnd.ms-excel.sheet.binary.macroEnabled.12				xlsb
+application/vnd.ms-excel.sheet.macroEnabled.12					xlsm
+application/vnd.ms-excel.template.macroEnabled.12				xltm
+application/vnd.ms-fontobject							eot
+application/vnd.ms-lrm
+application/vnd.ms-officetheme							thmx
+application/vnd.ms-pki.seccat							cat
+#application/vnd.ms-pki.stl							stl
+application/vnd.ms-powerpoint							ppt pps
+application/vnd.ms-powerpoint.addin.macroEnabled.12				ppam
+application/vnd.ms-powerpoint.presentation.macroEnabled.12			pptm
+application/vnd.ms-powerpoint.slide.macroEnabled.12				sldm
+application/vnd.ms-powerpoint.slideshow.macroEnabled.12				ppsm
+application/vnd.ms-powerpoint.template.macroEnabled.12				potm
+application/vnd.ms-project
+application/vnd.ms-tnef
+application/vnd.ms-word.document.macroEnabled.12				docm
+application/vnd.ms-word.template.macroEnabled.12				dotm
+application/vnd.ms-works
+application/vnd.mseq
+application/vnd.msign
+application/vnd.music-niff
+application/vnd.musician
+application/vnd.netfpx
+application/vnd.noblenet-directory
+application/vnd.noblenet-sealer
+application/vnd.noblenet-web
+application/vnd.novadigm.EDM
+application/vnd.novadigm.EDX
+application/vnd.novadigm.EXT
+application/vnd.oasis.opendocument.chart					odc
+application/vnd.oasis.opendocument.database					odb
+application/vnd.oasis.opendocument.formula					odf
+application/vnd.oasis.opendocument.graphics					odg
+application/vnd.oasis.opendocument.graphics-template				otg
+application/vnd.oasis.opendocument.image					odi
+application/vnd.oasis.opendocument.presentation					odp
+application/vnd.oasis.opendocument.presentation-template			otp
+application/vnd.oasis.opendocument.spreadsheet					ods
+application/vnd.oasis.opendocument.spreadsheet-template				ots
+application/vnd.oasis.opendocument.text						odt
+application/vnd.oasis.opendocument.text-master					odm
+application/vnd.oasis.opendocument.text-template				ott
+application/vnd.oasis.opendocument.text-web					oth
+application/vnd.openxmlformats-officedocument.presentationml.presentation	pptx
+application/vnd.openxmlformats-officedocument.presentationml.slide		sldx
+application/vnd.openxmlformats-officedocument.presentationml.slideshow		ppsx
+application/vnd.openxmlformats-officedocument.presentationml.template		potx
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheet		xlsx
+application/vnd.openxmlformats-officedocument.spreadsheetml.template		xltx
+application/vnd.openxmlformats-officedocument.wordprocessingml.document		docx
+application/vnd.openxmlformats-officedocument.wordprocessingml.template		dotx
+application/vnd.osa.netdeploy
+application/vnd.palm
+application/vnd.pg.format
+application/vnd.pg.osasli
+application/vnd.powerbuilder6
+application/vnd.powerbuilder6-s
+application/vnd.powerbuilder7
+application/vnd.powerbuilder7-s
+application/vnd.powerbuilder75
+application/vnd.powerbuilder75-s
+application/vnd.previewsystems.box
+application/vnd.publishare-delta-tree
+application/vnd.pvi.ptid1
+application/vnd.pwg-xhtml-print+xml
+application/vnd.rapid
+application/vnd.rim.cod								cod
+application/vnd.s3sms
+application/vnd.seemail
+application/vnd.shana.informed.formdata
+application/vnd.shana.informed.formtemplate
+application/vnd.shana.informed.interchange
+application/vnd.shana.informed.package
+application/vnd.smaf								mmf
+application/vnd.sss-cod
+application/vnd.sss-dtf
+application/vnd.sss-ntf
+application/vnd.stardivision.calc						sdc
+application/vnd.stardivision.chart						sds
+application/vnd.stardivision.draw						sda
+application/vnd.stardivision.impress						sdd
+application/vnd.stardivision.math						sdf
+application/vnd.stardivision.writer						sdw
+application/vnd.stardivision.writer-global					sgl
+application/vnd.street-stream
+application/vnd.sun.xml.calc							sxc
+application/vnd.sun.xml.calc.template						stc
+application/vnd.sun.xml.draw							sxd
+application/vnd.sun.xml.draw.template						std
+application/vnd.sun.xml.impress							sxi
+application/vnd.sun.xml.impress.template					sti
+application/vnd.sun.xml.math							sxm
+application/vnd.sun.xml.writer							sxw
+application/vnd.sun.xml.writer.global						sxg
+application/vnd.sun.xml.writer.template						stw
+application/vnd.svd
+application/vnd.swiftview-ics
+application/vnd.symbian.install							sis
+application/vnd.tcpdump.pcap							cap pcap
+application/vnd.triscape.mxs
+application/vnd.trueapp
+application/vnd.truedoc
+application/vnd.tve-trigger
+application/vnd.ufdl
+application/vnd.uplanet.alert
+application/vnd.uplanet.alert-wbxml
+application/vnd.uplanet.bearer-choice
+application/vnd.uplanet.bearer-choice-wbxml
+application/vnd.uplanet.cacheop
+application/vnd.uplanet.cacheop-wbxml
+application/vnd.uplanet.channel
+application/vnd.uplanet.channel-wbxml
+application/vnd.uplanet.list
+application/vnd.uplanet.list-wbxml
+application/vnd.uplanet.listcmd
+application/vnd.uplanet.listcmd-wbxml
+application/vnd.uplanet.signal
+application/vnd.vcx
+application/vnd.vectorworks
+application/vnd.vidsoft.vidconference
+application/vnd.visio								vsd vst vsw vss
+application/vnd.vividence.scriptfile
+application/vnd.wap.sic
+application/vnd.wap.slc
+application/vnd.wap.wbxml							wbxml
+application/vnd.wap.wmlc							wmlc
+application/vnd.wap.wmlscriptc							wmlsc
+application/vnd.webturbo
+application/vnd.wordperfect							wpd
+application/vnd.wordperfect5.1							wp5
+application/vnd.wrq-hp3000-labelled
+application/vnd.wt.stf
+application/vnd.xara
+application/vnd.xfdl
+application/vnd.yellowriver-custom-menu
+application/zlib
+application/x-123				wk
+application/x-7z-compressed			7z
+application/x-abiword				abw
+application/x-apple-diskimage			dmg
+application/x-bcpio				bcpio
+application/x-bittorrent			torrent
+application/x-cab				cab
+application/x-cbr				cbr
+application/x-cbz				cbz
+application/x-cdf				cdf cda
+application/x-cdlink				vcd
+application/x-chess-pgn				pgn
+application/x-comsol				mph
+application/x-core
+application/x-cpio				cpio
+application/x-csh				csh
+application/x-debian-package			deb udeb
+application/x-director				dcr dir dxr
+application/x-dms				dms
+application/x-doom				wad
+application/x-dvi				dvi
+application/x-executable
+application/x-font				pfa pfb gsf
+application/x-font-pcf				pcf pcf.Z
+application/x-freemind				mm
+application/x-futuresplash			spl
+application/x-ganttproject			gan
+application/x-gnumeric				gnumeric
+application/x-go-sgf				sgf
+application/x-graphing-calculator		gcf
+application/x-gtar				gtar
+application/x-gtar-compressed			tgz taz
+application/x-hdf				hdf
+#application/x-httpd-eruby			rhtml
+#application/x-httpd-php			phtml pht php
+#application/x-httpd-php-source			phps
+#application/x-httpd-php3			php3
+#application/x-httpd-php3-preprocessed		php3p
+#application/x-httpd-php4			php4
+#application/x-httpd-php5			php5
+application/x-hwp				hwp
+application/x-ica				ica
+application/x-info				info
+application/x-internet-signup			ins isp
+application/x-iphone				iii
+application/x-iso9660-image			iso
+application/x-jam				jam
+application/x-java-applet
+application/x-java-bean
+application/x-java-jnlp-file			jnlp
+application/x-jmol				jmz
+application/x-kchart				chrt
+application/x-kdelnk
+application/x-killustrator			kil
+application/x-koan				skp skd skt skm
+application/x-kpresenter			kpr kpt
+application/x-kspread				ksp
+application/x-kword				kwd kwt
+application/x-latex				latex
+application/x-lha				lha
+application/x-lyx				lyx
+application/x-lzh				lzh
+application/x-lzx				lzx
+application/x-maker				frm maker frame fm fb book fbdoc
+application/x-mif				mif
+application/x-mpegURL				m3u8
+application/x-ms-application			application
+application/x-ms-manifest			manifest
+application/x-ms-wmd				wmd
+application/x-ms-wmz				wmz
+application/x-msdos-program			com exe bat dll
+application/x-msi				msi
+application/x-netcdf				nc
+application/x-ns-proxy-autoconfig		pac
+application/x-nwc				nwc
+application/x-object				o
+application/x-oz-application			oza
+application/x-pkcs7-certreqresp			p7r
+application/x-pkcs7-crl				crl
+application/x-python-code			pyc pyo
+application/x-qgis				qgs shp shx
+application/x-quicktimeplayer			qtl
+application/x-rdp				rdp
+application/x-redhat-package-manager		rpm
+application/x-rss+xml				rss
+application/x-ruby				rb
+application/x-rx
+application/x-scilab				sci sce
+application/x-scilab-xcos			xcos
+application/x-sh				sh
+application/x-shar				shar
+application/x-shellscript
+application/x-shockwave-flash			swf swfl
+application/x-silverlight			scr
+application/x-sql				sql
+application/x-stuffit				sit sitx
+application/x-sv4cpio				sv4cpio
+application/x-sv4crc				sv4crc
+application/x-tar				tar
+application/x-tcl				tcl
+application/x-tex-gf				gf
+application/x-tex-pk				pk
+application/x-texinfo				texinfo texi
+application/x-trash				~ % bak old sik
+application/x-troff				t tr roff
+application/x-troff-man				man
+application/x-troff-me				me
+application/x-troff-ms				ms
+application/x-ustar				ustar
+application/x-videolan
+application/x-wais-source			src
+application/x-wingz				wz
+application/x-x509-ca-cert			crt
+application/x-xcf				xcf
+application/x-xfig				fig
+application/x-xpinstall				xpi
+application/x-xz				xz
+
+audio/32kadpcm
+audio/3gpp
+audio/amr					amr
+audio/amr-wb					awb
+audio/annodex					axa
+audio/basic					au snd
+audio/csound					csd orc sco
+audio/flac					flac
+audio/g.722.1
+audio/l16
+audio/midi					mid midi kar
+audio/mp4a-latm
+audio/mpa-robust
+audio/mpeg					mpga mpega mp2 mp3 m4a
+audio/mpegurl					m3u
+audio/ogg					oga ogg opus spx
+audio/parityfec
+audio/prs.sid					sid
+audio/telephone-event
+audio/tone
+audio/vnd.cisco.nse
+audio/vnd.cns.anp1
+audio/vnd.cns.inf1
+audio/vnd.digital-winds
+audio/vnd.everad.plj
+audio/vnd.lucent.voice
+audio/vnd.nortel.vbk
+audio/vnd.nuera.ecelp4800
+audio/vnd.nuera.ecelp7470
+audio/vnd.nuera.ecelp9600
+audio/vnd.octel.sbc
+audio/vnd.qcelp
+audio/vnd.rhetorex.32kadpcm
+audio/vnd.vmx.cvsd
+audio/x-aiff					aif aiff aifc
+audio/x-gsm					gsm
+audio/x-mpegurl					m3u
+audio/x-ms-wma					wma
+audio/x-ms-wax					wax
+audio/x-pn-realaudio-plugin
+audio/x-pn-realaudio				ra rm ram
+audio/x-realaudio				ra
+audio/x-scpls					pls
+audio/x-sd2					sd2
+audio/x-wav					wav
+
+chemical/x-alchemy				alc
+chemical/x-cache				cac cache
+chemical/x-cache-csf				csf
+chemical/x-cactvs-binary			cbin cascii ctab
+chemical/x-cdx					cdx
+chemical/x-cerius				cer
+chemical/x-chem3d				c3d
+chemical/x-chemdraw				chm
+chemical/x-cif					cif
+chemical/x-cmdf					cmdf
+chemical/x-cml					cml
+chemical/x-compass				cpa
+chemical/x-crossfire				bsd
+chemical/x-csml					csml csm
+chemical/x-ctx					ctx
+chemical/x-cxf					cxf cef
+#chemical/x-daylight-smiles			smi
+chemical/x-embl-dl-nucleotide			emb embl
+chemical/x-galactic-spc				spc
+chemical/x-gamess-input				inp gam gamin
+chemical/x-gaussian-checkpoint			fch fchk
+chemical/x-gaussian-cube			cub
+chemical/x-gaussian-input			gau gjc gjf
+chemical/x-gaussian-log				gal
+chemical/x-gcg8-sequence			gcg
+chemical/x-genbank				gen
+chemical/x-hin					hin
+chemical/x-isostar				istr ist
+chemical/x-jcamp-dx				jdx dx
+chemical/x-kinemage				kin
+chemical/x-macmolecule				mcm
+chemical/x-macromodel-input			mmd mmod
+chemical/x-mdl-molfile				mol
+chemical/x-mdl-rdfile				rd
+chemical/x-mdl-rxnfile				rxn
+chemical/x-mdl-sdfile				sd sdf
+chemical/x-mdl-tgf				tgf
+#chemical/x-mif					mif
+chemical/x-mmcif				mcif
+chemical/x-mol2					mol2
+chemical/x-molconn-Z				b
+chemical/x-mopac-graph				gpt
+chemical/x-mopac-input				mop mopcrt mpc zmt
+chemical/x-mopac-out				moo
+chemical/x-mopac-vib				mvb
+chemical/x-ncbi-asn1				asn
+chemical/x-ncbi-asn1-ascii			prt ent
+chemical/x-ncbi-asn1-binary			val aso
+chemical/x-ncbi-asn1-spec			asn
+chemical/x-pdb					pdb ent
+chemical/x-rosdal				ros
+chemical/x-swissprot				sw
+chemical/x-vamas-iso14976			vms
+chemical/x-vmd					vmd
+chemical/x-xtel					xtel
+chemical/x-xyz					xyz
+
+font/collection					ttc
+font/otf					ttf otf
+font/sfnt					ttf otf
+font/ttf					ttf otf
+font/woff					woff
+font/woff2					woff2
+
+image/cgm
+image/g3fax
+image/gif					gif
+image/ief					ief
+image/jp2					jp2 jpg2
+image/jpeg					jpeg jpg jpe
+image/jpm					jpm
+image/jpx					jpx jpf
+image/naplps
+image/pcx					pcx
+image/png					png
+image/prs.btif
+image/prs.pti
+image/svg+xml					svg svgz
+image/tiff					tiff tif
+image/vnd.cns.inf2
+image/vnd.djvu					djvu djv
+image/vnd.dwg
+image/vnd.dxf
+image/vnd.fastbidsheet
+image/vnd.fpx
+image/vnd.fst
+image/vnd.fujixerox.edmics-mmr
+image/vnd.fujixerox.edmics-rlc
+image/vnd.microsoft.icon			ico
+image/vnd.mix
+image/vnd.net-fpx
+image/vnd.svf
+image/vnd.wap.wbmp				wbmp
+image/vnd.xiff
+image/x-canon-cr2				cr2
+image/x-canon-crw				crw
+image/x-cmu-raster				ras
+image/x-coreldraw				cdr
+image/x-coreldrawpattern			pat
+image/x-coreldrawtemplate			cdt
+image/x-corelphotopaint				cpt
+image/x-epson-erf				erf
+image/x-icon
+image/x-jg					art
+image/x-jng					jng
+image/x-ms-bmp					bmp
+image/x-nikon-nef				nef
+image/x-olympus-orf				orf
+image/x-photoshop				psd
+image/x-portable-anymap				pnm
+image/x-portable-bitmap				pbm
+image/x-portable-graymap			pgm
+image/x-portable-pixmap				ppm
+image/x-rgb					rgb
+image/x-xbitmap					xbm
+image/x-xpixmap					xpm
+image/x-xwindowdump				xwd
+
+inode/chardevice
+inode/blockdevice
+inode/directory-locked
+inode/directory
+inode/fifo
+inode/socket
+
+message/delivery-status
+message/disposition-notification
+message/external-body
+message/http
+message/s-http
+message/news
+message/partial
+message/rfc822					eml
+
+model/iges					igs iges
+model/mesh					msh mesh silo
+model/vnd.dwf
+model/vnd.flatland.3dml
+model/vnd.gdl
+model/vnd.gs-gdl
+model/vnd.gtw
+model/vnd.mts
+model/vnd.vtu
+model/vrml					wrl vrml
+model/x3d+vrml					x3dv
+model/x3d+xml					x3d
+model/x3d+binary				x3db
+
+multipart/alternative
+multipart/appledouble
+multipart/byteranges
+multipart/digest
+multipart/encrypted
+multipart/form-data
+multipart/header-set
+multipart/mixed
+multipart/parallel
+multipart/related
+multipart/report
+multipart/signed
+multipart/voice-message
+
+text/cache-manifest				appcache
+text/calendar					ics icz
+text/css					css
+text/csv					csv
+text/directory
+text/english
+text/enriched
+text/h323					323
+text/html					html htm shtml
+text/iuls					uls
+text/mathml					mml
+text/markdown                                   md markdown
+text/parityfec
+text/plain					asc txt text pot brf srt
+text/prs.lines.tag
+text/rfc822-headers
+text/richtext					rtx
+text/rtf
+text/scriptlet					sct wsc
+text/t140
+text/texmacs					tm
+text/tab-separated-values			tsv
+text/turtle					ttl
+text/uri-list
+text/vcard					vcf vcard
+text/vnd.abc
+text/vnd.curl
+text/vnd.debian.copyright
+text/vnd.DMClientScript
+text/vnd.flatland.3dml
+text/vnd.fly
+text/vnd.fmi.flexstor
+text/vnd.in3d.3dml
+text/vnd.in3d.spot
+text/vnd.IPTC.NewsML
+text/vnd.IPTC.NITF
+text/vnd.latex-z
+text/vnd.motorola.reflex
+text/vnd.ms-mediapackage
+text/vnd.sun.j2me.app-descriptor		jad
+text/vnd.wap.si
+text/vnd.wap.sl
+text/vnd.wap.wml				wml
+text/vnd.wap.wmlscript				wmls
+text/x-bibtex					bib
+text/x-boo					boo
+text/x-c++hdr					h++ hpp hxx hh
+text/x-c++src					c++ cpp cxx cc
+text/x-chdr					h
+text/x-component				htc
+text/x-crontab
+text/x-csh					csh
+text/x-csrc					c
+text/x-dsrc					d
+text/x-diff					diff patch
+text/x-haskell					hs
+text/x-java					java
+text/x-lilypond					ly
+text/x-literate-haskell				lhs
+text/x-makefile
+text/x-moc					moc
+text/x-pascal					p pas
+text/x-pcs-gcd					gcd
+text/x-perl					pl pm
+text/x-python					py
+text/x-scala					scala
+text/x-server-parsed-html
+text/x-setext					etx
+text/x-sfv					sfv
+text/x-sh					sh
+text/x-tcl					tcl tk
+text/x-tex					tex ltx sty cls
+text/x-vcalendar				vcs
+
+video/3gpp					3gp
+video/annodex					axv
+video/dl					dl
+video/dv					dif dv
+video/fli					fli
+video/gl					gl
+video/mpeg					mpeg mpg mpe
+video/MP2T					ts
+video/mp4					mp4
+video/quicktime					qt mov
+video/mp4v-es
+video/ogg					ogv
+video/parityfec
+video/pointer
+video/webm					webm
+video/vnd.fvt
+video/vnd.motorola.video
+video/vnd.motorola.videop
+video/vnd.mpegurl				mxu
+video/vnd.mts
+video/vnd.nokia.interleaved-multimedia
+video/vnd.vivo
+video/x-flv					flv
+video/x-la-asf					lsf lsx
+video/x-mng					mng
+video/x-ms-asf					asf asx
+video/x-ms-wm					wm
+video/x-ms-wmv					wmv
+video/x-ms-wmx					wmx
+video/x-ms-wvx					wvx
+video/x-msvideo					avi
+video/x-sgi-movie				movie
+video/x-matroska				mpv mkv
+
+x-conference/x-cooltalk				ice
+
+x-epoc/x-sisx-app				sisx
+x-world/x-vrml					vrm vrml wrl
\ No newline at end of file
diff --git a/res/values-ar/strings.xml b/res/values-ar/strings.xml
index 9ba182654..63ffd1654 100644
--- a/res/values-ar/strings.xml
+++ b/res/values-ar/strings.xml
@@ -43,7 +43,7 @@
     <string name="picker_settings_title" msgid="5647700706470673258">"    "</string>
     <string name="picker_settings_description" msgid="2916686824777214585">"                "</string>
     <string name="picker_settings_selection_message" msgid="245453573086488596">"      "</string>
-    <string name="picker_settings_no_provider" msgid="2582311853680058223">" "</string>
+    <string name="picker_settings_no_provider" msgid="2582311853680058223">" "</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">"       "</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"  "</string>
     <string name="picker_sync_notification_title" msgid="1122713382122055246">"  "</string>
@@ -159,7 +159,7 @@
     <string name="transcode_processing" msgid="6753136468864077258">"  "</string>
     <string name="transcode_cancel" msgid="8555752601907598192">""</string>
     <string name="transcode_wait" msgid="8909773149560697501">""</string>
-    <string name="safety_protection_icon_label" msgid="6714354052747723623">"  "</string>
+    <string name="safety_protection_icon_label" msgid="6714354052747723623">"  "</string>
     <string name="transcode_alert_channel" msgid="9004850719456228643">"  "</string>
     <string name="transcode_progress_channel" msgid="6122609645085712101">"     "</string>
     <string name="dialog_error_message" msgid="5120432204743681606">"   .     ."</string>
diff --git a/res/values-ca/strings.xml b/res/values-ca/strings.xml
index 5c277c3a6..e2f3b2683 100644
--- a/res/values-ca/strings.xml
+++ b/res/values-ca/strings.xml
@@ -38,13 +38,13 @@
     <string name="allow" msgid="8885707816848569619">"Permet"</string>
     <string name="deny" msgid="6040983710442068936">"Denega"</string>
     <string name="picker_browse" msgid="5554477454636075934">"Navega"</string>
-    <string name="picker_settings" msgid="6443463167344790260">"Aplicaci multimdia al nvol"</string>
-    <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"App multimdia al nvol"</string>
-    <string name="picker_settings_title" msgid="5647700706470673258">"Aplicaci multimdia al nvol"</string>
+    <string name="picker_settings" msgid="6443463167344790260">"App de multimdia al nvol"</string>
+    <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"App de contingut multimdia al nvol"</string>
+    <string name="picker_settings_title" msgid="5647700706470673258">"App de contingut multimdia al nvol"</string>
     <string name="picker_settings_description" msgid="2916686824777214585">"Accedeix al contingut multimdia al nvol quan una aplicaci o un lloc web et demani que seleccionis fotos o vdeos"</string>
     <string name="picker_settings_selection_message" msgid="245453573086488596">"Accedeix al contingut multimdia al nvol des de"</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">"Cap"</string>
-    <string name="picker_settings_toast_error" msgid="697274445512467469">"No s\'ha pogut canviar l\'app multimdia al nvol."</string>
+    <string name="picker_settings_toast_error" msgid="697274445512467469">"No s\'ha pogut canviar l\'app de multimdia al nvol."</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"Selector de mitjans"</string>
     <string name="picker_sync_notification_title" msgid="1122713382122055246">"Selector de mitjans"</string>
     <string name="picker_sync_notification_text" msgid="8204423917712309382">"S\'est sincronitzant el contingut multimdia"</string>
@@ -110,8 +110,8 @@
     <string name="picker_banner_cloud_first_time_available_desc" msgid="5570916598348187607">"Pots seleccionar fotos del compte de <xliff:g id="APP_NAME">%1$s</xliff:g> de <xliff:g id="USER_ACCOUNT">%2$s</xliff:g>"</string>
     <string name="picker_banner_cloud_account_changed_title" msgid="4825058474378077327">"S\'ha actualitzat el compte de <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="picker_banner_cloud_account_changed_desc" msgid="3433218869899792497">"Les fotos de <xliff:g id="USER_ACCOUNT">%1$s</xliff:g> ara s\'inclouen aqu"</string>
-    <string name="picker_banner_cloud_choose_app_title" msgid="3165966147547974251">"Tria una aplicaci multimdia amb servei al nvol"</string>
-    <string name="picker_banner_cloud_choose_app_desc" msgid="2359212653555524926">"Per incloure una cpia de seguretat de les fotos aqu, a Configuraci, tria una aplicaci multimdia amb servei al nvol"</string>
+    <string name="picker_banner_cloud_choose_app_title" msgid="3165966147547974251">"Tria una aplicaci de contingut multimdia al nvol"</string>
+    <string name="picker_banner_cloud_choose_app_desc" msgid="2359212653555524926">"Per incloure una cpia de seguretat de les fotos aqu, a Configuraci, tria una aplicaci de contingut multimdia al nvol"</string>
     <string name="picker_banner_cloud_choose_account_title" msgid="5010901185639577685">"Tria un compte de <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="picker_banner_cloud_choose_account_desc" msgid="8868134443673142712">"Per incloure les fotos de <xliff:g id="APP_NAME">%1$s</xliff:g> aqu, tria un compte a l\'aplicaci"</string>
     <string name="picker_banner_cloud_dismiss_button" msgid="2935903078288463882">"Ignora"</string>
diff --git a/res/values-cs/strings.xml b/res/values-cs/strings.xml
index 25a360857..70bb04d25 100644
--- a/res/values-cs/strings.xml
+++ b/res/values-cs/strings.xml
@@ -42,7 +42,7 @@
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"Aplikace pro mdia vcloudu"</string>
     <string name="picker_settings_title" msgid="5647700706470673258">"Aplikace pro cloudov mdia"</string>
     <string name="picker_settings_description" msgid="2916686824777214585">"Kdy vs njak aplikace nebo webov strnka pod o vbr fotografi i vide, mete vybrat ze svch mdi v cloudu"</string>
-    <string name="picker_settings_selection_message" msgid="245453573086488596">"Vybrat mdia ztto aplikace"</string>
+    <string name="picker_settings_selection_message" msgid="245453573086488596">"Vybrat mdia ztto aplikace"</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">"dn aplikace"</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">"Aplikaci pro cloudov mdia nyn nelze zmnit."</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"Nstroj pro vbr mdi"</string>
diff --git a/res/values-fi/strings.xml b/res/values-fi/strings.xml
index 766090a50..657704dd2 100644
--- a/res/values-fi/strings.xml
+++ b/res/values-fi/strings.xml
@@ -105,7 +105,7 @@
     <string name="not_selected" msgid="2244008151669896758">"ei valittu"</string>
     <string name="preloading_dialog_title" msgid="4974348221848532887">"Valitsemaasi mediaa valmistellaan"</string>
     <string name="preloading_progress_message" msgid="4741327138031980582">"<xliff:g id="NUMBER_PRELOADED">%1$d</xliff:g>/<xliff:g id="NUMBER_TOTAL">%2$d</xliff:g> valmiina"</string>
-    <string name="preloading_cancel_button" msgid="824053521307342209">"Peruuta"</string>
+    <string name="preloading_cancel_button" msgid="824053521307342209">"Peru"</string>
     <string name="picker_banner_cloud_first_time_available_title" msgid="5912973744275711595">"Varmuuskopioidut kuvat lytyvt nyt tlt"</string>
     <string name="picker_banner_cloud_first_time_available_desc" msgid="5570916598348187607">"Voit valita sovelluksen <xliff:g id="APP_NAME">%1$s</xliff:g> kuvat tililt <xliff:g id="USER_ACCOUNT">%2$s</xliff:g>"</string>
     <string name="picker_banner_cloud_account_changed_title" msgid="4825058474378077327">"Tili pivitetty: <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
diff --git a/res/values-kk/strings.xml b/res/values-kk/strings.xml
index 35f3cda3c..077db1ac9 100644
--- a/res/values-kk/strings.xml
+++ b/res/values-kk/strings.xml
@@ -41,8 +41,8 @@
     <string name="picker_settings" msgid="6443463167344790260">"  "</string>
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"  "</string>
     <string name="picker_settings_title" msgid="5647700706470673258">"  "</string>
-    <string name="picker_settings_description" msgid="2916686824777214585">"  -          ."</string>
-    <string name="picker_settings_selection_message" msgid="245453573086488596">"     :"</string>
+    <string name="picker_settings_description" msgid="2916686824777214585">"  -      ,    ."</string>
+    <string name="picker_settings_selection_message" msgid="245453573086488596">"   "</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">""</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">"   ."</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"Me "</string>
@@ -67,7 +67,7 @@
     <string name="picker_work_profile" msgid="2083221066869141576">"  "</string>
     <string name="picker_personal_profile" msgid="639484258397758406">"  "</string>
     <string name="picker_personal_profile_label" msgid="6189198163209597344">""</string>
-    <string name="picker_profile_admin_title" msgid="4172022376418293777">" "</string>
+    <string name="picker_profile_admin_title" msgid="4172022376418293777">" "</string>
     <string name="picker_profile_admin_msg_from_personal" msgid="1941639895084555723">"      ."</string>
     <string name="picker_profile_admin_msg_from_work" msgid="8048524337462790110">"      ."</string>
     <string name="picker_profile_admin_msg" msgid="4060112887923255178">"<xliff:g id="PROFILE2">%2$s</xliff:g>  <xliff:g id="PROFILE1">%1$s</xliff:g>    ."</string>
diff --git a/res/values-night/colors.xml b/res/values-night/colors.xml
index 648c6d7a5..a9516140d 100644
--- a/res/values-night/colors.xml
+++ b/res/values-night/colors.xml
@@ -21,4 +21,7 @@
 
     <!-- PhotoPicker -->
     <color name="picker_background_color">#202124</color>
+
+    <!-- PhotoPicker Settings Activity -->
+    <color name="picker_settings_background_color">@android:color/black</color>
 </resources>
diff --git a/res/values-sw/strings.xml b/res/values-sw/strings.xml
index 3b797a7da..a10e3da2c 100644
--- a/res/values-sw/strings.xml
+++ b/res/values-sw/strings.xml
@@ -40,11 +40,11 @@
     <string name="picker_browse" msgid="5554477454636075934">"Vinjari"</string>
     <string name="picker_settings" msgid="6443463167344790260">"Programu ya maudhui ya wingu"</string>
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"Programu ya maudhui ya wingu"</string>
-    <string name="picker_settings_title" msgid="5647700706470673258">"Programu ya maudhui ya wingu"</string>
+    <string name="picker_settings_title" msgid="5647700706470673258">"Programu ya maudhui kwenye wingu"</string>
     <string name="picker_settings_description" msgid="2916686824777214585">"Fikia maudhui yako yaliyo kwenye wingu programu au tovuti inapokuomba uchague picha au video"</string>
     <string name="picker_settings_selection_message" msgid="245453573086488596">"Fikia maudhui yaliyo kwenye wingu katika"</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">"Hamna"</string>
-    <string name="picker_settings_toast_error" msgid="697274445512467469">"Imeshindwa kubadilisha programu ya maudhui ya wingu kwa wakati huu."</string>
+    <string name="picker_settings_toast_error" msgid="697274445512467469">"Imeshindwa kubadilisha programu ya maudhui kwenye wingu sasa."</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"Kiteua maudhui"</string>
     <string name="picker_sync_notification_title" msgid="1122713382122055246">"Kiteua maudhui"</string>
     <string name="picker_sync_notification_text" msgid="8204423917712309382">"Inasawazisha maudhui"</string>
@@ -110,7 +110,7 @@
     <string name="picker_banner_cloud_first_time_available_desc" msgid="5570916598348187607">"Unaweza kuchagua picha zilizotoka kwenye akaunti ya <xliff:g id="USER_ACCOUNT">%2$s</xliff:g> katika programu ya <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="picker_banner_cloud_account_changed_title" msgid="4825058474378077327">"Umesasisha akaunti ya <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="picker_banner_cloud_account_changed_desc" msgid="3433218869899792497">"Picha zilizopo kwenye akaunti ya <xliff:g id="USER_ACCOUNT">%1$s</xliff:g> sasa zimejumuishwa hapa"</string>
-    <string name="picker_banner_cloud_choose_app_title" msgid="3165966147547974251">"Chagua programu ya maudhui ya wingu"</string>
+    <string name="picker_banner_cloud_choose_app_title" msgid="3165966147547974251">"Chagua programu ya maudhui kwenye wingu"</string>
     <string name="picker_banner_cloud_choose_app_desc" msgid="2359212653555524926">"Ili ujumuishe picha zilizohifadhiwa nakala hapa, chagua programu ya maudhui ya wingu kwenye Mipangilio"</string>
     <string name="picker_banner_cloud_choose_account_title" msgid="5010901185639577685">"Chagua akaunti ya <xliff:g id="APP_NAME">%1$s</xliff:g>"</string>
     <string name="picker_banner_cloud_choose_account_desc" msgid="8868134443673142712">"Ili ujumuishe picha zilizotoka <xliff:g id="APP_NAME">%1$s</xliff:g> hapa, chagua akaunti kwenye programu"</string>
diff --git a/res/values-zh-rTW/strings.xml b/res/values-zh-rTW/strings.xml
index b3235733b..ba856c406 100644
--- a/res/values-zh-rTW/strings.xml
+++ b/res/values-zh-rTW/strings.xml
@@ -41,7 +41,7 @@
     <string name="picker_settings" msgid="6443463167344790260">""</string>
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">""</string>
     <string name="picker_settings_title" msgid="5647700706470673258">""</string>
-    <string name="picker_settings_description" msgid="2916686824777214585">""</string>
+    <string name="picker_settings_description" msgid="2916686824777214585">""</string>
     <string name="picker_settings_selection_message" msgid="245453573086488596">""</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">""</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">""</string>
diff --git a/res/values/colors.xml b/res/values/colors.xml
index 39e4cb84d..11783d96a 100644
--- a/res/values/colors.xml
+++ b/res/values/colors.xml
@@ -35,4 +35,7 @@
     <color name="preview_highlight_color">#8AB4F8</color>
     <color name="preview_default_grey">#202124</color>
     <color name="preview_background_color">@android:color/black</color>
+
+    <!-- PhotoPicker Settings Activity -->
+    <color name="picker_settings_background_color">@android:color/white</color>
 </resources>
diff --git a/res/values/config.xml b/res/values/config.xml
index 3675ad8b4..d7f1d2820 100644
--- a/res/values/config.xml
+++ b/res/values/config.xml
@@ -29,4 +29,9 @@
     <string name="config_default_media_cognition_service_package" translatable="false"></string>
     <!-- Config for OemMetadataService package -->
     <string name="config_default_oem_metadata_service_package" translatable="false"></string>
+
+    <!-- The subset of folders that should not be created during the default creation of folders on
+    the root directory of mounted storage devices by the MediaProvider. This is empty by default.
+    -->
+    <string-array name="config_foldersToSkipInDefaultCreation" translatable="false"></string-array>
 </resources>
diff --git a/res/values/dimens.xml b/res/values/dimens.xml
index 0f4561113..04d2bb07c 100644
--- a/res/values/dimens.xml
+++ b/res/values/dimens.xml
@@ -114,13 +114,14 @@
     <dimen name="picker_profile_dialog_icon_width">24dp</dimen>
 
     <!-- PhotoPicker Settings Activity -->
-    <dimen name="picker_heading_text_size">40sp</dimen>
-    <dimen name="picker_settings_title_margin_top">45dp</dimen>
-    <dimen name="picker_settings_cloud_select_title_margin">20dp</dimen>
-    <dimen name="picker_settings_margin_default">15dp</dimen>
     <dimen name="picker_settings_list_item_height">80dp</dimen>
     <dimen name="picker_settings_list_item_padding_end">10dp</dimen>
-    <dimen name="picker_body_text_size">16sp</dimen>
+    <dimen name="picker_settings_description_padding_top">8dp</dimen>
+    <dimen name="picker_settings_description_padding_bottom">16dp</dimen>
+    <dimen name="picker_settings_description_padding_start">24dp</dimen>
+    <dimen name="picker_settings_description_padding_end">24dp</dimen>
+    <dimen name="picker_settings_description_text_size">16sp</dimen>
+    <dimen name="picker_settings_description_letter_spacing">0.03125</dimen>
 
     <!-- PhotoPicker Banners -->
     <!-- TODO(b/195009152): Final banner dimensions to be updated once received -->
diff --git a/res/values/overlayable.xml b/res/values/overlayable.xml
index eeb1261cf..b1086f3a4 100644
--- a/res/values/overlayable.xml
+++ b/res/values/overlayable.xml
@@ -24,6 +24,8 @@
             <item type="string" name="config_default_cloud_provider_authority"/>
             <item type="string" name="config_default_media_cognition_service_package" />
             <item type="string" name="config_default_oem_metadata_service_package" />
+
+            <item type="array" name="config_foldersToSkipInDefaultCreation" />
         </policy>
     </overlayable>
 </resources>
diff --git a/res/values/photopicker_styles.xml b/res/values/photopicker_styles.xml
index 762fa5786..5bfab7bd4 100644
--- a/res/values/photopicker_styles.xml
+++ b/res/values/photopicker_styles.xml
@@ -39,6 +39,7 @@
     <!-- Defines theme of the PhotoPickerSettingsActivity -->
     <style name="PickerSettingsDefaultTheme" parent="PickerDefaultTheme">
         <item name="android:windowIsTranslucent">false</item>
+        <item name="android:windowBackground">@color/picker_settings_background_color</item>
         <item name="android:listPreferredItemHeightSmall">
             @dimen/picker_settings_list_item_height
         </item>
@@ -166,9 +167,4 @@
         <item name="android:textColor">?attr/colorOnSurface</item>
     </style>
 
-    <!--
-        TODO(b/309578419): Make activities handle insets properly and then remove this.
-    -->
-    <style name="OptOutEdgeToEdgeEnforcement" />
-
 </resources>
diff --git a/res/values/styles_text.xml b/res/values/styles_text.xml
index 9cb7758e6..25ee5a6d5 100644
--- a/res/values/styles_text.xml
+++ b/res/values/styles_text.xml
@@ -48,16 +48,6 @@
         <item name="android:textAllCaps">false</item>
     </style>
 
-    <style name="PickerHeadingTextAppearance"
-           parent="@android:style/TextAppearance.DeviceDefault.Large">
-        <item name="android:textSize">@dimen/picker_heading_text_size</item>
-    </style>
-
-    <style name="PickerBodyTextAppearance"
-           parent="@android:style/TextAppearance.DeviceDefault.Medium">
-        <item name="android:textSize">@dimen/picker_body_text_size</item>
-    </style>
-
     <style name="PickerButtonTextAppearance"
            parent="@android:style/TextAppearance.DeviceDefault.Widget.Button"/>
 
@@ -70,4 +60,10 @@
     <style name="PickerProfileDialogBody" parent="@android:style/TextAppearance.Material.Body2">
         <item name="android:textAllCaps">false</item>
     </style>
+
+    <style name="PickerSettingsDescription" parent="@android:style/TextAppearance.DeviceDefault">
+        <item name="android:textSize">@dimen/picker_settings_description_text_size</item>
+        <item name="android:letterSpacing">@dimen/picker_settings_description_letter_spacing</item>
+        <item name="android:textAllCaps">false</item>
+    </style>
 </resources>
diff --git a/res/xml/pref_screen_picker_settings.xml b/res/xml/cloud_media_selection_settings.xml
similarity index 67%
rename from res/xml/pref_screen_picker_settings.xml
rename to res/xml/cloud_media_selection_settings.xml
index d1eca6288..0aafce80b 100644
--- a/res/xml/pref_screen_picker_settings.xml
+++ b/res/xml/cloud_media_selection_settings.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2022 The Android Open Source Project
+  ~ Copyright (C) 2025 The Android Open Source Project
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -15,4 +15,10 @@
   ~ limitations under the License.
   -->
 
-<PreferenceScreen/>
+<PreferenceScreen
+    xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <PreferenceCategory
+        android:key="cloud_media_provider_options"
+        android:title="@string/picker_settings_selection_message"/>
+</PreferenceScreen>
diff --git a/res/xml/data_extraction_rules.xml b/res/xml/data_extraction_rules.xml
new file mode 100644
index 000000000..77d698b96
--- /dev/null
+++ b/res/xml/data_extraction_rules.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<data-extraction-rules>
+    <!-- Disable cloud backup -->
+    <cloud-backup>
+        <exclude domain="root" path="."/>
+        <exclude domain="file" path="."/>
+        <exclude domain="database" path="."/>
+        <exclude domain="sharedpref" path="."/>
+        <exclude domain="external" path="."/>
+        <exclude domain="device_root" path="."/>
+        <exclude domain="device_file" path="."/>
+        <exclude domain="device_database" path="."/>
+        <exclude domain="device_sharedpref" path="."/>
+    </cloud-backup>
+    <!-- Only transfer files/backup folder for device transfer -->
+    <device-transfer>
+        <include domain="file" path="backup" />
+    </device-transfer>
+</data-extraction-rules>
diff --git a/src/com/android/providers/media/AccessChecker.java b/src/com/android/providers/media/AccessChecker.java
index 4dea3c487..ba16cdf77 100644
--- a/src/com/android/providers/media/AccessChecker.java
+++ b/src/com/android/providers/media/AccessChecker.java
@@ -107,19 +107,22 @@ public class AccessChecker {
             case AUDIO_GENRES_ALL_MEMBERS:
             case AUDIO_PLAYLISTS_ID_MEMBERS_ID:
             case AUDIO_PLAYLISTS_ID_MEMBERS: {
-                return callingIdentity.checkCallingPermissionAudio(forWrite);
+                return callingIdentity.checkCallingPermissionAudio(forWrite,
+                        /* forDataDelivery */ true);
             }
             case IMAGES_MEDIA:
             case IMAGES_MEDIA_ID:
             case IMAGES_THUMBNAILS_ID:
             case IMAGES_THUMBNAILS: {
-                return callingIdentity.checkCallingPermissionImages(forWrite);
+                return callingIdentity.checkCallingPermissionImages(forWrite,
+                        /* forDataDelivery */ true);
             }
             case VIDEO_MEDIA_ID:
             case VIDEO_MEDIA:
             case VIDEO_THUMBNAILS_ID:
             case VIDEO_THUMBNAILS: {
-                return callingIdentity.checkCallingPermissionVideo(forWrite);
+                return callingIdentity.checkCallingPermissionVideo(forWrite,
+                        /* forDataDelivery */ true);
             }
             case DOWNLOADS_ID:
             case DOWNLOADS:
@@ -166,7 +169,8 @@ public class AccessChecker {
             case DOWNLOADS:
             case FILES_ID:
             case FILES: {
-                return callingIdentity.checkCallingPermissionUserSelected();
+                return callingIdentity.checkCallingPermissionUserSelected(
+                        /* forDataDelivery */ true);
             }
             default: return false;
         }
diff --git a/src/com/android/providers/media/AsyncPickerFileOpener.java b/src/com/android/providers/media/AsyncPickerFileOpener.java
index eb392c7b5..fdf25147c 100644
--- a/src/com/android/providers/media/AsyncPickerFileOpener.java
+++ b/src/com/android/providers/media/AsyncPickerFileOpener.java
@@ -33,16 +33,18 @@ import android.provider.OpenFileRequest;
 import android.provider.ParcelableException;
 import android.util.Log;
 
+import com.android.providers.media.util.FileUtils;
 import com.android.providers.media.util.StringUtils;
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Utility class used to open picker files asynchronously.
- * It manages a {@link java.util.concurrent.ThreadPoolExecutor} that is being used to schedule
+ * It manages a {@link ThreadPoolExecutor} that is being used to schedule
  * pending open file requests.
  */
 public class AsyncPickerFileOpener {
@@ -99,9 +101,10 @@ public class AsyncPickerFileOpener {
         final int tid = Process.myTid();
         mMediaProvider.addToPendingOpenMap(tid, callingIdentity.uid);
 
+        ParcelFileDescriptor pfd = null;
         try {
             cancellationSignal.throwIfCanceled();
-            final ParcelFileDescriptor pfd = mPickerUriResolver.openFile(
+            pfd = mPickerUriResolver.openFile(
                     request.getUri(), "r", cancellationSignal, callingIdentity);
             callback.onSuccess(pfd);
         } catch (RemoteException ignore) {
@@ -114,6 +117,10 @@ public class AsyncPickerFileOpener {
                 // ignore remote exception as it means the requester has died
             }
         }  finally {
+            if (pfd != null) {
+                // Closing the file descriptor on this side as Binder will dup it
+                FileUtils.closeQuietly(pfd);
+            }
             mMediaProvider.removeFromPendingOpenMap(tid);
         }
     }
@@ -164,10 +171,10 @@ public class AsyncPickerFileOpener {
 
         final int tid = Process.myTid();
         mMediaProvider.addToPendingOpenMap(tid, callingIdentity.uid);
-
+        AssetFileDescriptor afd = null;
         try {
             cancellationSignal.throwIfCanceled();
-            AssetFileDescriptor afd = mPickerUriResolver.openTypedAssetFile(
+            afd = mPickerUriResolver.openTypedAssetFile(
                     request.getUri(), request.getMimeType(), opts, cancellationSignal,
                     callingIdentity, wantsThumb);
             callback.onSuccess(afd);
@@ -181,6 +188,10 @@ public class AsyncPickerFileOpener {
                 // ignore remote Exception as it means that the requester has died
             }
         }  finally {
+            if (afd != null) {
+                // Closing the file descriptor on this side as Binder will dup it
+                FileUtils.closeQuietly(afd);
+            }
             mMediaProvider.removeFromPendingOpenMap(tid);
         }
     }
diff --git a/src/com/android/providers/media/ConfigStore.java b/src/com/android/providers/media/ConfigStore.java
index a16e956e3..b2ae87e98 100644
--- a/src/com/android/providers/media/ConfigStore.java
+++ b/src/com/android/providers/media/ConfigStore.java
@@ -22,6 +22,7 @@ import static android.provider.DeviceConfig.NAMESPACE_STORAGE_NATIVE_BOOT;
 import static java.util.Objects.requireNonNull;
 
 import android.content.res.Resources;
+import android.content.res.Resources.NotFoundException;
 import android.os.Binder;
 import android.os.Build;
 import android.os.SystemProperties;
@@ -399,18 +400,24 @@ public interface ConfigStore {
         @Nullable
         @Override
         public String getDefaultCloudProviderPackage() {
-            String pkg = mResources.getString(R.string.config_default_cloud_media_provider_package);
-            if (pkg == null && Build.VERSION.SDK_INT <= TIRAMISU) {
-                // We are on Android T or below and do not have
-                // config_default_cloud_media_provider_package: let's see if we have now deprecated
-                // config_default_cloud_provider_authority.
-                final String authority =
-                        mResources.getString(R.string.config_default_cloud_provider_authority);
-                if (authority != null) {
-                    pkg = maybeExtractPackageNameFromCloudProviderAuthority(authority);
+            try {
+                String pkg =
+                        mResources.getString(R.string.config_default_cloud_media_provider_package);
+                if (pkg == null && Build.VERSION.SDK_INT <= TIRAMISU) {
+                    // We are on Android T or below and do not have
+                    // config_default_cloud_media_provider_package: let's see if we have now
+                    // deprecated
+                    // config_default_cloud_provider_authority.
+                    final String authority =
+                            mResources.getString(R.string.config_default_cloud_provider_authority);
+                    if (authority != null) {
+                        pkg = maybeExtractPackageNameFromCloudProviderAuthority(authority);
+                    }
                 }
+                return pkg;
+            } catch (NotFoundException e) {
+                return null;
             }
-            return pkg;
         }
 
         @NonNull
@@ -533,12 +540,16 @@ public interface ConfigStore {
 
         @Override
         public Optional<String> getDefaultOemMetadataServicePackage() {
-            String pkg = mResources.getString(R.string.config_default_oem_metadata_service_package);
-            if (pkg == null || pkg.isEmpty()) {
+            try {
+                String pkg =
+                        mResources.getString(R.string.config_default_oem_metadata_service_package);
+                if (pkg == null || pkg.isEmpty()) {
+                    return Optional.empty();
+                }
+                return Optional.of(pkg);
+            } catch (NotFoundException e) {
                 return Optional.empty();
             }
-
-            return Optional.of(pkg);
         }
 
         @Override
diff --git a/src/com/android/providers/media/DatabaseBackupAndRecovery.java b/src/com/android/providers/media/DatabaseBackupAndRecovery.java
index 03888a772..d6e0565a6 100644
--- a/src/com/android/providers/media/DatabaseBackupAndRecovery.java
+++ b/src/com/android/providers/media/DatabaseBackupAndRecovery.java
@@ -74,6 +74,7 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.stream.Collectors;
 
 /**
@@ -163,6 +164,12 @@ public class DatabaseBackupAndRecovery {
      */
     protected static final int LEVEL_DB_READ_LIMIT = 100;
 
+
+    /**
+     * Re-entrant lock to ensure sequential update to leveldb by background threads.
+     */
+    private final ReentrantLock mLevelDbUpdateLock = new ReentrantLock();
+
     /**
      * Stores cached value of next owner id. This helps in improving performance by backing up next
      * row id less frequently in the external storage.
@@ -196,14 +203,14 @@ public class DatabaseBackupAndRecovery {
     public static final String STABLE_URI_EXTERNAL_PROPERTY =
             "persist.sys.fuse.backup.external_volume_backup";
 
-    private static boolean STABLE_URI_EXTERNAL_PROPERTY_VALUE = false;
+    private static boolean STABLE_URI_EXTERNAL_PROPERTY_VALUE = true;
 
     public static final String STABLE_URI_PUBLIC_PROPERTY =
             "persist.sys.fuse.backup.public_db_backup";
 
-    private static boolean STABLE_URI_PUBLIC_PROPERTY_VALUE = false;
+    private static boolean STABLE_URI_PUBLIC_PROPERTY_VALUE = true;
 
-    protected DatabaseBackupAndRecovery(ConfigStore configStore, VolumeCache volumeCache) {
+    DatabaseBackupAndRecovery(ConfigStore configStore, VolumeCache volumeCache) {
         mConfigStore = configStore;
         mVolumeCache = volumeCache;
     }
@@ -211,7 +218,7 @@ public class DatabaseBackupAndRecovery {
     /**
      * Returns true if migration and recovery code flow for stable uris is enabled for given volume.
      */
-    protected boolean isStableUrisEnabled(String volumeName) {
+    boolean isStableUrisEnabled(String volumeName) {
         // Check if flags are enabled for test for internal volume
         if (MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)
                 && mIsStableUriEnabledForInternal) {
@@ -263,7 +270,7 @@ public class DatabaseBackupAndRecovery {
      * setup(no-op if connection already exists). So, we setup backup and recovery for internal
      * volume on Media mount signal of EXTERNAL_PRIMARY.
      */
-    protected synchronized void setupVolumeDbBackupAndRecovery(String volumeName) {
+    synchronized void setupVolumeDbBackupAndRecovery(String volumeName) {
         // Since internal volume does not have any fuse daemon thread, leveldb instance
         // for internal volume is created by fuse daemon thread of EXTERNAL_PRIMARY.
         if (MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)) {
@@ -336,22 +343,30 @@ public class DatabaseBackupAndRecovery {
     /**
      * Backs up databases to external storage to ensure stable URIs.
      */
-    public void backupDatabases(DatabaseHelper internalDatabaseHelper,
+    void backupDatabases(DatabaseHelper internalDatabaseHelper,
             DatabaseHelper externalDatabaseHelper, CancellationSignal signal) {
-        setupVolumeDbBackupAndRecovery(MediaStore.VOLUME_EXTERNAL_PRIMARY);
-        Log.i(TAG, "Triggering database backup");
-        backupInternalDatabase(internalDatabaseHelper, signal);
-        backupExternalDatabase(externalDatabaseHelper, MediaStore.VOLUME_EXTERNAL_PRIMARY, signal);
-
-        for (MediaVolume mediaVolume : mVolumeCache.getExternalVolumes()) {
-            if (mediaVolume.isPublicVolume()) {
-                setupVolumeDbBackupAndRecovery(mediaVolume.getName());
-                backupExternalDatabase(externalDatabaseHelper, mediaVolume.getName(), signal);
+        mLevelDbUpdateLock.lock();
+        try {
+            setupVolumeDbBackupAndRecovery(MediaStore.VOLUME_EXTERNAL_PRIMARY);
+            Log.i(TAG, "Triggering database backup");
+            backupInternalDatabase(internalDatabaseHelper, signal);
+            backupExternalDatabase(externalDatabaseHelper,
+                    MediaStore.VOLUME_EXTERNAL_PRIMARY, signal);
+
+            for (MediaVolume mediaVolume : mVolumeCache.getExternalVolumes()) {
+                if (mediaVolume.isPublicVolume()) {
+                    setupVolumeDbBackupAndRecovery(mediaVolume.getName());
+                    backupExternalDatabase(externalDatabaseHelper, mediaVolume.getName(), signal);
+                }
             }
+        } catch (Exception e) {
+            Log.e(TAG, "Failure in backing up databases", e);
+        } finally {
+            mLevelDbUpdateLock.unlock();
         }
     }
 
-    protected Optional<BackupIdRow> readDataFromBackup(String volumeName, String filePath) {
+    Optional<BackupIdRow> readDataFromBackup(String volumeName, String filePath) {
         if (!isStableUrisEnabled(volumeName)) {
             return Optional.empty();
         }
@@ -371,7 +386,7 @@ public class DatabaseBackupAndRecovery {
         }
     }
 
-    protected synchronized void backupInternalDatabase(DatabaseHelper internalDbHelper,
+    private void backupInternalDatabase(DatabaseHelper internalDbHelper,
             CancellationSignal signal) {
         if (!isStableUrisEnabled(MediaStore.VOLUME_INTERNAL)
                 || internalDbHelper.isDatabaseRecovering()) {
@@ -412,7 +427,7 @@ public class DatabaseBackupAndRecovery {
         });
     }
 
-    protected synchronized void backupExternalDatabase(DatabaseHelper externalDbHelper,
+    private void backupExternalDatabase(DatabaseHelper externalDbHelper,
             String volumeName, CancellationSignal signal) {
         if (!isStableUrisEnabled(volumeName)
                 || externalDbHelper.isDatabaseRecovering()) {
@@ -523,7 +538,7 @@ public class DatabaseBackupAndRecovery {
         }
     }
 
-    protected void deleteBackupForVolume(String volumeName) {
+    void deleteBackupForVolume(String volumeName) {
         File dbFilePath = new File(
                 String.format(Locale.ROOT, "%s/%s.db", LOWER_FS_RECOVERY_DIRECTORY_PATH,
                         LEVEL_DB_PREFIX + volumeName));
@@ -532,7 +547,7 @@ public class DatabaseBackupAndRecovery {
         }
     }
 
-    protected String[] readBackedUpFilePaths(String volumeName, String lastReadValue, int limit)
+    String[] readBackedUpFilePaths(String volumeName, String lastReadValue, int limit)
             throws IOException, UnsupportedOperationException {
         if (!isStableUrisEnabled(volumeName)) {
             throw new UnsupportedOperationException("Stable Uris are not enabled");
@@ -542,7 +557,7 @@ public class DatabaseBackupAndRecovery {
                 .readBackedUpFilePaths(volumeName, lastReadValue, limit);
     }
 
-    protected void updateNextRowIdXattr(DatabaseHelper helper, long id) {
+    void updateNextRowIdXattr(DatabaseHelper helper, long id) {
         if (helper.isInternal()) {
             updateNextRowIdForInternal(helper, id);
             return;
@@ -583,7 +598,7 @@ public class DatabaseBackupAndRecovery {
         return MediaProvider.getFuseDaemonForFile(new File(path), mVolumeCache);
     }
 
-    protected void updateNextRowIdAndSetDirty(@NonNull DatabaseHelper helper,
+    void updateNextRowIdAndSetDirty(@NonNull DatabaseHelper helper,
             @NonNull FileRow oldRow, @NonNull FileRow newRow) {
         updateNextRowIdXattr(helper, newRow.getId());
         markBackupAsDirty(helper, oldRow);
@@ -592,11 +607,12 @@ public class DatabaseBackupAndRecovery {
     /**
      * Backs up DB data in external storage to recover in case of DB rollback.
      */
-    protected void backupVolumeDbData(DatabaseHelper databaseHelper, FileRow insertedRow) {
+    void backupVolumeDbData(DatabaseHelper databaseHelper, FileRow insertedRow) {
         if (!isBackupUpdateAllowed(databaseHelper, insertedRow.getVolumeName())) {
             return;
         }
 
+        mLevelDbUpdateLock.lock();
         try {
             FuseDaemon fuseDaemonExternalPrimary = getFuseDaemonForPath(EXTERNAL_PRIMARY_ROOT_PATH);
             final BackupIdRow value = createBackupIdRow(fuseDaemonExternalPrimary, insertedRow);
@@ -612,6 +628,8 @@ public class DatabaseBackupAndRecovery {
             }
         } catch (Exception e) {
             Log.e(TAG, "Failure in backing up data to external storage", e);
+        } finally {
+            mLevelDbUpdateLock.unlock();
         }
     }
 
@@ -647,8 +665,9 @@ public class DatabaseBackupAndRecovery {
     }
 
 
-    private int getOwnerPackageId(FuseDaemon fuseDaemon, String ownerPackageName, int userId)
-            throws IOException {
+    private synchronized int getOwnerPackageId(FuseDaemon fuseDaemon,
+            String ownerPackageName, int userId) throws IOException {
+        // In synchronized block to avoid use of same owner id for multiple owner package relations
         if (Strings.isNullOrEmpty(ownerPackageName) || ownerPackageName.equalsIgnoreCase("null")) {
             // We store -1 in the backup if owner package name is null.
             return -1;
@@ -686,8 +705,7 @@ public class DatabaseBackupAndRecovery {
         return Pair.create(arr[0], Integer.valueOf(arr[1]));
     }
 
-    private synchronized int getAndIncrementNextOwnerId() {
-        // In synchronized block to avoid use of same owner id for multiple owner package relations
+    private int getAndIncrementNextOwnerId() {
         if (mNextOwnerId == null) {
             Optional<Integer> nextOwnerIdOptional = getXattrOfIntegerValue(
                     OWNER_RELATION_LOWER_FS_BACKUP_PATH,
@@ -711,7 +729,7 @@ public class DatabaseBackupAndRecovery {
         Log.d(TAG, "Updated next owner id to: " + val);
     }
 
-    protected void removeOwnerIdToPackageRelation(String packageName, int userId) {
+    void removeOwnerIdToPackageRelation(String packageName, int userId) {
         if (Strings.isNullOrEmpty(packageName) || packageName.equalsIgnoreCase("null")
                 || !isStableUrisEnabled(MediaStore.VOLUME_EXTERNAL_PRIMARY)
                 || !new File(OWNER_RELATION_LOWER_FS_BACKUP_PATH).exists()
@@ -733,7 +751,7 @@ public class DatabaseBackupAndRecovery {
     /**
      * Deletes backed up data(needed for recovery) from external storage.
      */
-    protected void deleteFromDbBackup(DatabaseHelper databaseHelper, FileRow deletedRow) {
+    void deleteFromDbBackup(DatabaseHelper databaseHelper, FileRow deletedRow) {
         if (!isBackupUpdateAllowed(databaseHelper, deletedRow.getVolumeName())) {
             return;
         }
@@ -743,15 +761,18 @@ public class DatabaseBackupAndRecovery {
             return;
         }
 
+        mLevelDbUpdateLock.lock();
         try {
             getFuseDaemonForPath(getFuseFilePathFromVolumeName(deletedRow.getVolumeName()))
                     .deleteDbBackup(deletedFilePath);
         } catch (IOException e) {
             Log.w(TAG, "Failure in deleting backup data for key: " + deletedFilePath, e);
+        } finally {
+            mLevelDbUpdateLock.unlock();
         }
     }
 
-    protected boolean isBackupUpdateAllowed(DatabaseHelper databaseHelper, String volumeName) {
+    private boolean isBackupUpdateAllowed(DatabaseHelper databaseHelper, String volumeName) {
         // Backup only if stable uris is enabled, db is not recovering and backup setup is complete.
         return isStableUrisEnabled(volumeName) && !databaseHelper.isDatabaseRecovering()
                 && mSetupCompleteVolumes.contains(volumeName);
@@ -818,7 +839,7 @@ public class DatabaseBackupAndRecovery {
     /**
      * Reads long value corresponding to given key from xattr on given path.
      */
-    static Optional<Long> getXattrOfLongValue(String path, String key) {
+    private static Optional<Long> getXattrOfLongValue(String path, String key) {
         try {
             return Optional.of(Long.parseLong(new String(Os.getxattr(path, key))));
         } catch (Exception e) {
@@ -897,7 +918,7 @@ public class DatabaseBackupAndRecovery {
         }
     }
 
-    protected boolean insertDataInDatabase(SQLiteDatabase db, BackupIdRow row, String filePath,
+    private boolean insertDataInDatabase(SQLiteDatabase db, BackupIdRow row, String filePath,
             String volumeName) {
         final ContentValues values = createValuesFromFileRow(row, filePath, volumeName);
         return db.insertWithOnConflict("files", null, values,
@@ -935,7 +956,7 @@ public class DatabaseBackupAndRecovery {
         return values;
     }
 
-    protected Pair<String, Integer> getOwnerPackageNameAndUidPair(int ownerPackageId) {
+    private Pair<String, Integer> getOwnerPackageNameAndUidPair(int ownerPackageId) {
         if (sOwnerIdRelationMap == null) {
             try {
                 sOwnerIdRelationMap = readOwnerIdRelationsFromLevelDb();
@@ -953,11 +974,11 @@ public class DatabaseBackupAndRecovery {
         return Pair.create(null, null);
     }
 
-    protected Map<String, String> readOwnerIdRelationsFromLevelDb() throws IOException {
+    private Map<String, String> readOwnerIdRelationsFromLevelDb() throws IOException {
         return getFuseDaemonForPath(EXTERNAL_PRIMARY_ROOT_PATH).readOwnerIdRelations();
     }
 
-    protected String readOwnerPackageName(String ownerId) throws IOException {
+    String readOwnerPackageName(String ownerId) throws IOException {
         Map<String, String> ownerIdRelationMap = readOwnerIdRelationsFromLevelDb();
         if (ownerIdRelationMap.containsKey(String.valueOf(ownerId))) {
             return getPackageNameAndUserId(ownerIdRelationMap.get(ownerId)).first;
@@ -966,7 +987,7 @@ public class DatabaseBackupAndRecovery {
         return null;
     }
 
-    protected void markPublicVolumesRecovery() {
+    void markPublicVolumesRecovery() {
         try {
             File recoveryDir = new File(LOWER_FS_RECOVERY_DIRECTORY_PATH);
             for (File levelDbFile : recoveryDir.listFiles()) {
@@ -985,7 +1006,7 @@ public class DatabaseBackupAndRecovery {
         }
     }
 
-    protected boolean isPublicVolumeMarkedForRecovery(String volumeName) {
+    boolean isPublicVolumeMarkedForRecovery(String volumeName) {
         String filePath = LOWER_FS_RECOVERY_DIRECTORY_PATH + "/" + LEVEL_DB_PREFIX
                 + volumeName.toLowerCase(Locale.ROOT);
         Optional<String> flag = getXattr(filePath, PUBLIC_VOLUME_RECOVERY_FLAG_XATTR_KEY);
@@ -994,13 +1015,13 @@ public class DatabaseBackupAndRecovery {
         return flag.isPresent();
     }
 
-    protected void removePublicVolumeRecoveryFlag(String volumeName) {
+    void removePublicVolumeRecoveryFlag(String volumeName) {
         String filePath = LOWER_FS_RECOVERY_DIRECTORY_PATH + "/" + LEVEL_DB_PREFIX
                 + volumeName.toLowerCase(Locale.ROOT);
         removeXattr(filePath, PUBLIC_VOLUME_RECOVERY_FLAG_XATTR_KEY);
     }
 
-    protected void recoverData(SQLiteDatabase db, String volumeName) throws Exception {
+    void recoverData(SQLiteDatabase db, String volumeName) throws Exception {
         long rowsRecovered = 0, dirtyRowsCount = 0, insertionFailuresCount = 0,
                 totalLevelDbRows = 0;
         final long startTime = SystemClock.elapsedRealtime();
@@ -1103,7 +1124,7 @@ public class DatabaseBackupAndRecovery {
         Log.v(TAG, "Leveldb Last backed generation number reset done to 0 for " + volumeName);
     }
 
-    protected boolean isBackupPresent(String volumeName) {
+    boolean isBackupPresent(String volumeName) {
         if (MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)) {
             return new File(INTERNAL_VOLUME_LOWER_FS_BACKUP_PATH).exists();
         } else if (MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)) {
@@ -1116,7 +1137,7 @@ public class DatabaseBackupAndRecovery {
         return false;
     }
 
-    protected void waitForVolumeToBeAttached(String volumeName) throws TimeoutException {
+    void waitForVolumeToBeAttached(String volumeName) throws TimeoutException {
         long time = 0;
         // Wait of 10 seconds
         long waitTimeInMilliseconds = 10000;
@@ -1134,14 +1155,14 @@ public class DatabaseBackupAndRecovery {
         throw new TimeoutException("Timed out waiting for " + volumeName + " setup");
     }
 
-    protected FuseDaemon getFuseDaemonForFileWithWait(File fuseFilePath)
+    FuseDaemon getFuseDaemonForFileWithWait(File fuseFilePath)
             throws FileNotFoundException, TimeoutException {
         pollForExternalStorageMountedState();
         return MediaProvider.getFuseDaemonForFileWithWait(fuseFilePath, mVolumeCache,
                 WAIT_TIME_20_SECONDS_IN_MILLIS);
     }
 
-    protected void setStableUrisGlobalFlag(String volumeName, boolean isEnabled) {
+    void setStableUrisGlobalFlag(String volumeName, boolean isEnabled) {
         if (MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)) {
             mIsStableUriEnabledForInternal = isEnabled;
         } else if (MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)) {
@@ -1179,7 +1200,7 @@ public class DatabaseBackupAndRecovery {
     /**
      * Returns list of backed up files from external storage.
      */
-    protected List<File> getBackupFiles() {
+    List<File> getBackupFiles() {
         return Arrays.asList(new File(LOWER_FS_RECOVERY_DIRECTORY_PATH).listFiles());
     }
 
@@ -1187,7 +1208,7 @@ public class DatabaseBackupAndRecovery {
      * Updates backup in external storage to the latest values. Deletes backup of old file path if
      * file path has changed.
      */
-    public void updateBackup(DatabaseHelper helper, FileRow oldRow, FileRow newRow) {
+    void updateBackup(DatabaseHelper helper, FileRow oldRow, FileRow newRow) {
         if (!isBackupUpdateAllowed(helper, newRow.getVolumeName())) {
             return;
         }
@@ -1220,30 +1241,39 @@ public class DatabaseBackupAndRecovery {
             fuseDaemonPublicVolume = null;
         }
 
-        helper.runWithTransaction((db) -> {
-            try (Cursor c = db.query(true, "files", QUERY_COLUMNS, "_id=?",
-                    new String[]{String.valueOf(newRow.getId())}, null, null, null,
-                    null, null)) {
-                if (c.moveToFirst()) {
-                    backupDataValues(fuseDaemonExternalPrimary, fuseDaemonPublicVolume, c);
-                    String newPath = c.getString(1);
-                    if (oldRow.getPath() != null && !oldRow.getPath().equalsIgnoreCase(newPath)) {
-                        // If file path has changed, update leveldb backup to delete old path.
-                        deleteFromDbBackup(helper, oldRow);
-                        Log.v(TAG, "Deleted backup of old file path: " + oldRow.getPath());
+        mLevelDbUpdateLock.lock();
+        try {
+            helper.runWithTransaction((db) -> {
+                try (Cursor c = db.query(true, "files", QUERY_COLUMNS, "_id=?",
+                        new String[]{String.valueOf(newRow.getId())}, null, null, null,
+                        null, null)) {
+                    if (c.moveToFirst()) {
+                        backupDataValues(fuseDaemonExternalPrimary, fuseDaemonPublicVolume, c);
+                        String newPath = c.getString(1);
+                        if (oldRow.getPath() != null && !oldRow.getPath().equalsIgnoreCase(
+                                newPath)) {
+                            // If file path has changed, update leveldb backup to delete old path.
+                            deleteFromDbBackup(helper, oldRow);
+                            Log.v(TAG, "Deleted backup of old file path: "
+                                    + oldRow.getPath());
+                        }
                     }
+                } catch (Exception e) {
+                    Log.e(TAG, "Failure in updating row in external storage backup.", e);
                 }
-            } catch (Exception e) {
-                Log.e(TAG, "Failure in updating row in external storage backup.", e);
-            }
-            return null;
-        });
+                return null;
+            });
+        } catch (Exception e) {
+            Log.e(TAG, "Failure in updating row in external storage backup.", e);
+        } finally {
+            mLevelDbUpdateLock.unlock();
+        }
     }
 
     /**
      * Removes database recovery data for given user id. This is done when a user is removed.
      */
-    protected void removeRecoveryDataForUserId(int removedUserId) {
+    void removeRecoveryDataForUserId(int removedUserId) {
         String removeduserIdString = String.valueOf(removedUserId);
         removeXattr(DATA_MEDIA_XATTR_DIRECTORY_PATH,
                 INTERNAL_DB_NEXT_ROW_ID_XATTR_KEY_PREFIX.concat(
@@ -1263,7 +1293,7 @@ public class DatabaseBackupAndRecovery {
      * and removes the recovery data for ones not present in this list.
      * This is done during an idle maintenance.
      */
-    protected void removeRecoveryDataExceptValidUsers(List<String> validUsers) {
+    void removeRecoveryDataExceptValidUsers(List<String> validUsers) {
         List<String> xattrList = listXattr(DATA_MEDIA_XATTR_DIRECTORY_PATH);
         Log.i(TAG, "Xattr list is " + xattrList);
         if (xattrList.isEmpty()) {
@@ -1288,7 +1318,7 @@ public class DatabaseBackupAndRecovery {
                 dirtyRowsCount, totalLevelDbRows, insertionFailureCount, status);
     }
 
-    protected static List<String> getInvalidUsersList(List<String> recoveryData,
+    static List<String> getInvalidUsersList(List<String> recoveryData,
             List<String> validUsers) {
         Set<String> presentUserIdsAsXattr = new HashSet<>();
         for (String xattr : recoveryData) {
diff --git a/src/com/android/providers/media/FilesOwnershipUtils.java b/src/com/android/providers/media/FilesOwnershipUtils.java
new file mode 100644
index 000000000..a0e2ee5fb
--- /dev/null
+++ b/src/com/android/providers/media/FilesOwnershipUtils.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import static android.provider.BaseColumns._ID;
+import static android.provider.MediaStore.Files.FileColumns._USER_ID;
+import static android.provider.MediaStore.MediaColumns.GENERATION_MODIFIED;
+import static android.provider.MediaStore.MediaColumns.OWNER_PACKAGE_NAME;
+
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.net.Uri;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Utility class for revoking owner_grants when user deselects images that were created by the app
+ * in picker choice mode
+ */
+public class FilesOwnershipUtils {
+
+    private static final String FILES_TABLE_NAME = "files";
+    private static final String TEMP_TABLE_NAME = "temp_file_ids_table";
+    private static final String FILE_ID_COLUMN_NAME = "file_id";
+    private static final int CHUNK_SIZE = 50;
+    private static final String TAG = FilesOwnershipUtils.class.getSimpleName();
+
+    private final DatabaseHelper mExternalDatabase;
+
+    public FilesOwnershipUtils(DatabaseHelper databaseHelper) {
+        mExternalDatabase = databaseHelper;
+    }
+
+    /**
+     * Revokes the access of the file by setting the owner_package_name as null in the files table.
+     * <p>
+     * Images or videos can be preselected because the app owns the file and has access to it.
+     * If the user deselects such a image/video, we revoke the access of the file by setting the
+     * owner_package_name as null in the files table.
+     * </p>
+     */
+    public void removeOwnerPackageNameForUris(@NonNull String[] packages, @NonNull List<Uri> uris,
+            int packageUserId) {
+        mExternalDatabase.runWithTransaction(db -> {
+            db.execSQL("CREATE TEMPORARY TABLE " +  TEMP_TABLE_NAME + " (" + FILE_ID_COLUMN_NAME
+                    + " INTEGER)");
+
+            /*
+             * Insert all ids in temporary tables in batches.
+             * This will be used in update query below for setting owner_package_name to null
+             * if this file is currently owned by the app
+             */
+            List<List<Uri>> uriChunks = splitArrayList(uris, CHUNK_SIZE);
+            for (List<Uri> chunk : uriChunks) {
+                String sqlQuery = String.format(
+                        Locale.ROOT,
+                        "INSERT INTO %s (%s) VALUES %s",
+                        TEMP_TABLE_NAME,
+                        FILE_ID_COLUMN_NAME,
+                        getPlaceholderString(chunk.size())
+                );
+
+                db.execSQL(sqlQuery, chunk.stream().map(ContentUris::parseId).toArray());
+            }
+
+            long generationNumber = DatabaseHelper.getGeneration(db);
+
+            /*
+             * sample query for setting owner_package_name as null :
+             * UPDATE files SET generation_modified = (SELECT generation from local_metadata),
+             * owner_package_name = NULL WHERE (EXISTS (SELECT file_id FROM temp_file_ids_table
+             * WHERE files_id = files._id) AND owner_package_name IN (com.example.package1,
+             * com.example.package2) AND _user_id = example_user_id)
+             */
+
+            String whereClause = "(EXISTS (SELECT " + FILE_ID_COLUMN_NAME + " FROM "
+                    + TEMP_TABLE_NAME + " WHERE " + FILE_ID_COLUMN_NAME + " = " + FILES_TABLE_NAME
+                    + "." + _ID + ") " + "AND " + OWNER_PACKAGE_NAME + " IN ("
+                    + getPlaceholderString(packages.length) + ") " + "AND " + _USER_ID + " = ?)";
+
+            List<String> whereArgs = new ArrayList<>(Arrays.asList(packages));
+            whereArgs.add(String.valueOf(packageUserId));
+
+            ContentValues contentValues = new ContentValues();
+            contentValues.put(GENERATION_MODIFIED, generationNumber);
+            contentValues.putNull(OWNER_PACKAGE_NAME);
+
+            int rowsAffected = db.update(FILES_TABLE_NAME, contentValues, whereClause,
+                    whereArgs.toArray(String[]::new));
+
+            Log.i(TAG, "Set owner package name to null for " + rowsAffected + " items for "
+                    + "packages " + Arrays.toString(packages));
+
+            db.execSQL("DROP TABLE " + TEMP_TABLE_NAME);
+
+            return null;
+        });
+    }
+
+    private static String getPlaceholderString(int length) {
+        return String.join(", ", Collections.nCopies(length, "(?)"));
+    }
+
+    private static <T> List<List<T>> splitArrayList(List<T> list, int chunkSize) {
+        List<List<T>> subLists = new ArrayList<>();
+        for (int i = 0; i < list.size(); i += chunkSize) {
+            subLists.add(list.subList(i, Math.min(i + chunkSize, list.size())));
+        }
+        return subLists;
+    }
+}
diff --git a/src/com/android/providers/media/LocalCallingIdentity.java b/src/com/android/providers/media/LocalCallingIdentity.java
index e30a68ca1..2a5e452ce 100644
--- a/src/com/android/providers/media/LocalCallingIdentity.java
+++ b/src/com/android/providers/media/LocalCallingIdentity.java
@@ -29,12 +29,13 @@ import static com.android.providers.media.util.PermissionUtils.checkPermissionIn
 import static com.android.providers.media.util.PermissionUtils.checkPermissionManager;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionQueryAllPackages;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadAudio;
+import static com.android.providers.media.util.PermissionUtils.checkPermissionReadForLegacyStorage;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadImages;
-import static com.android.providers.media.util.PermissionUtils.checkPermissionReadStorage;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadVideo;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadVisualUserSelected;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionSelf;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionShell;
+import static com.android.providers.media.util.PermissionUtils.checkPermissionUpdateOemMetadata;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionWriteAudio;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionWriteImages;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionWriteStorage;
@@ -353,13 +354,22 @@ public class LocalCallingIdentity {
     public static final int PERMISSION_QUERY_ALL_PACKAGES = 1 << 28;
     public static final int PERMISSION_ACCESS_MEDIA_OWNER_PACKAGE_NAME = 1 << 29;
     public static final int PERMISSION_ACCESS_OEM_METADATA = 1 << 30;
+    public static final int PERMISSION_UPDATE_OEM_METADATA = 1 << 31;
 
     private volatile int hasPermission;
     private volatile int hasPermissionResolved;
 
     public boolean hasPermission(int permission) {
+        return hasPermission(permission, /* forDataDelivery */ true);
+    }
+
+    /**
+     * Checks the package for the input permission and if the param
+     * forDataDelivery is true then makes a note of it.
+     */
+    public boolean hasPermission(int permission, boolean forDataDelivery) {
         if ((hasPermissionResolved & permission) == 0) {
-            if (hasPermissionInternal(permission)) {
+            if (hasPermissionInternal(permission, forDataDelivery)) {
                 hasPermission |= permission;
             }
             hasPermissionResolved |= permission;
@@ -367,7 +377,7 @@ public class LocalCallingIdentity {
         return (hasPermission & permission) != 0;
     }
 
-    private boolean hasPermissionInternal(int permission) {
+    private boolean hasPermissionInternal(int permission, boolean forDataDelivery) {
         boolean targetSdkIsAtLeastT = getTargetSdkVersion() > Build.VERSION_CODES.S_V2;
         // While we're here, enforce any broad user-level restrictions
         if ((uid == Process.SHELL_UID) && context.getSystemService(UserManager.class)
@@ -401,25 +411,28 @@ public class LocalCallingIdentity {
 
             case PERMISSION_READ_AUDIO:
                 return checkPermissionReadAudio(
-                        context, pid, uid, getPackageName(), attributionTag, targetSdkIsAtLeastT);
+                        context, pid, uid, getPackageName(), attributionTag, targetSdkIsAtLeastT,
+                        forDataDelivery);
             case PERMISSION_READ_VIDEO:
                 return checkPermissionReadVideo(
-                        context, pid, uid, getPackageName(), attributionTag, targetSdkIsAtLeastT);
+                        context, pid, uid, getPackageName(), attributionTag, targetSdkIsAtLeastT,
+                        forDataDelivery);
             case PERMISSION_READ_IMAGES:
                 return checkPermissionReadImages(
-                        context, pid, uid, getPackageName(), attributionTag, targetSdkIsAtLeastT);
+                        context, pid, uid, getPackageName(), attributionTag, targetSdkIsAtLeastT,
+                        forDataDelivery);
             case PERMISSION_WRITE_AUDIO:
                 return checkPermissionWriteAudio(
-                        context, pid, uid, getPackageName(), attributionTag);
+                        context, pid, uid, getPackageName(), attributionTag, forDataDelivery);
             case PERMISSION_WRITE_VIDEO:
                 return checkPermissionWriteVideo(
-                        context, pid, uid, getPackageName(), attributionTag);
+                        context, pid, uid, getPackageName(), attributionTag, forDataDelivery);
             case PERMISSION_WRITE_IMAGES:
                 return checkPermissionWriteImages(
-                        context, pid, uid, getPackageName(), attributionTag);
+                        context, pid, uid, getPackageName(), attributionTag, forDataDelivery);
             case PERMISSION_IS_SYSTEM_GALLERY:
                 return checkWriteImagesOrVideoAppOps(
-                        context, uid, getPackageName(), attributionTag);
+                        context, uid, getPackageName(), attributionTag, forDataDelivery);
             case PERMISSION_INSTALL_PACKAGES:
                 return checkPermissionInstallPackages(
                         context, pid, uid, getPackageName(), attributionTag);
@@ -431,7 +444,7 @@ public class LocalCallingIdentity {
                         context, pid, uid, getPackageName(), attributionTag);
             case PERMISSION_READ_MEDIA_VISUAL_USER_SELECTED:
                 return checkPermissionReadVisualUserSelected(context, pid, uid, getPackageName(),
-                        attributionTag, targetSdkIsAtLeastT);
+                        attributionTag, targetSdkIsAtLeastT, forDataDelivery);
             case PERMISSION_QUERY_ALL_PACKAGES:
                 return checkPermissionQueryAllPackages(
                         context, pid, uid, getPackageName(), attributionTag);
@@ -441,6 +454,9 @@ public class LocalCallingIdentity {
             case PERMISSION_ACCESS_OEM_METADATA:
                 return checkPermissionAccessOemMetadata(context, pid, uid, getPackageName(),
                         attributionTag);
+            case PERMISSION_UPDATE_OEM_METADATA:
+                return checkPermissionUpdateOemMetadata(context, pid, uid, getPackageName(),
+                        attributionTag);
             default:
                 return false;
         }
@@ -464,8 +480,7 @@ public class LocalCallingIdentity {
         // To address b/338519249, we will check for sdk version V+
         boolean targetSdkIsAtLeastV =
                 getTargetSdkVersion() >= Build.VERSION_CODES.VANILLA_ICE_CREAM;
-        return checkIsLegacyStorageGranted(context, uid, getPackageName(), attributionTag,
-                targetSdkIsAtLeastV);
+        return checkIsLegacyStorageGranted(context, uid, getPackageName(), targetSdkIsAtLeastV);
     }
 
     private volatile boolean shouldBypass;
@@ -561,8 +576,14 @@ public class LocalCallingIdentity {
     }
 
     private boolean isLegacyReadInternal() {
-        return hasPermission(PERMISSION_IS_LEGACY_GRANTED)
-                && checkPermissionReadStorage(context, pid, uid, getPackageName(), attributionTag);
+        boolean isLegacyStorageGranted = hasPermission(PERMISSION_IS_LEGACY_GRANTED);
+        if (!isLegacyStorageGranted) {
+            return false;
+        }
+
+        boolean isTargetSdkAtleastT = getTargetSdkVersion() >= Build.VERSION_CODES.TIRAMISU;
+        return checkPermissionReadForLegacyStorage(context, pid, uid, getPackageName(),
+                attributionTag, isTargetSdkAtleastT);
     }
 
     /** System internals or callers holding permission have no redaction */
@@ -684,37 +705,39 @@ public class LocalCallingIdentity {
     /**
      * Returns {@code true} if this package has Audio read/write permissions.
      */
-    public boolean checkCallingPermissionAudio(boolean forWrite) {
+    public boolean checkCallingPermissionAudio(boolean forWrite, boolean forDataDelivery) {
         if (forWrite) {
-            return hasPermission(PERMISSION_WRITE_AUDIO);
+            return hasPermission(PERMISSION_WRITE_AUDIO, forDataDelivery);
         } else {
             // write permission should be enough for reading as well
-            return hasPermission(PERMISSION_READ_AUDIO)
-                    || hasPermission(PERMISSION_WRITE_AUDIO);
+            return hasPermission(PERMISSION_READ_AUDIO, forDataDelivery)
+                    || hasPermission(PERMISSION_WRITE_AUDIO, forDataDelivery);
         }
     }
 
     /**
      * Returns {@code true} if this package has Video read/write permissions.
      */
-    public boolean checkCallingPermissionVideo(boolean forWrite) {
+    public boolean checkCallingPermissionVideo(boolean forWrite, boolean forDataDelivery) {
         if (forWrite) {
-            return hasPermission(PERMISSION_WRITE_VIDEO);
+            return hasPermission(PERMISSION_WRITE_VIDEO, forDataDelivery);
         } else {
             // write permission should be enough for reading as well
-            return hasPermission(PERMISSION_READ_VIDEO) || hasPermission(PERMISSION_WRITE_VIDEO);
+            return hasPermission(PERMISSION_READ_VIDEO, forDataDelivery) || hasPermission(
+                    PERMISSION_WRITE_VIDEO, forDataDelivery);
         }
     }
 
     /**
      * Returns {@code true} if this package has Image read/write permissions.
      */
-    public boolean checkCallingPermissionImages(boolean forWrite) {
+    public boolean checkCallingPermissionImages(boolean forWrite, boolean forDataDelivery) {
         if (forWrite) {
-            return hasPermission(PERMISSION_WRITE_IMAGES);
+            return hasPermission(PERMISSION_WRITE_IMAGES, forDataDelivery);
         } else {
             // write permission should be enough for reading as well
-            return hasPermission(PERMISSION_READ_IMAGES) || hasPermission(PERMISSION_WRITE_IMAGES);
+            return hasPermission(PERMISSION_READ_IMAGES, forDataDelivery) || hasPermission(
+                    PERMISSION_WRITE_IMAGES, forDataDelivery);
         }
     }
 
@@ -735,6 +758,13 @@ public class LocalCallingIdentity {
         return hasPermission(PERMISSION_ACCESS_OEM_METADATA);
     }
 
+    /**
+     * Returns {@code true} if this package has permission to update oem_metadata of any media.
+     */
+    public boolean checkCallingPermissionToUpdateOemMetadata() {
+        return hasPermission(PERMISSION_UPDATE_OEM_METADATA);
+    }
+
     /**
      * Returns {@code true} if this package is a legacy app and has read permission
      */
@@ -752,11 +782,12 @@ public class LocalCallingIdentity {
     /**
      * Return {@code true} if this package has user selected access on images/videos.
      */
-    public boolean checkCallingPermissionUserSelected() {
+    public boolean checkCallingPermissionUserSelected(boolean forDataDelivery) {
         // For user select mode READ_MEDIA_VISUAL_USER_SELECTED == true &&
         // READ_MEDIA_IMAGES == false && READ_MEDIA_VIDEO == false
-        return hasPermission(PERMISSION_READ_MEDIA_VISUAL_USER_SELECTED)
-                && !hasPermission(PERMISSION_READ_IMAGES) && !hasPermission(PERMISSION_READ_VIDEO);
+        return hasPermission(PERMISSION_READ_MEDIA_VISUAL_USER_SELECTED, forDataDelivery)
+                && !hasPermission(PERMISSION_READ_IMAGES, forDataDelivery) && !hasPermission(
+                PERMISSION_READ_VIDEO, forDataDelivery);
     }
 
     protected void dump(PrintWriter writer) {
diff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java
index be59d3d1d..85227f7d6 100644
--- a/src/com/android/providers/media/MediaProvider.java
+++ b/src/com/android/providers/media/MediaProvider.java
@@ -34,6 +34,7 @@ import static android.provider.CloudMediaProviderContract.METHOD_GET_ASYNC_CONTE
 import static android.provider.MediaStore.EXTRA_IS_STABLE_URIS_ENABLED;
 import static android.provider.MediaStore.EXTRA_OPEN_ASSET_FILE_REQUEST;
 import static android.provider.MediaStore.EXTRA_OPEN_FILE_REQUEST;
+import static android.provider.MediaStore.EXTRA_URI_LIST;
 import static android.provider.MediaStore.Files.FileColumns.MEDIA_TYPE;
 import static android.provider.MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE;
 import static android.provider.MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO;
@@ -41,14 +42,14 @@ import static android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT;
 import static android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT_NONE;
 import static android.provider.MediaStore.GET_BACKUP_FILES;
 import static android.provider.MediaStore.GET_OWNER_PACKAGE_NAME;
+import static android.provider.MediaStore.Images.ImageColumns.LATITUDE;
+import static android.provider.MediaStore.Images.ImageColumns.LONGITUDE;
 import static android.provider.MediaStore.MATCH_DEFAULT;
 import static android.provider.MediaStore.MATCH_EXCLUDE;
 import static android.provider.MediaStore.MATCH_INCLUDE;
 import static android.provider.MediaStore.MATCH_ONLY;
 import static android.provider.MediaStore.MEDIA_IGNORE_FILENAME;
 import static android.provider.MediaStore.MY_UID;
-import static android.provider.MediaStore.Images.ImageColumns.LATITUDE;
-import static android.provider.MediaStore.Images.ImageColumns.LONGITUDE;
 import static android.provider.MediaStore.MediaColumns.OEM_METADATA;
 import static android.provider.MediaStore.MediaColumns.OWNER_PACKAGE_NAME;
 import static android.provider.MediaStore.PER_USER_RANGE;
@@ -87,6 +88,8 @@ import static com.android.providers.media.LocalCallingIdentity.PERMISSION_IS_RED
 import static com.android.providers.media.LocalCallingIdentity.PERMISSION_IS_SELF;
 import static com.android.providers.media.LocalCallingIdentity.PERMISSION_IS_SHELL;
 import static com.android.providers.media.LocalCallingIdentity.PERMISSION_IS_SYSTEM_GALLERY;
+import static com.android.providers.media.LocalCallingIdentity.PERMISSION_READ_IMAGES;
+import static com.android.providers.media.LocalCallingIdentity.PERMISSION_READ_VIDEO;
 import static com.android.providers.media.LocalCallingIdentity.PERMISSION_WRITE_EXTERNAL_STORAGE;
 import static com.android.providers.media.LocalUriMatcher.AUDIO_ALBUMART;
 import static com.android.providers.media.LocalUriMatcher.AUDIO_ALBUMART_FILE_ID;
@@ -139,7 +142,6 @@ import static com.android.providers.media.PickerUriResolver.PICKER_TRANSCODED_SE
 import static com.android.providers.media.PickerUriResolver.getMediaUri;
 import static com.android.providers.media.flags.Flags.indexMediaLatitudeLongitude;
 import static com.android.providers.media.flags.Flags.versionLockdown;
-import static com.android.providers.media.flags.Flags.enableBackupAndRestore;
 import static com.android.providers.media.photopicker.data.ItemsProvider.EXTRA_MIME_TYPE_SELECTION;
 import static com.android.providers.media.scan.MediaScanner.REASON_DEMAND;
 import static com.android.providers.media.scan.MediaScanner.REASON_IDLE;
@@ -299,6 +301,7 @@ import com.android.modules.utils.BackgroundThread;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.providers.media.DatabaseHelper.OnFilesChangeListener;
 import com.android.providers.media.DatabaseHelper.OnLegacyMigrationListener;
+import com.android.providers.media.backupandrestore.BackupAndRestoreUtils;
 import com.android.providers.media.backupandrestore.BackupExecutor;
 import com.android.providers.media.dao.FileRow;
 import com.android.providers.media.flags.Flags;
@@ -327,6 +330,7 @@ import com.android.providers.media.util.ForegroundThread;
 import com.android.providers.media.util.Logging;
 import com.android.providers.media.util.LongArray;
 import com.android.providers.media.util.Metrics;
+import com.android.providers.media.util.MimeTypeFixHandler;
 import com.android.providers.media.util.MimeUtils;
 import com.android.providers.media.util.PermissionUtils;
 import com.android.providers.media.util.Preconditions;
@@ -335,7 +339,6 @@ import com.android.providers.media.util.SQLiteQueryBuilder;
 import com.android.providers.media.util.SpecialFormatDetector;
 import com.android.providers.media.util.StringUtils;
 import com.android.providers.media.util.UserCache;
-import com.android.providers.media.util.XAttrUtils;
 
 import com.google.common.hash.HashCode;
 import com.google.common.hash.Hashing;
@@ -501,6 +504,27 @@ public class MediaProvider extends ContentProvider {
     @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.R)
     static final long ENABLE_INCLUDE_ALL_VOLUMES = 182734110L;
 
+    /**
+     * Enables allowing the user to revoke the app access to its created photos and videos.
+     * If the app target sdk is >= {@link android.os.Build.VERSION_CODES#BAKLAVA},
+     * then they should expect that they may lose access to photos or videos they have created
+     * while they could still be on the device.
+     */
+    @ChangeId
+    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    public static final long ENABLE_OWNED_PHOTOS = 310703690L;
+
+
+    /**
+     * Excludes unreliable storage volumes from being included in
+     * {@link MediaStore#getExternalVolumeNames(Context)}.
+     */
+    @ChangeId
+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.CUR_DEVELOPMENT)
+    @VisibleForTesting
+    // TODO: b/402623169 Set CUR_DEVELOPMENT as the latest version once available
+    static final long EXCLUDE_UNRELIABLE_STORAGE_VOLUMES = 391360514L;
+
     /**
      * Set of {@link Cursor} columns that refer to raw filesystem paths.
      */
@@ -535,6 +559,11 @@ public class MediaProvider extends ContentProvider {
      */
     private static final String META_DATA_PREFERENCE_SUMMARY = "com.android.settings.summary";
 
+    private static final String MEDIAPROVIDER_PREFS = "mediaprovider_prefs";
+
+    private static final String IS_MIME_TYPE_FIXED_IN_ANDROID_15 =
+            "is_mime_type_fixed_in_android_15";
+
     /**
      * Updates the MediaStore versioning schema and format to reduce identifying properties.
      */
@@ -542,6 +571,14 @@ public class MediaProvider extends ContentProvider {
     @EnabledSince(targetSdkVersion = Build.VERSION_CODES.BAKLAVA)
     static final long LOCKDOWN_MEDIASTORE_VERSION = 343977174L;
 
+    /**
+     * Number of uris sent to bulk write/delete/trash/favorite requests restricted at 2000.
+     * Attempting to send more than 2000 uris will result in an IllegalArgumentException.
+     */
+    @ChangeId
+    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    static final long LIMIT_CREATE_REQUEST_URIS = 203408344L;
+
     @GuardedBy("mPendingOpenInfo")
     private final Map<Integer, PendingOpenInfo> mPendingOpenInfo = new ArrayMap<>();
 
@@ -649,6 +686,18 @@ public class MediaProvider extends ContentProvider {
         }
     };
 
+    /**
+     * Utility function if owned photos features is enabled.
+     * @return boolean value indicating whether feature is enabled or not
+     */
+    public static boolean isOwnedPhotosEnabled(int uid) {
+        // TODO change this to SdkLevel.isAtLeastB() once method is available
+        return ((Build.VERSION.CODENAME.equals("Baklava")
+                || Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA)
+                && CompatChanges.isChangeEnabled(ENABLE_OWNED_PHOTOS, uid)
+                && Flags.revokeAccessOwnedPhotos());
+    }
+
     /**
      * Map from UID to cached {@link LocalCallingIdentity}. Values are only
      * maintained in this map until there's any change in the appops needed or packages
@@ -712,7 +761,7 @@ public class MediaProvider extends ContentProvider {
                     packageManager.getPackageUidAsUser(
                             packageName, PackageManager.PackageInfoFlags.of(0), userId);
             LocalCallingIdentity lci = LocalCallingIdentity.fromExternal(context, mUserCache, uid);
-            if (!lci.checkCallingPermissionUserSelected()) {
+            if (!lci.checkCallingPermissionUserSelected(/* forDataDelivery */ false)) {
                 String[] packages = lci.getSharedPackageNamesArray();
                 mMediaGrants.removeAllMediaGrantsForPackages(
                         packages, /* reason= */ "Mode changed: " + op, userId);
@@ -1188,8 +1237,7 @@ public class MediaProvider extends ContentProvider {
 
                 mDatabaseBackupAndRecovery.deleteFromDbBackup(helper, deletedRow);
                 if (deletedRow.getVolumeName() != null
-                        && deletedRow.getVolumeName().equalsIgnoreCase(VOLUME_EXTERNAL_PRIMARY)
-                        && enableBackupAndRestore()) {
+                        && deletedRow.getVolumeName().equalsIgnoreCase(VOLUME_EXTERNAL_PRIMARY)) {
                     mExternalPrimaryBackupExecutor.deleteBackupForPath(deletedRow.getPath());
                 }
             });
@@ -1278,12 +1326,24 @@ public class MediaProvider extends ContentProvider {
         }
     }
 
+    @VisibleForTesting
+    protected String[] getDefaultFolderNames() {
+        return DEFAULT_FOLDER_NAMES;
+    }
+
+    @VisibleForTesting
+    protected List<String> getFoldersToSkipInDefaultCreation() {
+        return StringUtils.getStringArrayConfig(getContext(),
+                R.array.config_foldersToSkipInDefaultCreation);
+    }
+
     /**
      * Ensure that default folders are created on mounted storage devices.
      * We only do this once per volume so we don't annoy the user if deleted
-     * manually.
+     * manually. Folders in the exclusion list are not created.
      */
-    private void ensureDefaultFolders(@NonNull MediaVolume volume, @NonNull SQLiteDatabase db) {
+    @VisibleForTesting
+    protected void ensureDefaultFolders(@NonNull MediaVolume volume, @NonNull SQLiteDatabase db) {
         if (volume.shouldSkipDefaultDirCreation()) {
             // Default folders should not be automatically created inside volumes managed from
             // outside Android.
@@ -1304,12 +1364,31 @@ public class MediaProvider extends ContentProvider {
 
         final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getContext());
         if (prefs.getInt(key, 0) == 0) {
-            for (String folderName : DEFAULT_FOLDER_NAMES) {
+            // Get case insensitive exclusion list.
+            List<String> exclusionList =
+                    Flags.enableExclusionListForDefaultFolders()
+                            ? getFoldersToSkipInDefaultCreation().stream().map(
+                            String::toLowerCase).collect(Collectors.toList())
+                            : List.of();
+            if (exclusionList.size() > getDefaultFolderNames().length) {
+                Log.e(TAG, "Exclusion list has " + exclusionList.size()
+                        + " items which exceeds the size of default folders list which has size "
+                        + getDefaultFolderNames().length);
+                exclusionList = List.of();
+            }
+            for (String folderName : getDefaultFolderNames()) {
                 final File folder = new File(volume.getPath(), folderName);
-                if (!folder.exists()) {
-                    folder.mkdirs();
-                    insertDirectory(db, folder.getAbsolutePath());
+                if (folder.exists()) {
+                    continue;
                 }
+                if (Flags.enableExclusionListForDefaultFolders() && exclusionList.contains(
+                        folderName.toLowerCase(Locale.ROOT))) {
+                    // Do not create mobile-centric folders for PC.
+                    Log.d(TAG, "Excluding " + folder + " from default creation");
+                    continue;
+                }
+                folder.mkdirs();
+                insertDirectory(db, folder.getAbsolutePath());
             }
 
             SharedPreferences.Editor editor = prefs.edit();
@@ -1438,6 +1517,7 @@ public class MediaProvider extends ContentProvider {
         mExternalDbFacade = new ExternalDbFacade(getContext(), mExternalDatabase, mVolumeCache);
 
         mMediaGrants = new MediaGrants(mExternalDatabase);
+        mFilesOwnershipUtils = new FilesOwnershipUtils(mExternalDatabase);
 
         PickerSyncLockManager pickerSyncLockManager = new PickerSyncLockManager();
         mPickerDbFacade = new PickerDbFacade(context, pickerSyncLockManager);
@@ -1559,6 +1639,9 @@ public class MediaProvider extends ContentProvider {
 
         PulledMetrics.initialize(context);
         mMaliciousAppDetector = createMaliciousAppDetector();
+
+        initializeMimeTypeFixHandlerForAndroid15(getContext());
+
         return true;
     }
 
@@ -1733,6 +1816,7 @@ public class MediaProvider extends ContentProvider {
                 return null;
             });
         }
+        BackupAndRestoreUtils.doCleanUpAfterRestoreIfRequired(getContext());
 
         // Delete any stale thumbnails
         final int staleThumbnails = mExternalDatabase.runWithTransaction((db) -> {
@@ -1764,11 +1848,11 @@ public class MediaProvider extends ContentProvider {
         // value as NULL, and update the same in the picker db
         detectSpecialFormat(signal);
 
-        if (enableBackupAndRestore()) {
-            Log.i(TAG, "Backup is enabled");
-            // Backup needed for B&R
-            mExternalPrimaryBackupExecutor.doBackup(signal);
-        }
+        mExternalPrimaryBackupExecutor.doBackup(signal);
+
+        // In Android 15, certain MIME types were introduced that are not supported, this fixes
+        // existing data with these unsupported MIME types
+        fixUnsupportedMimeTypesForAndroid15(getContext());
 
         final long durationMillis = (SystemClock.elapsedRealtime() - startTime);
         Metrics.logIdleMaintenance(MediaStore.VOLUME_EXTERNAL, itemCount,
@@ -1907,6 +1991,38 @@ public class MediaProvider extends ContentProvider {
         }
     }
 
+    private void fixUnsupportedMimeTypesForAndroid15(Context context) {
+        if (!Flags.enableMimeTypeFixForAndroid15()) {
+            return;
+        }
+
+        if (context == null) {
+            return;
+        }
+
+        if (Build.VERSION.SDK_INT != Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+            return;
+        }
+
+        SharedPreferences prefs = context.getSharedPreferences(MEDIAPROVIDER_PREFS,
+                Context.MODE_PRIVATE);
+        if (prefs.getBoolean(IS_MIME_TYPE_FIXED_IN_ANDROID_15, false)) {
+            Log.v(TAG, "Mime type already corrected");
+            return;
+        }
+
+        mExternalDatabase.runWithTransaction(db -> {
+            boolean isSuccess = MimeTypeFixHandler.updateUnsupportedMimeTypes(db);
+            // if success then update the shared pref value
+            if (isSuccess) {
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(IS_MIME_TYPE_FIXED_IN_ANDROID_15, true);
+                editor.apply();
+            }
+            return null;
+        });
+    }
+
     private void updateSpecialFormatColumn(SQLiteDatabase db, @NonNull CancellationSignal signal) {
         // This is to ensure we only do a bounded iteration over the rows as updates can fail, and
         // we don't want to keep running the query/update indefinitely.
@@ -2022,35 +2138,57 @@ public class MediaProvider extends ContentProvider {
         final long expiredTime = now + (FileUtils.DEFAULT_DURATION_EXTENDED / 1000);
         return mExternalDatabase.runWithTransaction((db) -> {
             String selection = FileColumns.DATE_EXPIRES + " < " + now;
+            selection += " AND (IS_PENDING=1 OR IS_TRASHED=1)";
             selection += " AND volume_name in " + bindList(MediaStore.getExternalVolumeNames(
                     getContext()).toArray());
             String[] projection = new String[]{"volume_name", "_id",
                     FileColumns.DATE_EXPIRES, FileColumns.DATA};
-            try (Cursor c = db.query(true, "files", projection, selection, null, null, null, null,
-                    null, signal)) {
-                int totalDeleteCount = 0;
-                int totalExtendedCount = 0;
-                int index = 0;
+            final class TrashItem {
+                final String mVolumeName;
+                final long mId;
+                final long mDateExpires;
+                final String mOriginalPath;
+
+                TrashItem(String volumeName, long id, long dateExpires, String oriPath) {
+                    this.mVolumeName = volumeName;
+                    this.mId = id;
+                    this.mDateExpires = dateExpires;
+                    this.mOriginalPath = oriPath;
+                }
+            }
+
+            final List<TrashItem> items = new ArrayList<>();
+            try (Cursor c = db.query(true, "files", projection, selection,
+                    null, null, null, null, null, signal)) {
                 while (c.moveToNext()) {
-                    final String volumeName = c.getString(0);
-                    final long id = c.getLong(1);
-                    final long dateExpires = c.getLong(2);
-                    // we only delete the items that expire in one week
-                    if (dateExpires > expiredOneWeek) {
-                        totalDeleteCount += delete(Files.getContentUri(volumeName, id), null, null);
-                    } else {
-                        final String oriPath = c.getString(3);
+                    items.add(new TrashItem(
+                            c.getString(0), // volumeName
+                            c.getLong(1),   // id
+                            c.getLong(2),   // dateExpires
+                            c.getString(3)  // oriPath
+                    ));
+                }
+            }
 
-                        final boolean success = extendExpiredItem(db, oriPath, id, expiredTime,
-                                expiredTime + index);
-                        if (success) {
-                            totalExtendedCount++;
-                        }
-                        index++;
+            int totalDeleteCount = 0;
+            int totalExtendedCount = 0;
+            int index = 0;
+
+            for (TrashItem item : items) {
+                if (item.mDateExpires > expiredOneWeek) {
+                    totalDeleteCount += delete(Files.getContentUri(item.mVolumeName, item.mId),
+                            null, null);
+                } else {
+                    boolean success = extendExpiredItem(db, item.mOriginalPath, item.mId,
+                            expiredTime, expiredTime + index);
+                    if (success) {
+                        totalExtendedCount++;
                     }
+                    index++;
                 }
-                return new int[]{totalDeleteCount, totalExtendedCount};
             }
+
+            return new int[]{totalDeleteCount, totalExtendedCount};
         });
     }
 
@@ -3289,11 +3427,13 @@ public class MediaProvider extends ContentProvider {
 
     private ArrayList<String> getIncludedDefaultDirectories() {
         final ArrayList<String> includedDefaultDirs = new ArrayList<>();
-        if (mCallingIdentity.get().checkCallingPermissionVideo(/* forWrite */ true)) {
+        if (mCallingIdentity.get().checkCallingPermissionVideo(/* forWrite */
+                true, /* forDataDelivery */ true)) {
             includedDefaultDirs.add(Environment.DIRECTORY_DCIM);
             includedDefaultDirs.add(Environment.DIRECTORY_PICTURES);
             includedDefaultDirs.add(Environment.DIRECTORY_MOVIES);
-        } else if (mCallingIdentity.get().checkCallingPermissionImages(/* forWrite */ true)) {
+        } else if (mCallingIdentity.get().checkCallingPermissionImages(/* forWrite */
+                true, /* forDataDelivery */ true)) {
             includedDefaultDirs.add(Environment.DIRECTORY_DCIM);
             includedDefaultDirs.add(Environment.DIRECTORY_PICTURES);
         }
@@ -3935,7 +4075,8 @@ public class MediaProvider extends ContentProvider {
                     mPickerSyncController.getCloudProvider(), mPickerDataLayer);
         }
         if (table == PICKER_INTERNAL_V2) {
-            return PickerUriResolverV2.query(getContext().getApplicationContext(), uri, queryArgs);
+            return PickerUriResolverV2.query(
+                    getContext().getApplicationContext(), uri, queryArgs, signal);
         }
 
         final DatabaseHelper helper = getDatabaseForUri(uri);
@@ -5720,6 +5861,12 @@ public class MediaProvider extends ContentProvider {
             }
         }
 
+
+        // Enforce oem_metadata permission if caller is not MediaProvider
+        if (Flags.enableOemMetadataUpdate() && initialValues.containsKey(OEM_METADATA)) {
+            enforcePermissionCheckForOemMetadataUpdate();
+        }
+
         long rowId = -1;
         Uri newUri = null;
 
@@ -7097,6 +7244,10 @@ public class MediaProvider extends ContentProvider {
             case MediaStore.PICKER_MEDIA_INIT_CALL: {
                 return getResultForPickerMediaInit(extras);
             }
+            case MediaStore.PICKER_MEDIA_IN_MEDIA_SET_INIT_CALL: {
+                initMediaInMediaSet(extras);
+                return new Bundle();
+            }
             case MediaStore.PICKER_INTERNAL_SEARCH_MEDIA_INIT_CALL: {
                 return getResultForPickerSearchMediaInit(extras);
             }
@@ -7104,6 +7255,9 @@ public class MediaProvider extends ContentProvider {
                 initMediaSets(extras);
                 return new Bundle();
             }
+            case MediaStore.PICKER_GET_SEARCH_PROVIDERS_CALL: {
+                return getPickerSearchProviders();
+            }
             case MediaStore.PICKER_TRANSCODE_CALL: {
                 return getResultForPickerTranscode(extras);
             }
@@ -7170,11 +7324,80 @@ public class MediaProvider extends ContentProvider {
                 removeRecoveryData();
                 return new Bundle();
             }
+            case MediaStore.BULK_UPDATE_OEM_METADATA_CALL: {
+                callForBulkUpdateOemMetadataColumn();
+                return new Bundle();
+            }
             default:
                 throw new UnsupportedOperationException("Unsupported call: " + method);
         }
     }
 
+    private void callForBulkUpdateOemMetadataColumn() {
+        if (!Flags.enableOemMetadataUpdate()) {
+            return;
+        }
+
+        enforcePermissionCheckForOemMetadataUpdate();
+        Set<String> oemSupportedMimeTypes = mMediaScanner.getOemSupportedMimeTypes();
+        if (oemSupportedMimeTypes == null || oemSupportedMimeTypes.isEmpty()) {
+            // Nothing to update
+            return;
+        }
+
+        // Get media types to update rows based on media type
+        Set<Integer> mediaTypesToBeUpdated = new HashSet<>();
+        for (String mimeType : oemSupportedMimeTypes) {
+            // Convert to media type to avoid using like clause on mime types to protect against
+            // SQL injection
+            mediaTypesToBeUpdated.add(MimeUtils.resolveMediaType(mimeType));
+        }
+
+        if (mediaTypesToBeUpdated.isEmpty()) {
+            // For invalid mime types, do not bother
+            return;
+        }
+
+        final LocalCallingIdentity token = clearLocalCallingIdentity();
+        try {
+            ContentValues values = new ContentValues();
+            values.putNull(OEM_METADATA);
+            // Mark _modifier as _MODIFIER_CR to allow metadata update on next scan. This
+            // is explicitly required when calling update with MediaProvider identity
+            values.put(FileColumns._MODIFIER, FileColumns._MODIFIER_CR);
+            Bundle extras = new Bundle();
+            extras.putString(ContentResolver.QUERY_ARG_SQL_SELECTION,
+                    appendMediaTypeClause(mediaTypesToBeUpdated));
+            Log.v(TAG, "Trigger bulk update of OEM metadata");
+            update(MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL), values, extras);
+        } finally {
+            restoreLocalCallingIdentity(token);
+        }
+    }
+
+    private String appendMediaTypeClause(Set<Integer> mediaTypesToBeUpdated) {
+        List<String> whereMediaTypesCondition = new ArrayList<String>();
+        for (Integer mediaType : mediaTypesToBeUpdated) {
+            whereMediaTypesCondition.add(
+                    String.format(Locale.ROOT, "%s=%d", MEDIA_TYPE, mediaType));
+        }
+
+        StringBuilder sb = new StringBuilder();
+        sb.append("(");
+        sb.append(TextUtils.join(" OR ", whereMediaTypesCondition));
+        sb.append(")");
+        return sb.toString();
+    }
+
+    @VisibleForTesting
+    protected void enforcePermissionCheckForOemMetadataUpdate() {
+        if (!isCallingPackageSelf()
+                && !mCallingIdentity.get().checkCallingPermissionToUpdateOemMetadata()) {
+            throw new SecurityException(
+                    "Calling package does not have permission to update OEM metadata");
+        }
+    }
+
     @Nullable
     private Bundle getResultForRevokeReadGrantForPackage(Bundle extras) {
         final int caller = Binder.getCallingUid();
@@ -7183,6 +7406,7 @@ public class MediaProvider extends ContentProvider {
         int userId;
         List<Uri> uris = null;
         String[] packageNames;
+        int packageUid;
         if (checkPermissionShell(caller)) {
             // If the caller is the shell, the accepted parameter is EXTRA_PACKAGE_NAME
             // (as string).
@@ -7191,7 +7415,14 @@ public class MediaProvider extends ContentProvider {
                         "Missing required extras arguments: EXTRA_URI or"
                                 + " EXTRA_PACKAGE_NAME");
             }
-            packageNames = new String[]{extras.getString(Intent.EXTRA_PACKAGE_NAME)};
+            String packageName = extras.getString(Intent.EXTRA_PACKAGE_NAME);
+            packageNames = new String[]{packageName};
+            try {
+                packageUid = mPackageManager.getPackageUid(packageName, 0);
+            } catch (NameNotFoundException e) {
+                Log.e(TAG, "No packageUid found for packageName " + packageName, e);
+                throw new RuntimeException(e);
+            }
             // Uris are not a requirement for revoke all call
             if (!isCallForRevokeAll) {
                 uris = List.of(Uri.parse(extras.getString(MediaStore.EXTRA_URI)));
@@ -7201,7 +7432,7 @@ public class MediaProvider extends ContentProvider {
             userId = UserHandle.myUserId();
         } else if (checkPermissionSelf(caller) || isCallerPhotoPicker()) {
             final PackageManager pm = getContext().getPackageManager();
-            final int packageUid = extras.getInt(Intent.EXTRA_UID);
+            packageUid = extras.getInt(Intent.EXTRA_UID);
             packageNames = pm.getPackagesForUid(packageUid);
             // Get the userId from packageUid as the initiator could be a cloned app, which
             // accesses Media via MP of its parent user and Binder's callingUid reflects
@@ -7209,7 +7440,7 @@ public class MediaProvider extends ContentProvider {
             userId = uidToUserId(packageUid);
             // Uris are not a requirement for revoke all call
             if (!isCallForRevokeAll) {
-                uris = extras.getParcelableArrayList(MediaStore.EXTRA_URI_LIST);
+                uris = extras.getParcelableArrayList(EXTRA_URI_LIST);
             }
         } else {
             // All other callers are unauthorized.
@@ -7217,11 +7448,15 @@ public class MediaProvider extends ContentProvider {
                     getSecurityExceptionMessage("revoke media grants"));
         }
 
-        if (isCallForRevokeAll) {
+        if (isCallForRevokeAll && !isOwnedPhotosEnabled(packageUid)) {
             mMediaGrants.removeAllMediaGrantsForPackages(packageNames, "user de-selections",
                     userId);
         } else if (uris != null) {
             mMediaGrants.removeMediaGrantsForPackage(packageNames, uris, userId);
+            if (isOwnedPhotosEnabled(packageUid)) {
+                mFilesOwnershipUtils.removeOwnerPackageNameForUris(packageNames, uris,
+                        userId);
+            }
         }
         return null;
     }
@@ -7275,6 +7510,13 @@ public class MediaProvider extends ContentProvider {
         return null;
     }
 
+    /**
+     * Triggers backup for MediaProvider.
+     */
+    public void triggerBackup() {
+        mExternalPrimaryBackupExecutor.doBackup(null);
+    }
+
     @Nullable
     private Bundle getResultForWaitForIdle() {
         // TODO(b/195009139): Remove after overriding wait for idle in test to sync picker
@@ -7475,14 +7717,14 @@ public class MediaProvider extends ContentProvider {
 
     @NotNull
     private Bundle getResultForGetRedactedMediaUriList(Bundle extras) {
-        final List<Uri> uris = extras.getParcelableArrayList(MediaStore.EXTRA_URI_LIST);
+        final List<Uri> uris = extras.getParcelableArrayList(EXTRA_URI_LIST);
         // NOTE: It is ok to update the DB and return a redacted URI for the cases when
         // the user code only has read access, hence we don't check for write permission.
         enforceCallingPermission(uris, false);
         final LocalCallingIdentity token = clearLocalCallingIdentity();
         try {
             final Bundle res = new Bundle();
-            res.putParcelableArrayList(MediaStore.EXTRA_URI_LIST,
+            res.putParcelableArrayList(EXTRA_URI_LIST,
                     (ArrayList<? extends Parcelable>) getRedactedUri(uris));
             return res;
         } finally {
@@ -7513,12 +7755,12 @@ public class MediaProvider extends ContentProvider {
         } else if (checkPermissionSelf(caller) || isCallerPhotoPicker()) {
             // If the caller is MediaProvider the accepted parameters are EXTRA_URI_LIST
             // and EXTRA_UID.
-            if (!extras.containsKey(MediaStore.EXTRA_URI_LIST)
+            if (!extras.containsKey(EXTRA_URI_LIST)
                     && !extras.containsKey(Intent.EXTRA_UID)) {
                 throw new IllegalArgumentException(
                         "Missing required extras arguments: EXTRA_URI_LIST or" + " EXTRA_UID");
             }
-            uris = extras.getParcelableArrayList(MediaStore.EXTRA_URI_LIST);
+            uris = extras.getParcelableArrayList(EXTRA_URI_LIST);
             final PackageManager pm = getContext().getPackageManager();
             final int packageUid = extras.getInt(Intent.EXTRA_UID);
             final String[] packages = pm.getPackagesForUid(packageUid);
@@ -7618,7 +7860,8 @@ public class MediaProvider extends ContentProvider {
             String packageName = arg;
             int uid = extras.getInt(MediaStore.EXTRA_IS_SYSTEM_GALLERY_UID);
             boolean isSystemGallery = PermissionUtils.checkWriteImagesOrVideoAppOps(
-                    getContext(), uid, packageName, getContext().getAttributionTag());
+                    getContext(), uid, packageName, getContext().getAttributionTag(),
+                    /*forDataDelivery*/ false);
             Bundle res = new Bundle();
             res.putBoolean(MediaStore.EXTRA_IS_SYSTEM_GALLERY_RESPONSE, isSystemGallery);
             return res;
@@ -7640,6 +7883,28 @@ public class MediaProvider extends ContentProvider {
         return null;
     }
 
+    private void initMediaInMediaSet(@NonNull Bundle extras) {
+        Objects.requireNonNull(extras);
+        Log.i(TAG, "Extras received for media in media set init: " + extras);
+        if (!checkPermissionSelf(Binder.getCallingUid()) && !isCallerPhotoPicker()) {
+            throw new SecurityException(
+                    getSecurityExceptionMessage("Picker media in media set init"));
+        }
+        PickerDataLayerV2.triggerMediaSyncForMediaSet(extras, getContext());
+    }
+
+    @Nullable
+    private Bundle getPickerSearchProviders() {
+        Log.i(TAG, "Received picker internal call to get available search providers.");
+        if (!checkPermissionShell(Binder.getCallingUid())
+                && !checkPermissionSelf(Binder.getCallingUid())
+                && !isCallerPhotoPicker()) {
+            throw new SecurityException(
+                    getSecurityExceptionMessage("Picker get search providers"));
+        }
+        return PickerDataLayerV2.getSearchProviders(getContext());
+    }
+
     /**
      * Checks if the caller has the permission to handle picker search media init. If not,
      * this method throws a security exception.
@@ -7652,7 +7917,7 @@ public class MediaProvider extends ContentProvider {
             throw new SecurityException(
                     getSecurityExceptionMessage("Picker search media init"));
         }
-        return PickerDataLayerV2.handleNewSearchRequest(getContext(), extras);
+        return PickerDataLayerV2.handleSearchResultsInit(getContext(), extras);
     }
 
     private void initMediaSets(@NonNull Bundle extras) {
@@ -8058,6 +8323,11 @@ public class MediaProvider extends ContentProvider {
         final ClipData clipData = extras.getParcelable(MediaStore.EXTRA_CLIP_DATA);
         final List<Uri> uris = collectUris(clipData);
 
+        if (getCallingPackageTargetSdkVersion() > Build.VERSION_CODES.VANILLA_ICE_CREAM
+                && CompatChanges.isChangeEnabled(LIMIT_CREATE_REQUEST_URIS) && uris.size() > 2000) {
+            throw new IllegalArgumentException("URI list restricted to 2000 per request");
+        }
+
         for (Uri uri : uris) {
             final int match = matchUri(uri, false);
             switch (match) {
@@ -8570,6 +8840,11 @@ public class MediaProvider extends ContentProvider {
                 initialValues.remove(FileColumns.GENERATION_MODIFIED);
             }
 
+            // Enforce oem_metadata permission if caller is not MediaProvider
+            if (Flags.enableOemMetadataUpdate() && initialValues.containsKey(OEM_METADATA)) {
+                enforcePermissionCheckForOemMetadataUpdate();
+            }
+
             if (!isCallingPackageSelf()) {
                 Trace.beginSection("MP.filter");
 
@@ -10217,8 +10492,44 @@ public class MediaProvider extends ContentProvider {
             return true;
         }
 
-        // Check if the caller has access to private app directories.
-        if (isUidAllowedAccessToDataOrObbPathForFuse(mCallingIdentity.get().uid, filePath)) {
+        // Check if the caller has access to private app directories. Checks for Android/data,
+        // Android/media and Android/obb
+        boolean isUidAllowedAccessToDataOrObbPath =
+                isUidAllowedAccessToDataOrObbPathForFuse(mCallingIdentity.get().uid, filePath);
+
+        /*
+         * If owned photos is enabled, then image or video stored in app's private directory may
+         * not have access to it (i.e, have owner_package_name as null). So, only checking path is
+         * not enough to bypass fuse restrictions. We will have to additionally check if calling
+         * app has read permission.
+         */
+        if (isUidAllowedAccessToDataOrObbPath) {
+            if (!isExternalMediaDirectory(filePath)) {
+                return true;
+            }
+
+            if (!isOwnedPhotosEnabled(mCallingIdentity.get().uid)) {
+                return true;
+            }
+
+            int mediaType = getFileMediaType(filePath);
+
+            if (MEDIA_TYPE_IMAGE == mediaType) {
+                boolean hasReadImagesPermission =
+                        mCallingIdentity.get().hasPermission(PERMISSION_READ_IMAGES);
+                Log.v(TAG, "calling app has PERMISSION_READ_IMAGES? "
+                        + hasReadImagesPermission);
+                return hasReadImagesPermission;
+            }
+
+            if (MEDIA_TYPE_VIDEO == mediaType) {
+                boolean hasReadVideoPermission =
+                        mCallingIdentity.get().hasPermission(PERMISSION_READ_VIDEO);
+                Log.v(TAG, "calling app has PERMISSION_READ_VIDEO? "
+                        + hasReadVideoPermission);
+                return hasReadVideoPermission;
+            }
+
             return true;
         }
 
@@ -10330,15 +10641,17 @@ public class MediaProvider extends ContentProvider {
         // Hence, we check the mPendingOpenInfo object (populated when opens are initiated from
         // MediaProvider) if there's a pending open from MediaProvider with matching tid and uid and
         // use the shouldRedact decision there if there's one.
+        PendingOpenInfo info;
         synchronized (mPendingOpenInfo) {
-            PendingOpenInfo info = mPendingOpenInfo.get(tid);
-            if (info != null && info.uid == original_uid) {
-                boolean shouldRedact = info.shouldRedact;
-                if (shouldRedact) {
-                    return RedactionUtils.getRedactionRanges(file);
-                } else {
-                    return new long[0];
-                }
+            info = mPendingOpenInfo.get(tid);
+        }
+
+        if (info != null && info.uid == original_uid) {
+            boolean shouldRedact = info.shouldRedact;
+            if (shouldRedact) {
+                return RedactionUtils.getRedactionRanges(file);
+            } else {
+                return new long[0];
             }
         }
 
@@ -10561,23 +10874,8 @@ public class MediaProvider extends ContentProvider {
                 return new FileOpenResult(OsConstants.EACCES /* status */, originalUid,
                         mediaCapabilitiesUid, new long[0]);
             }
-            // TODO: Fetch owner id from Android/media directory and check if caller is owner
-            FileAccessAttributes fileAttributes = null;
-            if (XAttrUtils.ENABLE_XATTR_METADATA_FOR_FUSE) {
-                Optional<FileAccessAttributes> fileAttributesThroughXattr =
-                        XAttrUtils.getFileAttributesFromXAttr(path,
-                                XAttrUtils.FILE_ACCESS_XATTR_KEY);
-                if (fileAttributesThroughXattr.isPresent()) {
-                    fileAttributes = fileAttributesThroughXattr.get();
-                }
-            }
 
-            // FileAttributes will be null if the xattr call failed or the flag to enable xattr
-            // metadata support is not set
-            if (fileAttributes == null)  {
-                fileAttributes = queryForFileAttributes(path);
-            }
-            checkIfFileOpenIsPermitted(path, fileAttributes, redactedUriId, forWrite);
+            checkIfFileOpenIsPermitted(path, queryForFileAttributes(path), redactedUriId, forWrite);
             isSuccess = true;
             return new FileOpenResult(0 /* status */, originalUid, mediaCapabilitiesUid,
                     redact ? getRedactionRangesForFuse(path, ioPath, originalUid, uid, tid,
@@ -11683,14 +11981,15 @@ public class MediaProvider extends ContentProvider {
         final ContentResolver resolver = getContext().getContentResolver();
         final Uri uri = getBaseContentUri(volumeName);
         // TODO(b/182396009) we probably also want to notify clone profile (and vice versa)
-        resolver.notifyChange(getBaseContentUri(volumeName), null);
+        ForegroundThread.getExecutor().execute(() -> {
+            resolver.notifyChange(getBaseContentUri(volumeName), null);
+        });
 
         if (LOGV) Log.v(TAG, "Attached volume: " + volume);
         if (!MediaStore.VOLUME_INTERNAL.equals(volumeName)) {
-            // Also notify on synthetic view of all devices
-            resolver.notifyChange(getBaseContentUri(MediaStore.VOLUME_EXTERNAL), null);
-
             ForegroundThread.getExecutor().execute(() -> {
+                // Also notify on synthetic view of all devices
+                resolver.notifyChange(getBaseContentUri(MediaStore.VOLUME_EXTERNAL), null);
                 mExternalDatabase.runWithTransaction((db) -> {
                     ensureNecessaryFolders(volume, db);
                     return null;
@@ -11751,11 +12050,15 @@ public class MediaProvider extends ContentProvider {
         }
 
         final ContentResolver resolver = getContext().getContentResolver();
-        resolver.notifyChange(getBaseContentUri(volumeName), null);
+        ForegroundThread.getExecutor().execute(() -> {
+            resolver.notifyChange(getBaseContentUri(volumeName), null);
+        });
 
         if (!MediaStore.VOLUME_INTERNAL.equals(volumeName)) {
-            // Also notify on synthetic view of all devices
-            resolver.notifyChange(getBaseContentUri(MediaStore.VOLUME_EXTERNAL), null);
+            ForegroundThread.getExecutor().execute(() -> {
+                // Also notify on synthetic view of all devices
+                resolver.notifyChange(getBaseContentUri(MediaStore.VOLUME_EXTERNAL), null);
+            });
         }
 
         if (LOGV) Log.v(TAG, "Detached volume: " + volumeName);
@@ -11795,6 +12098,7 @@ public class MediaProvider extends ContentProvider {
     private TranscodeHelper mTranscodeHelper;
     private PhotoPickerTranscodeHelper mPhotoPickerTranscodeHelper;
     private MediaGrants mMediaGrants;
+    private FilesOwnershipUtils mFilesOwnershipUtils;
     private DatabaseBackupAndRecovery mDatabaseBackupAndRecovery;
 
     private BackupExecutor mExternalPrimaryBackupExecutor;
@@ -11846,6 +12150,8 @@ public class MediaProvider extends ContentProvider {
 
         sMutableColumns.add(MediaStore.Files.FileColumns.MIME_TYPE);
         sMutableColumns.add(MediaStore.Files.FileColumns.MEDIA_TYPE);
+
+        sMutableColumns.add(MediaStore.Files.FileColumns.OEM_METADATA);
     }
 
     /**
@@ -12124,6 +12430,31 @@ public class MediaProvider extends ContentProvider {
         return configStore;
     }
 
+    /**
+     * Initializes the MimeTypeFixHandler for Android 15, running only for Android 15
+     * This method loads the mime types from the res/raw directory
+     * This is necessary to ensure that MediaProvider can handle mime types correctly on Android 15
+     */
+    private void initializeMimeTypeFixHandlerForAndroid15(Context context) {
+        if (Build.VERSION.SDK_INT != Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+            return;
+        }
+
+        if (!Flags.enableMimeTypeFixForAndroid15()) {
+            return;
+        }
+
+        // Load all the MIME types from various files in the background to reduce the latency
+        // caused when this method is called from onCreate
+        BackgroundThread.getExecutor().execute(() -> {
+            try {
+                MimeTypeFixHandler.loadMimeTypes(context);
+            } catch (Exception e) {
+                Log.e(TAG, "Failed to initialize MimeTypeFixHandler: ", e);
+            }
+        });
+    }
+
     /**
      * <b>FOT TESTING PURPOSES ONLY</b>
      * <p>
diff --git a/src/com/android/providers/media/PermissionActivity.java b/src/com/android/providers/media/PermissionActivity.java
index ac38fe30f..5ebe51fa8 100644
--- a/src/com/android/providers/media/PermissionActivity.java
+++ b/src/com/android/providers/media/PermissionActivity.java
@@ -512,21 +512,24 @@ public class PermissionActivity extends Activity {
             if (shouldCheckMediaPermissions) {
                 // check READ_MEDIA_AUDIO
                 if (shouldCheckReadAudio && !checkPermissionReadAudio(context, pid, uid,
-                        packageName, attributionTag, isTargetSdkAtLeastT)) {
+                        packageName, attributionTag, isTargetSdkAtLeastT,
+                        /* forDataDelivery */ true)) {
                     Log.d(TAG, "No permission READ_MEDIA_AUDIO or MANAGE_EXTERNAL_STORAGE");
                     return true;
                 }
 
                 // check READ_MEDIA_IMAGES
                 if (shouldCheckReadImages && !checkPermissionReadImages(context, pid, uid,
-                        packageName, attributionTag, isTargetSdkAtLeastT)) {
+                        packageName, attributionTag, isTargetSdkAtLeastT,
+                        /* forDataDelivery */ true)) {
                     Log.d(TAG, "No permission READ_MEDIA_IMAGES or MANAGE_EXTERNAL_STORAGE");
                     return true;
                 }
 
                 // check READ_MEDIA_VIDEO
                 if (shouldCheckReadVideo && !checkPermissionReadVideo(context, pid, uid,
-                        packageName, attributionTag, isTargetSdkAtLeastT)) {
+                        packageName, attributionTag, isTargetSdkAtLeastT,
+                        /* forDataDelivery */ true)) {
                     Log.d(TAG, "No permission READ_MEDIA_VIDEO or MANAGE_EXTERNAL_STORAGE");
                     return true;
                 }
@@ -534,9 +537,9 @@ public class PermissionActivity extends Activity {
                 // For subtitle case, check READ_MEDIA_AUDIO or READ_MEDIA_VIDEO
                 if (mShouldCheckReadAudioOrReadVideo
                         && !checkPermissionReadAudio(context, pid, uid, packageName, attributionTag,
-                        isTargetSdkAtLeastT)
+                        isTargetSdkAtLeastT, /* forDataDelivery */ true)
                         && !checkPermissionReadVideo(context, pid, uid, packageName, attributionTag,
-                        isTargetSdkAtLeastT)) {
+                        isTargetSdkAtLeastT, /* forDataDelivery */  true)) {
                     Log.d(TAG, "No permission READ_MEDIA_AUDIO, READ_MEDIA_VIDEO or "
                             + "MANAGE_EXTERNAL_STORAGE");
                     return true;
diff --git a/src/com/android/providers/media/TranscodeHelperImpl.java b/src/com/android/providers/media/TranscodeHelperImpl.java
index 616186794..5775f0f9b 100644
--- a/src/com/android/providers/media/TranscodeHelperImpl.java
+++ b/src/com/android/providers/media/TranscodeHelperImpl.java
@@ -119,6 +119,11 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -142,7 +147,7 @@ public class TranscodeHelperImpl implements TranscodeHelper {
     private static final int MY_UID = android.os.Process.myUid();
 
     // Whether the device has HDR plugin for transcoding HDR to SDR video.
-    private boolean mHasHdrPlugin = false;
+    private Future<Boolean> mHasHdrPlugin;
 
     /**
      * Force enable an app to support the HEVC media capability
@@ -279,7 +284,9 @@ public class TranscodeHelperImpl implements TranscodeHelper {
                 mTranscodingUiNotifier, mConfigStore.getTranscodeMaxDurationMs());
         mSupportedRelativePaths = verifySupportedRelativePaths(StringUtils.getStringArrayConfig(
                         mContext, R.array.config_supported_transcoding_relative_paths));
-        mHasHdrPlugin = hasHDRPlugin();
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        mHasHdrPlugin = executor.submit(() -> { return hasHDRPlugin(); });
+        executor.shutdown();
 
         parseTranscodeCompatManifest();
         // The storage namespace is a boot namespace so we actually don't expect this to be changed
@@ -310,7 +317,6 @@ public class TranscodeHelperImpl implements TranscodeHelper {
         } finally {
             if (decoder != null) {
                 try {
-                    decoder.stop();
                     decoder.release();
                 } catch (Exception e) {
                     Log.w(TAG, "Unable to stop decoder", e);
@@ -321,6 +327,15 @@ public class TranscodeHelperImpl implements TranscodeHelper {
         return hasPlugin;
     }
 
+    private boolean getHasHdrPlugin() {
+        try {
+            return mHasHdrPlugin.get(1, TimeUnit.SECONDS);
+        } catch (InterruptedException | ExecutionException | TimeoutException e) {
+            Log.w(TAG, "Unable to get HDR plugin status", e);
+            return false;
+        }
+    }
+
     /**
      * Regex that matches path of transcode file. The regex only
      * matches emulated volume, for files in other volumes we don't
@@ -815,7 +830,7 @@ public class TranscodeHelperImpl implements TranscodeHelper {
             // the original file regardless whether the app supports HEVC due to not all the devices
             // support transcoding 10bit HEVC to 8bit AVC. This check needs to be removed when
             // devices add support for it.
-            boolean isTranscodeUnsupported = isHdr10Plus && !mHasHdrPlugin;
+            boolean isTranscodeUnsupported = isHdr10Plus && !getHasHdrPlugin();
             if (isTranscodeUnsupported) {
                 return Pair.create(0, 0L);
             }
@@ -1529,7 +1544,7 @@ public class TranscodeHelperImpl implements TranscodeHelper {
             writer.println("mAppCompatMediaCapabilities=" + mAppCompatMediaCapabilities);
             writer.println("mStorageTranscodingSessions=" + mStorageTranscodingSessions);
             writer.println("mSupportedTranscodingRelativePaths=" + mSupportedRelativePaths);
-            writer.println("mHasHdrPlugin=" + mHasHdrPlugin);
+            writer.println("mHasHdrPlugin=" + getHasHdrPlugin());
             dumpFinishedSessions(writer);
         }
     }
diff --git a/src/com/android/providers/media/backupandrestore/BackupAndRestoreUtils.java b/src/com/android/providers/media/backupandrestore/BackupAndRestoreUtils.java
index 4ad086784..c162c8c06 100644
--- a/src/com/android/providers/media/backupandrestore/BackupAndRestoreUtils.java
+++ b/src/com/android/providers/media/backupandrestore/BackupAndRestoreUtils.java
@@ -16,10 +16,21 @@
 
 package com.android.providers.media.backupandrestore;
 
+import static com.android.providers.media.flags.Flags.enableBackupAndRestore;
+
+import android.annotation.NonNull;
+import android.content.Context;
+import android.content.pm.PackageManager;
 import android.provider.MediaStore;
+import android.util.Log;
+
+import com.android.modules.utils.build.SdkLevel;
+import com.android.providers.media.util.FileUtils;
 
 import com.google.common.collect.HashBiMap;
 
+import java.io.File;
+
 /**
  * Class containing common constants and methods for backup and restore.
  */
@@ -55,6 +66,11 @@ public final class BackupAndRestoreUtils {
      */
     static final String RESTORE_COMPLETED = "RESTORE_COMPLETED";
 
+    /**
+     * TAG to be used for logging purposes
+     */
+    static final String TAG = BackupAndRestoreUtils.class.getSimpleName();
+
     /**
      * Array of columns backed up for restore in the future.
      */
@@ -156,4 +172,117 @@ public final class BackupAndRestoreUtils {
         // Adding number gap to allow addition of new values
         sIdToColumnBiMap.put("80", MediaStore.MediaColumns.XMP);
     }
+
+    /**
+     * Checks whether backup and restore operations are supported and enabled on the current device.
+     *
+     * <p>This method verifies that the required backup and restore flag is enabled, SDK version is
+     * S+ and ensures the device hardware is suitable for these operations. Backup and restore are
+     * supported only on mobile phones and tablets, excluding devices like automotive systems, TVs,
+     * PCs, and smartwatches.</p>
+     *
+     * @param context the application {@link Context}, used to access system resources.
+     * @return {@code true} if backup and restore is enabled and supported on the device,
+     *         {@code false} otherwise.
+     */
+    static boolean isBackupAndRestoreSupported(Context context) {
+        if (!enableBackupAndRestore() || !SdkLevel.isAtLeastS()) {
+            return false;
+        }
+
+        if (context == null || context.getPackageManager() == null) {
+            return false;
+        }
+
+        final PackageManager pm = context.getPackageManager();
+        return !pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)
+                && !pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION)
+                && !pm.hasSystemFeature(PackageManager.FEATURE_PC)
+                && !pm.hasSystemFeature(PackageManager.FEATURE_WATCH);
+    }
+
+    /**
+     * Deletes the restore directory and unsets shared preference.
+     *
+     * <p>
+     * This method is triggered during idle maintenance after a media scan.
+     * During the scan, restored values are read and metadata is updated.
+     * Once the scan is complete, the restore directory is no longer needed and is deleted.
+     * The shared preference is unset to indicate that no recent restoration has occurred.
+     * </p>
+     *
+     * @param context The context to check shared preference and delete the restore directory
+     */
+    public static void doCleanUpAfterRestoreIfRequired(Context context) {
+        if (isBackupAndRestoreSupported(context) && isRestoringFromRecentBackup(context)) {
+            try {
+                deleteRestoreDirectory(context);
+            } catch (Exception e) {
+                Log.e(TAG, "Failed to delete restore directory", e);
+            }
+            disableRestoreFromRecentBackup(context);
+        }
+    }
+
+    /**
+     * Indicates that the values should be read from the recent backup. Sets shared preference's
+     * value to true.
+     *
+     * @param context The context used to access shared preferences.
+     */
+    static void enableRestoreFromRecentBackup(@NonNull Context context) {
+        context.getSharedPreferences(SHARED_PREFERENCE_NAME,
+                Context.MODE_PRIVATE).edit().putBoolean(RESTORE_COMPLETED, true).apply();
+    }
+
+    /**
+     * Indicates that values shouldn't be read from backup. Sets shared preference value to false.
+     *
+     * @param context The context used to access shared preferences.
+     */
+    static void disableRestoreFromRecentBackup(@NonNull Context context) {
+        context.getSharedPreferences(SHARED_PREFERENCE_NAME,
+                Context.MODE_PRIVATE).edit().putBoolean(RESTORE_COMPLETED, false).apply();
+    }
+
+    /**
+     * Checks if the shared preference is set, indicating a recent restore operation.
+     *
+     * @param context The application context used to access shared preferences.
+     * @return {@code true} if a restore operation was recently completed, {@code false} otherwise.
+     */
+    static boolean isRestoringFromRecentBackup(@NonNull Context context) {
+        return context.getSharedPreferences(SHARED_PREFERENCE_NAME,
+                Context.MODE_PRIVATE).getBoolean(RESTORE_COMPLETED, false);
+    }
+
+    /**
+     * Deletes the backup directory if it exists.
+     *
+     * @param context The application context used to locate and delete the backup directory.
+     */
+    static void deleteBackupDirectory(@NonNull Context context) {
+        File filesDir = context.getFilesDir();
+        File backupDir = new File(filesDir, BACKUP_DIRECTORY_NAME);
+
+        if (backupDir.exists() && backupDir.isDirectory()) {
+            FileUtils.deleteContents(backupDir);
+            backupDir.delete();
+        }
+    }
+
+    /**
+     * Deletes the restore directory if it exists.
+     *
+     * @param context The application context used to locate and delete the restore directory.
+     */
+    static void deleteRestoreDirectory(@NonNull Context context) {
+        File filesDir = context.getFilesDir();
+        File restoreDir = new File(filesDir, RESTORE_DIRECTORY_NAME);
+
+        if (restoreDir.exists() && restoreDir.isDirectory()) {
+            FileUtils.deleteContents(restoreDir);
+            restoreDir.delete();
+        }
+    }
 }
diff --git a/src/com/android/providers/media/backupandrestore/BackupExecutor.java b/src/com/android/providers/media/backupandrestore/BackupExecutor.java
index 55b731020..118ddd88f 100644
--- a/src/com/android/providers/media/backupandrestore/BackupExecutor.java
+++ b/src/com/android/providers/media/backupandrestore/BackupExecutor.java
@@ -22,6 +22,7 @@ import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.BACKUP_DIRECTORY_NAME;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.FIELD_SEPARATOR;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.KEY_VALUE_SEPARATOR;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isBackupAndRestoreSupported;
 import static com.android.providers.media.util.Logging.TAG;
 
 import android.annotation.SuppressLint;
@@ -32,7 +33,6 @@ import android.provider.MediaStore.Files.FileColumns;
 import android.provider.MediaStore.MediaColumns;
 import android.util.Log;
 
-import com.android.modules.utils.build.SdkLevel;
 import com.android.providers.media.DatabaseHelper;
 import com.android.providers.media.leveldb.LevelDBEntry;
 import com.android.providers.media.leveldb.LevelDBInstance;
@@ -82,7 +82,6 @@ public final class BackupExecutor {
     public BackupExecutor(Context context, DatabaseHelper databaseHelper) {
         mContext = context;
         mExternalDatabaseHelper = databaseHelper;
-        mLevelDBInstance = LevelDBManager.getInstance(getBackupFilePath());
     }
 
     /**
@@ -92,10 +91,14 @@ public final class BackupExecutor {
      * 3. Updates the new backed up generation number
      */
     public void doBackup(CancellationSignal signal) {
-        if (!SdkLevel.isAtLeastS()) {
+        if (!isBackupAndRestoreSupported(mContext)) {
             return;
         }
+        Log.v(TAG, "Backup is enabled");
 
+        if (mLevelDBInstance == null) {
+            mLevelDBInstance = LevelDBManager.getInstance(getBackupFilePath());
+        }
         final long lastBackedUpGenerationNumberFromLevelDb = getLastBackedUpGenerationNumber();
         final long currentDbGenerationNumber = mExternalDatabaseHelper.runWithoutTransaction(
                 DatabaseHelper::getGeneration);
@@ -269,7 +272,7 @@ public final class BackupExecutor {
      * Removes entry for given file path from Backup.
      */
     public void deleteBackupForPath(String path) {
-        if (path != null) {
+        if (isBackupAndRestoreSupported(mContext) && path != null && mLevelDBInstance != null) {
             mLevelDBInstance.delete(path);
         }
     }
diff --git a/src/com/android/providers/media/backupandrestore/MediaBackupAgent.java b/src/com/android/providers/media/backupandrestore/MediaBackupAgent.java
new file mode 100644
index 000000000..6fa98220e
--- /dev/null
+++ b/src/com/android/providers/media/backupandrestore/MediaBackupAgent.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.backupandrestore;
+
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.BACKUP_DIRECTORY_NAME;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.RESTORE_DIRECTORY_NAME;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.deleteBackupDirectory;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.deleteRestoreDirectory;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.enableRestoreFromRecentBackup;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isBackupAndRestoreSupported;
+
+import android.annotation.NonNull;
+import android.app.backup.BackupAgent;
+import android.app.backup.BackupDataInput;
+import android.app.backup.BackupDataOutput;
+import android.app.backup.FullBackupDataOutput;
+import android.content.ContentProviderClient;
+import android.content.Context;
+import android.os.ParcelFileDescriptor;
+import android.provider.MediaStore;
+import android.util.Log;
+
+import com.android.providers.media.MediaProvider;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.util.stream.Stream;
+
+/**
+ * This custom BackupAgent is used for backing up and restoring MediaProvider's metadata.
+ * <p>
+ * It implements {@link BackupAgent#onFullBackup} and {@link BackupAgent#onRestoreFinished}
+ * to handle pre-processing tasks before the backup is initiated and post-processing tasks after
+ * the restore is completed, respectively.
+ * </p>
+ */
+public final class MediaBackupAgent extends BackupAgent {
+
+    private static final String TAG = MediaBackupAgent.class.getSimpleName();
+
+    @Override
+    public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
+            ParcelFileDescriptor newState) throws IOException {
+    }
+
+    @Override
+    public void onRestore(BackupDataInput data, int appVersionCode, ParcelFileDescriptor newState)
+            throws IOException {
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>
+     *     Checks if media provider's backup and restore is supported for the device. If supported,
+     *     triggers a backup
+     * </p>
+     */
+    @Override
+    public void onFullBackup(FullBackupDataOutput data) throws IOException {
+        if ((data.getTransportFlags() & FLAG_DEVICE_TO_DEVICE_TRANSFER) == 0) {
+            Log.v(TAG, "Skip cloud backup for media provider");
+            return;
+        }
+
+        Context context = getApplicationContext();
+        if (isBackupAndRestoreSupported(context)) {
+            try (ContentProviderClient cpc = context.getContentResolver()
+                    .acquireContentProviderClient(MediaStore.AUTHORITY)) {
+                final MediaProvider provider = ((MediaProvider) cpc.getLocalContentProvider());
+                provider.triggerBackup();
+            } catch (Exception e) {
+                Log.e(TAG, "Failed to trigger backup", e);
+            }
+        }
+
+        super.onFullBackup(data);
+    }
+
+    /**
+     * This method is called on the target device as a part of restore process after files transfer
+     * is completed and before the first media scan is triggered by restore apk. Checks if media
+     * provider's backup and restore is supported for the device. If supported,
+     *  1. Copies over files from backup directory to restore directory & deletes backup directory
+     *  2. Sets shared preference to true
+     */
+    @Override
+    public void onRestoreFinished() {
+        super.onRestoreFinished();
+
+        Context context = getApplicationContext();
+        if (isBackupAndRestoreSupported(context)) {
+            // The backed-up data from the source device will be read from the restore directory,
+            // while the device will create its own backup directory.
+            copyContentsFromBackupToRestoreDirectory(context);
+
+            // Delete the copied over backup directory
+            deleteBackupDirectory(context);
+
+            // Indicates restore is completed and metadata can be read from restore directory
+            enableRestoreFromRecentBackup(context);
+        }
+    }
+
+    /**
+     * Copies the contents of the backup directory to the restore directory.
+     *
+     * @param context The application context, used to retrieve the files directory.
+     */
+    private static void copyContentsFromBackupToRestoreDirectory(@NonNull Context context) {
+        deleteRestoreDirectory(context);
+
+        File filesDir = context.getFilesDir();
+        File backupDir = new File(filesDir, BACKUP_DIRECTORY_NAME);
+        File restoreDir = new File(filesDir, RESTORE_DIRECTORY_NAME);
+
+        try {
+            if (backupDir.exists() && backupDir.isDirectory()) {
+                copyDirectory(backupDir.toPath(), restoreDir.toPath());
+            } else {
+                Log.e(TAG, "Backup directory does not exist.");
+            }
+        } catch (Exception ex) {
+            Log.e(TAG, "Failed to copy backup directory to restore directory", ex);
+        }
+    }
+
+    private static void copyDirectory(Path source, Path target) throws IOException {
+        try (Stream<Path> paths = Files.walk(source)) {
+            paths.forEach(path -> {
+                try {
+                    Path destination = target.resolve(source.relativize(path));
+                    if (Files.isDirectory(path)) {
+                        if (!Files.exists(destination)) {
+                            Files.createDirectories(destination);
+                        }
+                    } else {
+                        Files.copy(path, destination, StandardCopyOption.REPLACE_EXISTING);
+                    }
+                } catch (IOException e) {
+                    Log.e(TAG, "Failed to copy contents of backup "
+                            + "directory to restore directory", e);
+                }
+            });
+        }
+    }
+}
diff --git a/src/com/android/providers/media/backupandrestore/RestoreExecutor.java b/src/com/android/providers/media/backupandrestore/RestoreExecutor.java
index 93e8ef6fb..05db447ff 100644
--- a/src/com/android/providers/media/backupandrestore/RestoreExecutor.java
+++ b/src/com/android/providers/media/backupandrestore/RestoreExecutor.java
@@ -18,17 +18,15 @@ package com.android.providers.media.backupandrestore;
 
 import static android.provider.MediaStore.VOLUME_EXTERNAL_PRIMARY;
 
-import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.RESTORE_COMPLETED;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.FIELD_SEPARATOR;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.KEY_VALUE_SEPARATOR;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.RESTORE_DIRECTORY_NAME;
-import static com.android.providers.media.flags.Flags.enableBackupAndRestore;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isBackupAndRestoreSupported;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isRestoringFromRecentBackup;
 
 import android.content.ContentValues;
 import android.content.Context;
-import android.content.SharedPreferences;
 
-import com.android.modules.utils.build.SdkLevel;
 import com.android.providers.media.leveldb.LevelDBInstance;
 import com.android.providers.media.leveldb.LevelDBManager;
 import com.android.providers.media.leveldb.LevelDBResult;
@@ -50,7 +48,19 @@ public final class RestoreExecutor {
         mLevelDBInstance = levelDBInstance;
     }
 
-    public Optional<ContentValues> getMetadataForFileIfBackedUp(String filePath) {
+    /**
+     * Retrieves metadata for a file from leveldb if it is backed up.
+     *
+     * @param filePath The path of the file for which metadata is requested.
+     * @param context The context to check if backup and restore functionality is supported.
+     * @return An {@link Optional} containing the metadata as {@link ContentValues} if the file is
+     * backed up or {@link Optional#empty()} if backup is not supported or the file is not backed up
+     */
+    public Optional<ContentValues> getMetadataForFileIfBackedUp(String filePath, Context context) {
+        if (!isBackupAndRestoreSupported(context)) {
+            return Optional.empty();
+        }
+
         if (mLevelDBInstance == null) {
             return Optional.empty();
         }
@@ -73,14 +83,6 @@ public final class RestoreExecutor {
         return Optional.of(contentValues);
     }
 
-    private static boolean isRestoringFromRecentBackup(Context context) {
-        // Shared preference with key "RESTORE_COMPLETED" should be set to true for recovery to
-        // take place.
-        SharedPreferences sharedPreferences = context.getSharedPreferences(
-                BackupAndRestoreUtils.SHARED_PREFERENCE_NAME, Context.MODE_PRIVATE);
-        return sharedPreferences.getBoolean(RESTORE_COMPLETED, false);
-    }
-
     private Map<String, String> deSerialiseValueString(String valueString) {
         String[] values = valueString.split(FIELD_SEPARATOR);
         Map<String, String> map = new HashMap<>();
@@ -97,7 +99,7 @@ public final class RestoreExecutor {
     }
 
     public static Optional<RestoreExecutor> getRestoreExecutor(Context context) {
-        if (!enableBackupAndRestore() || !SdkLevel.isAtLeastS()) {
+        if (!isBackupAndRestoreSupported(context)) {
             return Optional.empty();
         }
 
diff --git a/src/com/android/providers/media/photopicker/PhotoPickerActivity.java b/src/com/android/providers/media/photopicker/PhotoPickerActivity.java
index af6f30331..2d74aa857 100644
--- a/src/com/android/providers/media/photopicker/PhotoPickerActivity.java
+++ b/src/com/android/providers/media/photopicker/PhotoPickerActivity.java
@@ -57,6 +57,7 @@ import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewGroup.MarginLayoutParams;
 import android.view.ViewOutlineProvider;
 import android.view.WindowInsetsController;
 import android.view.WindowManager;
@@ -64,12 +65,16 @@ import android.view.accessibility.AccessibilityManager;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import androidx.activity.EdgeToEdge;
 import androidx.annotation.ColorInt;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 import androidx.appcompat.app.AppCompatActivity;
 import androidx.appcompat.widget.Toolbar;
+import androidx.core.graphics.Insets;
+import androidx.core.view.ViewCompat;
+import androidx.core.view.WindowInsetsCompat;
 import androidx.fragment.app.FragmentManager;
 import androidx.lifecycle.LiveData;
 import androidx.lifecycle.MutableLiveData;
@@ -169,8 +174,7 @@ public class PhotoPickerActivity extends AppCompatActivity {
         // in the base theme will be copied.
         getTheme().applyStyle(R.style.PickerMaterialTheme, /* force */ false);
 
-        // TODO(b/309578419): Make this activity handle insets properly and then remove this.
-        getTheme().applyStyle(R.style.OptOutEdgeToEdgeEnforcement, /* force */ false);
+        EdgeToEdge.enable(this);
 
         super.onCreate(savedInstanceState);
 
@@ -179,6 +183,17 @@ public class PhotoPickerActivity extends AppCompatActivity {
         setSupportActionBar(mToolbar);
         getSupportActionBar().setDisplayHomeAsUpEnabled(true);
 
+        View photo_picker_base = findViewById(R.id.photo_picker_base);
+        ViewCompat.setOnApplyWindowInsetsListener(photo_picker_base, (v, windowInsets) -> {
+            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars());
+            MarginLayoutParams mlp = (MarginLayoutParams) v.getLayoutParams();
+            mlp.topMargin = insets.top;
+            mlp.bottomMargin = insets.bottom;
+            v.setLayoutParams(mlp);
+
+            return WindowInsetsCompat.CONSUMED;
+        });
+
         final int[] attrs = new int[]{R.attr.actionBarSize, R.attr.pickerTextColor};
         final TypedArray ta = obtainStyledAttributes(attrs);
         // Save toolbar height so that we can use it as padding for FragmentContainerView
diff --git a/src/com/android/providers/media/photopicker/PhotoPickerSettingsActivity.java b/src/com/android/providers/media/photopicker/PhotoPickerSettingsActivity.java
index 122bfd99d..2818f3154 100644
--- a/src/com/android/providers/media/photopicker/PhotoPickerSettingsActivity.java
+++ b/src/com/android/providers/media/photopicker/PhotoPickerSettingsActivity.java
@@ -32,10 +32,13 @@ import android.os.Bundle;
 import android.os.UserManager;
 import android.util.Log;
 import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup.MarginLayoutParams;
 
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.appcompat.widget.Toolbar;
+import androidx.activity.EdgeToEdge;
+import androidx.core.graphics.Insets;
+import androidx.core.view.ViewCompat;
+import androidx.core.view.WindowInsetsCompat;
 import androidx.fragment.app.Fragment;
 import androidx.fragment.app.FragmentManager;
 import androidx.lifecycle.ViewModelProvider;
@@ -48,6 +51,7 @@ import com.android.providers.media.photopicker.data.model.UserId;
 import com.android.providers.media.photopicker.ui.settings.SettingsProfileSelectFragment;
 import com.android.providers.media.photopicker.ui.settings.SettingsViewModel;
 import com.android.providers.media.photopicker.util.RecentsPreviewUtil;
+import com.android.settingslib.collapsingtoolbar.CollapsingToolbarAppCompatActivity;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -56,7 +60,7 @@ import java.util.List;
 /**
  * Photo Picker settings page where user can view/edit current cloud media provider.
  */
-public class PhotoPickerSettingsActivity extends AppCompatActivity {
+public class PhotoPickerSettingsActivity extends CollapsingToolbarAppCompatActivity {
     private static final String TAG = "PickerSettings";
     static final String EXTRA_CURRENT_USER_ID = "user_id";
     private static final int DEFAULT_EXTRA_USER_ID = -1;
@@ -88,8 +92,7 @@ public class PhotoPickerSettingsActivity extends AppCompatActivity {
         // in the base theme will be copied.
         getTheme().applyStyle(R.style.PickerMaterialTheme, /* force */ false);
 
-        // TODO(b/309578419): Make this activity handle insets properly and then remove this.
-        getTheme().applyStyle(R.style.OptOutEdgeToEdgeEnforcement, /* force */ false);
+        EdgeToEdge.enable(this);
 
         super.onCreate(savedInstanceState);
 
@@ -102,10 +105,21 @@ public class PhotoPickerSettingsActivity extends AppCompatActivity {
             mCallingUserId = DEFAULT_EXTRA_USER_ID;
         }
 
+        setTitle(R.string.picker_settings_title);
         setContentView(R.layout.activity_photo_picker_settings);
-        displayActionBar();
         createAndShowFragment(mCallingUserId, /* allowReplace= */ false);
 
+        View settingsView = findViewById(R.id.settings_activity_root);
+        ViewCompat.setOnApplyWindowInsetsListener(settingsView, (v, windowInsets) -> {
+            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars());
+            MarginLayoutParams mlp = (MarginLayoutParams) v.getLayoutParams();
+            mlp.topMargin = insets.top;
+            mlp.bottomMargin = insets.bottom;
+            v.setLayoutParams(mlp);
+
+            return WindowInsetsCompat.CONSUMED;
+        });
+
         updateRecentsVisibilitySetting();
 
         // TODO: merge with CrossProfile listeners in the main Photo picker activity.
@@ -138,14 +152,6 @@ public class PhotoPickerSettingsActivity extends AppCompatActivity {
                 mSettingsViewModel.getUserManagerState(), this);
     }
 
-    private void displayActionBar() {
-        final Toolbar toolbar = findViewById(R.id.picker_settings_toolbar);
-        setSupportActionBar(toolbar);
-        final ActionBar actionBar = getSupportActionBar();
-        actionBar.setDisplayHomeAsUpEnabled(true);
-        actionBar.setDisplayShowTitleEnabled(false);
-    }
-
     @Override
     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
         if (item.getItemId() == android.R.id.home) {
diff --git a/src/com/android/providers/media/photopicker/PickerSyncController.java b/src/com/android/providers/media/photopicker/PickerSyncController.java
index d90e1c1fa..b29d52896 100644
--- a/src/com/android/providers/media/photopicker/PickerSyncController.java
+++ b/src/com/android/providers/media/photopicker/PickerSyncController.java
@@ -1331,7 +1331,7 @@ public class PickerSyncController {
     /**
      * Commit the latest media collection info when a sync operation is completed.
      */
-    private boolean cacheMediaCollectionInfo(@Nullable String authority, boolean isLocal,
+    public boolean cacheMediaCollectionInfo(@Nullable String authority, boolean isLocal,
             @Nullable Bundle bundle) throws UnableToAcquireLockException {
         if (authority == null) {
             Log.d(TAG, "Ignoring cache media info for null authority with bundle: " + bundle);
@@ -1469,6 +1469,38 @@ public class PickerSyncController {
         return bundle;
     }
 
+    /**
+     * Checks if full sync is pending for the given CMP.
+     *
+     * @param authority Authority of the CMP that uniquely identifies it.
+     * @param isLocal true of the authority belongs to the local provider, else false.
+     * @return true if full sync is pending for the CMP, else false.
+     * @throws RequestObsoleteException if the input authority is different than the authority of
+     * the current cloud provider.
+     */
+    public boolean isFullSyncPending(@NonNull String authority, boolean isLocal)
+            throws RequestObsoleteException {
+        final ProviderCollectionInfo latestCollectionInfo = isLocal
+                ? getLocalProviderLatestCollectionInfo()
+                : getCloudProviderLatestCollectionInfo();
+
+        if (!authority.equals(latestCollectionInfo.getAuthority())) {
+            throw new RequestObsoleteException(
+                    "Authority has changed to " + latestCollectionInfo.getAuthority());
+        }
+
+        final Bundle cachedPreviousCollectionInfo = getCachedMediaCollectionInfo(isLocal);
+        final String cachedPreviousCollectionId =
+                cachedPreviousCollectionInfo.getString(MEDIA_COLLECTION_ID);
+        final long cachedPreviousGeneration =
+                cachedPreviousCollectionInfo.getLong(LAST_MEDIA_SYNC_GENERATION);
+
+        return isFullSyncRequired(
+                latestCollectionInfo.getCollectionId(),
+                cachedPreviousCollectionId,
+                cachedPreviousGeneration);
+    }
+
     @NonNull
     private SyncRequestParams getSyncRequestParams(@Nullable String authority,
             boolean isLocal) throws RequestObsoleteException, UnableToAcquireLockException {
@@ -1523,7 +1555,7 @@ public class PickerSyncController {
                         + "ID/Gen=" + latestCollectionId + "/" + latestGeneration);
             }
 
-            if (!Objects.equals(latestCollectionId, cachedCollectionId)) {
+            if (isFullSyncWithResetRequired(latestCollectionId, cachedCollectionId)) {
                 result = SyncRequestParams.forFullMediaWithReset(latestMediaCollectionInfo);
 
                 // Update collection info cache.
@@ -1535,7 +1567,8 @@ public class PickerSyncController {
                         new ProviderCollectionInfo(authority, latestCollectionId, latestAccountName,
                                 latestAccountConfigurationIntent);
                 updateLatestKnownCollectionInfoLocked(isLocal, latestCollectionInfo);
-            } else if (cachedGeneration == DEFAULT_GENERATION) {
+            } else if (isFullSyncWithoutResetRequired(
+                    latestCollectionId, cachedCollectionId, cachedGeneration)) {
                 result = SyncRequestParams.forFullMedia(latestMediaCollectionInfo);
             } else if (cachedGeneration == latestGeneration) {
                 result = SyncRequestParams.forNone();
@@ -1548,6 +1581,49 @@ public class PickerSyncController {
         return result;
     }
 
+    /**
+     * @param latestCollectionId The latest collection id of the CMP library.
+     * @param cachedCollectionId The last collection id Picker DB was synced with, either fully
+     *                           or partially.
+     * @param cachedGenerationId The last generation id Picker DB was synced with.
+     * @return true if a full sync is pending, else false.
+     */
+    private boolean isFullSyncRequired(
+            @Nullable String latestCollectionId,
+            @Nullable String cachedCollectionId,
+            long cachedGenerationId) {
+        return isFullSyncWithResetRequired(latestCollectionId, cachedCollectionId)
+                || isFullSyncWithoutResetRequired(latestCollectionId, cachedCollectionId,
+                cachedGenerationId);
+    }
+
+    /**
+     * @param latestCollectionId The latest collection id of the CMP library.
+     * @param cachedCollectionId The last collection id Picker DB was synced with, either fully
+     *                           or partially.
+     * @return true if a full sync with reset is pending, else false.
+     */
+    private boolean isFullSyncWithResetRequired(
+            @Nullable String latestCollectionId,
+            @Nullable String cachedCollectionId) {
+        return !Objects.equals(latestCollectionId, cachedCollectionId);
+    }
+
+    /**
+     * @param latestCollectionId The latest collection id of the CMP library.
+     * @param cachedCollectionId The last collection id Picker DB was synced with, either fully
+     *                           or partially.
+     * @param cachedGenerationId The last generation id Picker DB was synced with.
+     * @return true if a resumable full sync is pending, else false.
+     */
+    private boolean isFullSyncWithoutResetRequired(
+            @Nullable String latestCollectionId,
+            @Nullable String cachedCollectionId,
+            long cachedGenerationId) {
+        return Objects.equals(latestCollectionId, cachedCollectionId)
+                && cachedGenerationId == DEFAULT_GENERATION;
+    }
+
     private void updateLatestKnownCollectionInfoLocked(
             boolean isLocal,
             @Nullable ProviderCollectionInfo latestCollectionInfo) {
@@ -1558,7 +1634,16 @@ public class PickerSyncController {
         }
     }
 
-    private String getPrefsKey(boolean isLocal, String key) {
+    /**
+     * Generates a key for shared preferences by appending the specified key
+     * to the prefix corresponding to the local or cloud provider.
+     *
+     * @param isLocal {@code true} to use the local provider prefix,
+     * {@code false} to use the cloud provider prefix.
+     * @param key the specific key to append to the provider's prefix.
+     * @return a complete key to used to query shared preferences.
+     */
+    public static String getPrefsKey(boolean isLocal, String key) {
         return (isLocal ? PREFS_KEY_LOCAL_PREFIX : PREFS_KEY_CLOUD_PREFIX) + key;
     }
 
diff --git a/src/com/android/providers/media/photopicker/SearchState.java b/src/com/android/providers/media/photopicker/SearchState.java
index e6cbeabf3..9e41bb04c 100644
--- a/src/com/android/providers/media/photopicker/SearchState.java
+++ b/src/com/android/providers/media/photopicker/SearchState.java
@@ -23,6 +23,7 @@ import android.content.pm.PackageManager;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.android.modules.utils.build.SdkLevel;
 import com.android.providers.media.ConfigStore;
@@ -45,9 +46,13 @@ public class SearchState {
      */
     public boolean isCloudSearchEnabled(
             @NonNull Context context,
-            @NonNull String cloudAuthority) {
+            @Nullable String cloudAuthority) {
         requireNonNull(context);
-        requireNonNull(cloudAuthority);
+
+        if (cloudAuthority == null) {
+            Log.d(TAG, "Cloud authority received is null. Cloud search is disabled");
+            return false;
+        }
 
         if (!isSearchFeatureEnabled(context)) {
             Log.d(TAG, "Search feature is disabled on the device.");
@@ -111,7 +116,7 @@ public class SearchState {
         }
 
         if (!Flags.enablePhotopickerSearch()) {
-            Log.d(TAG, "Search feature is disabled.");
+            Log.d(TAG, "Search feature flag is disabled.");
             return false;
         }
 
diff --git a/src/com/android/providers/media/photopicker/data/ExternalDbFacade.java b/src/com/android/providers/media/photopicker/data/ExternalDbFacade.java
index c4361ba61..9d75256d5 100644
--- a/src/com/android/providers/media/photopicker/data/ExternalDbFacade.java
+++ b/src/com/android/providers/media/photopicker/data/ExternalDbFacade.java
@@ -95,6 +95,9 @@ public class ExternalDbFacade {
         MediaColumns.WIDTH + " AS " + CloudMediaProviderContract.MediaColumns.WIDTH,
         MediaColumns.HEIGHT + " AS " + CloudMediaProviderContract.MediaColumns.HEIGHT,
         MediaColumns.ORIENTATION + " AS " + CloudMediaProviderContract.MediaColumns.ORIENTATION,
+        MediaColumns.OWNER_PACKAGE_NAME + " AS "
+                + CloudMediaProviderContract.MediaColumns.OWNER_PACKAGE_NAME,
+        FileColumns._USER_ID + " AS " + CloudMediaProviderContract.MediaColumns.USER_ID,
     };
     private static final String[] PROJECTION_MEDIA_INFO = new String[] {
         "MAX(" + MediaColumns.GENERATION_MODIFIED + ") AS "
diff --git a/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java b/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java
index fb70e7135..4997d199e 100644
--- a/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java
+++ b/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java
@@ -16,6 +16,10 @@
 
 package com.android.providers.media.photopicker.data;
 
+import static android.provider.CloudMediaProviderContract.MediaCollectionInfo.MEDIA_COLLECTION_ID;
+
+import static com.android.providers.media.photopicker.PickerSyncController.PICKER_SYNC_PREFS_FILE_NAME;
+import static com.android.providers.media.photopicker.PickerSyncController.getPrefsKey;
 import static com.android.providers.media.util.MimeUtils.getExtensionFromMimeType;
 
 import android.content.Context;
@@ -47,10 +51,13 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
     public static final int VERSION_INTRODUCING_MEDIA_GRANTS_TABLE = 12;
     @VisibleForTesting
     public static final int VERSION_INTRODUCING_DE_SELECTIONS_TABLE = 13;
-    public static final int VERSION_INTRODUCING_SEARCH_TABLES = 14;
     public static final int VERSION_INTRODUCING_CATEGORY_TABLES = 15;
     public static final int VERSION_INTRODUCING_SEARCH_SUGGESTION_TABLES = 16;
-    public static final int VERSION_LATEST = VERSION_INTRODUCING_SEARCH_SUGGESTION_TABLES;
+    public static final int VERSION_UPDATING_SEARCH_TABLES = 17;
+    private static final int VERSION_INTRODUCING_OWNED_PHOTOS = 18;
+    private static final int VERSION_ADDING_UNIQUE_CONSTRAINT_TO_MEDIA_IN_MEDIA_SETS_TABLE = 19;
+    public static final int VERSION_LATEST =
+            VERSION_ADDING_UNIQUE_CONSTRAINT_TO_MEDIA_IN_MEDIA_SETS_TABLE;
 
     final Context mContext;
     final String mName;
@@ -98,11 +105,6 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
             // de_selection table did not exist.
             createDeselectionTable(db);
         }
-        if (oldV < VERSION_INTRODUCING_SEARCH_TABLES) {
-            // Create picker search tables if the database does not already contain it.
-            createSearchRequestTable(db);
-            createSearchResultMediaTable(db);
-        }
         if (oldV < VERSION_INTRODUCING_CATEGORY_TABLES) {
             createMediaSetsTable(db);
             createMediaInMediaSetsTable(db);
@@ -112,6 +114,26 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
             createSearchSuggestionsTable(db);
             createSearchHistoryTable(db);
         }
+        if (oldV < VERSION_UPDATING_SEARCH_TABLES) {
+            // Create picker search tables if the database does not already contain the
+            // latest version of it.
+            createSearchRequestTable(db);
+            createSearchResultMediaTable(db);
+        }
+        if (oldV < VERSION_INTRODUCING_OWNED_PHOTOS) {
+            db.execSQL("ALTER TABLE media ADD COLUMN owner_package_name TEXT DEFAULT NULL");
+            db.execSQL("ALTER TABLE media ADD COLUMN _user_id INTEGER");
+
+            db.execSQL(
+                    "ALTER TABLE album_media ADD COLUMN owner_package_name TEXT DEFAULT NULL");
+            db.execSQL("ALTER TABLE album_media ADD COLUMN _user_id INTEGER");
+
+            mContext.getSharedPreferences(PICKER_SYNC_PREFS_FILE_NAME, Context.MODE_PRIVATE)
+                    .edit().remove(getPrefsKey(true, MEDIA_COLLECTION_ID)).apply();
+        }
+        if (oldV < VERSION_ADDING_UNIQUE_CONSTRAINT_TO_MEDIA_IN_MEDIA_SETS_TABLE) {
+            createMediaInMediaSetsTable(db);
+        }
     }
 
     @Override
@@ -172,6 +194,8 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
                 + "mime_type TEXT NOT NULL,"
                 + "standard_mime_type_extension INTEGER,"
                 + "is_favorite INTEGER,"
+                + "_user_id INTEGER,"
+                + "owner_package_name TEXT DEFAULT NULL,"
                 + "CHECK(local_id IS NOT NULL OR cloud_id IS NOT NULL),"
                 + "UNIQUE(local_id, is_visible))");
 
@@ -185,6 +209,8 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
                 + "duration_ms INTEGER CHECK(duration_ms >= 0),"
                 + "mime_type TEXT NOT NULL,"
                 + "standard_mime_type_extension INTEGER,"
+                + "_user_id INTEGER,"
+                + "owner_package_name TEXT DEFAULT NULL,"
                 + "CHECK((local_id IS NULL AND cloud_id IS NOT NULL) "
                 + "OR (local_id IS NOT NULL AND cloud_id IS NULL)),"
                 + "UNIQUE(local_id,  album_id),"
@@ -238,15 +264,32 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
         // a placeholder value will be used instead of null so that the unique constraint gets
         // applied to all search requests saved in the table.
         db.execSQL("CREATE TABLE search_request"
+                // Unique identifier of the search request.
                 + "(_id INTEGER PRIMARY KEY AUTOINCREMENT,"
-                + "sync_resume_key TEXT,"
+                // Resume key saved for the local sync. This will be NULL initially when the request
+                // has been created but the sync has not started.
+                + "local_sync_resume_key TEXT,"
+                // Source authority of the local sync resume key.
+                + "local_authority TEXT,"
+                // Resume key saved for the cloud sync. This will be NULL initially when the request
+                // has been created but the sync has not started.
+                + "cloud_sync_resume_key TEXT,"
+                // Source authority of the cloud sync resume key.
+                + "cloud_authority TEXT,"
+                // MIME types applied to the session.
                 + "mime_types TEXT NOT NULL,"
+                // Search text either entered by the user, or equal to the display text of a
+                // search suggestion.
                 + "search_text TEXT NOT NULL,"
+                // Media Set ID of the search suggestion. In case the search request was not made
+                // by selecting a search suggestion, this will be an empty string.
                 + "media_set_id TEXT NOT NULL,"
+                // Type of the search suggestion.
                 + "suggestion_type TEXT NOT NULL,"
-                + "authority TEXT NOT NULL,"
-                + "CHECK(search_text IS NOT NULL OR media_set_id IS NOT NULL),"
-                + "UNIQUE(mime_types, search_text, media_set_id, suggestion_type, authority))");
+                // Source authority of the search suggestion.
+                + "suggestion_authority TEXT NOT NULL,"
+                + "UNIQUE(mime_types, search_text, media_set_id, "
+                + "suggestion_type, suggestion_authority))");
     }
 
     /**
@@ -300,7 +343,9 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
                 + "cloud_id TEXT,"
                 + "local_id TEXT,"
                 + "media_set_picker_id INTEGER,"
-                + "CHECK(local_id IS NOT NULL OR cloud_id IS NOT NULL))");
+                + "CHECK(local_id IS NOT NULL OR cloud_id IS NOT NULL),"
+                + "UNIQUE(media_set_picker_id, local_id),"
+                + "UNIQUE(media_set_picker_id, cloud_id))");
     }
 
     /**
diff --git a/src/com/android/providers/media/photopicker/data/PickerDbFacade.java b/src/com/android/providers/media/photopicker/data/PickerDbFacade.java
index fbb32ef42..3145ab73b 100644
--- a/src/com/android/providers/media/photopicker/data/PickerDbFacade.java
+++ b/src/com/android/providers/media/photopicker/data/PickerDbFacade.java
@@ -35,6 +35,7 @@ import android.content.ContentUris;
 import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
+import android.database.DatabaseUtils;
 import android.database.MatrixCursor;
 import android.database.MergeCursor;
 import android.database.sqlite.SQLiteConstraintException;
@@ -58,6 +59,7 @@ import com.android.providers.media.photopicker.sync.CloseableReentrantLock;
 import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
 import com.android.providers.media.photopicker.sync.SyncTrackerRegistry;
 import com.android.providers.media.photopicker.util.exceptions.UnableToAcquireLockException;
+import com.android.providers.media.photopicker.v2.PickerDataLayerV2;
 import com.android.providers.media.photopicker.v2.PickerNotificationSender;
 import com.android.providers.media.util.MimeUtils;
 
@@ -74,7 +76,7 @@ import java.util.Objects;
 public class PickerDbFacade {
     private static final String VIDEO_MIME_TYPES = "video/%";
     private final Context mContext;
-    private final SQLiteDatabase mDatabase;
+    private final PickerDatabaseHelper mPickerDatabaseHelper;
     private final PickerSyncLockManager mPickerSyncLockManager;
     private final String mLocalProvider;
     // This is the cloud provider the database is synced with. It can be set as null to disable
@@ -82,6 +84,7 @@ public class PickerDbFacade {
     @Nullable
     private String mCloudProvider;
 
+
     public PickerDbFacade(Context context, PickerSyncLockManager pickerSyncLockManager) {
         this(context, pickerSyncLockManager, PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY);
     }
@@ -97,7 +100,7 @@ public class PickerDbFacade {
             String localProvider, PickerDatabaseHelper dbHelper) {
         mContext = context;
         mLocalProvider = localProvider;
-        mDatabase = dbHelper.getWritableDatabase();
+        mPickerDatabaseHelper = dbHelper;
         mPickerSyncLockManager = pickerSyncLockManager;
     }
 
@@ -132,6 +135,8 @@ public class PickerDbFacade {
     public static final String KEY_WIDTH = "width";
     @VisibleForTesting
     public static final String KEY_ORIENTATION = "orientation";
+    public static final String KEY_OWNER_PACKAGE_NAME = "owner_package_name";
+    public static final String KEY_USER_ID = "_user_id";
     public static final String EXTRA_OWNER_PACKAGE_NAMES = "owner_package_names";
     public static final String EXTRA_PACKAGE_USER_ID = "package_user_id";
 
@@ -224,7 +229,10 @@ public class PickerDbFacade {
 
     /**
      * Sets the cloud provider to be returned after querying the picker db
-     * If null, cloud media will be excluded from all queries.
+     *
+     * Set cloud provider to null in case the CMP or collection id has changed and the cloud media
+     * results previously synced in the database should not be displayed on the UI.
+     *
      * This should not be used in picker sync paths because we should not wait on a lock
      * indefinitely during the picker sync process.
      * Use {@link this#setCloudProviderWithTimeout} instead.
@@ -235,14 +243,17 @@ public class PickerDbFacade {
             final String previousCloudProvider = mCloudProvider;
             mCloudProvider = authority;
             if (!Objects.equals(previousCloudProvider, mCloudProvider)) {
-                PickerNotificationSender.notifyAvailableProvidersChange(mContext);
+                onCloudProviderUpdate(mCloudProvider);
             }
         }
     }
 
     /**
      * Sets the cloud provider to be returned after querying the picker db
-     * If null, cloud media will be excluded from all queries.
+     *
+     * Set cloud provider to null in case the CMP or collection id has changed and the cloud media
+     * results previously synced in the database should not be displayed on the UI.
+     *
      * This should be used in picker sync paths because we should not wait on a lock
      * indefinitely during the picker sync process
      */
@@ -252,11 +263,24 @@ public class PickerDbFacade {
             final String previousCloudProvider = mCloudProvider;
             mCloudProvider = authority;
             if (!Objects.equals(previousCloudProvider, mCloudProvider)) {
-                PickerNotificationSender.notifyAvailableProvidersChange(mContext);
+                onCloudProviderUpdate(mCloudProvider);
             }
         }
     }
 
+    /**
+     * Notifies dependant systems that the cloud provider has changed.
+     */
+    public void onCloudProviderUpdate(String mCloudProvider) {
+        PickerNotificationSender.notifyAvailableProvidersChange(mContext);
+        // If cloud provider set is null, it means that the cloud queries have been disabled because
+        // a full sync is required (this is typically triggered by collection id change
+        // or CMP change). Notify PickerDataLayerV2 to handle this change.
+        if (mCloudProvider == null) {
+            PickerDataLayerV2.handleCloudMediaReset(mContext);
+        }
+    }
+
     /**
      * Returns the cloud provider that will be returned after querying the picker db.
      * This should not be used in picker sync paths because we should not wait on a lock
@@ -278,21 +302,21 @@ public class PickerDbFacade {
      * db.
      */
     public DbWriteOperation beginAddMediaOperation(String authority) {
-        return new AddMediaOperation(mDatabase, isLocal(authority));
+        return new AddMediaOperation(getDatabase(), isLocal(authority));
     }
 
     /**
      * Returns {@link DbWriteOperation} that can be used to insert grants into the database.
      */
     public DbWriteOperation beginInsertGrantsOperation() {
-        return new InsertGrantsOperation(mDatabase, /* isLocal */ true);
+        return new InsertGrantsOperation(getDatabase(), /* isLocal */ true);
     }
 
     /**
      * Returns {@link DbWriteOperation} that can be used to clear all grants from the database.
      */
     public DbWriteOperation beginClearGrantsOperation(String[] packageNames, int userId) {
-        return new ClearGrantsOperation(mDatabase, /* isLocal */ true, packageNames, userId);
+        return new ClearGrantsOperation(getDatabase(), /* isLocal */ true, packageNames, userId);
     }
 
     /**
@@ -300,7 +324,7 @@ public class PickerDbFacade {
      * into the picker db.
      */
     public DbWriteOperation beginAddAlbumMediaOperation(String authority, String albumId) {
-        return new AddAlbumMediaOperation(mDatabase, isLocal(authority), albumId);
+        return new AddAlbumMediaOperation(getDatabase(), isLocal(authority), albumId);
     }
 
     /**
@@ -308,7 +332,7 @@ public class PickerDbFacade {
      * picker db.
      */
     public DbWriteOperation beginRemoveMediaOperation(String authority) {
-        return new RemoveMediaOperation(mDatabase, isLocal(authority));
+        return new RemoveMediaOperation(getDatabase(), isLocal(authority));
     }
 
     /**
@@ -318,7 +342,7 @@ public class PickerDbFacade {
      * @param authority to determine whether local or cloud media should be cleared
      */
     public DbWriteOperation beginResetMediaOperation(String authority) {
-        return new ResetMediaOperation(mDatabase, isLocal(authority));
+        return new ResetMediaOperation(getDatabase(), isLocal(authority));
     }
 
     /**
@@ -332,7 +356,7 @@ public class PickerDbFacade {
      * @param authority to determine whether local or cloud media should be cleared
      */
     public DbWriteOperation beginResetAlbumMediaOperation(String authority, String albumId) {
-        return new ResetAlbumOperation(mDatabase, isLocal(authority), albumId);
+        return new ResetAlbumOperation(getDatabase(), isLocal(authority), albumId);
     }
 
     /**
@@ -342,7 +366,7 @@ public class PickerDbFacade {
      * @param authority to determine whether local or cloud media should be updated
      */
     public UpdateMediaOperation beginUpdateMediaOperation(String authority) {
-        return new UpdateMediaOperation(mDatabase, isLocal(authority));
+        return new UpdateMediaOperation(getDatabase(), isLocal(authority));
     }
 
     /**
@@ -1144,11 +1168,31 @@ public class PickerDbFacade {
     }
 
     private Cursor queryMediaIdForAppsLocked(@NonNull SQLiteQueryBuilder qb,
-            @NonNull String[] projection, @NonNull String[] selectionArgs,
+            @NonNull String[] columns, @NonNull String[] selectionArgs,
             String pickerSegmentType) {
-        return qb.query(mDatabase, getMediaStoreProjectionLocked(projection, pickerSegmentType),
-                /* selection */ null, selectionArgs, /* groupBy */ null, /* having */ null,
-                /* orderBy */ null, /* limitStr */ null);
+        final Cursor cursor =
+                qb.query(getDatabase(), getMediaStoreProjectionLocked(columns, pickerSegmentType),
+                    /* selection */ null, selectionArgs, /* groupBy */ null, /* having */ null,
+                    /* orderBy */ null, /* limitStr */ null);
+
+        if (columns == null || columns.length == 0 || cursor.getColumnCount() == columns.length) {
+            return cursor;
+        } else {
+            // An unknown column was encountered. Populate it will null for backwards compatibility.
+            final MatrixCursor result = new MatrixCursor(columns);
+            if (cursor.moveToFirst()) {
+                do {
+                    final ContentValues contentValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(cursor, contentValues);
+                    final MatrixCursor.RowBuilder rowBuilder = result.newRow();
+                    for (String column : columns) {
+                        rowBuilder.add(column, contentValues.get(column));
+                    }
+                } while (cursor.moveToNext());
+            }
+            cursor.close();
+            return result;
+        }
     }
 
     /**
@@ -1174,9 +1218,9 @@ public class PickerDbFacade {
             }
             addMimeTypesToQueryBuilderAndSelectionArgs(qb, selectionArgs, query.mMimeTypes);
 
-            Cursor cursor = qb.query(mDatabase, getMergedAlbumProjection(), /* selection */ null,
-                    selectionArgs.toArray(new String[0]), /* groupBy */ null, /* having */ null,
-                    /* orderBy */ null, /* limit */ null);
+            Cursor cursor = qb.query(getDatabase(), getMergedAlbumProjection(),
+                    /* selection */ null, selectionArgs.toArray(new String[0]), /* groupBy */ null,
+                    /* having */ null, /* orderBy */ null, /* limit */ null);
 
             if (cursor == null || !cursor.moveToFirst()) {
                 continue;
@@ -1274,7 +1318,7 @@ public class PickerDbFacade {
 
     private Cursor queryMediaForUiLocked(SQLiteQueryBuilder qb, String[] selectionArgs,
             String orderBy, String limitStr) {
-        return qb.query(mDatabase, getCloudMediaProjectionLocked(), /* selection */ null,
+        return qb.query(getDatabase(), getCloudMediaProjectionLocked(), /* selection */ null,
                 selectionArgs, /* groupBy */ null, /* having */ null, orderBy, limitStr);
     }
 
@@ -1296,58 +1340,57 @@ public class PickerDbFacade {
             getProjectionSimple(KEY_MIME_TYPE, MediaColumns.MIME_TYPE),
             getProjectionSimple(KEY_STANDARD_MIME_TYPE_EXTENSION,
                     MediaColumns.STANDARD_MIME_TYPE_EXTENSION),
+            getProjectionSimple(KEY_OWNER_PACKAGE_NAME, MediaColumns.OWNER_PACKAGE_NAME),
+            getProjectionSimple(KEY_USER_ID, MediaColumns.USER_ID),
         };
     }
 
     private String[] getMediaStoreProjectionLocked(String[] columns, String pickerSegmentType) {
-        final String[] projection = new String[columns.length];
+        final List<String> projection = new ArrayList<>();
 
-        for (int i = 0; i < projection.length; i++) {
+        for (int i = 0; i < columns.length; i++) {
             switch (columns[i]) {
                 case PickerMediaColumns.DATA:
-                    projection[i] = getProjectionDataLocked(PickerMediaColumns.DATA,
-                            pickerSegmentType);
+                    projection.add(getProjectionDataLocked(PickerMediaColumns.DATA,
+                            pickerSegmentType));
                     break;
                 case PickerMediaColumns.DISPLAY_NAME:
-                    projection[i] =
-                            getProjectionSimple(
-                                    getDisplayNameSql(), PickerMediaColumns.DISPLAY_NAME);
+                    projection.add(getProjectionSimple(
+                            getDisplayNameSql(), PickerMediaColumns.DISPLAY_NAME));
                     break;
                 case PickerMediaColumns.MIME_TYPE:
-                    projection[i] =
-                            getProjectionSimple(KEY_MIME_TYPE, PickerMediaColumns.MIME_TYPE);
+                    projection.add(getProjectionSimple(
+                            KEY_MIME_TYPE, PickerMediaColumns.MIME_TYPE));
                     break;
                 case PickerMediaColumns.DATE_TAKEN:
-                    projection[i] =
-                            getProjectionSimple(KEY_DATE_TAKEN_MS, PickerMediaColumns.DATE_TAKEN);
+                    projection.add(getProjectionSimple(
+                            KEY_DATE_TAKEN_MS, PickerMediaColumns.DATE_TAKEN));
                     break;
                 case PickerMediaColumns.SIZE:
-                    projection[i] = getProjectionSimple(KEY_SIZE_BYTES, PickerMediaColumns.SIZE);
+                    projection.add(getProjectionSimple(KEY_SIZE_BYTES, PickerMediaColumns.SIZE));
                     break;
                 case PickerMediaColumns.DURATION_MILLIS:
-                    projection[i] =
-                            getProjectionSimple(
-                                    KEY_DURATION_MS, PickerMediaColumns.DURATION_MILLIS);
+                    projection.add(getProjectionSimple(
+                            KEY_DURATION_MS, PickerMediaColumns.DURATION_MILLIS));
                     break;
                 case PickerMediaColumns.HEIGHT:
-                    projection[i] = getProjectionSimple(KEY_HEIGHT, PickerMediaColumns.HEIGHT);
+                    projection.add(getProjectionSimple(KEY_HEIGHT, PickerMediaColumns.HEIGHT));
                     break;
                 case PickerMediaColumns.WIDTH:
-                    projection[i] = getProjectionSimple(KEY_WIDTH, PickerMediaColumns.WIDTH);
+                    projection.add(getProjectionSimple(KEY_WIDTH, PickerMediaColumns.WIDTH));
                     break;
                 case PickerMediaColumns.ORIENTATION:
-                    projection[i] =
-                            getProjectionSimple(KEY_ORIENTATION, PickerMediaColumns.ORIENTATION);
+                    projection.add(getProjectionSimple(
+                            KEY_ORIENTATION, PickerMediaColumns.ORIENTATION));
                     break;
                 default:
-                    projection[i] = getProjectionSimple("NULL", columns[i]);
                     // Ignore unsupported columns; we do not throw error here to support
-                    // backward compatibility
+                    // backward compatibility for ACTION_GET_CONTENT takeover.
                     Log.w(TAG, "Unexpected Picker column: " + columns[i]);
             }
         }
 
-        return projection;
+        return projection.toArray(new String[0]);
     }
 
     private String getProjectionAuthorityLocked() {
@@ -1465,6 +1508,12 @@ public class PickerDbFacade {
                         values.put(KEY_IS_FAVORITE, cursor.getInt(index));
                     }
                     break;
+                case MediaColumns.OWNER_PACKAGE_NAME:
+                    values.put(KEY_OWNER_PACKAGE_NAME, cursor.getString(index));
+                    break;
+                case MediaColumns.USER_ID:
+                    values.put(KEY_USER_ID, cursor.getInt(index));
+                    break;
 
                     /* The below columns are only included if this is not the album_media table
                      * (AlbumId is an empty string)
@@ -1909,6 +1958,6 @@ public class PickerDbFacade {
      * Returns the associated SQLiteDatabase instance.
      */
     public SQLiteDatabase getDatabase() {
-        return mDatabase;
+        return mPickerDatabaseHelper.getWritableDatabase();
     }
 }
diff --git a/src/com/android/providers/media/photopicker/data/UserManagerState.java b/src/com/android/providers/media/photopicker/data/UserManagerState.java
index 58b70e87e..8df364c3c 100644
--- a/src/com/android/providers/media/photopicker/data/UserManagerState.java
+++ b/src/com/android/providers/media/photopicker/data/UserManagerState.java
@@ -21,12 +21,11 @@ import static androidx.core.util.Preconditions.checkNotNull;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresApi;
-import android.app.ActivityManager;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.content.pm.UserProperties;
-import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.os.Handler;
@@ -44,6 +43,7 @@ import com.android.providers.media.photopicker.data.model.UserId;
 import com.android.providers.media.photopicker.ui.TabFragment;
 import com.android.providers.media.photopicker.util.CrossProfileUtils;
 
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -54,9 +54,7 @@ import java.util.Map;
  * Interface to query user ids {@link UserId}
  */
 public interface UserManagerState {
-    /**
-     * Whether there are more than 1 user profiles associated with the current user.
-     */
+    /** Whether there are more than 1 user profiles associated with the current user. */
     boolean isMultiUserProfiles();
 
     /**
@@ -73,9 +71,9 @@ public interface UserManagerState {
 
     /**
      * A Map of all the profiles with their cross profile allowed status from current user.
-     * key : userId of a profile
-     * Value : cross profile allowed status of a user profile corresponding to user id with
-     * current user .
+     *
+     * <p>key : userId of a profile Value : cross profile allowed status of a user profile
+     * corresponding to user id with current user .
      */
     @NonNull
     Map<UserId, Boolean> getCrossProfileAllowedStatusForAll();
@@ -86,16 +84,13 @@ public interface UserManagerState {
      */
     int getProfileCount();
 
-    /**
-     *
-     * A {@link MutableLiveData} to check if cross profile interaction allowed or not.
-     */
+    /** A {@link MutableLiveData} to check if cross profile interaction allowed or not. */
     @NonNull
     MutableLiveData<Map<UserId, Boolean>> getCrossProfileAllowed();
 
     /**
-     * A list of all user profile ids including current user that need to be shown
-     * separately in PhotoPicker
+     * A list of all user profile ids including current user that need to be shown separately in
+     * PhotoPicker
      */
     @NonNull
     List<UserId> getAllUserProfileIds();
@@ -105,38 +100,32 @@ public interface UserManagerState {
      */
     void updateProfileOffValuesAndPostCrossProfileStatus();
 
-    /**
-     * Updates on/off values of all the user profiles
-     */
+    /** Updates on/off values of all the user profiles */
     void updateProfileOffValues();
 
-    /**
-     * Waits for Media Provider of the user profile corresponding to userId to be available.
-     */
+    /** Waits for Media Provider of the user profile corresponding to userId to be available. */
     void waitForMediaProviderToBeAvailable(UserId userId);
 
     /**
-     * Get if it is allowed to access the otherUser profile from current user ( current user :
-     * the user profile that started the photo picker activity)
-     **/
+     * Get if it is allowed to access the otherUser profile from current user ( current user : the
+     * user profile that started the photo picker activity)
+     */
     @NonNull
     boolean isCrossProfileAllowedToUser(UserId otherUser);
 
-    /**
-     * A {@link MutableLiveData} to check if there are multiple user profiles or not
-     */
+    /** A {@link MutableLiveData} to check if there are multiple user profiles or not */
     @NonNull
     MutableLiveData<Boolean> getIsMultiUserProfiles();
 
     /**
-     * Resets the user ids. This is usually called as a result of receiving broadcast that
-     * any profile has been added or removed.
+     * Resets the user ids. This is usually called as a result of receiving broadcast that any
+     * profile has been added or removed.
      */
     void resetUserIds();
 
     /**
-     * Resets the user ids and set their cross profile values. This is usually called as a result
-     * of receiving broadcast that any profile has been added or removed.
+     * Resets the user ids and set their cross profile values. This is usually called as a result of
+     * receiving broadcast that any profile has been added or removed.
      */
     void resetUserIdsAndSetCrossProfileValues(Intent intent);
 
@@ -152,39 +141,31 @@ public interface UserManagerState {
     void setIntentAndCheckRestrictions(Intent intent);
 
     /**
-     * Whether cross profile access corresponding to the userID is blocked
-     * by admin for the current user.
+     * Whether cross profile access corresponding to the userID is blocked by admin for the current
+     * user.
      */
     boolean isBlockedByAdmin(UserId userId);
 
-    /**
-     * Whether profile corresponding to the userID is on or off.
-     */
+    /** Whether profile corresponding to the userID is on or off. */
     boolean isProfileOff(UserId userId);
 
-    /**
-     * A map of all user profile labels corresponding to all profile userIds
-     */
+    /** A map of all user profile labels corresponding to all profile userIds */
     Map<UserId, String> getProfileLabelsForAll();
 
     /**
      * Returns whether a user should be shown in the PhotoPicker depending on its quite mode status.
      *
-     * @return One of {@link UserProperties.SHOW_IN_QUIET_MODE_PAUSED},
-     *         {@link UserProperties.SHOW_IN_QUIET_MODE_HIDDEN}, or
-     *         {@link UserProperties.SHOW_IN_QUIET_MODE_DEFAULT} depending on whether the profile
-     *         should be shown in quiet mode or not.
+     * @return One of {@link UserProperties.SHOW_IN_QUIET_MODE_PAUSED}, {@link
+     *     UserProperties.SHOW_IN_QUIET_MODE_HIDDEN}, or {@link
+     *     UserProperties.SHOW_IN_QUIET_MODE_DEFAULT} depending on whether the profile should be
+     *     shown in quiet mode or not.
      */
     int getShowInQuietMode(UserId userId);
 
-    /**
-     * A map of all user profile Icon ids corresponding to all profile userIds
-     */
+    /** A map of all user profile Icon ids corresponding to all profile userIds */
     Map<UserId, Drawable> getProfileBadgeForAll();
 
-    /**
-     * Set a user as a current user profile
-     **/
+    /** Set a user as a current user profile */
     void setUserAsCurrentUserProfile(UserId userId);
 
     /**
@@ -193,8 +174,7 @@ public interface UserManagerState {
     boolean isUserSelectedAsCurrentUserProfile(UserId userId);
 
     /**
-     * Creates an implementation of {@link UserManagerState}.
-     * Todo(b/319067964): make this singleton
+     * Creates an implementation of {@link UserManagerState}. Todo(b/319067964): make this singleton
      */
     static UserManagerState create(Context context) {
         return new RuntimeUserManagerState(context);
@@ -212,37 +192,37 @@ public interface UserManagerState {
         private static final int SHOW_IN_QUIET_MODE_DEFAULT = -1;
 
         private final Context mContext;
-        // This is the user profile that started the photo picker activity. That's why it cannot
-        // change in a UserIdManager instance.
+        // This is the user profile that started the photo picker activity. That's why
+        // it cannot change in a UserIdManager instance.
         private final UserId mCurrentUser;
         private final Handler mHandler;
         private Map<UserId, Runnable> mIsProviderAvailableRunnableMap = new HashMap<>();
 
-        // This is the user profile selected in the photo picker. Photo picker will display media
-        // for this user. It could be different from mCurrentUser.
+        // This is the user profile selected in the photo picker. Photo picker will
+        // display media for this user. It could be different from mCurrentUser.
         private UserId mCurrentUserProfile = null;
 
-        // A map of user profile ids (Except current user) with a Boolean value that represents
-        // whether corresponding user profile is blocked by admin or not.
-        private Map<UserId , Boolean> mIsProfileBlockedByAdminMap = new HashMap<>();
+        // A map of user profile ids (Except current user) with a Boolean value that
+        // represents whether corresponding user profile is blocked by admin or not.
+        private Map<UserId, Boolean> mIsProfileBlockedByAdminMap = new HashMap<>();
 
-        // A map of user profile ids (Except current user) with a Boolean value that represents
-        // whether corresponding user profile is on or off.
-        private Map<UserId , Boolean> mProfileOffStatus = new HashMap<>();
+        // A map of user profile ids (Except current user) with a Boolean value that
+        // represents whether corresponding user profile is on or off.
+        private Map<UserId, Boolean> mProfileOffStatus = new HashMap<>();
         private final MutableLiveData<Boolean> mIsMultiUserProfiles = new MutableLiveData<>();
 
-        // A list of all user profile Ids present on the device that require a separate tab to show
-        // in PhotoPicker. It also includes currentUser/contextUser.
+        // A list of all user profile Ids present on the device that require a separate
+        // tab to show in PhotoPicker. It also includes currentUser/contextUser.
         private List<UserId> mUserProfileIds = new ArrayList<>();
         private UserManager mUserManager;
 
         /**
          * This live data will be posted every time when a user profile change occurs in the
-         * background such as turning on/off/adding/removing a user profile. The complete map
-         * will be reinitiated again in {@link #getCrossProfileAllowedStatusForAll()} and will
-         * be posted into the below mutable live data. This live data will be observed later in
-         * {@link TabFragment}.
-         **/
+         * background such as turning on/off/adding/removing a user profile. The complete map will
+         * be reinitiated again in {@link #getCrossProfileAllowedStatusForAll()} and will be posted
+         * into the below mutable live data. This live data will be observed later in {@link
+         * TabFragment}.
+         */
         private final MutableLiveData<Map<UserId, Boolean>> mCrossProfileAllowedStatus =
                 new MutableLiveData<>();
 
@@ -260,48 +240,40 @@ public interface UserManagerState {
             setUserIds();
         }
 
-        private UserId getSystemUser() {
-            return UserId.of(UserHandle.of(ActivityManager.getCurrentUser()));
-        }
-
         private void setUserIds() {
-            setUserIdsInternal();
-            mIsMultiUserProfiles.postValue(isMultiUserProfiles());
-        }
-
-        private void setUserIdsInternal() {
             mUserProfileIds.clear();
-            mUserProfileIds.add(getSystemUser());
-            if (mUserManager == null) {
-                Log.e(TAG, "Cannot obtain user manager");
-                return;
-            }
 
-            // Here there could be other profiles too , that we do not want to show  anywhere in
-            // photo picker at all.
-            final List<UserHandle> userProfiles = mUserManager.getUserProfiles();
-            if (SdkLevel.isAtLeastV()) {
-                for (UserHandle userHandle : userProfiles) {
-                    UserProperties userProperties = mUserManager.getUserProperties(userHandle);
-                    UserId userId = UserId.of(userHandle);
-
-                    // Check if we want to show this profile data in PhotoPicker or if it is
-                    // an owner profile itself.
-                    if (getSystemUser().getIdentifier() != userHandle.getIdentifier()
-                            && userProperties.getShowInSharingSurfaces()
-                            == userProperties.SHOW_IN_SHARING_SURFACES_SEPARATE) {
-                        mUserProfileIds.add(userId);
+            mUserProfileIds.add(mCurrentUser);
+             boolean currentUserIsManaged =
+                    mUserManager.isManagedProfile(mCurrentUser.getIdentifier());
+
+            for (UserHandle handle : mUserManager.getUserProfiles()) {
+
+                // For >= Android V, check if the profile wants to be shown
+                if (SdkLevel.isAtLeastV()) {
+
+                    UserProperties properties = mUserManager.getUserProperties(handle);
+                    if (properties.getShowInSharingSurfaces()
+                            != UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE) {
+                        continue;
                     }
-                }
-            } else {
-                // if sdk version is less than V, then maximum two profiles with separate tab could
-                // only be available
-                for (UserHandle userHandle : userProfiles) {
-                    if (mUserManager.isManagedProfile(userHandle.getIdentifier())) {
-                        mUserProfileIds.add(UserId.of(userHandle));
+                } else {
+                     // Only allow managed profiles + the parent user on lower than V.
+                    if (currentUserIsManaged
+                            && mUserManager.getProfileParent(mCurrentUser.getUserHandle())
+                                    == handle) {
+                        // Intentionally empty so that this profile gets added.
+                    } else if (!mUserManager.isManagedProfile(handle.getIdentifier())) {
+                        continue;
                     }
                 }
+
+                // Ensure the system user doesn't get added twice.
+                if (mUserProfileIds.contains(UserId.of(handle))) continue;
+                mUserProfileIds.add(UserId.of(handle));
             }
+
+            mIsMultiUserProfiles.postValue(isMultiUserProfiles());
         }
 
         @Override
@@ -311,7 +283,7 @@ public interface UserManagerState {
         }
 
         @Override
-        public  int getProfileCount() {
+        public int getProfileCount() {
             return mUserProfileIds.size();
         }
 
@@ -330,12 +302,162 @@ public interface UserManagerState {
             return crossProfileAllowedStatusForAll;
         }
 
+
+        /**
+         * External method that allows quick checking from the current user to a target user.
+         *
+         * Takes into account the On/Off state of the profile, as well as cross profile content
+         * sharing policies.
+         *
+         * @param targetUser the target of the access. Current User is the "from" user.
+         * @return If the target user currently is eligible for cross profile content sharing.
+         */
         @Override
-        public boolean isCrossProfileAllowedToUser(UserId otherUser) {
+        public boolean isCrossProfileAllowedToUser(UserId targetUser) {
             assertMainThread();
-            return !isProfileOff(otherUser) && !isBlockedByAdmin(otherUser);
+            return !isProfileOff(targetUser) && !isBlockedByAdmin(targetUser);
+        }
+
+        /**
+         * Determines if the provided UserIds support CrossProfile content sharing.
+         *
+         * <p>This method accepts a pair of user handles (from/to) and determines if CrossProfile
+         * access is permitted between those two profiles.
+         *
+         * <p>There are differences is on how the access is determined based on the platform SDK:
+         *
+         * <p>For Platform SDK < V:
+         *
+         * <p>A check for CrossProfileIntentForwarders in the origin (from) profile that target the
+         * destination (to) profile. If such a forwarder exists, then access is allowed, and denied
+         * otherwise.
+         *
+         * <p>For Platform SDK >= V:
+         *
+         * <p>The method now takes into account access delegation, which was first added in Android
+         * V.
+         *
+         * <p>For profiles that set the [CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT]
+         * property in its [UserProperties], its parent profile will be substituted in for its side
+         * of the check.
+         *
+         * <p>ex. For access checks between a Managed (from) and Private (to) profile, where: -
+         * Managed does not delegate to its parent - Private delegates to its parent
+         *
+         * <p>The following logic is performed: Managed -> parent(Private)
+         *
+         * <p>The same check in the other direction would yield: parent(Private) -> Managed
+         *
+         * <p>Note how the private profile is never actually used for either side of the check,
+         * since it is delegating its access check to the parent. And thus, if Managed can access
+         * the parent, it can also access the private.
+         *
+         * @param context Current context object, for switching user contexts.
+         * @param intent The current intent the Photopicker is running under.
+         * @param fromUser The Origin profile, where the user is coming from
+         * @param toUser The destination profile, where the user is attempting to go to.
+         * @return Whether CrossProfile content sharing is supported in this handle.
+         */
+        private boolean isCrossProfileAllowedToUser(
+                Context context, Intent intent, UserId fromUser, UserId toUser) {
+
+            // Early exit conditions, accessing self.
+            // NOTE: It is also possible to reach this state if this method is recursively checking
+            // from: parent(A) to:parent(B) where A and B are both children of the same parent.
+            if (fromUser.getIdentifier() == toUser.getIdentifier()) {
+                return true;
+            }
+
+            // Decide if we should use actual from or parent(from)
+            UserHandle currentFromUser =
+                    getProfileToCheckCrossProfileAccess(fromUser.getUserHandle());
+
+            // Decide if we should use actual to or parent(to)
+            UserHandle currentToUser = getProfileToCheckCrossProfileAccess(toUser.getUserHandle());
+
+            // When the from/to has changed from the original parameters, recursively restart the
+            // checks with the new from/to handles.
+            if (fromUser.getIdentifier() != currentFromUser.getIdentifier()
+                    || toUser.getIdentifier() != currentToUser.getIdentifier()) {
+                return isCrossProfileAllowedToUser(
+                        context, intent, UserId.of(currentFromUser), UserId.of(currentToUser));
+            }
+
+            return doesCrossProfileIntentForwarderExist(
+                    intent,
+                    mContext.getPackageManager(),
+                    fromUser.getUserHandle(),
+                    toUser.getUserHandle());
+        }
+
+        /**
+         * Checks the Intent to see if it can be resolved as a CrossProfileIntentForwarderActivity
+         * for the target user.
+         *
+         * @param intent The current intent the photopicker is running under.
+         * @param pm the PM which will be used for querying.
+         * @param fromUser the [UserHandle] of the origin user
+         * @param targetUserHandle the [UserHandle] of the target user
+         * @return Whether the current Intent Photopicker may be running under has a matching
+         *     CrossProfileIntentForwarderActivity
+         */
+        private boolean doesCrossProfileIntentForwarderExist(
+                Intent intent,
+                PackageManager pm,
+                UserHandle fromUser,
+                UserHandle targetUserHandle) {
+
+            // Clear out the component & package before attempting to match
+            Intent intentToCheck = (Intent) intent.clone();
+            intentToCheck.setComponent(null);
+            intentToCheck.setPackage(null);
+
+            for (ResolveInfo resolveInfo :
+                    pm.queryIntentActivitiesAsUser(
+                            intentToCheck, PackageManager.MATCH_DEFAULT_ONLY, fromUser)) {
+
+                // If the activity is a CrossProfileIntentForwardingActivity, inspect its
+                // targetUserId to see if it targets the user we are currently checking for.
+                if (resolveInfo.isCrossProfileIntentForwarderActivity()) {
+
+                    /*
+                     * IMPORTANT: This is a reflection based hack to ensure the profile is
+                     * actually the installer of the CrossProfileIntentForwardingActivity.
+                     *
+                     * ResolveInfo.targetUserId exists, but is a hidden API not available to
+                     * mainline modules, and no such API exists, so it is accessed via
+                     * reflection below. All exceptions are caught to protect against
+                     * reflection related issues such as:
+                     * NoSuchFieldException / IllegalAccessException / SecurityException.
+                     *
+                     * In the event of an exception, the code fails "closed" for the current
+                     * profile to avoid showing content that should not be visible.
+                     */
+                    try {
+                        Field targetUserIdField =
+                                resolveInfo.getClass().getDeclaredField("targetUserId");
+                        targetUserIdField.setAccessible(true);
+                        int targetUserId = (int) targetUserIdField.get(resolveInfo);
+
+                        if (targetUserId == targetUserHandle.getIdentifier()) {
+                            // Don't need to look further, exit the loop.
+                            return true;
+                        }
+
+                    } catch (NoSuchFieldException | IllegalAccessException | SecurityException ex) {
+                        // Couldn't check the targetUserId via reflection, so fail without
+                        // further iterations.
+                        Log.e(TAG, "Could not access targetUserId via reflection.", ex);
+                        return false;
+                    } catch (Exception ex) {
+                        Log.e(TAG, "Exception occurred during cross profile checks", ex);
+                    }
+                }
+            }
+            return false;
         }
 
+
         @Override
         public MutableLiveData<Boolean> getIsMultiUserProfiles() {
             return mIsMultiUserProfiles;
@@ -349,8 +471,7 @@ public interface UserManagerState {
 
         @Override
         public void resetUserIdsAndSetCrossProfileValues(Intent intent) {
-            assertMainThread();
-            setUserIdsInternal();
+            resetUserIds();
             setCrossProfileValues(intent);
             mIsMultiUserProfiles.postValue(isMultiUserProfiles());
         }
@@ -364,11 +485,11 @@ public interface UserManagerState {
         @Override
         public void setIntentAndCheckRestrictions(Intent intent) {
             assertMainThread();
-            // The below method should be called even if only one profile is present on the device
-            // because we want to have current profile off value and blocked by admin values in the
-            // corresponding maps
+            // The below method should be called even if only one profile is present on the
+            // device because we want to have current profile off value and blocked by admin
+            // values
+            // in the corresponding maps
             updateCrossProfileValues(intent);
-
         }
 
         @Override
@@ -431,13 +552,14 @@ public interface UserManagerState {
                 }
             }
         }
+
         @Override
         public void waitForMediaProviderToBeAvailable(UserId userId) {
             assertMainThread();
-            // Remove callbacks if any pre-available callbacks are present in the message queue for
-            // given user
+            // Remove callbacks if any pre-available callbacks are present in the message
+            // queue for given user
             stopWaitingForProviderToBeAvailableForUser(userId);
-            if (CrossProfileUtils.isMediaProviderAvailable(userId , mContext)) {
+            if (CrossProfileUtils.isMediaProviderAvailable(userId, mContext)) {
                 mProfileOffStatus.put(userId, false);
                 updateAndPostCrossProfileStatus();
                 return;
@@ -446,37 +568,49 @@ public interface UserManagerState {
         }
 
         private void waitForProviderToBeAvailable(UserId userId, int numOfTries) {
-            // The runnable should make sure to post update on the live data if it is changed.
-            Runnable runnable = () -> {
-                try {
-                    // We stop the recursive check when
-                    // 1. the provider is available
-                    // 2. the profile is in quiet mode, i.e. provider will not be available
-                    // 3. after maximum retries
-                    if (CrossProfileUtils.isMediaProviderAvailable(userId, mContext)) {
-                        mProfileOffStatus.put(userId, false);
-                        updateAndPostCrossProfileStatus();
-                        return;
-                    }
-
-                    if (CrossProfileUtils.isQuietModeEnabled(userId, mContext)) {
-                        return;
-                    }
-
-                    if (numOfTries <= PROVIDER_AVAILABILITY_MAX_RETRIES) {
-                        Log.d(TAG, "MediaProvider is not available. Retry after "
-                                + PROVIDER_AVAILABILITY_CHECK_DELAY);
-                        waitForProviderToBeAvailable(userId, numOfTries + 1);
-                        return;
-                    }
-
-                    Log.w(TAG, "Failed waiting for MediaProvider for user:" + userId
-                            + " to be available");
-                } catch (Exception e) {
-                    Log.e(TAG, "An error occurred in runnable while waiting for "
-                            + "MediaProvider for user:" + userId + " to be available", e);
-                }
-            };
+            // The runnable should make sure to post update on the live data if it is
+            // changed.
+            Runnable runnable =
+                    () -> {
+                        try {
+                            // We stop the recursive check when
+                            // 1. the provider is available
+                            // 2. the profile is in quiet mode, i.e. provider will not be available
+                            // 3. after maximum retries
+                            if (CrossProfileUtils.isMediaProviderAvailable(userId, mContext)) {
+                                mProfileOffStatus.put(userId, false);
+                                updateAndPostCrossProfileStatus();
+                                return;
+                            }
+
+                            if (CrossProfileUtils.isQuietModeEnabled(userId, mContext)) {
+                                return;
+                            }
+
+                            if (numOfTries <= PROVIDER_AVAILABILITY_MAX_RETRIES) {
+                                Log.d(
+                                        TAG,
+                                        "MediaProvider is not available. Retry after "
+                                                + PROVIDER_AVAILABILITY_CHECK_DELAY);
+                                waitForProviderToBeAvailable(userId, numOfTries + 1);
+                                return;
+                            }
+
+                            Log.w(
+                                    TAG,
+                                    "Failed waiting for MediaProvider for user:"
+                                            + userId
+                                            + " to be available");
+                        } catch (Exception e) {
+                            Log.e(
+                                    TAG,
+                                    "An error occurred in runnable while waiting for "
+                                            + "MediaProvider for user:"
+                                            + userId
+                                            + " to be available",
+                                    e);
+                        }
+                    };
             mIsProviderAvailableRunnableMap.put(userId, runnable);
             mHandler.postDelayed(runnable, PROVIDER_AVAILABILITY_CHECK_DELAY);
         }
@@ -515,6 +649,12 @@ public interface UserManagerState {
                     || !CrossProfileUtils.isMediaProviderAvailable(userId, mContext);
         }
 
+        /**
+         * Determines if the target UserHandle delegates its content sharing to its parent.
+         *
+         * @param userHandle The target handle to check delegation for.
+         * @return TRUE if V+ and the handle delegates to parent. False otherwise.
+         */
         private boolean isCrossProfileStrategyDelegatedToParent(UserHandle userHandle) {
             if (SdkLevel.isAtLeastV()) {
                 if (mUserManager == null) {
@@ -530,86 +670,59 @@ public interface UserManagerState {
             return false;
         }
 
+        /**
+         * Acquires the correct {@link UserHandle} which should be used for CrossProfile access
+         * checks.
+         *
+         * @param userHandle the origin handle.
+         * @return The UserHandle that should be used for cross profile access checks. In the event
+         *     the origin handle delegates its access, this may not be the same handle as the origin
+         *     handle.
+         */
         private UserHandle getProfileToCheckCrossProfileAccess(UserHandle userHandle) {
             if (mUserManager == null) {
                 Log.e(TAG, "Cannot obtain user manager");
                 return null;
             }
             return isCrossProfileStrategyDelegatedToParent(userHandle)
-                    ? mUserManager.getProfileParent(userHandle) : userHandle;
+                    ? mUserManager.getProfileParent(userHandle)
+                    : userHandle;
         }
 
-
         /**
-         * {@link #setBlockedByAdminValue(Intent)} Based on  assumption that the only profiles with
-         * {@link UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION} could be systemUser
-         * and managedUser(if available).
+         * Updates Cross Profile access for all UserProfiles in {@code mUserProfileIds}
+         *
+         * <p>This method looks at a variety of situations for each Profile and decides if the
+         * profile's content is accessible by the current process owner user id.
+         *
+         * <p>- UserProperties attributes for CrossProfileDelegation are checked first -
+         * CrossProfileIntentForwardingActivitys are resolved via the process owner's
+         * PackageManager, and are considered when evaluating cross profile to the target profile.
          *
-         * Todo(b/319567023):Refactor the below {@link #setBlockedByAdminValue(Intent)} to
-         * avoid assumptions mentioned above.
+         * <p>- In the event none of the above checks succeeds, the profile is considered to be
+         * inaccessible to the current process user, and is thus marked as "BlockedByAdmin".
+         *
+         * @param intent The intent Photopicker is currently running under, for
+         *     CrossProfileForwardActivity checking.
          */
         private void setBlockedByAdminValue(Intent intent) {
             if (intent == null) {
-                Log.e(TAG, "No intent specified to check if cross profile forwarding is"
-                        + " allowed.");
-                return;
-            }
-
-            // List of all user profile ids that context user cannot access
-            List<UserId> canNotForwardToUserProfiles = new ArrayList<>();
-
-            /*
-             * List of all user profile ids that have cross profile access among themselves.
-             * It contains parent user and child profiles with user property
-             * {@link UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT}
-             */
-            List<UserId> parentOrDelegatedFromParent = new ArrayList<>();
-
-            // Userprofile to check cross profile intentForwarderActivity for
-            UserHandle needToCheck = null;
-
-            if (mUserManager == null) {
-                Log.e(TAG, "Cannot obtain user manager");
+                Log.e(
+                        TAG,
+                        "No intent specified to check if cross profile forwarding is"
+                                + " allowed.");
                 return;
             }
 
-            for (UserId userId : mUserProfileIds) {
-                /*
-                 * All user profiles with user property
-                 * {@link UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT}
-                 * can access each other including its parent.
-                 */
-                if (userId.equals(getSystemUser())
-                        || isCrossProfileStrategyDelegatedToParent(userId.getUserHandle())) {
-                    parentOrDelegatedFromParent.add(userId);
-                } else {
-                    needToCheck = userId.getUserHandle();
-                }
-            }
-
-            // When context user is a managed user , then will replace needToCheck with its parent
-            // to check cross profile intentForwarderActivity for.
-            if (needToCheck != null && needToCheck.equals(mCurrentUser.getUserHandle())) {
-                needToCheck = mUserManager.getProfileParent(mCurrentUser.getUserHandle());
-            }
-
-            final PackageManager packageManager = mContext.getPackageManager();
-            if (needToCheck != null && !CrossProfileUtils.isIntentAllowedCrossProfileAccessFromUser(
-                    intent, packageManager,
-                    getProfileToCheckCrossProfileAccess(mCurrentUser.getUserHandle()))) {
-                if (parentOrDelegatedFromParent.contains(UserId.of(needToCheck))) {
-                    // if user profile cannot access its parent then all direct child profiles with
-                    // delegated from parent will also be inaccessible.
-                    canNotForwardToUserProfiles.addAll(parentOrDelegatedFromParent);
-                } else {
-                    canNotForwardToUserProfiles.add(UserId.of(needToCheck));
-                }
-            }
-
             mIsProfileBlockedByAdminMap.clear();
             for (UserId userId : mUserProfileIds) {
-                mIsProfileBlockedByAdminMap.put(userId,
-                        canNotForwardToUserProfiles.contains(userId));
+                mIsProfileBlockedByAdminMap.put(
+                        // Boolean inversion seems strange, but this map is the opposite of what was
+                        // calculated, (which are blocked, rather than which are accessible) so the
+                        // boolean needs to be inverted.
+                        userId,
+                        !isCrossProfileAllowedToUser(mContext, intent, UserId.CURRENT_USER, userId)
+                );
             }
         }
 
@@ -617,68 +730,79 @@ public interface UserManagerState {
         public Map<UserId, String> getProfileLabelsForAll() {
             assertMainThread();
             Map<UserId, String> profileLabels = new HashMap<>();
-            String personalTabLabel = mContext.getString(R.string.picker_personal_profile_label);
-            profileLabels.put(getSystemUser(), personalTabLabel);
-            if (SdkLevel.isAtLeastV()) {
-                for (UserId userId : mUserProfileIds) {
-                    UserHandle userHandle = userId.getUserHandle();
-                    if (userHandle.getIdentifier() != getSystemUser().getIdentifier()) {
-                        profileLabels.put(userId, getProfileLabel(userHandle));
-                    }
-                }
+            for (UserId userId : mUserProfileIds) {
+                UserHandle userHandle = userId.getUserHandle();
+                profileLabels.put(userId, getProfileLabel(userHandle));
             }
 
             return profileLabels;
         }
+
         private String getProfileLabel(UserHandle userHandle) {
             if (SdkLevel.isAtLeastV()) {
-                Context userContext = mContext.createContextAsUser(userHandle, 0 /* flags */);
                 try {
+                    Context userContext = mContext.createContextAsUser(userHandle, 0 /* flags */);
                     UserManager userManager = userContext.getSystemService(UserManager.class);
                     if (userManager == null) {
                         Log.e(TAG, "Cannot obtain user manager");
                         return null;
                     }
                     return userManager.getProfileLabel();
-                } catch (Resources.NotFoundException e) {
-                    //Todo(b/318530691): Handle the label for the profile that is not defined
-                    // already
+                } catch (IllegalStateException e) {
+                    Log.e(TAG, "could not create user context for user.", e);
+                } catch (Exception e) {
+                    Log.e(TAG, "Exception while fetching profile badge", e);
                 }
             }
-            return null;
+
+            // Fall back case if not V, or an error encountered above, return hard coded strings.
+            boolean isPrimaryProfile = mUserManager.getProfileParent(userHandle) == null;
+            boolean isManagedProfile = mUserManager.isManagedProfile(userHandle.getIdentifier());
+
+            int resId;
+            if (isPrimaryProfile) {
+                resId = R.string.photopicker_profile_primary_label;
+            } else if (isManagedProfile) {
+                resId = R.string.photopicker_profile_managed_label;
+            } else {
+                resId = R.string.photopicker_profile_unknown_label;
+            }
+
+            return mContext.getString(resId);
         }
 
         @Override
         public Map<UserId, Drawable> getProfileBadgeForAll() {
             assertMainThread();
             Map<UserId, Drawable> profileBadges = new HashMap<>();
-            profileBadges.put(getSystemUser(), mContext.getDrawable(R.drawable.ic_personal_mode));
-            if (SdkLevel.isAtLeastV()) {
-                for (UserId userId : mUserProfileIds) {
-                    UserHandle userHandle = userId.getUserHandle();
-                    if (userHandle.getIdentifier() != getSystemUser().getIdentifier()) {
-                        profileBadges.put(userId, getProfileBadge(userHandle));
-                    }
-                }
+            for (UserId userId : mUserProfileIds) {
+                profileBadges.put(userId, getProfileBadge(userId.getUserHandle()));
             }
             return profileBadges;
         }
 
         private Drawable getProfileBadge(UserHandle userHandle) {
             if (SdkLevel.isAtLeastV()) {
-                Context userContext = mContext.createContextAsUser(userHandle, 0 /* flags */);
                 try {
+                    Context userContext = mContext.createContextAsUser(userHandle, 0 /* flags */);
                     UserManager userManager = userContext.getSystemService(UserManager.class);
                     if (userManager == null) {
                         Log.e(TAG, "Cannot obtain user manager");
                         return null;
                     }
                     return userManager.getUserBadge();
-                } catch (Resources.NotFoundException e) {
-                    //Todo(b/318530691): Handle the icon for the profile that is not defined already
+                } catch (IllegalStateException e) {
+                    Log.e(TAG, "could not create user context for user.", e);
+                } catch (Exception e) {
+                    Log.e(TAG, "Exception while fetching profile badge", e);
                 }
             }
-            return null;
+
+            // Fall back case if not V, or an error encountered above, return hard coded icons.
+            boolean isManagedProfile = mUserManager.isManagedProfile(userHandle.getIdentifier());
+            int drawable =
+                    isManagedProfile ? R.drawable.ic_work_outline : R.drawable.ic_personal_mode;
+            return mContext.getDrawable(drawable);
         }
 
         @Override
@@ -707,6 +831,7 @@ public interface UserManagerState {
             assertMainThread();
             return mIsProfileBlockedByAdminMap.get(userId);
         }
+
         @Override
         public boolean isProfileOff(UserId userId) {
             assertMainThread();
@@ -716,10 +841,15 @@ public interface UserManagerState {
         private void assertMainThread() {
             if (Looper.getMainLooper().isCurrentThread()) return;
 
-            throw new IllegalStateException("UserManagerState methods are expected to be called"
-                    + "from main thread. " + (Looper.myLooper() == null ? "" : "Current thread "
-                    + Looper.myLooper().getThread() + ", Main thread "
-                    + Looper.getMainLooper().getThread()));
+            throw new IllegalStateException(
+                    "UserManagerState methods are expected to be called"
+                            + "from main thread. "
+                            + (Looper.myLooper() == null
+                                    ? ""
+                                    : "Current thread "
+                                            + Looper.myLooper().getThread()
+                                            + ", Main thread "
+                                            + Looper.getMainLooper().getThread()));
         }
     }
 }
diff --git a/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java b/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java
index 9cbeb7618..cf34c5949 100644
--- a/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java
+++ b/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java
@@ -29,6 +29,7 @@ import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.os.Bundle;
 import android.os.CancellationSignal;
+import android.os.OperationCanceledException;
 import android.provider.CloudMediaProviderContract;
 import android.util.Log;
 import android.util.Pair;
@@ -40,13 +41,16 @@ import androidx.work.ListenableWorker;
 import androidx.work.Worker;
 import androidx.work.WorkerParameters;
 
-import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.PhotopickerSyncHelper;
+import com.android.providers.media.photopicker.v2.PickerNotificationSender;
 import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsDatabaseUtil;
 import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
 
+import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
+import java.util.Set;
 
 /**
  * This is a {@link Worker} class responsible for syncing the media items of a media set with the
@@ -54,7 +58,7 @@ import java.util.Objects;
  */
 public class MediaInMediaSetsSyncWorker extends Worker {
 
-    private static final String TAG = "SearchSyncWorker";
+    private static final String TAG = "MediaSetsContentSyncWorker";
     private static final int SYNC_PAGE_COUNT = Integer.MAX_VALUE;
     private static final int PAGE_SIZE = 500;
     private static final int INVALID_SYNC_SOURCE = -1;
@@ -63,12 +67,15 @@ public class MediaInMediaSetsSyncWorker extends Worker {
     private final Context mContext;
     private final CancellationSignal mCancellationSignal;
     private final SQLiteDatabase mDatabase;
+    private boolean mMarkedSyncWorkAsComplete = false;
+    private final PhotopickerSyncHelper mPhotopickerSyncHelper;
 
     public MediaInMediaSetsSyncWorker(@NonNull Context context, @NonNull WorkerParameters params) {
         super(context, params);
         mContext = context;
         mCancellationSignal = new CancellationSignal();
-        mDatabase = getDatabase();
+        mPhotopickerSyncHelper = new PhotopickerSyncHelper();
+        mDatabase = mPhotopickerSyncHelper.getDatabase();
     }
 
     @NonNull
@@ -77,7 +84,8 @@ public class MediaInMediaSetsSyncWorker extends Worker {
         final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
                 /* defaultValue */ INVALID_SYNC_SOURCE);
         String mediaSetAuthority = getInputData().getString(SYNC_WORKER_INPUT_AUTHORITY);
-        String mediaSetPickerId = getInputData().getString(SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID);
+        Long mediaSetPickerId = getInputData().getLong(
+                SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, Long.MIN_VALUE);
         String mediaSetId = "";
 
         try {
@@ -96,8 +104,6 @@ public class MediaInMediaSetsSyncWorker extends Worker {
             Log.i(TAG, "Starting media in media sets sync from sync source " + syncSource
                     + " with mediaSetId " + mediaSetId);
 
-            checkIfWorkerHasStopped();
-
             checkValidityOfWorkerInputParams(
                     mediaSetId, syncSource, mediaSetPickerId, mediaSetAuthority);
 
@@ -110,11 +116,13 @@ public class MediaInMediaSetsSyncWorker extends Worker {
 
         } catch (RuntimeException | RequestObsoleteException e) {
             Log.e(TAG, "Could not complete media in media set sync from sync source "
-                    + " for mediaSetId " + mediaSetId);
+                    + " for mediaSetId " + mediaSetId, e);
             return ListenableWorker.Result.failure();
         } finally {
             // mark sync as complete
-            markMediaInMediaSetSyncAsComplete(syncSource, getId());
+            if (!mMarkedSyncWorkAsComplete) {
+                markMediaInMediaSetSyncAsComplete(syncSource, getId());
+            }
         }
     }
 
@@ -126,9 +134,9 @@ public class MediaInMediaSetsSyncWorker extends Worker {
      */
     private void syncMediaInMediaSet(
             int syncSource, @NonNull String mediaSetId,
-            @NonNull String mediaSetPickerId, @NonNull String mediaSetAuthority,
+            @NonNull Long mediaSetPickerId, @NonNull String mediaSetAuthority,
             @Nullable String[] mimeTypes)
-            throws RequestObsoleteException, IllegalArgumentException {
+            throws RequestObsoleteException, IllegalArgumentException, OperationCanceledException {
         final PickerSearchProviderClient searchClient =
                 PickerSearchProviderClient.create(mContext, mediaSetAuthority);
 
@@ -141,6 +149,11 @@ public class MediaInMediaSetsSyncWorker extends Worker {
             return;
         }
 
+        final Set<String> knownTokens = new HashSet<>();
+        if (resumePageToken != null) {
+            knownTokens.add(resumePageToken);
+        }
+
         try {
             for (int currentIteration = 0; currentIteration < SYNC_PAGE_COUNT; currentIteration++) {
                 checkIfWorkerHasStopped();
@@ -148,29 +161,58 @@ public class MediaInMediaSetsSyncWorker extends Worker {
 
                 try (Cursor mediaInMediaSetsCursor = fetchMediaInMediaSetFromCmp(
                         searchClient, mediaSetId, resumePageToken, mimeTypes)) {
+                    Log.d(TAG, "Fetching media set content for request id " + mediaSetPickerId
+                            + " and next page token " + resumePageToken);
+
                     // Cache the media items in this media set
                     List<ContentValues> mediaItemsToInsert =
                             MediaInMediaSetsDatabaseUtil.getMediaContentValuesFromCursor(
                                     mediaInMediaSetsCursor,
                                     mediaSetPickerId,
-                                    isAuthorityLocal(mediaSetAuthority)
+                                    mPhotopickerSyncHelper.isAuthorityLocal(mediaSetAuthority)
                             );
-                    MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+
+                    checkIfWorkerHasStopped();
+                    checkIfCurrentCloudProviderAuthorityHasChanged(mediaSetAuthority);
+                    int numberOfRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                             mDatabase, mediaItemsToInsert, mediaSetAuthority
                     );
                     resumePageToken = getResumePageToken(mediaInMediaSetsCursor.getExtras());
 
                     if (resumePageToken.equals(SYNC_COMPLETE_RESUME_KEY)) {
+                        Log.d(TAG, "Number of media set results pages synced: "
+                                + (currentIteration + 1));
                         break;
+                    } else if (knownTokens.contains(resumePageToken)) {
+                        Log.e(TAG, "Loop detected! CMP has sent the same page token twice: "
+                                + resumePageToken);
+                        break;
+                    }
+
+                    knownTokens.add(resumePageToken);
+
+                    // Mark sync as complete
+                    if (mMarkedSyncWorkAsComplete) {
+                        // Notify the UI that a change has been made in the DB
+                        if (numberOfRowsInserted > 0) {
+                            PickerNotificationSender
+                                    .notifyMediaSetContentChange(mContext, mediaSetId);
+                        }
+                    } else {
+                        markMediaInMediaSetSyncAsComplete(syncSource, getId());
+                        mMarkedSyncWorkAsComplete = true;
                     }
-                    // mark sync as complete
-                    markMediaInMediaSetSyncAsComplete(syncSource, getId());
                 }
             }
         } finally {
-            MediaSetsDatabaseUtil.updateMediaInMediaSetSyncResumeKey(
-                    mDatabase, mediaSetPickerId, resumePageToken
-            );
+            // Save progress in DB
+            // TODO(b/398221732): Resume syncs.
+            if (SYNC_COMPLETE_RESUME_KEY.equals(resumePageToken)) {
+                checkIfWorkerHasStopped();
+                MediaSetsDatabaseUtil.updateMediaInMediaSetSyncResumeKey(
+                        mDatabase, mediaSetPickerId, SYNC_COMPLETE_RESUME_KEY
+                );
+            }
         }
     }
 
@@ -184,7 +226,7 @@ public class MediaInMediaSetsSyncWorker extends Worker {
     private Cursor fetchMediaInMediaSetFromCmp(
             @NonNull PickerSearchProviderClient pickerSearchProviderClient,
             @NonNull String mediaSetId, @Nullable String resumePageToken,
-            @Nullable String[] mimeTypes) {
+            @Nullable String[] mimeTypes) throws OperationCanceledException {
         final Cursor cursor = pickerSearchProviderClient.fetchMediasInMediaSetFromCmp(
                 mediaSetId,
                 resumePageToken,
@@ -219,10 +261,11 @@ public class MediaInMediaSetsSyncWorker extends Worker {
 
     private void checkIfCurrentCloudProviderAuthorityHasChanged(@NonNull String authority)
             throws RequestObsoleteException {
-        if (isAuthorityLocal(authority)) {
+        if (mPhotopickerSyncHelper.isAuthorityLocal(authority)) {
             return;
         }
-        final String currentCloudAuthority = getCurrentCloudProviderAuthority();
+        final String currentCloudAuthority =
+                mPhotopickerSyncHelper.getCurrentCloudProviderAuthority();
         if (!authority.equals(currentCloudAuthority)) {
             throw new RequestObsoleteException("Cloud provider authority has changed."
                     + " Sync will not be continued."
@@ -233,7 +276,7 @@ public class MediaInMediaSetsSyncWorker extends Worker {
 
     private void checkValidityOfWorkerInputParams(
             @NonNull String mediaSetId, int syncSource,
-            @NonNull String mediaSetPickerId, @NonNull String mediaSetAuthority) {
+            @NonNull Long mediaSetPickerId, @NonNull String mediaSetAuthority) {
         Objects.requireNonNull(mediaSetId);
         if (mediaSetId.isEmpty()) {
             Log.e(TAG, "Received empty mediaSetId id to fetch media set items");
@@ -241,10 +284,6 @@ public class MediaInMediaSetsSyncWorker extends Worker {
         }
 
         Objects.requireNonNull(mediaSetPickerId);
-        if (mediaSetPickerId.isEmpty()) {
-            Log.e(TAG, "Received empty mediaSetPickerId id to fetch media set items");
-            throw new IllegalArgumentException("mediaSetPickerId was an empty string");
-        }
 
         // SyncSource should either be cloud or local in order to fetch media set items
         if (syncSource != SYNC_LOCAL_ONLY && syncSource != SYNC_CLOUD_ONLY) {
@@ -257,22 +296,4 @@ public class MediaInMediaSetsSyncWorker extends Worker {
             throw new IllegalArgumentException("mediaSetPickerId was an empty string");
         }
     }
-
-    private boolean isAuthorityLocal(@NonNull String authority) {
-        return getLocalProviderAuthority().equals(authority);
-    }
-
-    @Nullable
-    private String getLocalProviderAuthority() {
-        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
-    }
-
-    @Nullable
-    private String getCurrentCloudProviderAuthority() {
-        return PickerSyncController.getInstanceOrThrow().getCloudProvider();
-    }
-
-    private SQLiteDatabase getDatabase() {
-        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
-    }
 }
diff --git a/src/com/android/providers/media/photopicker/sync/MediaResetWorker.java b/src/com/android/providers/media/photopicker/sync/MediaResetWorker.java
index 1558b9f0e..9130ead85 100644
--- a/src/com/android/providers/media/photopicker/sync/MediaResetWorker.java
+++ b/src/com/android/providers/media/photopicker/sync/MediaResetWorker.java
@@ -46,7 +46,8 @@ import com.android.providers.media.photopicker.sync.PickerSyncManager.SyncResetT
 import com.android.providers.media.photopicker.util.exceptions.UnableToAcquireLockException;
 
 /**
- * This is a {@link Worker} class responsible for handling table reset operations in the picker
+ * This is a {@link Worker} class responsible for handling table reset operations for media and
+ * album_media tables in the picker
  * database.
  */
 public class MediaResetWorker extends Worker {
diff --git a/src/com/android/providers/media/photopicker/sync/MediaSetsResetWorker.java b/src/com/android/providers/media/photopicker/sync/MediaSetsResetWorker.java
new file mode 100644
index 000000000..e847bd505
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/sync/MediaSetsResetWorker.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_CATEGORY_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markMediaSetsSyncAsComplete;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.work.ListenableWorker;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
+
+import java.util.List;
+
+/**
+ * This worker is responsible for cleaning up the cached media sets or media sets content for the
+ * given categoryId
+ */
+public class MediaSetsResetWorker extends Worker {
+    private static final String TAG = "MediaSetsResetWorker";
+
+    public MediaSetsResetWorker(
+            @NonNull Context context, @NonNull WorkerParameters workerParameters) {
+        super(context, workerParameters);
+    }
+
+    @Override
+    public ListenableWorker.Result doWork() {
+
+        final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
+                /* defaultValue */ -1);
+        final String categoryId = getInputData().getString(SYNC_WORKER_INPUT_CATEGORY_ID);
+        final String authority = getInputData().getString(SYNC_WORKER_INPUT_AUTHORITY);
+
+        // Do not allow endless re-runs of this worker, if this isn't the original run,
+        // just fail and wait until the next scheduled run.
+        if (getRunAttemptCount() > 0) {
+            Log.w(TAG, "Worker retry was detected, ending this run in failure.");
+            return ListenableWorker.Result.failure();
+        }
+
+        boolean isMediaInMediaSetsCacheDeleted = clearMediaSetsContentCache(categoryId, authority);
+        boolean isMediaSetsCacheDeleted = clearMediaSetsCache(syncSource, categoryId, authority);
+
+        // Both the tables were cleared. Mark the worker's run as success
+        if (isMediaSetsCacheDeleted && isMediaInMediaSetsCacheDeleted) {
+            return ListenableWorker.Result.success();
+        }
+
+        return ListenableWorker.Result.failure();
+    }
+
+    private boolean clearMediaSetsCache(int syncSource,
+                                        @NonNull String categoryId,
+                                        @NonNull String authority) {
+
+        requireNonNull(categoryId);
+        requireNonNull(authority);
+
+        SQLiteDatabase database = getDatabase();
+
+        try {
+            checkIfWorkerHasStopped();
+
+            database.beginTransaction();
+
+            MediaSetsDatabaseUtil.clearMediaSetsCache(database, categoryId, authority);
+
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+                return true;
+            } else {
+                return false;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Could not clear media sets cache", e);
+            return false;
+        } finally {
+            // Ensure that the transaction ends and the DB lock is released.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+            markMediaSetsSyncAsComplete(syncSource, getId());
+        }
+    }
+
+    private boolean clearMediaSetsContentCache(
+            @NonNull String categoryId,
+            @NonNull String authority) {
+
+        requireNonNull(categoryId);
+        requireNonNull(authority);
+
+        SQLiteDatabase database = getDatabase();
+
+        try {
+            checkIfWorkerHasStopped();
+
+            database.beginTransaction();
+
+            List<String> mediaSetPickerIds = MediaSetsDatabaseUtil
+                    .getMediaSetPickerIdsForGivenCategoryId(database, categoryId, authority);
+            MediaInMediaSetsDatabaseUtil.clearMediaInMediaSetsCache(
+                    database, mediaSetPickerIds);
+
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+                return true;
+            } else {
+                return false;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Could not clear media sets content cache", e);
+            return false;
+        } finally {
+            // Ensure that the transaction ends and the DB lock is released.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    private void checkIfWorkerHasStopped() throws RequestObsoleteException {
+        if (isStopped()) {
+            throw new RequestObsoleteException("CategoriesResetWorker has stopped.");
+        }
+    }
+
+    @NonNull
+    private SQLiteDatabase getDatabase() {
+        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java b/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java
index a662a685c..f3a91d6d1 100644
--- a/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java
+++ b/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java
@@ -26,9 +26,9 @@ import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.m
 
 import android.content.Context;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
 import android.os.Bundle;
 import android.os.CancellationSignal;
+import android.os.OperationCanceledException;
 import android.provider.CloudMediaProviderContract;
 import android.util.Log;
 
@@ -38,13 +38,16 @@ import androidx.work.ListenableWorker;
 import androidx.work.Worker;
 import androidx.work.WorkerParameters;
 
-import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.PhotopickerSyncHelper;
+import com.android.providers.media.photopicker.v2.PickerNotificationSender;
 import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
 
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
+import java.util.Set;
 
 public class MediaSetsSyncWorker extends Worker {
 
@@ -55,17 +58,22 @@ public class MediaSetsSyncWorker extends Worker {
     private final int PAGE_SIZE = 500;
     private final Context mContext;
     private final CancellationSignal mCancellationSignal;
+    private boolean mMarkedSyncWorkAsComplete = false;
+    private final PhotopickerSyncHelper mPhotopickerSyncHelper;
+
 
     public MediaSetsSyncWorker(@NonNull Context context, @NonNull WorkerParameters parameters) {
         super(context, parameters);
 
         mContext = context;
         mCancellationSignal = new CancellationSignal();
+        mPhotopickerSyncHelper = new PhotopickerSyncHelper();
     }
 
     @NonNull
     @Override
     public ListenableWorker.Result doWork() {
+
         final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
                 /* defaultValue */ INVALID_SYNC_SOURCE);
         final String categoryId = getInputData().getString(SYNC_WORKER_INPUT_CATEGORY_ID);
@@ -91,7 +99,7 @@ public class MediaSetsSyncWorker extends Worker {
             return ListenableWorker.Result.success();
         } catch (RuntimeException | RequestObsoleteException e) {
             Log.e(TAG, "Could not complete media sets sync from "
-                            + syncSource + " with categoryId " + categoryId + " due to " + e);
+                            + syncSource + " with categoryId " + categoryId, e);
             return ListenableWorker.Result.failure();
         }
     }
@@ -118,12 +126,13 @@ public class MediaSetsSyncWorker extends Worker {
     private void syncMediaSets(
             int syncSource, @NonNull String categoryId,
             @NonNull String categoryAuthority, @Nullable String[] mimeTypes)
-            throws RequestObsoleteException, IllegalArgumentException {
+            throws RequestObsoleteException, IllegalArgumentException, OperationCanceledException {
 
         List<String> mimeTypesList = mimeTypes == null || mimeTypes.length == 0 ? null
                 : Arrays.asList(mimeTypes);
         final PickerSearchProviderClient searchClient =
                 PickerSearchProviderClient.create(mContext, categoryAuthority);
+        final Set<String> knownTokens = new HashSet<>();
         String nextPageToken = null;
 
         try {
@@ -135,18 +144,39 @@ public class MediaSetsSyncWorker extends Worker {
                         searchClient, categoryId, nextPageToken, mimeTypes, mCancellationSignal)) {
                     // Cache the retrieved media sets
                     int numberOfRowsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
-                            getDatabase(), mediaSetsCursor, categoryId,
+                            mPhotopickerSyncHelper.getDatabase(), mediaSetsCursor, categoryId,
                             categoryAuthority, mimeTypesList);
                     Log.i(TAG, "Cached " + numberOfRowsInserted + " media sets");
+
                     // Update the next page token
                     nextPageToken = getNextPageToken(mediaSetsCursor.getExtras());
                     if (nextPageToken.equals(SYNC_COMPLETE_KEY)) {
+                        Log.d(TAG, "Number of media set results pages synced: "
+                                + (currentIteration + 1));
+                        break;
+                    } else if (knownTokens.contains(nextPageToken)) {
+                        Log.e(TAG, "Loop detected! CMP has sent the same page token twice: "
+                                + nextPageToken);
                         break;
                     }
+                    knownTokens.add(nextPageToken);
+
+                    // Mark sync as complete
+                    if (mMarkedSyncWorkAsComplete) {
+                        // Notify the UI that a change has been made in the DB
+                        if (numberOfRowsInserted > 0) {
+                            PickerNotificationSender.notifyMediaSetsChange(mContext, categoryId);
+                        }
+                    } else {
+                        markMediaSetsSyncAsComplete(syncSource, getId());
+                        mMarkedSyncWorkAsComplete = true;
+                    }
                 }
             }
         } finally {
-            markMediaSetsSyncAsComplete(syncSource, getId());
+            if (!mMarkedSyncWorkAsComplete) {
+                markMediaSetsSyncAsComplete(syncSource, getId());
+            }
         }
     }
 
@@ -155,7 +185,7 @@ public class MediaSetsSyncWorker extends Worker {
             String categoryId,
             String nextPageToken,
             String[] mimeTypes,
-            CancellationSignal cancellationSignal) {
+            CancellationSignal cancellationSignal) throws OperationCanceledException {
         final Cursor cursor = client.fetchMediaSetsFromCmp(
                 categoryId, nextPageToken, PAGE_SIZE, mimeTypes, cancellationSignal);
 
@@ -165,6 +195,7 @@ public class MediaSetsSyncWorker extends Worker {
         return cursor;
     }
 
+    @NonNull
     private String getNextPageToken(Bundle extras) {
         if (extras == null
                 || extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN) == null) {
@@ -181,10 +212,11 @@ public class MediaSetsSyncWorker extends Worker {
 
     private void checkIfCurrentCloudProviderAuthorityHasChanged(@NonNull String authority)
             throws RequestObsoleteException {
-        if (isAuthorityLocal(authority)) {
+        if (mPhotopickerSyncHelper.isAuthorityLocal(authority)) {
             return;
         }
-        final String currentCloudAuthority = getCurrentCloudProviderAuthority();
+        final String currentCloudAuthority =
+                mPhotopickerSyncHelper.getCurrentCloudProviderAuthority();
         if (!authority.equals(currentCloudAuthority)) {
             throw new RequestObsoleteException("Cloud provider authority has changed."
                     + " Sync will not be continued."
@@ -192,22 +224,4 @@ public class MediaSetsSyncWorker extends Worker {
                     + " Cloud provider authority to sync with: " + authority);
         }
     }
-
-    private boolean isAuthorityLocal(@NonNull String authority) {
-        return getLocalProviderAuthority().equals(authority);
-    }
-
-    @Nullable
-    private String getLocalProviderAuthority() {
-        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
-    }
-
-    @Nullable
-    private String getCurrentCloudProviderAuthority() {
-        return PickerSyncController.getInstanceOrThrow().getCloudProvider();
-    }
-
-    private SQLiteDatabase getDatabase() {
-        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
-    }
 }
diff --git a/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java b/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java
index a51501634..4b1e8963b 100644
--- a/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java
+++ b/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java
@@ -27,6 +27,7 @@ import android.database.Cursor;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.CancellationSignal;
+import android.os.OperationCanceledException;
 import android.provider.CloudMediaProviderContract;
 import android.provider.CloudMediaProviderContract.SortOrder;
 import android.util.Log;
@@ -34,6 +35,8 @@ import android.util.Log;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
+import java.util.List;
+
 /**
  * A client class responsible for fetching search results from
  * cloud media provider and local search provider.
@@ -70,6 +73,7 @@ public class PickerSearchProviderClient {
             @Nullable String suggestedMediaSetId,
             @Nullable String searchText,
             @SortOrder int sortOrder,
+            @Nullable List<String> mimeTypes,
             int pageSize,
             @Nullable String resumePageToken,
             @Nullable CancellationSignal cancellationSignal) {
@@ -83,10 +87,26 @@ public class PickerSearchProviderClient {
         queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, pageSize);
         queryArgs.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, resumePageToken);
         queryArgs.putInt(CloudMediaProviderContract.EXTRA_SORT_ORDER, sortOrder);
+        if (mimeTypes != null) {
+            queryArgs.putStringArray(
+                    Intent.EXTRA_MIME_TYPES,
+                    mimeTypes.toArray(new String[mimeTypes.size()]));
+        }
 
-        return mContext.getContentResolver().query(
+        Log.d(TAG, "Search results query sent to CMP: " + queryArgs);
+
+        final Cursor cursor = mContext.getContentResolver().query(
                 getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_SEARCH_MEDIA),
-                null, queryArgs,  cancellationSignal);
+                null, queryArgs, null);
+
+        if (cursor == null) {
+            Log.d(TAG, "Search results response from the CMP is null.");
+
+        } else {
+            Log.d(TAG, "Search results received from the CMP: " + cursor.getCount()
+                    + " extras: " + cursor.getExtras());
+        }
+        return cursor;
     }
 
     /**
@@ -99,9 +119,21 @@ public class PickerSearchProviderClient {
         final Bundle queryArgs = new Bundle();
         queryArgs.putString(CloudMediaProviderContract.KEY_PREFIX_TEXT, requireNonNull(prefixText));
         queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, limit);
-        return mContext.getContentResolver().query(
+
+        Log.d(TAG, "Search suggestions query sent to CMP: " + queryArgs);
+
+        final Cursor cursor = mContext.getContentResolver().query(
                 getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_SEARCH_SUGGESTION),
-                null, queryArgs,  cancellationSignal);
+                null, queryArgs, null);
+
+        if (cursor == null) {
+            Log.d(TAG, "Search suggestions response from the CMP is null.");
+
+        } else {
+            Log.d(TAG, "Search suggestions received from the CMP: " + cursor.getCount()
+                    + " extras: " + cursor.getExtras());
+        }
+        return cursor;
     }
 
     /**
@@ -116,9 +148,21 @@ public class PickerSearchProviderClient {
             queryArgs = new Bundle();
         }
         queryArgs.putString(CloudMediaProviderContract.KEY_PARENT_CATEGORY_ID, parentCategoryId);
-        return mContext.getContentResolver().query(
+
+        Log.d(TAG, "Categories query sent to CMP: " + queryArgs);
+
+        final Cursor cursor = mContext.getContentResolver().query(
                 getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_MEDIA_CATEGORY),
                 null, queryArgs, cancellationSignal);
+
+        if (cursor == null) {
+            Log.d(TAG, "Categories response from the CMP is null.");
+
+        } else {
+            Log.d(TAG, "Categories received from the CMP: " + cursor.getCount()
+                    + " extras: " + cursor.getExtras());
+        }
+        return cursor;
     }
 
     /**
@@ -127,16 +171,29 @@ public class PickerSearchProviderClient {
     @Nullable
     public Cursor fetchMediaSetsFromCmp(
             @NonNull String mediaCategoryId, @Nullable String nextPageToken, int pageSize,
-            @Nullable String[] mimeTypes, @Nullable CancellationSignal cancellationSignal) {
+            @Nullable String[] mimeTypes, @Nullable CancellationSignal cancellationSignal)
+            throws OperationCanceledException {
         final Bundle queryArgs = new Bundle();
         queryArgs.putString(CloudMediaProviderContract.KEY_MEDIA_CATEGORY_ID,
                 requireNonNull(mediaCategoryId));
         queryArgs.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, nextPageToken);
         queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, pageSize);
         queryArgs.putStringArray(Intent.EXTRA_MIME_TYPES, mimeTypes);
-        return mContext.getContentResolver().query(
+
+        Log.d(TAG, "Media sets query sent to CMP: " + queryArgs);
+
+        final Cursor cursor = mContext.getContentResolver().query(
                 getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_MEDIA_SET),
-                null, queryArgs,  cancellationSignal);
+                null, queryArgs, cancellationSignal);
+
+        if (cursor == null) {
+            Log.d(TAG, "Media sets response from the CMP is null.");
+
+        } else {
+            Log.d(TAG, "Media sets received from the CMP: " + cursor.getCount()
+                    + " extras: " + cursor.getExtras());
+        }
+        return cursor;
     }
 
     /**
@@ -149,7 +206,7 @@ public class PickerSearchProviderClient {
             int pageSize,
             int sortOrder,
             @Nullable String[] mimeTypes,
-            @Nullable CancellationSignal cancellationSignal) {
+            @Nullable CancellationSignal cancellationSignal) throws OperationCanceledException {
         final Bundle queryArgs = new Bundle();
         queryArgs.putString(CloudMediaProviderContract.KEY_MEDIA_SET_ID,
                 requireNonNull(mediaSetId));
@@ -158,9 +215,20 @@ public class PickerSearchProviderClient {
         queryArgs.putInt(CloudMediaProviderContract.EXTRA_SORT_ORDER, sortOrder);
         queryArgs.putStringArray(Intent.EXTRA_MIME_TYPES, mimeTypes);
 
-        return mContext.getContentResolver().query(
+        Log.d(TAG, "Media set content query sent to CMP: " + queryArgs);
+
+        final Cursor cursor = mContext.getContentResolver().query(
                 getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_MEDIA_IN_MEDIA_SET),
-                null, queryArgs,  cancellationSignal);
+                null, queryArgs, cancellationSignal);
+
+        if (cursor == null) {
+            Log.d(TAG, "Media set contents response from the CMP is null.");
+
+        } else {
+            Log.d(TAG, "Media set contents received from the CMP: " + cursor.getCount()
+                    + " extras: " + cursor.getExtras());
+        }
+        return cursor;
     }
 
     private Uri getCloudUriFromPath(String uriPath) {
@@ -185,6 +253,7 @@ public class PickerSearchProviderClient {
             final CloudMediaProviderContract.Capabilities capabilities =
                     response.getParcelable(EXTRA_PROVIDER_CAPABILITIES);
             requireNonNull(capabilities);
+            Log.d(TAG, "Capabilities received from CMP: " + capabilities);
 
             return capabilities;
         } catch (RuntimeException e) {
diff --git a/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java b/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java
index a8f37ebb6..85cd059ac 100644
--- a/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java
+++ b/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java
@@ -17,10 +17,14 @@
 package com.android.providers.media.photopicker.sync;
 
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markAlbumMediaSyncAsComplete;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markAllMediaInMediaSetsSyncAsComplete;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markAllSearchResultsSyncAsComplete;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markMediaInMediaSetSyncAsComplete;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markMediaSetsSyncAsComplete;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markSearchResultsSyncAsComplete;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markSyncAsComplete;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewAlbumMediaSyncRequests;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewMediaInMediaSetSyncRequest;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewMediaSetsSyncRequest;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewSearchResultsSyncRequests;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewSyncRequests;
@@ -33,6 +37,7 @@ import android.util.Log;
 
 import androidx.annotation.IntDef;
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.work.Constraints;
 import androidx.work.Data;
 import androidx.work.ExistingPeriodicWorkPolicy;
@@ -41,22 +46,29 @@ import androidx.work.OneTimeWorkRequest;
 import androidx.work.Operation;
 import androidx.work.OutOfQuotaPolicy;
 import androidx.work.PeriodicWorkRequest;
+import androidx.work.WorkInfo;
 import androidx.work.WorkManager;
 import androidx.work.Worker;
 
 import com.android.modules.utils.BackgroundThread;
 import com.android.providers.media.ConfigStore;
+import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.data.PickerSyncRequestExtras;
+import com.android.providers.media.photopicker.v2.model.MediaInMediaSetSyncRequestParams;
 import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 
-import org.jetbrains.annotations.NotNull;
+import com.google.common.util.concurrent.ListenableFuture;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
+
 /**
  * This class manages all the triggers for Picker syncs.
  * <p></p>
@@ -87,6 +99,20 @@ public class PickerSyncManager {
     @Retention(RetentionPolicy.SOURCE)
     public @interface SyncResetType {}
 
+    /** Clears all search requests and search results from the database. */
+    public static final int SEARCH_RESULTS_FULL_CACHE_RESET = 1;
+    /** Clears search results and suggestions of the local or cloud provider from the database. */
+    public static final int SEARCH_PARTIAL_CACHE_RESET = 2;
+    /** Clears all expired history and cached suggestions from the database. */
+    public static final int EXPIRED_SUGGESTIONS_RESET = 3;
+
+    @IntDef(value = {
+            SEARCH_RESULTS_FULL_CACHE_RESET,
+            SEARCH_PARTIAL_CACHE_RESET,
+            EXPIRED_SUGGESTIONS_RESET})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface SearchCacheResetType {}
+
     static final String SYNC_WORKER_INPUT_AUTHORITY = "INPUT_AUTHORITY";
     static final String SYNC_WORKER_INPUT_SYNC_SOURCE = "INPUT_SYNC_TYPE";
     static final String SYNC_WORKER_INPUT_RESET_TYPE = "INPUT_RESET_TYPE";
@@ -99,6 +125,9 @@ public class PickerSyncManager {
     static final long PROACTIVE_SYNC_DELAY_MS = 1500;
     private static final int SYNC_MEDIA_PERIODIC_WORK_INTERVAL = 4; // Time unit is hours.
     private static final int RESET_ALBUM_MEDIA_PERIODIC_WORK_INTERVAL = 12; // Time unit is hours.
+    // Time unit is days.
+    private static final int RESET_SEARCH_SUGGESTIONS_PERIODIC_WORK_INTERVAL = 1;
+    static final int SEARCH_RESULTS_RESET_DELAY = 30; // Time unit is minutes.
 
     public static final String PERIODIC_SYNC_WORK_NAME;
     private static final String PROACTIVE_LOCAL_SYNC_WORK_NAME;
@@ -110,6 +139,10 @@ public class PickerSyncManager {
     public static final String IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME;
     public static final String IMMEDIATE_LOCAL_MEDIA_SETS_SYNC_WORK_NAME;
     public static final String IMMEDIATE_CLOUD_MEDIA_SETS_SYNC_WORK_NAME;
+    public static final String IMMEDIATE_LOCAL_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME;
+    public static final String IMMEDIATE_CLOUD_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME;
+    public static final String SEARCH_CACHE_RESET_WORK_NAME;
+    public static final String PERIODIC_SEARCH_SUGGESTIONS_RESET_WORK_NAME;
     public static final String PERIODIC_ALBUM_RESET_WORK_NAME;
     private static final String ENDLESS_WORK_NAME;
     public static final String IMMEDIATE_GRANTS_SYNC_WORK_NAME;
@@ -122,6 +155,7 @@ public class PickerSyncManager {
         final String syncImmediatePrefix = "SYNC_MEDIA_IMMEDIATE_";
         final String syncSearchResultsImmediatePrefix = "SYNC_SEARCH_RESULTS_IMMEDIATE_";
         final String syncMediaSetsImmediatePrefix = "SYNC_MEDIA_SETS_IMMEDIATE_";
+        final String syncMediaInMediaSetImmediatePrefix = "SYNC_MEDIA_IN_MEDIA_SET_IMMEDIATE";
         final String syncAllSuffix = "ALL";
         final String syncLocalSuffix = "LOCAL";
         final String syncCloudSuffix = "CLOUD";
@@ -136,9 +170,17 @@ public class PickerSyncManager {
         IMMEDIATE_CLOUD_SYNC_WORK_NAME = syncImmediatePrefix + syncCloudSuffix;
         IMMEDIATE_ALBUM_SYNC_WORK_NAME = "SYNC_ALBUM_MEDIA_IMMEDIATE";
         IMMEDIATE_LOCAL_SEARCH_SYNC_WORK_NAME = syncSearchResultsImmediatePrefix + syncLocalSuffix;
+        // Use this work name to schedule cloud search results sync and cloud search results
+        // reset both.
         IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME = syncSearchResultsImmediatePrefix + syncCloudSuffix;
         IMMEDIATE_LOCAL_MEDIA_SETS_SYNC_WORK_NAME = syncMediaSetsImmediatePrefix + syncLocalSuffix;
         IMMEDIATE_CLOUD_MEDIA_SETS_SYNC_WORK_NAME = syncMediaSetsImmediatePrefix + syncCloudSuffix;
+        IMMEDIATE_LOCAL_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME =
+                syncMediaInMediaSetImmediatePrefix + syncLocalSuffix;
+        IMMEDIATE_CLOUD_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME =
+                syncMediaInMediaSetImmediatePrefix + syncCloudSuffix;
+        SEARCH_CACHE_RESET_WORK_NAME = "SEARCH_CACHE_FULL_RESET";
+        PERIODIC_SEARCH_SUGGESTIONS_RESET_WORK_NAME = "RESET_SEARCH_SUGGESTIONS";
         ENDLESS_WORK_NAME = "ENDLESS_WORK";
         SHOULD_SYNC_GRANTS = "SHOULD_SYNC_GRANTS";
         EXTRA_MIME_TYPES = "mime_types";
@@ -197,17 +239,27 @@ public class PickerSyncManager {
      * the cloud photopicker experiment is currently enabled.
      */
     private void setUpPeriodicWork(@NonNull ConfigStore configStore) {
-        requireNonNull(configStore);
-
-        if (configStore.isCloudMediaInPhotoPickerEnabled()) {
-            PickerSyncNotificationHelper.createNotificationChannel(mContext);
-
-            schedulePeriodicSyncs();
-            schedulePeriodicAlbumReset();
-        } else {
-            // Disable any scheduled ongoing work if the feature is disabled.
-            mWorkManager.cancelUniqueWork(PERIODIC_SYNC_WORK_NAME);
-            mWorkManager.cancelUniqueWork(PERIODIC_ALBUM_RESET_WORK_NAME);
+        try {
+            requireNonNull(configStore);
+
+            if (configStore.isCloudMediaInPhotoPickerEnabled()) {
+                PickerSyncNotificationHelper.createNotificationChannel(mContext);
+
+                schedulePeriodicSyncs();
+                schedulePeriodicAlbumReset();
+            } else {
+                // Disable any scheduled ongoing work if the feature is disabled.
+                mWorkManager.cancelUniqueWork(PERIODIC_SYNC_WORK_NAME);
+                mWorkManager.cancelUniqueWork(PERIODIC_ALBUM_RESET_WORK_NAME);
+            }
+
+            if (Flags.enablePhotopickerSearch()) {
+                schedulePeriodicSearchSuggestionsReset();
+            } else {
+                mWorkManager.cancelUniqueWork(PERIODIC_SEARCH_SUGGESTIONS_RESET_WORK_NAME);
+            }
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not schedule periodic work", e);
         }
     }
 
@@ -462,32 +514,146 @@ public class PickerSyncManager {
                                 SYNC_WORKER_INPUT_AUTHORITY, authority,
                                 SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource,
                                 SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
-        final OneTimeWorkRequest syncRequest =
-                buildOneTimeWorkerRequest(SearchResultsSyncWorker.class, inputData);
-
-        // Track the new sync request
-        trackNewSearchResultsSyncRequests(syncSource, syncRequest.getId());
 
         final String workName = syncSource == SYNC_LOCAL_ONLY
                 ? IMMEDIATE_LOCAL_SEARCH_SYNC_WORK_NAME
                 : IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME;
-        // Enqueue local or cloud sync request
+
+        final String tag = String.format(Locale.ROOT, "%s-%s-%s",
+                workName, authority, searchRequestId);
+
+        final OneTimeWorkRequest syncRequest =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(inputData)
+                        .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
+                        .addTag(tag)
+                        .build();
+
+        synchronized (PickerSyncManager.class) {
+            // Check if this work is already in progress. This logic is inside a class level
+            // synchronized block to avoid race conditions.
+            try {
+                if (isWorkPendingForTag(tag)) {
+                    Log.d(TAG, "Sync work is already in progress. Ignoring sync request " + tag);
+                    return;
+                }
+            } catch (InterruptedException | ExecutionException | RuntimeException e) {
+                Log.e(TAG, "Error occurred in fetching work info - scheduling sync work " + tag);
+            }
+
+            // Clear all existing requests since there can be only one unique work running and our
+            // new sync work will replace the existing work (if any).
+            markAllSearchResultsSyncAsComplete(syncSource);
+
+            // Track the new sync request
+            trackNewSearchResultsSyncRequests(syncSource, syncRequest.getId());
+
+            // Enqueue local or cloud sync request
+            try {
+                final Operation enqueueOperation = mWorkManager.enqueueUniqueWork(
+                        workName,
+                        ExistingWorkPolicy.REPLACE,
+                        syncRequest);
+
+                // Check that the request has been successfully enqueued.
+                enqueueOperation.getResult().get();
+            } catch (Exception e) {
+                Log.e(TAG, "Could not enqueue expedited search results sync request", e);
+                markSearchResultsSyncAsComplete(syncSource, syncRequest.getId());
+            }
+        }
+    }
+
+    /**
+     * Schedules work to reset all cloud search results and suggestions synced in the database.
+     * This is used when the cloud media provider changes or the collection id of the cloud media
+     * provider changes indicating that a full reset of cloud media is required.
+     *
+     * @param cloudAuthority Cloud authority might be null if there was an error in getting it.
+     */
+    public void resetCloudSearchCache(@Nullable String cloudAuthority) {
+        final Map<String, Object> inputMap = new HashMap<>();
+        inputMap.put(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY);
+        inputMap.put(SYNC_WORKER_INPUT_RESET_TYPE, SEARCH_PARTIAL_CACHE_RESET);
+        if (cloudAuthority != null) {
+            inputMap.put(SYNC_WORKER_INPUT_AUTHORITY, cloudAuthority);
+        }
+        final Data inputData = new Data(inputMap);
+
+        final OneTimeWorkRequest syncRequest =
+                buildOneTimeWorkerRequest(SearchResetWorker.class, inputData);
+
         try {
-            final Operation enqueueOperation = mWorkManager.enqueueUniqueWork(
-                    workName,
-                    ExistingWorkPolicy.APPEND_OR_REPLACE,
+            Log.d(TAG, "Scheduling cloud search results reset request.");
+
+            // Enqueue cloud search reset request with the ExistingWorkPolicy as REPLACE so
+            // that any currently running synced will be cancelled. Don't wait to check the
+            // results of the enqueue operation because this runs the critical path.
+            mWorkManager.enqueueUniqueWork(
+                    IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME,
+                    ExistingWorkPolicy.REPLACE,
                     syncRequest);
+        } catch (Exception e) {
+            Log.e(TAG, "Could not enqueue search results cloud reset request", e);
+        }
+    }
+
+    /**
+     * Schedules work to reset all search results cache after some delay from the search database.
+     */
+    public void delayedResetSearchCache() {
+        final Data inputData =
+                new Data(Map.of(
+                        SYNC_WORKER_INPUT_RESET_TYPE, SEARCH_RESULTS_FULL_CACHE_RESET,
+                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_AND_CLOUD));
+        final OneTimeWorkRequest syncRequest =
+                getDelayedSearchResetRequest(inputData);
+
+        // Enqueue full cache reset request. Ensure that this runs when the device is idle to
+        // prevent search requests from clearing when the user is using PhotoPicker search feature.
+        try {
+            Log.d(TAG, "Scheduling delayed search results full cache reset request.");
+            mWorkManager.enqueueUniqueWork(
+                    SEARCH_CACHE_RESET_WORK_NAME,
+                    ExistingWorkPolicy.KEEP,
+                    syncRequest);
+        } catch (Exception e) {
+            Log.e(TAG, "Could not enqueue search results full cache reset request", e);
+        }
+    }
+
+    /**
+     * Schedules periodic syncs that clears expired search history and cached suggestions from the
+     * Picker database when the search feature is turned on.
+     */
+    public void schedulePeriodicSearchSuggestionsReset() {
+        final Data inputData =
+                new Data(Map.of(
+                        SYNC_WORKER_INPUT_RESET_TYPE, EXPIRED_SUGGESTIONS_RESET,
+                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_AND_CLOUD));
+        final PeriodicWorkRequest syncRequest =
+                getPeriodicSearchSuggestionsResetRequest(inputData);
+
+        try {
+            Operation enqueueOperation =
+                    mWorkManager.enqueueUniquePeriodicWork(
+                            PERIODIC_SEARCH_SUGGESTIONS_RESET_WORK_NAME,
+                            ExistingPeriodicWorkPolicy.KEEP,
+                            syncRequest);
 
             // Check that the request has been successfully enqueued.
             enqueueOperation.getResult().get();
-        } catch (Exception e) {
-            Log.e(TAG, "Could not enqueue expedited search results sync request", e);
-            markSearchResultsSyncAsComplete(syncSource, syncRequest.getId());
+        } catch (InterruptedException | ExecutionException e) {
+            Log.e(TAG, "Could not enqueue periodic search suggestions request", e);
         }
     }
 
     /**
-     * Creates OneTimeWork request for syncing media sets with the given provider
+     * Creates OneTimeWork request for syncing media sets with the given provider.
+     * The existing media sets cache and the media sets content cache for the given categoryId
+     * is cleared before a new media sets sync is triggered to ensure accuracy of the media sets
+     * metadata stored in the database. The reset cache and sync requests are chained to ensure
+     * correctness of the entire operation.
      * @param requestParams The MediaSetsSyncRequestsParams object containing all input parameters
      *                      for creating a sync request
      * @param syncSource Indicates whether the sync is required with the local provider or
@@ -495,17 +661,38 @@ public class PickerSyncManager {
      */
     public void syncMediaSetsForProvider(
             MediaSetsSyncRequestParams requestParams, @SyncSource int syncSource) {
-        final Data inputData =
-                new Data(
-                        Map.of(
-                                SYNC_WORKER_INPUT_AUTHORITY, requestParams.getAuthority(),
-                                SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource,
-                                SYNC_WORKER_INPUT_CATEGORY_ID, requestParams.getCategoryId(),
-                                EXTRA_MIME_TYPES, requestParams.getMimeTypes()));
+        // Create media sets sync request
+        final Map<String, Object> syncRequestInputMap = new HashMap<>();
+        syncRequestInputMap.put(SYNC_WORKER_INPUT_AUTHORITY, requestParams.getAuthority());
+        syncRequestInputMap.put(SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource);
+        syncRequestInputMap.put(SYNC_WORKER_INPUT_CATEGORY_ID, requestParams.getCategoryId());
+        if (requestParams.getMimeTypes() != null) {
+            syncRequestInputMap.put(EXTRA_MIME_TYPES, requestParams.getMimeTypes().toArray(
+                    new String[0]
+            ));
+        }
+        final Data syncRequestInputData = new Data(syncRequestInputMap);
         final OneTimeWorkRequest syncRequest =
-                buildOneTimeWorkerRequest(MediaSetsSyncWorker.class, inputData);
+                buildOneTimeWorkerRequest(MediaSetsSyncWorker.class, syncRequestInputData);
+
+        // Create media sets reset request. MediaSets sync are non-resumable.
+        // It's fine to delete the entire cache before a new set is triggered for the given
+        // categoryId.
+        // The media sets content cache for media sets belonging to the given categoryId
+        // is also cleared before we start syncing any particular media set for its content.
+        // These tables are cleared once per picker session before the media sets sync for this
+        // session is triggered. This ensures that the data read from the cache in every session
+        // is always in sync with the cloud provider.
+        final Map<String, Object> resetRequestInputMap = new HashMap<>();
+        resetRequestInputMap.put(SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource);
+        resetRequestInputMap.put(SYNC_WORKER_INPUT_CATEGORY_ID, requestParams.getCategoryId());
+        resetRequestInputMap.put(SYNC_WORKER_INPUT_AUTHORITY, requestParams.getAuthority());
+        final Data resetRequestInputData = new Data(resetRequestInputMap);
+        final OneTimeWorkRequest resetRequest =
+                buildOneTimeWorkerRequest(MediaSetsResetWorker.class, resetRequestInputData);
 
-        // track the new request
+        // Track the new requests
+        trackNewMediaSetsSyncRequest(syncSource, resetRequest.getId());
         trackNewMediaSetsSyncRequest(syncSource, syncRequest.getId());
 
         final String workName = syncSource == SYNC_LOCAL_ONLY
@@ -513,30 +700,117 @@ public class PickerSyncManager {
                 : IMMEDIATE_CLOUD_MEDIA_SETS_SYNC_WORK_NAME;
         // Enqueue local or cloud sync request
         try {
-            final Operation enqueueOperation = mWorkManager.enqueueUniqueWork(
-                    workName,
-                    ExistingWorkPolicy.APPEND_OR_REPLACE,
-                    syncRequest);
+            final Operation enqueueOperation = mWorkManager
+                    .beginUniqueWork(
+                            workName,
+                            ExistingWorkPolicy.APPEND_OR_REPLACE,
+                            resetRequest)
+                    .then(syncRequest).enqueue();
 
             // Check that the request has been successfully enqueued.
             enqueueOperation.getResult().get();
         } catch (Exception e) {
             Log.e(TAG, "Could not enqueue expedited media sets sync request", e);
+            markMediaSetsSyncAsComplete(syncSource, resetRequest.getId());
             markMediaSetsSyncAsComplete(syncSource, syncRequest.getId());
         }
     }
 
-    @NotNull
+    /**
+     * Creates OneTimeWork request for syncing media in media set with the given provider
+     * @param requestParams The MediaInMediaSetSyncRequestParams object containing all input
+     *                      parameters for creating a sync request
+     * @param syncSource Indicates whether the sync is required with the local provider or
+     *                   the cloud provider.
+     */
+    public void syncMediaInMediaSetForProvider(
+            MediaInMediaSetSyncRequestParams requestParams,
+            @SyncSource int syncSource) {
+        final Data inputData =
+                new Data(
+                        Map.of(
+                                SYNC_WORKER_INPUT_AUTHORITY, requestParams.getAuthority(),
+                                SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource,
+                                SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID,
+                                requestParams.getMediaSetPickerId()));
+
+        final String workName = syncSource == SYNC_LOCAL_ONLY
+                ? IMMEDIATE_LOCAL_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME
+                : IMMEDIATE_CLOUD_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME;
+
+        final String tag = String.format(Locale.ROOT, "%s-%s-%s",
+                workName, requestParams.getAuthority(), requestParams.getMediaSetPickerId());
+
+        final OneTimeWorkRequest syncRequest =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(inputData)
+                        .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
+                        .addTag(tag)
+                        .build();
+
+        synchronized (PickerSyncManager.class) {
+            // Check if this work is already in progress. This logic is inside a class level
+            // synchronized block to avoid race conditions.
+            try {
+                if (isWorkPendingForTag(tag)) {
+                    Log.d(TAG, "Sync work is already in progress. Ignoring sync request " + tag);
+                    return;
+                }
+            } catch (InterruptedException | ExecutionException | RuntimeException e) {
+                Log.e(TAG, "Error occurred in fetching work info - scheduling sync work " + tag);
+            }
+
+            markAllMediaInMediaSetsSyncAsComplete(syncSource);
+
+            // track the new request
+            trackNewMediaInMediaSetSyncRequest(syncSource, syncRequest.getId());
+
+            // Enqueue local or cloud sync request
+            try {
+                final Operation enqueueOperation = mWorkManager.enqueueUniqueWork(
+                        workName,
+                        ExistingWorkPolicy.REPLACE,
+                        syncRequest
+                );
+
+                // Check that the request has been successfully enqueued.
+                enqueueOperation.getResult().get();
+            } catch (Exception e) {
+                Log.e(TAG, "Could not enqueue expedited media in media set sync request", e);
+                markMediaInMediaSetSyncAsComplete(syncSource, syncRequest.getId());
+            }
+        }
+    }
+
+    private boolean isWorkPendingForTag(@NonNull String tag)
+            throws InterruptedException, ExecutionException {
+        ListenableFuture<List<WorkInfo>> future = mWorkManager.getWorkInfosByTag(tag);
+        List<WorkInfo> workInfos = future.get();
+        for (WorkInfo workInfo : workInfos) {
+            if (!workInfo.getState().isFinished()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @NonNull
     private OneTimeWorkRequest buildOneTimeWorkerRequest(
-            @NotNull Class<? extends Worker> workerClass, @NonNull Data inputData) {
-        return new OneTimeWorkRequest.Builder(workerClass)
-                .setInputData(inputData)
-                .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
-                .build();
+            @NonNull Class<? extends Worker> workerClass, Data inputData) {
+        if (inputData != null) {
+            return new OneTimeWorkRequest.Builder(workerClass)
+                    .setInputData(inputData)
+                    .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
+                    .build();
+        } else {
+            return new OneTimeWorkRequest.Builder(workerClass)
+                    .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
+                    .build();
+        }
     }
 
-    @NotNull
-    private PeriodicWorkRequest getPeriodicProactiveSyncRequest(@NotNull Data inputData) {
+    @NonNull
+    private PeriodicWorkRequest getPeriodicProactiveSyncRequest(@NonNull Data inputData) {
         return new PeriodicWorkRequest.Builder(
                 ProactiveSyncWorker.class, SYNC_MEDIA_PERIODIC_WORK_INTERVAL, TimeUnit.HOURS)
                 .setInputData(inputData)
@@ -544,8 +818,8 @@ public class PickerSyncManager {
                 .build();
     }
 
-    @NotNull
-    private PeriodicWorkRequest getPeriodicAlbumResetRequest(@NotNull Data inputData) {
+    @NonNull
+    private PeriodicWorkRequest getPeriodicAlbumResetRequest(@NonNull Data inputData) {
 
         return new PeriodicWorkRequest.Builder(
                         MediaResetWorker.class,
@@ -557,8 +831,43 @@ public class PickerSyncManager {
                 .build();
     }
 
-    @NotNull
-    private OneTimeWorkRequest getOneTimeProactiveSyncRequest(@NotNull Data inputData) {
+    /**
+     * @param inputData Input data required by the Worker.
+     * @return A PeriodicWorkRequest for periodically clearing expired search suggestions from
+     * the database.
+     */
+    @NonNull
+    private PeriodicWorkRequest getPeriodicSearchSuggestionsResetRequest(@NonNull Data inputData) {
+
+        return new PeriodicWorkRequest.Builder(
+                SearchResetWorker.class,
+                RESET_SEARCH_SUGGESTIONS_PERIODIC_WORK_INTERVAL,
+                TimeUnit.DAYS)
+                .setInputData(inputData)
+                .setConstraints(getRequiresChargingAndIdleConstraints())
+                .build();
+    }
+
+    /**
+     * @param inputData Input data required by the Worker.
+     * @return A OneTimeWorkRequest for clearing all search results cache after an initial delay.
+     */
+    @NonNull
+    private OneTimeWorkRequest getDelayedSearchResetRequest(@NonNull Data inputData) {
+        Constraints constraints =  new Constraints.Builder()
+                .setRequiresDeviceIdle(true)
+                .build();
+
+        return new OneTimeWorkRequest
+                .Builder(SearchResetWorker.class)
+                .setConstraints(constraints)
+                .setInitialDelay(SEARCH_RESULTS_RESET_DELAY, TimeUnit.MINUTES)
+                .setInputData(inputData)
+                .build();
+    }
+
+    @NonNull
+    private OneTimeWorkRequest getOneTimeProactiveSyncRequest(@NonNull Data inputData) {
         Constraints constraints =  new Constraints.Builder()
                 .setRequiresBatteryNotLow(true)
                 .build();
@@ -570,7 +879,7 @@ public class PickerSyncManager {
                 .build();
     }
 
-    @NotNull
+    @NonNull
     private static Constraints getRequiresChargingAndIdleConstraints() {
         return new Constraints.Builder()
                 .setRequiresCharging(true)
diff --git a/src/com/android/providers/media/photopicker/sync/SearchResetWorker.java b/src/com/android/providers/media/photopicker/sync/SearchResetWorker.java
new file mode 100644
index 000000000..d83241ccf
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/sync/SearchResetWorker.java
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.EXPIRED_SUGGESTIONS_RESET;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SEARCH_PARTIAL_CACHE_RESET;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SEARCH_RESULTS_FULL_CACHE_RESET;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_RESET_TYPE;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.work.ListenableWorker;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.sqlite.SearchRequestDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.SearchResultsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils;
+
+import java.util.List;
+
+/**
+ * This worker is responsible to cleaning up search results or suggestions related data in
+ * picker database.
+ */
+public class SearchResetWorker extends Worker {
+    private static final String TAG = "SearchResetWorker";
+
+    private final int mSyncSource;
+    private final int mResetType;
+    private final String mProviderAuthority;
+
+    public SearchResetWorker(
+            @NonNull Context context,
+            @NonNull WorkerParameters workerParameters) {
+        super(context, workerParameters);
+
+        mSyncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1);
+        mResetType = getInputData().getInt(SYNC_WORKER_INPUT_RESET_TYPE, -1);
+        mProviderAuthority = getInputData().getString(SYNC_WORKER_INPUT_AUTHORITY);
+    }
+
+    @Override
+    public ListenableWorker.Result doWork() {
+        // Do not allow endless re-runs of this worker, if this isn't the original run,
+        // just succeed and wait until the next scheduled run.
+        if (getRunAttemptCount() > 0) {
+            Log.w(TAG, "Worker retry was detected, ending this run in failure.");
+            return ListenableWorker.Result.failure();
+        }
+
+        switch (mResetType) {
+            case SEARCH_RESULTS_FULL_CACHE_RESET:
+                return searchResultsFullCacheReset();
+
+            case SEARCH_PARTIAL_CACHE_RESET:
+                return searchPartialCacheResetForAuthority();
+
+            case EXPIRED_SUGGESTIONS_RESET:
+                return expiredSuggestionsReset();
+
+            default:
+                Log.e(TAG, "Could not recognize reset type: " + mResetType);
+                return ListenableWorker.Result.failure();
+        }
+    }
+
+    /**
+     * Clears search results for either local or cloud provider based on the input data.
+     * Also clears the sync resume information in the database.
+     *
+     * @return ListenableWorker.Result that indicates whether the work was either a success
+     * or a failure.
+     */
+    @NonNull
+    private ListenableWorker.Result searchPartialCacheResetForAuthority() {
+        final SQLiteDatabase database = getDatabase();
+
+        try {
+            checkIfWorkerIsStopped();
+
+            if (mSyncSource != SYNC_LOCAL_ONLY && mSyncSource != SYNC_CLOUD_ONLY) {
+                throw new IllegalArgumentException(
+                        "Cannot perform partial search results reset with sync source "
+                                + mSyncSource);
+            }
+            final boolean isLocal = mSyncSource == SYNC_LOCAL_ONLY;
+
+            // Start a database transaction with EXCLUSIVE lock.
+            database.beginTransaction();
+
+            final List<Integer> syncedSearchRequestIds =
+                    SearchRequestDatabaseUtil.getSyncedRequestIds(database, isLocal);
+            SearchRequestDatabaseUtil.clearSyncResumeInfo(
+                    database, syncedSearchRequestIds, isLocal);
+            SearchResultsDatabaseUtil.clearObsoleteSearchResults(
+                    database, syncedSearchRequestIds, isLocal);
+
+            // Clear all history and caches search suggestions sources received from the authority.
+            SearchSuggestionsDatabaseUtils.clearCachedSearchSuggestionsForAuthority(
+                    database, mProviderAuthority);
+            SearchSuggestionsDatabaseUtils.clearHistorySearchSuggestionsForAuthority(
+                    database, mProviderAuthority);
+
+
+            // Check if this work has been cancelled before committing these changes to
+            // the database.
+            checkIfWorkerIsStopped();
+
+            // Mark transaction as successful so that the changes get committed to the database.
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
+
+            return ListenableWorker.Result.success();
+        } catch (Exception e) {
+            Log.e(TAG, "Could not perform search results partial cache reset.", e);
+            return ListenableWorker.Result.failure();
+        } finally {
+            // Ensure that the transaction ends and the DB lock is released.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    /**
+     * Clears all search results and search requests from the cache.
+     *
+     * @return ListenableWorker.Result that indicates whether the work was either a success
+     * or a failure.
+     */
+    @NonNull
+    private ListenableWorker.Result searchResultsFullCacheReset() {
+        final SQLiteDatabase database = getDatabase();
+
+        try {
+            // Don't proceed with this if any local or cloud search results sync is pending,
+            // or if the worker is stopped.
+            checkPendingLocalSearchSync();
+            checkPendingCloudSearchSync();
+            checkIfWorkerIsStopped();
+
+            // Start a database transaction with EXCLUSIVE lock.
+            database.beginTransaction();
+
+            // Clear all search requests and their associated results.
+            SearchRequestDatabaseUtil.clearAllSearchRequests(database);
+            SearchResultsDatabaseUtil.clearAllSearchResults(database);
+
+            // Check again if this work has been cancelled/made obsolete before committing these
+            // changes to the database.
+            checkPendingLocalSearchSync();
+            checkPendingCloudSearchSync();
+            checkIfWorkerIsStopped();
+
+            // Mark transaction as successful so that the changes get committed to the database.
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
+            return ListenableWorker.Result.success();
+        } catch (RequestObsoleteException | RuntimeException e) {
+            Log.e(TAG, "Could not clear search request and/or results cache", e);
+            return ListenableWorker.Result.failure();
+        } finally {
+            // Ensure that the transaction ends and the DB lock is released.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    /**
+     * Clears all expired history search suggestions and cached search suggestions.
+     *
+     * @return ListenableWorker.Result that indicates whether the work was either a success
+     * or a failure.
+     */
+    @NonNull
+    private ListenableWorker.Result expiredSuggestionsReset() {
+        final SQLiteDatabase database = getDatabase();
+
+        try {
+            // Don't proceed if the worker is stopped.
+            checkIfWorkerIsStopped();
+
+            // Clear all expired history and caches search suggestions.
+            SearchSuggestionsDatabaseUtils.clearExpiredCachedSearchSuggestions(database);
+            SearchSuggestionsDatabaseUtils.clearExpiredHistorySearchSuggestions(database);
+
+            // Check again if the worker is stopped before committing the changes.
+            checkIfWorkerIsStopped();
+
+            return ListenableWorker.Result.success();
+        } catch (RequestObsoleteException | RuntimeException e) {
+            Log.e(TAG, "Could not clear expired cached/history suggestions", e);
+            return ListenableWorker.Result.failure();
+        }
+    }
+
+    private void checkPendingLocalSearchSync() throws RequestObsoleteException {
+        if (!SyncTrackerRegistry.getLocalSearchSyncTracker().pendingSyncFutures().isEmpty()) {
+            throw new RequestObsoleteException("Local search sync is pending.");
+        }
+    }
+
+    private void checkPendingCloudSearchSync() throws RequestObsoleteException {
+        if (!SyncTrackerRegistry.getCloudSearchSyncTracker().pendingSyncFutures().isEmpty()) {
+            throw new RequestObsoleteException("Cloud search sync is pending.");
+        }
+    }
+
+    private void checkIfWorkerIsStopped() throws RequestObsoleteException {
+        if (isStopped()) {
+            throw new RequestObsoleteException("Worker is stopped.");
+        }
+    }
+
+    @NonNull
+    private SQLiteDatabase getDatabase() {
+        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java b/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java
index 82fc29b9c..76e0e6e06 100644
--- a/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java
+++ b/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java
@@ -20,10 +20,13 @@ import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBU
 
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SEARCH_REQUEST_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markSearchResultsSyncAsComplete;
 
+import static java.util.Objects.requireNonNull;
+
 import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
@@ -32,6 +35,7 @@ import android.os.Bundle;
 import android.os.CancellationSignal;
 import android.provider.CloudMediaProviderContract;
 import android.util.Log;
+import android.util.Pair;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
@@ -40,15 +44,19 @@ import androidx.work.ListenableWorker;
 import androidx.work.Worker;
 import androidx.work.WorkerParameters;
 
-import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.PhotopickerSyncHelper;
+import com.android.providers.media.photopicker.v2.PickerNotificationSender;
 import com.android.providers.media.photopicker.v2.model.SearchRequest;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
 import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
 import com.android.providers.media.photopicker.v2.sqlite.SearchRequestDatabaseUtil;
 import com.android.providers.media.photopicker.v2.sqlite.SearchResultsDatabaseUtil;
 
+import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
+import java.util.Set;
 
 /**
  * This is a {@link Worker} class responsible for syncing search results media with the
@@ -64,6 +72,9 @@ public class SearchResultsSyncWorker extends Worker {
     public static final String SYNC_COMPLETE_RESUME_KEY = "SYNCED";
     private final Context mContext;
     private final CancellationSignal mCancellationSignal;
+    private boolean mMarkedSyncWorkAsComplete = false;
+    private final PhotopickerSyncHelper mPhotopickerSyncHelper;
+    private final SQLiteDatabase mDatabase;
 
     /**
      * Creates an instance of the {@link Worker}.
@@ -78,6 +89,8 @@ public class SearchResultsSyncWorker extends Worker {
 
         mContext = context;
         mCancellationSignal = new CancellationSignal();
+        mPhotopickerSyncHelper = new PhotopickerSyncHelper();
+        mDatabase = mPhotopickerSyncHelper.getDatabase();
     }
 
     @NonNull
@@ -85,6 +98,7 @@ public class SearchResultsSyncWorker extends Worker {
     public ListenableWorker.Result doWork() {
         final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
                 /* defaultValue */ INVALID_SYNC_SOURCE);
+        final String syncAuthority = getInputData().getString(SYNC_WORKER_INPUT_AUTHORITY);
         final int searchRequestId = getInputData().getInt(SYNC_WORKER_INPUT_SEARCH_REQUEST_ID,
                 /* defaultValue */ INVALID_SEARCH_REQUEST_ID);
 
@@ -97,16 +111,16 @@ public class SearchResultsSyncWorker extends Worker {
             }
 
             Log.i(TAG, String.format(
-                    "Starting search results sync from sync source: %s search request id: %s",
-                    syncSource, searchRequestId));
-
-            throwIfWorkerStopped();
+                    Locale.ROOT,
+                    "Starting search results sync from sync source: %s, "
+                            + "sync authority: %s, search request id: %s",
+                    syncSource, syncAuthority, searchRequestId));
 
             final SearchRequest searchRequest = SearchRequestDatabaseUtil
-                    .getSearchRequestDetails(getDatabase(), searchRequestId);
-            validateWorkInput(syncSource, searchRequestId, searchRequest);
+                    .getSearchRequestDetails(mDatabase, searchRequestId);
+            validateWorkInput(syncSource, syncAuthority, searchRequestId, searchRequest);
 
-            syncWithSource(syncSource, searchRequestId, searchRequest);
+            syncWithSource(syncSource, syncAuthority, searchRequestId, searchRequest);
 
             Log.i(TAG, String.format(
                     "Completed search results sync from sync source: %s search request id: %s",
@@ -118,69 +132,181 @@ public class SearchResultsSyncWorker extends Worker {
                     syncSource, searchRequestId), e);
             return ListenableWorker.Result.failure();
         } finally {
-            markSearchResultsSyncAsComplete(syncSource, getId());
+            if (!mMarkedSyncWorkAsComplete) {
+                markSearchResultsSyncAsComplete(syncSource, getId());
+            }
         }
     }
 
     /**
      * Sync search results with the given sync source.
      *
-     * @param syncSource Identifies if we need to sync with local provider or cloud provider.
+     * @param syncSource      Identifies if we need to sync source type. this could be the
+     *                        local provider or cloud provider.
+     * @param authority   Input authority of the CMP.
      * @param searchRequestId Identifier for the search request.
-     * @param searchRequest Details of the search request.
+     * @param searchRequest   Details of the search request.
      * @throws IllegalArgumentException If the search request could not be identified.
      * @throws RequestObsoleteException If the search request has become obsolete.
      */
     private void syncWithSource(
-            int syncSource,
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull String authority,
             int searchRequestId,
             @Nullable SearchRequest searchRequest)
             throws IllegalArgumentException, RequestObsoleteException {
-        final String authority = getProviderAuthority(syncSource, searchRequest);
         final PickerSearchProviderClient searchClient =
                 PickerSearchProviderClient.create(mContext, authority);
 
-        String resumePageToken = searchRequest.getResumeKey();
+        final boolean resetResumeKey =
+                maybeResetResumeKey(searchRequestId, searchRequest, authority, syncSource);
+        if (resetResumeKey) {
+            searchRequest = requireNonNull(SearchRequestDatabaseUtil
+                    .getSearchRequestDetails(mDatabase, searchRequestId));
+        }
 
-        if (SYNC_COMPLETE_RESUME_KEY.equals(resumePageToken)) {
-            Log.i(TAG, "Sync has already been completed.");
+        final Pair<String, String> resumeKey = getResumeKey(searchRequest, syncSource);
+
+        if (SYNC_COMPLETE_RESUME_KEY.equals(resumeKey.first)) {
+            Log.i(TAG, "Sync was already complete.");
             return;
         }
 
+        final Set<String> knownTokens = new HashSet<>();
+        String nextPageToken = resumeKey.first;
+        if (nextPageToken != null) {
+            knownTokens.add(nextPageToken);
+        }
+
         try {
             for (int iteration = 0; iteration < SYNC_PAGE_COUNT; iteration++) {
                 throwIfWorkerStopped();
                 throwIfCloudProviderHasChanged(authority);
 
                 try (Cursor cursor = fetchSearchResultsFromCmp(
-                        searchClient, searchRequest, resumePageToken)) {
+                        searchClient, authority, searchRequest, nextPageToken,
+                        searchRequest.getMimeTypes())) {
+                    Log.d(TAG, "Fetching search results for request id " + searchRequestId
+                            + " and next page token " + nextPageToken);
 
                     List<ContentValues> contentValues =
                             SearchResultsDatabaseUtil.extractContentValuesList(
-                                    searchRequestId, cursor, isLocal(authority));
+                                    searchRequestId, cursor,
+                                    mPhotopickerSyncHelper.isAuthorityLocal(authority));
+
+                    throwIfWorkerStopped();
+                    throwIfCloudProviderHasChanged(authority);
 
-                    SearchResultsDatabaseUtil
-                            .cacheSearchResults(getDatabase(), authority, contentValues);
+                    int numberOfRowsInserted = SearchResultsDatabaseUtil
+                            .cacheSearchResults(mDatabase, authority, contentValues,
+                                    mCancellationSignal);
 
-                    resumePageToken = getResumePageToken(cursor.getExtras());
-                    if (SYNC_COMPLETE_RESUME_KEY.equals(resumePageToken)) {
+                    nextPageToken = getResumePageToken(cursor.getExtras());
+                    if (SYNC_COMPLETE_RESUME_KEY.equals(nextPageToken)) {
+                        Log.d(TAG, "Number of search results pages synced: " + (iteration + 1));
                         // Stop syncing if there are no more pages to sync.
                         break;
+                    } else if (knownTokens.contains(nextPageToken)) {
+                        Log.e(TAG, "Loop detected! CMP has sent the same page token twice: "
+                                + nextPageToken);
+                        break;
                     }
+                    knownTokens.add(nextPageToken);
 
                     // Mark sync as completed after getting the first page to start returning
                     // search results to the UI.
-                    markSearchResultsSyncAsComplete(syncSource, getId());
+                    if (mMarkedSyncWorkAsComplete) {
+                        // Notify the UI that a change has been made in the DB
+                        if (numberOfRowsInserted > 0) {
+                            PickerNotificationSender
+                                    .notifySearchResultsChange(mContext, searchRequestId);
+                        }
+                    } else {
+                        markSearchResultsSyncAsComplete(syncSource, getId());
+                        mMarkedSyncWorkAsComplete = true;
+                    }
                 }
             }
         } finally {
-            // Save sync resume key till the point it was performed successfully
-            searchRequest.setResumeKey(resumePageToken);
-            SearchRequestDatabaseUtil
-                    .updateResumeKey(getDatabase(), searchRequestId, resumePageToken);
+            // Save progress in DB
+            // TODO(b/398221732): Resume search results syncs.
+            if (SYNC_COMPLETE_RESUME_KEY.equals(nextPageToken)) {
+                throwIfWorkerStopped();
+                setResumeKey(searchRequest, nextPageToken, syncSource);
+                SearchRequestDatabaseUtil
+                        .updateResumeKey(mDatabase, searchRequestId, SYNC_COMPLETE_RESUME_KEY,
+                                authority, mPhotopickerSyncHelper.isAuthorityLocal(authority));
+            }
+        }
+    }
+
+    private boolean maybeResetResumeKey(
+            int searchRequestId,
+            @NonNull SearchRequest searchRequest,
+            @NonNull String authority,
+            @PickerSyncManager.SyncSource int syncSource) throws RequestObsoleteException {
+
+        final Pair<String, String> resumeKey = getResumeKey(searchRequest, syncSource);
+        if (resumeKey.second != null && !authority.equals(resumeKey.second)) {
+            Log.w(TAG, String.format(
+                    Locale.ROOT,
+                    "Search request is already (fully or partially) synced with %s "
+                            + "when a sync has been triggered with %s",
+                    resumeKey.second,
+                    authority));
+
+            try {
+                mDatabase.beginTransaction();
+
+                SearchRequestDatabaseUtil.clearSyncResumeInfo(
+                        mDatabase, List.of(searchRequestId),
+                        mPhotopickerSyncHelper.isAuthorityLocal(authority));
+                SearchResultsDatabaseUtil.clearObsoleteSearchResults(
+                        mDatabase, List.of(searchRequestId),
+                        mPhotopickerSyncHelper.isAuthorityLocal(authority));
+
+                // Check if this worker has stopped and the current sync request is obsolete before
+                // committing the change.
+                throwIfWorkerStopped();
+                throwIfCloudProviderHasChanged(authority);
+
+                if (mDatabase.inTransaction()) {
+                    mDatabase.setTransactionSuccessful();
+                }
+                return true;
+            } catch (RuntimeException e) {
+                Log.e(TAG, "Could not clear sync resume info", e);
+            } finally {
+                if (mDatabase.inTransaction()) {
+                    mDatabase.endTransaction();
+                }
+            }
+        }
+
+        return false;
+    }
+
+    private void setResumeKey(
+            @NonNull SearchRequest searchRequest,
+            @NonNull String resumePageToken,
+            @PickerSyncManager.SyncSource int syncSource) {
+        if (syncSource == SYNC_LOCAL_ONLY) {
+            searchRequest.setCloudResumeKey(resumePageToken);
+        } else {
+            searchRequest.setLocalSyncResumeKey(resumePageToken);
         }
     }
 
+    @NonNull
+    private Pair<String, String> getResumeKey(
+            @NonNull SearchRequest searchRequest,
+            @PickerSyncManager.SyncSource int syncSource) {
+        return syncSource == SYNC_LOCAL_ONLY
+                ? new Pair(searchRequest.getLocalSyncResumeKey(), searchRequest.getLocalAuthority())
+                : new Pair(searchRequest.getCloudSyncResumeKey(),
+                        searchRequest.getCloudAuthority());
+    }
+
     /**
      * @param extras Bundle received from the CloudMediaProvider with the search results cursor.
      * @return Extracts the rsume page token from the extras and returns it. If it is not present
@@ -202,12 +328,20 @@ public class SearchResultsSyncWorker extends Worker {
     @NonNull
     private Cursor fetchSearchResultsFromCmp(
             @NonNull PickerSearchProviderClient searchClient,
+            @NonNull String authority,
             @NonNull SearchRequest searchRequest,
-            @Nullable String resumePageToken) {
+            @Nullable String resumePageToken,
+            @Nullable List<String> mimeTypes) {
         final String suggestedMediaSetId;
         final String searchText;
         if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
-            suggestedMediaSetId = searchSuggestionRequest.getSearchSuggestion().getMediaSetId();
+            // Only media set id to the CMP if it is the suggestion source.
+            if (authority.equals(searchSuggestionRequest.getSearchSuggestion().getAuthority())) {
+                suggestedMediaSetId = searchSuggestionRequest.getSearchSuggestion().getMediaSetId();
+            } else {
+                suggestedMediaSetId = null;
+            }
+
             searchText = searchSuggestionRequest.getSearchSuggestion().getSearchText();
         } else if (searchRequest instanceof SearchTextRequest searchTextRequest) {
             suggestedMediaSetId = null;
@@ -220,6 +354,7 @@ public class SearchResultsSyncWorker extends Worker {
                 suggestedMediaSetId,
                 searchText,
                 CloudMediaProviderContract.SORT_ORDER_DESC_DATE_TAKEN,
+                mimeTypes,
                 PAGE_SIZE,
                 resumePageToken,
                 mCancellationSignal
@@ -237,27 +372,64 @@ public class SearchResultsSyncWorker extends Worker {
      * Validates input data received by the Worker for an immediate search results sync.
      */
     private void validateWorkInput(
-            int syncSource,
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull String authority,
             int searchRequestId,
-            @Nullable SearchRequest searchRequest) throws IllegalArgumentException {
+            @Nullable SearchRequest searchRequest)
+            throws IllegalArgumentException, RequestObsoleteException {
+        requireNonNull(authority);
+
         // Search result sync can only happen with either local provider or cloud provider. This
         // information needs to be provided in the {@code inputData}.
         if (syncSource != SYNC_LOCAL_ONLY && syncSource != SYNC_CLOUD_ONLY) {
             throw new IllegalArgumentException("Invalid search results sync source " + syncSource);
         }
+
+        // Check if the input authority matches the current provider.
+        if (syncSource == SYNC_LOCAL_ONLY) {
+            final String localAuthority = mPhotopickerSyncHelper.getLocalProviderAuthority();
+            if (!authority.equals(localAuthority)) {
+                throw new RequestObsoleteException(String.format(
+                        Locale.ROOT,
+                        "Input authority %s does not match current authority %s for sync source %d",
+                        authority,
+                        localAuthority,
+                        syncSource)
+                );
+            }
+        } else {
+            final String cloudAuthority = mPhotopickerSyncHelper.getCurrentCloudProviderAuthority();
+            if (!authority.equals(cloudAuthority)) {
+                throw new RequestObsoleteException(String.format(
+                        Locale.ROOT,
+                        "Input authority %s does not match current authority %s for sync source %d",
+                        authority,
+                        cloudAuthority,
+                        syncSource)
+                );
+            }
+        }
+
+        // Check if input search request id is valid.
         if (searchRequestId == INVALID_SEARCH_REQUEST_ID) {
             throw new IllegalArgumentException("Invalid search request id " + searchRequestId);
         }
+
+        // Check search request details pulled from the database are valid.
         if (searchRequest == null) {
             throw new IllegalArgumentException(
                     "Could not get search request details for search request id "
                             + searchRequestId);
         }
+
+        // If the search request is an ALBUM type suggestion, check that we're only syncing with the
+        // album suggestion source CMP.
         if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
             if (searchSuggestionRequest.getSearchSuggestion().getSearchSuggestionType()
                     == SEARCH_SUGGESTION_ALBUM) {
                 final boolean isLocal =
-                        isLocal(searchSuggestionRequest.getSearchSuggestion().getAuthority());
+                        mPhotopickerSyncHelper.isAuthorityLocal(
+                                searchSuggestionRequest.getSearchSuggestion().getAuthority());
 
                 if (isLocal && syncSource == SYNC_CLOUD_ONLY) {
                     throw new IllegalArgumentException(
@@ -272,51 +444,15 @@ public class SearchResultsSyncWorker extends Worker {
         }
     }
 
-    private String getProviderAuthority(
-            int syncSource,
-            @NonNull SearchRequest searchRequest) {
-        final String authority;
-        if (syncSource == SYNC_LOCAL_ONLY) {
-            authority = getLocalProviderAuthority();
-        } else if (syncSource == SYNC_CLOUD_ONLY) {
-            authority = getCurrentCloudProviderAuthority();
-        } else {
-            throw new IllegalArgumentException("Invalid search results sync source " + syncSource);
-        }
-
-        if (authority == null) {
-            throw new IllegalArgumentException("Authority of the provider to sync search results "
-                    + "with cannot be null");
-        }
-
-        // Only in case of ALBUM type search suggestion, we want to explicitly query the source
-        // suggestion authority. For the rest of the suggestion types, we can query both
-        // available providers - local and cloud.
-        if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
-            if (searchSuggestionRequest.getSearchSuggestion().getSearchSuggestionType()
-                    == SEARCH_SUGGESTION_ALBUM) {
-                if (!authority.equals(
-                        searchSuggestionRequest.getSearchSuggestion().getAuthority())) {
-                    throw new IllegalArgumentException(String.format(
-                            "Mismatch in the suggestion source authority %s and the "
-                                    + "current sync authority %s for album search results sync",
-                            searchSuggestionRequest.getSearchSuggestion().getAuthority(),
-                            authority));
-                }
-            }
-        }
-
-        return authority;
-    }
-
     private void throwIfCloudProviderHasChanged(@NonNull String authority)
             throws RequestObsoleteException {
         // Local provider's authority cannot change.
-        if (isLocal(authority)) {
+        if (mPhotopickerSyncHelper.isAuthorityLocal(authority)) {
             return;
         }
 
-        final String currentCloudAuthority = getCurrentCloudProviderAuthority();
+        final String currentCloudAuthority =
+                mPhotopickerSyncHelper.getCurrentCloudProviderAuthority();
         if (!authority.equals(currentCloudAuthority)) {
             throw new RequestObsoleteException("Cloud provider authority has changed. "
                     + " Current cloud provider authority: " + currentCloudAuthority
@@ -330,21 +466,9 @@ public class SearchResultsSyncWorker extends Worker {
         }
     }
 
-    private boolean isLocal(@NonNull String authority) {
-        return getLocalProviderAuthority().equals(authority);
-    }
-
-    @Nullable
-    private String getLocalProviderAuthority() {
-        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
-    }
-
-    @Nullable
-    private String getCurrentCloudProviderAuthority() {
-        return PickerSyncController.getInstanceOrThrow().getCloudProvider();
-    }
-
-    private SQLiteDatabase getDatabase() {
-        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    @Override
+    public void onStopped() {
+        // Mark the operation as cancelled so that the cancellation can be propagated to subtasks.
+        mCancellationSignal.cancel();
     }
 }
diff --git a/src/com/android/providers/media/photopicker/sync/SyncTracker.java b/src/com/android/providers/media/photopicker/sync/SyncTracker.java
index 87d3a204f..02f0bebb9 100644
--- a/src/com/android/providers/media/photopicker/sync/SyncTracker.java
+++ b/src/com/android/providers/media/photopicker/sync/SyncTracker.java
@@ -87,6 +87,22 @@ public class SyncTracker {
         }
     }
 
+    /**
+     * Use this method to mark all picker sync futures as complete.
+     *
+     * This is useful when using {@link ExistingWorkPolicy.REPLACE} to enqueue Unique Work.
+     * It clears the tracker of the work that will get cancelled by the REPLACE policy.
+     */
+    public void markAllSyncsCompleted() {
+        synchronized (mFutureMap) {
+            for (CompletableFuture future : mFutureMap.values()) {
+                future.complete(FUTURE_RESULT);
+            }
+            mFutureMap.clear();
+            Log.i(TAG, String.format("Marked all sync futures as complete"));
+        }
+    }
+
     /**
      * Use this method to check if any sync request is still pending.
      * @return a {@link Collection} of {@link CompletableFuture} of pending syncs. This can be
diff --git a/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java b/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java
index b9f937ac1..82acd40fe 100644
--- a/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java
+++ b/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java
@@ -285,6 +285,26 @@ public class SyncTrackerRegistry {
         }
     }
 
+    /**
+     * Create the required completable futures to track a new media in media set sync request
+     */
+    public static void trackNewMediaInMediaSetSyncRequest(
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull UUID syncRequestId) {
+        switch (syncSource) {
+            case SYNC_LOCAL_ONLY:
+                getLocalMediaInMediaSetTracker().createSyncFuture(syncRequestId);
+                break;
+            case SYNC_CLOUD_ONLY:
+                getCloudMediaInMediaSetTracker().createSyncFuture(syncRequestId);
+                break;
+            default:
+                getLocalMediaInMediaSetTracker().createSyncFuture(syncRequestId);
+                getCloudMediaInMediaSetTracker().createSyncFuture(syncRequestId);
+                break;
+        }
+    }
+
     /**
      * Mark the required futures as complete for existing media sync requests.
      */
@@ -330,6 +350,19 @@ public class SyncTrackerRegistry {
         }
     }
 
+    /**
+     * Mark all the pending futures as complete.
+     */
+    public static void markAllSearchResultsSyncAsComplete(
+            @PickerSyncManager.SyncSource int syncSource) {
+        if (syncSource == SYNC_LOCAL_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getLocalSearchSyncTracker().markAllSyncsCompleted();
+        }
+        if (syncSource == SYNC_CLOUD_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getCloudSearchSyncTracker().markAllSyncsCompleted();
+        }
+    }
+
     /**
      * Mark the required futures as complete for existing media set sync requests.
      */
@@ -357,4 +390,17 @@ public class SyncTrackerRegistry {
             getCloudMediaInMediaSetTracker().markSyncCompleted(syncRequestId);
         }
     }
+
+    /**
+     * Mark all media in media sets sync pending futures as complete
+     */
+    public static void markAllMediaInMediaSetsSyncAsComplete(
+            @PickerSyncManager.SyncSource int syncSource) {
+        if (syncSource == SYNC_LOCAL_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getLocalMediaInMediaSetTracker().markAllSyncsCompleted();
+        }
+        if (syncSource == SYNC_CLOUD_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getCloudMediaInMediaSetTracker().markAllSyncsCompleted();
+        }
+    }
 }
diff --git a/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java b/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java
index c086d0863..3727d181e 100644
--- a/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java
+++ b/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java
@@ -33,7 +33,7 @@ public class WorkManagerInitializer {
     // {@link PickerSyncManager} to ensure that any request type is not blocked on other request
     // types. It is advisable to use unique work requests because in case the number of queued
     // requests grows, they should not block other work requests.
-    private static final int WORK_MANAGER_THREAD_POOL_SIZE = 11;
+    private static final int WORK_MANAGER_THREAD_POOL_SIZE = 13;
     @Nullable
     private static volatile Executor sWorkManagerExecutor;
 
diff --git a/src/com/android/providers/media/photopicker/ui/settings/SettingsCloudMediaSelectFragment.java b/src/com/android/providers/media/photopicker/ui/settings/SettingsCloudMediaSelectFragment.java
index 7d0586476..fce75ae19 100644
--- a/src/com/android/providers/media/photopicker/ui/settings/SettingsCloudMediaSelectFragment.java
+++ b/src/com/android/providers/media/photopicker/ui/settings/SettingsCloudMediaSelectFragment.java
@@ -32,18 +32,19 @@ import androidx.annotation.UiThread;
 import androidx.lifecycle.ViewModel;
 import androidx.lifecycle.ViewModelProvider;
 import androidx.preference.Preference;
-import androidx.preference.PreferenceFragmentCompat;
+import androidx.preference.PreferenceGroup;
 import androidx.preference.PreferenceScreen;
 
 import com.android.providers.media.R;
 import com.android.providers.media.photopicker.data.model.UserId;
 import com.android.settingslib.widget.SelectorWithWidgetPreference;
+import com.android.settingslib.widget.SettingsBasePreferenceFragment;
 
 /**
  * This fragment will display a list of available cloud providers for the profile selected.
  * Users can view or change the preferred cloud provider media app.
  */
-public class SettingsCloudMediaSelectFragment extends PreferenceFragmentCompat
+public class SettingsCloudMediaSelectFragment extends SettingsBasePreferenceFragment
         implements SelectorWithWidgetPreference.OnClickListener {
     public static final String EXTRA_TAB_USER_ID = "user_id";
     private static final String TAG = "SettingsCMSelectFgmt";
@@ -91,7 +92,7 @@ public class SettingsCloudMediaSelectFragment extends PreferenceFragmentCompat
 
     @Override
     public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
-        super.addPreferencesFromResource(R.xml.pref_screen_picker_settings);
+        super.addPreferencesFromResource(R.xml.cloud_media_selection_settings);
 
         mSettingsCloudMediaViewModel.loadData(getConfigStore());
         observeMediaCollectionInfoChanges();
@@ -101,12 +102,12 @@ public class SettingsCloudMediaSelectFragment extends PreferenceFragmentCompat
     @UiThread
     private void refreshUI() {
         final PreferenceScreen screen = getPreferenceScreen();
-        resetPreferenceScreen(screen);
 
-        screen.addPreference(buildTitlePreference());
+        final PreferenceGroup preferenceGroup = findPreference("cloud_media_provider_options");
+
         for (CloudMediaProviderOption provider :
                 mSettingsCloudMediaViewModel.getProviderOptions()) {
-            screen.addPreference(buildProviderOptionPreference(provider));
+            preferenceGroup.addPreference(buildProviderOptionPreference(provider));
         }
 
         updateSelectedRadioButton();
@@ -182,24 +183,10 @@ public class SettingsCloudMediaSelectFragment extends PreferenceFragmentCompat
         return pref;
     }
 
-    @NonNull
-    private Preference buildTitlePreference() {
-        final Preference titlePref = new Preference(getPrefContext());
-        titlePref.setTitle(R.string.picker_settings_selection_message);
-        titlePref.setSelectable(false);
-        titlePref.setPersistent(false);
-        titlePref.setLayoutResource(R.layout.pref_settings_cloud_select_title);
-        return titlePref;
-    }
-
     private Context getPrefContext() {
         return getPreferenceManager().getContext();
     }
 
-    private void resetPreferenceScreen(PreferenceScreen screen) {
-        screen.removeAll();
-    }
-
     @NonNull
     private UserId getUserId() {
         if (getArguments() != null && getArguments().containsKey(EXTRA_TAB_USER_ID)) {
diff --git a/src/com/android/providers/media/photopicker/v2/PhotopickerSyncHelper.java b/src/com/android/providers/media/photopicker/v2/PhotopickerSyncHelper.java
new file mode 100644
index 000000000..37ec98190
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/PhotopickerSyncHelper.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+
+import java.util.Objects;
+
+/**
+ * Helper methods required across the picker search sync workers are extracted out into this
+ * utility class.
+ */
+public class PhotopickerSyncHelper {
+
+    /**
+     * Checks if the authority in the parameter is that of the local provider
+     */
+    public boolean isAuthorityLocal(@NonNull String authority) {
+        Objects.requireNonNull(authority);
+        return getLocalProviderAuthority().equals(authority);
+    }
+
+    /**
+     * Returns local provider authority
+     */
+    @Nullable
+    public String getLocalProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
+    }
+
+    /**
+     * Returns the authority of the current cloud provider
+     */
+    @Nullable
+    public String getCurrentCloudProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow()
+                .getCloudProviderOrDefault(/* defaultValue */ null);
+    }
+
+    /**
+     * Returns a database object to be used for required database operations
+     */
+    public SQLiteDatabase getDatabase() {
+        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java b/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java
index 11db2a58e..6471205f2 100644
--- a/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java
+++ b/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java
@@ -18,12 +18,15 @@ package com.android.providers.media.photopicker.v2;
 
 import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
 
+import static com.android.providers.media.MediaGrants.FILE_ID_COLUMN;
 import static com.android.providers.media.MediaGrants.MEDIA_GRANTS_TABLE;
 import static com.android.providers.media.MediaGrants.OWNER_PACKAGE_NAME_COLUMN;
 import static com.android.providers.media.MediaGrants.PACKAGE_USER_ID_COLUMN;
+import static com.android.providers.media.MediaProvider.isOwnedPhotosEnabled;
 import static com.android.providers.media.PickerUriResolver.getAlbumUri;
 import static com.android.providers.media.photopicker.PickerSyncController.getPackageNameFromUid;
 import static com.android.providers.media.photopicker.PickerSyncController.uidToUserId;
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.IMMEDIATE_GRANTS_SYNC_WORK_NAME;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.IMMEDIATE_LOCAL_SYNC_WORK_NAME;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
@@ -64,6 +67,7 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.work.WorkManager;
 
+import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.SearchState;
 import com.android.providers.media.photopicker.sync.PickerSearchProviderClient;
@@ -75,6 +79,7 @@ import com.android.providers.media.photopicker.util.exceptions.UnableToAcquireLo
 import com.android.providers.media.photopicker.v2.model.AlbumMediaQuery;
 import com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper;
 import com.android.providers.media.photopicker.v2.model.MediaGroup;
+import com.android.providers.media.photopicker.v2.model.MediaInMediaSetSyncRequestParams;
 import com.android.providers.media.photopicker.v2.model.MediaQuery;
 import com.android.providers.media.photopicker.v2.model.MediaQueryForPreSelection;
 import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
@@ -85,6 +90,9 @@ import com.android.providers.media.photopicker.v2.model.SearchRequest;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
 import com.android.providers.media.photopicker.v2.sqlite.MediaGroupCursorUtils;
+import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsQuery;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
 import com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil;
 import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
 import com.android.providers.media.photopicker.v2.sqlite.SearchMediaQuery;
@@ -110,11 +118,17 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
 /**
- * This class handles Photo Picker content queries.\
+ * This class handles Photo Picker content queries.
  */
 public class PickerDataLayerV2 {
     private static final String TAG = "PickerDataLayerV2";
     private static final int CLOUD_SYNC_TIMEOUT_MILLIS = 500;
+    private static final String MEDIA_TABLE = "media";
+    private static final String MEDIA_LEFT_JOIN_MEDIA_GRANTS_TABLE =
+            MEDIA_TABLE + " LEFT JOIN " + MEDIA_GRANTS_TABLE
+                    + " ON " + MEDIA_TABLE + "." + KEY_LOCAL_ID
+                    + " = " + MEDIA_GRANTS_TABLE + "." + FILE_ID_COLUMN;
+
     // Local and merged albums have a predefined order that they should be displayed in. They always
     // need to be displayed above the cloud albums too.
     public static final List<String> PINNED_ALBUMS_ORDER = List.of(
@@ -230,7 +244,8 @@ public class PickerDataLayerV2 {
      */
     @NonNull
     static Cursor queryPreviewMedia(@NonNull Context appContext, @NonNull Bundle queryArgs) {
-        final PreviewMediaQuery query = new PreviewMediaQuery(queryArgs);
+        final PreviewMediaQuery query = new PreviewMediaQuery(queryArgs, appContext);
+
         final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
         final String effectiveLocalAuthority =
                 query.getProviders().contains(syncController.getLocalProvider())
@@ -260,6 +275,36 @@ public class PickerDataLayerV2 {
         );
     }
 
+    /**
+     * Returns a cursor with cached media sets in response
+     * @param queryArgs The arguments to filter and fetch media sets
+     */
+    @NonNull
+    public static Cursor queryMediaSets(@NonNull Bundle queryArgs) {
+        requireNonNull(queryArgs);
+
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(queryArgs);
+        PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final Set<String> providers = new HashSet<>(
+                Objects.requireNonNull(queryArgs.getStringArrayList("providers")));
+        final String effectiveLocalAuthority = providers.contains(
+                syncController.getLocalProvider()) ? syncController.getLocalProvider() : null;
+        final String currentCloudAuthority = syncController
+                .getCloudProviderOrDefault(/*defaultValue*/ null);
+        final String effectiveCloudAuthority = syncController
+                .shouldQueryCloudMediaSets(providers, currentCloudAuthority)
+                ? currentCloudAuthority : null;
+
+        waitForOngoingMediaSetsSync(effectiveLocalAuthority, effectiveCloudAuthority);
+
+        Cursor mediaSetsCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                syncController.getDbFacade().getDatabase(),
+                requestParams
+               );
+
+        return MediaGroupCursorUtils.getMediaGroupCursorForMediaSets(mediaSetsCursor);
+    }
+
     /**
      * Returns a cursor with the Photo Picker albums in response.
      *
@@ -309,7 +354,7 @@ public class PickerDataLayerV2 {
         // This is an external query into the CMP, so catch any exceptions that might get thrown
         // so that at a minimum, the local results are sent back to the UI.
         try {
-            allAlbumCursors.add(getCloudAlbumsCursor(appContext, query, effectiveLocalAuthority,
+            allAlbumCursors.add(getCloudAlbumsCursor(appContext, query, localAuthority,
                     effectiveCloudAuthority));
         } catch (RuntimeException ex) {
             Log.w(TAG, "Cloud provider exception while fetching cloud albums cursor", ex);
@@ -369,20 +414,23 @@ public class PickerDataLayerV2 {
 
         // Add Pinned album and categories to the list of cursors in the order in which they
         // should be displayed. Note that pinned albums can only be local and merged albums.
+        long index = 0;
         for (Pair<MediaGroup, String> mediaGroup: PINNED_CATEGORIES_AND_ALBUMS_ORDER) {
             final Cursor cursor;
-
             switch (mediaGroup.first) {
                 case ALBUM:
                     final String albumId = mediaGroup.second;
                     if (MERGED_ALBUMS.contains(albumId)) {
-                        final Cursor albumsCursor = PickerMediaDatabaseUtil.getMergedAlbumsCursor(
+                        final Cursor mergedAlbumCursor =
+                                PickerMediaDatabaseUtil.getMergedAlbumsCursor(
                                 albumId, appContext, queryArgs, database, effectiveLocalAuthority,
                                 effectiveCloudAuthority);
-                        cursor = MediaGroupCursorUtils.getMediaGroupCursorForAlbums(albumsCursor);
+                        cursor = MediaGroupCursorUtils.getMediaGroupCursorForAlbums(
+                                mergedAlbumCursor, index);
                     } else if (LOCAL_ALBUMS.contains(albumId)) {
-                        final Cursor albumCursor = localAlbums.getOrDefault(albumId, null);
-                        cursor = MediaGroupCursorUtils.getMediaGroupCursorForAlbums(albumCursor);
+                        final Cursor localAlbumCursor = localAlbums.getOrDefault(albumId, null);
+                        cursor = MediaGroupCursorUtils.getMediaGroupCursorForAlbums(
+                                localAlbumCursor, index);
                     } else {
                         Log.e(TAG, "Could not recognize pinned album id, skipping it : " + albumId);
                         cursor = null;
@@ -393,7 +441,7 @@ public class PickerDataLayerV2 {
                     switch (mediaGroup.second) {
                         case CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS:
                             cursor = MediaGroupCursorUtils.getMediaGroupCursorForCategories(
-                                    categories, effectiveCloudAuthority);
+                                    categories, effectiveCloudAuthority, index);
                             break;
                         default:
                             Log.e(TAG, "Could not recognize pinned category type, skipping it : "
@@ -407,7 +455,10 @@ public class PickerDataLayerV2 {
                     cursor = null;
             }
 
-            allMediaGroupCursors.add(cursor);
+            if (cursor != null) {
+                index += cursor.getCount();
+                allMediaGroupCursors.add(cursor);
+            }
         }
 
         // Add cloud albums at the end.
@@ -415,9 +466,9 @@ public class PickerDataLayerV2 {
         // so that at a minimum, the local results are sent back to the UI.
         try {
             final Cursor cloudAlbumsCursor = getCloudAlbumsCursor(appContext, query,
-                    effectiveLocalAuthority, effectiveCloudAuthority);
+                    localAuthority, effectiveCloudAuthority);
             allMediaGroupCursors.add(
-                    MediaGroupCursorUtils.getMediaGroupCursorForAlbums(cloudAlbumsCursor));
+                    MediaGroupCursorUtils.getMediaGroupCursorForAlbums(cloudAlbumsCursor, index));
         } catch (RuntimeException ex) {
             Log.w(TAG, "Cloud provider exception while fetching cloud albums cursor", ex);
         }
@@ -528,6 +579,43 @@ public class PickerDataLayerV2 {
         );
     }
 
+    /**
+     * Returns a cursor with the cached content of a media set in response
+     * @param queryArgs The arguments to filter and fetch media set content
+     */
+    public static Cursor queryMediaInMediaSet(@NonNull Bundle queryArgs) {
+
+        requireNonNull(queryArgs);
+
+        MediaInMediaSetSyncRequestParams requestParams =
+                new MediaInMediaSetSyncRequestParams(queryArgs);
+        MediaInMediaSetsQuery query = new MediaInMediaSetsQuery(
+                queryArgs, requestParams.getMediaSetPickerId()
+        );
+
+        if (MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(query.getIntentAction())) {
+            throw new RuntimeException("Search feature cannot be enabled with PickerChoice. "
+                    + "Can't query MediaSet content");
+        }
+
+        PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final Set<String> providers = new HashSet<>(query.getProviders());
+        final String effectiveLocalAuthority = syncController
+                .getLocalProvider().equals(requestParams.getAuthority())
+                ? requestParams.getAuthority() : null;
+        String currentCloudAuthority = syncController.getCloudProviderOrDefault(
+                /*defaultValue*/ null);
+        final String effectiveCloudAuthority = syncController
+                .shouldQueryCloudMediaSets(providers, currentCloudAuthority)
+                ? currentCloudAuthority : null;
+
+        waitForOngoingMediaInMediaSetSync(effectiveLocalAuthority, effectiveCloudAuthority);
+
+        return MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                syncController, query, effectiveLocalAuthority, effectiveCloudAuthority);
+
+    }
+
     /**
      * Get search suggestions for a given prefix from the cloud media provider and search history.
      * In case cloud media provider is taking time in returning the suggestion results, we'll try to
@@ -596,7 +684,7 @@ public class PickerDataLayerV2 {
 
         try {
             cloudSearchSuggestions = cloudSuggestionsFuture.get(
-                    /* timeout */ 300, TimeUnit.MILLISECONDS);
+                    /* timeout */ 1500, TimeUnit.MILLISECONDS);
             cloudSuggestionsFuture.thenApplyAsync(
                     (suggestions) -> maybeCacheSearchSuggestions(query, suggestions),
                     executor);
@@ -646,13 +734,13 @@ public class PickerDataLayerV2 {
     }
 
     /**
-     * Queries the picker database and fetches the count of pre-granted media for the current
-     * package and userId.
+     * Queries the picker database and fetches the count of pre-granted media. Returns count of
+     * media either owned by the app or user has granted access to.
      *
      * @return a [Cursor] containing only one column [COLUMN_GRANTS_COUNT] which have a single
      * row representing the count.
      */
-    static Cursor fetchMediaGrantsCount(
+    static Cursor fetchCountForPreGrantedItems(
             @NonNull Context appContext,
             @NonNull Bundle queryArgs) {
         String[] projectionIn = new String[]{PROJECTION_GRANTS_COUNT};
@@ -667,8 +755,34 @@ public class PickerDataLayerV2 {
                 packageUid);
 
         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
-        qb.setTables(MEDIA_GRANTS_TABLE);
-        addWhereClausesForPackageAndUserIdSelection(userId, packageNames, MEDIA_GRANTS_TABLE, qb);
+        if (isOwnedPhotosEnabled(packageUid)) {
+            waitForOngoingSync(appContext, syncController.getLocalProvider(), null,
+                    MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP);
+
+            qb.setTables(MEDIA_LEFT_JOIN_MEDIA_GRANTS_TABLE);
+
+            String packageSelectionForMediaGrants = getPackageSelectionWhereClause(packageNames,
+                    MEDIA_GRANTS_TABLE).toString();
+            String packageSelectionForMedia = getPackageSelectionWhereClause(packageNames,
+                    MEDIA_TABLE).toString();
+
+            /*
+            (media.owner_package_name IN (com.android.example) AND media._user_id = 0) OR
+            (media_grants.owner_package_name IN (com.android.example) AND media_grants._user_id = 0)
+             */
+            String whereClause = String.format(Locale.ROOT,
+                    "(%s AND %s.%s = %d) OR (%s AND %s.%s = %d)",
+                    packageSelectionForMedia,
+                    MEDIA_TABLE, MediaStore.Files.FileColumns._USER_ID, userId,
+                    packageSelectionForMediaGrants,
+                    MEDIA_GRANTS_TABLE, PACKAGE_USER_ID_COLUMN, userId);
+
+            qb.appendWhereStandalone(whereClause);
+        } else {
+            qb.setTables(MEDIA_GRANTS_TABLE);
+            addWhereClausesForPackageAndUserIdSelection(userId, packageNames, MEDIA_GRANTS_TABLE,
+                    qb);
+        }
 
         Cursor result = qb.query(database, projectionIn, null,
                 null, null, null, null);
@@ -766,13 +880,65 @@ public class PickerDataLayerV2 {
         final SearchState searchState = PickerSyncController.getInstanceOrThrow().getSearchState();
 
         if (localAuthority != null) {
+            Log.d(TAG, "Waiting for local search results");
             SyncCompletionWaiter.waitForSyncWithTimeout(
                     SyncTrackerRegistry.getLocalSearchSyncTracker(), /* timeoutInMillis */ 500);
         }
 
+        if (cloudAuthority != null) {
+            Log.d(TAG, "Waiting for cloud search results");
+            SyncCompletionWaiter.waitForSyncWithTimeout(
+                    SyncTrackerRegistry.getCloudSearchSyncTracker(), /* timeoutInMillis */ 5000);
+        }
+    }
+
+    /**
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queried but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the cloud items should not be queried but the cloud
+     *                       authority has some value, the effective cloud authority would be null.
+     */
+    private static void waitForOngoingMediaInMediaSetSync(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        if (localAuthority != null && cloudAuthority != null) {
+            Log.w(TAG, "Media sets sync can only happen with either the local provider or a "
+                    + "cloud provider for a parent category. Please check the input providers.");
+        }
+        if (localAuthority != null) {
+            SyncCompletionWaiter.waitForSyncWithTimeout(
+                    SyncTrackerRegistry.getLocalMediaInMediaSetTracker(), /*timeoutInMillis*/ 500);
+        }
+        if (cloudAuthority != null) {
+            SyncCompletionWaiter.waitForSyncWithTimeout(
+                    SyncTrackerRegistry.getCloudMediaInMediaSetTracker(), /*timeoutInMillis*/ 5000);
+        }
+    }
+
+    /**
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queried but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the cloud items should not be queried but the cloud
+     *                       authority has some value, the effective cloud authority would be null.
+     */
+    private static void waitForOngoingMediaSetsSync(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        if (localAuthority != null && cloudAuthority != null) {
+            Log.w(TAG, "Media set contents sync can only happen with either the local provider or"
+                    + " a cloud provider for a parent category. Please check the input providers.");
+        }
+        if (localAuthority != null) {
+            SyncCompletionWaiter.waitForSyncWithTimeout(
+                    SyncTrackerRegistry.getLocalMediaSetsSyncTracker(), /*timeoutInMillis*/ 500);
+        }
         if (cloudAuthority != null) {
             SyncCompletionWaiter.waitForSyncWithTimeout(
-                    SyncTrackerRegistry.getCloudSearchSyncTracker(), /* timeoutInMillis */ 3000);
+                    SyncTrackerRegistry.getCloudMediaSetsSyncTracker(), /*timeoutInMillis*/ 2000);
         }
     }
 
@@ -915,7 +1081,10 @@ public class PickerDataLayerV2 {
             return null;
         }
 
+        Log.d(TAG, "Fetching albums from CMP " + cloudAuthority);
         final Cursor cursor = getAlbumsCursorFromProvider(appContext, query, cloudAuthority);
+
+        Log.d(TAG, "Received albums from CMP " + cloudAuthority);
         return cursor == null
                 ? null
                 : new AlbumsCursorWrapper(cursor, cloudAuthority, localAuthority);
@@ -963,6 +1132,18 @@ public class PickerDataLayerV2 {
                 Log.d(TAG, "Cannot fetch cloud categories when cloud authority is null.");
                 return null;
             }
+
+            try {
+                if (syncController.isFullSyncPending(cloudAuthority, /* isLocal */ false)) {
+                    Log.d(TAG, "Don't return cloud categories when full sync is pending.");
+                    return null;
+                }
+            } catch (RequestObsoleteException | RuntimeException e) {
+                Log.e(TAG, "Could not check if full sync is pending. "
+                        + "Not returning cloud categories", e);
+                return null;
+            }
+
             final PickerSearchProviderClient searchClient = PickerSearchProviderClient.create(
                     appContext, cloudAuthority);
             if (syncController.getCategoriesState().areCategoriesEnabled(
@@ -1142,24 +1323,39 @@ public class PickerDataLayerV2 {
     }
 
     /**
-     * Handle Picker application's request to create a new search request and return a Bundle with
-     * the search request Id.
+     * Handle Picker application's request to initialize search request media. If a new search
+     * request id needs to be created, return a Bundle with the search request Id.
+     *
      * Also trigger search results sync with the providers and saves the incoming search request in
-     * the search history table.
+     * the search history table if this is a new request.
+     *
+     * By default use ForkJoinPool.commonPool() for small background tasks to reduce resource
+     * usage instead of creating a custom pool. Its threads are slowly reclaimed during periods
+     * of non-use, and reinstated upon subsequent use.
      *
      * @param appContext Application context.
      * @param extras Bundle with input parameters.
      * @return a response Bundle.
      */
     @NonNull
-    public static Bundle handleNewSearchRequest(
+    public static Bundle handleSearchResultsInit(
             @NonNull Context appContext,
             @NonNull Bundle extras) {
-        // By default use ForkJoinPool.commonPool() to reduce resource usage instead of creating a
-        // custom pool. Its threads are slowly reclaimed during periods of non-use, and reinstated
-        // upon subsequent use.
-        return handleNewSearchRequest(appContext, extras, ForkJoinPool.commonPool(),
-                getWorkManager(appContext));
+        final int defaultSearchRequestId = -1;
+        final int inputSearchRequestId = extras.getInt("search_request_id", defaultSearchRequestId);
+        final WorkManager workManager = getWorkManager(appContext);
+
+        if (inputSearchRequestId == defaultSearchRequestId) {
+            Log.d(TAG, "New search request id needs to be created");
+
+            return handleNewSearchRequest(appContext, extras,
+                    ForkJoinPool.commonPool(), workManager);
+        } else {
+            Log.d(TAG, "Search request id already exists. Ensure that sync is complete for the "
+                    + "search request id.");
+
+            return ensureSearchResultsSynced(appContext, extras, workManager);
+        }
     }
 
     /**
@@ -1180,6 +1376,7 @@ public class PickerDataLayerV2 {
                                                 @NonNull Executor executor,
                                                 @NonNull WorkManager workManager) {
         requireNonNull(extras);
+        Log.d(TAG, "Received a new search request: " + extras);
 
         final SearchRequest searchRequest = SearchRequest.create(extras);
         final SQLiteDatabase database = PickerSyncController.getInstanceOrThrow().getDbFacade()
@@ -1198,13 +1395,113 @@ public class PickerDataLayerV2 {
                     executor);
 
             // Schedule search results sync
-            scheduleSearchResultsSync(appContext, searchRequest, searchRequestId, extras,
+            final Set<String> providers = new HashSet<>(
+                    Objects.requireNonNull(extras.getStringArrayList("providers")));
+            scheduleSearchResultsSync(appContext, searchRequest, searchRequestId, providers,
                     workManager);
 
+            Log.d(TAG, "Returning search request id: " + searchRequestId);
             return getSearchRequestInitResponse(searchRequestId);
         }
     }
 
+    /**
+     * Ensure that the search results are synced for the given search request id. If not,
+     * start or resume the sync for the search results. Both of these aspects are taken care of by
+     * scheduling a work request.
+     *
+     * @param appContext Application context.
+     * @param extras Bundle with input parameters.
+     * @param workManager An instance of {@link WorkManager}
+     * @return a response Bundle.
+     */
+    @NonNull
+    public static Bundle ensureSearchResultsSynced(@NonNull Context appContext,
+                                                @NonNull Bundle extras,
+                                                @NonNull WorkManager workManager) {
+        requireNonNull(extras);
+        Log.d(TAG, "Received a previously known search request again: " + extras);
+
+        final int searchRequestId = extras.getInt("search_request_id", -1);
+        final SearchRequest searchRequest = SearchRequest.create(extras);
+
+        // Schedule search results sync with REPLACE policy. This takes care of cancelling any
+        // existing search results sync that might be obsolete.
+        final Set<String> providers = new HashSet<>(
+                Objects.requireNonNull(extras.getStringArrayList("providers")));
+        scheduleSearchResultsSync(appContext, searchRequest, searchRequestId, providers,
+                workManager);
+
+        return getSearchRequestInitResponse(searchRequestId);
+    }
+
+    /**
+     * Handles Photopicker's request to trigger a sync for media items in a media set
+     * based on whether the provider implements search categories and media sets
+     * @param extras Bundle with all input parameters
+     * @param appContext The application context
+     */
+    public static void triggerMediaSyncForMediaSet(
+            @NonNull Bundle extras, @NonNull Context appContext) {
+        requireNonNull(extras);
+        requireNonNull(appContext);
+        triggerMediaSyncForMediaSet(extras, appContext, getWorkManager(appContext));
+    }
+
+    /**
+     * Handles Photopicker's request to trigger a sync for media items in a media set
+     * based on whether the provider implements search categories and media sets
+     * @param extras Bundle with all input parameters
+     * @param appContext The application context
+     * @param workManager An instance of {@link WorkManager}
+     */
+    public static void triggerMediaSyncForMediaSet(
+            @NonNull Bundle extras, @NonNull Context appContext, @NonNull WorkManager workManager) {
+        requireNonNull(extras);
+        requireNonNull(appContext);
+        requireNonNull(workManager);
+        MediaInMediaSetSyncRequestParams requestParams =
+                new MediaInMediaSetSyncRequestParams(extras);
+        final Set<String> providers = new HashSet<>(
+                Objects.requireNonNull(extras.getStringArrayList("providers")));
+        scheduleMediaInMediaSetSync(
+                requestParams, appContext, workManager, providers);
+    }
+
+    /**
+     * Schedules a sync of media items in the given media set for the local or cloud provider if t
+     * he corresponding provider implements Categories and MediaSets.
+     * @param context  The application context
+     * @param requestParams Wrapper object to hold all media in media set sync parameters
+     * @param providers Set of available providers
+     * @param workManager An instance of {@link WorkManager}
+     */
+    private static void scheduleMediaInMediaSetSync(
+            @NonNull MediaInMediaSetSyncRequestParams requestParams, @NonNull Context context,
+            @NonNull WorkManager workManager, @NonNull Set<String> providers) {
+
+        PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        PickerSyncManager syncManager = new PickerSyncManager(workManager, context);
+        int syncSource = Objects.equals(requestParams.getAuthority(),
+                syncController.getLocalProvider())
+                ? SYNC_LOCAL_ONLY : SYNC_CLOUD_ONLY;
+
+        // Sync MediaSet content only if the media sets can actually be queried
+        if (syncSource == SYNC_LOCAL_ONLY && syncController.shouldQueryLocalMediaSets(providers)) {
+            syncManager.syncMediaInMediaSetForProvider(
+                    requestParams, SYNC_LOCAL_ONLY);
+        } else if (syncController.shouldQueryCloudMediaSets(
+                providers, requestParams.getAuthority())) {
+            syncManager.syncMediaInMediaSetForProvider(
+                    requestParams, SYNC_CLOUD_ONLY);
+        } else {
+            Log.e(TAG, "Unidentified provider authority: " + requestParams.getAuthority()
+                    + " skipping MediaSet content sync.");
+        }
+    }
+
+
+
     /**
      * Handles Photopicker's request to trigger a sync for media sets for the given category
      * based on whether the providers implement search categories.
@@ -1229,7 +1526,6 @@ public class PickerDataLayerV2 {
             @NonNull Bundle extras, @NonNull Context appContext, @NonNull WorkManager workManager) {
 
         requireNonNull(workManager);
-
         MediaSetsSyncRequestParams mediaSetsSyncRequestParams =
                 new MediaSetsSyncRequestParams(extras);
         final Set<String> providers = new HashSet<>(
@@ -1238,6 +1534,59 @@ public class PickerDataLayerV2 {
         scheduleMediaSetsSync(appContext, mediaSetsSyncRequestParams, providers, workManager);
     }
 
+    /**
+     * Handle cloud media queries being disabled. This method is called from the critical path of
+     * updating the PickerDBFacade cloud provider. This method should not take a long time to
+     * execute and it should ensure that unexpected exceptions/failures don't cause any disruption.
+     * @param context The application context.
+     */
+    public static void handleCloudMediaReset(Context context) {
+        try {
+            if (Flags.enablePhotopickerSearch()) {
+                Log.d(TAG, "Cloud media reset detected. "
+                        + "Clear search results cache that has synced with a cloud media provider");
+
+                final PickerSyncManager syncManager =
+                        new PickerSyncManager(getWorkManager(context), context);
+                final String cloudAuthority = PickerSyncController.getInstanceOrThrow()
+                        .getCloudProviderOrDefault(null);
+                syncManager.resetCloudSearchCache(cloudAuthority);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Unexpected error occurred in handleCloudMediaReset", e);
+        }
+    }
+
+    /**
+     * @param context the application context.
+     * @return a bundle with the list of available provider authorities that support the
+     * search feature. If no providers are available, return an empty list in the bundle.
+     */
+    @NonNull
+    public static Bundle getSearchProviders(@NonNull Context context) {
+        Log.d(TAG, "Calculating available search providers.");
+
+        requireNonNull(context);
+
+        // Check the state of cloud and local search.
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final String cloudProvider = syncController.getCloudProviderOrDefault(null);
+        final boolean isCloudSearchEnabled =
+                syncController.getSearchState().isCloudSearchEnabled(context, cloudProvider);
+        final boolean isLocalSearchEnabled = syncController.getSearchState().isLocalSearchEnabled();
+
+        // Prepare a bundle response with the result.
+        final ArrayList<String> searchProviderAuthorities = new ArrayList<>();
+        if (isCloudSearchEnabled) searchProviderAuthorities.add(cloudProvider);
+        if (isLocalSearchEnabled) searchProviderAuthorities.add(syncController.getLocalProvider());
+
+        final Bundle result = new Bundle();
+        result.putStringArrayList(
+                PickerSQLConstants.EXTRA_SEARCH_PROVIDER_AUTHORITIES, searchProviderAuthorities);
+        Log.d(TAG, "Available search providers are: " + result);
+        return result;
+    }
+
     /**
      * Schedules MediaSets sync for both local and cloud provider if the corresponding
      * providers implement Categories.
@@ -1281,14 +1630,18 @@ public class PickerDataLayerV2 {
             @NonNull Context appContext,
             @NonNull SearchRequest searchRequest,
             int searchRequestId,
-            @NonNull Bundle extras,
+            @NonNull Set<String> providers,
             WorkManager workManager) {
         final PickerSyncManager syncManager = new PickerSyncManager(workManager, appContext);
-        final Set<String> providers = new HashSet<>(
-                Objects.requireNonNull(extras.getStringArrayList("providers")));
 
-        scheduleSyncWithLocalProvider(searchRequest, searchRequestId, syncManager, providers);
-        scheduleSyncWithCloudProvider(searchRequest, searchRequestId, syncManager, providers);
+        final boolean localSyncWasScheduled = scheduleSearchSyncWithLocalProvider(
+                searchRequest, searchRequestId, syncManager, providers);
+        final boolean cloudSyncWasScheduled = scheduleSearchSyncWithCloudProvider(
+                searchRequest, searchRequestId, syncManager, providers);
+
+        if (localSyncWasScheduled || cloudSyncWasScheduled) {
+            syncManager.delayedResetSearchCache();
+        }
     }
 
     /**
@@ -1300,8 +1653,9 @@ public class PickerDataLayerV2 {
      * @param syncManager An instance of PickerSyncManager that helps us schedule work manager
      *                    sync requests.
      * @param providers Set of valid providers we can sync search results from.
+     * @return True if the sync was schedules, else returns false.
      */
-    private static void scheduleSyncWithLocalProvider(
+    private static boolean scheduleSearchSyncWithLocalProvider(
             @NonNull SearchRequest searchRequest,
             int searchRequestId,
             @NonNull PickerSyncManager syncManager,
@@ -1312,7 +1666,7 @@ public class PickerDataLayerV2 {
             Log.d(TAG, "Search is not enabled for the current local authority. "
                     + "Not syncing search results with local provider for request id "
                     + searchRequestId);
-            return;
+            return false;
         }
 
         if (searchRequest instanceof SearchSuggestionRequest) {
@@ -1323,15 +1677,17 @@ public class PickerDataLayerV2 {
                     Log.d(TAG, "Album search suggestion does not belong to local provider. "
                             + "Not syncing search results with local provider for request id "
                             + searchRequestId);
-                    return;
+                    return false;
                 }
             }
         }
 
+        Log.d(TAG, "Scheduling search results sync with local provider: " + searchRequestId);
         syncManager.syncSearchResultsForProvider(
                 searchRequestId,
-                PickerSyncManager.SYNC_LOCAL_ONLY,
+                SYNC_LOCAL_ONLY,
                 syncController.getLocalProvider());
+        return true;
     }
 
     /**
@@ -1343,8 +1699,9 @@ public class PickerDataLayerV2 {
      * @param syncManager An instance of PickerSyncManager that helps us schedule work manager
      *                    sync requests.
      * @param providers Set of valid providers we can sync search results from.
+     * @return True if the sync was schedules, else returns false.
      */
-    private static void scheduleSyncWithCloudProvider(
+    private static boolean scheduleSearchSyncWithCloudProvider(
             @NonNull SearchRequest searchRequest,
             int searchRequestId,
             @NonNull PickerSyncManager syncManager,
@@ -1357,7 +1714,7 @@ public class PickerDataLayerV2 {
             Log.d(TAG, "Search is not enabled for the current cloud authority. "
                     + "Not syncing search results with cloud provider for request id "
                     + searchRequestId);
-            return;
+            return false;
         }
 
         if (searchRequest instanceof SearchSuggestionRequest) {
@@ -1368,15 +1725,17 @@ public class PickerDataLayerV2 {
                     Log.d(TAG, "Album search suggestion does not belong to cloud provider. "
                             + "Not syncing search results with cloud provider for request id "
                             + searchRequestId);
-                    return;
+                    return false;
                 }
             }
         }
 
+        Log.d(TAG, "Scheduling search results sync with cloud provider: " + searchRequestId);
         syncManager.syncSearchResultsForProvider(
                 searchRequestId,
-                PickerSyncManager.SYNC_CLOUD_ONLY,
+                SYNC_CLOUD_ONLY,
                 cloudAuthority);
+        return true;
     }
 
     /**
@@ -1386,7 +1745,7 @@ public class PickerDataLayerV2 {
     @NonNull
     private static Bundle getSearchRequestInitResponse(int searchRequestId) {
         final Bundle response = new Bundle();
-        response.putInt("search_request_id", searchRequestId);
+        response.putInt(PickerSQLConstants.EXTRA_SEARCH_REQUEST_ID, searchRequestId);
         return response;
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/PickerNotificationSender.java b/src/com/android/providers/media/photopicker/v2/PickerNotificationSender.java
index 3fe9770db..eb5d97125 100644
--- a/src/com/android/providers/media/photopicker/v2/PickerNotificationSender.java
+++ b/src/com/android/providers/media/photopicker/v2/PickerNotificationSender.java
@@ -19,8 +19,11 @@ package com.android.providers.media.photopicker.v2;
 import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.ALBUM_PATH_SEGMENT;
 import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.AVAILABLE_PROVIDERS_PATH_SEGMENT;
 import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.MEDIA_PATH_SEGMENT;
+import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.MEDIA_SETS_PATH_SEGMENT;
+import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.MEDIA_SET_CONTENTS_PATH_SEGMENT;
 import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.PICKER_INTERNAL_PATH_SEGMENT;
 import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.PICKER_V2_PATH_SEGMENT;
+import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.SEARCH_RESULT_MEDIA_PATH_SEGMENT;
 import static com.android.providers.media.photopicker.v2.PickerUriResolverV2.UPDATE_PATH_SEGMENT;
 
 import static java.util.Objects.requireNonNull;
@@ -72,6 +75,33 @@ public class PickerNotificationSender {
             .appendPath(UPDATE_PATH_SEGMENT)
             .build();
 
+    private static final Uri SEARCH_RESULTS_UPDATE_URI = new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_CONTENT)
+            .authority(MediaStore.AUTHORITY)
+            .appendPath(PICKER_INTERNAL_PATH_SEGMENT)
+            .appendPath(PICKER_V2_PATH_SEGMENT)
+            .appendPath(SEARCH_RESULT_MEDIA_PATH_SEGMENT)
+            .appendPath(UPDATE_PATH_SEGMENT)
+            .build();
+
+    private static final Uri MEDIA_SETS_UPDATE_URI = new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_CONTENT)
+            .authority(MediaStore.AUTHORITY)
+            .appendPath(PICKER_INTERNAL_PATH_SEGMENT)
+            .appendPath(PICKER_V2_PATH_SEGMENT)
+            .appendPath(MEDIA_SETS_PATH_SEGMENT)
+            .appendPath(UPDATE_PATH_SEGMENT)
+            .build();
+
+    private static final Uri MEDIA_SET_CONTENT_UPDATE_URI = new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_CONTENT)
+            .authority(MediaStore.AUTHORITY)
+            .appendPath(PICKER_INTERNAL_PATH_SEGMENT)
+            .appendPath(PICKER_V2_PATH_SEGMENT)
+            .appendPath(MEDIA_SET_CONTENTS_PATH_SEGMENT)
+            .appendPath(UPDATE_PATH_SEGMENT)
+            .build();
+
     /**
      * Send media update notification to the registered {@link android.database.ContentObserver}-s.
      * @param context The application context.
@@ -126,6 +156,64 @@ public class PickerNotificationSender {
         }
     }
 
+    /**
+     * Send search results update notification to the registered
+     * {@link android.database.ContentObserver}-s.
+     * @param context The application context.
+     * @param searchRequestId Search request ID corresponding for which the search results
+     *                        have updated.
+     */
+    public static void notifySearchResultsChange(
+            @NonNull Context context,
+            int searchRequestId) {
+        Log.d(TAG, "Sending a notification for search results update " + searchRequestId);
+        context.getContentResolver().notifyChange(
+                getSearchResultsUpdateUri(searchRequestId),
+                /* observer= */ null);
+    }
+
+    /**
+     * Send media sets update notification to the registered
+     * {@link android.database.ContentObserver}-s.
+     * @param context The application context.
+     * @param categoryId Category ID for which the media sets have updated.
+     */
+    public static void notifyMediaSetsChange(
+            @NonNull Context context,
+            @NonNull String categoryId) {
+        requireNonNull(context);
+        requireNonNull(categoryId);
+        Log.d(TAG, "Sending notification for media sets update for the "
+                + "given categoryId " + categoryId);
+        context.getContentResolver().notifyChange(
+                getMediaSetsUpdateUri(categoryId), /* observer */ null
+        );
+    }
+
+    private static Uri getMediaSetsUpdateUri(@NonNull String categoryId) {
+        return MEDIA_SETS_UPDATE_URI
+                .buildUpon()
+                .appendPath(categoryId)
+                .build();
+    }
+
+    /**
+     * Send media set content update notification to the registered
+     * {@link android.database.ContentObserver}-s.
+     * @param context The application context.
+     * @param mediaSetId MediaSet ID for which the media content has updated.
+     */
+    public static void notifyMediaSetContentChange(
+            @NonNull Context context, @NonNull String mediaSetId) {
+        requireNonNull(context);
+        requireNonNull(mediaSetId);
+        Log.d(TAG, "Sending notification for media set content update for the "
+                + "given mediaSet " + mediaSetId);
+        context.getContentResolver().notifyChange(
+                getMediaSetContentUpdateUri(mediaSetId), /* observer */ null
+        );
+    }
+
     private static Uri getAlbumMediaUpdateUri(
             @NonNull String albumAuthority,
             @NonNull String albumId) {
@@ -135,4 +223,18 @@ public class PickerNotificationSender {
                 .appendPath(requireNonNull(albumId))
                 .build();
     }
+
+    private static Uri getSearchResultsUpdateUri(int searchRequestId) {
+        return SEARCH_RESULTS_UPDATE_URI
+                .buildUpon()
+                .appendPath(Integer.toString(searchRequestId))
+                .build();
+    }
+
+    private static Uri getMediaSetContentUpdateUri(@NonNull String mediaSetId) {
+        return MEDIA_SET_CONTENT_UPDATE_URI
+                .buildUpon()
+                .appendPath(mediaSetId)
+                .build();
+    }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java b/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java
index 3667c7631..1f1385fef 100644
--- a/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java
+++ b/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java
@@ -23,6 +23,7 @@ import android.content.UriMatcher;
 import android.database.Cursor;
 import android.net.Uri;
 import android.os.Bundle;
+import android.os.CancellationSignal;
 import android.provider.MediaStore;
 
 import androidx.annotation.IntDef;
@@ -41,11 +42,15 @@ public class PickerUriResolverV2 {
     public static final String COLLECTION_INFO_PATH_SEGMENT = "collection_info";
     public static final String MEDIA_PATH_SEGMENT = "media";
     public static final String ALBUM_PATH_SEGMENT = "album";
+    public static final String SEARCH_RESULT_MEDIA_PATH_SEGMENT = "search_media";
     public static final String UPDATE_PATH_SEGMENT = "update";
     private static final String MEDIA_GRANTS_COUNT_PATH_SEGMENT = "media_grants_count";
     private static final String PREVIEW_PATH_SEGMENT = "preview";
     private static final String PRE_SELECTION_PATH_SEGMENT = "pre_selection";
-    private static final String SEARCH_RESULT_MEDIA_PATH_SEGMENT = "search_media";
+    private static final String SEARCH_SUGGESTIONS_PATH_SEGMENT = "search_suggestions";
+    private static final String CATEGORIES_PATH_SEGMENT = "categories";
+    public static final String MEDIA_SETS_PATH_SEGMENT = "media_sets";
+    public static final String MEDIA_SET_CONTENTS_PATH_SEGMENT = "media_set_contents";
 
 
     static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
@@ -58,6 +63,10 @@ public class PickerUriResolverV2 {
     static final int PICKER_INTERNAL_MEDIA_PREVIEW = 7;
     static final int PICKER_INTERNAL_PRE_SELECTION = 8;
     static final int PICKER_INTERNAL_SEARCH_MEDIA = 9;
+    static final int PICKER_INTERNAL_SEARCH_SUGGESTIONS = 10;
+    static final int PICKER_INTERNAL_CATEGORIES = 11;
+    static final int PICKER_INTERNAL_MEDIA_SETS = 12;
+    static final int PICKER_INTERNAL_MEDIA_SET_CONTENTS = 13;
 
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
@@ -71,6 +80,10 @@ public class PickerUriResolverV2 {
             PICKER_INTERNAL_MEDIA_PREVIEW,
             PICKER_INTERNAL_PRE_SELECTION,
             PICKER_INTERNAL_SEARCH_MEDIA,
+            PICKER_INTERNAL_SEARCH_SUGGESTIONS,
+            PICKER_INTERNAL_CATEGORIES,
+            PICKER_INTERNAL_MEDIA_SETS,
+            PICKER_INTERNAL_MEDIA_SET_CONTENTS
     })
     private @interface PickerQuery {}
 
@@ -107,6 +120,18 @@ public class PickerUriResolverV2 {
                 BASE_PICKER_PATH + SEARCH_RESULT_MEDIA_PATH_SEGMENT + "/*",
                 PICKER_INTERNAL_SEARCH_MEDIA
         );
+        sUriMatcher.addURI(MediaStore.AUTHORITY,
+                BASE_PICKER_PATH + SEARCH_SUGGESTIONS_PATH_SEGMENT,
+                PICKER_INTERNAL_SEARCH_SUGGESTIONS);
+        sUriMatcher.addURI(MediaStore.AUTHORITY,
+                BASE_PICKER_PATH + CATEGORIES_PATH_SEGMENT,
+                PICKER_INTERNAL_CATEGORIES);
+        sUriMatcher.addURI(MediaStore.AUTHORITY,
+                BASE_PICKER_PATH + MEDIA_SETS_PATH_SEGMENT,
+                PICKER_INTERNAL_MEDIA_SETS);
+        sUriMatcher.addURI(MediaStore.AUTHORITY,
+                BASE_PICKER_PATH + MEDIA_SET_CONTENTS_PATH_SEGMENT,
+                PICKER_INTERNAL_MEDIA_SET_CONTENTS);
     }
 
     /**
@@ -117,7 +142,8 @@ public class PickerUriResolverV2 {
     public static Cursor query(
             @NonNull Context appContext,
             @NonNull Uri uri,
-            @Nullable Bundle queryArgs) {
+            @Nullable Bundle queryArgs,
+            @Nullable CancellationSignal cancellationSignal) {
         @PickerQuery
         final int query = sUriMatcher.match(uri);
 
@@ -137,7 +163,7 @@ public class PickerUriResolverV2 {
             case PICKER_INTERNAL_COLLECTION_INFO:
                 return PickerDataLayerV2.queryCollectionInfo();
             case PICKER_INTERNAL_MEDIA_GRANTS_COUNT:
-                return PickerDataLayerV2.fetchMediaGrantsCount(appContext,
+                return PickerDataLayerV2.fetchCountForPreGrantedItems(appContext,
                         requireNonNull(queryArgs));
             case PICKER_INTERNAL_MEDIA_PREVIEW:
                 return PickerDataLayerV2.queryPreviewMedia(appContext, queryArgs);
@@ -150,6 +176,20 @@ public class PickerUriResolverV2 {
                         appContext,
                         requireNonNull(queryArgs),
                         searchRequestId);
+            case PICKER_INTERNAL_SEARCH_SUGGESTIONS:
+                return PickerDataLayerV2.querySearchSuggestions(
+                        appContext,
+                        requireNonNull(queryArgs),
+                        cancellationSignal);
+            case PICKER_INTERNAL_CATEGORIES:
+                return PickerDataLayerV2.queryCategoriesAndAlbums(
+                        appContext,
+                        requireNonNull(queryArgs),
+                        cancellationSignal);
+            case PICKER_INTERNAL_MEDIA_SETS:
+                return PickerDataLayerV2.queryMediaSets(requireNonNull(queryArgs));
+            case PICKER_INTERNAL_MEDIA_SET_CONTENTS:
+                return PickerDataLayerV2.queryMediaInMediaSet(requireNonNull(queryArgs));
             default:
                 throw new UnsupportedOperationException("Could not recognize content URI " + uri);
         }
diff --git a/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java b/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java
index 80f2e1b51..2c5b39f67 100644
--- a/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java
+++ b/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java
@@ -106,7 +106,7 @@ public class SearchSuggestionsProvider {
                 PickerSQLConstants.SearchSuggestionsResponseColumns.MEDIA_SET_ID.getProjection(),
                 PickerSQLConstants.SearchSuggestionsResponseColumns.SEARCH_TEXT.getProjection(),
                 PickerSQLConstants.SearchSuggestionsResponseColumns.SUGGESTION_TYPE.getProjection(),
-                PickerSQLConstants.SearchSuggestionsResponseColumns.COVER_MEDIA_ID.getProjection()
+                PickerSQLConstants.SearchSuggestionsResponseColumns.COVER_MEDIA_URI.getProjection()
         ).toArray(new String[5]));
 
         for (SearchSuggestion suggestion : suggestions) {
diff --git a/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java b/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java
index ca82f6db4..a11035868 100644
--- a/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java
+++ b/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java
@@ -121,15 +121,15 @@ public class AlbumsCursorWrapper extends CursorWrapper {
                 return mCoverAuthority;
 
             case UNWRAPPED_COVER_URI:
-                // TODO(b/317118334): Use local copy of the cover image when available.
                 final String mediaId = getMediaIdFromWrappedCursor();
+
                 if (EMPTY_MEDIA_ID.equals(mediaId)) {
                     return Uri.EMPTY.toString();
                 } else {
                     return PickerUriResolver
                             .getMediaUri(getEncodedUserAuthority(mCoverAuthority))
                             .buildUpon()
-                            .appendPath(getMediaIdFromWrappedCursor())
+                            .appendPath(mediaId)
                             .build()
                             .toString();
                 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/MediaInMediaSetSyncRequestParams.java b/src/com/android/providers/media/photopicker/v2/model/MediaInMediaSetSyncRequestParams.java
new file mode 100644
index 000000000..9e296ec63
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/MediaInMediaSetSyncRequestParams.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+
+import java.util.Objects;
+
+public class MediaInMediaSetSyncRequestParams {
+    public static final String KEY_PARENT_MEDIA_SET_AUTHORITY = "media_set_picker_authority";
+    public static final String KEY_PARENT_MEDIA_SET_PICKER_ID = "media_set_picker_id";
+    private final String mAuthority;
+    private final Long mMediaSetPickerId;
+
+    public MediaInMediaSetSyncRequestParams(@NonNull Bundle extras) {
+        Objects.requireNonNull(extras);
+        mAuthority = extras.getString(KEY_PARENT_MEDIA_SET_AUTHORITY);
+        mMediaSetPickerId = extras.getLong(KEY_PARENT_MEDIA_SET_PICKER_ID);
+        Objects.requireNonNull(mAuthority);
+    }
+
+    public String getAuthority() {
+        return mAuthority;
+    }
+
+    public Long getMediaSetPickerId() {
+        return mMediaSetPickerId;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java b/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java
index 821306bc3..cc737f9cf 100644
--- a/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java
+++ b/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java
@@ -20,6 +20,7 @@ import android.os.Bundle;
 
 import androidx.annotation.NonNull;
 
+import java.util.List;
 import java.util.Objects;
 
 /*
@@ -27,16 +28,19 @@ import java.util.Objects;
  provider.
  */
 public class MediaSetsSyncRequestParams {
+    public static final String KEY_PARENT_CATEGORY_AUTHORITY = "parent_category_authority";
+    public static final String KEY_MIME_TYPES = "mime_types";
+    public static final String KEY_PARENT_CATEGORY_ID = "parent_category_id";
 
     private final String mAuthority;
     private final String mCategoryId;
-    private final String[] mMimeTypes;
+    private final List<String> mMimeTypes;
 
     public MediaSetsSyncRequestParams(@NonNull Bundle extras) {
         Objects.requireNonNull(extras);
-        mAuthority = extras.getString("authority");
-        mMimeTypes = extras.getStringArray("mime_types");
-        mCategoryId = extras.getString("category_id");
+        mAuthority = extras.getString(KEY_PARENT_CATEGORY_AUTHORITY);
+        mMimeTypes = extras.getStringArrayList(KEY_MIME_TYPES);
+        mCategoryId = extras.getString(KEY_PARENT_CATEGORY_ID);
     }
 
     public String getAuthority() {
@@ -47,7 +51,7 @@ public class MediaSetsSyncRequestParams {
         return mCategoryId;
     }
 
-    public String[] getMimeTypes() {
+    public List<String> getMimeTypes() {
         return mMimeTypes;
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java b/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java
index b1797ace1..d485ac8c0 100644
--- a/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java
@@ -20,6 +20,7 @@ import static com.android.providers.media.MediaGrants.FILE_ID_COLUMN;
 import static com.android.providers.media.MediaGrants.MEDIA_GRANTS_TABLE;
 import static com.android.providers.media.MediaGrants.OWNER_PACKAGE_NAME_COLUMN;
 import static com.android.providers.media.MediaGrants.PACKAGE_USER_ID_COLUMN;
+import static com.android.providers.media.MediaProvider.isOwnedPhotosEnabled;
 import static com.android.providers.media.photopicker.PickerSyncController.getPackageNameFromUid;
 import static com.android.providers.media.photopicker.PickerSyncController.uidToUserId;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
@@ -54,15 +55,16 @@ import java.util.Objects;
 public class PreviewMediaQuery extends MediaQuery {
     private final ArrayList<String> mCurrentSelection;
     private final ArrayList<String> mCurrentDeSelection;
+    private final String[] mCallingPackageNames;
 
-    public PreviewMediaQuery(
-            @NonNull Bundle queryArgs) {
+    public PreviewMediaQuery(@NonNull Bundle queryArgs, @NonNull Context context) {
         super(queryArgs);
 
         // This is not required for preview.
         mShouldPopulateItemsBeforeCount = false;
         mCurrentSelection = queryArgs.getStringArrayList("current_selection");
         mCurrentDeSelection = queryArgs.getStringArrayList("current_de_selection");
+        mCallingPackageNames = getPackageNameFromUid(context, getCallingPackageUid());
     }
 
     public ArrayList<String> getCurrentSelection() {
@@ -83,10 +85,11 @@ public class PreviewMediaQuery extends MediaQuery {
     ) {
         super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
 
-        addIdSelectionClause(queryBuilder);
+        addIdSelectionClause(queryBuilder, table.name());
     }
 
-    private void addIdSelectionClause(@NonNull SelectSQLiteQueryBuilder queryBuilder) {
+    private void addIdSelectionClause(@NonNull SelectSQLiteQueryBuilder queryBuilder,
+            String table) {
         StringBuilder idSelectionPlaceholder = new StringBuilder();
         if (mCurrentSelection != null && !mCurrentSelection.isEmpty()) {
             idSelectionPlaceholder.append("local_id IN  (");
@@ -99,14 +102,34 @@ public class PreviewMediaQuery extends MediaQuery {
             idSelectionPlaceholder.append(" OR ");
         }
 
-        idSelectionPlaceholder.append(
-                String.format(
-                        Locale.ROOT,
-                        "(%s.%s IS NOT NULL AND %s.%s IS NULL)",
-                        // current_media_grants.file_id IS NOT NULL
-                        CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN,
-                        // current_de_selections.file_id IS NULL
-                        CURRENT_DE_SELECTIONS_TABLE, MediaGrants.FILE_ID_COLUMN));
+        if (isOwnedPhotosEnabled(getCallingPackageUid())) {
+            StringBuilder packageSelection =
+                    getPackageSelectionWhereClause(mCallingPackageNames, table);
+            int userId = uidToUserId(getCallingPackageUid());
+
+            /*
+             (current_media_grants.file_id IS NOT NULL OR
+             (media.owner_package_name IN (com.android.example) AND media._user_id = 0))
+             AND current_de_selections.file_id IS NULL)
+             */
+            String selectionQueryForPreviewMode =  String.format(Locale.ROOT,
+                    "((%s.%s IS NOT NULL OR (%s AND %s.%s = %d)) AND %s.%s IS NULL)",
+                    CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN,
+                    packageSelection, table, "_user_id", userId,
+                    CURRENT_DE_SELECTIONS_TABLE, MediaGrants.FILE_ID_COLUMN);
+
+            idSelectionPlaceholder.append(selectionQueryForPreviewMode);
+        } else {
+            idSelectionPlaceholder.append(
+                    String.format(
+                            Locale.ROOT,
+                            "(%s.%s IS NOT NULL AND %s.%s IS NULL)",
+                            // current_media_grants.file_id IS NOT NULL
+                            CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN,
+                            // current_de_selections.file_id IS NULL
+                            CURRENT_DE_SELECTIONS_TABLE, MediaGrants.FILE_ID_COLUMN));
+        }
+
         queryBuilder.appendWhereStandalone(idSelectionPlaceholder.toString());
     }
 
@@ -222,9 +245,14 @@ public class PreviewMediaQuery extends MediaQuery {
                     qb.insert(database, cv);
                 }
             }
-            database.setTransactionSuccessful();
+
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
         } finally {
-            database.endTransaction();
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
         }
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java b/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java
index c4478aac9..38f325711 100644
--- a/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java
@@ -38,10 +38,18 @@ public abstract class SearchRequest {
     @Nullable
     protected final List<String> mMimeTypes;
     @Nullable
-    protected String mResumeKey;
+    protected String mLocalSyncResumeKey;
+    @Nullable
+    protected String mLocalAuthority;
+    @Nullable
+    protected String mCloudSyncResumeKey;
+    @Nullable
+    protected String mCloudAuthority;
 
     /**
-     * Creates an instance of {@link SearchRequest}.
+     * Creates an instance of {@link SearchRequest} with resume keys set as null.
+     * Only use this method to create a new search request item that has not been synced with the
+     * CMPs yet.
      *
      * @param extras Bundle with input parameters.
      * @return A new instance of {@link SearchRequest}.
@@ -49,7 +57,8 @@ public abstract class SearchRequest {
     public static SearchRequest create(Bundle extras) {
         final List<String> mimeTypes = extras.getStringArrayList("mime_types") != null
                 ? new ArrayList<>(extras.getStringArrayList("mime_types")) : null;
-        final String searchText = extras.getString("search_text");
+        final String rawSearchText = extras.getString("search_text");
+        final String searchText = rawSearchText == null ? null : rawSearchText.trim();
         final String mediaSetId = extras.getString("media_set_id");
         final String suggestionAuthority = extras.getString("authority");
         final String searchSuggestionType = extras.getString("search_suggestion_type");
@@ -60,8 +69,7 @@ public abstract class SearchRequest {
                 searchText,
                 mediaSetId,
                 suggestionAuthority,
-                searchSuggestionType,
-                /* resumeKey */ null
+                searchSuggestionType
             );
         } else {
             return new SearchTextRequest(
@@ -71,23 +79,12 @@ public abstract class SearchRequest {
         }
     }
 
-    protected SearchRequest(@Nullable List<String> rawMimeTypes) {
-        this (
-                rawMimeTypes,
-                /* resumeKey */ null
-        );
-    }
-
-    protected SearchRequest(
-            @Nullable String rawMimeTypes,
-            @Nullable String resumeKey
-    ) {
-        this (getMimeTypesAsList(rawMimeTypes), resumeKey);
-    }
-
     protected SearchRequest(
             @Nullable List<String> rawMimeTypes,
-            @Nullable String resumeKey
+            @Nullable String localSyncResumeKey,
+            @Nullable String localAuthority,
+            @Nullable String cloudSyncResumeKey,
+            @Nullable String cloudAuthority
     ) {
         if (rawMimeTypes != null) {
             mMimeTypes = new ArrayList<>();
@@ -99,7 +96,10 @@ public abstract class SearchRequest {
             mMimeTypes = null;
         }
 
-        mResumeKey = resumeKey;
+        mLocalSyncResumeKey = localSyncResumeKey;
+        mLocalAuthority = localAuthority;
+        mCloudSyncResumeKey = cloudSyncResumeKey;
+        mCloudAuthority = cloudAuthority;
     }
 
     /**
@@ -136,15 +136,44 @@ public abstract class SearchRequest {
     }
 
     @Nullable
-    public String getResumeKey() {
-        return mResumeKey;
+    public String getLocalSyncResumeKey() {
+        return mLocalSyncResumeKey;
+    }
+
+    /**
+     * Set the local sync resume key for a given search request.
+     */
+    public void setLocalSyncResumeKey(
+            @Nullable String localSyncResumeKey) {
+        this.mLocalSyncResumeKey = localSyncResumeKey;
+    }
+
+    public String getLocalAuthority() {
+        return mLocalAuthority;
+    }
+
+    public void setLocalAuthority(String mCloudAuthority) {
+        this.mCloudAuthority = mCloudAuthority;
+    }
+
+    @Nullable
+    public String getCloudSyncResumeKey() {
+        return mCloudSyncResumeKey;
     }
 
     /**
-     * Set the resume key for a given search request.
+     * Set the cloud sync resume key for a given search request.
      */
-    public void setResumeKey(@Nullable String mResumeKey) {
-        this.mResumeKey = mResumeKey;
+    public void setCloudResumeKey(@Nullable String cloudSyncResumeKey) {
+        this.mCloudSyncResumeKey = cloudSyncResumeKey;
+    }
+
+    public String getCloudAuthority() {
+        return mCloudAuthority;
+    }
+
+    public void setCloudAuthority(String mCloudAuthority) {
+        this.mCloudAuthority = mCloudAuthority;
     }
 }
 
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java
index d72de686d..9d6823b45 100644
--- a/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java
@@ -32,7 +32,6 @@ public class SearchSuggestion {
     private final String mMediaSetId;
     @Nullable
     private final String mAuthority;
-    @SearchSuggestionType
     private final String mSearchSuggestionType;
     @Nullable
     private final String mCoverMediaId;
@@ -74,4 +73,12 @@ public class SearchSuggestion {
     public String getCoverMediaId() {
         return mCoverMediaId;
     }
+
+    @Override
+    public String toString() {
+        // Intentionally left out search text from logging because that may contain
+        // sensitive information.
+        return "SearchSuggestion{mediaSetId=" + mMediaSetId + ",authority=" + mAuthority
+                + ",type=" + mSearchSuggestionType + ",coverMediaId=" + mCoverMediaId + "}";
+    }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java
index 3c4e023fa..ccd83f830 100644
--- a/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java
@@ -33,25 +33,47 @@ public class SearchSuggestionRequest extends SearchRequest {
     public SearchSuggestionRequest(
             @Nullable List<String> mimeTypes,
             @Nullable String searchText,
-            @NonNull String mediaSetId,
-            @NonNull String authority,
+            @Nullable String mediaSetId,
+            @Nullable String suggestionAuthority,
+            @SearchSuggestionType String searchSuggestionType
+    ) {
+        this(mimeTypes, searchText, mediaSetId, suggestionAuthority, searchSuggestionType,
+                /* localSyncResumeKey */ null,
+                /* localAuthority */ null,
+                /* cloudSyncResumeKey */ null,
+                /* cloudAuthority */ null);
+    }
+
+    public SearchSuggestionRequest(
+            @Nullable List<String> mimeTypes,
+            @Nullable String searchText,
+            @Nullable String mediaSetId,
+            @Nullable String suggestionAuthority,
             @SearchSuggestionType String searchSuggestionType,
-            @Nullable String resumeKey) {
-        this(mimeTypes, searchText, mediaSetId, authority, searchSuggestionType, resumeKey,
+            @Nullable String localSyncResumeKey,
+            @Nullable String localAuthority,
+            @Nullable String cloudSyncResumeKey,
+            @Nullable String cloudAuthority
+    ) {
+        this(mimeTypes, searchText, mediaSetId, suggestionAuthority, searchSuggestionType,
+                localSyncResumeKey, localAuthority, cloudSyncResumeKey, cloudAuthority,
                 /* coverMediaSetId */ null);
     }
 
     public SearchSuggestionRequest(
             @Nullable List<String> mimeTypes,
             @Nullable String searchText,
-            @NonNull String mediaSetId,
-            @NonNull String authority,
+            @Nullable String mediaSetId,
+            @Nullable String suggestionAuthority,
             @SearchSuggestionType String searchSuggestionType,
-            @Nullable String resumeKey,
+            @Nullable String localSyncResumeKey,
+            @Nullable String localAuthority,
+            @Nullable String cloudSyncResumeKey,
+            @Nullable String cloudAuthority,
             @Nullable String coverMediaId) {
-        super(mimeTypes, resumeKey);
+        super(mimeTypes, localSyncResumeKey, localAuthority, cloudSyncResumeKey, cloudAuthority);
 
-        mSearchSuggestion = new SearchSuggestion(searchText, mediaSetId, authority,
+        mSearchSuggestion = new SearchSuggestion(searchText, mediaSetId, suggestionAuthority,
                 searchSuggestionType, coverMediaId);
     }
 
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java b/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java
index 4306d7732..9393ae9fa 100644
--- a/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java
@@ -34,16 +34,21 @@ public class SearchTextRequest extends SearchRequest {
     public SearchTextRequest(
             @Nullable List<String> mimeTypes,
             @NonNull String searchText) {
-        super(mimeTypes);
-
-        mSearchText = requireNonNull(searchText);
+        this(mimeTypes, searchText,
+                /* localSyncResumeKey */ null,
+                /* localAuthority */ null,
+                /* cloudSyncResumeKey */ null,
+                /* cloudAuthority */ null);
     }
 
     public SearchTextRequest(
             @Nullable List<String> mimeTypes,
             @NonNull String searchText,
-            @Nullable String resumeKey) {
-        super(mimeTypes, resumeKey);
+            @Nullable String localSyncResumeKey,
+            @Nullable String localAuthority,
+            @Nullable String cloudSyncResumeKey,
+            @Nullable String cloudAuthority) {
+        super(mimeTypes, localSyncResumeKey, localAuthority, cloudSyncResumeKey, cloudAuthority);
 
         mSearchText = requireNonNull(searchText);
     }
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java
index de10bb816..8e3034869 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java
@@ -28,6 +28,7 @@ import android.util.Log;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 
 import com.android.providers.media.PickerUriResolver;
 import com.android.providers.media.photopicker.PickerSyncController;
@@ -67,13 +68,87 @@ public class MediaGroupCursorUtils {
             PickerSQLConstants.MediaGroupResponseColumns.IS_LEAF_CATEGORY.getColumnName(),
     };
 
+    private static final String[] MEDIA_SET_RESPONSE_PROJECTION = new String[] {
+            PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.PICKER_ID.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.DISPLAY_NAME.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.AUTHORITY.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.UNWRAPPED_COVER_URI.getColumnName()
+    };
+
+    /**
+     * @param cursor Input
+     * {@link CloudMediaProviderContract.MediaSetColumns} cursor.
+     * @return Cursor with the columns {@link PickerSQLConstants.MediaGroupResponseColumns}.
+     */
+    public static Cursor getMediaGroupCursorForMediaSets(@Nullable Cursor cursor) {
+        if (cursor == null) {
+            return null;
+        }
+
+        MatrixCursor mediaSetsResponse = new MatrixCursor(MEDIA_SET_RESPONSE_PROJECTION);
+
+        // Get the list of Uris from the cursor.
+        final List<String> uris = new ArrayList<>();
+        if (cursor.moveToFirst()) {
+            do {
+                String authority = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY.getColumnName()
+                ));
+                String coverId = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.COVER_ID.getColumnName()
+                ));
+                String coverUri = getUri(coverId, authority).toString();
+                if (coverUri != null) {
+                    uris.add(coverUri);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        // Get list of local ids if local copy exists for corresponding cloud ids.
+        final Map<String, String> cloudToLocalIdMap = getLocalIds(uris);
+
+        if (cursor.moveToFirst()) {
+            do {
+                String mediaSetId = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_ID.getColumnName()
+                ));
+                String mediaSetPickerId = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()
+                ));
+                String displayName = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.DISPLAY_NAME.getColumnName()
+                ));
+                String authority = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY.getColumnName()
+                ));
+                String coverId = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.COVER_ID.getColumnName()
+                ));
+                String coverUri = getUri(coverId, authority).toString();
+                String unwrappedCoverUri = maybeGetLocalUri(coverUri, cloudToLocalIdMap);
+
+                mediaSetsResponse.addRow(new Object[] {
+                        mediaSetId,
+                        mediaSetPickerId,
+                        displayName,
+                        authority,
+                        unwrappedCoverUri
+                });
+            } while (cursor.moveToNext());
+        }
+        return mediaSetsResponse;
+    }
+
     /**
      * @param cursor Input
      * {@link com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper}
+     * @param index The index for the first album in the given albums cursor.
+     *              The index value can be used to generate unique picker id for albums.
      * @return Cursor with the columns {@link PickerSQLConstants.MediaGroupResponseColumns}.
      */
     @Nullable
-    public static Cursor getMediaGroupCursorForAlbums(@Nullable Cursor cursor) {
+    public static Cursor getMediaGroupCursorForAlbums(@Nullable Cursor cursor, long index) {
         if (cursor == null) {
             return null;
         }
@@ -101,8 +176,9 @@ public class MediaGroupCursorUtils {
                 final String albumId = cursor.getString(cursor.getColumnIndexOrThrow(
                                 PickerSQLConstants.AlbumResponse.ALBUM_ID.getColumnName()));
 
-                final String pickerId = cursor.getString(cursor.getColumnIndexOrThrow(
-                        PickerSQLConstants.AlbumResponse.PICKER_ID.getColumnName()));
+                // Sets the picker id of the current album and increments the index for the
+                // next album.
+                final long pickerId = index++;
 
                 final String displayName = cursor.getString(cursor.getColumnIndexOrThrow(
                         PickerSQLConstants.AlbumResponse.ALBUM_NAME.getColumnName()));
@@ -137,12 +213,16 @@ public class MediaGroupCursorUtils {
     /**
      * @param cursor Input
      * {@link CloudMediaProviderContract.MediaCategoryColumns} cursor.
+     * @param authority The authority of the category's CMP.
+     * @param index The index for the first category in the given categories cursor.
+     *              The index value can be used to generate unique picker id for categories.
      * @return Cursor with the columns {@link PickerSQLConstants.MediaGroupResponseColumns}.
      */
     @Nullable
     public static Cursor getMediaGroupCursorForCategories(
             @Nullable Cursor cursor,
-            @NonNull String authority) {
+            @NonNull String authority,
+            long index) {
         if (cursor == null) {
             return null;
         }
@@ -170,7 +250,6 @@ public class MediaGroupCursorUtils {
 
         // Get list of local ids if local copy exists for corresponding cloud ids.
         final Map<String, String> cloudToLocalIdMap = getLocalIds(uris);
-
         if (cursor.moveToFirst()) {
             if (cursor.getCount() > 1) {
                 Log.e(TAG, "Only one category of type PEOPLE AND PETS is expected but received "
@@ -224,7 +303,7 @@ public class MediaGroupCursorUtils {
             response.addRow(new Object[]{
                     MediaGroup.CATEGORY.name(),
                     categoryId,
-                    /* pickerId */ null,
+                    index,
                     displayName,
                     authority,
                     coverUri1,
@@ -335,18 +414,20 @@ public class MediaGroupCursorUtils {
      * find the local copy of it and returns the URI of the local copy. Otherwise returns the input
      * coverUri as it is.
      */
-    private static String maybeGetLocalUri(
+    @VisibleForTesting
+    public static String maybeGetLocalUri(
             @Nullable String rawCoverUri,
             @NonNull Map<String, String> cloudToLocalIdMap) {
         if (rawCoverUri == null) {
             return null;
         }
 
+        final String localAuthority = PickerSyncController.getInstanceOrThrow().getLocalProvider();
         try {
             final Uri coverUri = Uri.parse(rawCoverUri);
             final String mediaId = coverUri.getLastPathSegment();
             if (cloudToLocalIdMap.containsKey(mediaId)) {
-                return getUri(cloudToLocalIdMap.get(mediaId), coverUri.getAuthority()).toString();
+                return getUri(cloudToLocalIdMap.get(mediaId), localAuthority).toString();
             } else {
                 return rawCoverUri;
             }
@@ -366,6 +447,10 @@ public class MediaGroupCursorUtils {
     }
 
     private static String getEncodedUserAuthority(String authority) {
-        return MY_USER_ID + "@" + authority;
+        if (authority.contains("@")) {
+            return authority;
+        } else {
+            return MY_USER_ID + "@" + authority;
+        }
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java
index d9c5a8e16..969394707 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java
@@ -30,7 +30,7 @@ import java.util.Locale;
  * Picker DB.
  */
 public class MediaInMediaSetsCloudSubQuery extends MediaInMediaSetsSubQuery {
-    public MediaInMediaSetsCloudSubQuery(Bundle queryArgs, String mediaSetPickerId) {
+    public MediaInMediaSetsCloudSubQuery(Bundle queryArgs, Long mediaSetPickerId) {
         super(queryArgs, mediaSetPickerId);
     }
 
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java
index 40592e22f..e6e729718 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java
@@ -22,6 +22,8 @@ import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
 import static com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil.addNextPageKey;
 import static com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil.addPrevPageKey;
 
+import static java.util.Objects.requireNonNull;
+
 import android.content.ContentUris;
 import android.content.ContentValues;
 import android.database.Cursor;
@@ -40,7 +42,6 @@ import com.android.providers.media.photopicker.PickerSyncController;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
-import java.util.Objects;
 
 /**
  * Utility class for insertion or querying the media items in various media sets
@@ -60,11 +61,10 @@ public class MediaInMediaSetsDatabaseUtil {
      */
     public static int cacheMediaOfMediaSet(
             @NonNull SQLiteDatabase database,
-            @Nullable List<ContentValues> mediaListToInsert,
-            @NonNull String authority) {
+            @Nullable List<ContentValues> mediaListToInsert, @NonNull String authority) {
 
-        Objects.requireNonNull(database);
-        Objects.requireNonNull(authority);
+        requireNonNull(database);
+        requireNonNull(authority);
 
         final boolean isLocal = PickerSyncController.getInstanceOrThrow()
                 .getLocalProvider()
@@ -179,14 +179,18 @@ public class MediaInMediaSetsDatabaseUtil {
             );
             addPrevPageKey(extraArgs, prevPageKeyCursor);
 
-            database.setTransactionSuccessful();
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
             pageData.setExtras(extraArgs);
             Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
             return pageData;
         } catch (Exception e) {
             throw new RuntimeException("Could not fetch media from the media set", e);
         } finally {
-            database.endTransaction();
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
         }
     }
 
@@ -293,9 +297,9 @@ public class MediaInMediaSetsDatabaseUtil {
      * insert into the media_in_media_sets_table
      */
     public static List<ContentValues> getMediaContentValuesFromCursor(
-            @NonNull Cursor mediaCursor, @NonNull String mediaSetPickerId, boolean isLocal) {
-        Objects.requireNonNull(mediaSetPickerId);
-        Objects.requireNonNull(mediaCursor);
+            @NonNull Cursor mediaCursor, @NonNull Long mediaSetPickerId, boolean isLocal) {
+        requireNonNull(mediaSetPickerId);
+        requireNonNull(mediaCursor);
 
         List<ContentValues> contentValuesList = new ArrayList<>(mediaCursor.getCount());
         if (mediaCursor.moveToFirst()) {
@@ -333,4 +337,45 @@ public class MediaInMediaSetsDatabaseUtil {
         }
         return contentValuesList;
     }
+
+    /**
+     * Deletes all the rows from the MediaInMediaSets table
+     */
+    public static void clearMediaInMediaSetsCache(
+            @NonNull SQLiteDatabase database, @NonNull List<String> mediaSetPickerIds) {
+
+        requireNonNull(database);
+        requireNonNull(mediaSetPickerIds);
+
+        if (mediaSetPickerIds.isEmpty()) {
+            return;
+        }
+
+        String whereClause =
+                PickerSQLConstants.MediaInMediaSetsTableColumns.MEDIA_SETS_PICKER_ID.getColumnName()
+                        + " IN (" + generatePlaceholders(mediaSetPickerIds.size()) + ")";
+        String[] whereArgs = mediaSetPickerIds.toArray(new String[0]);
+
+        try {
+            int deletedRows = database.delete(
+                    PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                    whereClause,
+                    whereArgs);
+
+            Log.d(TAG, "Deleted " + deletedRows + " rows from the media in media sets table");
+        } catch (Exception e) {
+            Log.d(TAG, "Couldn't clear the media in media sets table due to " + e);
+        }
+    }
+
+    private static String generatePlaceholders(int size) {
+        StringBuilder placeholders = new StringBuilder();
+        for (int i = 0; i < size; i++) {
+            placeholders.append("?");
+            if (i < size - 1) {
+                placeholders.append(",");
+            }
+        }
+        return placeholders.toString();
+    }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java
index d00e4306c..0e1df140f 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java
@@ -31,7 +31,7 @@ import java.util.Locale;
  * Picker DB.
  */
 public class MediaInMediaSetsLocalSubQuery extends MediaInMediaSetsSubQuery {
-    public MediaInMediaSetsLocalSubQuery(Bundle queryArgs, String mediaSetPickerId) {
+    public MediaInMediaSetsLocalSubQuery(Bundle queryArgs, Long mediaSetPickerId) {
         super(queryArgs, mediaSetPickerId);
     }
 
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java
index f0ba09f1a..09172721c 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java
@@ -44,11 +44,8 @@ public class MediaInMediaSetsQuery {
     final MediaInMediaSetsCloudSubQuery mCloudMediaSubquery;
 
 
-    public MediaInMediaSetsQuery(Bundle queryArgs, @NonNull String mediaPickerSetId) {
+    public MediaInMediaSetsQuery(Bundle queryArgs, @NonNull Long mediaPickerSetId) {
         Objects.requireNonNull(mediaPickerSetId);
-        if (mediaPickerSetId.isEmpty()) {
-            throw new RuntimeException("MediaSet pickerId to query media cannot be null");
-        }
         mIntentAction = queryArgs.getString("intent_action");
         mProviders = new ArrayList<>(
                 Objects.requireNonNull(queryArgs.getStringArrayList("providers")));
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java
index 2e37e5255..ea536ee39 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java
@@ -30,9 +30,9 @@ import java.util.Locale;
  * and media table in Picker DB.
  */
 public abstract class MediaInMediaSetsSubQuery extends MediaQuery {
-    private final String mMediaSetPickerId;
+    private final Long mMediaSetPickerId;
 
-    public MediaInMediaSetsSubQuery(Bundle queryArgs, String mediaSetPickerId) {
+    public MediaInMediaSetsSubQuery(Bundle queryArgs, Long mediaSetPickerId) {
         super(queryArgs);
 
         mMediaSetPickerId = mediaSetPickerId;
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java
index dc6a1f35b..5b413f600 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java
@@ -16,9 +16,12 @@
 
 package com.android.providers.media.photopicker.v2.sqlite;
 
+import static com.android.providers.media.MediaProvider.isOwnedPhotosEnabled;
 import static com.android.providers.media.PickerUriResolver.getPickerSegmentFromIntentAction;
+import static com.android.providers.media.photopicker.PickerSyncController.uidToUserId;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
+import static com.android.providers.media.photopicker.v2.PickerDataLayerV2.getPackageSelectionWhereClause;
 
 import static java.util.Objects.requireNonNull;
 
@@ -30,6 +33,7 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import com.android.providers.media.MediaGrants;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
 import com.android.providers.media.photopicker.v2.PickerDataLayerV2;
 import com.android.providers.media.photopicker.v2.model.MediaSource;
 
@@ -52,6 +56,8 @@ public class MediaProjection {
     private final String mIntentAction;
     @Nullable
     private final PickerSQLConstants.Table mTableName;
+    private String[] mCallingPackageNames;
+    private int mCallingPackageUid;
     private static final String DEFAULT_PROJECTION = "%s AS %s";
 
     public MediaProjection(
@@ -65,6 +71,18 @@ public class MediaProjection {
         mTableName = tableName;
     }
 
+    public MediaProjection(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            @Nullable String intentAction,
+            @Nullable PickerSQLConstants.Table tableName,
+            int callingPackageUid,
+            @Nullable String[] callingPackageNames) {
+        this(localAuthority, cloudAuthority, intentAction, tableName);
+        mCallingPackageUid = callingPackageUid;
+        mCallingPackageNames = callingPackageNames;
+    }
+
     /**
      * Returns a list of all media response sql projections for the given media tables.
      */
@@ -126,7 +144,7 @@ public class MediaProjection {
                 return String.format(
                         Locale.ROOT,
                         DEFAULT_PROJECTION,
-                        getIsPregranted(mIntentAction),
+                        getIsPreGranted(mIntentAction),
                         mediaResponseColumn.getProjectedName());
             default:
                 if (mediaResponseColumn.getColumnName() == null) {
@@ -208,8 +226,30 @@ public class MediaProjection {
         );
     }
 
-    private String getIsPregranted(String intentAction) {
+    private String getIsPreGranted(String intentAction) {
         if (MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(intentAction)) {
+            if (isOwnedPhotosEnabled(mCallingPackageUid) && mCallingPackageNames != null) {
+                StringBuilder packageSelection =
+                        getPackageSelectionWhereClause(mCallingPackageNames, mTableName.name());
+                int userId = uidToUserId(mCallingPackageUid);
+
+                /*
+                 * sample query :
+                 * CASE
+                 * WHEN current_media_grants.file_id IS NOT NULL
+                 * OR (media.owner_package_name IN ('com.google.example') AND media._user_id = 0)
+                 * THEN 1 ELSE 0
+                 * END
+                 */
+                return String.format(Locale.ROOT,
+                        "CASE "
+                                + "WHEN %s.%s IS NOT NULL OR (%s AND %s = %d) "
+                                + "THEN 1 ELSE 0 "
+                                + "END",
+                        PickerDataLayerV2.CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN,
+                        packageSelection, prependTableName(mTableName, PickerDbFacade.KEY_USER_ID),
+                        userId);
+            }
             return String.format(
                     Locale.ROOT, "CASE WHEN %s.%s IS NOT NULL THEN 1 ELSE 0 END",
                     PickerDataLayerV2.CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN);
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java
index 3e554978a..6fc045561 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java
@@ -18,6 +18,8 @@ package com.android.providers.media.photopicker.v2.sqlite;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
 
+import static java.util.Objects.requireNonNull;
+
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.SQLException;
@@ -29,11 +31,12 @@ import android.util.Pair;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
+
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
-import java.util.Objects;
 
 /**
  * Utility class which holds functionality for inserting and querying media set data
@@ -59,10 +62,10 @@ public class MediaSetsDatabaseUtil {
             @NonNull String categoryId, @NonNull String authority,
             @Nullable List<String> mimeTypes) {
 
-        Objects.requireNonNull(database);
-        Objects.requireNonNull(mediaSetMetadataCursor);
-        Objects.requireNonNull(categoryId);
-        Objects.requireNonNull(authority);
+        requireNonNull(database);
+        requireNonNull(mediaSetMetadataCursor);
+        requireNonNull(categoryId);
+        requireNonNull(authority);
 
         String mimeTypesAsString = getMimeTypesAsString(mimeTypes);
         List<ContentValues> insertValues = getMediaSetContentValues(
@@ -123,9 +126,9 @@ public class MediaSetsDatabaseUtil {
      */
     public static Pair<String, String[]> getMediaSetIdAndMimeType(
             @NonNull SQLiteDatabase database,
-            @NonNull String mediaSetPickerId) {
-        Objects.requireNonNull(database);
-        Objects.requireNonNull(mediaSetPickerId);
+            @NonNull Long mediaSetPickerId) {
+        requireNonNull(database);
+        requireNonNull(mediaSetPickerId);
 
         SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
                 .setTables(PickerSQLConstants.Table.MEDIA_SETS.name())
@@ -165,11 +168,19 @@ public class MediaSetsDatabaseUtil {
      * @return Cursor containing metadata of all the media sets under the given category
      */
     public static Cursor getMediaSetsForCategory(
-            @NonNull SQLiteDatabase database, @NonNull String categoryId,
-            @NonNull String authority, @Nullable List<String> mimeTypes) {
-        Objects.requireNonNull(database);
-        Objects.requireNonNull(categoryId);
-        Objects.requireNonNull(authority);
+            @NonNull SQLiteDatabase database, @NonNull MediaSetsSyncRequestParams requestParams) {
+        requireNonNull(database);
+        requireNonNull(requestParams);
+        final String categoryId = requestParams.getCategoryId();
+        final String authority = requestParams.getAuthority();
+        final List<String> mimeTypes;
+        if (requestParams.getMimeTypes() != null) {
+            mimeTypes = requestParams.getMimeTypes();
+        } else {
+            mimeTypes = null;
+        }
+        requireNonNull(categoryId);
+        requireNonNull(authority);
 
         final List<String> projection = List.of(
                 PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName(),
@@ -195,8 +206,7 @@ public class MediaSetsDatabaseUtil {
                         String.format(Locale.ROOT, " %s = '%s' ",
                                 PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY
                                         .getColumnName(), authority)
-                )
-                .appendWhereStandalone(
+                ).appendWhereStandalone(
                         String.format(Locale.ROOT, " %s = '%s' ",
                                 PickerSQLConstants.MediaSetsTableColumns.MIME_TYPE_FILTER
                                         .getColumnName(), getMimeTypesAsString(mimeTypes)));
@@ -213,9 +223,9 @@ public class MediaSetsDatabaseUtil {
      * @return The cursor which contains the media resume key for the media in that media set
      */
     public static String getMediaResumeKey(
-            @NonNull SQLiteDatabase database, @NonNull String mediaPickerId) {
-        Objects.requireNonNull(database);
-        Objects.requireNonNull(mediaPickerId);
+            @NonNull SQLiteDatabase database, @NonNull Long mediaPickerId) {
+        requireNonNull(database);
+        requireNonNull(mediaPickerId);
 
         final List<String> projection = List.of(
                 PickerSQLConstants.MediaSetsTableColumns.MEDIA_IN_MEDIA_SET_SYNC_RESUME_KEY
@@ -251,9 +261,9 @@ public class MediaSetsDatabaseUtil {
      * @param resumeKey The new value of the resume key
      */
     public static void updateMediaInMediaSetSyncResumeKey(@NonNull SQLiteDatabase database,
-            @NonNull String mediaSetPickerId, @Nullable String resumeKey) {
-        Objects.requireNonNull(database);
-        Objects.requireNonNull(mediaSetPickerId);
+            @NonNull Long mediaSetPickerId, @Nullable String resumeKey) {
+        requireNonNull(database);
+        requireNonNull(mediaSetPickerId);
 
         String table = PickerSQLConstants.Table.MEDIA_SETS.name();
 
@@ -276,6 +286,81 @@ public class MediaSetsDatabaseUtil {
         );
     }
 
+    /**
+     * Deletes all the rows from the MediaSets table
+     */
+    public static void clearMediaSetsCache(
+            @NonNull SQLiteDatabase database,
+            @NonNull String categoryId,
+            @NonNull String authority) {
+
+        requireNonNull(database);
+        requireNonNull(categoryId);
+        requireNonNull(authority);
+
+        String whereClause = PickerSQLConstants.MediaSetsTableColumns.CATEGORY_ID.getColumnName()
+                + " = ? AND "
+                + PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY.getColumnName()
+                + " = ?";
+        String[] whereArgs = new String[] { categoryId, authority };
+        try {
+            int deletedRows = database.delete(
+                    PickerSQLConstants.Table.MEDIA_SETS.name(),
+                    whereClause,
+                    whereArgs);
+
+            Log.d(TAG, "Deleted " + deletedRows + " rows from the media sets table.");
+        } catch (Exception exception) {
+            Log.e(TAG, "couldn't clear the media sets table due to " + exception);
+        }
+    }
+
+    /**
+     * Fetches the generated database ids, also called media_set_picker_id for the given
+     * categoryId
+     */
+    public static List<String> getMediaSetPickerIdsForGivenCategoryId(
+            @NonNull SQLiteDatabase database,
+            @NonNull String categoryId,
+            @NonNull String authority) {
+
+        requireNonNull(database);
+        requireNonNull(categoryId);
+        requireNonNull(authority);
+
+        List<String> mediaSetPickerIds = new ArrayList<>();
+
+        final List<String> projection = List.of(
+                PickerSQLConstants.MediaSetsTableColumns.PICKER_ID
+                        .getColumnName());
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.MEDIA_SETS.name())
+                .setProjection(projection);
+        queryBuilder.appendWhereStandalone(
+                String.format(Locale.ROOT, " %s = '%s' ",
+                        PickerSQLConstants.MediaSetsTableColumns.CATEGORY_ID.getColumnName(),
+                        categoryId)
+        );
+        queryBuilder.appendWhereStandalone(
+                String.format(Locale.ROOT, " %s = '%s' ",
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY
+                                .getColumnName(),
+                        authority)
+        );
+
+        try (Cursor cursor = database.rawQuery(queryBuilder.buildQuery(), /*selectionArgs*/ null)) {
+            if (cursor.moveToFirst()) {
+                do {
+                    int pickerIdIndex = cursor.getColumnIndex(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName());
+                    String pickerId = cursor.getString(pickerIdIndex);
+                    mediaSetPickerIds.add(pickerId);
+                } while (cursor.moveToNext());
+            }
+        }
+        return mediaSetPickerIds;
+    }
+
     private static List<ContentValues> getMediaSetContentValues(
             Cursor mediaSetCursor, String categoryId, String authority, String mimeTypes) {
 
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java
index 2bfb1b955..35573faac 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java
@@ -16,6 +16,8 @@
 
 package com.android.providers.media.photopicker.v2.sqlite;
 
+import static com.android.providers.media.MediaProvider.isOwnedPhotosEnabled;
+import static com.android.providers.media.photopicker.PickerSyncController.getPackageNameFromUid;
 import static com.android.providers.media.photopicker.v2.PickerDataLayerV2.getDefaultEmptyAlbum;
 import static com.android.providers.media.photopicker.v2.sqlite.MediaProjection.prependTableName;
 
@@ -133,12 +135,16 @@ public class PickerMediaDatabaseUtil {
                     addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
                 }
 
-                database.setTransactionSuccessful();
+                if (database.inTransaction()) {
+                    database.setTransactionSuccessful();
+                }
                 pageData.setExtras(extraArgs);
                 Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
                 return pageData;
             } finally {
-                database.endTransaction();
+                if (database.inTransaction()) {
+                    database.endTransaction();
+                }
             }
         } catch (Exception e) {
             throw new RuntimeException("Could not fetch media", e);
@@ -226,14 +232,18 @@ public class PickerMediaDatabaseUtil {
                     addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
                 }
 
-                database.setTransactionSuccessful();
+                if (database.inTransaction()) {
+                    database.setTransactionSuccessful();
+                }
 
                 pageData.setExtras(extraArgs);
                 Log.i(TAG, "Returning " + pageData.getCount() + " album media items for album "
                         + query.getAlbumId());
                 return pageData;
             } finally {
-                database.endTransaction();
+                if (database.inTransaction()) {
+                    database.endTransaction();
+                }
             }
 
 
@@ -383,14 +393,18 @@ public class PickerMediaDatabaseUtil {
                     addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
                 }
 
-                database.setTransactionSuccessful();
+                if (database.inTransaction()) {
+                    database.setTransactionSuccessful();
+                }
 
                 pageData.setExtras(extraArgs);
                 Log.i(TAG, "Returning " + pageData.getCount() + " album media items for album "
                         + albumId);
                 return pageData;
             } finally {
-                database.endTransaction();
+                if (database.inTransaction()) {
+                    database.endTransaction();
+                }
             }
         } catch (Exception e) {
             throw new RuntimeException("Could not fetch media", e);
@@ -492,8 +506,10 @@ public class PickerMediaDatabaseUtil {
 
             return null;
         } finally {
-            database.setTransactionSuccessful();
-            database.endTransaction();
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+                database.endTransaction();
+            }
         }
     }
 
@@ -507,11 +523,21 @@ public class PickerMediaDatabaseUtil {
             @NonNull PickerSQLConstants.Table table,
             @Nullable String localAuthority,
             @Nullable String cloudAuthority) {
+        int callingPackageUid = query.getCallingPackageUid();
+        String[] packageNames = null;
+
+        if (callingPackageUid != -1 && isOwnedPhotosEnabled(callingPackageUid) && appContext != null
+                && appContext.getPackageManager() != null) {
+            packageNames = getPackageNameFromUid(appContext, callingPackageUid);
+        }
+
         final MediaProjection projectionUtil = new MediaProjection(
                 localAuthority,
                 cloudAuthority,
                 query.getIntentAction(),
-                table
+                table,
+                callingPackageUid,
+                packageNames
         );
 
         SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java b/src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java
index db3fa931e..fc9945a29 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java
@@ -42,6 +42,8 @@ import java.util.Objects;
 public class PickerSQLConstants {
     public static final int DEFAULT_SEARCH_SUGGESTIONS_LIMIT = 50;
     public static final int DEFAULT_SEARCH_HISTORY_SUGGESTIONS_LIMIT = 3;
+    public static String EXTRA_SEARCH_REQUEST_ID = "search_request_id";
+    public static String EXTRA_SEARCH_PROVIDER_AUTHORITIES = "search_provider_authorities";
     static final String COUNT_COLUMN = "Count";
 
     /**
@@ -199,11 +201,14 @@ public class PickerSQLConstants {
 
     public enum SearchRequestTableColumns {
         SEARCH_REQUEST_ID("_id"),
-        SYNC_RESUME_KEY("sync_resume_key"),
+        LOCAL_SYNC_RESUME_KEY("local_sync_resume_key"),
+        LOCAL_AUTHORITY("local_authority"),
+        CLOUD_SYNC_RESUME_KEY("cloud_sync_resume_key"),
+        CLOUD_AUTHORITY("cloud_authority"),
         SEARCH_TEXT("search_text"),
         MEDIA_SET_ID("media_set_id"),
         SUGGESTION_TYPE("suggestion_type"),
-        AUTHORITY("authority"),
+        SUGGESTION_AUTHORITY("suggestion_authority"),
         MIME_TYPES("mime_types");
 
         private final String mColumnName;
@@ -304,7 +309,7 @@ public class PickerSQLConstants {
         AUTHORITY("authority"),
         MEDIA_SET_ID("media_set_id"),
         SEARCH_TEXT("display_text"),
-        COVER_MEDIA_ID("cover_media_id"),
+        COVER_MEDIA_URI("cover_media_uri"),
         SUGGESTION_TYPE("suggestion_type");
 
         private final String mProjection;
@@ -348,13 +353,13 @@ public class PickerSQLConstants {
         /** Source provider's authority. */
         AUTHORITY("authority"),
         /** Cover image Uri for the group. */
-        UNWRAPPED_COVER_URI("cover_uri_1"),
+        UNWRAPPED_COVER_URI("unwrapped_cover_uri"),
         /** Additional cover image Uri for the category. */
-        ADDITIONAL_UNWRAPPED_COVER_URI_1("cover_uri_2"),
+        ADDITIONAL_UNWRAPPED_COVER_URI_1("additional_cover_uri_1"),
         /** Additional cover image Uri for the category. */
-        ADDITIONAL_UNWRAPPED_COVER_URI_2("cover_uri_3"),
+        ADDITIONAL_UNWRAPPED_COVER_URI_2("additional_cover_uri_2"),
         /** Additional cover image Uri for the category. */
-        ADDITIONAL_UNWRAPPED_COVER_URI_3("cover_uri_4"),
+        ADDITIONAL_UNWRAPPED_COVER_URI_3("additional_cover_uri_3"),
         /** If the media group is category, this will be populated with the category type. */
         CATEGORY_TYPE("category_type"),
         /** True, if the media category is leaf category which contains media sets,
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java
index ebe8b2139..1c8781671 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java
@@ -32,8 +32,10 @@ import com.android.providers.media.photopicker.v2.model.SearchRequest;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
 import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
+import java.util.stream.Collectors;
 
 /**
  * Convenience class for running Picker Search Request related sql queries.
@@ -88,18 +90,38 @@ public class SearchRequestDatabaseUtil {
      * @param searchRequestId Identifier for a search request.
      * @param resumeKey The resume key that can be used to fetch the next page of results,
      *                  or indicate that the sync is complete.
+     * @param isLocal True if the sync resume key of local sync should be updated, else false if the
+     *               sync resume key of cloud sync should be updated.
      * @throws RuntimeException if an error occurs in running the sql command.
      */
     public static void updateResumeKey(
             @NonNull SQLiteDatabase database,
             int searchRequestId,
-            @Nullable String resumeKey) {
+            @Nullable String resumeKey,
+            @NonNull String authority,
+            boolean isLocal) {
         final String table = PickerSQLConstants.Table.SEARCH_REQUEST.name();
 
         ContentValues contentValues = new ContentValues();
-        contentValues.put(
-                PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName(),
-                resumeKey);
+        if (isLocal) {
+            contentValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .LOCAL_SYNC_RESUME_KEY.getColumnName(),
+                    resumeKey);
+            contentValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .LOCAL_AUTHORITY.getColumnName(),
+                    authority);
+        } else {
+            contentValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .CLOUD_SYNC_RESUME_KEY.getColumnName(),
+                    resumeKey);
+            contentValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .CLOUD_AUTHORITY.getColumnName(),
+                    authority);
+        }
 
         database.update(
                 table,
@@ -112,7 +134,7 @@ public class SearchRequestDatabaseUtil {
                                 .SEARCH_REQUEST_ID.getColumnName(),
                         searchRequestId
                 ),
-                null
+                /* whereArgs */ null
         );
     }
 
@@ -175,10 +197,13 @@ public class SearchRequestDatabaseUtil {
             @NonNull int searchRequestID
     ) {
         final List<String> projection = List.of(
-                PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.LOCAL_SYNC_RESUME_KEY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.LOCAL_AUTHORITY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.CLOUD_SYNC_RESUME_KEY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.CLOUD_AUTHORITY.getColumnName(),
                 PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName(),
                 PickerSQLConstants.SearchRequestTableColumns.MEDIA_SET_ID.getColumnName(),
-                PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_AUTHORITY.getColumnName(),
                 PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_TYPE.getColumnName(),
                 PickerSQLConstants.SearchRequestTableColumns.MIME_TYPES.getColumnName()
         );
@@ -196,30 +221,52 @@ public class SearchRequestDatabaseUtil {
                             + "- returning the first match");
                 }
 
-                final String authority = getColumnValueOrNull(
+                final String suggestionAuthority = getColumnValueOrNull(
                         cursor,
-                        PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName()
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .SUGGESTION_AUTHORITY.getColumnName()
                 );
                 final String mimeTypes = getColumnValueOrNull(
                         cursor,
-                        PickerSQLConstants.SearchRequestTableColumns.MIME_TYPES.getColumnName()
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .MIME_TYPES.getColumnName()
                 );
                 final String searchText = getColumnValueOrNull(
                             cursor,
-                            PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName()
+                            PickerSQLConstants.SearchRequestTableColumns
+                                    .SEARCH_TEXT.getColumnName()
+                );
+                final String localSyncResumeKey = getColumnValueOrNull(
+                        cursor,
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .LOCAL_SYNC_RESUME_KEY.getColumnName()
+                );
+                final String localAuthority = getColumnValueOrNull(
+                        cursor,
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .LOCAL_AUTHORITY.getColumnName()
+                );
+                final String cloudSyncResumeKey = getColumnValueOrNull(
+                        cursor,
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .CLOUD_SYNC_RESUME_KEY.getColumnName()
                 );
-                final String resumeKey = getColumnValueOrNull(
+                final String cloudAuthority = getColumnValueOrNull(
                         cursor,
-                        PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName()
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .CLOUD_AUTHORITY.getColumnName()
                 );
 
                 final SearchRequest searchRequest;
-                if (authority == null) {
+                if (suggestionAuthority == null) {
                     // This is a search text request
                     searchRequest = new SearchTextRequest(
                             SearchRequest.getMimeTypesAsList(mimeTypes),
-                            requireNonNull(searchText),
-                            resumeKey
+                            searchText,
+                            localSyncResumeKey,
+                            localAuthority,
+                            cloudSyncResumeKey,
+                            cloudAuthority
                     );
                 } else {
                     // This is a search suggestion request
@@ -242,9 +289,12 @@ public class SearchRequestDatabaseUtil {
                             SearchRequest.getMimeTypesAsList(mimeTypes),
                             searchText,
                             mediaSetID,
-                            authority,
+                            suggestionAuthority,
                             suggestionType,
-                            resumeKey
+                            localSyncResumeKey,
+                            localAuthority,
+                            cloudSyncResumeKey,
+                            cloudAuthority
                     );
                 }
                 return searchRequest;
@@ -259,6 +309,149 @@ public class SearchRequestDatabaseUtil {
         }
     }
 
+    /**
+     * @param database The database you need to run the query on.
+     * @param isLocal True if the search results synced with the local provider need to be reset.
+     *                Else if the search results synced with cloud provider need to be reset,
+     *                this is false.
+     * @return a list of search request IDs of the search requests that are either fully or
+     * partially synced with the provider.
+     */
+    public static List<Integer> getSyncedRequestIds(
+            @NonNull SQLiteDatabase database,
+            boolean isLocal) {
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database);
+        queryBuilder.setTables(PickerSQLConstants.Table.SEARCH_REQUEST.name())
+                .setProjection(List.of(
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .SEARCH_REQUEST_ID.getColumnName()
+                ));
+
+        if (isLocal) {
+            queryBuilder.appendWhereStandalone(
+                    String.format(
+                            Locale.ROOT,
+                            "%s IS NOT NULL OR %s IS NOT NULL",
+                            PickerSQLConstants.SearchRequestTableColumns
+                                    .LOCAL_AUTHORITY.getColumnName(),
+                            PickerSQLConstants.SearchRequestTableColumns
+                                    .LOCAL_SYNC_RESUME_KEY.getColumnName()
+                    )
+            );
+        } else {
+            queryBuilder.appendWhereStandalone(
+                    String.format(
+                            Locale.ROOT,
+                            "%s IS NOT NULL OR %s IS NOT NULL",
+                            PickerSQLConstants.SearchRequestTableColumns
+                                    .CLOUD_AUTHORITY.getColumnName(),
+                            PickerSQLConstants.SearchRequestTableColumns
+                                    .CLOUD_SYNC_RESUME_KEY.getColumnName()
+                    )
+            );
+        }
+
+        final List<Integer> searchRequestIds = new ArrayList<>();
+        try (Cursor cursor = database.rawQuery(queryBuilder.buildQuery(), null)) {
+            if (cursor.moveToFirst()) {
+                do {
+                    searchRequestIds.add(cursor.getInt(
+                            cursor.getColumnIndexOrThrow(
+                                    PickerSQLConstants.SearchRequestTableColumns
+                                            .SEARCH_REQUEST_ID.getColumnName()
+                            )
+                    ));
+                } while (cursor.moveToNext());
+            }
+        }
+        return searchRequestIds;
+    }
+
+    /**
+     * Clear sync resume info from the database.
+     *
+     * @param database SQLiteDatabase object that contains the database connection.
+     * @param searchRequestIds List of search request ids that identify the rows that need to be
+     *                         updated.
+     * @param isLocal This is true when the local sync resume info needs to clear,
+     *                otherwise it is false.
+     * @return The number of items that were updated.
+     */
+    public static int clearSyncResumeInfo(
+            @NonNull SQLiteDatabase database,
+            @NonNull List<Integer> searchRequestIds,
+            boolean isLocal) {
+        requireNonNull(database);
+        requireNonNull(searchRequestIds);
+        if (searchRequestIds.isEmpty()) {
+            Log.d(TAG, "No search request ids received for clearing resume info");
+            return 0;
+        }
+
+        final String whereClause = String.format(
+                Locale.ROOT,
+                "%s IN ('%s')",
+                PickerSQLConstants.SearchRequestTableColumns.SEARCH_REQUEST_ID.getColumnName(),
+                searchRequestIds
+                        .stream()
+                        .map(Object::toString)
+                        .collect(Collectors.joining("','")));
+
+        final ContentValues updatedValues = new ContentValues();
+        if (isLocal) {
+            updatedValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .LOCAL_SYNC_RESUME_KEY.getColumnName(),
+                    (String) null
+            );
+            updatedValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns.LOCAL_AUTHORITY.getColumnName(),
+                    (String) null
+            );
+        } else {
+            updatedValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .CLOUD_SYNC_RESUME_KEY.getColumnName(),
+                    (String) null
+            );
+            updatedValues.put(
+                    PickerSQLConstants.SearchRequestTableColumns.CLOUD_AUTHORITY.getColumnName(),
+                    (String) null
+            );
+        }
+
+        final int updatedSearchRequestsCount = database.update(
+                PickerSQLConstants.Table.SEARCH_REQUEST.name(),
+                updatedValues,
+                whereClause,
+                /* whereArgs */ null);
+        Log.d(TAG, "Updated number of search results: " + updatedSearchRequestsCount);
+        return updatedSearchRequestsCount;
+    }
+
+    /**
+     * Clears all search requests from the database.
+     *
+     * @param database SQLiteDatabase object that contains the database connection.
+     * @return The number of items that were updated.
+     */
+    public static int clearAllSearchRequests(@NonNull SQLiteDatabase database) {
+        requireNonNull(database);
+
+        int searchRequestsDeletionCount =
+                database.delete(
+                        PickerSQLConstants.Table.SEARCH_REQUEST.name(),
+                        /* whereClause */ null,
+                        /* whereArgs */ null);
+
+        Log.d(TAG, String.format(
+                Locale.ROOT,
+                "Deleted %s rows in search request table",
+                searchRequestsDeletionCount));
+
+        return searchRequestsDeletionCount;
+    }
+
 
     /**
      * @return ContentValues that contains a mapping of column names of search_request table as key
@@ -277,10 +470,22 @@ public class SearchRequestDatabaseUtil {
                 getValueOrPlaceholder(
                         SearchRequest.getMimeTypesAsString(searchRequest.getMimeTypes())));
 
-        // Insert value as it is for a non-unique column.
+        // Insert value as it is for non-unique columns.
+        values.put(
+                PickerSQLConstants.SearchRequestTableColumns.LOCAL_SYNC_RESUME_KEY.getColumnName(),
+                searchRequest.getLocalSyncResumeKey());
+
+        values.put(
+                PickerSQLConstants.SearchRequestTableColumns.LOCAL_AUTHORITY.getColumnName(),
+                searchRequest.getLocalAuthority());
+
+        values.put(
+                PickerSQLConstants.SearchRequestTableColumns.CLOUD_SYNC_RESUME_KEY.getColumnName(),
+                searchRequest.getCloudSyncResumeKey());
+
         values.put(
-                PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName(),
-                searchRequest.getResumeKey());
+                PickerSQLConstants.SearchRequestTableColumns.CLOUD_AUTHORITY.getColumnName(),
+                searchRequest.getCloudAuthority());
 
         if (searchRequest instanceof SearchTextRequest searchTextRequest) {
             // Insert placeholder for null for unique column.
@@ -291,7 +496,8 @@ public class SearchRequestDatabaseUtil {
                     PickerSQLConstants.SearchRequestTableColumns.MEDIA_SET_ID.getColumnName(),
                     PLACEHOLDER_FOR_NULL);
             values.put(
-                    PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .SUGGESTION_AUTHORITY.getColumnName(),
                     PLACEHOLDER_FOR_NULL);
             values.put(
                     PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_TYPE.getColumnName(),
@@ -307,7 +513,8 @@ public class SearchRequestDatabaseUtil {
                     getValueOrPlaceholder(
                             searchSuggestionRequest.getSearchSuggestion().getMediaSetId()));
             values.put(
-                    PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                    PickerSQLConstants.SearchRequestTableColumns
+                            .SUGGESTION_AUTHORITY.getColumnName(),
                     getValueOrPlaceholder(searchSuggestionRequest
                             .getSearchSuggestion().getAuthority()));
             values.put(
@@ -363,7 +570,7 @@ public class SearchRequestDatabaseUtil {
                 mediaSetId);
         addWhereClause(
                 queryBuilder,
-                PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_AUTHORITY.getColumnName(),
                 authority);
         addWhereClause(
                 queryBuilder,
@@ -376,7 +583,8 @@ public class SearchRequestDatabaseUtil {
             @NonNull int searchRequestID
     ) {
         queryBuilder.appendWhereStandalone(
-                String.format(Locale.ROOT, " %s = '%s' ",
+                String.format(Locale.ROOT,
+                        " %s = '%s' ",
                         PickerSQLConstants.SearchRequestTableColumns
                                 .SEARCH_REQUEST_ID.getColumnName(),
                         searchRequestID));
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java
index d6052c469..984fdb440 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java
@@ -31,6 +31,7 @@ import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 import android.net.Uri;
 import android.os.Bundle;
+import android.os.CancellationSignal;
 import android.provider.CloudMediaProviderContract;
 import android.util.Log;
 
@@ -38,10 +39,12 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
+import java.util.stream.Collectors;
 
 /**
  * Convenience class for running Picker Search Results related sql queries.
@@ -121,7 +124,8 @@ public class SearchResultsDatabaseUtil {
     public static int cacheSearchResults(
             @NonNull SQLiteDatabase database,
             @NonNull String authority,
-            @Nullable List<ContentValues> contentValuesList) {
+            @Nullable List<ContentValues> contentValuesList,
+            @Nullable CancellationSignal cancellationSignal) {
         requireNonNull(database);
         requireNonNull(authority);
 
@@ -167,12 +171,22 @@ public class SearchResultsDatabaseUtil {
                 }
             }
 
+            if (cancellationSignal != null && cancellationSignal.isCanceled()) {
+                throw new RequestObsoleteException(
+                        "cacheSearchResults operation has been cancelled.");
+            }
+
             // Mark transaction as successful so that it gets committed after it ends.
             if (database.inTransaction()) {
                 database.setTransactionSuccessful();
             }
 
+            Log.d(TAG, "Number of search results cached: " + numberOfRowsInserted);
             return numberOfRowsInserted;
+        } catch (RequestObsoleteException e) {
+            // Do not mark transaction as successful so that it gets roll-backed. after it ends.
+            throw new RuntimeException("Could not insert items in the DB because "
+                    + "the operation has been cancelled.", e);
         } catch (RuntimeException e) {
             // Do not mark transaction as successful so that it gets roll-backed. after it ends.
             throw new RuntimeException("Could not insert items in the DB", e);
@@ -255,14 +269,19 @@ public class SearchResultsDatabaseUtil {
             );
             addPrevPageKey(extraArgs, prevPageKeyCursor);
 
-            database.setTransactionSuccessful();
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
+
             pageData.setExtras(extraArgs);
             Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
             return pageData;
         } catch (Exception e) {
             throw new RuntimeException("Could not fetch media", e);
         } finally {
-            database.endTransaction();
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
         }
     }
 
@@ -367,4 +386,78 @@ public class SearchResultsDatabaseUtil {
 
         return queryBuilder.buildQuery();
     }
+
+    /**
+     * Deletes all the obsolete search results from the database.
+     *
+     * @param database SQLiteDatabase object that contains the database connection.
+     * @param searchRequestIds List of search request ids that identify the rows that need to be
+     *                         deleted.
+     * @param isLocal This is true when the local sync results info needs to clear,
+     *                otherwise it is false.
+     * @return The number of items that were deleted.
+     */
+    public static int clearObsoleteSearchResults(
+            @NonNull SQLiteDatabase database,
+            @NonNull List<Integer> searchRequestIds,
+            boolean isLocal) {
+        requireNonNull(database);
+        requireNonNull(searchRequestIds);
+        if (searchRequestIds.isEmpty()) {
+            Log.d(TAG, "No search request ids received for clearing search results");
+            return 0;
+        }
+
+        final String whereClause;
+
+        if (isLocal) {
+            whereClause = String.format(
+                    Locale.ROOT,
+                    "%s IN ('%s') AND %s IS NULL",
+                    PickerSQLConstants.SearchResultMediaTableColumns
+                            .SEARCH_REQUEST_ID.getColumnName(),
+                    searchRequestIds.stream().map(Object::toString)
+                            .collect(Collectors.joining("','")),
+                    PickerSQLConstants.SearchResultMediaTableColumns.CLOUD_ID.getColumnName());
+        } else {
+            whereClause = String.format(
+                    Locale.ROOT,
+                    "%s IN ('%s') AND %s IS NOT NULL",
+                    PickerSQLConstants.SearchResultMediaTableColumns
+                            .SEARCH_REQUEST_ID.getColumnName(),
+                    searchRequestIds.stream().map(Object::toString)
+                            .collect(Collectors.joining("','")),
+                    PickerSQLConstants.SearchResultMediaTableColumns.CLOUD_ID.getColumnName());
+        }
+
+        final int deletedSearchResultsCount = database.delete(
+                PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                whereClause,
+                /* whereArgs */ null);
+        Log.d(TAG, "Deleted number of search results: " + deletedSearchResultsCount);
+        return deletedSearchResultsCount;
+    }
+
+    /**
+     * Clears all cached search results from the database.
+     *
+     * @param database SQLiteDatabase object that contains the database connection.
+     * @return The number of items that were updated.
+     */
+    public static int clearAllSearchResults(@NonNull SQLiteDatabase database) {
+        requireNonNull(database);
+
+        int searchResultsDeletionCount =
+                database.delete(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                        /* whereClause */ null,
+                        /* whereArgs */ null);
+
+        Log.d(TAG, String.format(
+                Locale.ROOT,
+                "Deleted %s rows in search results table",
+                searchResultsDeletionCount));
+
+        return searchResultsDeletionCount;
+    }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java
index 3a0b11788..25c0208fd 100644
--- a/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java
@@ -47,8 +47,16 @@ import java.util.concurrent.TimeUnit;
  */
 public class SearchSuggestionsDatabaseUtils {
     private static final String TAG = "SearchSuggestionsDBUtil";
-    private static final int TTL_HISTORY_SUGGESTIONS_IN_DAYS = 60;
-    private static final int TTL_CACHED_SUGGESTIONS_IN_DAYS = 30;
+    // Note that SQLite treats all null values as different. So, if you apply a
+    // UNIQUE(...) constraint on some columns and if any of those columns holds a null value,
+    // the unique constraint will not be applied. This is why in the search history table,
+    // a placeholder value will be used instead of null so that the unique constraint gets
+    // applied to all search requests saved in the table.
+    // The placeholder values should not be a valid value to any of the columns in the unique
+    // constraint.
+    public static final String PLACEHOLDER_FOR_NULL = "";
+    static final int TTL_HISTORY_SUGGESTIONS_IN_DAYS = 7;
+    static final int TTL_CACHED_SUGGESTIONS_IN_DAYS = 3;
 
     /**
      * Save Search Request as search history to serve as search suggestions later.
@@ -62,6 +70,7 @@ public class SearchSuggestionsDatabaseUtils {
             @NonNull SearchRequest searchRequest) {
         requireNonNull(database);
         requireNonNull(searchRequest);
+        Log.d(TAG, "Saving search history: " + searchRequest);
 
         try {
             // Note that CONFLICT_REPLACE create a new row in case of a conflict so the
@@ -104,7 +113,7 @@ public class SearchSuggestionsDatabaseUtils {
                         PickerSQLConstants.SearchHistoryTableColumns.MEDIA_SET_ID.getColumnName(),
                         PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY.getColumnName(),
                         PickerSQLConstants.SearchHistoryTableColumns.COVER_MEDIA_ID.getColumnName()
-                )).setLimit(query.getHistoryLimit())
+                ))
                 .setSortOrder(String.format(
                         Locale.ROOT,
                         "%s DESC",
@@ -146,7 +155,8 @@ public class SearchSuggestionsDatabaseUtils {
                             historySuggestions.add(historySuggestion);
                         }
                     }
-                } while (cursor.moveToNext());
+                } while (cursor.moveToNext()
+                        && historySuggestions.size() < query.getHistoryLimit());
             }
 
             Log.d(TAG, "Number of history suggestions: " + historySuggestions.size());
@@ -187,7 +197,7 @@ public class SearchSuggestionsDatabaseUtils {
                                 .COVER_MEDIA_ID.getColumnName(),
                         PickerSQLConstants.SearchSuggestionsTableColumns
                                 .SUGGESTION_TYPE.getColumnName()
-                )).setLimit(query.getLimit())
+                ))
                 .setSortOrder(String.format(
                         Locale.ROOT,
                         "%s ASC",
@@ -221,7 +231,7 @@ public class SearchSuggestionsDatabaseUtils {
                             suggestions.add(suggestion);
                         }
                     }
-                } while (cursor.moveToNext());
+                } while (cursor.moveToNext() && suggestions.size() < query.getLimit());
             }
 
             Log.d(TAG, "Number of fetched cached suggestions: " + suggestions.size());
@@ -255,11 +265,12 @@ public class SearchSuggestionsDatabaseUtils {
                 } catch (RuntimeException e) {
                     ContentValues contentValues = new ContentValues();
                     DatabaseUtils.cursorRowToContentValues(cursor, contentValues);
-                    Log.e(TAG, "Invalid search suggestion - skipping it: " + contentValues);
+                    Log.e(TAG, "Invalid search suggestion - skipping it: " + contentValues, e);
                 }
             } while (cursor.moveToNext());
         }
 
+        Log.d(TAG, "Extracted suggestions from cursor: " + searchSuggestions.size());
         return searchSuggestions;
     }
 
@@ -342,6 +353,156 @@ public class SearchSuggestionsDatabaseUtils {
         }
     }
 
+    /**
+     * Clear all expired cached search suggestions from the database.
+     *
+     * @param database SQLiteDatabase object that holds DB connections.
+     * @return the number of items deleted from the database.
+     */
+    public static int clearExpiredCachedSearchSuggestions(@NonNull SQLiteDatabase database) {
+        requireNonNull(database);
+
+        final Long creationThreshold = System.currentTimeMillis()
+                - TimeUnit.DAYS.toMillis(TTL_CACHED_SUGGESTIONS_IN_DAYS);
+
+        final String whereClause = String.format(
+                Locale.ROOT,
+                " %s < ? ",
+                PickerSQLConstants.SearchSuggestionsTableColumns.CREATION_TIME_MS);
+
+        final String[] whereArgs = List.of(creationThreshold.toString()).toArray(new String[0]);
+
+        int suggestionsDeletionCount =
+                database.delete(
+                        PickerSQLConstants.Table.SEARCH_SUGGESTION.name(),
+                        whereClause,
+                        whereArgs);
+
+        Log.d(TAG, String.format(
+                Locale.ROOT,
+                "Deleted %s rows in search suggestions table",
+                suggestionsDeletionCount));
+
+        return suggestionsDeletionCount;
+    }
+
+    /**
+     * Clear all cached search suggestions for the given authority.
+     *
+     * @param database SQLiteDatabase object that holds DB connections.
+     * @param providerAuthority The provider authority for which all suggestions need to be cleared.
+     *                         If the authority is null, all cached suggestions will be cleared to
+     *                         be on the safer side.
+     * @return the number of items deleted from the database.
+     */
+    public static int clearCachedSearchSuggestionsForAuthority(
+            @NonNull SQLiteDatabase database,
+            @Nullable String providerAuthority) {
+        requireNonNull(database);
+
+        String whereClause = null;
+        String[] whereArgs = null;
+        if (providerAuthority != null) {
+            whereClause = String.format(
+                    Locale.ROOT,
+                    " %s = ? ",
+                    PickerSQLConstants.SearchSuggestionsTableColumns.AUTHORITY);
+
+            whereArgs = List.of(providerAuthority).toArray(new String[0]);
+        }
+
+        int suggestionsDeletionCount =
+                database.delete(
+                        PickerSQLConstants.Table.SEARCH_SUGGESTION.name(),
+                        whereClause,
+                        whereArgs);
+
+        Log.d(TAG, String.format(
+                Locale.ROOT,
+                "Deleted %s rows in search suggestions table",
+                suggestionsDeletionCount));
+
+        return suggestionsDeletionCount;
+    }
+
+    /**
+     * Clear all expired history search suggestions from the database.
+     *
+     * @param database SQLiteDatabase object that holds DB connections.
+     * @return the number of items deleted from the database.
+     */
+    public static int clearExpiredHistorySearchSuggestions(@NonNull SQLiteDatabase database) {
+        requireNonNull(database);
+
+        final Long creationThreshold = System.currentTimeMillis()
+                - TimeUnit.DAYS.toMillis(TTL_HISTORY_SUGGESTIONS_IN_DAYS);
+
+        final String whereClause = String.format(
+                Locale.ROOT,
+                " %s < ? ",
+                PickerSQLConstants.SearchHistoryTableColumns.CREATION_TIME_MS);
+
+        final String[] whereArgs = List.of(creationThreshold.toString()).toArray(new String[0]);
+
+        int historyDeletionCount =
+                database.delete(
+                        PickerSQLConstants.Table.SEARCH_HISTORY.name(),
+                        whereClause,
+                        whereArgs);
+
+        Log.d(TAG, String.format(
+                Locale.ROOT,
+                "Deleted %s rows in search history table",
+                historyDeletionCount));
+        return historyDeletionCount;
+    }
+
+    /**
+     * Clear all expired history search suggestions from the database that were sourced from the
+     * given authority.
+     *
+     * @param database SQLiteDatabase object that holds DB connections.
+     * @param providerAuthority The provider authority for which all suggestions need to be cleared.
+     *                          If the authority is null, all suggestion search requests stored in
+     *                          the history table will be cleared to  be on the safer side.
+     * @return the number of items deleted from the database.
+     */
+    public static int clearHistorySearchSuggestionsForAuthority(
+            @NonNull SQLiteDatabase database,
+            @Nullable String providerAuthority) {
+        requireNonNull(database);
+
+        final String whereClause;
+        final String[] whereArgs;
+        if (providerAuthority != null) {
+            whereClause = String.format(
+                    Locale.ROOT,
+                    " %s = ? ",
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY);
+
+            whereArgs = List.of(providerAuthority).toArray(new String[0]);
+        } else {
+            whereClause = String.format(
+                    Locale.ROOT,
+                    " %s IS NOT NULL ",
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY);
+
+            whereArgs = null;
+        }
+
+        int historyDeletionCount =
+                database.delete(
+                        PickerSQLConstants.Table.SEARCH_HISTORY.name(),
+                        whereClause,
+                        whereArgs);
+
+        Log.d(TAG, String.format(
+                Locale.ROOT,
+                "Deleted %s rows in search history table",
+                historyDeletionCount));
+        return historyDeletionCount;
+    }
+
     /**
      * @param suggestion Input search suggestion to be saved to be saved in
      * {@link PickerSQLConstants.Table#SEARCH_SUGGESTION}
@@ -412,8 +573,7 @@ public class SearchSuggestionsDatabaseUtils {
         if (suggestionType == null) {
             throw new IllegalArgumentException("Suggestion type cannot be null");
         }
-
-        if (searchText == null && (suggestionType != SEARCH_SUGGESTION_FACE)) {
+        if (searchText == null && !suggestionType.equals(SEARCH_SUGGESTION_FACE)) {
             throw new IllegalArgumentException(
                     "Only FACE type suggestions can have null search text");
         }
@@ -448,8 +608,8 @@ public class SearchSuggestionsDatabaseUtils {
                     PickerSQLConstants.SearchHistoryTableColumns.COVER_MEDIA_ID.getColumnName()));
 
             return new SearchSuggestion(
-                    searchText,
-                    mediaSetId,
+                    getValueOrNull(searchText),
+                    getValueOrNull(mediaSetId),
                     authority,
                     SEARCH_SUGGESTION_HISTORY,
                     coverMediaId
@@ -522,15 +682,21 @@ public class SearchSuggestionsDatabaseUtils {
         if (searchRequest instanceof SearchTextRequest searchTextRequest) {
             values.put(
                     PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName(),
-                    searchTextRequest.getSearchText());
+                    getValueOrPlaceholder(searchTextRequest.getSearchText()));
+
+            values.put(
+                    PickerSQLConstants.SearchHistoryTableColumns.MEDIA_SET_ID.getColumnName(),
+                    PLACEHOLDER_FOR_NULL);
         } else if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
             values.put(
                     PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName(),
-                    searchSuggestionRequest.getSearchSuggestion().getSearchText());
+                    getValueOrPlaceholder(
+                            searchSuggestionRequest.getSearchSuggestion().getSearchText()));
 
             values.put(
                     PickerSQLConstants.SearchHistoryTableColumns.MEDIA_SET_ID.getColumnName(),
-                    searchSuggestionRequest.getSearchSuggestion().getMediaSetId());
+                    getValueOrPlaceholder(
+                            searchSuggestionRequest.getSearchSuggestion().getMediaSetId()));
 
             values.put(
                     PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY.getColumnName(),
@@ -546,5 +712,15 @@ public class SearchSuggestionsDatabaseUtils {
 
         return values;
     }
+
+    @NonNull
+    private static String getValueOrPlaceholder(@Nullable String value) {
+        return value == null ? PLACEHOLDER_FOR_NULL : value;
+    }
+
+    @Nullable
+    private static String getValueOrNull(@Nullable String value) {
+        return (value == null || PLACEHOLDER_FOR_NULL.equals(value)) ? null : value;
+    }
 }
 
diff --git a/src/com/android/providers/media/scan/LegacyMediaScanner.java b/src/com/android/providers/media/scan/LegacyMediaScanner.java
index d73dda584..39bffe2f5 100644
--- a/src/com/android/providers/media/scan/LegacyMediaScanner.java
+++ b/src/com/android/providers/media/scan/LegacyMediaScanner.java
@@ -22,6 +22,7 @@ import android.net.Uri;
 import com.android.providers.media.MediaVolume;
 
 import java.io.File;
+import java.util.Set;
 
 @Deprecated
 public class LegacyMediaScanner implements MediaScanner {
@@ -60,4 +61,9 @@ public class LegacyMediaScanner implements MediaScanner {
     public void onDirectoryDirty(File file) {
         throw new UnsupportedOperationException();
     }
+
+    @Override
+    public Set<String> getOemSupportedMimeTypes() {
+        throw new UnsupportedOperationException();
+    }
 }
diff --git a/src/com/android/providers/media/scan/MediaScanner.java b/src/com/android/providers/media/scan/MediaScanner.java
index 8999542bf..2ce537409 100644
--- a/src/com/android/providers/media/scan/MediaScanner.java
+++ b/src/com/android/providers/media/scan/MediaScanner.java
@@ -33,6 +33,7 @@ import com.android.providers.media.MediaVolume;
 import java.io.File;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Set;
 
 public interface MediaScanner {
     int REASON_UNKNOWN = MEDIA_PROVIDER_SCAN_OCCURRED__REASON__UNKNOWN;
@@ -62,4 +63,9 @@ public interface MediaScanner {
     void onIdleScanStopped();
 
     void onDirectoryDirty(@NonNull File file);
+
+    /**
+     * Returns OEM supported mime types for OEM metadata.
+     */
+    Set<String> getOemSupportedMimeTypes();
 }
diff --git a/src/com/android/providers/media/scan/ModernMediaScanner.java b/src/com/android/providers/media/scan/ModernMediaScanner.java
index 066fbd785..da6b30b5f 100644
--- a/src/com/android/providers/media/scan/ModernMediaScanner.java
+++ b/src/com/android/providers/media/scan/ModernMediaScanner.java
@@ -47,6 +47,7 @@ import static android.media.MediaMetadataRetriever.METADATA_KEY_WRITER;
 import static android.media.MediaMetadataRetriever.METADATA_KEY_YEAR;
 import static android.provider.MediaStore.AUTHORITY;
 import static android.provider.MediaStore.UNKNOWN_STRING;
+import static android.provider.MediaStore.VOLUME_EXTERNAL;
 import static android.text.format.DateUtils.HOUR_IN_MILLIS;
 import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 
@@ -154,6 +155,8 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.TimeZone;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.regex.Matcher;
@@ -259,9 +262,20 @@ public class ModernMediaScanner implements MediaScanner {
      */
     private Set<String> mOemSupportedMimeTypes;
 
+    /**
+     * Default OemMetadataService implementation package.
+     */
+    private Optional<String> mDefaultOemMetadataServicePackage;
+
+    /**
+     * Count down latch to process delay in connection to OemMetadataService.
+     */
+    private CountDownLatch mCountDownLatchForOemMetadataConnection = new CountDownLatch(1);
+
     public ModernMediaScanner(@NonNull Context context, @NonNull ConfigStore configStore) {
         mContext = requireNonNull(context);
         mDrmClient = new DrmManagerClient(context);
+        mDefaultOemMetadataServicePackage = configStore.getDefaultOemMetadataServicePackage();
 
         // Dynamically collect the set of MIME types that should be considered
         // to be DRM, as this can vary between devices
@@ -271,15 +285,26 @@ public class ModernMediaScanner implements MediaScanner {
                 mDrmMimeTypes.add(mimeTypes.next());
             }
         }
-        connectOemMetadataServiceWrapper(configStore);
     }
 
-    private Set<String> getOemSupportedMimeTypes() {
-        if (mOemMetadataServiceWrapper == null) {
-            return new HashSet<String>();
-        }
-
+    @Override
+    public Set<String> getOemSupportedMimeTypes() {
         try {
+            // Return if no package implements OemMetadataService
+            if (!mDefaultOemMetadataServicePackage.isPresent()) {
+                return new HashSet<>();
+            }
+
+            // Setup connection if missing
+            if (mOemMetadataServiceWrapper == null) {
+                connectOemMetadataServiceWrapper();
+            }
+
+            // Return empty set if we cannot setup any connection
+            if (mOemMetadataServiceWrapper == null) {
+                return new HashSet<>();
+            }
+
             return mOemMetadataServiceWrapper.getSupportedMimeTypes();
         } catch (Exception e) {
             Log.w(TAG, "Error in fetching OEM supported mimetypes", e);
@@ -287,32 +312,42 @@ public class ModernMediaScanner implements MediaScanner {
         }
     }
 
-    private void connectOemMetadataServiceWrapper(ConfigStore configStore) {
-        if (!enableOemMetadata()) {
-            return;
-        }
+    private synchronized void connectOemMetadataServiceWrapper() {
+        try {
+            if (!enableOemMetadata()) {
+                return;
+            }
 
-        Optional<String> pkgOptional = configStore.getDefaultOemMetadataServicePackage();
-        if (!pkgOptional.isPresent()) {
-            Log.v(TAG, "No default package listed for OEM Metadata service");
-            return;
-        }
+            // Return if wrapper is already initialised
+            if (mOemMetadataServiceWrapper != null) {
+                return;
+            }
 
-        Intent intent = new Intent(OemMetadataService.SERVICE_INTERFACE);
-        ResolveInfo resolveInfo = mContext.getPackageManager().resolveService(intent,
-                PackageManager.MATCH_ALL);
-        if (resolveInfo == null || resolveInfo.serviceInfo == null
-                || resolveInfo.serviceInfo.packageName == null
-                || !pkgOptional.get().equalsIgnoreCase(resolveInfo.serviceInfo.packageName)
-                || resolveInfo.serviceInfo.permission == null
-                || !resolveInfo.serviceInfo.permission.equalsIgnoreCase(
-                OemMetadataService.BIND_OEM_METADATA_SERVICE_PERMISSION)) {
-            Log.v(TAG, "No valid package found for OEM Metadata service");
-            return;
-        }
+            if (!mDefaultOemMetadataServicePackage.isPresent()) {
+                Log.v(TAG, "No default package listed for OEM Metadata service");
+                return;
+            }
+
+            Intent intent = new Intent(OemMetadataService.SERVICE_INTERFACE);
+            ResolveInfo resolveInfo = mContext.getPackageManager().resolveService(intent,
+                    PackageManager.MATCH_ALL);
+            if (resolveInfo == null || resolveInfo.serviceInfo == null
+                    || resolveInfo.serviceInfo.packageName == null
+                    || !mDefaultOemMetadataServicePackage.get().equalsIgnoreCase(
+                    resolveInfo.serviceInfo.packageName)
+                    || resolveInfo.serviceInfo.permission == null
+                    || !resolveInfo.serviceInfo.permission.equalsIgnoreCase(
+                    OemMetadataService.BIND_OEM_METADATA_SERVICE_PERMISSION)) {
+                Log.v(TAG, "No valid package found for OEM Metadata service");
+                return;
+            }
 
-        intent.setPackage(pkgOptional.get());
-        mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);
+            intent.setPackage(mDefaultOemMetadataServicePackage.get());
+            mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);
+            mCountDownLatchForOemMetadataConnection.await(5, TimeUnit.SECONDS);
+        } catch (Exception e) {
+            Log.e(TAG, "Exception in connecting OemMetadataServiceWrapper", e);
+        }
     }
 
     private ServiceConnection mServiceConnection = new ServiceConnection() {
@@ -320,15 +355,31 @@ public class ModernMediaScanner implements MediaScanner {
         public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
             IOemMetadataService service = IOemMetadataService.Stub.asInterface(iBinder);
             mOemMetadataServiceWrapper = new OemMetadataServiceWrapper(service);
+            mCountDownLatchForOemMetadataConnection.countDown();
             Log.i(TAG, "Connected to OemMetadataService");
         }
+
         @Override
         public void onServiceDisconnected(ComponentName componentName) {
             mOemMetadataServiceWrapper = null;
-            Log.i(TAG, "Disconnected from OemMetadataService");
+            Log.w(TAG, "Disconnected from OemMetadataService");
+            mCountDownLatchForOemMetadataConnection = new CountDownLatch(1);
+        }
+
+        @Override
+        public void onBindingDied(ComponentName name) {
+            Log.w(TAG, "Binding to OemMetadataService died");
+            mContext.unbindService(this);
+            mOemMetadataServiceWrapper = null;
+            mCountDownLatchForOemMetadataConnection = new CountDownLatch(1);
         }
     };
 
+    @VisibleForTesting
+    public ServiceConnection getOemMetadataServiceConnection() {
+        return mServiceConnection;
+    }
+
     @Override
     @NonNull
     public Context getContext() {
@@ -474,11 +525,6 @@ public class ModernMediaScanner implements MediaScanner {
         private int mUpdateCount;
         private int mDeleteCount;
 
-        /**
-         * Tracks hidden directory and hidden subdirectories in a directory tree. A positive count
-         * indicates that one or more of the current file's parents is a hidden directory.
-         */
-        private int mHiddenDirCount;
         /**
          * Indicates if the nomedia directory tree is dirty. When a nomedia directory is dirty, we
          * mark the top level nomedia as dirty. Hence if one of the sub directory in the nomedia
@@ -486,6 +532,12 @@ public class ModernMediaScanner implements MediaScanner {
          */
         private boolean mIsDirectoryTreeDirty;
 
+        /**
+         * Tracks hidden directory and hidden subdirectories in a directory tree.
+         */
+        private boolean mIsDirectoryTreeHidden = false;
+        private String mTopLevelHiddenDirectory;
+
         Scan(File root, int reason) throws FileNotFoundException {
             Trace.beginSection("Scanner.ctor");
 
@@ -551,16 +603,20 @@ public class ModernMediaScanner implements MediaScanner {
 
         private void walkFileTree() {
             mSignal.throwIfCanceled();
-            final Pair<Boolean, Boolean> isDirScannableAndHidden =
-                    shouldScanPathAndIsPathHidden(mSingleFile ? mRoot.getParentFile() : mRoot);
+
+            File dirPath = mSingleFile ? mRoot.getParentFile() : mRoot;
+            final Pair<Boolean, Boolean> isDirScannableAndHidden = shouldScanPathAndIsPathHidden(
+                    dirPath);
             if (isDirScannableAndHidden.first) {
                 // This directory is scannable.
                 Trace.beginSection("Scanner.walkFileTree");
 
                 if (isDirScannableAndHidden.second) {
                     // This directory is hidden
-                    mHiddenDirCount++;
+                    mIsDirectoryTreeHidden = true;
+                    mTopLevelHiddenDirectory = dirPath.getAbsolutePath();
                 }
+
                 if (mSingleFile) {
                     acquireDirectoryLock(mRoot.getParentFile().toPath().toString());
                 }
@@ -842,8 +898,9 @@ public class ModernMediaScanner implements MediaScanner {
             // overlap and confuse each other
             acquireDirectoryLock(dir.toString());
 
-            if (FileUtils.isDirectoryHidden(dir.toFile())) {
-                mHiddenDirCount++;
+            if (!mIsDirectoryTreeHidden && FileUtils.isDirectoryHidden(dir.toFile())) {
+                mIsDirectoryTreeHidden = true;
+                mTopLevelHiddenDirectory = dir.toString();
             }
 
             // Scan this directory as a normal file so that "parent" database
@@ -998,17 +1055,35 @@ public class ModernMediaScanner implements MediaScanner {
         }
 
         private void fetchOemMetadata(ContentProviderOperation.Builder op, File file) {
-            if (!enableOemMetadata() || mOemMetadataServiceWrapper == null) {
+            if (!enableOemMetadata()) {
                 return;
             }
+            try {
+                // Return if no package implements OemMetadataService
+                if (!mDefaultOemMetadataServicePackage.isPresent()) {
+                    return;
+                }
+
+                if (mOemMetadataServiceWrapper == null) {
+                    connectOemMetadataServiceWrapper();
+                }
+
+                // Return if we cannot find any connection
+                if (mOemMetadataServiceWrapper == null) {
+                    return;
+                }
 
-            try (ParcelFileDescriptor pfd = FileUtils.openSafely(file,
-                    ParcelFileDescriptor.MODE_READ_ONLY)) {
-                Map<String, String> oemMetadata = mOemMetadataServiceWrapper.getOemCustomData(pfd);
-                op.withValue(FileColumns.OEM_METADATA, oemMetadata.toString().getBytes());
-                Log.v(TAG, "Fetched OEM metadata successfully");
+                try (ParcelFileDescriptor pfd = FileUtils.openSafely(file,
+                        ParcelFileDescriptor.MODE_READ_ONLY)) {
+                    Map<String, String> oemMetadata = mOemMetadataServiceWrapper.getOemCustomData(
+                            pfd);
+                    op.withValue(FileColumns.OEM_METADATA, oemMetadata.toString().getBytes());
+                    Log.v(TAG, "Fetched OEM metadata successfully");
+                } catch (Exception e) {
+                    Log.w(TAG, "Failure in fetching OEM metadata", e);
+                }
             } catch (Exception e) {
-                Log.w(TAG, "Failure in fetching OEM metadata", e);
+                Log.w(TAG, "Failure in connecting to OEM metadata service", e);
             }
         }
 
@@ -1016,7 +1091,7 @@ public class ModernMediaScanner implements MediaScanner {
                 File file, String mimeType, int defaultMediaType) {
             if (mimeType != null) {
                 return resolveMediaTypeFromFilePath(
-                        file, mimeType, /*isHidden*/ mHiddenDirCount > 0);
+                        file, mimeType, /*isHidden*/ mIsDirectoryTreeHidden);
             }
             return defaultMediaType;
         }
@@ -1075,8 +1150,18 @@ public class ModernMediaScanner implements MediaScanner {
             // before releasing our lock below
             applyPending();
 
-            if (FileUtils.isDirectoryHidden(dir.toFile())) {
-                mHiddenDirCount--;
+            boolean isDirHidden = FileUtils.isDirectoryHidden(dir.toFile());
+
+            if (isDirHidden && !mIsDirectoryTreeHidden) {
+                Log.w(TAG, "Hidden state of directory " + dir + " changed during active scan.");
+            }
+
+            if (mTopLevelHiddenDirectory != null && dir.toString().equals(
+                    mTopLevelHiddenDirectory)) {
+                // Post visit the top level hidden directory being tracked. Reset hidden status
+                // for directory tree.
+                mIsDirectoryTreeHidden = false;
+                mTopLevelHiddenDirectory = null;
             }
 
             // Now that we're finished scanning this directory, release lock to
@@ -1196,21 +1281,20 @@ public class ModernMediaScanner implements MediaScanner {
         }
 
         // Recovery is performed on first scan of file in target device
-        if (existingId == -1) {
-            try {
-                if (restoreExecutor != null) {
-                    Optional<ContentValues> restoredDataOptional =
-                            restoreExecutor.getMetadataForFileIfBackedUp(file.getAbsolutePath());
-                    if (restoredDataOptional.isPresent()) {
-                        ContentValues valuesRestored = restoredDataOptional.get();
-                        if (isRestoredMetadataOfActualFile(valuesRestored, attrs)) {
-                            return restoreDataFromBackup(valuesRestored, file, attrs, mimeType);
-                        }
+        try {
+            if (restoreExecutor != null) {
+                Optional<ContentValues> restoredDataOptional = restoreExecutor
+                        .getMetadataForFileIfBackedUp(file.getAbsolutePath(), mContext);
+                if (restoredDataOptional.isPresent()) {
+                    ContentValues valuesRestored = restoredDataOptional.get();
+                    if (isRestoredMetadataOfActualFile(valuesRestored, attrs)) {
+                        return restoreDataFromBackup(valuesRestored, file, attrs, mimeType,
+                                existingId);
                     }
                 }
-            } catch (Exception e) {
-                Log.e(TAG, "Error while attempting to restore metadata from backup", e);
             }
+        } catch (Exception e) {
+            Log.e(TAG, "Error while attempting to restore metadata from backup", e);
         }
 
         switch (mediaType) {
@@ -1243,8 +1327,9 @@ public class ModernMediaScanner implements MediaScanner {
     }
 
     private ContentProviderOperation.Builder restoreDataFromBackup(
-            ContentValues restoredValues, File file, BasicFileAttributes attrs, String mimeType) {
-        final ContentProviderOperation.Builder op = newUpsert(MediaStore.VOLUME_EXTERNAL, -1);
+            ContentValues restoredValues, File file, BasicFileAttributes attrs, String mimeType,
+            long existingId) {
+        final ContentProviderOperation.Builder op = newUpsert(VOLUME_EXTERNAL, existingId);
         withGenericValues(op, file, attrs, mimeType, /* mediaType */ null);
         op.withValues(restoredValues);
         return op;
diff --git a/src/com/android/providers/media/util/MimeTypeFixHandler.java b/src/com/android/providers/media/util/MimeTypeFixHandler.java
new file mode 100644
index 000000000..8bdd88ef1
--- /dev/null
+++ b/src/com/android/providers/media/util/MimeTypeFixHandler.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.provider.MediaStore;
+import android.util.Log;
+
+import com.android.providers.media.R;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * Utility class for handling MIME type mappings.
+ */
+public final class MimeTypeFixHandler {
+
+    private static final String TAG = "MimeTypeFixHandler";
+    private static final Map<String, String> sExtToMimeType = new HashMap<>();
+    private static final Map<String, String> sMimeTypeToExt = new HashMap<>();
+
+    private static final Map<String, String> sCorruptedExtToMimeType = new HashMap<>();
+    private static final Map<String, String> sCorruptedMimeTypeToExt = new HashMap<>();
+
+    /**
+     * Loads MIME type mappings from the classpath resource if not already loaded.
+     * <p>
+     * This method initializes both the standard and corrupted MIME type maps.
+     * </p>
+     */
+    public static void loadMimeTypes(Context context) {
+        if (context == null) {
+            return;
+        }
+
+        if (sExtToMimeType.isEmpty()) {
+            parseTypes(context, R.raw.mime_types, sExtToMimeType, sMimeTypeToExt);
+            // this will add or override the extension to mime type mapping
+            parseTypes(context, R.raw.android_mime_types, sExtToMimeType, sMimeTypeToExt);
+            Log.v(TAG, "MIME types loaded");
+        }
+        if (sCorruptedExtToMimeType.isEmpty()) {
+            parseTypes(context, R.raw.corrupted_mime_types, sCorruptedExtToMimeType,
+                    sCorruptedMimeTypeToExt);
+            Log.v(TAG, "Corrupted MIME types loaded");
+        }
+
+    }
+
+    /**
+     * Parses the specified mime types file and populates the provided mapping with file extension
+     * to MIME type entries.
+     *
+     * @param resource the mime.type resource
+     * @param mapping  the map to populate with file extension (key) to MIME type (value) mappings
+     */
+    private static void parseTypes(Context context, int resource, Map<String, String> extToMimeType,
+            Map<String, String> mimeTypeToExt) {
+        try (InputStream inputStream = context.getResources().openRawResource(resource)) {
+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
+                String line;
+                while ((line = reader.readLine()) != null) {
+                    // Strip comments and normalize whitespace
+                    line = line.replaceAll("#.*$", "").trim().replaceAll("\\s+", " ");
+                    // Skip empty lines or lines without a space (i.e., no extension mapping)
+                    if (line.isEmpty() || !line.contains(" ")) {
+                        continue;
+                    }
+                    String[] tokens = line.split(" ");
+                    if (tokens.length < 2) {
+                        continue;
+                    }
+                    String mimeType = tokens[0].toLowerCase(Locale.ROOT);
+                    String firstExt = tokens[1].toLowerCase(Locale.ROOT);
+                    if (firstExt.startsWith("?")) {
+                        firstExt = firstExt.substring(1);
+                        if (firstExt.isEmpty()) {
+                            continue;
+                        }
+                    }
+
+                    // ?mime ext1 ?ext2 ext3
+                    if (mimeType.toLowerCase(Locale.ROOT).startsWith("?")) {
+                        mimeType = mimeType.substring(1); // Remove the "?"
+                        if (mimeType.isEmpty()) {
+                            continue;
+                        }
+                        mimeTypeToExt.putIfAbsent(mimeType, firstExt);
+                    } else {
+                        mimeTypeToExt.put(mimeType, firstExt);
+                    }
+
+                    for (int i = 1; i < tokens.length; i++) {
+                        String extension = tokens[i].toLowerCase(Locale.ROOT);
+                        boolean putIfAbsent = extension.startsWith("?");
+                        if (putIfAbsent) {
+                            extension = extension.substring(1); // Remove the "?"
+                            extToMimeType.putIfAbsent(extension, mimeType);
+                        } else {
+                            extToMimeType.put(extension, mimeType);
+                        }
+                    }
+                }
+            }
+        } catch (IOException | RuntimeException e) {
+            Log.e(TAG, "Exception raised while parsing mime.types", e);
+        }
+    }
+
+    /**
+     * Returns the MIME type for the given file extension from our internal mappings.
+     *
+     * @param extension The file extension to look up.
+     * @return The associated MIME type from the primary mapping if available, or
+     * {@link android.content.ClipDescription#MIMETYPE_UNKNOWN} if the extension is marked
+     * as corrupted
+     * Returns {@link Optional#empty()}  if not found in either mapping.
+     */
+    static Optional<String> getMimeType(String extension) {
+        String lowerExt = extension.toLowerCase(Locale.ROOT);
+        if (sExtToMimeType.containsKey(lowerExt)) {
+            return Optional.of(sExtToMimeType.get(lowerExt));
+        }
+
+        if (sCorruptedExtToMimeType.containsKey(lowerExt)) {
+            return Optional.of(android.content.ClipDescription.MIMETYPE_UNKNOWN);
+        }
+
+        return Optional.empty();
+    }
+
+    /**
+     * Gets file extension from MIME type.
+     *
+     * @param mimeType The MIME type.
+     * @return Optional file extension, or empty.
+     */
+    static Optional<String> getExtFromMimeType(String mimeType) {
+        if (mimeType == null) {
+            return Optional.empty();
+        }
+
+        mimeType = mimeType.toLowerCase(Locale.ROOT);
+        return Optional.ofNullable(sMimeTypeToExt.get(mimeType));
+    }
+
+    /**
+     * Checks if a MIME type is corrupted.
+     *
+     * @param mimeType The MIME type.
+     * @return {@code true} if corrupted, {@code false} otherwise.
+     */
+    static boolean isCorruptedMimeType(String mimeType) {
+        if (sMimeTypeToExt.containsKey(mimeType)) {
+            return false;
+        }
+
+        return sCorruptedMimeTypeToExt.containsKey(mimeType);
+    }
+
+
+    /**
+     * Scans the database for files with unsupported or mismatched MIME types and updates them.
+     *
+     * @param db The SQLiteDatabase to update.
+     * @return true if all intended updates were successfully applied (or if there were no files),
+     * false otherwise.
+     */
+    public static boolean updateUnsupportedMimeTypes(SQLiteDatabase db) {
+        class FileMimeTypeUpdate {
+            final long mFileId;
+            final String mNewMimeType;
+
+            FileMimeTypeUpdate(long fileId, String newMimeType) {
+                this.mFileId = fileId;
+                this.mNewMimeType = newMimeType;
+            }
+        }
+
+        List<FileMimeTypeUpdate> filesToUpdate = new ArrayList<>();
+        String[] projections = new String[]{MediaStore.Files.FileColumns._ID,
+                MediaStore.Files.FileColumns.DATA,
+                MediaStore.Files.FileColumns.MIME_TYPE,
+                MediaStore.Files.FileColumns.DISPLAY_NAME
+        };
+        try (Cursor cursor = db.query(MediaStore.Files.TABLE, projections,
+                null, null, null, null, null)) {
+
+            while (cursor != null && cursor.moveToNext()) {
+                long fileId = cursor.getLong(cursor.getColumnIndexOrThrow(
+                        MediaStore.Files.FileColumns._ID));
+                String data = cursor.getString(cursor.getColumnIndexOrThrow(
+                        MediaStore.Files.FileColumns.DATA));
+                String currentMimeType = cursor.getString(
+                        cursor.getColumnIndexOrThrow(MediaStore.Files.FileColumns.MIME_TYPE));
+                String displayName = cursor.getString(cursor.getColumnIndexOrThrow(
+                        MediaStore.Files.FileColumns.DISPLAY_NAME));
+
+                String extension = FileUtils.extractFileExtension(data);
+                if (extension == null) {
+                    continue;
+                }
+                String newMimeType = MimeUtils.resolveMimeType(new File(displayName));
+                if (!newMimeType.equalsIgnoreCase(currentMimeType)) {
+                    filesToUpdate.add(new FileMimeTypeUpdate(fileId, newMimeType));
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to fetch files for MIME type check", e);
+            return false;
+        }
+
+        Log.v(TAG, "Identified " + filesToUpdate.size() + " files with incorrect MIME types.");
+        int updatedRows = 0;
+        for (FileMimeTypeUpdate fileUpdate : filesToUpdate) {
+            try {
+                ContentValues contentValues = new ContentValues();
+                contentValues.put(MediaStore.Files.FileColumns.MIME_TYPE, fileUpdate.mNewMimeType);
+                contentValues.put(MediaStore.Files.FileColumns.MEDIA_TYPE,
+                        MimeUtils.resolveMediaType(fileUpdate.mNewMimeType));
+
+                String whereClause = MediaStore.Files.FileColumns._ID + " = ?";
+                String[] whereArgs = new String[]{String.valueOf(fileUpdate.mFileId)};
+                updatedRows += db.update(MediaStore.Files.TABLE, contentValues, whereClause,
+                        whereArgs);
+            } catch (Exception e) {
+                Log.e(TAG, "Error updating file with id: " + fileUpdate.mFileId, e);
+            }
+        }
+        Log.v(TAG, "Updated MIME type and Media type for " + updatedRows + " rows");
+        return updatedRows == filesToUpdate.size();
+    }
+}
diff --git a/src/com/android/providers/media/util/MimeUtils.java b/src/com/android/providers/media/util/MimeUtils.java
index cdd2c8287..5698a83aa 100644
--- a/src/com/android/providers/media/util/MimeUtils.java
+++ b/src/com/android/providers/media/util/MimeUtils.java
@@ -18,6 +18,7 @@ package com.android.providers.media.util;
 
 import android.content.ClipDescription;
 import android.mtp.MtpConstants;
+import android.os.Build;
 import android.provider.MediaStore.Files.FileColumns;
 import android.util.Log;
 import android.webkit.MimeTypeMap;
@@ -26,8 +27,11 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 
+import com.android.providers.media.flags.Flags;
+
 import java.io.File;
 import java.util.Locale;
+import java.util.Optional;
 
 public class MimeUtils {
     private static final String TAG = "MimeUtils";
@@ -46,6 +50,13 @@ public class MimeUtils {
         final String extension = FileUtils.extractFileExtension(file.getPath());
         if (extension == null) return ClipDescription.MIMETYPE_UNKNOWN;
 
+        // In Android 15, certain unsupported MIME types were introduced
+        // This ensures new files with these MIME types are handled with the correct MIME type
+        Optional<String> android15MimeType = getMimeTypeForAndroid15(extension);
+        if (android15MimeType.isPresent()) {
+            return android15MimeType.get();
+        }
+
         final String mimeType = MimeTypeMap.getSingleton()
                 .getMimeTypeFromExtension(extension.toLowerCase(Locale.ROOT));
         if (mimeType == null) return ClipDescription.MIMETYPE_UNKNOWN;
@@ -265,6 +276,11 @@ public class MimeUtils {
      */
     @NonNull
     public static String getExtensionFromMimeType(@Nullable String mimeType) {
+        Optional<String> android15Extension = getExtFromMimeTypeForAndroid15(mimeType);
+        if (android15Extension.isPresent()) {
+            return android15Extension.get();
+        }
+
         final String extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
         if (extension != null) {
             return "." + extension;
@@ -283,4 +299,36 @@ public class MimeUtils {
 
         return "";
     }
+
+    private static Optional<String> getMimeTypeForAndroid15(String extension) {
+        if (Flags.enableMimeTypeFixForAndroid15()
+                && Build.VERSION.SDK_INT == Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+            return MimeTypeFixHandler.getMimeType(extension);
+        }
+        return Optional.empty();
+    }
+
+    /**
+     * Gets file extension from MIME type for Android 15.
+     * Handles Android 15 specific MIME type to extension mapping. If the mime-type is corrupted,
+     * then return the default one with respect to mime type.
+     *
+     * @param mimeType The MIME type.
+     * @return Optional file extension (with dot), or empty.
+     */
+    private static Optional<String> getExtFromMimeTypeForAndroid15(String mimeType) {
+        if (Flags.enableMimeTypeFixForAndroid15()
+                && Build.VERSION.SDK_INT == Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+            Optional<String> value = MimeTypeFixHandler.getExtFromMimeType(mimeType);
+            if (value.isPresent()) {
+                return Optional.of("." + value.get());
+            } else if (MimeTypeFixHandler.isCorruptedMimeType(mimeType)) {
+                if (isImageMimeType(mimeType)) return Optional.of(DEFAULT_IMAGE_FILE_EXTENSION);
+                if (isVideoMimeType(mimeType)) return Optional.of(DEFAULT_VIDEO_FILE_EXTENSION);
+                return Optional.of("");
+            }
+        }
+        return Optional.empty();
+    }
+
 }
diff --git a/src/com/android/providers/media/util/PermissionUtils.java b/src/com/android/providers/media/util/PermissionUtils.java
index 3a272eee0..7dbfd23da 100644
--- a/src/com/android/providers/media/util/PermissionUtils.java
+++ b/src/com/android/providers/media/util/PermissionUtils.java
@@ -148,6 +148,41 @@ public class PermissionUtils {
                 generateAppOpMessage(packageName,sOpDescription.get()));
     }
 
+    /**
+     * Check for read permission when legacy storage is granted.
+     * There is a bug in AppOpsManager that keeps legacy storage granted even
+     * when an app updates its targetSdkVersion from value <30 to >=30.
+     * If an app upgrades from targetSdk 29 to targetSdk 33, legacy storage
+     * remains granted and in targetSdk 33, app are required to replace R_E_S
+     * with R_M_*. If an app updates its manifest with R_M_*, permission check
+     * in MediaProvider will look for R_E_S and will not grant read access as
+     * the app would be still treated as legacy. Ensure that legacy app either has
+     * R_E_S or all of R_M_* to get read permission. Since this is a fix for legacy
+     * app op bug, we are avoiding granular permission checks based on media type.
+     */
+    public static boolean checkPermissionReadForLegacyStorage(@NonNull Context context,
+            int pid, int uid, @NonNull String packageName, @Nullable String attributionTag,
+            boolean isTargetSdkAtleastT) {
+        if (isTargetSdkAtleastT) {
+            return checkPermissionForDataDelivery(context, READ_EXTERNAL_STORAGE, pid, uid,
+                    packageName, attributionTag,
+                    generateAppOpMessage(packageName, sOpDescription.get())) || (
+                    checkPermissionForDataDelivery(context, READ_MEDIA_IMAGES, pid, uid,
+                            packageName, attributionTag,
+                            generateAppOpMessage(packageName, sOpDescription.get()))
+                            && checkPermissionForDataDelivery(context, READ_MEDIA_VIDEO, pid, uid,
+                            packageName, attributionTag,
+                            generateAppOpMessage(packageName, sOpDescription.get()))
+                            && checkPermissionForDataDelivery(context, READ_MEDIA_AUDIO, pid, uid,
+                            packageName, attributionTag,
+                            generateAppOpMessage(packageName, sOpDescription.get())));
+        } else {
+            return checkPermissionForDataDelivery(context, READ_EXTERNAL_STORAGE, pid, uid,
+                    packageName, attributionTag,
+                    generateAppOpMessage(packageName, sOpDescription.get()));
+        }
+    }
+
     /**
      * Check if the given package has been granted the
      * android.Manifest.permission#ACCESS_MEDIA_LOCATION permission.
@@ -191,7 +226,8 @@ public class PermissionUtils {
             }
 
             return amlRequested && userSelectedImplicit && checkPermissionReadVisualUserSelected(
-                    context, pid, uid, packageName, attributionTag, isTargetSdkAtLeastT);
+                    context, pid, uid, packageName, attributionTag, isTargetSdkAtLeastT,
+                    /* forDataDelivery */ true);
         } catch (PackageManager.NameNotFoundException e) {
             return false;
         }
@@ -208,13 +244,13 @@ public class PermissionUtils {
     }
 
     public static boolean checkIsLegacyStorageGranted(@NonNull Context context, int uid,
-            String packageName, @Nullable String attributionTag, boolean isTargetSdkAtLeastV) {
+            String packageName, boolean isTargetSdkAtLeastV) {
         if (!isTargetSdkAtLeastV && context.getSystemService(AppOpsManager.class)
                 .unsafeCheckOp(OPSTR_LEGACY_STORAGE, uid, packageName) == MODE_ALLOWED) {
             return true;
         }
         // Check OPSTR_NO_ISOLATED_STORAGE app op.
-        return checkNoIsolatedStorageGranted(context, uid, packageName, attributionTag);
+        return checkNoIsolatedStorageGranted(context, uid, packageName);
     }
 
     public static boolean checkPermissionReadAudio(
@@ -223,7 +259,8 @@ public class PermissionUtils {
             int uid,
             @NonNull String packageName,
             @Nullable String attributionTag,
-            boolean targetSdkIsAtLeastT) {
+            boolean targetSdkIsAtLeastT,
+            boolean forDataDelivery) {
 
         String permission = targetSdkIsAtLeastT && SdkLevel.isAtLeastT()
                 ? READ_MEDIA_AUDIO : READ_EXTERNAL_STORAGE;
@@ -233,18 +270,18 @@ public class PermissionUtils {
         }
         return checkAppOpAllowingLegacy(context, OPSTR_READ_MEDIA_AUDIO, pid,
                 uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     public static boolean checkPermissionWriteAudio(@NonNull Context context, int pid, int uid,
-            @NonNull String packageName, @Nullable String attributionTag) {
+            @NonNull String packageName, @Nullable String attributionTag, boolean forDataDelivery) {
         if (!checkPermissionAllowingNonLegacy(
                     context, WRITE_EXTERNAL_STORAGE, pid, uid, packageName)) {
             return false;
         }
         return checkAppOpAllowingLegacy(context, OPSTR_WRITE_MEDIA_AUDIO, pid,
                 uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     public static boolean checkPermissionReadVideo(
@@ -253,7 +290,8 @@ public class PermissionUtils {
             int uid,
             @NonNull String packageName,
             @Nullable String attributionTag,
-            boolean targetSdkIsAtLeastT) {
+            boolean targetSdkIsAtLeastT,
+            boolean forDataDelivery) {
         String permission = targetSdkIsAtLeastT && SdkLevel.isAtLeastT()
                 ? READ_MEDIA_VIDEO : READ_EXTERNAL_STORAGE;
 
@@ -263,18 +301,18 @@ public class PermissionUtils {
 
         return checkAppOpAllowingLegacy(context, OPSTR_READ_MEDIA_VIDEO, pid,
                 uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     public static boolean checkPermissionWriteVideo(@NonNull Context context, int pid, int uid,
-            @NonNull String packageName, @Nullable String attributionTag) {
+            @NonNull String packageName, @Nullable String attributionTag, boolean forDataDelivery) {
         if (!checkPermissionAllowingNonLegacy(
                 context, WRITE_EXTERNAL_STORAGE, pid, uid, packageName)) {
             return false;
         }
         return checkAppOpAllowingLegacy(context, OPSTR_WRITE_MEDIA_VIDEO, pid,
                 uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     public static boolean checkPermissionReadImages(
@@ -283,7 +321,7 @@ public class PermissionUtils {
             int uid,
             @NonNull String packageName,
             @Nullable String attributionTag,
-            boolean targetSdkIsAtLeastT) {
+            boolean targetSdkIsAtLeastT, boolean forDataDelivery) {
         String permission = targetSdkIsAtLeastT && SdkLevel.isAtLeastT()
                 ? READ_MEDIA_IMAGES : READ_EXTERNAL_STORAGE;
 
@@ -293,18 +331,18 @@ public class PermissionUtils {
 
         return checkAppOpAllowingLegacy(context, OPSTR_READ_MEDIA_IMAGES, pid,
                 uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     public static boolean checkPermissionWriteImages(@NonNull Context context, int pid, int uid,
-            @NonNull String packageName, @Nullable String attributionTag) {
+            @NonNull String packageName, @Nullable String attributionTag, boolean forDataDelivery) {
         if (!checkPermissionAllowingNonLegacy(
                 context, WRITE_EXTERNAL_STORAGE, pid, uid, packageName)) {
             return false;
         }
         return checkAppOpAllowingLegacy(context, OPSTR_WRITE_MEDIA_IMAGES, pid,
                 uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     /**
@@ -317,13 +355,21 @@ public class PermissionUtils {
             int uid,
             @NonNull String packageName,
             @Nullable String attributionTag,
-            boolean targetSdkIsAtLeastT) {
+            boolean targetSdkIsAtLeastT,
+            boolean forDataDelivery) {
         if (!SdkLevel.isAtLeastU() || !targetSdkIsAtLeastT) {
             return false;
         }
-        return checkPermissionForDataDelivery(context, READ_MEDIA_VISUAL_USER_SELECTED, pid, uid,
-                packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+        if (forDataDelivery) {
+            return checkPermissionForDataDelivery(context, READ_MEDIA_VISUAL_USER_SELECTED, pid,
+                    uid,
+                    packageName, attributionTag,
+                    generateAppOpMessage(packageName, sOpDescription.get()));
+        } else {
+            return checkPermissionForPreflight(context, READ_MEDIA_VISUAL_USER_SELECTED, pid,
+                    uid,
+                    packageName);
+        }
     }
 
     /**
@@ -349,7 +395,7 @@ public class PermissionUtils {
 
     /**
      * Check if the given package has been granted the
-     * android.provider.MediaStore#ACCESS_OEM_METADATA_PERMISSION permission.
+     * {@link android.provider.MediaStore#ACCESS_OEM_METADATA_PERMISSION} permission.
      */
     public static boolean checkPermissionAccessOemMetadata(@NonNull Context context,
             int pid, int uid, @NonNull String packageName, @Nullable String attributionTag) {
@@ -357,6 +403,16 @@ public class PermissionUtils {
                 pid, uid, packageName, attributionTag, null);
     }
 
+    /**
+     * Check if the given package has been granted the
+     * {@link android.provider.MediaStore#UPDATE_OEM_METADATA_PERMISSION} permission.
+     */
+    public static boolean checkPermissionUpdateOemMetadata(@NonNull Context context,
+            int pid, int uid, @NonNull String packageName, @Nullable String attributionTag) {
+        return checkPermissionForPreflight(context, MediaStore.UPDATE_OEM_METADATA_PERMISSION,
+                pid, uid, packageName);
+    }
+
     public static boolean checkPermissionInstallPackages(@NonNull Context context, int pid, int uid,
         @NonNull String packageName, @Nullable String attributionTag) {
         return checkPermissionForDataDelivery(context, INSTALL_PACKAGES, pid,
@@ -374,13 +430,13 @@ public class PermissionUtils {
      * indicates the package is a system gallery.
      */
     public static boolean checkWriteImagesOrVideoAppOps(@NonNull Context context, int uid,
-            @NonNull String packageName, @Nullable String attributionTag) {
+            @NonNull String packageName, @Nullable String attributionTag, boolean forDataDelivery) {
         return checkAppOp(
                 context, OPSTR_WRITE_MEDIA_IMAGES, uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()))
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery)
                 || checkAppOp(
                         context, OPSTR_WRITE_MEDIA_VIDEO, uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, sOpDescription.get()));
+                generateAppOpMessage(packageName, sOpDescription.get()), forDataDelivery);
     }
 
     /**
@@ -390,7 +446,8 @@ public class PermissionUtils {
             int uid, @NonNull String[] sharedPackageNames, @Nullable String attributionTag) {
         for (String packageName : sharedPackageNames) {
             if (checkAppOp(context, OPSTR_REQUEST_INSTALL_PACKAGES, uid, packageName,
-                    attributionTag, generateAppOpMessage(packageName, sOpDescription.get()))) {
+                    attributionTag, generateAppOpMessage(packageName, sOpDescription.get()),
+                    /*forDataDelivery*/ false)) {
                 return true;
             }
         }
@@ -415,10 +472,9 @@ public class PermissionUtils {
 
     @VisibleForTesting
     static boolean checkNoIsolatedStorageGranted(@NonNull Context context, int uid,
-            @NonNull String packageName, @Nullable String attributionTag) {
+            @NonNull String packageName) {
         final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
-        int ret = appOps.noteOpNoThrow(OPSTR_NO_ISOLATED_STORAGE, uid, packageName, attributionTag,
-                generateAppOpMessage(packageName, "am instrument --no-isolated-storage"));
+        int ret = appOps.unsafeCheckOpNoThrow(OPSTR_NO_ISOLATED_STORAGE, uid, packageName);
         return ret == AppOpsManager.MODE_ALLOWED;
     }
 
@@ -455,9 +511,10 @@ public class PermissionUtils {
      */
     private static boolean checkAppOp(@NonNull Context context,
             @NonNull String op, int uid, @NonNull String packageName,
-            @Nullable String attributionTag, @Nullable String opMessage) {
+            @Nullable String attributionTag, @Nullable String opMessage, boolean forDataDelivery) {
         final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
-        final int mode = appOps.noteOpNoThrow(op, uid, packageName, attributionTag, opMessage);
+        final int mode = forDataDelivery ? appOps.noteOpNoThrow(op, uid, packageName,
+                attributionTag, opMessage) : appOps.unsafeCheckOpNoThrow(op, uid, packageName);
         switch (mode) {
             case AppOpsManager.MODE_ALLOWED:
                 return true;
@@ -476,9 +533,11 @@ public class PermissionUtils {
      */
     private static boolean checkAppOpAllowingLegacy(@NonNull Context context,
             @NonNull String op, int pid, int uid, @NonNull String packageName,
-            @Nullable String attributionTag, @Nullable String opMessage) {
+            @Nullable String attributionTag, @Nullable String opMessage, boolean forDataDelivery) {
         final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
-        final int mode = appOps.noteOpNoThrow(op, uid, packageName, attributionTag, opMessage);
+        final int mode = forDataDelivery
+                ? appOps.noteOpNoThrow(op, uid, packageName, attributionTag, opMessage)
+                : appOps.unsafeCheckOpNoThrow(op, uid, packageName);
         switch (mode) {
             case AppOpsManager.MODE_ALLOWED:
                 return true;
diff --git a/src/com/android/providers/media/util/XAttrUtils.java b/src/com/android/providers/media/util/XAttrUtils.java
deleted file mode 100644
index 31dbe8ab7..000000000
--- a/src/com/android/providers/media/util/XAttrUtils.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.media.util;
-
-import static com.android.providers.media.util.FileUtils.extractDisplayName;
-import static com.android.providers.media.util.FileUtils.extractRelativePath;
-import static com.android.providers.media.util.Logging.TAG;
-
-import android.os.SystemProperties;
-import android.os.Trace;
-import android.os.UserHandle;
-import android.system.ErrnoException;
-import android.system.Os;
-import android.util.Log;
-
-import com.android.providers.media.FileAccessAttributes;
-
-import java.nio.ByteOrder;
-import java.util.Optional;
-
-public class XAttrUtils {
-
-    /**
-     * Path on which {@link XAttrUtils#DATA_MEDIA_XATTR_DIRECTORY_PATH} is set.
-     * /storage/emulated/.. can point to /data/media/.. on ext4/f2fs on modern devices. However, for
-     * legacy devices with sdcardfs, it points to /mnt/runtime/.. which then points to
-     * /data/media/.. sdcardfs does not support xattrs, hence xattrs are set on /data/media/.. path.
-     *
-     * TODO(b/220895679): Add logic to handle external sd cards with primary volume with paths
-     * /mnt/expand/<volume>/media/<user-id>.
-     */
-    static final String DATA_MEDIA_XATTR_DIRECTORY_PATH = String.format(
-            "/data/media/%s", UserHandle.myUserId());
-
-    static final int SIZE_OF_FILE_ATTRIBUTES = 18;
-
-    /**
-     * Flag to turn on reading file metadata through xattr in FUSE file open calls
-     */
-    public static final boolean ENABLE_XATTR_METADATA_FOR_FUSE =
-            SystemProperties.getBoolean("persist.sys.fuse.perf.xattr_metadata_enabled",
-                    false);
-
-    /**
-     * XAttribute key against which the file metadata is stored
-     */
-    public static final String FILE_ACCESS_XATTR_KEY = "user.fattr";
-
-    public static Optional<FileAccessAttributes> getFileAttributesFromXAttr(String path,
-            String key) {
-        Trace.beginSection("XAttrUtils.getFileAttributesFromXAttr");
-        String relativePathWithDisplayName = DATA_MEDIA_XATTR_DIRECTORY_PATH + "/"
-                + extractRelativePath(path) + extractDisplayName(path);
-        try {
-            return Optional.of(deserializeFileAccessAttributes(
-                    Os.getxattr(relativePathWithDisplayName, key)));
-        } catch (ErrnoException e) {
-            Log.w(TAG,
-                    String.format("Exception encountered while reading xattr:%s from path:%s.", key,
-                            path));
-            return Optional.empty();
-        } finally {
-            Trace.endSection();
-        }
-    }
-
-    /**
-     * Serializes file access attributes into byte array that will be stored in the xattr.
-     * This method serializes only the id, mediaType, isPending, isTrashed and ownerId fields.
-     * @param fileAccessAttributes File attributes to be stored as byte[] in the file inode
-     * @return byte[]
-     */
-    public static byte[] serializeFileAccessAttributes(
-            FileAccessAttributes fileAccessAttributes) {
-        byte[] bytes = new byte[SIZE_OF_FILE_ATTRIBUTES];
-        int offset = 0;
-        ByteOrder byteOrder = ByteOrder.nativeOrder();
-
-        Memory.pokeLong(bytes, offset, fileAccessAttributes.getId(), byteOrder);
-        offset += Long.BYTES;
-
-        // TODO(b/227753174): Merge mediaType and the booleans in a single byte
-        Memory.pokeInt(bytes, offset, fileAccessAttributes.getMediaType(), byteOrder);
-        offset += Integer.BYTES;
-
-        bytes[offset++] = (byte) (fileAccessAttributes.isPending() ? 1 : 0);
-        bytes[offset++] = (byte) (fileAccessAttributes.isTrashed() ? 1 : 0);
-
-        Memory.pokeInt(bytes, offset, fileAccessAttributes.getOwnerId(), byteOrder);
-        offset += Integer.BYTES;
-        if (offset != SIZE_OF_FILE_ATTRIBUTES) {
-            Log.wtf(TAG, "Error: Serialized byte[] is of unexpected size");
-        }
-        return bytes;
-    }
-
-    /**
-     * Deserialize the byte[] data into the corresponding fields - id, mediaType, isPending,
-     * isTrashed and ownerId in that order, and returns an instance of FileAccessAttributes
-     * containing this deserialized data.
-     * @param data Data that is read from the file inode as a result of the xattr call
-     * @return FileAccessAttributes
-     */
-    public static FileAccessAttributes deserializeFileAccessAttributes(byte[] data) {
-        ByteOrder byteOrder = ByteOrder.nativeOrder();
-        int offset = 0;
-
-        long id = Memory.peekLong(data, offset, byteOrder);
-        offset += Long.BYTES;
-
-        int mediaType = Memory.peekInt(data, offset, byteOrder);
-        offset += Integer.BYTES;
-
-        boolean isPending = data[offset++] != 0;
-        boolean isTrashed = data[offset++] != 0;
-
-        int ownerId = Memory.peekInt(data, offset, byteOrder);
-        offset += Integer.BYTES;
-        if (offset != SIZE_OF_FILE_ATTRIBUTES) {
-            Log.wtf(TAG, " Error: Deserialized attributes are of unexpected size");
-        }
-        return new FileAccessAttributes(id, mediaType, isPending, isTrashed,
-                ownerId, null);
-    }
-}
diff --git a/tests/Android.bp b/tests/Android.bp
index f18d04ae7..3de35a077 100644
--- a/tests/Android.bp
+++ b/tests/Android.bp
@@ -155,6 +155,25 @@ android_test_helper_app {
     ],
 }
 
+android_test_helper_app {
+    name: "LegacyMediaProviderTestAppFor33",
+    manifest: "test_app/LegacyTestAppWithTargetSdk33.xml",
+    srcs: [
+        "test_app/src/**/*.java",
+        "src/com/android/providers/media/util/TestUtils.java",
+    ],
+    static_libs: [
+        "cts-install-lib",
+    ],
+    sdk_version: "test_current",
+    target_sdk_version: "33",
+    min_sdk_version: "30",
+    test_suites: [
+        "general-tests",
+        "mts-mediaprovider",
+    ],
+}
+
 // This looks a bit awkward, but we need our tests to run against either
 // MediaProvider or MediaProviderGoogle, and we don't know which one is
 // on the device being tested, so we can't sign our tests with a key that
@@ -173,6 +192,7 @@ android_test {
     resource_dirs: [
         "main_res",
         "res",
+        "photopicker_res",
     ],
 
     srcs: [
@@ -224,10 +244,16 @@ android_test {
         "exoplayer-mediaprovider-ui",
         "SettingsLibProfileSelector",
         "SettingsLibSelectorWithWidgetPreference",
+        "SettingsLibTopIntroPreference",
+        "SettingsLibCollapsingToolbarBaseActivity",
         "mediaprovider_flags_java_lib",
         "flag-junit",
         "androidx.media3.media3-common",
         "androidx.media3.media3-transformer",
+        "junit",
+        "android-support-test",
+        "mockito-target-minus-junit4",
+        "platform-compat-test-rules",
     ],
 
     certificate: "media",
@@ -243,6 +269,7 @@ android_test {
 
     data: [
         ":LegacyMediaProviderTestApp",
+        ":LegacyMediaProviderTestAppFor33",
         ":LegacyMediaProviderTestAppFor35",
         ":MediaProviderTestAppForPermissionActivity",
         ":MediaProviderTestAppForPermissionActivity33",
diff --git a/tests/AndroidManifest.xml b/tests/AndroidManifest.xml
index f57aaed20..2e7d9348c 100644
--- a/tests/AndroidManifest.xml
+++ b/tests/AndroidManifest.xml
@@ -13,6 +13,7 @@
         <package android:name="com.android.providers.media.testapp.withuserselectedperms" />
         <package android:name="com.android.providers.media.testapp.legacy" />
         <package android:name="com.android.providers.media.testapp.legacywithtargetsdk35" />
+        <package android:name="com.android.providers.media.testapp.legacywithtargetsdk33" />
     </queries>
 
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
@@ -22,12 +23,17 @@
     <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
     <uses-permission android:name="android.permission.READ_DEVICE_CONFIG" />
 
+    <!-- Permissions required for reading and logging compat changes -->
+    <uses-permission android:name="android.permission.LOG_COMPAT_CHANGE"/>
+    <uses-permission android:name="android.permission.READ_COMPAT_CHANGE_CONFIG"/>
+
     <uses-permission
         android:name="com.android.providers.media.permission.BIND_MEDIA_COGNITION_SERVICE"/>
     <uses-permission
         android:name="com.android.providers.media.permission.BIND_OEM_METADATA_SERVICE"/>
 
-    <application android:label="MediaProvider Tests">
+    <application android:label="MediaProvider Tests"
+        android:debuggable="true">
         <uses-library android:name="android.test.runner" />
 
         <activity android:name="com.android.providers.media.GetResultActivity" />
diff --git a/tests/AndroidTest.xml b/tests/AndroidTest.xml
index 31d9e1535..44fb27930 100644
--- a/tests/AndroidTest.xml
+++ b/tests/AndroidTest.xml
@@ -30,6 +30,7 @@
         <option name="test-file-name" value="MediaProviderTestAppWithUserSelectedPerms.apk" />
         <option name="test-file-name" value="MediaProviderTestAppWithoutPerms.apk" />
         <option name="test-file-name" value="LegacyMediaProviderTestApp.apk" />
+        <option name="test-file-name" value="LegacyMediaProviderTestAppFor33.apk" />
         <option name="test-file-name" value="LegacyMediaProviderTestAppFor35.apk" />
         <option name="install-arg" value="-g" />
     </target_preparer>
diff --git a/tests/client/src/com/android/providers/media/client/DownloadProviderTest.java b/tests/client/src/com/android/providers/media/client/DownloadProviderTest.java
index 3deb2593e..ec83e196e 100644
--- a/tests/client/src/com/android/providers/media/client/DownloadProviderTest.java
+++ b/tests/client/src/com/android/providers/media/client/DownloadProviderTest.java
@@ -65,6 +65,16 @@ public class DownloadProviderTest {
         deletePublicVolumes();
     }
 
+    @Test
+    public void canCreateOtherPackageExternalFilesDir() {
+        try {
+            // Verifies that downloadProvider can create files dir for other packages.
+            createOtherPackageExternalFilesDir();
+        } catch (Exception e) {
+            throw new UnsupportedOperationException(
+                    "Unable to create files dir: \n" + e.getMessage());
+        }
+    }
 
     @Test
     public void testCanReadWriteOtherAppPrivateFiles() throws Exception {
@@ -104,11 +114,11 @@ public class DownloadProviderTest {
 
             for (String dir: otherPackageDirsOnSameVolume) {
                 otherPackageDirs.add(new File(dir));
-                final String otherPackageExternalFilesDir = dir + "/files";
-                executeShellCommand("mkdir -p " + otherPackageExternalFilesDir + " -m 2770");
+                File otherPackageExternalFilesDir = new File(dir, "/files");
+                otherPackageExternalFilesDir.mkdirs();
                 // Need to wait for the directory to be created, as the rest of the test depends on
                 // the dir to be created. A race condition can cause the test to be flaky.
-                pollForDirectoryToBeCreated(new File(otherPackageExternalFilesDir));
+                pollForDirectoryToBeCreated(otherPackageExternalFilesDir);
             }
         }
         return otherPackageDirs;
diff --git a/tests/hostsidetests/photopicker/TEST_MAPPING b/tests/hostsidetests/photopicker/TEST_MAPPING
index 2dfcf6c61..7a8de2095 100644
--- a/tests/hostsidetests/photopicker/TEST_MAPPING
+++ b/tests/hostsidetests/photopicker/TEST_MAPPING
@@ -1,7 +1,7 @@
 {
-  "postsubmit": [
+  "presubmit": [
     {
       "name": "PhotoPickerHostTestCases"
     }
   ]
-}
\ No newline at end of file
+}
diff --git a/tests/hostsidetests/photopicker/src/android/tests/photopicker/CloudProviderHostSideTest.kt b/tests/hostsidetests/photopicker/src/android/tests/photopicker/CloudProviderHostSideTest.kt
index 7dad80ea7..61d54b2a3 100644
--- a/tests/hostsidetests/photopicker/src/android/tests/photopicker/CloudProviderHostSideTest.kt
+++ b/tests/hostsidetests/photopicker/src/android/tests/photopicker/CloudProviderHostSideTest.kt
@@ -39,6 +39,8 @@ import org.junit.runner.RunWith
 class CloudProviderHostSideTest : IDeviceTest {
     private lateinit var mDevice: ITestDevice
 
+    private var mInitialCloudProvider: String? = null
+
     companion object {
         /** The package name of the test APK.  */
         private const val TEST_PACKAGE = "com.android.photopicker.testcloudmediaproviderapp"
@@ -68,6 +70,15 @@ class CloudProviderHostSideTest : IDeviceTest {
     fun setUp() {
         // ensure the test APK is enabled before each test by setting it explicitly.
         mDevice.executeShellCommand(COMMAND_ENABLE_TEST_APK)
+        // find the initial cloud provider to be reset at the end of the test execution.
+        mInitialCloudProvider = null
+        val result: String = mDevice.executeShellCommand(COMMAND_GET_CLOUD_PROVIDER)
+        val regex = Regex("get_cloud_provider_result=(.*?)}]")
+        val matchResult = regex.find(result)
+        val initialCloudProvider = matchResult?.groupValues?.get(1)
+        if (initialCloudProvider != "null") {
+            mInitialCloudProvider = initialCloudProvider
+        }
     }
 
     /**
@@ -87,8 +98,8 @@ class CloudProviderHostSideTest : IDeviceTest {
 
         // Add the test package authority to the allowlist for cloud providers.
         mDevice.executeShellCommand(
-                "device_config put mediaprovider allowed_cloud_providers "
-                        + "\"$TEST_CLOUD_PROVIDER_AUTHORITY\""
+            "device_config put mediaprovider allowed_cloud_providers "
+                    + "\"$TEST_CLOUD_PROVIDER_AUTHORITY\""
         )
 
         // Set the test cloud provider as the current provider.
@@ -126,8 +137,10 @@ class CloudProviderHostSideTest : IDeviceTest {
                     COMMAND_GET_CLOUD_PROVIDER
                 )
                 assertWithMessage("Unexpected cloud provider, expected : null")
-                    .that(resultForGetCloudProvider
-                        .contains("{get_cloud_provider_result=null}"))
+                    .that(
+                        resultForGetCloudProvider
+                            .contains("{get_cloud_provider_result=null}")
+                    )
                     .isTrue()
                 isCloudProviderReset = true
                 break // Condition met, exit the loop
@@ -144,5 +157,20 @@ class CloudProviderHostSideTest : IDeviceTest {
     @Throws(Exception::class)
     fun tearDown() {
         mDevice.executeShellCommand(COMMAND_ENABLE_TEST_APK)
+
+        // reset initial cloud provider.
+        val setCloudProvider: String
+        if (mInitialCloudProvider != null) {
+            setCloudProvider = " content call --uri content://media --method set_cloud_provider" +
+                    " --extra cloud_provider:s:$mInitialCloudProvider"
+        } else {
+            // set to null if no cloud provider was set earlier.
+            setCloudProvider =
+                " content call --uri content://media --method set_cloud_provider"
+        }
+        mDevice.executeShellCommand(setCloudProvider)
+
+        // To enable syncs after test is completed
+        mDevice.executeShellCommand("device_config set_sync_disabled_for_tests none")
     }
 }
\ No newline at end of file
diff --git a/tests/photopicker_res b/tests/photopicker_res
new file mode 120000
index 000000000..c1f73810f
--- /dev/null
+++ b/tests/photopicker_res
@@ -0,0 +1 @@
+../photopicker/res
\ No newline at end of file
diff --git a/tests/res/raw/android_mime_types b/tests/res/raw/android_mime_types
new file mode 100644
index 000000000..d8a2ce8f5
--- /dev/null
+++ b/tests/res/raw/android_mime_types
@@ -0,0 +1,166 @@
+
+###############################################################################
+#
+# Android-specific MIME type <-> extension mappings
+#
+# Each line below defines a mapping from one MIME type to the first of the
+# listed extensions, and from listed extension back to the MIME type.
+# A mapping overrides any previous mapping _from_ that same MIME type or
+# extension (put() semantics), unless that MIME type / extension is prefixed with '?'
+# (putIfAbsent() semantics).
+#
+#
+###############################################################################
+#
+# EXAMPLES
+#
+# A line of the form:
+#
+#    ?mime ext1 ?ext2 ext3
+#
+# affects the current mappings along the lines of the following pseudo code:
+#
+#    mimeToExt.putIfAbsent("mime", "ext1");
+#    extToMime.put("ext1", "mime");
+#    extToMime.putIfAbsent("ext2", "mime");
+#    extToMime.put("ext3", "mime");
+#
+# The line:
+#
+#     ?text/plain txt
+#
+# leaves any earlier mapping for "text/plain" untouched, or maps that MIME type
+# to the file extension ".txt" if there is no earlier mapping. The line also
+# sets the mapping from file extension ".txt" to be the MIME type "text/plain",
+# regardless of whether a previous mapping existed.
+#
+###############################################################################
+
+
+# File extensions that Android wants to override to point to the given MIME type.
+#
+# After processing a line of the form:
+# ?<mimeType> <extension1> <extension2>
+# If <mimeType> was not already mapped to an extension then it will be
+# mapped to <extension1>.
+# <extension1> and <extension2> are mapped (or remapped) to <mimeType>.
+
+?application/epub+zip epub
+?application/lrc lrc
+?application/pkix-cert cer
+?application/rss+xml rss
+?application/sdp sdp
+?application/smil+xml smil
+?application/ttml+xml ttml dfxp
+?application/vnd.android.haptics.vibration+xml ahv
+?application/vnd.android.ota ota
+?application/vnd.apple.mpegurl m3u8
+?application/vnd.apple.pkpass pkpass
+?application/vnd.apple.pkpasses pkpasses
+?application/vnd.ms-pki.stl stl
+?application/vnd.ms-powerpoint pot
+?application/vnd.ms-wpl wpl
+?application/vnd.stardivision.impress sdp
+?application/vnd.stardivision.writer vor
+?application/vnd.youtube.yt yt
+?application/x-android-drm-fl fl
+?application/x-flac flac
+?application/x-font pcf
+?application/x-mobipocket-ebook prc mobi
+?application/x-mpegurl m3u m3u8
+?application/x-pem-file pem
+?application/x-pkcs12 p12 pfx
+?application/x-subrip srt
+?application/x-webarchive webarchive
+?application/x-webarchive-xml webarchivexml
+?application/x-x509-server-cert crt
+?application/x-x509-user-cert crt
+
+?audio/3gpp 3ga 3gpp
+?audio/aac-adts aac
+?audio/ac3 ac3 a52
+?audio/amr amr
+?audio/x-gsm gsm
+?audio/imelody imy
+?audio/midi rtttl xmf
+?audio/mobile-xmf mxmf
+?audio/mp4 m4a m4b m4p f4a f4b f4p
+?audio/mpegurl m3u
+?audio/sp-midi smf
+?audio/x-matroska mka
+?audio/x-pn-realaudio ra
+?audio/x-mpeg mp3
+?audio/mp3 mp3
+
+?image/bmp bmp
+?image/gif gif
+?image/heic heic
+?image/heic-sequence heics
+?image/heif heif hif
+?image/heif-sequence heifs
+?image/avif avif
+?image/ico cur
+?image/webp webp
+?image/x-adobe-dng dng
+?image/x-fuji-raf raf
+?image/x-icon ico
+?image/x-jg art
+?image/x-nikon-nrw nrw
+?image/x-panasonic-rw2 rw2
+?image/x-pentax-pef pef
+?image/x-samsung-srw srw
+?image/x-sony-arw arw
+
+?text/comma-separated-values csv
+?text/plain diff po
+?text/rtf rtf
+?text/text phps
+?text/xml xml
+?text/x-vcard vcf
+
+?video/3gpp2 3gpp2 3gp2 3g2
+?video/3gpp 3gpp 3gp
+?video/avi avi
+?video/m4v m4v
+?video/mp4 m4v f4v mp4v mpeg4
+?video/mp2p mpeg
+?video/mp2t m2ts mts
+?video/mp2ts ts
+?video/vnd.youtube.yt yt
+?video/x-webex wrf
+
+# Optional additions that should not override any previous mapping.
+
+?application/x-wifi-config ?xml
+?multipart/related mht
+
+# Special cases where Android has a strong opinion about mappings, so we
+# define them very last and make them override in both directions (no "?").
+#
+# Lines here are of the form:
+# <mimeType> <extension1> <extension2> ...
+#
+# After processing each line,
+#   <mimeType> is mapped to <extension1>
+#   <extension1>, <extension2>, ... are all mapped to <mimeType>
+# This overrides any mappings for this <mimeType> / for these extensions
+# that may have been defined earlier.
+
+application/pgp-signature pgp
+application/x-x509-ca-cert crt der
+audio/aac aac adts adt
+audio/basic snd
+audio/flac flac
+audio/midi rtx
+audio/mpeg mp3 mp2 mp1 mpa m4a m4r
+audio/x-mpegurl m3u m3u8
+image/jpeg jpg
+image/x-ms-bmp bmp
+image/x-photoshop psd
+text/plain txt
+text/x-c++hdr hpp
+text/x-c++src cpp
+video/3gpp 3gpp
+video/mpeg mpeg mpeg2 mpv2 mp2v m2v m2t mpeg1 mpv1 mp1v m1v
+video/quicktime mov
+video/x-matroska mkv
\ No newline at end of file
diff --git a/tests/res/raw/corrupted_mime_types b/tests/res/raw/corrupted_mime_types
new file mode 100644
index 000000000..dc34a542a
--- /dev/null
+++ b/tests/res/raw/corrupted_mime_types
@@ -0,0 +1,2320 @@
+###############################################################################
+#
+#  Media (MIME) types and the extensions that represent them.
+#
+#  The format of this file is a media type on the left and zero or more
+#  filename extensions on the right.  Programs using this file will map
+#  files ending with those extensions to the associated type.
+#
+#  This file is part of the "media-types" package.  Please report a bug using
+#  the "reportbug" command of the "reportbug" package if you would like new
+#  types or extensions to be added.
+#
+#  The reason that all types are managed by the media-types package instead
+#  allowing individual packages to install types in much the same way as they
+#  add entries in to the mailcap file is so these types can be referenced by
+#  other programs (such as a web server) even if the specific support package
+#  for that type is not installed.
+#
+#  Users can add their own types if they wish by creating a ".mime.types"
+#  file in their home directory.  Definitions included there will take
+#  precedence over those listed here.
+#
+###############################################################################
+
+application/1d-interleaved-parityfec
+application/3gpdash-qoe-report+xml
+application/3gpp-ims+xml
+application/3gppHal+json
+application/3gppHalForms+json
+application/A2L					a2l
+application/ace+cbor
+application/ace+json
+application/activemessage
+application/activity+json
+application/aif+cbor
+application/aif+json
+application/alto-cdni+json
+application/alto-cdnifilter+json
+application/alto-costmap+json
+application/alto-costmapfilter+json
+application/alto-directory+json
+application/alto-endpointcost+json
+application/alto-endpointcostparams+json
+application/alto-endpointprop+json
+application/alto-endpointpropparams+json
+application/alto-error+json
+application/alto-networkmap+json
+application/alto-networkmapfilter+json
+application/alto-propmap+json
+application/alto-propmapparams+json
+application/alto-updatestreamcontrol+json
+application/alto-updatestreamparams+json
+application/AML					aml
+application/andrew-inset			ez
+application/annodex				anx
+application/applefile
+application/at+jwt
+application/ATF					atf
+application/ATFX				atfx
+application/atom+xml				atom
+application/atomcat+xml				atomcat
+application/atomdeleted+xml			atomdeleted
+application/atomicmail
+application/atomserv+xml			atomsrv
+application/atomsvc+xml				atomsvc
+application/atsc-dwd+xml			dwd
+application/atsc-dynamic-event-message
+application/atsc-held+xml			held
+application/atsc-rdt+json
+application/atsc-rsat+xml			rsat
+application/ATXML				atxml
+application/auth-policy+xml			apxml
+application/automationml-aml+xml
+application/automationml-amlx+zip		amlx
+application/bacnet-xdd+zip			xdd
+application/batch-SMTP
+application/bbolin				lin
+application/beep+xml
+application/calendar+json
+application/calendar+xml			xcs
+application/call-completion
+application/CALS-1840
+application/captive+json
+application/cbor				cbor
+application/cbor-seq
+application/cccex				c3ex
+application/ccmp+xml				ccmp
+application/ccxml+xml				ccxml
+application/cda+xml
+application/CDFX+XML				cdfx
+application/cdmi-capability			cdmia
+application/cdmi-container			cdmic
+application/cdmi-domain				cdmid
+application/cdmi-object				cdmio
+application/cdmi-queue				cdmiq
+application/cdni
+application/CEA					cea
+application/cea-2018+xml
+application/cellml+xml				cellml cml
+application/cfw
+application/city+json
+application/clr					1clr
+application/clue+xml
+application/clue_info+xml			clue
+application/cms					cmsc
+application/cnrp+xml
+application/coap-group+json
+application/coap-payload
+application/commonground
+application/concise-problem-details+cbor
+application/conference-info+xml
+application/cose
+application/cose-key
+application/cose-key-set
+application/cose-x509
+application/cpl+xml				cpl
+application/csrattrs				csrattrs
+application/csta+xml
+application/CSTAdata+xml
+application/csvm+json
+application/cu-seeme				cu
+application/cwl					cwl
+application/cwl+json				cwl.json
+application/cwt
+application/cybercash
+application/dash+xml				mpd
+application/dash-patch+xml
+application/dashdelta				mpdd
+application/davmount+xml			davmount
+application/dca-rft
+application/DCD					dcd
+application/dec-dx
+application/dialog-info+xml
+application/dicom				dcm
+application/dicom+json
+application/dicom+xml
+application/DII					dii
+application/DIT					dit
+application/dns
+application/dns+json
+application/dns-message
+application/dots+cbor
+application/dpop+jwt
+application/dskpp+xml				xmls
+application/dsptype				tsp
+application/dssc+der				dssc
+application/dssc+xml				xdssc
+application/dvcs				dvc
+application/EDI-consent
+application/EDI-X12
+application/EDIFACT
+application/efi					efi
+application/elm+json
+application/elm+xml
+application/EmergencyCallData.cap+xml
+application/EmergencyCallData.Comment+xml
+application/EmergencyCallData.Control+xml
+application/EmergencyCallData.DeviceInfo+xml
+application/EmergencyCallData.eCall.MSD
+application/EmergencyCallData.LegacyESN+json
+application/EmergencyCallData.ProviderInfo+xml
+application/EmergencyCallData.ServiceInfo+xml
+application/EmergencyCallData.SubscriberInfo+xml
+application/EmergencyCallData.VEDS+xml
+application/emma+xml				emma
+application/emotionml+xml			emotionml
+application/encaprtp
+application/epp+xml
+application/epub+zip				epub
+application/eshop
+application/example
+application/exi					exi
+application/expect-ct-report+json
+application/express				exp
+application/fastinfoset				finf
+application/fastsoap
+application/fdf					fdf
+application/fdt+xml				fdt
+application/fhir+json
+application/fhir+xml
+application/fits
+application/flexfec
+application/font-tdpfr				pfr
+application/framework-attributes+xml
+application/futuresplash			spl
+application/geo+json				geojson
+application/geo+json-seq
+application/geopackage+sqlite3			gpkg
+application/geoxacml+xml
+application/gltf-buffer				glbin glbuf
+application/gml+xml				gml
+application/gzip				gz
+application/H224
+application/held+xml
+application/hl7v2+xml
+application/hta					hta
+application/http
+application/hyperstudio				stk
+application/ibe-key-request+xml
+application/ibe-pkg-reply+xml
+application/ibe-pp-data
+application/iges
+application/im-iscomposing+xml
+application/index
+application/index.cmd
+application/index.obj
+application/index.response
+application/index.vnd
+application/inkml+xml				ink inkml
+application/IOTP
+application/ipfix				ipfix
+application/ipp
+application/ISUP
+application/its+xml				its
+application/java-archive			jar
+application/java-serialized-object		ser
+application/java-vm				class
+application/jf2feed+json
+application/jose
+application/jose+json
+application/jrd+json				jrd
+application/jscalendar+json
+application/json				json
+application/json-patch+json			json-patch
+application/json-seq
+application/jwk+json
+application/jwk-set+json
+application/jwt
+application/kpml-request+xml
+application/kpml-response+xml
+application/ld+json				jsonld
+application/lgr+xml				lgr
+application/link-format				wlnk
+application/linkset
+application/linkset+json
+application/load-control+xml
+application/logout+jwt
+application/lost+xml				lostxml
+application/lostsync+xml			lostsyncxml
+application/lpf+zip				lpf
+application/LXF					lxf
+application/m3g					m3g
+application/mac-binhex40			hqx
+application/mac-compactpro			cpt
+application/macwriteii
+application/mads+xml				mads
+application/manifest+json			webmanifest
+application/marc				mrc
+application/marcxml+xml				mrcx
+application/mathematica				ma mb
+application/mathml+xml				mml
+application/mathml-content+xml
+application/mathml-presentation+xml
+application/mbms-associated-procedure-description+xml
+application/mbms-deregister+xml
+application/mbms-envelope+xml
+application/mbms-msk+xml
+application/mbms-msk-response+xml
+application/mbms-protection-description+xml
+application/mbms-reception-report+xml
+application/mbms-register+xml
+application/mbms-register-response+xml
+application/mbms-schedule+xml
+application/mbms-user-service-description+xml
+application/mbox				mbox
+application/media-policy-dataset+xml
+application/mediaservercontrol+xml
+application/media_control+xml
+application/merge-patch+json
+application/metalink4+xml			meta4
+application/mets+xml				mets
+application/MF4					mf4
+application/mikey
+application/mipc
+application/missing-blocks+cbor-seq
+application/mmt-aei+xml				maei
+application/mmt-usd+xml				musd
+application/mods+xml				mods
+application/moss-keys
+application/moss-signature
+application/mosskey-data
+application/mosskey-request
+application/mp21				m21 mp21
+application/mp4
+application/mpeg4-generic
+application/mpeg4-iod
+application/mpeg4-iod-xmt
+application/mrb-consumer+xml
+application/mrb-publish+xml
+application/msaccess				mdb
+application/msc-ivr+xml
+application/msc-mixer+xml
+application/msword				doc
+application/mud+json
+application/multipart-core
+application/mxf					mxf
+application/n-quads				nq
+application/n-triples				nt
+application/nasdata
+application/news-checkgroups
+application/news-groupinfo
+application/news-transmission
+application/nlsml+xml
+application/node
+application/nss
+application/oauth-authz-req+jwt
+application/oblivious-dns-message
+application/ocsp-request			orq
+application/ocsp-response			ors
+application/octet-stream			bin deploy msu msp
+application/ODA					oda
+application/odm+xml
+application/ODX					odx
+application/oebps-package+xml			opf
+application/ogg					ogx
+application/ohttp-keys
+application/onenote				one onetoc2 onetmp onepkg
+application/opc-nodeset+xml
+application/oscore
+application/oxps				oxps
+application/p21					p21 stpnc 210 ifc
+application/p21+zip
+application/p2p-overlay+xml			relo
+application/parityfec
+application/passport
+application/patch-ops-error+xml
+application/pdf					pdf
+application/PDX					pdx
+application/pem-certificate-chain		pem
+application/pgp-encrypted			pgp
+application/pgp-keys				asc key
+application/pgp-signature			sig
+application/pics-rules				prf
+application/pidf+xml
+application/pidf-diff+xml
+application/pkcs10				p10
+application/pkcs12				p12 pfx
+application/pkcs7-mime				p7m p7c p7z
+application/pkcs7-signature			p7s
+application/pkcs8				p8
+application/pkcs8-encrypted			p8e
+application/pkix-attr-cert			ac
+application/pkix-cert				cer
+application/pkix-crl				crl
+application/pkix-pkipath			pkipath
+application/pkixcmp				pki
+application/pls+xml
+application/poc-settings+xml
+application/postscript				ps ai eps epsi epsf eps2 eps3
+application/ppsp-tracker+json
+application/problem+json
+application/problem+xml
+application/provenance+xml			provx
+application/prs.alvestrand.titrax-sheet
+application/prs.cww				cw cww
+application/prs.cyn
+application/prs.hpub+zip			hpub
+application/prs.implied-document+xml
+application/prs.implied-executable
+application/prs.implied-structure
+application/prs.nprend				rnd rct
+application/prs.plucker
+application/prs.rdf-xml-crypt			rdf-crypt
+application/prs.xsf+xml				xsf
+application/pskc+xml				pskcxml
+application/pvd+json
+application/QSIG
+application/raptorfec
+application/rdap+json
+application/rdf+xml				rdf
+application/reginfo+xml				rif
+application/relax-ng-compact-syntax		rnc
+application/reputon+json
+application/resource-lists+xml			rl
+application/resource-lists-diff+xml		rld
+application/rfc+xml				rfcxml
+application/riscos
+application/rlmi+xml
+application/rls-services+xml			rs
+application/route-apd+xml			rapd
+application/route-s-tsid+xml			sls
+application/route-usd+xml			rusd
+application/rpki-checklist
+application/rpki-ghostbusters			gbr
+application/rpki-manifest			mft
+application/rpki-publication
+application/rpki-roa				roa
+application/rpki-updown
+application/rtf					rtf
+application/rtploopback
+application/rtx
+application/samlassertion+xml
+application/samlmetadata+xml
+application/sarif+json				sarif sarif.json
+application/sarif-external-properties+json	sarif-external-properties sarif-external-properties.json
+application/sbe
+application/sbml+xml
+application/scaip+xml
+application/scim+json				scim
+application/scvp-cv-request			scq
+application/scvp-cv-response			scs
+application/scvp-vp-request			spq
+application/scvp-vp-response			spp
+application/sdp					sdp
+application/secevent+jwt
+application/senml+cbor				senmlc
+application/senml+json				senml
+application/senml+xml				senmlx
+application/senml-etch+cbor			senml-etchc
+application/senml-etch+json			senml-etchj
+application/senml-exi				senmle
+application/sensml+cbor				sensmlc
+application/sensml+json				sensml
+application/sensml+xml				sensmlx
+application/sensml-exi				sensmle
+application/sep+xml
+application/sep-exi
+application/session-info
+application/set-payment
+application/set-payment-initiation
+application/set-registration
+application/set-registration-initiation
+application/SGML
+application/sgml-open-catalog			soc
+application/shf+xml				shf
+application/sieve				siv sieve
+application/simple-filter+xml			cl
+application/simple-message-summary
+application/simpleSymbolContainer
+application/sipc
+application/slate
+application/smil+xml				smil smi sml
+application/smpte336m
+application/soap+fastinfoset
+application/soap+xml
+application/sparql-query			rq
+application/sparql-results+xml			srx
+application/spdx+json				spdx.json
+application/spirits-event+xml
+application/sql					sql
+application/srgs				gram
+application/srgs+xml				grxml
+application/sru+xml				sru
+application/ssml+xml				ssml
+application/stix+json				stix
+application/swid+cbor				coswid
+application/swid+xml				swidtag
+application/tamp-apex-update			tau
+application/tamp-apex-update-confirm		auc
+application/tamp-community-update		tcu
+application/tamp-community-update-confirm	cuc
+application/tamp-error				ter
+application/tamp-sequence-adjust		tsa
+application/tamp-sequence-adjust-confirm	sac
+application/tamp-status-query
+application/tamp-status-response
+application/tamp-update				tur
+application/tamp-update-confirm			tuc
+application/taxii+json
+application/td+json				jsontd
+application/tei+xml				tei teiCorpus odd
+application/TETRA_ISI
+application/thraud+xml				tfi
+application/timestamp-query			tsq
+application/timestamp-reply			tsr
+application/timestamped-data			tsd
+application/tlsrpt+gzip
+application/tlsrpt+json
+application/tm+json				tm.jsonld tm.json jsontm
+application/tnauthlist
+application/token-introspection+jwt
+application/trickle-ice-sdpfrag
+application/trig				trig
+application/ttml+xml				ttml
+application/tve-trigger
+application/tzif
+application/tzif-leap
+application/ulpfec
+application/urc-grpsheet+xml			gsheet
+application/urc-ressheet+xml			rsheet
+application/urc-targetdesc+xml			td
+application/urc-uisocketdesc+xml		uis
+application/vcard+json
+application/vcard+xml
+application/vemmi
+application/vnd.1000minds.decision-model+xml	1km
+application/vnd.1ob				ob
+application/vnd.3gpp-prose+xml
+application/vnd.3gpp-prose-pc3a+xml
+application/vnd.3gpp-prose-pc3ach+xml
+application/vnd.3gpp-prose-pc3ch+xml
+application/vnd.3gpp-prose-pc8+xml
+application/vnd.3gpp-v2x-local-service-information
+application/vnd.3gpp.5gnas
+application/vnd.3gpp.access-transfer-events+xml
+application/vnd.3gpp.bsf+xml
+application/vnd.3gpp.crs+xml
+application/vnd.3gpp.current-location-discovery+xml
+application/vnd.3gpp.GMOP+xml
+application/vnd.3gpp.gtpc
+application/vnd.3gpp.interworking-data
+application/vnd.3gpp.lpp
+application/vnd.3gpp.mc-signalling-ear
+application/vnd.3gpp.mcdata-affiliation-command+xml
+application/vnd.3gpp.mcdata-info+xml
+application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml
+application/vnd.3gpp.mcdata-payload
+application/vnd.3gpp.mcdata-regroup+xml
+application/vnd.3gpp.mcdata-service-config+xml
+application/vnd.3gpp.mcdata-signalling
+application/vnd.3gpp.mcdata-ue-config+xml
+application/vnd.3gpp.mcdata-user-profile+xml
+application/vnd.3gpp.mcptt-affiliation-command+xml
+application/vnd.3gpp.mcptt-floor-request+xml
+application/vnd.3gpp.mcptt-info+xml
+application/vnd.3gpp.mcptt-location-info+xml
+application/vnd.3gpp.mcptt-mbms-usage-info+xml
+application/vnd.3gpp.mcptt-regroup+xml
+application/vnd.3gpp.mcptt-service-config+xml
+application/vnd.3gpp.mcptt-signed+xml
+application/vnd.3gpp.mcptt-ue-config+xml
+application/vnd.3gpp.mcptt-ue-init-config+xml
+application/vnd.3gpp.mcptt-user-profile+xml
+application/vnd.3gpp.mcvideo-affiliation-command+xml
+application/vnd.3gpp.mcvideo-info+xml
+application/vnd.3gpp.mcvideo-location-info+xml
+application/vnd.3gpp.mcvideo-mbms-usage-info+xml
+application/vnd.3gpp.mcvideo-regroup+xml
+application/vnd.3gpp.mcvideo-service-config+xml
+application/vnd.3gpp.mcvideo-transmission-request+xml
+application/vnd.3gpp.mcvideo-ue-config+xml
+application/vnd.3gpp.mcvideo-user-profile+xml
+application/vnd.3gpp.mid-call+xml
+application/vnd.3gpp.ngap
+application/vnd.3gpp.pfcp
+application/vnd.3gpp.pic-bw-large		plb
+application/vnd.3gpp.pic-bw-small		psb
+application/vnd.3gpp.pic-bw-var			pvb
+application/vnd.3gpp.s1ap
+application/vnd.3gpp.seal-group-doc+xml
+application/vnd.3gpp.seal-info+xml
+application/vnd.3gpp.seal-location-info+xml
+application/vnd.3gpp.seal-mbms-usage-info+xml
+application/vnd.3gpp.seal-network-QoS-management-info+xml
+application/vnd.3gpp.seal-ue-config-info+xml
+application/vnd.3gpp.seal-unicast-info+xml
+application/vnd.3gpp.seal-user-profile-info+xml
+application/vnd.3gpp.sms
+application/vnd.3gpp.sms+xml
+application/vnd.3gpp.srvcc-ext+xml
+application/vnd.3gpp.SRVCC-info+xml
+application/vnd.3gpp.state-and-event-info+xml
+application/vnd.3gpp.ussd+xml
+application/vnd.3gpp.v2x
+application/vnd.3gpp.vae-info+xml
+application/vnd.3gpp2.bcmcsinfo+xml
+application/vnd.3gpp2.sms			sms
+application/vnd.3gpp2.tcap			tcap
+application/vnd.3lightssoftware.imagescal	imgcal
+application/vnd.3M.Post-it-Notes		pwn
+application/vnd.accpac.simply.aso		aso
+application/vnd.accpac.simply.imp		imp
+application/vnd.acm.addressxfer+json
+application/vnd.acucobol			acu
+application/vnd.acucorp				atc acutc
+application/vnd.adobe.flash.movie		swf
+application/vnd.adobe.formscentral.fcdt		fcdt
+application/vnd.adobe.fxp			fxp fxpl
+application/vnd.adobe.partial-upload
+application/vnd.adobe.xdp+xml			xdp
+application/vnd.aether.imp
+application/vnd.afpc.afplinedata
+application/vnd.afpc.afplinedata-pagedef
+application/vnd.afpc.cmoca-cmresource
+application/vnd.afpc.foca-charset
+application/vnd.afpc.foca-codedfont
+application/vnd.afpc.foca-codepage
+application/vnd.afpc.modca			list3820 listafp afp pseg3820
+application/vnd.afpc.modca-formdef
+application/vnd.afpc.modca-mediummap
+application/vnd.afpc.modca-objectcontainer
+application/vnd.afpc.modca-overlay		ovl
+application/vnd.afpc.modca-pagesegment		psg
+application/vnd.age				age
+application/vnd.ah-barcode
+application/vnd.ahead.space			ahead
+application/vnd.airzip.filesecure.azf		azf
+application/vnd.airzip.filesecure.azs		azs
+application/vnd.amadeus+json
+application/vnd.amazon.mobi8-ebook		azw3
+application/vnd.americandynamics.acc		acc
+application/vnd.amiga.ami			ami
+application/vnd.amundsen.maze+xml
+application/vnd.android.ota			ota
+application/vnd.android.package-archive						apk
+application/vnd.anki				apkg
+application/vnd.anser-web-certificate-issue-initiation	cii
+application/vnd.anser-web-funds-transfer-initiation	fti
+application/vnd.antix.game-component
+application/vnd.apache.arrow.file		arrow
+application/vnd.apache.arrow.stream		arrows
+application/vnd.apache.thrift.binary
+application/vnd.apache.thrift.compact
+application/vnd.apache.thrift.json
+application/vnd.apexlang			apexlang apex
+application/vnd.api+json
+application/vnd.aplextor.warrp+json
+application/vnd.apothekende.reservation+json
+application/vnd.apple.installer+xml		dist distz pkg mpkg
+application/vnd.apple.keynote			keynote
+application/vnd.apple.mpegurl			m3u8
+application/vnd.apple.numbers			numbers
+application/vnd.apple.pages			pages
+application/vnd.aristanetworks.swi		swi
+application/vnd.artisan+json			artisan
+application/vnd.artsquare
+application/vnd.astraea-software.iota		iota
+application/vnd.audiograph			aep
+application/vnd.autopackage			package
+application/vnd.avalon+json
+application/vnd.avistar+xml
+application/vnd.balsamiq.bmml+xml		bmml
+application/vnd.balsamiq.bmpr			bmpr
+application/vnd.banana-accounting		ac2
+application/vnd.bbf.usp.error
+application/vnd.bbf.usp.msg
+application/vnd.bbf.usp.msg+json
+application/vnd.bekitzur-stech+json
+application/vnd.belightsoft.lhzd+zip		lhzd
+application/vnd.belightsoft.lhzl+zip		lhzl
+application/vnd.bint.med-content
+application/vnd.biopax.rdf+xml
+application/vnd.blink-idb-value-wrapper
+application/vnd.blueice.multipass		mpm
+application/vnd.bluetooth.ep.oob		ep
+application/vnd.bluetooth.le.oob		le
+application/vnd.bmi				bmi
+application/vnd.bpf
+application/vnd.bpf3
+application/vnd.businessobjects			rep
+application/vnd.byu.uapi+json
+application/vnd.cab-jscript
+application/vnd.canon-cpdl
+application/vnd.canon-lips
+application/vnd.capasystems-pg+json
+application/vnd.cendio.thinlinc.clientconf	tlclient
+application/vnd.century-systems.tcp_stream
+application/vnd.chemdraw+xml			cdxml
+application/vnd.chess-pgn			pgn
+application/vnd.chipnuts.karaoke-mmd		mmd
+application/vnd.ciedi
+application/vnd.cinderella			cdy
+application/vnd.cirpack.isdn-ext
+application/vnd.citationstyles.style+xml	csl
+application/vnd.claymore			cla
+application/vnd.cloanto.rp9			rp9
+application/vnd.clonk.c4group			c4g c4d c4f c4p c4u
+application/vnd.cluetrust.cartomobile-config	c11amc
+application/vnd.cluetrust.cartomobile-config-pkg	c11amz
+application/vnd.cncf.helm.chart.content.v1.tar+gzip
+application/vnd.cncf.helm.chart.provenance.v1.prov
+application/vnd.cncf.helm.config.v1+json
+application/vnd.coffeescript			coffee
+application/vnd.collabio.xodocuments.document	xodt
+application/vnd.collabio.xodocuments.document-template	xott
+application/vnd.collabio.xodocuments.presentation	xodp
+application/vnd.collabio.xodocuments.presentation-template	xotp
+application/vnd.collabio.xodocuments.spreadsheet	xods
+application/vnd.collabio.xodocuments.spreadsheet-template	xots
+application/vnd.collection+json
+application/vnd.collection.doc+json
+application/vnd.collection.next+json
+application/vnd.comicbook+zip			cbz
+application/vnd.comicbook-rar			cbr
+application/vnd.commerce-battelle		icf icd ic0 ic1 ic2 ic3 ic4 ic5 ic6 ic7 ic8
+application/vnd.commonspace			csp cst
+application/vnd.contact.cmsg			cdbcmsg
+application/vnd.coreos.ignition+json		ign ignition
+application/vnd.cosmocaller			cmc
+application/vnd.crick.clicker			clkx
+application/vnd.crick.clicker.keyboard		clkk
+application/vnd.crick.clicker.palette		clkp
+application/vnd.crick.clicker.template		clkt
+application/vnd.crick.clicker.wordbank		clkw
+application/vnd.criticaltools.wbs+xml		wbs
+application/vnd.cryptii.pipe+json
+application/vnd.crypto-shade-file		ssvc
+application/vnd.cryptomator.encrypted		c9r c9s
+application/vnd.cryptomator.vault		cryptomator
+application/vnd.ctc-posml			pml
+application/vnd.ctct.ws+xml
+application/vnd.cups-pdf
+application/vnd.cups-postscript
+application/vnd.cups-ppd			ppd
+application/vnd.cups-raster
+application/vnd.cups-raw
+application/vnd.curl
+application/vnd.cyan.dean.root+xml
+application/vnd.cybank
+application/vnd.cyclonedx+json
+application/vnd.cyclonedx+xml
+application/vnd.d2l.coursepackage1p0+zip
+application/vnd.d3m-dataset
+application/vnd.d3m-problem
+application/vnd.dart				dart
+application/vnd.data-vision.rdz			rdz
+application/vnd.datalog				dl
+application/vnd.datapackage+json
+application/vnd.dataresource+json
+application/vnd.dbf				dbf
+application/vnd.debian.binary-package		deb ddeb udeb
+application/vnd.dece.data			uvf uvvf uvd uvvd
+application/vnd.dece.ttml+xml			uvt uvvt
+application/vnd.dece.unspecified		uvx uvvx
+application/vnd.dece.zip			uvz uvvz
+application/vnd.denovo.fcselayout-link		fe_launch
+application/vnd.desmume.movie			dsm
+application/vnd.dir-bi.plate-dl-nosuffix
+application/vnd.dm.delegation+xml
+application/vnd.dna				dna
+application/vnd.document+json			docjson
+application/vnd.dolby.mobile.1
+application/vnd.dolby.mobile.2
+application/vnd.doremir.scorecloud-binary-document	scld
+application/vnd.dpgraph				dpg mwc dpgraph
+application/vnd.dreamfactory			dfac
+application/vnd.drive+json
+application/vnd.dtg.local
+application/vnd.dtg.local.flash			fla
+application/vnd.dtg.local.html
+application/vnd.dvb.ait				ait
+application/vnd.dvb.dvbisl+xml
+application/vnd.dvb.dvbj
+application/vnd.dvb.esgcontainer
+application/vnd.dvb.ipdcdftnotifaccess
+application/vnd.dvb.ipdcesgaccess
+application/vnd.dvb.ipdcesgaccess2
+application/vnd.dvb.ipdcesgpdd
+application/vnd.dvb.ipdcroaming
+application/vnd.dvb.iptv.alfec-base
+application/vnd.dvb.iptv.alfec-enhancement
+application/vnd.dvb.notif-aggregate-root+xml
+application/vnd.dvb.notif-container+xml
+application/vnd.dvb.notif-generic+xml
+application/vnd.dvb.notif-ia-msglist+xml
+application/vnd.dvb.notif-ia-registration-request+xml
+application/vnd.dvb.notif-ia-registration-response+xml
+application/vnd.dvb.notif-init+xml
+application/vnd.dvb.pfr
+application/vnd.dvb.service			svc
+application/vnd.dxr
+application/vnd.dynageo				geo
+application/vnd.dzr				dzr
+application/vnd.easykaraoke.cdgdownload
+application/vnd.ecdis-update
+application/vnd.ecip.rlp
+application/vnd.eclipse.ditto+json
+application/vnd.ecowin.chart			mag
+application/vnd.ecowin.filerequest
+application/vnd.ecowin.fileupdate
+application/vnd.ecowin.series
+application/vnd.ecowin.seriesrequest
+application/vnd.ecowin.seriesupdate
+application/vnd.efi.img
+application/vnd.efi.iso
+application/vnd.eln+zip				ELN
+application/vnd.emclient.accessrequest+xml
+application/vnd.enliven				nml
+application/vnd.enphase.envoy
+application/vnd.eprints.data+xml
+application/vnd.epson.esf			esf
+application/vnd.epson.msf			msf
+application/vnd.epson.quickanime		qam
+application/vnd.epson.salt			slt
+application/vnd.epson.ssf			ssf
+application/vnd.ericsson.quickcall		qcall qca
+application/vnd.espass-espass+zip		espass
+application/vnd.eszigno3+xml			es3 et3
+application/vnd.etsi.aoc+xml
+application/vnd.etsi.asic-e+zip			asice sce
+application/vnd.etsi.asic-s+zip			asics
+application/vnd.etsi.cug+xml
+application/vnd.etsi.iptvcommand+xml
+application/vnd.etsi.iptvdiscovery+xml
+application/vnd.etsi.iptvprofile+xml
+application/vnd.etsi.iptvsad-bc+xml
+application/vnd.etsi.iptvsad-cod+xml
+application/vnd.etsi.iptvsad-npvr+xml
+application/vnd.etsi.iptvservice+xml
+application/vnd.etsi.iptvsync+xml
+application/vnd.etsi.iptvueprofile+xml
+application/vnd.etsi.mcid+xml
+application/vnd.etsi.mheg5
+application/vnd.etsi.overload-control-policy-dataset+xml
+application/vnd.etsi.pstn+xml
+application/vnd.etsi.sci+xml
+application/vnd.etsi.simservs+xml
+application/vnd.etsi.timestamp-token		tst
+application/vnd.etsi.tsl+xml
+application/vnd.etsi.tsl.der
+application/vnd.eu.kasparian.car+json		carjson
+application/vnd.eudora.data
+application/vnd.evolv.ecig.profile		ecigprofile
+application/vnd.evolv.ecig.settings		ecig
+application/vnd.evolv.ecig.theme		ecigtheme
+application/vnd.exstream-empower+zip		mpw
+application/vnd.exstream-package		pub
+application/vnd.ezpix-album			ez2
+application/vnd.ezpix-package			ez3
+application/vnd.f-secure.mobile
+application/vnd.familysearch.gedcom+zip		gdz
+application/vnd.fastcopy-disk-image		dim
+application/vnd.fdsn.mseed			msd mseed
+application/vnd.fdsn.seed			seed dataless
+application/vnd.ffsns
+application/vnd.ficlab.flb+zip			flb
+application/vnd.filmit.zfc			zfc
+application/vnd.fints
+application/vnd.firemonkeys.cloudcell
+application/vnd.FloGraphIt			gph
+application/vnd.fluxtime.clip			ftc
+application/vnd.font-fontforge-sfd		sfd
+application/vnd.framemaker			fm
+application/vnd.freelog.comic
+application/vnd.fsc.weblaunch			fsc
+application/vnd.fujifilm.fb.docuworks
+application/vnd.fujifilm.fb.docuworks.binder
+application/vnd.fujifilm.fb.docuworks.container
+application/vnd.fujifilm.fb.jfi+xml
+application/vnd.fujitsu.oasys			oas
+application/vnd.fujitsu.oasys2			oa2
+application/vnd.fujitsu.oasys3			oa3
+application/vnd.fujitsu.oasysgp			fg5
+application/vnd.fujitsu.oasysprs		bh2
+application/vnd.fujixerox.ART-EX
+application/vnd.fujixerox.ART4
+application/vnd.fujixerox.ddd			ddd
+application/vnd.fujixerox.HBPL
+application/vnd.fut-misnet
+application/vnd.futoin+cbor
+application/vnd.futoin+json
+application/vnd.fuzzysheet			fzs
+application/vnd.genomatix.tuxedo		txd
+application/vnd.genozip				genozip
+application/vnd.gentics.grd+json		grd
+application/vnd.gentoo.catmetadata+xml
+application/vnd.gentoo.ebuild			ebuild
+application/vnd.gentoo.eclass			eclass
+application/vnd.gentoo.gpkg			gpkg.tar
+application/vnd.gentoo.manifest
+application/vnd.gentoo.pkgmetadata+xml
+application/vnd.gentoo.xpak			xpak
+application/vnd.geogebra.file			ggb
+application/vnd.geogebra.slides			ggs
+application/vnd.geogebra.tool			ggt
+application/vnd.geometry-explorer		gex gre
+application/vnd.geonext				gxt
+application/vnd.geoplan				g2w
+application/vnd.geospace			g3w
+application/vnd.gerber
+application/vnd.globalplatform.card-content-mgt
+application/vnd.globalplatform.card-content-mgt-response
+application/vnd.gnu.taler.exchange+json
+application/vnd.gnu.taler.merchant+json
+application/vnd.google-earth.kml+xml		kml
+application/vnd.google-earth.kmz		kmz
+application/vnd.gov.sk.e-form+xml
+application/vnd.gov.sk.e-form+zip
+application/vnd.gov.sk.xmldatacontainer+xml
+application/vnd.gpxsee.map+xml
+application/vnd.grafeq				gqf gqs
+application/vnd.gridmp
+application/vnd.groove-account			gac
+application/vnd.groove-help			ghf
+application/vnd.groove-identity-message		gim
+application/vnd.groove-injector			grv
+application/vnd.groove-tool-message		gtm
+application/vnd.groove-tool-template		tpl
+application/vnd.groove-vcard			vcg
+application/vnd.hal+json
+application/vnd.hal+xml				hal
+application/vnd.HandHeld-Entertainment+xml	zmm
+application/vnd.hbci				hbci hbc kom upa pkd bpd
+application/vnd.hc+json
+application/vnd.hcl-bireports
+application/vnd.hdt				hdt
+application/vnd.heroku+json
+application/vnd.hhe.lesson-player		les
+application/vnd.hp-HPGL				hpgl
+application/vnd.hp-hpid				hpi hpid
+application/vnd.hp-hps				hps
+application/vnd.hp-jlyt				jlt
+application/vnd.hp-PCL				pcl
+application/vnd.hp-PCLXL
+application/vnd.hsl				hsl
+application/vnd.httphone
+application/vnd.hydrostatix.sof-data		sfd-hdstx
+application/vnd.hyper+json
+application/vnd.hyper-item+json
+application/vnd.hyperdrive+json
+application/vnd.hzn-3d-crossword
+application/vnd.ibm.electronic-media		emm
+application/vnd.ibm.MiniPay			mpy
+application/vnd.ibm.rights-management		irm
+application/vnd.ibm.secure-container		sc
+application/vnd.iccprofile			icc icm
+application/vnd.ieee.1905			1905.1
+application/vnd.igloader			igl
+application/vnd.imagemeter.folder+zip		imf
+application/vnd.imagemeter.image+zip		imi
+application/vnd.immervision-ivp			ivp
+application/vnd.immervision-ivu			ivu
+application/vnd.ims.imsccv1p1			imscc
+application/vnd.ims.imsccv1p2
+application/vnd.ims.imsccv1p3
+application/vnd.ims.lis.v2.result+json
+application/vnd.ims.lti.v2.toolconsumerprofile+json
+application/vnd.ims.lti.v2.toolproxy+json
+application/vnd.ims.lti.v2.toolproxy.id+json
+application/vnd.ims.lti.v2.toolsettings+json
+application/vnd.ims.lti.v2.toolsettings.simple+json
+application/vnd.informedcontrol.rms+xml
+application/vnd.infotech.project
+application/vnd.infotech.project+xml
+application/vnd.innopath.wamp.notification
+application/vnd.insors.igm			igm
+application/vnd.intercon.formnet		xpw xpx
+application/vnd.intergeo			i2g
+application/vnd.intertrust.digibox
+application/vnd.intertrust.nncp
+application/vnd.intu.qbo			qbo
+application/vnd.intu.qfx			qfx
+application/vnd.ipfs.ipns-record		ipns-record
+application/vnd.ipld.car			car
+application/vnd.ipld.dag-cbor
+application/vnd.ipld.dag-json
+application/vnd.ipld.raw
+application/vnd.iptc.g2.catalogitem+xml
+application/vnd.iptc.g2.conceptitem+xml
+application/vnd.iptc.g2.knowledgeitem+xml
+application/vnd.iptc.g2.newsitem+xml
+application/vnd.iptc.g2.newsmessage+xml
+application/vnd.iptc.g2.packageitem+xml
+application/vnd.iptc.g2.planningitem+xml
+application/vnd.ipunplugged.rcprofile		rcprofile
+application/vnd.irepository.package+xml		irp
+application/vnd.is-xpr				xpr
+application/vnd.isac.fcs			fcs
+application/vnd.iso11783-10+zip
+application/vnd.jam				jam
+application/vnd.japannet-directory-service
+application/vnd.japannet-jpnstore-wakeup
+application/vnd.japannet-payment-wakeup
+application/vnd.japannet-registration
+application/vnd.japannet-registration-wakeup
+application/vnd.japannet-setstore-wakeup
+application/vnd.japannet-verification
+application/vnd.japannet-verification-wakeup
+application/vnd.jcp.javame.midlet-rms		rms
+application/vnd.jisp				jisp
+application/vnd.joost.joda-archive		joda
+application/vnd.jsk.isdn-ngn
+application/vnd.kahootz				ktz ktr
+application/vnd.kde.karbon			karbon
+application/vnd.kde.kchart			chrt
+application/vnd.kde.kformula			kfo
+application/vnd.kde.kivio			flw
+application/vnd.kde.kontour			kon
+application/vnd.kde.kpresenter			kpr kpt
+application/vnd.kde.kspread			ksp
+application/vnd.kde.kword			kwd kwt
+application/vnd.kenameaapp			htke
+application/vnd.kidspiration			kia
+application/vnd.Kinar				kne knp sdf
+application/vnd.koan				skp skd skm skt
+application/vnd.kodak-descriptor		sse
+application/vnd.las				las
+application/vnd.las.las+json			lasjson
+application/vnd.las.las+xml			lasxml
+application/vnd.laszip
+application/vnd.leap+json
+application/vnd.liberty-request+xml
+application/vnd.llamagraphics.life-balance.desktop	lbd
+application/vnd.llamagraphics.life-balance.exchange+xml	lbe
+application/vnd.logipipe.circuit+zip		lcs lca
+application/vnd.loom				loom
+application/vnd.lotus-1-2-3			123 wk4 wk3 wk1
+application/vnd.lotus-approach			apr vew
+application/vnd.lotus-freelance			prz pre
+application/vnd.lotus-notes			nsf ntf ndl ns4 ns3 ns2 nsh nsg
+application/vnd.lotus-organizer			or3 or2 org
+application/vnd.lotus-screencam			scm
+application/vnd.lotus-wordpro			lwp sam
+application/vnd.macports.portpkg		portpkg
+application/vnd.mapbox-vector-tile		mvt
+application/vnd.marlin.drm.actiontoken+xml
+application/vnd.marlin.drm.conftoken+xml
+application/vnd.marlin.drm.license+xml
+application/vnd.marlin.drm.mdcf			mdc
+application/vnd.mason+json
+application/vnd.maxar.archive.3tz+zip		3tz
+application/vnd.maxmind.maxmind-db		mmdb
+application/vnd.mcd				mcd
+application/vnd.mdl				mdl
+application/vnd.mdl-mbsdf			mbsdf
+application/vnd.medcalcdata			mc1
+application/vnd.mediastation.cdkey		cdkey
+application/vnd.medicalholodeck.recordxr	rxt
+application/vnd.meridian-slingshot
+application/vnd.MFER				mwf
+application/vnd.mfmp				mfm
+application/vnd.micro+json
+application/vnd.micrografx.flo			flo
+application/vnd.micrografx.igx			igx
+application/vnd.microsoft.portable-executable
+application/vnd.microsoft.windows.thumbnail-cache
+application/vnd.miele+json
+application/vnd.mif				mif
+application/vnd.minisoft-hp3000-save
+application/vnd.mitsubishi.misty-guard.trustweb
+application/vnd.Mobius.DAF			daf
+application/vnd.Mobius.DIS			dis
+application/vnd.Mobius.MBK			mbk
+application/vnd.Mobius.MQY			mqy
+application/vnd.Mobius.MSL			msl
+application/vnd.Mobius.PLC			plc
+application/vnd.Mobius.TXF			txf
+application/vnd.modl				modl
+application/vnd.mophun.application		mpn
+application/vnd.mophun.certificate		mpc
+application/vnd.motorola.flexsuite
+application/vnd.motorola.flexsuite.adsi
+application/vnd.motorola.flexsuite.fis
+application/vnd.motorola.flexsuite.gotap
+application/vnd.motorola.flexsuite.kmr
+application/vnd.motorola.flexsuite.ttc
+application/vnd.motorola.flexsuite.wem
+application/vnd.motorola.iprm
+application/vnd.mozilla.xul+xml			xul
+application/vnd.ms-3mfdocument			3mf
+application/vnd.ms-artgalry			cil
+application/vnd.ms-asf				asf
+application/vnd.ms-cab-compressed		cab
+application/vnd.ms-excel			xls xlm xla xlc xlt xlw
+application/vnd.ms-excel.addin.macroEnabled.12	xlam
+application/vnd.ms-excel.sheet.binary.macroEnabled.12	xlsb
+application/vnd.ms-excel.sheet.macroEnabled.12	xlsm
+application/vnd.ms-excel.template.macroEnabled.12	xltm
+application/vnd.ms-fontobject			eot
+application/vnd.ms-htmlhelp			chm
+application/vnd.ms-ims				ims
+application/vnd.ms-lrm				lrm
+application/vnd.ms-office.activeX+xml
+application/vnd.ms-officetheme			thmx
+application/vnd.ms-pki.seccat			cat
+application/vnd.ms-playready.initiator+xml
+application/vnd.ms-powerpoint							ppt pps
+application/vnd.ms-powerpoint.addin.macroEnabled.12				ppam
+application/vnd.ms-powerpoint.presentation.macroEnabled.12			pptm
+application/vnd.ms-powerpoint.slide.macroEnabled.12				sldm
+application/vnd.ms-powerpoint.slideshow.macroEnabled.12				ppsm
+application/vnd.ms-powerpoint.template.macroEnabled.12				potm
+application/vnd.ms-PrintDeviceCapabilities+xml
+application/vnd.ms-PrintSchemaTicket+xml
+application/vnd.ms-project			mpp mpt
+application/vnd.ms-tnef				tnef tnf
+application/vnd.ms-windows.devicepairing
+application/vnd.ms-windows.nwprinting.oob
+application/vnd.ms-windows.printerpairing
+application/vnd.ms-windows.wsd.oob
+application/vnd.ms-wmdrm.lic-chlg-req
+application/vnd.ms-wmdrm.lic-resp
+application/vnd.ms-wmdrm.meter-chlg-req
+application/vnd.ms-wmdrm.meter-resp
+application/vnd.ms-word.document.macroEnabled.12				docm
+application/vnd.ms-word.template.macroEnabled.12				dotm
+application/vnd.ms-works			wcm wdb wks wps
+application/vnd.ms-wpl				wpl
+application/vnd.ms-xpsdocument			xps
+application/vnd.msa-disk-image			msa
+application/vnd.mseq				mseq
+application/vnd.msign
+application/vnd.multiad.creator			crtr
+application/vnd.multiad.creator.cif		cif
+application/vnd.music-niff
+application/vnd.musician			mus
+application/vnd.muvee.style			msty
+application/vnd.mynfc				taglet
+application/vnd.nacamar.ybrid+json
+application/vnd.ncd.control
+application/vnd.ncd.reference
+application/vnd.nearst.inv+json
+application/vnd.nebumind.line			nebul line
+application/vnd.nervana				entity request bkm kcm
+application/vnd.netfpx
+application/vnd.neurolanguage.nlu		nlu
+application/vnd.nimn				nimn
+application/vnd.nintendo.nitro.rom		nds
+application/vnd.nintendo.snes.rom		sfc smc
+application/vnd.nitf				nitf
+application/vnd.noblenet-directory		nnd
+application/vnd.noblenet-sealer			nns
+application/vnd.noblenet-web			nnw
+application/vnd.nokia.catalogs
+application/vnd.nokia.conml+wbxml
+application/vnd.nokia.conml+xml
+application/vnd.nokia.iptv.config+xml
+application/vnd.nokia.iSDS-radio-presets
+application/vnd.nokia.landmark+wbxml
+application/vnd.nokia.landmark+xml
+application/vnd.nokia.landmarkcollection+xml
+application/vnd.nokia.n-gage.ac+xml
+application/vnd.nokia.n-gage.data		ngdat
+application/vnd.nokia.ncd
+application/vnd.nokia.pcd+wbxml
+application/vnd.nokia.pcd+xml
+application/vnd.nokia.radio-preset		rpst
+application/vnd.nokia.radio-presets		rpss
+application/vnd.novadigm.EDM			edm
+application/vnd.novadigm.EDX			edx
+application/vnd.novadigm.EXT			ext
+application/vnd.ntt-local.content-share
+application/vnd.ntt-local.file-transfer
+application/vnd.ntt-local.ogw_remote-access
+application/vnd.ntt-local.sip-ta_remote
+application/vnd.ntt-local.sip-ta_tcp_stream
+application/vnd.oasis.opendocument.base						odb
+application/vnd.oasis.opendocument.chart					odc
+application/vnd.oasis.opendocument.chart-template				otc
+application/vnd.oasis.opendocument.formula					odf
+application/vnd.oasis.opendocument.formula-template
+application/vnd.oasis.opendocument.graphics					odg
+application/vnd.oasis.opendocument.graphics-template				otg
+application/vnd.oasis.opendocument.image					odi
+application/vnd.oasis.opendocument.image-template				oti
+application/vnd.oasis.opendocument.presentation					odp
+application/vnd.oasis.opendocument.presentation-template			otp
+application/vnd.oasis.opendocument.spreadsheet					ods
+application/vnd.oasis.opendocument.spreadsheet-template				ots
+application/vnd.oasis.opendocument.text						odt
+application/vnd.oasis.opendocument.text-master					odm
+application/vnd.oasis.opendocument.text-master-template				otm
+application/vnd.oasis.opendocument.text-template				ott
+application/vnd.oasis.opendocument.text-web					oth
+application/vnd.obn
+application/vnd.ocf+cbor
+application/vnd.oci.image.manifest.v1+json
+application/vnd.oftn.l10n+json
+application/vnd.oipf.contentaccessdownload+xml
+application/vnd.oipf.contentaccessstreaming+xml
+application/vnd.oipf.cspg-hexbinary
+application/vnd.oipf.dae.svg+xml
+application/vnd.oipf.dae.xhtml+xml
+application/vnd.oipf.mippvcontrolmessage+xml
+application/vnd.oipf.pae.gem
+application/vnd.oipf.spdiscovery+xml
+application/vnd.oipf.spdlist+xml
+application/vnd.oipf.ueprofile+xml
+application/vnd.oipf.userprofile+xml
+application/vnd.olpc-sugar			xo
+application/vnd.oma-scws-config
+application/vnd.oma-scws-http-request
+application/vnd.oma-scws-http-response
+application/vnd.oma.bcast.associated-procedure-parameter+xml
+application/vnd.oma.bcast.drm-trigger+xml
+application/vnd.oma.bcast.imd+xml
+application/vnd.oma.bcast.ltkm
+application/vnd.oma.bcast.notification+xml
+application/vnd.oma.bcast.provisioningtrigger
+application/vnd.oma.bcast.sgboot
+application/vnd.oma.bcast.sgdd+xml
+application/vnd.oma.bcast.sgdu
+application/vnd.oma.bcast.simple-symbol-container
+application/vnd.oma.bcast.smartcard-trigger+xml
+application/vnd.oma.bcast.sprov+xml
+application/vnd.oma.bcast.stkm
+application/vnd.oma.cab-address-book+xml
+application/vnd.oma.cab-feature-handler+xml
+application/vnd.oma.cab-pcc+xml
+application/vnd.oma.cab-subs-invite+xml
+application/vnd.oma.cab-user-prefs+xml
+application/vnd.oma.dcd
+application/vnd.oma.dcdc
+application/vnd.oma.dd2+xml			dd2
+application/vnd.oma.drm.risd+xml
+application/vnd.oma.group-usage-list+xml
+application/vnd.oma.lwm2m+cbor
+application/vnd.oma.lwm2m+json
+application/vnd.oma.lwm2m+tlv
+application/vnd.oma.pal+xml
+application/vnd.oma.poc.detailed-progress-report+xml
+application/vnd.oma.poc.final-report+xml
+application/vnd.oma.poc.groups+xml
+application/vnd.oma.poc.invocation-descriptor+xml
+application/vnd.oma.poc.optimized-progress-report+xml
+application/vnd.oma.push
+application/vnd.oma.scidm.messages+xml
+application/vnd.oma.xcap-directory+xml
+application/vnd.omads-email+xml
+application/vnd.omads-file+xml
+application/vnd.omads-folder+xml
+application/vnd.omaloc-supl-init
+application/vnd.onepager			tam
+application/vnd.onepagertamp			tamp
+application/vnd.onepagertamx			tamx
+application/vnd.onepagertat			tat
+application/vnd.onepagertatp			tatp
+application/vnd.onepagertatx			tatx
+application/vnd.onvif.metadata
+application/vnd.openblox.game+xml		obgx
+application/vnd.openblox.game-binary		obg
+application/vnd.openeye.oeb			oeb
+application/vnd.openofficeorg.extension		oxt
+application/vnd.openstreetmap.data+xml		osm
+application/vnd.opentimestamps.ots
+application/vnd.openxmlformats-officedocument.custom-properties+xml
+application/vnd.openxmlformats-officedocument.customXmlProperties+xml
+application/vnd.openxmlformats-officedocument.drawing+xml
+application/vnd.openxmlformats-officedocument.drawingml.chart+xml
+application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml
+application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml
+application/vnd.openxmlformats-officedocument.extended-properties+xml
+application/vnd.openxmlformats-officedocument.presentationml.commentAuthors+xml
+application/vnd.openxmlformats-officedocument.presentationml.comments+xml
+application/vnd.openxmlformats-officedocument.presentationml.handoutMaster+xml
+application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml
+application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml
+application/vnd.openxmlformats-officedocument.presentationml.presentation	pptx
+application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml
+application/vnd.openxmlformats-officedocument.presentationml.presProps+xml
+application/vnd.openxmlformats-officedocument.presentationml.slide		sldx
+application/vnd.openxmlformats-officedocument.presentationml.slide+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideshow		ppsx
+application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml
+application/vnd.openxmlformats-officedocument.presentationml.slideUpdateInfo+xml
+application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml
+application/vnd.openxmlformats-officedocument.presentationml.tags+xml
+application/vnd.openxmlformats-officedocument.presentationml.template		potx
+application/vnd.openxmlformats-officedocument.presentationml.template.main+xml
+application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheet		xlsx
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.template		xltx
+application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml
+application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml
+application/vnd.openxmlformats-officedocument.theme+xml
+application/vnd.openxmlformats-officedocument.themeOverride+xml
+application/vnd.openxmlformats-officedocument.vmlDrawing
+application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.document		docx
+application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.template		dotx
+application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml
+application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml
+application/vnd.openxmlformats-package.core-properties+xml
+application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml
+application/vnd.openxmlformats-package.relationships+xml
+application/vnd.oracle.resource+json
+application/vnd.orange.indata
+application/vnd.osa.netdeploy			ndc
+application/vnd.osgeo.mapguide.package		mgp
+application/vnd.osgi.bundle
+application/vnd.osgi.dp				dp
+application/vnd.osgi.subsystem			esa
+application/vnd.otps.ct-kip+xml
+application/vnd.oxli.countgraph			oxlicg
+application/vnd.pagerduty+json
+application/vnd.palm				pdb pqa oprc
+application/vnd.panoply				plp
+application/vnd.paos.xml
+application/vnd.patentdive			dive
+application/vnd.patientecommsdoc
+application/vnd.pawaafile			paw
+application/vnd.pcos
+application/vnd.pg.format			str
+application/vnd.pg.osasli			ei6
+application/vnd.piaccess.application-licence	pil
+application/vnd.picsel				efif
+application/vnd.pmi.widget			wg
+application/vnd.poc.group-advertisement+xml
+application/vnd.pocketlearn			plf
+application/vnd.powerbuilder6			pbd
+application/vnd.powerbuilder6-s
+application/vnd.powerbuilder7
+application/vnd.powerbuilder7-s
+application/vnd.powerbuilder75
+application/vnd.powerbuilder75-s
+application/vnd.preminet			preminet
+application/vnd.previewsystems.box		box vbox
+application/vnd.proteus.magazine		mgz
+application/vnd.psfs				psfs
+application/vnd.pt.mundusmundi
+application/vnd.publishare-delta-tree		qps
+application/vnd.pvi.ptid1			ptid
+application/vnd.pwg-multiplexed
+application/vnd.pwg-xhtml-print+xml
+application/vnd.qualcomm.brew-app-res		bar
+application/vnd.quarantainenet
+application/vnd.Quark.QuarkXPress		qxd qxt qwd qwt qxl qxb
+application/vnd.quobject-quoxdocument		quox quiz
+application/vnd.radisys.moml+xml
+application/vnd.radisys.msml+xml
+application/vnd.radisys.msml-audit+xml
+application/vnd.radisys.msml-audit-conf+xml
+application/vnd.radisys.msml-audit-conn+xml
+application/vnd.radisys.msml-audit-dialog+xml
+application/vnd.radisys.msml-audit-stream+xml
+application/vnd.radisys.msml-conf+xml
+application/vnd.radisys.msml-dialog+xml
+application/vnd.radisys.msml-dialog-base+xml
+application/vnd.radisys.msml-dialog-fax-detect+xml
+application/vnd.radisys.msml-dialog-fax-sendrecv+xml
+application/vnd.radisys.msml-dialog-group+xml
+application/vnd.radisys.msml-dialog-speech+xml
+application/vnd.radisys.msml-dialog-transform+xml
+application/vnd.rainstor.data			tree
+application/vnd.rapid
+application/vnd.rar				rar
+application/vnd.realvnc.bed			bed
+application/vnd.recordare.musicxml		mxl
+application/vnd.recordare.musicxml+xml
+application/vnd.RenLearn.rlprint
+application/vnd.resilient.logic			rlm reload
+application/vnd.restful+json
+application/vnd.rig.cryptonote			cryptonote
+application/vnd.rim.cod								cod
+application/vnd.route66.link66+xml		link66
+application/vnd.rs-274x
+application/vnd.ruckus.download
+application/vnd.s3sms
+application/vnd.sailingtracker.track		st
+application/vnd.sar				SAR
+application/vnd.sbm.cid
+application/vnd.sbm.mid2
+application/vnd.scribus				scd sla slaz
+application/vnd.sealed.3df			s3df
+application/vnd.sealed.csf			scsf
+application/vnd.sealed.doc			sdoc sdo s1w
+application/vnd.sealed.eml			seml sem
+application/vnd.sealed.mht			smht smh
+application/vnd.sealed.net
+application/vnd.sealed.ppt			sppt s1p
+application/vnd.sealed.tiff			stif
+application/vnd.sealed.xls			sxls sxl s1e
+application/vnd.sealedmedia.softseal.html	stml s1h
+application/vnd.sealedmedia.softseal.pdf	spdf spd s1a
+application/vnd.seemail				see
+application/vnd.seis+json
+application/vnd.sema				sema
+application/vnd.semd				semd
+application/vnd.semf				semf
+application/vnd.shade-save-file			ssv
+application/vnd.shana.informed.formdata		ifm
+application/vnd.shana.informed.formtemplate	itp
+application/vnd.shana.informed.interchange	iif
+application/vnd.shana.informed.package		ipk
+application/vnd.shootproof+json
+application/vnd.shopkick+json
+application/vnd.shp				shp
+application/vnd.shx				shx
+application/vnd.sigrok.session			sr
+application/vnd.SimTech-MindMapper		twd twds
+application/vnd.siren+json
+application/vnd.smaf				mmf
+application/vnd.smart.notebook			notebook
+application/vnd.smart.teacher			teacher
+application/vnd.smintio.portals.archive		sipa
+application/vnd.snesdev-page-table		ptrom pt
+application/vnd.software602.filler.form+xml	fo
+application/vnd.software602.filler.form-xml-zip	zfo
+application/vnd.solent.sdkm+xml			sdkm sdkd
+application/vnd.spotfire.dxp			dxp
+application/vnd.spotfire.sfs			sfs
+application/vnd.sqlite3				sqlite sqlite3
+application/vnd.sss-cod
+application/vnd.sss-dtf
+application/vnd.sss-ntf
+application/vnd.stardivision.calc						sdc
+application/vnd.stardivision.chart						sds
+application/vnd.stardivision.draw						sda
+application/vnd.stardivision.impress						sdd
+application/vnd.stardivision.math						smf
+application/vnd.stardivision.writer						sdw
+application/vnd.stardivision.writer-global					sgl
+application/vnd.stepmania.package		smzip
+application/vnd.stepmania.stepchart		sm
+application/vnd.street-stream
+application/vnd.sun.wadl+xml			wadl
+application/vnd.sun.xml.calc							sxc
+application/vnd.sun.xml.calc.template						stc
+application/vnd.sun.xml.draw							sxd
+application/vnd.sun.xml.draw.template						std
+application/vnd.sun.xml.impress							sxi
+application/vnd.sun.xml.impress.template					sti
+application/vnd.sun.xml.math							sxm
+application/vnd.sun.xml.writer							sxw
+application/vnd.sun.xml.writer.global						sxg
+application/vnd.sun.xml.writer.template						stw
+application/vnd.sus-calendar			sus susp
+application/vnd.svd
+application/vnd.swiftview-ics
+application/vnd.sybyl.mol2			ml2 mol2 sy2
+application/vnd.sycle+xml			scl
+application/vnd.syft+json			syft.json
+application/vnd.symbian.install							sis
+application/vnd.syncml+xml			xsm
+application/vnd.syncml.dm+wbxml			bdm
+application/vnd.syncml.dm+xml			xdm
+application/vnd.syncml.dm.notification
+application/vnd.syncml.dmddf+wbxml
+application/vnd.syncml.dmddf+xml		ddf
+application/vnd.syncml.dmtnds+wbxml
+application/vnd.syncml.dmtnds+xml
+application/vnd.syncml.ds.notification
+application/vnd.tableschema+json
+application/vnd.tao.intent-module-archive	tao
+application/vnd.tcpdump.pcap			pcap cap dmp
+application/vnd.theqvd				qvd
+application/vnd.think-cell.ppttc+json		ppttc
+application/vnd.tmd.mediaflex.api+xml
+application/vnd.tml				vfr viaframe
+application/vnd.tmobile-livetv			tmo
+application/vnd.tri.onesource
+application/vnd.trid.tpt			tpt
+application/vnd.triscape.mxs			mxs
+application/vnd.trueapp				tra
+application/vnd.truedoc
+application/vnd.ubisoft.webplayer
+application/vnd.ufdl				ufdl ufd frm
+application/vnd.uiq.theme			utz
+application/vnd.umajin				umj
+application/vnd.unity				unityweb
+application/vnd.uoml+xml			uoml uo
+application/vnd.uplanet.alert
+application/vnd.uplanet.alert-wbxml
+application/vnd.uplanet.bearer-choice
+application/vnd.uplanet.bearer-choice-wbxml
+application/vnd.uplanet.cacheop
+application/vnd.uplanet.cacheop-wbxml
+application/vnd.uplanet.channel
+application/vnd.uplanet.channel-wbxml
+application/vnd.uplanet.list
+application/vnd.uplanet.list-wbxml
+application/vnd.uplanet.listcmd
+application/vnd.uplanet.listcmd-wbxml
+application/vnd.uplanet.signal
+application/vnd.uri-map				urim urimap
+application/vnd.valve.source.material		vmt
+application/vnd.vcx				vcx
+application/vnd.vd-study			mxi study-inter model-inter
+application/vnd.vectorworks			vwx
+application/vnd.vel+json
+application/vnd.verimatrix.vcas
+application/vnd.veritone.aion+json		aion vtnstd
+application/vnd.veryant.thin			istc isws
+application/vnd.ves.encrypted			VES
+application/vnd.vidsoft.vidconference		vsc
+application/vnd.visio				vsd vst vsw vss
+application/vnd.visionary			vis
+application/vnd.vividence.scriptfile
+application/vnd.vsf				vsf
+application/vnd.wap.sic				sic
+application/vnd.wap.slc				slc
+application/vnd.wap.wbxml			wbxml
+application/vnd.wap.wmlc			wmlc
+application/vnd.wap.wmlscriptc			wmlsc
+application/vnd.wasmflow.wafl			wafl
+application/vnd.webturbo			wtb
+application/vnd.wfa.dpp
+application/vnd.wfa.p2p				p2p
+application/vnd.wfa.wsc				wsc
+application/vnd.windows.devicepairing
+application/vnd.wmc				wmc
+application/vnd.wmf.bootstrap
+application/vnd.wolfram.mathematica		nb
+application/vnd.wolfram.mathematica.package	m
+application/vnd.wolfram.player			nbp
+application/vnd.wordlift
+application/vnd.wordperfect			wpd
+application/vnd.wqd				wqd
+application/vnd.wrq-hp3000-labelled
+application/vnd.wt.stf				stf
+application/vnd.wv.csp+wbxml			wv
+application/vnd.wv.csp+xml
+application/vnd.wv.ssp+xml
+application/vnd.xacml+json
+application/vnd.xara				xar
+application/vnd.xfdl				xfdl xfd
+application/vnd.xfdl.webform
+application/vnd.xmi+xml
+application/vnd.xmpie.cpkg			cpkg
+application/vnd.xmpie.dpkg			dpkg
+application/vnd.xmpie.plan
+application/vnd.xmpie.ppkg			ppkg
+application/vnd.xmpie.xlim			xlim
+application/vnd.yamaha.hv-dic			hvd
+application/vnd.yamaha.hv-script		hvs
+application/vnd.yamaha.hv-voice			hvp
+application/vnd.yamaha.openscoreformat		osf
+application/vnd.yamaha.openscoreformat.osfpvg+xml
+application/vnd.yamaha.remote-setup
+application/vnd.yamaha.smaf-audio		saf
+application/vnd.yamaha.smaf-phrase		spf
+application/vnd.yamaha.through-ngn
+application/vnd.yamaha.tunnel-udpencap
+application/vnd.yaoweme				yme
+application/vnd.yellowriver-custom-menu		cmp
+application/vnd.zul				zir zirz
+application/vnd.zzazz.deck+xml			zaz
+application/voicexml+xml			vxml
+application/voucher-cms+json			vcj
+application/vq-rtcpxr
+application/wasm				wasm
+application/watcherinfo+xml			wif
+application/webpush-options+json
+application/whoispp-query
+application/whoispp-response
+application/widget				wgt
+application/wita
+application/wordperfect5.1
+application/wsdl+xml				wsdl
+application/wspolicy+xml			wspolicy
+application/x-123				wk
+application/x-7z-compressed			7z
+application/x-abiword				abw
+application/x-apple-diskimage			dmg
+application/x-bcpio				bcpio
+application/x-bittorrent			torrent
+application/x-cdf				cdf cda
+application/x-cdlink				vcd
+application/x-comsol				mph
+application/x-cpio				cpio
+application/x-csh				csh
+application/x-director				dcr dir dxr
+application/x-doom				wad
+application/x-dvi				dvi
+application/x-font				pfa pfb gsf
+application/x-font-pcf				pcf pcf.Z
+application/x-freemind				mm
+application/x-ganttproject			gan
+application/x-gnumeric				gnumeric
+application/x-go-sgf				sgf
+application/x-graphing-calculator		gcf
+application/x-gtar				gtar
+application/x-gtar-compressed			tgz taz
+application/x-hdf				hdf
+application/x-hwp				hwp
+application/x-ica				ica
+application/x-info				info
+application/x-internet-signup			ins isp
+application/x-iphone				iii
+application/x-iso9660-image			iso
+application/x-java-jnlp-file			jnlp
+application/x-jmol				jmz
+application/x-killustrator			kil
+application/x-latex				latex
+application/x-lha				lha
+application/x-lyx				lyx
+application/x-lzh				lzh
+application/x-lzx				lzx
+application/x-maker				frm maker frame fm fb book fbdoc
+application/x-ms-wmd				wmd
+application/x-ms-wmz				wmz
+application/x-msdos-program			com exe bat dll
+application/x-msi				msi
+application/x-netcdf				nc
+application/x-ns-proxy-autoconfig		pac
+application/x-nwc				nwc
+application/x-object				o
+application/x-oz-application			oza
+application/x-pkcs7-certreqresp			p7r
+application/x-pki-message
+application/x-python-code			pyc pyo
+application/x-qgis				qgs shp shx
+application/x-quicktimeplayer			qtl
+application/x-rdp				rdp
+application/x-redhat-package-manager		rpm
+application/x-rss+xml				rss
+application/x-ruby				rb
+application/x-scilab				sci sce
+application/x-scilab-xcos			xcos
+application/x-sh				sh
+application/x-shar				shar
+application/x-silverlight			scr
+application/x-stuffit				sit sitx
+application/x-sv4cpio				sv4cpio
+application/x-sv4crc				sv4crc
+application/x-tar				tar
+application/x-tcl				tcl
+application/x-tex-gf				gf
+application/x-tex-pk				pk
+application/x-texinfo				texinfo texi
+application/x-trash				~ % bak old sik
+application/x-troff-man				man
+application/x-troff-me				me
+application/x-troff-ms				ms
+application/x-ustar				ustar
+application/x-wais-source			src
+application/x-wingz				wz
+application/x-www-form-urlencoded
+application/x-x509-ca-cert			crt
+application/x-x509-ca-ra-cert
+application/x-x509-next-ca-cert
+application/x-xfig				fig
+application/x-xpinstall				xpi
+application/x-xz				xz
+application/x400-bp
+application/xacml+xml
+application/xcap-att+xml			xav
+application/xcap-caps+xml			xca
+application/xcap-diff+xml			xdf
+application/xcap-el+xml				xel
+application/xcap-error+xml			xer
+application/xcap-ns+xml				xns
+application/xcon-conference-info+xml
+application/xcon-conference-info-diff+xml
+application/xenc+xml
+application/xfdf				xfdf
+application/xhtml+xml				xhtml xhtm xht
+application/xliff+xml				xlf
+application/xml					xml
+application/xml-dtd				dtd mod
+application/xml-external-parsed-entity		ent
+application/xml-patch+xml
+application/xmpp+xml
+application/xop+xml				xop
+application/xslt+xml				xsl xslt
+application/xspf+xml				xspf
+application/xv+xml				mxml xhvml xvml xvm
+application/yaml				yaml yml
+application/yang				yang
+application/yang-data+cbor
+application/yang-data+json
+application/yang-data+xml
+application/yang-patch+json
+application/yang-patch+xml
+application/yin+xml				yin
+application/zip					zip
+application/zlib
+application/zstd				zst
+
+audio/1d-interleaved-parityfec
+audio/32kadpcm					726
+audio/3gpp
+audio/3gpp2
+audio/aac					adts aac ass
+audio/ac3					ac3
+audio/AMR					amr AMR
+audio/AMR-WB					awb AWB
+audio/amr-wb+
+audio/annodex					axa
+audio/aptx
+audio/asc					acn
+audio/ATRAC-ADVANCED-LOSSLESS			aal
+audio/ATRAC-X					atx
+audio/ATRAC3					at3 aa3 omg
+audio/basic					au snd
+audio/BV16
+audio/BV32
+audio/clearmode
+audio/CN
+audio/csound					csd orc sco
+audio/DAT12
+audio/dls					dls
+audio/dsr-es201108
+audio/dsr-es202050
+audio/dsr-es202211
+audio/dsr-es202212
+audio/DV
+audio/DVI4
+audio/eac3
+audio/encaprtp
+audio/EVRC					evc
+audio/EVRC-QCP					qcp QCP
+audio/EVRC0
+audio/EVRC1
+audio/EVRCB					evb
+audio/EVRCB0
+audio/EVRCB1
+audio/EVRCNW					enw
+audio/EVRCNW0
+audio/EVRCNW1
+audio/EVRCWB					evw
+audio/EVRCWB0
+audio/EVRCWB1
+audio/EVS
+audio/example
+audio/flac					flac
+audio/flexfec
+audio/fwdred
+audio/G711-0
+audio/G719
+audio/G722
+audio/G7221
+audio/G723
+audio/G726-16
+audio/G726-24
+audio/G726-32
+audio/G726-40
+audio/G728
+audio/G729
+audio/G7291
+audio/G729D
+audio/G729E
+audio/GSM
+audio/GSM-EFR
+audio/GSM-HR-08
+audio/iLBC					lbc
+audio/ip-mr_v2.5
+audio/L16					l16
+audio/L20
+audio/L24
+audio/L8
+audio/LPC
+audio/MELP
+audio/MELP1200
+audio/MELP2400
+audio/MELP600
+audio/mhas					mhas
+audio/mobile-xmf				mxmf
+audio/mp4					m4a
+audio/MP4A-LATM
+audio/MPA
+audio/mpa-robust
+audio/mpeg					mpga mpega mp1 mp2 mp3
+audio/mpeg4-generic
+audio/mpegurl					m3u
+audio/ogg					oga ogg opus spx
+audio/opus
+audio/parityfec
+audio/PCMA
+audio/PCMA-WB
+audio/PCMU
+audio/PCMU-WB
+audio/prs.sid					sid psid
+audio/QCELP
+audio/raptorfec
+audio/RED
+audio/rtp-enc-aescm128
+audio/rtp-midi
+audio/rtploopback
+audio/rtx
+audio/scip
+audio/SMV					smv
+audio/SMV-QCP
+audio/SMV0
+audio/sofa					sofa
+audio/sp-midi					mid
+audio/speex
+audio/t140c
+audio/t38
+audio/telephone-event
+audio/TETRA_ACELP
+audio/TETRA_ACELP_BB
+audio/tone
+audio/TSVCIS
+audio/UEMCLIP
+audio/ulpfec
+audio/usac					loas xhe
+audio/VDVI
+audio/VMR-WB
+audio/vnd.3gpp.iufp
+audio/vnd.4SB
+audio/vnd.audiokoz				koz
+audio/vnd.CELP
+audio/vnd.cisco.nse
+audio/vnd.cmles.radio-events
+audio/vnd.cns.anp1
+audio/vnd.cns.inf1
+audio/vnd.dece.audio				uva uvva
+audio/vnd.digital-winds				eol
+audio/vnd.dlna.adts
+audio/vnd.dolby.heaac.1
+audio/vnd.dolby.heaac.2
+audio/vnd.dolby.mlp				mlp
+audio/vnd.dolby.mps
+audio/vnd.dolby.pl2
+audio/vnd.dolby.pl2x
+audio/vnd.dolby.pl2z
+audio/vnd.dolby.pulse.1
+audio/vnd.dra
+audio/vnd.dts					dts
+audio/vnd.dts.hd				dtshd
+audio/vnd.dts.uhd
+audio/vnd.dvb.file
+audio/vnd.everad.plj				plj
+audio/vnd.hns.audio
+audio/vnd.lucent.voice				lvp
+audio/vnd.ms-playready.media.pya		pya
+audio/vnd.nokia.mobile-xmf
+audio/vnd.nortel.vbk				vbk
+audio/vnd.nuera.ecelp4800			ecelp4800
+audio/vnd.nuera.ecelp7470			ecelp7470
+audio/vnd.nuera.ecelp9600			ecelp9600
+audio/vnd.octel.sbc
+audio/vnd.presonus.multitrack			multitrack
+audio/vnd.rhetorex.32kadpcm
+audio/vnd.rip					rip
+audio/vnd.sealedmedia.softseal.mpeg		smp3 smp s1m
+audio/vnd.vmx.cvsd
+audio/vorbis
+audio/vorbis-config
+audio/x-aiff					aif aiff aifc
+audio/x-gsm					gsm
+audio/x-ms-wax					wax
+audio/x-ms-wma					wma
+audio/x-pn-realaudio				ra rm ram
+audio/x-scpls					pls
+audio/x-sd2					sd2
+audio/x-wav					wav
+
+chemical/x-alchemy				alc
+chemical/x-cache				cac cache
+chemical/x-cache-csf				csf
+chemical/x-cactvs-binary			cbin cascii ctab
+chemical/x-cdx					cdx
+chemical/x-cerius
+chemical/x-chem3d				c3d
+chemical/x-chemdraw				chm
+chemical/x-cif					cif
+chemical/x-cmdf					cmdf
+chemical/x-cml					cml
+chemical/x-compass				cpa
+chemical/x-crossfire				bsd
+chemical/x-csml					csml csm
+chemical/x-ctx					ctx
+chemical/x-cxf					cxf cef
+#chemical/x-daylight-smiles			smi
+chemical/x-embl-dl-nucleotide			emb embl
+chemical/x-galactic-spc				spc
+chemical/x-gamess-input				inp gam gamin
+chemical/x-gaussian-checkpoint			fch fchk
+chemical/x-gaussian-cube			cub
+chemical/x-gaussian-input			gau gjc gjf
+chemical/x-gaussian-log				gal
+chemical/x-gcg8-sequence			gcg
+chemical/x-genbank				gen
+chemical/x-hin					hin
+chemical/x-isostar				istr ist
+chemical/x-jcamp-dx				jdx dx
+chemical/x-kinemage				kin
+chemical/x-macmolecule				mcm
+chemical/x-macromodel-input			mmod
+chemical/x-mdl-molfile				mol
+chemical/x-mdl-rdfile				rd
+chemical/x-mdl-rxnfile				rxn
+chemical/x-mdl-sdfile				sd sdf
+chemical/x-mdl-tgf				tgf
+#chemical/x-mif					mif
+chemical/x-mmcif				mcif
+chemical/x-molconn-Z				b
+chemical/x-mopac-graph				gpt
+chemical/x-mopac-input				mop mopcrt mpc zmt
+chemical/x-mopac-out				moo
+chemical/x-mopac-vib				mvb
+chemical/x-ncbi-asn1				asn
+chemical/x-ncbi-asn1-ascii			prt
+chemical/x-ncbi-asn1-binary			val aso
+chemical/x-ncbi-asn1-spec			asn
+chemical/x-pdb					pdb
+chemical/x-rosdal				ros
+chemical/x-swissprot				sw
+chemical/x-vamas-iso14976			vms
+chemical/x-vmd					vmd
+chemical/x-xtel					xtel
+chemical/x-xyz					xyz
+
+font/collection					ttc
+font/otf					otf
+font/sfnt
+font/ttf					ttf
+font/woff					woff
+font/woff2					woff2
+
+image/aces					exr
+image/apng					apng
+image/avci					avci
+image/avcs					avcs
+image/avif					avif hif
+image/bmp					bmp
+image/cgm					cgm
+image/dicom-rle					drle
+image/dpx					dpx
+image/emf					emf
+image/example
+image/fits					fits fit fts
+image/g3fax
+image/gif					gif
+image/heic					heic
+image/heic-sequence				heics
+image/heif					heif
+image/heif-sequence				heifs
+image/hej2k					hej2
+image/hsj2					hsj2
+image/ief					ief
+image/j2c					j2c J2C j2k J2K
+image/jls					jls
+image/jp2					jp2 jpg2
+image/jpeg					jpeg jpg jpe jfif
+image/jph					jph
+image/jphc					jhc jphc
+image/jpm					jpm jpgm
+image/jpx					jpx jpf
+image/jxl					jxl
+image/jxr					jxr
+image/jxrA					jxra
+image/jxrS					jxrs
+image/jxs					jxs
+image/jxsc					jxsc
+image/jxsi					jxsi
+image/jxss					jxss
+image/ktx					ktx
+image/ktx2					ktx2
+image/naplps
+image/png					png
+image/prs.btif					btif btf
+image/prs.pti					pti
+image/pwg-raster
+image/svg+xml					svg svgz
+image/t38
+image/tiff					tiff tif
+image/tiff-fx					tfx
+image/vnd.adobe.photoshop			psd
+image/vnd.airzip.accelerator.azv		azv
+image/vnd.cns.inf2
+image/vnd.dece.graphic				uvi uvvi uvg uvvg
+image/vnd.djvu					djvu djv
+image/vnd.dvb.subtitle
+image/vnd.dwg					dwg
+image/vnd.dxf					dxf
+image/vnd.fastbidsheet				fbs
+image/vnd.fpx					fpx
+image/vnd.fst					fst
+image/vnd.fujixerox.edmics-mmr			mmr
+image/vnd.fujixerox.edmics-rlc			rlc
+image/vnd.globalgraphics.pgb			PGB pgb
+image/vnd.microsoft.icon			ico
+image/vnd.mix
+image/vnd.ms-modi				mdi
+image/vnd.net-fpx
+image/vnd.pco.b16				b16
+image/vnd.radiance				hdr rgbe xyze
+image/vnd.sealed.png				spng spn s1n
+image/vnd.sealedmedia.softseal.gif		sgif sgi s1g
+image/vnd.sealedmedia.softseal.jpg		sjpg sjp s1j
+image/vnd.svf
+image/vnd.tencent.tap				tap
+image/vnd.valve.source.texture			vtf
+image/vnd.wap.wbmp				wbmp
+image/vnd.xiff					xif
+image/vnd.zbrush.pcx				pcx
+image/webp					webp
+image/wmf					wmf
+image/x-canon-cr2				cr2
+image/x-canon-crw				crw
+image/x-cmu-raster				ras
+image/x-coreldraw				cdr
+image/x-coreldrawpattern			pat
+image/x-coreldrawtemplate			cdt
+image/x-corelphotopaint				cpt
+image/x-epson-erf				erf
+image/x-jg					art
+image/x-jng					jng
+image/x-nikon-nef				nef
+image/x-olympus-orf				orf
+image/x-portable-anymap				pnm
+image/x-portable-bitmap				pbm
+image/x-portable-graymap			pgm
+image/x-portable-pixmap				ppm
+image/x-rgb					rgb
+image/x-xbitmap					xbm
+image/x-xcf					xcf
+image/x-xpixmap					xpm
+image/x-xwindowdump				xwd
+
+inode/blockdevice
+inode/chardevice
+inode/directory
+inode/directory-locked
+inode/fifo
+inode/socket
+
+message/bhttp
+message/CPIM
+message/delivery-status
+message/disposition-notification
+message/example
+message/external-body
+message/feedback-report
+message/global					u8msg
+message/global-delivery-status			u8dsn
+message/global-disposition-notification		u8mdn
+message/global-headers				u8hdr
+message/http
+message/imdn+xml
+message/mls
+message/ohttp-req
+message/ohttp-res
+message/partial
+message/rfc822					eml mail art
+message/s-http
+message/sip
+message/sipfrag
+message/tracking-status
+message/vnd.wfa.wsc
+
+model/3mf
+model/e57
+model/example
+model/gltf+json					gltf
+model/gltf-binary				glb
+model/iges					igs iges
+model/JT					jt
+model/mesh					msh mesh silo
+model/mtl					mtl
+model/obj					obj
+model/prc					prc
+model/step					stp step
+model/step+xml					stpx
+model/step+zip					stpz
+model/step-xml+zip				stpxz
+model/stl					stl
+model/u3d					u3d
+model/vnd.bary					bary
+model/vnd.cld					cld
+model/vnd.collada+xml				dae
+model/vnd.dwf					dwf
+model/vnd.flatland.3dml
+model/vnd.gdl					gdl gsm win dor lmp rsm msm ism
+model/vnd.gs-gdl
+model/vnd.gtw					gtw
+model/vnd.moml+xml				moml
+model/vnd.mts					mts
+model/vnd.opengex				ogex
+model/vnd.parasolid.transmit.binary		x_b xmt_bin
+model/vnd.parasolid.transmit.text		x_t xmt_txt
+model/vnd.pytha.pyox				pyox
+model/vnd.rosette.annotated-data-model
+model/vnd.sap.vds				vds
+model/vnd.usda					usda
+model/vnd.usdz+zip				usdz
+model/vnd.valve.source.compiled-map		bsp
+model/vnd.vtu					vtu
+model/vrml					wrl vrm vrml
+model/x3d+fastinfoset				x3db
+model/x3d+xml					x3d x3dz
+model/x3d-vrml					x3dv x3dvz
+
+multipart/alternative
+multipart/appledouble
+multipart/byteranges
+multipart/digest
+multipart/encrypted
+multipart/example
+multipart/form-data
+multipart/header-set
+multipart/mixed
+multipart/multilingual
+multipart/parallel
+multipart/related
+multipart/report
+multipart/signed
+multipart/vnd.bint.med-plus			bmed
+multipart/voice-message				vpm
+multipart/x-mixed-replace
+
+text/1d-interleaved-parityfec
+text/cache-manifest				appcache manifest
+text/calendar					ics ifb
+text/cql					CQL
+text/cql-extension
+text/cql-identifier
+text/css					css
+text/csv					csv
+text/csv-schema					csvs
+text/dns					soa zone
+text/encaprtp
+text/enriched
+text/example
+text/fhirpath
+text/flexfec
+text/fwdred
+text/gff3					gff3
+text/grammar-ref-list
+text/hl7v2
+text/html					html htm shtml
+text/javascript					es js mjs
+text/jcr-cnd					cnd
+text/markdown					md markdown
+text/mizar					miz
+text/n3						n3
+text/parameters
+text/parityfec
+text/plain					txt text pot brf srt
+text/provenance-notation			provn
+text/prs.fallenstein.rst			rst
+text/prs.lines.tag				tag dsc
+text/prs.prop.logic
+text/raptorfec
+text/RED
+text/rfc822-headers
+text/rtf
+text/rtp-enc-aescm128
+text/rtploopback
+text/rtx
+text/SGML					sgml sgm
+text/shaclc					shaclc shc
+text/shex					shex
+text/spdx					spdx
+text/strings
+text/t140
+text/tab-separated-values			tsv
+text/texmacs					tm
+text/troff					t tr roff
+text/turtle					ttl
+text/ulpfec
+text/uri-list					uris uri
+text/vcard					vcf vcard
+text/vnd.a					a
+text/vnd.abc					abc
+text/vnd.ascii-art				ascii
+text/vnd.curl					curl
+text/vnd.debian.copyright			copyright
+text/vnd.DMClientScript				dms
+text/vnd.dvb.subtitle
+text/vnd.esmertec.theme-descriptor		jtd
+text/vnd.exchangeable				VFK
+text/vnd.familysearch.gedcom			ged
+text/vnd.ficlab.flt				flt
+text/vnd.fly					fly
+text/vnd.fmi.flexstor				flx
+text/vnd.gml
+text/vnd.graphviz				gv dot
+text/vnd.hans					hans
+text/vnd.hgl					hgl
+text/vnd.in3d.3dml				3dml 3dm
+text/vnd.in3d.spot				spot spo
+text/vnd.IPTC.NewsML
+text/vnd.IPTC.NITF
+text/vnd.latex-z
+text/vnd.motorola.reflex
+text/vnd.ms-mediapackage			mpf
+text/vnd.net2phone.commcenter.command		ccc
+text/vnd.radisys.msml-basic-layout
+text/vnd.senx.warpscript			mc2
+text/vnd.sosi					sos
+text/vnd.sun.j2me.app-descriptor		jad
+text/vnd.trolltech.linguist			ts
+text/vnd.wap.si					si
+text/vnd.wap.sl					sl
+text/vnd.wap.wml				wml
+text/vnd.wap.wmlscript				wmls
+text/vtt					vtt
+text/wgsl					wgsl
+text/x-bibtex					bib
+text/x-boo					boo
+text/x-c++hdr					h++ hpp hxx hh
+text/x-c++src					c++ cpp cxx cc
+text/x-chdr					h
+text/x-component				htc
+text/x-csh					csh
+text/x-csrc					c
+text/x-diff					diff patch
+text/x-dsrc					d
+text/x-haskell					hs
+text/x-java					java
+text/x-lilypond					ly
+text/x-literate-haskell				lhs
+text/x-moc					moc
+text/x-pascal					p pas
+text/x-pcs-gcd					gcd
+text/x-perl					pl pm
+text/x-python					py
+text/x-scala					scala
+text/x-setext					etx
+text/x-sfv					sfv
+text/x-sh					sh
+text/x-tcl					tcl tk
+text/x-tex					tex ltx sty cls
+text/x-vcalendar				vcs
+text/xml
+text/xml-dtd
+text/xml-external-parsed-entity
+
+video/1d-interleaved-parityfec
+video/3gpp
+video/3gpp-tt
+video/3gpp2
+video/annodex					axv
+video/AV1
+video/BMPEG
+video/BT656
+video/CelB
+video/DV
+video/dv					dif dv
+video/encaprtp
+video/example
+video/FFV1
+video/flexfec
+video/fli					fli
+video/gl					gl
+video/H261
+video/H263
+video/H263-1998
+video/H263-2000
+video/H264
+video/H264-RCDO
+video/H264-SVC
+video/H265
+video/H266
+video/iso.segment				m4s
+video/JPEG
+video/jpeg2000
+video/jxsv
+video/mj2					mj2 mjp2
+video/MP1S
+video/MP2P
+video/MP2T
+video/mp4					mp4 mpg4 m4v
+video/MP4V-ES
+video/mpeg					mpeg mpg mpe m1v m2v
+video/mpeg4-generic
+video/MPV
+video/nv
+video/ogg					ogv
+video/parityfec
+video/pointer
+video/quicktime					qt mov
+video/raptorfec
+video/raw
+video/rtp-enc-aescm128
+video/rtploopback
+video/rtx
+video/scip
+video/smpte291
+video/SMPTE292M
+video/ulpfec
+video/vc1
+video/vc2
+video/vnd.CCTV
+video/vnd.dece.hd				uvh uvvh
+video/vnd.dece.mobile				uvm uvvm
+video/vnd.dece.mp4				uvu uvvu
+video/vnd.dece.pd				uvp uvvp
+video/vnd.dece.sd				uvs uvvs
+video/vnd.dece.video				uvv uvvv
+video/vnd.directv.mpeg
+video/vnd.directv.mpeg-tts
+video/vnd.dlna.mpeg-tts
+video/vnd.dvb.file				dvb
+video/vnd.fvt					fvt
+video/vnd.hns.video
+video/vnd.iptvforum.1dparityfec-1010
+video/vnd.iptvforum.1dparityfec-2005
+video/vnd.iptvforum.2dparityfec-1010
+video/vnd.iptvforum.2dparityfec-2005
+video/vnd.iptvforum.ttsavc
+video/vnd.iptvforum.ttsmpeg2
+video/vnd.motorola.video
+video/vnd.motorola.videop
+video/vnd.mpegurl				mxu m4u
+video/vnd.ms-playready.media.pyv		pyv
+video/vnd.nokia.interleaved-multimedia		nim
+video/vnd.nokia.mp4vr
+video/vnd.nokia.videovoip
+video/vnd.objectvideo
+video/vnd.radgamettools.bink			bik bk2
+video/vnd.radgamettools.smacker			smk
+video/vnd.sealed.mpeg1				smpg s11
+video/vnd.sealed.mpeg4				s14
+video/vnd.sealed.swf				sswf ssw
+video/vnd.sealedmedia.softseal.mov		smov smo s1q
+video/vnd.uvvu.mp4
+video/vnd.vivo					viv
+video/vnd.youtube.yt				yt
+video/VP8
+video/VP9
+video/webm					webm
+video/x-flv					flv
+video/x-la-asf					lsf lsx
+video/x-matroska				mpv mkv
+video/x-mng					mng
+video/x-ms-wm					wm
+video/x-ms-wmv					wmv
+video/x-ms-wmx					wmx
+video/x-ms-wvx					wvx
+video/x-msvideo					avi
+video/x-sgi-movie				movie
\ No newline at end of file
diff --git a/tests/res/raw/mime_types b/tests/res/raw/mime_types
new file mode 100644
index 000000000..57fa013c2
--- /dev/null
+++ b/tests/res/raw/mime_types
@@ -0,0 +1,846 @@
+###############################################################################
+#
+#  MIME media types and the extensions that represent them.
+#
+#  The format of this file is a media type on the left and zero or more
+#  filename extensions on the right.  Programs using this file will map
+#  files ending with those extensions to the associated type.
+#
+#  This file is part of the "mime-support" package.  Please report a bug using
+#  the "reportbug" command of the "reportbug" package if you would like new
+#  types or extensions to be added.
+#
+#  The reason that all types are managed by the mime-support package instead
+#  allowing individual packages to install types in much the same way as they
+#  add entries in to the mailcap file is so these types can be referenced by
+#  other programs (such as a web server) even if the specific support package
+#  for that type is not installed.
+#
+#  Users can add their own types if they wish by creating a ".mime.types"
+#  file in their home directory.  Definitions included there will take
+#  precedence over those listed here.
+#
+###############################################################################
+
+
+application/activemessage
+application/andrew-inset			ez
+application/annodex				anx
+application/applefile
+application/atom+xml				atom
+application/atomcat+xml				atomcat
+application/atomicmail
+application/atomserv+xml			atomsrv
+application/batch-SMTP
+application/bbolin				lin
+application/beep+xml
+application/cals-1840
+application/commonground
+application/cu-seeme				cu
+application/cybercash
+application/davmount+xml			davmount
+application/dca-rft
+application/dec-dx
+application/dicom				dcm
+application/docbook+xml
+application/dsptype				tsp
+application/dvcs
+application/ecmascript				es
+application/edi-consent
+application/edi-x12
+application/edifact
+application/epub+zip				epub
+application/eshop
+application/font-sfnt				otf ttf
+application/font-tdpfr				pfr
+application/font-woff				woff
+application/futuresplash			spl
+application/ghostview
+application/gzip				gz
+application/hta					hta
+application/http
+application/hyperstudio
+application/iges
+application/index
+application/index.cmd
+application/index.obj
+application/index.response
+application/index.vnd
+application/iotp
+application/ipp
+application/isup
+application/java-archive			jar
+application/java-serialized-object		ser
+application/java-vm				class
+application/javascript				js mjs
+application/json				json
+application/ld+json				jsonld
+application/m3g					m3g
+application/mac-binhex40			hqx
+application/mac-compactpro			cpt
+application/macwriteii
+application/marc
+application/mathematica				nb nbp
+application/mbox				mbox
+application/ms-tnef
+application/msaccess				mdb
+application/msword				doc dot
+application/mxf					mxf
+application/news-message-id
+application/news-transmission
+application/ocsp-request
+application/ocsp-response
+application/octet-stream			bin deploy msu msp
+application/oda					oda
+application/oebps-package+xml			opf
+application/ogg					ogx
+application/onenote				one onetoc2 onetmp onepkg
+application/parityfec
+application/pdf					pdf
+application/pgp-encrypted			pgp
+application/pgp-keys				key
+application/pgp-signature			sig
+application/pics-rules				prf
+application/pkcs10
+application/pkcs7-mime
+application/pkcs7-signature
+application/pkix-cert
+application/pkix-crl
+application/pkixcmp
+application/postscript				ps ai eps epsi epsf eps2 eps3
+application/prs.alvestrand.titrax-sheet
+application/prs.cww
+application/prs.nprend
+application/qsig
+application/rar					rar
+application/rdf+xml				rdf
+application/remote-printing
+application/riscos
+application/rtf					rtf
+application/sdp
+application/set-payment
+application/set-payment-initiation
+application/set-registration
+application/set-registration-initiation
+application/sgml
+application/sgml-open-catalog
+application/sieve
+application/sla					stl
+application/slate
+application/smil+xml				smi smil
+application/timestamp-query
+application/timestamp-reply
+application/vemmi
+application/wasm                                wasm
+application/whoispp-query
+application/whoispp-response
+application/wita
+application/x400-bp
+application/xhtml+xml				xhtml xht
+application/xml					xml xsd
+application/xml-dtd
+application/xml-external-parsed-entity
+application/xslt+xml				xsl xslt
+application/xspf+xml				xspf
+application/zip					zip
+application/vnd.3M.Post-it-Notes
+application/vnd.accpac.simply.aso
+application/vnd.accpac.simply.imp
+application/vnd.acucobol
+application/vnd.aether.imp
+application/vnd.android.package-archive						apk
+application/vnd.anser-web-certificate-issue-initiation
+application/vnd.anser-web-funds-transfer-initiation
+application/vnd.audiograph
+application/vnd.bmi
+application/vnd.businessobjects
+application/vnd.canon-cpdl
+application/vnd.canon-lips
+application/vnd.cinderella							cdy
+application/vnd.claymore
+application/vnd.commerce-battelle
+application/vnd.commonspace
+application/vnd.comsocaller
+application/vnd.contact.cmsg
+application/vnd.cosmocaller
+application/vnd.ctc-posml
+application/vnd.cups-postscript
+application/vnd.cups-raster
+application/vnd.cups-raw
+application/vnd.cybank
+application/vnd.debian.binary-package						deb ddeb udeb
+application/vnd.dna
+application/vnd.dpgraph
+application/vnd.dxr
+application/vnd.ecdis-update
+application/vnd.ecowin.chart
+application/vnd.ecowin.filerequest
+application/vnd.ecowin.fileupdate
+application/vnd.ecowin.series
+application/vnd.ecowin.seriesrequest
+application/vnd.ecowin.seriesupdate
+application/vnd.enliven
+application/vnd.epson.esf
+application/vnd.epson.msf
+application/vnd.epson.quickanime
+application/vnd.epson.salt
+application/vnd.epson.ssf
+application/vnd.ericsson.quickcall
+application/vnd.eudora.data
+application/vnd.fdf
+application/vnd.ffsns
+application/vnd.flographit
+application/vnd.font-fontforge-sfd						sfd
+application/vnd.framemaker
+application/vnd.fsc.weblaunch
+application/vnd.fujitsu.oasys
+application/vnd.fujitsu.oasys2
+application/vnd.fujitsu.oasys3
+application/vnd.fujitsu.oasysgp
+application/vnd.fujitsu.oasysprs
+application/vnd.fujixerox.ddd
+application/vnd.fujixerox.docuworks
+application/vnd.fujixerox.docuworks.binder
+application/vnd.fut-misnet
+application/vnd.google-earth.kml+xml						kml
+application/vnd.google-earth.kmz						kmz
+application/vnd.grafeq
+application/vnd.groove-account
+application/vnd.groove-identity-message
+application/vnd.groove-injector
+application/vnd.groove-tool-message
+application/vnd.groove-tool-template
+application/vnd.groove-vcard
+application/vnd.hhe.lesson-player
+application/vnd.hp-HPGL
+application/vnd.hp-PCL
+application/vnd.hp-PCLXL
+application/vnd.hp-hpid
+application/vnd.hp-hps
+application/vnd.httphone
+application/vnd.hzn-3d-crossword
+application/vnd.ibm.MiniPay
+application/vnd.ibm.afplinedata
+application/vnd.ibm.modcap
+application/vnd.informix-visionary
+application/vnd.intercon.formnet
+application/vnd.intertrust.digibox
+application/vnd.intertrust.nncp
+application/vnd.intu.qbo
+application/vnd.intu.qfx
+application/vnd.irepository.package+xml
+application/vnd.is-xpr
+application/vnd.japannet-directory-service
+application/vnd.japannet-jpnstore-wakeup
+application/vnd.japannet-payment-wakeup
+application/vnd.japannet-registration
+application/vnd.japannet-registration-wakeup
+application/vnd.japannet-setstore-wakeup
+application/vnd.japannet-verification
+application/vnd.japannet-verification-wakeup
+application/vnd.koan
+application/vnd.lotus-1-2-3
+application/vnd.lotus-approach
+application/vnd.lotus-freelance
+application/vnd.lotus-notes
+application/vnd.lotus-organizer
+application/vnd.lotus-screencam
+application/vnd.lotus-wordpro
+application/vnd.mcd
+application/vnd.mediastation.cdkey
+application/vnd.meridian-slingshot
+application/vnd.mif
+application/vnd.minisoft-hp3000-save
+application/vnd.mitsubishi.misty-guard.trustweb
+application/vnd.mobius.daf
+application/vnd.mobius.dis
+application/vnd.mobius.msl
+application/vnd.mobius.plc
+application/vnd.mobius.txf
+application/vnd.motorola.flexsuite
+application/vnd.motorola.flexsuite.adsi
+application/vnd.motorola.flexsuite.fis
+application/vnd.motorola.flexsuite.gotap
+application/vnd.motorola.flexsuite.kmr
+application/vnd.motorola.flexsuite.ttc
+application/vnd.motorola.flexsuite.wem
+application/vnd.mozilla.xul+xml							xul
+application/vnd.ms-artgalry
+application/vnd.ms-asf
+application/vnd.ms-excel							xls xlb xlt
+application/vnd.ms-excel.addin.macroEnabled.12					xlam
+application/vnd.ms-excel.sheet.binary.macroEnabled.12				xlsb
+application/vnd.ms-excel.sheet.macroEnabled.12					xlsm
+application/vnd.ms-excel.template.macroEnabled.12				xltm
+application/vnd.ms-fontobject							eot
+application/vnd.ms-lrm
+application/vnd.ms-officetheme							thmx
+application/vnd.ms-pki.seccat							cat
+#application/vnd.ms-pki.stl							stl
+application/vnd.ms-powerpoint							ppt pps
+application/vnd.ms-powerpoint.addin.macroEnabled.12				ppam
+application/vnd.ms-powerpoint.presentation.macroEnabled.12			pptm
+application/vnd.ms-powerpoint.slide.macroEnabled.12				sldm
+application/vnd.ms-powerpoint.slideshow.macroEnabled.12				ppsm
+application/vnd.ms-powerpoint.template.macroEnabled.12				potm
+application/vnd.ms-project
+application/vnd.ms-tnef
+application/vnd.ms-word.document.macroEnabled.12				docm
+application/vnd.ms-word.template.macroEnabled.12				dotm
+application/vnd.ms-works
+application/vnd.mseq
+application/vnd.msign
+application/vnd.music-niff
+application/vnd.musician
+application/vnd.netfpx
+application/vnd.noblenet-directory
+application/vnd.noblenet-sealer
+application/vnd.noblenet-web
+application/vnd.novadigm.EDM
+application/vnd.novadigm.EDX
+application/vnd.novadigm.EXT
+application/vnd.oasis.opendocument.chart					odc
+application/vnd.oasis.opendocument.database					odb
+application/vnd.oasis.opendocument.formula					odf
+application/vnd.oasis.opendocument.graphics					odg
+application/vnd.oasis.opendocument.graphics-template				otg
+application/vnd.oasis.opendocument.image					odi
+application/vnd.oasis.opendocument.presentation					odp
+application/vnd.oasis.opendocument.presentation-template			otp
+application/vnd.oasis.opendocument.spreadsheet					ods
+application/vnd.oasis.opendocument.spreadsheet-template				ots
+application/vnd.oasis.opendocument.text						odt
+application/vnd.oasis.opendocument.text-master					odm
+application/vnd.oasis.opendocument.text-template				ott
+application/vnd.oasis.opendocument.text-web					oth
+application/vnd.openxmlformats-officedocument.presentationml.presentation	pptx
+application/vnd.openxmlformats-officedocument.presentationml.slide		sldx
+application/vnd.openxmlformats-officedocument.presentationml.slideshow		ppsx
+application/vnd.openxmlformats-officedocument.presentationml.template		potx
+application/vnd.openxmlformats-officedocument.spreadsheetml.sheet		xlsx
+application/vnd.openxmlformats-officedocument.spreadsheetml.template		xltx
+application/vnd.openxmlformats-officedocument.wordprocessingml.document		docx
+application/vnd.openxmlformats-officedocument.wordprocessingml.template		dotx
+application/vnd.osa.netdeploy
+application/vnd.palm
+application/vnd.pg.format
+application/vnd.pg.osasli
+application/vnd.powerbuilder6
+application/vnd.powerbuilder6-s
+application/vnd.powerbuilder7
+application/vnd.powerbuilder7-s
+application/vnd.powerbuilder75
+application/vnd.powerbuilder75-s
+application/vnd.previewsystems.box
+application/vnd.publishare-delta-tree
+application/vnd.pvi.ptid1
+application/vnd.pwg-xhtml-print+xml
+application/vnd.rapid
+application/vnd.rim.cod								cod
+application/vnd.s3sms
+application/vnd.seemail
+application/vnd.shana.informed.formdata
+application/vnd.shana.informed.formtemplate
+application/vnd.shana.informed.interchange
+application/vnd.shana.informed.package
+application/vnd.smaf								mmf
+application/vnd.sss-cod
+application/vnd.sss-dtf
+application/vnd.sss-ntf
+application/vnd.stardivision.calc						sdc
+application/vnd.stardivision.chart						sds
+application/vnd.stardivision.draw						sda
+application/vnd.stardivision.impress						sdd
+application/vnd.stardivision.math						sdf
+application/vnd.stardivision.writer						sdw
+application/vnd.stardivision.writer-global					sgl
+application/vnd.street-stream
+application/vnd.sun.xml.calc							sxc
+application/vnd.sun.xml.calc.template						stc
+application/vnd.sun.xml.draw							sxd
+application/vnd.sun.xml.draw.template						std
+application/vnd.sun.xml.impress							sxi
+application/vnd.sun.xml.impress.template					sti
+application/vnd.sun.xml.math							sxm
+application/vnd.sun.xml.writer							sxw
+application/vnd.sun.xml.writer.global						sxg
+application/vnd.sun.xml.writer.template						stw
+application/vnd.svd
+application/vnd.swiftview-ics
+application/vnd.symbian.install							sis
+application/vnd.tcpdump.pcap							cap pcap
+application/vnd.triscape.mxs
+application/vnd.trueapp
+application/vnd.truedoc
+application/vnd.tve-trigger
+application/vnd.ufdl
+application/vnd.uplanet.alert
+application/vnd.uplanet.alert-wbxml
+application/vnd.uplanet.bearer-choice
+application/vnd.uplanet.bearer-choice-wbxml
+application/vnd.uplanet.cacheop
+application/vnd.uplanet.cacheop-wbxml
+application/vnd.uplanet.channel
+application/vnd.uplanet.channel-wbxml
+application/vnd.uplanet.list
+application/vnd.uplanet.list-wbxml
+application/vnd.uplanet.listcmd
+application/vnd.uplanet.listcmd-wbxml
+application/vnd.uplanet.signal
+application/vnd.vcx
+application/vnd.vectorworks
+application/vnd.vidsoft.vidconference
+application/vnd.visio								vsd vst vsw vss
+application/vnd.vividence.scriptfile
+application/vnd.wap.sic
+application/vnd.wap.slc
+application/vnd.wap.wbxml							wbxml
+application/vnd.wap.wmlc							wmlc
+application/vnd.wap.wmlscriptc							wmlsc
+application/vnd.webturbo
+application/vnd.wordperfect							wpd
+application/vnd.wordperfect5.1							wp5
+application/vnd.wrq-hp3000-labelled
+application/vnd.wt.stf
+application/vnd.xara
+application/vnd.xfdl
+application/vnd.yellowriver-custom-menu
+application/zlib
+application/x-123				wk
+application/x-7z-compressed			7z
+application/x-abiword				abw
+application/x-apple-diskimage			dmg
+application/x-bcpio				bcpio
+application/x-bittorrent			torrent
+application/x-cab				cab
+application/x-cbr				cbr
+application/x-cbz				cbz
+application/x-cdf				cdf cda
+application/x-cdlink				vcd
+application/x-chess-pgn				pgn
+application/x-comsol				mph
+application/x-core
+application/x-cpio				cpio
+application/x-csh				csh
+application/x-debian-package			deb udeb
+application/x-director				dcr dir dxr
+application/x-dms				dms
+application/x-doom				wad
+application/x-dvi				dvi
+application/x-executable
+application/x-font				pfa pfb gsf
+application/x-font-pcf				pcf pcf.Z
+application/x-freemind				mm
+application/x-futuresplash			spl
+application/x-ganttproject			gan
+application/x-gnumeric				gnumeric
+application/x-go-sgf				sgf
+application/x-graphing-calculator		gcf
+application/x-gtar				gtar
+application/x-gtar-compressed			tgz taz
+application/x-hdf				hdf
+#application/x-httpd-eruby			rhtml
+#application/x-httpd-php			phtml pht php
+#application/x-httpd-php-source			phps
+#application/x-httpd-php3			php3
+#application/x-httpd-php3-preprocessed		php3p
+#application/x-httpd-php4			php4
+#application/x-httpd-php5			php5
+application/x-hwp				hwp
+application/x-ica				ica
+application/x-info				info
+application/x-internet-signup			ins isp
+application/x-iphone				iii
+application/x-iso9660-image			iso
+application/x-jam				jam
+application/x-java-applet
+application/x-java-bean
+application/x-java-jnlp-file			jnlp
+application/x-jmol				jmz
+application/x-kchart				chrt
+application/x-kdelnk
+application/x-killustrator			kil
+application/x-koan				skp skd skt skm
+application/x-kpresenter			kpr kpt
+application/x-kspread				ksp
+application/x-kword				kwd kwt
+application/x-latex				latex
+application/x-lha				lha
+application/x-lyx				lyx
+application/x-lzh				lzh
+application/x-lzx				lzx
+application/x-maker				frm maker frame fm fb book fbdoc
+application/x-mif				mif
+application/x-mpegURL				m3u8
+application/x-ms-application			application
+application/x-ms-manifest			manifest
+application/x-ms-wmd				wmd
+application/x-ms-wmz				wmz
+application/x-msdos-program			com exe bat dll
+application/x-msi				msi
+application/x-netcdf				nc
+application/x-ns-proxy-autoconfig		pac
+application/x-nwc				nwc
+application/x-object				o
+application/x-oz-application			oza
+application/x-pkcs7-certreqresp			p7r
+application/x-pkcs7-crl				crl
+application/x-python-code			pyc pyo
+application/x-qgis				qgs shp shx
+application/x-quicktimeplayer			qtl
+application/x-rdp				rdp
+application/x-redhat-package-manager		rpm
+application/x-rss+xml				rss
+application/x-ruby				rb
+application/x-rx
+application/x-scilab				sci sce
+application/x-scilab-xcos			xcos
+application/x-sh				sh
+application/x-shar				shar
+application/x-shellscript
+application/x-shockwave-flash			swf swfl
+application/x-silverlight			scr
+application/x-sql				sql
+application/x-stuffit				sit sitx
+application/x-sv4cpio				sv4cpio
+application/x-sv4crc				sv4crc
+application/x-tar				tar
+application/x-tcl				tcl
+application/x-tex-gf				gf
+application/x-tex-pk				pk
+application/x-texinfo				texinfo texi
+application/x-trash				~ % bak old sik
+application/x-troff				t tr roff
+application/x-troff-man				man
+application/x-troff-me				me
+application/x-troff-ms				ms
+application/x-ustar				ustar
+application/x-videolan
+application/x-wais-source			src
+application/x-wingz				wz
+application/x-x509-ca-cert			crt
+application/x-xcf				xcf
+application/x-xfig				fig
+application/x-xpinstall				xpi
+application/x-xz				xz
+
+audio/32kadpcm
+audio/3gpp
+audio/amr					amr
+audio/amr-wb					awb
+audio/annodex					axa
+audio/basic					au snd
+audio/csound					csd orc sco
+audio/flac					flac
+audio/g.722.1
+audio/l16
+audio/midi					mid midi kar
+audio/mp4a-latm
+audio/mpa-robust
+audio/mpeg					mpga mpega mp2 mp3 m4a
+audio/mpegurl					m3u
+audio/ogg					oga ogg opus spx
+audio/parityfec
+audio/prs.sid					sid
+audio/telephone-event
+audio/tone
+audio/vnd.cisco.nse
+audio/vnd.cns.anp1
+audio/vnd.cns.inf1
+audio/vnd.digital-winds
+audio/vnd.everad.plj
+audio/vnd.lucent.voice
+audio/vnd.nortel.vbk
+audio/vnd.nuera.ecelp4800
+audio/vnd.nuera.ecelp7470
+audio/vnd.nuera.ecelp9600
+audio/vnd.octel.sbc
+audio/vnd.qcelp
+audio/vnd.rhetorex.32kadpcm
+audio/vnd.vmx.cvsd
+audio/x-aiff					aif aiff aifc
+audio/x-gsm					gsm
+audio/x-mpegurl					m3u
+audio/x-ms-wma					wma
+audio/x-ms-wax					wax
+audio/x-pn-realaudio-plugin
+audio/x-pn-realaudio				ra rm ram
+audio/x-realaudio				ra
+audio/x-scpls					pls
+audio/x-sd2					sd2
+audio/x-wav					wav
+
+chemical/x-alchemy				alc
+chemical/x-cache				cac cache
+chemical/x-cache-csf				csf
+chemical/x-cactvs-binary			cbin cascii ctab
+chemical/x-cdx					cdx
+chemical/x-cerius				cer
+chemical/x-chem3d				c3d
+chemical/x-chemdraw				chm
+chemical/x-cif					cif
+chemical/x-cmdf					cmdf
+chemical/x-cml					cml
+chemical/x-compass				cpa
+chemical/x-crossfire				bsd
+chemical/x-csml					csml csm
+chemical/x-ctx					ctx
+chemical/x-cxf					cxf cef
+#chemical/x-daylight-smiles			smi
+chemical/x-embl-dl-nucleotide			emb embl
+chemical/x-galactic-spc				spc
+chemical/x-gamess-input				inp gam gamin
+chemical/x-gaussian-checkpoint			fch fchk
+chemical/x-gaussian-cube			cub
+chemical/x-gaussian-input			gau gjc gjf
+chemical/x-gaussian-log				gal
+chemical/x-gcg8-sequence			gcg
+chemical/x-genbank				gen
+chemical/x-hin					hin
+chemical/x-isostar				istr ist
+chemical/x-jcamp-dx				jdx dx
+chemical/x-kinemage				kin
+chemical/x-macmolecule				mcm
+chemical/x-macromodel-input			mmd mmod
+chemical/x-mdl-molfile				mol
+chemical/x-mdl-rdfile				rd
+chemical/x-mdl-rxnfile				rxn
+chemical/x-mdl-sdfile				sd sdf
+chemical/x-mdl-tgf				tgf
+#chemical/x-mif					mif
+chemical/x-mmcif				mcif
+chemical/x-mol2					mol2
+chemical/x-molconn-Z				b
+chemical/x-mopac-graph				gpt
+chemical/x-mopac-input				mop mopcrt mpc zmt
+chemical/x-mopac-out				moo
+chemical/x-mopac-vib				mvb
+chemical/x-ncbi-asn1				asn
+chemical/x-ncbi-asn1-ascii			prt ent
+chemical/x-ncbi-asn1-binary			val aso
+chemical/x-ncbi-asn1-spec			asn
+chemical/x-pdb					pdb ent
+chemical/x-rosdal				ros
+chemical/x-swissprot				sw
+chemical/x-vamas-iso14976			vms
+chemical/x-vmd					vmd
+chemical/x-xtel					xtel
+chemical/x-xyz					xyz
+
+font/collection					ttc
+font/otf					ttf otf
+font/sfnt					ttf otf
+font/ttf					ttf otf
+font/woff					woff
+font/woff2					woff2
+
+image/cgm
+image/g3fax
+image/gif					gif
+image/ief					ief
+image/jp2					jp2 jpg2
+image/jpeg					jpeg jpg jpe
+image/jpm					jpm
+image/jpx					jpx jpf
+image/naplps
+image/pcx					pcx
+image/png					png
+image/prs.btif
+image/prs.pti
+image/svg+xml					svg svgz
+image/tiff					tiff tif
+image/vnd.cns.inf2
+image/vnd.djvu					djvu djv
+image/vnd.dwg
+image/vnd.dxf
+image/vnd.fastbidsheet
+image/vnd.fpx
+image/vnd.fst
+image/vnd.fujixerox.edmics-mmr
+image/vnd.fujixerox.edmics-rlc
+image/vnd.microsoft.icon			ico
+image/vnd.mix
+image/vnd.net-fpx
+image/vnd.svf
+image/vnd.wap.wbmp				wbmp
+image/vnd.xiff
+image/x-canon-cr2				cr2
+image/x-canon-crw				crw
+image/x-cmu-raster				ras
+image/x-coreldraw				cdr
+image/x-coreldrawpattern			pat
+image/x-coreldrawtemplate			cdt
+image/x-corelphotopaint				cpt
+image/x-epson-erf				erf
+image/x-icon
+image/x-jg					art
+image/x-jng					jng
+image/x-ms-bmp					bmp
+image/x-nikon-nef				nef
+image/x-olympus-orf				orf
+image/x-photoshop				psd
+image/x-portable-anymap				pnm
+image/x-portable-bitmap				pbm
+image/x-portable-graymap			pgm
+image/x-portable-pixmap				ppm
+image/x-rgb					rgb
+image/x-xbitmap					xbm
+image/x-xpixmap					xpm
+image/x-xwindowdump				xwd
+
+inode/chardevice
+inode/blockdevice
+inode/directory-locked
+inode/directory
+inode/fifo
+inode/socket
+
+message/delivery-status
+message/disposition-notification
+message/external-body
+message/http
+message/s-http
+message/news
+message/partial
+message/rfc822					eml
+
+model/iges					igs iges
+model/mesh					msh mesh silo
+model/vnd.dwf
+model/vnd.flatland.3dml
+model/vnd.gdl
+model/vnd.gs-gdl
+model/vnd.gtw
+model/vnd.mts
+model/vnd.vtu
+model/vrml					wrl vrml
+model/x3d+vrml					x3dv
+model/x3d+xml					x3d
+model/x3d+binary				x3db
+
+multipart/alternative
+multipart/appledouble
+multipart/byteranges
+multipart/digest
+multipart/encrypted
+multipart/form-data
+multipart/header-set
+multipart/mixed
+multipart/parallel
+multipart/related
+multipart/report
+multipart/signed
+multipart/voice-message
+
+text/cache-manifest				appcache
+text/calendar					ics icz
+text/css					css
+text/csv					csv
+text/directory
+text/english
+text/enriched
+text/h323					323
+text/html					html htm shtml
+text/iuls					uls
+text/mathml					mml
+text/markdown                                   md markdown
+text/parityfec
+text/plain					asc txt text pot brf srt
+text/prs.lines.tag
+text/rfc822-headers
+text/richtext					rtx
+text/rtf
+text/scriptlet					sct wsc
+text/t140
+text/texmacs					tm
+text/tab-separated-values			tsv
+text/turtle					ttl
+text/uri-list
+text/vcard					vcf vcard
+text/vnd.abc
+text/vnd.curl
+text/vnd.debian.copyright
+text/vnd.DMClientScript
+text/vnd.flatland.3dml
+text/vnd.fly
+text/vnd.fmi.flexstor
+text/vnd.in3d.3dml
+text/vnd.in3d.spot
+text/vnd.IPTC.NewsML
+text/vnd.IPTC.NITF
+text/vnd.latex-z
+text/vnd.motorola.reflex
+text/vnd.ms-mediapackage
+text/vnd.sun.j2me.app-descriptor		jad
+text/vnd.wap.si
+text/vnd.wap.sl
+text/vnd.wap.wml				wml
+text/vnd.wap.wmlscript				wmls
+text/x-bibtex					bib
+text/x-boo					boo
+text/x-c++hdr					h++ hpp hxx hh
+text/x-c++src					c++ cpp cxx cc
+text/x-chdr					h
+text/x-component				htc
+text/x-crontab
+text/x-csh					csh
+text/x-csrc					c
+text/x-dsrc					d
+text/x-diff					diff patch
+text/x-haskell					hs
+text/x-java					java
+text/x-lilypond					ly
+text/x-literate-haskell				lhs
+text/x-makefile
+text/x-moc					moc
+text/x-pascal					p pas
+text/x-pcs-gcd					gcd
+text/x-perl					pl pm
+text/x-python					py
+text/x-scala					scala
+text/x-server-parsed-html
+text/x-setext					etx
+text/x-sfv					sfv
+text/x-sh					sh
+text/x-tcl					tcl tk
+text/x-tex					tex ltx sty cls
+text/x-vcalendar				vcs
+
+video/3gpp					3gp
+video/annodex					axv
+video/dl					dl
+video/dv					dif dv
+video/fli					fli
+video/gl					gl
+video/mpeg					mpeg mpg mpe
+video/MP2T					ts
+video/mp4					mp4
+video/quicktime					qt mov
+video/mp4v-es
+video/ogg					ogv
+video/parityfec
+video/pointer
+video/webm					webm
+video/vnd.fvt
+video/vnd.motorola.video
+video/vnd.motorola.videop
+video/vnd.mpegurl				mxu
+video/vnd.mts
+video/vnd.nokia.interleaved-multimedia
+video/vnd.vivo
+video/x-flv					flv
+video/x-la-asf					lsf lsx
+video/x-mng					mng
+video/x-ms-asf					asf asx
+video/x-ms-wm					wm
+video/x-ms-wmv					wmv
+video/x-ms-wmx					wmx
+video/x-ms-wvx					wvx
+video/x-msvideo					avi
+video/x-sgi-movie				movie
+video/x-matroska				mpv mkv
+
+x-conference/x-cooltalk				ice
+
+x-epoc/x-sisx-app				sisx
+x-world/x-vrml					vrm vrml wrl
\ No newline at end of file
diff --git a/tests/src/com/android/providers/media/GetExternalVolumesBehaviorModificationTest.java b/tests/src/com/android/providers/media/GetExternalVolumesBehaviorModificationTest.java
new file mode 100644
index 000000000..743e00f8a
--- /dev/null
+++ b/tests/src/com/android/providers/media/GetExternalVolumesBehaviorModificationTest.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.providers.media;
+
+import android.compat.testing.PlatformCompatChangeRule;
+import android.content.Context;
+import android.os.Build;
+import android.os.Environment;
+import android.os.Parcel;
+import android.os.UserHandle;
+import android.os.storage.StorageManager;
+import android.os.storage.StorageVolume;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.provider.MediaStore;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.flags.Flags;
+
+import libcore.junit.util.compat.CoreCompatChangeRule.DisableCompatChanges;
+import libcore.junit.util.compat.CoreCompatChangeRule.EnableCompatChanges;
+
+import junit.framework.Assert;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Set;
+
+@RunWith(AndroidJUnit4.class)
+@RequiresFlagsEnabled({Flags.FLAG_EXCLUDE_UNRELIABLE_VOLUMES})
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+public class GetExternalVolumesBehaviorModificationTest {
+    @Rule
+    public TestRule compatChangeRule = new PlatformCompatChangeRule();
+
+    @Rule
+    public final CheckFlagsRule mCheckFlagsRule =
+            DeviceFlagsValueProvider.createCheckFlagsRule();
+
+    @Mock
+    private Context mContext;
+
+    private static final String RELIABLE_STORAGE = "reliable";
+    private static final String UNRELIABLE_STORAGE = "unreliable";
+
+    @Before
+    public void setup() {
+        MockitoAnnotations.initMocks(this);
+
+        // create a testing storage volume which behaves as a reliable storage and hence have a
+        // directory starting with storage/. Naming this volume as reliable.
+        Parcel parcel = Parcel.obtain();
+        parcel.writeString8("1"); // id
+        parcel.writeString8("Storage/emulated/testDir"); // path
+        parcel.writeString8("Storage/emulated/testDir"); // internalPath
+        parcel.writeString8(""); // description
+        parcel.writeInt(0); // removable (boolean)
+        parcel.writeInt(1); // primary (boolean)
+        parcel.writeInt(0); // emulated (boolean)
+        parcel.writeInt(0); // allowMassStorage (boolean)
+        parcel.writeInt(0); // allowFullBackup (boolean)
+        parcel.writeLong(1000); // maxFileSize
+        parcel.writeParcelable(UserHandle.CURRENT, 0); // owner (UserHandle)
+        parcel.writeInt(0); // uuid
+        parcel.writeString8(RELIABLE_STORAGE); // name
+        parcel.writeString8(Environment.MEDIA_MOUNTED); // state
+
+        parcel.setDataPosition(0);
+
+        StorageVolume reliableStorage = StorageVolume.CREATOR.createFromParcel(parcel);
+
+        // create a testing storage volume which behaves as a unreliable storage and hence have a
+        // directory starting with mnt/. Naming this volume as unreliable.
+        Parcel parcel2 = Parcel.obtain();
+        parcel2.writeString8("2"); // id
+        parcel2.writeString8("mnt/testDir"); // path
+        parcel2.writeString8("mnt/testDir"); // internalPath
+        parcel2.writeString8(""); // description
+        parcel2.writeInt(0); // removable (boolean)
+        parcel2.writeInt(1); // primary (boolean)
+        parcel2.writeInt(0); // emulated (boolean)
+        parcel2.writeInt(0); // allowMassStorage (boolean)
+        parcel2.writeInt(0); // allowFullBackup (boolean)
+        parcel2.writeLong(1000); // maxFileSize
+        parcel2.writeParcelable(UserHandle.CURRENT, 0); // owner (UserHandle)
+        parcel2.writeInt(0); // uuid
+        parcel2.writeString8(UNRELIABLE_STORAGE); // name
+        parcel2.writeString8(Environment.MEDIA_MOUNTED); // state
+
+        parcel2.setDataPosition(0);
+
+        StorageVolume unreliableStorage = StorageVolume.CREATOR.createFromParcel(parcel2);
+
+        // Creating a mock storage manager which on being queried for storage volumes return the
+        // list of both reliable and unreliable storage.
+        StorageManager mockedStorageManager = Mockito.mock(StorageManager.class);
+        Mockito.when(mockedStorageManager.getStorageVolumes()).thenReturn(new ArrayList<>(
+                Arrays.asList(reliableStorage, unreliableStorage)));
+
+        // Creating a mock for context so that it returns the mocked storage manager.
+        mContext = Mockito.mock(Context.class);
+        Mockito.when(mContext.getSystemServiceName(StorageManager.class)).thenReturn(
+                Context.STORAGE_SERVICE);
+        Mockito.when(mContext.getApplicationInfo()).thenReturn(
+                InstrumentationRegistry.getInstrumentation().getContext().getApplicationInfo());
+        Mockito.when(mContext.getSystemService(StorageManager.class)).thenReturn(
+                mockedStorageManager);
+    }
+
+    /**
+     * This test verifies the behaviour of MediaStore.getExternalVolumeNames() before enabling the
+     * EXCLUDE_UNRELIABLE_STORAGE_VOLUMES appcompat flag.
+     */
+    @Test
+    @DisableCompatChanges({MediaProvider.EXCLUDE_UNRELIABLE_STORAGE_VOLUMES})
+    public void test_getExternalVolumes_returnsAllVolumes() {
+        Set<String> result = MediaStore.getExternalVolumeNames(mContext);
+
+        // Verify result is not null and both unreliable and reliable storage is returned.
+        Assert.assertNotNull(result);
+        Assert.assertEquals(2, result.size());
+        Assert.assertTrue(result.contains(RELIABLE_STORAGE));
+        Assert.assertTrue(result.contains(UNRELIABLE_STORAGE));
+    }
+
+    /**
+     * This test verifies the behaviour of MediaStore.getExternalVolumeNames() before enabling the
+     * EXCLUDE_UNRELIABLE_STORAGE_VOLUMES appcompat flag.
+     */
+    @Test
+    @EnableCompatChanges({MediaProvider.EXCLUDE_UNRELIABLE_STORAGE_VOLUMES})
+    public void test_getExternalVolumes_returnsFilteredVolumes() {
+        Set<String> result = MediaStore.getExternalVolumeNames(mContext);
+
+        // Verify result is not null and only reliable storage is returned.
+        Assert.assertNotNull(result);
+        Assert.assertEquals(1, result.size());
+        Assert.assertTrue(result.contains(RELIABLE_STORAGE));
+        Assert.assertFalse(result.contains(UNRELIABLE_STORAGE));
+    }
+}
+
diff --git a/tests/src/com/android/providers/media/IsolatedContext.java b/tests/src/com/android/providers/media/IsolatedContext.java
index fa9a103ba..1b0f1f31e 100644
--- a/tests/src/com/android/providers/media/IsolatedContext.java
+++ b/tests/src/com/android/providers/media/IsolatedContext.java
@@ -152,6 +152,11 @@ public class IsolatedContext extends ContextWrapper {
             protected boolean shouldCheckForMaliciousActivity() {
                 return Flags.enableMaliciousAppDetector();
             }
+
+            @Override
+            protected void enforcePermissionCheckForOemMetadataUpdate(){
+
+            }
         };
     }
 
diff --git a/tests/src/com/android/providers/media/MediaProviderForFuseTest.java b/tests/src/com/android/providers/media/MediaProviderForFuseTest.java
index 8cbdb9c7b..ab3c4969f 100644
--- a/tests/src/com/android/providers/media/MediaProviderForFuseTest.java
+++ b/tests/src/com/android/providers/media/MediaProviderForFuseTest.java
@@ -31,6 +31,7 @@ import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.os.Bundle;
 import android.os.Environment;
+import android.os.UserHandle;
 import android.provider.MediaStore;
 import android.system.OsConstants;
 import android.util.Log;
@@ -52,6 +53,7 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.util.Arrays;
+import java.util.Locale;
 
 /**
  * Unit tests for {@link MediaProvider} forFuse methods. {@code CtsScopedStorageHostTest} (and
@@ -205,15 +207,20 @@ public class MediaProviderForFuseTest {
     @Test
     public void testRenameDirectory_WhenParentDirectoryIsHidden() throws Exception {
         // Create parent dir with nomedia file
-        final File parent = new File(sTestDir, "hidden" + System.nanoTime());
-        parent.mkdirs();
-        createNomediaFile(parent);
+        // Choosing the base dir to be a public directory so the file can be created by the test
+        // app context without need of shell or root privilege.
+        File parentDir = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        File dir = new File(parentDir, "hidden" + System.nanoTime());
+        dir.mkdirs();
+        createNomediaFile(dir);
+
         // Create dir in hidden parent dir
-        File file = createSubdirWithOneFile(parent);
+        File file = createSubdirWithOneFile(dir);
         File oldDir = file.getParentFile();
 
         // Rename dir within hidden parent.
-        final File renamedDir = new File(parent, "renamed" + System.nanoTime());
+        final File renamedDir = new File(dir, "renamed" + System.nanoTime());
         Truth.assertThat(sMediaProvider.renameForFuse(
                 oldDir.getPath(), renamedDir.getPath(), sTestUid)).isEqualTo(0);
 
@@ -237,8 +244,14 @@ public class MediaProviderForFuseTest {
             // the process that is, mContext.checkUriPermission and should throw a security
             // exception.
             sMediaProvider.onFileLookupForFuse(
-                    "/storage/emulated/0/.transforms/synthetic/picker/0/com.android.providers"
-                            + ".media.photopicker/media/1000000.jpg", sTestUid /* uid */,
+                    String.format(
+                            Locale.ROOT,
+                    "/storage/emulated/%d/.transforms/synthetic/picker/%d/com.android.providers"
+                            + ".media.photopicker/media/1000000.jpg",
+                            UserHandle.myUserId(),
+                            UserHandle.myUserId()
+                    ),
+                    sTestUid /* uid */,
                     0 /* tid */);
             fail("This test should throw a security exception");
         } catch (SecurityException se) {
@@ -248,7 +261,7 @@ public class MediaProviderForFuseTest {
 
     private @NonNull File createNomediaFile(@NonNull File dir) throws IOException {
         final File nomediaFile = new File(dir, ".nomedia");
-        executeShellCommand("touch " + nomediaFile.getAbsolutePath());
+        nomediaFile.createNewFile();
         Truth.assertWithMessage("cannot create nomedia file: " + nomediaFile.getAbsolutePath())
                 .that(nomediaFile.exists())
                 .isTrue();
diff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java
index 1a213eefa..21cb56e48 100644
--- a/tests/src/com/android/providers/media/MediaProviderTest.java
+++ b/tests/src/com/android/providers/media/MediaProviderTest.java
@@ -20,6 +20,7 @@ import static android.content.ContentResolver.QUERY_ARG_SQL_GROUP_BY;
 import static android.content.ContentResolver.QUERY_ARG_SQL_HAVING;
 import static android.provider.MediaStore.getGeneration;
 
+import static com.android.providers.media.DatabaseHelper.EXTERNAL_DATABASE_NAME;
 import static com.android.providers.media.scan.MediaScannerTest.stage;
 import static com.android.providers.media.util.FileUtils.extractDisplayName;
 import static com.android.providers.media.util.FileUtils.extractRelativePath;
@@ -48,6 +49,7 @@ import android.content.ContentUris;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.content.pm.ProviderInfo;
 import android.content.res.AssetFileDescriptor;
@@ -61,7 +63,11 @@ import android.os.Environment;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
-import android.platform.test.annotations.EnableFlags;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.preference.PreferenceManager;
 import android.provider.MediaStore;
 import android.provider.MediaStore.Audio.AudioColumns;
 import android.provider.MediaStore.Files.FileColumns;
@@ -92,12 +98,12 @@ import com.android.providers.media.util.FileUtilsTest;
 import com.android.providers.media.util.SQLiteQueryBuilder;
 import com.android.providers.media.util.UserCache;
 
-import org.junit.AfterClass;
+import org.junit.After;
 import org.junit.Assert;
 import org.junit.Assume;
 import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
@@ -113,10 +119,15 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
+import java.util.Optional;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 @RunWith(AndroidJUnit4.class)
 public class MediaProviderTest {
+    @Rule
+    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+
     static final String TAG = "MediaProviderTest";
 
     // The test app without permissions
@@ -128,8 +139,8 @@ public class MediaProviderTest {
     private static Context sContext;
     private static ContentResolver sIsolatedResolver;
 
-    @BeforeClass
-    public static void setUpBeforeClass() {
+    @Before
+    public void setUp() {
         InstrumentationRegistry.getInstrumentation().getUiAutomation()
                 .adoptShellPermissionIdentity(Manifest.permission.LOG_COMPAT_CHANGE,
                         Manifest.permission.READ_COMPAT_CHANGE_CONFIG,
@@ -140,15 +151,11 @@ public class MediaProviderTest {
                         // MANAGE_USERS permission for MediaProvider module.
                         Manifest.permission.CREATE_USERS,
                         Manifest.permission.INTERACT_ACROSS_USERS);
-    }
-
-    @Before
-    public void setUp() {
         resetIsolatedContext();
     }
 
-    @AfterClass
-    public static void tearDown() {
+    @After
+    public void tearDown() {
         InstrumentationRegistry.getInstrumentation()
                 .getUiAutomation().dropShellPermissionIdentity();
     }
@@ -657,13 +664,19 @@ public class MediaProviderTest {
                 values);
 
         final ContentValues newValues = new ContentValues();
-        newValues.put(MediaStore.MediaColumns.DATA, "/storage/emulated/0/../../../data/media/");
+        newValues.put(
+                MediaStore.MediaColumns.DATA,
+                String.format(Locale.ROOT,
+                        "/storage/emulated/%d/../../../data/media/",
+                        UserHandle.myUserId()));
         IllegalArgumentException illegalArgumentException = Assert.assertThrows(
                 IllegalArgumentException.class,
                 () -> sIsolatedResolver.update(uri, newValues, null));
 
         assertThat(illegalArgumentException).hasMessageThat().contains(
-                "Requested path /data/media doesn't appear under [/storage/emulated/0]");
+                String.format(Locale.ROOT,
+                        "Requested path /data/media doesn't appear under [/storage/emulated/%d]",
+                        UserHandle.myUserId()));
     }
 
     /**
@@ -910,6 +923,276 @@ public class MediaProviderTest {
                 buildFile(uri, null, "", ""));
     }
 
+    private void setSharedPreference(String preference, int value) {
+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
+                sIsolatedContext);
+        SharedPreferences.Editor editor = prefs.edit();
+        editor.putInt(preference, value);
+        editor.commit();
+    }
+
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EXCLUSION_LIST_FOR_DEFAULT_FOLDERS)
+    public void testEnsureDefaultFolders_EmptyExclusionList() throws Exception {
+        // Put the fake "default" folders in Documents as they can easily be created and
+        // deleted here.
+        String[] defaultFolderList =
+                new String[]{"Documents/A", "Documents/B", "Documents/C", "Documents/D"};
+        final MediaProvider provider = new MediaProvider() {
+            @Override
+            protected String[] getDefaultFolderNames() {
+                return defaultFolderList;
+            }
+
+            @Override
+            protected List<String> getFoldersToSkipInDefaultCreation() {
+                // Set an empty exclusion list.
+                return Arrays.asList();
+            }
+
+            @Override
+            protected void storageNativeBootPropertyChangeListener() {
+                // Ignore this as test app cannot read device config
+            }
+        };
+
+        // Get the external primary volume.
+        final ProviderInfo info = sIsolatedContext.getPackageManager()
+                .resolveContentProvider(MediaStore.AUTHORITY, PackageManager.GET_META_DATA);
+        provider.attachInfo(sIsolatedContext, info);
+        MediaVolume externalPrimary = provider.getVolume(MediaStore.VOLUME_EXTERNAL_PRIMARY);
+
+        // Set this preference to ensure that the default folders are actually created.
+        setSharedPreference("created_default_folders_" + externalPrimary.getId(), 0);
+
+        // Make sure none of the folders exist already.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            if (folder.exists()) {
+                assertTrue(folder.delete());
+            }
+        }
+
+        // Create the default folders for the external primary volume.
+        Optional<DatabaseHelper> maybeDatabaseHelper = provider.getDatabaseHelper(
+                EXTERNAL_DATABASE_NAME);
+        assertTrue(maybeDatabaseHelper.isPresent());
+        provider.ensureDefaultFolders(externalPrimary,
+                maybeDatabaseHelper.get().getWritableDatabaseForTest());
+
+        // Make sure all of the folders were created.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            try {
+                assertTrue(folder.exists());
+            } finally {
+                // Clean up.
+                folder.delete();
+            }
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EXCLUSION_LIST_FOR_DEFAULT_FOLDERS)
+    public void testEnsureDefaultFolders_WithInvalidExclusionList() throws Exception {
+        // Put the fake "default" folders in Documents as they can easily be created and
+        // deleted here.
+        String[] defaultFolderList =
+                new String[]{"Documents/FolderA", "Documents/FolderB", "Documents/FolderC",
+                        "Documents/FolderD"};
+        // The exclusion list contains more items than there are on the default list. It should
+        // be ignored.
+        List<String> exclusionList = Arrays.asList("Documents/FolderA", "Documents/FolderB",
+                "Documents/FolderC",
+                "Documents/FolderD", "Documents/FolderE");
+        final MediaProvider provider = new MediaProvider() {
+            @Override
+            protected String[] getDefaultFolderNames() {
+                return defaultFolderList;
+            }
+
+            @Override
+            protected List<String> getFoldersToSkipInDefaultCreation() {
+                return exclusionList;
+            }
+
+            @Override
+            protected void storageNativeBootPropertyChangeListener() {
+                // Ignore this as test app cannot read device config
+            }
+        };
+
+        // Get the external primary volume.
+        final ProviderInfo info = sIsolatedContext.getPackageManager()
+                .resolveContentProvider(MediaStore.AUTHORITY, PackageManager.GET_META_DATA);
+        provider.attachInfo(sIsolatedContext, info);
+        MediaVolume externalPrimary = provider.getVolume(MediaStore.VOLUME_EXTERNAL_PRIMARY);
+
+        // Set this preference to ensure that the default folders are actually created.
+        setSharedPreference("created_default_folders_" + externalPrimary.getId(), 0);
+
+        // Make sure none of the folders exist already.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            if (folder.exists()) {
+                assertTrue(folder.delete());
+            }
+        }
+
+        // Create the default folders for the external primary volume.
+        Optional<DatabaseHelper> maybeDatabaseHelper = provider.getDatabaseHelper(
+                EXTERNAL_DATABASE_NAME);
+        assertTrue(maybeDatabaseHelper.isPresent());
+        provider.ensureDefaultFolders(externalPrimary,
+                maybeDatabaseHelper.get().getWritableDatabaseForTest());
+
+        // Make sure all of the folders were created.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            try {
+                assertTrue(folder.exists());
+            } finally {
+                // Clean up.
+                folder.delete();
+            }
+        }
+    }
+
+    @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_EXCLUSION_LIST_FOR_DEFAULT_FOLDERS)
+    public void testEnsureDefaultFolders_FlagDisabled() throws Exception {
+        // Put the fake "default" folders in Documents as they can easily be created and
+        // deleted here.
+        String[] defaultFolderList =
+                new String[]{"Documents/FolderA", "Documents/FolderB", "Documents/FolderC",
+                        "Documents/FolderD"};
+        List<String> exclusionList = Arrays.asList("Documents/FolderA", "Documents/FolderC");
+        final MediaProvider provider = new MediaProvider() {
+            @Override
+            protected String[] getDefaultFolderNames() {
+                return defaultFolderList;
+            }
+
+            @Override
+            protected List<String> getFoldersToSkipInDefaultCreation() {
+                // This should be ignored as the flag is disabled.
+                return exclusionList;
+            }
+
+            @Override
+            protected void storageNativeBootPropertyChangeListener() {
+                // Ignore this as test app cannot read device config
+            }
+        };
+
+        // Get the external primary volume.
+        final ProviderInfo info = sIsolatedContext.getPackageManager()
+                .resolveContentProvider(MediaStore.AUTHORITY, PackageManager.GET_META_DATA);
+        provider.attachInfo(sIsolatedContext, info);
+        MediaVolume externalPrimary = provider.getVolume(MediaStore.VOLUME_EXTERNAL_PRIMARY);
+
+        // Set this preference to ensure that the default folders are actually created.
+        setSharedPreference("created_default_folders_" + externalPrimary.getId(), 0);
+
+        // Make sure none of the folders exist already.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            if (folder.exists()) {
+                assertTrue(folder.delete());
+            }
+        }
+
+        // Create the default folders for the external primary volume.
+        Optional<DatabaseHelper> maybeDatabaseHelper = provider.getDatabaseHelper(
+                EXTERNAL_DATABASE_NAME);
+        assertTrue(maybeDatabaseHelper.isPresent());
+        provider.ensureDefaultFolders(externalPrimary,
+                maybeDatabaseHelper.get().getWritableDatabaseForTest());
+
+        // Make sure all of the folders were created.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            try {
+                assertTrue(folder.exists());
+            } finally {
+                // Clean up.
+                folder.delete();
+            }
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EXCLUSION_LIST_FOR_DEFAULT_FOLDERS)
+    public void testEnsureDefaultFolders_WithExclusionList() throws Exception {
+        // Put the fake "default" folders in Documents as they can easily be created and
+        // deleted here.
+        String[] defaultFolderList =
+                new String[]{"Documents/FolderA", "Documents/FolderB", "Documents/FolderC",
+                        "Documents/FolderD"};
+        // The exclusion list is case insensitive.
+        List<String> exclusionList = Arrays.asList("Documents/foldera", "Documents/FOLDERC");
+        final MediaProvider provider = new MediaProvider() {
+            @Override
+            protected String[] getDefaultFolderNames() {
+                return defaultFolderList;
+            }
+
+            @Override
+            protected List<String> getFoldersToSkipInDefaultCreation() {
+                return exclusionList;
+            }
+
+            @Override
+            protected void storageNativeBootPropertyChangeListener() {
+                // Ignore this as test app cannot read device config
+            }
+        };
+
+        // Get the external primary volume.
+        final ProviderInfo info = sIsolatedContext.getPackageManager()
+                .resolveContentProvider(MediaStore.AUTHORITY, PackageManager.GET_META_DATA);
+        provider.attachInfo(sIsolatedContext, info);
+        MediaVolume externalPrimary = provider.getVolume(MediaStore.VOLUME_EXTERNAL_PRIMARY);
+
+        // Set this preference to ensure that the default folders are actually created.
+        setSharedPreference("created_default_folders_" + externalPrimary.getId(), 0);
+
+        // Make sure none of the folders exist already.
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            if (folder.exists()) {
+                assertTrue(folder.delete());
+            }
+        }
+
+        // Create the default folders for the external primary volume.
+        Optional<DatabaseHelper> maybeDatabaseHelper = provider.getDatabaseHelper(
+                EXTERNAL_DATABASE_NAME);
+        assertTrue(maybeDatabaseHelper.isPresent());
+        provider.ensureDefaultFolders(externalPrimary,
+                maybeDatabaseHelper.get().getWritableDatabaseForTest());
+
+        // Make sure that the folders on exclusion list were not created.
+        List<String> exclusionListCaseInsensitive = exclusionList.stream().map(
+                String::toLowerCase).collect(
+                Collectors.toList());
+        for (String folderName : defaultFolderList) {
+            final File folder = new File(externalPrimary.getPath(), folderName);
+            try {
+                if (exclusionListCaseInsensitive.contains(
+                        folderName.toLowerCase(Locale.ROOT))) {
+                    assertFalse(folder.exists());
+                } else {
+                    assertTrue(folder.exists());
+                }
+            } finally {
+                // Clean up.
+                folder.delete();
+            }
+        }
+    }
+
     @Test
     public void testEnsureFileColumns_InvalidMimeType_targetSdkQ() throws Exception {
         final MediaProvider provider = new MediaProvider() {
@@ -1036,7 +1319,10 @@ public class MediaProviderTest {
         final Uri uri = MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);
         final ContentValues reverse = new ContentValues();
         reverse.put(MediaColumns.DATA,
-                "/storage/emulated/0/DCIM/My Vacation/.pending-1577836800-IMG1024.JPG");
+                String.format(
+                        Locale.ROOT,
+                        "/storage/emulated/%d/DCIM/My Vacation/.pending-1577836800-IMG1024.JPG",
+                        UserHandle.myUserId()));
         ensureFileColumns(uri, reverse);
 
         assertEquals("DCIM/My Vacation/", reverse.getAsString(MediaColumns.RELATIVE_PATH));
@@ -1084,7 +1370,10 @@ public class MediaProviderTest {
         final Uri uri = MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);
         final ContentValues reverse = new ContentValues();
         reverse.put(MediaColumns.DATA,
-                "/storage/emulated/0/DCIM/My Vacation/.trashed-1577836800-IMG1024.JPG");
+                String.format(
+                        Locale.ROOT,
+                        "/storage/emulated/%d/DCIM/My Vacation/.trashed-1577836800-IMG1024.JPG",
+                        UserHandle.myUserId()));
         ensureFileColumns(uri, reverse);
 
         assertEquals("DCIM/My Vacation/", reverse.getAsString(MediaColumns.RELATIVE_PATH));
@@ -1950,7 +2239,7 @@ public class MediaProviderTest {
     }
 
     @Test
-    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    @RequiresFlagsEnabled(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
     public void testQueryingMediaGeolocationDataInProjectionShouldReturnNull() throws Exception {
         // Check with both upper and lower case column names
         String[][] projections = new String[][] {
@@ -2002,7 +2291,7 @@ public class MediaProviderTest {
     }
 
     @Test
-    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    @RequiresFlagsEnabled(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
     public void testQueryingMediaGeolocationDataInSelectionShouldReturnEmptyCursor()
             throws Exception {
         final File downloads = new File(Environment.getExternalStorageDirectory(),
@@ -2030,7 +2319,7 @@ public class MediaProviderTest {
     }
 
     @Test
-    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    @RequiresFlagsEnabled(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
     public void testQueryingMediaGeolocationDataInOrderByShouldReturnNonEmptyCursor()
             throws Exception {
         String testFileName = "test";
@@ -2061,7 +2350,7 @@ public class MediaProviderTest {
     }
 
     @Test
-    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    @RequiresFlagsEnabled(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
     public void testQueryingMediaGeolocationDataInGroupByAndHavingShouldReturnEmptyCursor()
             throws Exception {
         String testFileName = "test";
diff --git a/tests/src/com/android/providers/media/PermissionActivityTest.java b/tests/src/com/android/providers/media/PermissionActivityTest.java
index 1e8b1cd10..984c9c2ca 100644
--- a/tests/src/com/android/providers/media/PermissionActivityTest.java
+++ b/tests/src/com/android/providers/media/PermissionActivityTest.java
@@ -529,13 +529,16 @@ public class PermissionActivityTest {
                     /* attributionTag= */ null);
         } else if (TextUtils.equals(op, OP_READ_MEDIA_IMAGES)) {
             return expected == checkPermissionReadImages(
-                context, pid, uid, packageName, /* attributionTag= */ null, /* isAtleastT */ true);
+                context, pid, uid, packageName, /* attributionTag= */ null, /* isAtleastT */ true,
+                    /* forDataDelivery */ true);
         } else if (TextUtils.equals(op, OP_READ_MEDIA_AUDIO)) {
             return expected == checkPermissionReadAudio(
-                context, pid, uid, packageName, /* attributionTag= */ null, /* isAtleastT */ true);
+                context, pid, uid, packageName, /* attributionTag= */ null, /* isAtleastT */ true,
+                    /* forDataDelivery */ true);
         } else if (TextUtils.equals(op, OP_READ_MEDIA_VIDEO)) {
             return expected == checkPermissionReadVideo(
-                context, pid, uid, packageName, /* attributionTag= */ null, /* isAtleastT */ true);
+                context, pid, uid, packageName, /* attributionTag= */ null, /* isAtleastT */ true,
+                    /* forDataDelivery */ true);
         } else if (TextUtils.equals(op, OP_MANAGE_EXTERNAL_STORAGE)) {
             return expected == checkPermissionManager(context, pid, uid, packageName,
                     /* attributionTag= */ null);
diff --git a/tests/src/com/android/providers/media/PickerUriResolverTest.java b/tests/src/com/android/providers/media/PickerUriResolverTest.java
index e571cefb4..c0504d0de 100644
--- a/tests/src/com/android/providers/media/PickerUriResolverTest.java
+++ b/tests/src/com/android/providers/media/PickerUriResolverTest.java
@@ -80,6 +80,7 @@ import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 
 @RunWith(AndroidJUnit4.class)
 public class PickerUriResolverTest {
@@ -285,8 +286,11 @@ public class PickerUriResolverTest {
     @Test
     public void testOpenPickerTranscodedFile() throws Exception {
         final Uri transcodedUri = Uri.parse(
-                "content://media/picker_transcoded/0/com.android.providers.media"
-                        + ".photopicker/media/" + TEST_ID);
+                  String.format(
+                    Locale.ROOT,
+                    "content://media/picker_transcoded/%d/com.android.providers.media"
+                        + ".photopicker/media/",
+                    UserHandle.myUserId()) + TEST_ID);
         updateReadUriPermission(transcodedUri, /* grant */ true);
 
         // Act & Assert.
diff --git a/tests/src/com/android/providers/media/backupandrestore/BackupAndRestoreTestUtils.java b/tests/src/com/android/providers/media/backupandrestore/BackupAndRestoreTestUtils.java
new file mode 100644
index 000000000..228be1b40
--- /dev/null
+++ b/tests/src/com/android/providers/media/backupandrestore/BackupAndRestoreTestUtils.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.backupandrestore;
+
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.FIELD_SEPARATOR;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.KEY_VALUE_SEPARATOR;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.RESTORE_COMPLETED;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.SHARED_PREFERENCE_NAME;
+
+import android.content.Context;
+import android.provider.MediaStore;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class BackupAndRestoreTestUtils {
+
+    /**
+     * Map used to store column name for given key id.
+     */
+    private static Map<String, String> sColumnIdToKeyMap;
+
+    /**
+     * Map used to store key id for given column name.
+     */
+    private static Map<String, String> sColumnNameToIdMap;
+
+    static void createKeyToColumnNameMap() {
+        sColumnIdToKeyMap = new HashMap<>();
+        sColumnIdToKeyMap.put("0", MediaStore.Files.FileColumns.IS_FAVORITE);
+        sColumnIdToKeyMap.put("1", MediaStore.Files.FileColumns.MEDIA_TYPE);
+        sColumnIdToKeyMap.put("2", MediaStore.Files.FileColumns.MIME_TYPE);
+        sColumnIdToKeyMap.put("3", MediaStore.Files.FileColumns._USER_ID);
+        sColumnIdToKeyMap.put("4", MediaStore.Files.FileColumns.SIZE);
+        sColumnIdToKeyMap.put("5", MediaStore.MediaColumns.DATE_TAKEN);
+        sColumnIdToKeyMap.put("6", MediaStore.MediaColumns.CD_TRACK_NUMBER);
+        sColumnIdToKeyMap.put("7", MediaStore.MediaColumns.ALBUM);
+        sColumnIdToKeyMap.put("8", MediaStore.MediaColumns.ARTIST);
+        sColumnIdToKeyMap.put("9", MediaStore.MediaColumns.AUTHOR);
+        sColumnIdToKeyMap.put("10", MediaStore.MediaColumns.COMPOSER);
+        sColumnIdToKeyMap.put("11", MediaStore.MediaColumns.GENRE);
+        sColumnIdToKeyMap.put("12", MediaStore.MediaColumns.TITLE);
+        sColumnIdToKeyMap.put("13", MediaStore.MediaColumns.YEAR);
+        sColumnIdToKeyMap.put("14", MediaStore.MediaColumns.DURATION);
+        sColumnIdToKeyMap.put("15", MediaStore.MediaColumns.NUM_TRACKS);
+        sColumnIdToKeyMap.put("16", MediaStore.MediaColumns.WRITER);
+        sColumnIdToKeyMap.put("17", MediaStore.MediaColumns.ALBUM_ARTIST);
+        sColumnIdToKeyMap.put("18", MediaStore.MediaColumns.DISC_NUMBER);
+        sColumnIdToKeyMap.put("19", MediaStore.MediaColumns.COMPILATION);
+        sColumnIdToKeyMap.put("20", MediaStore.MediaColumns.BITRATE);
+        sColumnIdToKeyMap.put("21", MediaStore.MediaColumns.CAPTURE_FRAMERATE);
+        sColumnIdToKeyMap.put("22", MediaStore.Audio.AudioColumns.TRACK);
+        sColumnIdToKeyMap.put("23", MediaStore.MediaColumns.DOCUMENT_ID);
+        sColumnIdToKeyMap.put("24", MediaStore.MediaColumns.INSTANCE_ID);
+        sColumnIdToKeyMap.put("25", MediaStore.MediaColumns.ORIGINAL_DOCUMENT_ID);
+        sColumnIdToKeyMap.put("26", MediaStore.MediaColumns.RESOLUTION);
+        sColumnIdToKeyMap.put("27", MediaStore.MediaColumns.ORIENTATION);
+        sColumnIdToKeyMap.put("28", MediaStore.Video.VideoColumns.COLOR_STANDARD);
+        sColumnIdToKeyMap.put("29", MediaStore.Video.VideoColumns.COLOR_TRANSFER);
+        sColumnIdToKeyMap.put("30", MediaStore.Video.VideoColumns.COLOR_RANGE);
+        sColumnIdToKeyMap.put("31", MediaStore.Files.FileColumns._VIDEO_CODEC_TYPE);
+        sColumnIdToKeyMap.put("32", MediaStore.MediaColumns.WIDTH);
+        sColumnIdToKeyMap.put("33", MediaStore.MediaColumns.HEIGHT);
+        sColumnIdToKeyMap.put("34", MediaStore.Images.ImageColumns.DESCRIPTION);
+        sColumnIdToKeyMap.put("35", MediaStore.Images.ImageColumns.EXPOSURE_TIME);
+        sColumnIdToKeyMap.put("36", MediaStore.Images.ImageColumns.F_NUMBER);
+        sColumnIdToKeyMap.put("37", MediaStore.Images.ImageColumns.ISO);
+        sColumnIdToKeyMap.put("38", MediaStore.Images.ImageColumns.SCENE_CAPTURE_TYPE);
+        sColumnIdToKeyMap.put("39", MediaStore.Files.FileColumns._SPECIAL_FORMAT);
+        sColumnIdToKeyMap.put("40", MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME);
+        // Adding number gap to allow addition of new values
+        sColumnIdToKeyMap.put("80", MediaStore.MediaColumns.XMP);
+    }
+
+    static void createColumnNameToKeyMap() {
+        sColumnNameToIdMap = new HashMap<>();
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.IS_FAVORITE, "0");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.MEDIA_TYPE, "1");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.MIME_TYPE, "2");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns._USER_ID, "3");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.SIZE, "4");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.DATE_TAKEN, "5");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.CD_TRACK_NUMBER, "6");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.ALBUM, "7");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.ARTIST, "8");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.AUTHOR, "9");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.COMPOSER, "10");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.GENRE, "11");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.TITLE, "12");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.YEAR, "13");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.DURATION, "14");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.NUM_TRACKS, "15");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.WRITER, "16");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.ALBUM_ARTIST, "17");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.DISC_NUMBER, "18");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.COMPILATION, "19");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.BITRATE, "20");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.CAPTURE_FRAMERATE, "21");
+        sColumnNameToIdMap.put(MediaStore.Audio.AudioColumns.TRACK, "22");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.DOCUMENT_ID, "23");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.INSTANCE_ID, "24");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.ORIGINAL_DOCUMENT_ID, "25");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.RESOLUTION, "26");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.ORIENTATION, "27");
+        sColumnNameToIdMap.put(MediaStore.Video.VideoColumns.COLOR_STANDARD, "28");
+        sColumnNameToIdMap.put(MediaStore.Video.VideoColumns.COLOR_TRANSFER, "29");
+        sColumnNameToIdMap.put(MediaStore.Video.VideoColumns.COLOR_RANGE, "30");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns._VIDEO_CODEC_TYPE, "31");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.WIDTH, "32");
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.HEIGHT, "33");
+        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.DESCRIPTION, "34");
+        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.EXPOSURE_TIME, "35");
+        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.F_NUMBER, "36");
+        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.ISO, "37");
+        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.SCENE_CAPTURE_TYPE, "38");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns._SPECIAL_FORMAT, "39");
+        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME, "40");
+        // Adding number gap to allow addition of new values
+        sColumnNameToIdMap.put(MediaStore.MediaColumns.XMP, "80");
+    }
+
+    static Map<String, String> deSerialiseValueString(String valueString) {
+        if (sColumnIdToKeyMap == null) {
+            createKeyToColumnNameMap();
+        }
+
+        String[] values = valueString.split(":::");
+        Map<String, String> map = new HashMap<>();
+        for (String value : values) {
+            if (value == null || value.isEmpty()) {
+                continue;
+            }
+
+            String[] keyValue = value.split("=", 2);
+            map.put(sColumnIdToKeyMap.get(keyValue[0]), keyValue[1]);
+        }
+
+        return map;
+    }
+
+    static String createSerialisedValue(Map<String, String> entries) {
+        if (sColumnNameToIdMap == null) {
+            createColumnNameToKeyMap();
+        }
+
+        StringBuilder sb = new StringBuilder();
+        for (String backupColumn : sColumnNameToIdMap.keySet()) {
+            if (entries.containsKey(backupColumn)) {
+                sb.append(sColumnNameToIdMap.get(backupColumn)).append(KEY_VALUE_SEPARATOR).append(
+                        entries.get(backupColumn));
+                sb.append(FIELD_SEPARATOR);
+            }
+        }
+        return sb.toString();
+    }
+
+    static boolean getSharedPreferenceValue(Context context) {
+        return context.getSharedPreferences(SHARED_PREFERENCE_NAME,
+                Context.MODE_PRIVATE).getBoolean(RESTORE_COMPLETED, false);
+    }
+}
diff --git a/tests/src/com/android/providers/media/backupandrestore/BackupExecutorTest.java b/tests/src/com/android/providers/media/backupandrestore/BackupExecutorTest.java
index d464dffc3..83a132c62 100644
--- a/tests/src/com/android/providers/media/backupandrestore/BackupExecutorTest.java
+++ b/tests/src/com/android/providers/media/backupandrestore/BackupExecutorTest.java
@@ -16,13 +16,17 @@
 
 package com.android.providers.media.backupandrestore;
 
+import static com.android.providers.media.backupandrestore.BackupAndRestoreTestUtils.deSerialiseValueString;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.BACKUP_COLUMNS;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isBackupAndRestoreSupported;
 import static com.android.providers.media.scan.MediaScanner.REASON_UNKNOWN;
 import static com.android.providers.media.scan.MediaScannerTest.stage;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import static org.junit.Assume.assumeTrue;
+
 import android.Manifest;
 import android.content.ContentResolver;
 import android.content.Context;
@@ -31,9 +35,8 @@ import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
 import android.os.SystemClock;
-import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
 import android.provider.MediaStore;
 
 import androidx.test.InstrumentationRegistry;
@@ -51,7 +54,6 @@ import com.android.providers.media.util.FileUtils;
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -68,17 +70,12 @@ import java.util.Optional;
 import java.util.Set;
 
 @RunWith(AndroidJUnit4.class)
-@RequiresFlagsEnabled(com.android.providers.media.flags.Flags.FLAG_ENABLE_BACKUP_AND_RESTORE)
+@EnableFlags(com.android.providers.media.flags.Flags.FLAG_ENABLE_BACKUP_AND_RESTORE)
 @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
 public final class BackupExecutorTest {
 
     @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
-
-    /**
-     * Map used to store key id for given column and vice versa.
-     */
-    private static Map<String, String> sColumnIdToKeyMap;
+    public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
 
     private Set<File> mStagedFiles = new HashSet<>();
 
@@ -90,11 +87,6 @@ public final class BackupExecutorTest {
 
     private File mDownloadsDir;
 
-    @BeforeClass
-    public static void setupBeforeClass() {
-        createColumnToKeyMap();
-    }
-
     private String mLevelDbPath;
 
     @Before
@@ -113,7 +105,7 @@ public final class BackupExecutorTest {
         mDownloadsDir = new File(Environment.getExternalStorageDirectory(),
                 Environment.DIRECTORY_DOWNLOADS);
         mLevelDbPath =
-                mIsolatedContext.getFilesDir().getAbsolutePath() + "/backup/external_primary/";
+                mIsolatedContext.getFilesDir().getAbsolutePath() + "/backup/external_primary";
         FileUtils.deleteContents(mDownloadsDir);
     }
 
@@ -131,6 +123,7 @@ public final class BackupExecutorTest {
 
     @Test
     public void testBackup() throws Exception {
+        assumeTrue(isBackupAndRestoreSupported(mIsolatedContext));
         try {
             // Add all files in Downloads directory
             File file = new File(mDownloadsDir, "a_" + SystemClock.elapsedRealtimeNanos() + ".jpg");
@@ -216,71 +209,9 @@ public final class BackupExecutorTest {
         }
     }
 
-    static Map<String, String> deSerialiseValueString(String valueString) {
-        String[] values = valueString.split(":::");
-        Map<String, String> map = new HashMap<>();
-        for (String value : values) {
-            if (value == null || value.isEmpty()) {
-                continue;
-            }
-
-            String[] keyValue = value.split("=", 2);
-            map.put(sColumnIdToKeyMap.get(keyValue[0]), keyValue[1]);
-        }
-
-        return map;
-    }
-
     private void stageNewFile(int resId, File file) throws IOException {
         file.createNewFile();
         mStagedFiles.add(file);
         stage(resId, file);
     }
-
-    static void createColumnToKeyMap() {
-        sColumnIdToKeyMap = new HashMap<>();
-        sColumnIdToKeyMap.put("0", MediaStore.Files.FileColumns.IS_FAVORITE);
-        sColumnIdToKeyMap.put("1", MediaStore.Files.FileColumns.MEDIA_TYPE);
-        sColumnIdToKeyMap.put("2", MediaStore.Files.FileColumns.MIME_TYPE);
-        sColumnIdToKeyMap.put("3", MediaStore.Files.FileColumns._USER_ID);
-        sColumnIdToKeyMap.put("4", MediaStore.Files.FileColumns.SIZE);
-        sColumnIdToKeyMap.put("5", MediaStore.MediaColumns.DATE_TAKEN);
-        sColumnIdToKeyMap.put("6", MediaStore.MediaColumns.CD_TRACK_NUMBER);
-        sColumnIdToKeyMap.put("7", MediaStore.MediaColumns.ALBUM);
-        sColumnIdToKeyMap.put("8", MediaStore.MediaColumns.ARTIST);
-        sColumnIdToKeyMap.put("9", MediaStore.MediaColumns.AUTHOR);
-        sColumnIdToKeyMap.put("10", MediaStore.MediaColumns.COMPOSER);
-        sColumnIdToKeyMap.put("11", MediaStore.MediaColumns.GENRE);
-        sColumnIdToKeyMap.put("12", MediaStore.MediaColumns.TITLE);
-        sColumnIdToKeyMap.put("13", MediaStore.MediaColumns.YEAR);
-        sColumnIdToKeyMap.put("14", MediaStore.MediaColumns.DURATION);
-        sColumnIdToKeyMap.put("15", MediaStore.MediaColumns.NUM_TRACKS);
-        sColumnIdToKeyMap.put("16", MediaStore.MediaColumns.WRITER);
-        sColumnIdToKeyMap.put("17", MediaStore.MediaColumns.ALBUM_ARTIST);
-        sColumnIdToKeyMap.put("18", MediaStore.MediaColumns.DISC_NUMBER);
-        sColumnIdToKeyMap.put("19", MediaStore.MediaColumns.COMPILATION);
-        sColumnIdToKeyMap.put("20", MediaStore.MediaColumns.BITRATE);
-        sColumnIdToKeyMap.put("21", MediaStore.MediaColumns.CAPTURE_FRAMERATE);
-        sColumnIdToKeyMap.put("22", MediaStore.Audio.AudioColumns.TRACK);
-        sColumnIdToKeyMap.put("23", MediaStore.MediaColumns.DOCUMENT_ID);
-        sColumnIdToKeyMap.put("24", MediaStore.MediaColumns.INSTANCE_ID);
-        sColumnIdToKeyMap.put("25", MediaStore.MediaColumns.ORIGINAL_DOCUMENT_ID);
-        sColumnIdToKeyMap.put("26", MediaStore.MediaColumns.RESOLUTION);
-        sColumnIdToKeyMap.put("27", MediaStore.MediaColumns.ORIENTATION);
-        sColumnIdToKeyMap.put("28", MediaStore.Video.VideoColumns.COLOR_STANDARD);
-        sColumnIdToKeyMap.put("29", MediaStore.Video.VideoColumns.COLOR_TRANSFER);
-        sColumnIdToKeyMap.put("30", MediaStore.Video.VideoColumns.COLOR_RANGE);
-        sColumnIdToKeyMap.put("31", MediaStore.Files.FileColumns._VIDEO_CODEC_TYPE);
-        sColumnIdToKeyMap.put("32", MediaStore.MediaColumns.WIDTH);
-        sColumnIdToKeyMap.put("33", MediaStore.MediaColumns.HEIGHT);
-        sColumnIdToKeyMap.put("34", MediaStore.Images.ImageColumns.DESCRIPTION);
-        sColumnIdToKeyMap.put("35", MediaStore.Images.ImageColumns.EXPOSURE_TIME);
-        sColumnIdToKeyMap.put("36", MediaStore.Images.ImageColumns.F_NUMBER);
-        sColumnIdToKeyMap.put("37", MediaStore.Images.ImageColumns.ISO);
-        sColumnIdToKeyMap.put("38", MediaStore.Images.ImageColumns.SCENE_CAPTURE_TYPE);
-        sColumnIdToKeyMap.put("39", MediaStore.Files.FileColumns._SPECIAL_FORMAT);
-        sColumnIdToKeyMap.put("40", MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME);
-        // Adding number gap to allow addition of new values
-        sColumnIdToKeyMap.put("80", MediaStore.MediaColumns.XMP);
-    }
 }
diff --git a/tests/src/com/android/providers/media/backupandrestore/MediaBackupAgentTest.java b/tests/src/com/android/providers/media/backupandrestore/MediaBackupAgentTest.java
new file mode 100644
index 000000000..e072f35bc
--- /dev/null
+++ b/tests/src/com/android/providers/media/backupandrestore/MediaBackupAgentTest.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.backupandrestore;
+
+import static com.android.providers.media.backupandrestore.BackupAndRestoreTestUtils.deSerialiseValueString;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreTestUtils.getSharedPreferenceValue;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isBackupAndRestoreSupported;
+import static com.android.providers.media.scan.MediaScanner.REASON_UNKNOWN;
+import static com.android.providers.media.scan.MediaScannerTest.stage;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
+
+import android.Manifest;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Environment;
+import android.os.SystemClock;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
+import android.provider.MediaStore;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+
+import com.android.providers.media.IsolatedContext;
+import com.android.providers.media.R;
+import com.android.providers.media.TestConfigStore;
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.leveldb.LevelDBInstance;
+import com.android.providers.media.leveldb.LevelDBManager;
+import com.android.providers.media.leveldb.LevelDBResult;
+import com.android.providers.media.scan.ModernMediaScanner;
+import com.android.providers.media.util.FileUtils;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.util.Map;
+
+@RunWith(AndroidJUnit4.class)
+@EnableFlags(Flags.FLAG_ENABLE_BACKUP_AND_RESTORE)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+public class MediaBackupAgentTest {
+    @Rule
+    public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
+
+    private Context mIsolatedContext;
+
+    private ContentResolver mIsolatedResolver;
+
+    private ModernMediaScanner mModern;
+
+    private File mDownloadsDir;
+
+    private File mRestoreDir;
+    private File mBackupDir;
+
+    private String mLevelDbPath;
+    private MediaBackupAgent mMediaBackupAgent;
+
+    @Before
+    public void setUp() {
+        final Context context = InstrumentationRegistry.getTargetContext();
+        androidx.test.platform.app.InstrumentationRegistry.getInstrumentation().getUiAutomation()
+                .adoptShellPermissionIdentity(Manifest.permission.LOG_COMPAT_CHANGE,
+                        Manifest.permission.READ_COMPAT_CHANGE_CONFIG,
+                        Manifest.permission.DUMP,
+                        Manifest.permission.READ_DEVICE_CONFIG);
+
+        mIsolatedContext = new IsolatedContext(context, "modern", /*asFuseThread*/ false);
+        mIsolatedResolver = mIsolatedContext.getContentResolver();
+        mModern = new ModernMediaScanner(mIsolatedContext, new TestConfigStore());
+        mRestoreDir = new File(mIsolatedContext.getFilesDir(), "restore");
+        mBackupDir = new File(mIsolatedContext.getFilesDir(), "backup");
+        mDownloadsDir = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        mLevelDbPath =
+                mIsolatedContext.getFilesDir().getAbsolutePath() + "/backup/external_primary";
+        FileUtils.deleteContents(mDownloadsDir);
+
+        mMediaBackupAgent = new MediaBackupAgent();
+        mMediaBackupAgent.attach(mIsolatedContext);
+    }
+
+    @Test
+    public void testCompleteFlow() throws Exception {
+        assumeTrue(isBackupAndRestoreSupported(mIsolatedContext));
+        //create new test file & stage it
+        File file = new File(mDownloadsDir, "testImage_"
+                + SystemClock.elapsedRealtimeNanos() + ".jpg");
+        file.createNewFile();
+        stage(R.raw.test_image, file);
+
+        try {
+            String path = file.getAbsolutePath();
+            // scan directory to have entry in files table
+            mModern.scanDirectory(mDownloadsDir, REASON_UNKNOWN);
+
+            // set is_favorite value to 1. We will check this value later after restoration.
+            updateFavoritesValue(path, 1);
+
+            // run idle maintenance, this will save file's metadata in leveldb with is_favorite = 1
+            MediaStore.runIdleMaintenance(mIsolatedResolver);
+            assertTrue(mBackupDir.exists());
+
+            assertLevelDbExistsAndHasLatestValues(path);
+
+            // run the backup agent. This will copy over backup directory to restore directory and
+            // set shared preference.
+            mMediaBackupAgent.onRestoreFinished();
+            assertTrue(getSharedPreferenceValue(mIsolatedContext));
+            assertTrue(mRestoreDir.exists());
+            assertFalse(mBackupDir.exists());
+
+            //delete existing external db database having old values
+            mIsolatedContext.deleteDatabase("external.db");
+
+            // run media scan, this will populate db and read value from backup
+            mModern.scanDirectory(mDownloadsDir, REASON_UNKNOWN);
+            assertEquals(1, queryFavoritesValue(path));
+
+            // on idle maintenance, clean up is called. It should delete restore directory and set
+            // shared preference to false
+            MediaStore.runIdleMaintenance(mIsolatedResolver);
+            assertFalse(getSharedPreferenceValue(mIsolatedContext));
+            assertFalse(mRestoreDir.exists());
+        } finally {
+            file.delete();
+        }
+    }
+
+    private void assertLevelDbExistsAndHasLatestValues(String path) {
+        // check that entry is created in level db for the file
+        LevelDBInstance levelDBInstance = LevelDBManager.getInstance(mLevelDbPath);
+        assertNotNull(levelDBInstance);
+
+        // check that entry created in level db has latest value(is_favorite = 1)
+        LevelDBResult levelDBResult = levelDBInstance.query(path);
+        assertNotNull(levelDBResult);
+        Map<String, String> actualResultMap = deSerialiseValueString(levelDBResult.getValue());
+        assertEquals(1,
+                Integer.parseInt(actualResultMap.get(MediaStore.MediaColumns.IS_FAVORITE)));
+    }
+
+    private void updateFavoritesValue(String path, int value) {
+        Uri uri = MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL);
+        String selection = MediaStore.Files.FileColumns.DATA + " LIKE ?";
+        String[] selectionArgs = new String[]{path};
+
+        ContentValues values = new ContentValues();
+        values.put(MediaStore.Files.FileColumns.IS_FAVORITE, value);
+        values.put(MediaStore.MediaColumns.DATE_MODIFIED, System.currentTimeMillis());
+
+        mIsolatedResolver.update(uri, values, selection, selectionArgs);
+    }
+
+    private int queryFavoritesValue(String path) {
+        Uri uri = MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL);
+        String selection = MediaStore.Files.FileColumns.DATA + " LIKE ?";
+        String[] selectionArgs = new String[]{path};
+
+        Cursor cursor = mIsolatedResolver.query(uri, null, selection, selectionArgs, null);
+        cursor.moveToFirst();
+        return cursor.getInt(cursor.getColumnIndex(MediaStore.Files.FileColumns.IS_FAVORITE));
+    }
+}
diff --git a/tests/src/com/android/providers/media/backupandrestore/RestoreExecutorTest.java b/tests/src/com/android/providers/media/backupandrestore/RestoreExecutorTest.java
index ebffecc13..cf333b205 100644
--- a/tests/src/com/android/providers/media/backupandrestore/RestoreExecutorTest.java
+++ b/tests/src/com/android/providers/media/backupandrestore/RestoreExecutorTest.java
@@ -16,14 +16,16 @@
 
 package com.android.providers.media.backupandrestore;
 
-import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.FIELD_SEPARATOR;
-import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.KEY_VALUE_SEPARATOR;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreTestUtils.createSerialisedValue;
 import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.RESTORE_COMPLETED;
+import static com.android.providers.media.backupandrestore.BackupAndRestoreUtils.isBackupAndRestoreSupported;
 import static com.android.providers.media.scan.MediaScanner.REASON_UNKNOWN;
 import static com.android.providers.media.scan.MediaScannerTest.stage;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeTrue;
+
 import android.Manifest;
 import android.content.ContentResolver;
 import android.content.Context;
@@ -33,9 +35,8 @@ import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
 import android.os.SystemClock;
-import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
 import android.provider.MediaStore;
 
 import androidx.test.InstrumentationRegistry;
@@ -53,30 +54,22 @@ import com.android.providers.media.util.FileUtils;
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.io.File;
 import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.Path;
 import java.util.HashMap;
 import java.util.Map;
 
 @RunWith(AndroidJUnit4.class)
-@RequiresFlagsEnabled(com.android.providers.media.flags.Flags.FLAG_ENABLE_BACKUP_AND_RESTORE)
+@EnableFlags(com.android.providers.media.flags.Flags.FLAG_ENABLE_BACKUP_AND_RESTORE)
 @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
 public final class RestoreExecutorTest {
 
     @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
-
-    /**
-     * Map used to store key id for given column and vice versa.
-     */
-    private static Map<String, String> sColumnNameToIdMap;
+    public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
 
     private Context mIsolatedContext;
 
@@ -86,11 +79,6 @@ public final class RestoreExecutorTest {
 
     private File mDownloadsDir;
 
-    @BeforeClass
-    public static void setupBeforeClass() {
-        createColumnToKeyMap();
-    }
-
     @Before
     public void setUp() {
         final Context context = InstrumentationRegistry.getTargetContext();
@@ -117,8 +105,9 @@ public final class RestoreExecutorTest {
 
     @Test
     public void testMetadataRestoreForImageFile() throws Exception {
+        assumeTrue(isBackupAndRestoreSupported(mIsolatedContext));
         String levelDbPath =
-                mIsolatedContext.getFilesDir().getAbsolutePath() + "/restore/external_primary/";
+                mIsolatedContext.getFilesDir().getAbsolutePath() + "/restore/external_primary";
         if (!new File(levelDbPath).exists()) {
             new File(levelDbPath).mkdirs();
         }
@@ -289,12 +278,10 @@ public final class RestoreExecutorTest {
         }
     }
 
-    private void seedAudioDataIntoLevelDb(File testAudioFile, LevelDBInstance levelDBInstance)
-            throws IOException {
+    private void seedAudioDataIntoLevelDb(File testAudioFile, LevelDBInstance levelDBInstance) {
         Map<String, String> values = new HashMap<>();
         values.put(MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME, "com.hello.audio");
-        values.put(MediaStore.Files.FileColumns.SIZE,
-                String.valueOf(Files.size(Path.of(testAudioFile.getAbsolutePath()))));
+        values.put(MediaStore.Files.FileColumns.SIZE, String.valueOf(testAudioFile.length()));
         values.put(MediaStore.Files.FileColumns.TITLE, "MyAudio");
         values.put(MediaStore.Audio.AudioColumns.TRACK, "Forever");
         values.put(MediaStore.Files.FileColumns.DURATION, "120");
@@ -306,12 +293,10 @@ public final class RestoreExecutorTest {
                         createSerialisedValue(values))).isSuccess()).isTrue();
     }
 
-    private void seedVideoDataIntoLevelDb(File testVideoFile, LevelDBInstance levelDBInstance)
-            throws IOException {
+    private void seedVideoDataIntoLevelDb(File testVideoFile, LevelDBInstance levelDBInstance) {
         Map<String, String> values = new HashMap<>();
         values.put(MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME, "com.hello.video");
-        values.put(MediaStore.Files.FileColumns.SIZE,
-                String.valueOf(Files.size(Path.of(testVideoFile.getAbsolutePath()))));
+        values.put(MediaStore.Files.FileColumns.SIZE, String.valueOf(testVideoFile.length()));
         values.put(MediaStore.Files.FileColumns.TITLE, "MyVideo");
         values.put(MediaStore.Video.VideoColumns.COLOR_STANDARD, "1");
         values.put(MediaStore.Video.VideoColumns.COLOR_RANGE, "5");
@@ -323,12 +308,10 @@ public final class RestoreExecutorTest {
                         createSerialisedValue(values))).isSuccess()).isTrue();
     }
 
-    private void seedImageDataIntoLevelDb(File testFile, LevelDBInstance levelDBInstance)
-            throws IOException {
+    private void seedImageDataIntoLevelDb(File testFile, LevelDBInstance levelDBInstance) {
         Map<String, String> values = new HashMap<>();
         values.put(MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME, "com.hello.image");
-        values.put(MediaStore.Files.FileColumns.SIZE,
-                String.valueOf(Files.size(Path.of(testFile.getAbsolutePath()))));
+        values.put(MediaStore.Files.FileColumns.SIZE, String.valueOf(testFile.length()));
         values.put(MediaStore.Files.FileColumns.TITLE, "MyImage");
         values.put(MediaStore.Files.FileColumns.HEIGHT, "1600");
         values.put(MediaStore.Files.FileColumns.WIDTH, "3200");
@@ -347,63 +330,4 @@ public final class RestoreExecutorTest {
         file.createNewFile();
         stage(resId, file);
     }
-
-    private String createSerialisedValue(Map<String, String> entries) {
-        StringBuilder sb = new StringBuilder();
-        for (String backupColumn : sColumnNameToIdMap.keySet()) {
-            if (entries.containsKey(backupColumn)) {
-                sb.append(sColumnNameToIdMap.get(backupColumn)).append(KEY_VALUE_SEPARATOR).append(
-                        entries.get(backupColumn));
-                sb.append(FIELD_SEPARATOR);
-            }
-        }
-        return sb.toString();
-    }
-
-    private static void createColumnToKeyMap() {
-        sColumnNameToIdMap = new HashMap<>();
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.IS_FAVORITE, "0");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.MEDIA_TYPE, "1");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.MIME_TYPE, "2");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns._USER_ID, "3");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.SIZE, "4");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.DATE_TAKEN, "5");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.CD_TRACK_NUMBER, "6");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.ALBUM, "7");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.ARTIST, "8");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.AUTHOR, "9");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.COMPOSER, "10");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.GENRE, "11");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.TITLE, "12");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.YEAR, "13");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.DURATION, "14");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.NUM_TRACKS, "15");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.WRITER, "16");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.ALBUM_ARTIST, "17");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.DISC_NUMBER, "18");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.COMPILATION, "19");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.BITRATE, "20");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.CAPTURE_FRAMERATE, "21");
-        sColumnNameToIdMap.put(MediaStore.Audio.AudioColumns.TRACK, "22");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.DOCUMENT_ID, "23");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.INSTANCE_ID, "24");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.ORIGINAL_DOCUMENT_ID, "25");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.RESOLUTION, "26");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.ORIENTATION, "27");
-        sColumnNameToIdMap.put(MediaStore.Video.VideoColumns.COLOR_STANDARD, "28");
-        sColumnNameToIdMap.put(MediaStore.Video.VideoColumns.COLOR_TRANSFER, "29");
-        sColumnNameToIdMap.put(MediaStore.Video.VideoColumns.COLOR_RANGE, "30");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns._VIDEO_CODEC_TYPE, "31");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.WIDTH, "32");
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.HEIGHT, "33");
-        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.DESCRIPTION, "34");
-        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.EXPOSURE_TIME, "35");
-        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.F_NUMBER, "36");
-        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.ISO, "37");
-        sColumnNameToIdMap.put(MediaStore.Images.ImageColumns.SCENE_CAPTURE_TYPE, "38");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns._SPECIAL_FORMAT, "39");
-        sColumnNameToIdMap.put(MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME, "40");
-        // Adding number gap to allow addition of new values
-        sColumnNameToIdMap.put(MediaStore.MediaColumns.XMP, "80");
-    }
 }
diff --git a/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java b/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java
index f6b269ccc..d0da49abe 100644
--- a/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java
+++ b/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java
@@ -53,18 +53,6 @@ public class SearchProvider extends CloudMediaProvider {
             getCloudMediaCursor(CLOUD_ID_4, null, 0)
     ).toArray(new Cursor[0]));
 
-    public static final MergeCursor DEFAULT_CLOUD_SEARCH_RESULTS = new MergeCursor(List.of(
-            getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_1, 1),
-            getCloudMediaCursor(CLOUD_ID_3, null, 0)
-    ).toArray(new Cursor[0]));
-
-    public static final MergeCursor DEFAULT_LOCAL_SEARCH_RESULTS = new MergeCursor(List.of(
-            getLocalMediaCursor(LOCAL_ID_1, 1),
-            getLocalMediaCursor(LOCAL_ID_2, 0)
-    ).toArray(new Cursor[0]));
-
-    private static Cursor sSearchResults = DEFAULT_CLOUD_SEARCH_RESULTS;
-
     public static final MergeCursor DEFAULT_SUGGESTION_RESULTS = new MergeCursor(List.of(
             getSuggestionCursor(CLOUD_ID_1),
             getSuggestionCursor(CLOUD_ID_2)
@@ -84,6 +72,12 @@ public class SearchProvider extends CloudMediaProvider {
 
     private static Cursor sAlbums = DEFAULT_ALBUM_RESULTS;
 
+    private static Cursor sSearchResults = getDefaultCloudSearchResults();
+
+    public static Cursor sMediaSets = getDefaultCursorForMediaSetSyncTest();
+
+    public static Cursor sMediaSetContents = getDefaultCloudSearchResults();
+
     @Override
     public Cursor onSearchMedia(String mediaSetId, String fallbackSearchText,
                                 Bundle extras, CancellationSignal cancellationSignal) {
@@ -99,7 +93,7 @@ public class SearchProvider extends CloudMediaProvider {
     @Override
     public Cursor onQueryMediaInMediaSet(String mediaSetId,
             Bundle extras, CancellationSignal cancellationSignal) {
-        return sSearchResults;
+        return sMediaSetContents;
     }
 
     @Override
@@ -111,7 +105,7 @@ public class SearchProvider extends CloudMediaProvider {
     @Override
     public Cursor onQueryMediaSets(String mediaCategoryId,
             Bundle extras, CancellationSignal cancellationSignal) {
-        return getCursorForMediaSetSyncTest();
+        return sMediaSets;
     }
 
     @Override
@@ -178,10 +172,18 @@ public class SearchProvider extends CloudMediaProvider {
         return sSearchResults;
     }
 
-    /*
-     Returns a media set data cursor for tests
+    public static void setMediaSets(Cursor mediaSets) {
+        sMediaSets = mediaSets;
+    }
+
+    public static void setMediaSetContents(Cursor mediaSetContents) {
+        sMediaSetContents = mediaSetContents;
+    }
+
+    /**
+     Returns a default media set data cursor for tests
      */
-    public static Cursor getCursorForMediaSetSyncTest() {
+    public static Cursor getDefaultCursorForMediaSetSyncTest() {
         String[] columns = new String[]{
                 CloudMediaProviderContract.MediaSetColumns.ID,
                 CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
@@ -193,4 +195,24 @@ public class SearchProvider extends CloudMediaProvider {
 
         return cursor;
     }
+
+    /**
+     * Returns a default set of cloud search results for tests.
+     */
+    public static final MergeCursor getDefaultCloudSearchResults() {
+        return new MergeCursor(List.of(
+                getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_1, 1),
+                getCloudMediaCursor(CLOUD_ID_3, null, 0)
+        ).toArray(new Cursor[0]));
+    }
+
+    /**
+     * Returns a default set of local search results for tests.
+     */
+    public static final MergeCursor getDefaultLocalSearchResults() {
+        return new MergeCursor(List.of(
+                getLocalMediaCursor(LOCAL_ID_1, 1),
+                getLocalMediaCursor(LOCAL_ID_2, 0)
+        ).toArray(new Cursor[0]));
+    }
 }
diff --git a/tests/src/com/android/providers/media/leveldb/LevelDBManagerTest.java b/tests/src/com/android/providers/media/leveldb/LevelDBManagerTest.java
index f684e8ce5..191f11a59 100644
--- a/tests/src/com/android/providers/media/leveldb/LevelDBManagerTest.java
+++ b/tests/src/com/android/providers/media/leveldb/LevelDBManagerTest.java
@@ -21,8 +21,8 @@ import static com.google.common.truth.Truth.assertThat;
 
 import android.content.Context;
 
+import androidx.test.InstrumentationRegistry;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import androidx.test.platform.app.InstrumentationRegistry;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,7 +39,7 @@ public class LevelDBManagerTest {
 
     @Test
     public void testLevelDbOperations() {
-        final Context context = InstrumentationRegistry.getInstrumentation().getContext();
+        final Context context = InstrumentationRegistry.getTargetContext();
         String levelDBFile = "test-leveldb";
         final String levelDBPath = context.getFilesDir().getPath() + "/" + levelDBFile;
         LevelDBInstance levelDBInstance = LevelDBManager.getInstance(levelDBPath);
diff --git a/tests/src/com/android/providers/media/oemmetadataservices/OemMetadataServiceTest.java b/tests/src/com/android/providers/media/oemmetadataservices/OemMetadataServiceTest.java
index c01e06f00..d8001c6c4 100644
--- a/tests/src/com/android/providers/media/oemmetadataservices/OemMetadataServiceTest.java
+++ b/tests/src/com/android/providers/media/oemmetadataservices/OemMetadataServiceTest.java
@@ -26,6 +26,7 @@ import android.Manifest;
 import android.app.Instrumentation;
 import android.content.ComponentName;
 import android.content.ContentUris;
+import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
 import android.content.ServiceConnection;
@@ -36,15 +37,13 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.IBinder;
 import android.os.ParcelFileDescriptor;
-import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
 import android.provider.IOemMetadataService;
 import android.provider.MediaStore;
 import android.provider.MediaStore.Files.FileColumns;
 import android.provider.OemMetadataService;
 import android.provider.OemMetadataServiceWrapper;
-import android.provider.media.internal.flags.Flags;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.filters.SdkSuppress;
@@ -65,6 +64,7 @@ import org.junit.runner.RunWith;
 
 import java.io.File;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
@@ -73,12 +73,10 @@ import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
 
 @RunWith(AndroidJUnit4.class)
-@RequiresFlagsEnabled(com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA)
 @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
 public class OemMetadataServiceTest {
 
-    @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+    @Rule public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
 
     private static final long POLLING_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(5);
     private static final long POLLING_SLEEP_MILLIS = 100;
@@ -108,6 +106,7 @@ public class OemMetadataServiceTest {
     }
 
     @Test
+    @EnableFlags(com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA)
     public void testGetSupportedMimeTypes() throws Exception {
         bindService();
         assertNotNull(mOemMetadataServiceWrapper);
@@ -119,6 +118,7 @@ public class OemMetadataServiceTest {
     }
 
     @Test
+    @EnableFlags(com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA)
     public void testGetOemCustomData() throws Exception {
         bindService();
         assertNotNull(mOemMetadataServiceWrapper);
@@ -144,6 +144,7 @@ public class OemMetadataServiceTest {
     }
 
     @Test
+    @EnableFlags(com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA)
     public void testScanOfOemMetadataAndFilterOnReadWithoutPermission() throws Exception {
         IsolatedContext isolatedContext = new IsolatedContext(mContext, "modern",
                 /* asFuseThread */ false);
@@ -179,6 +180,131 @@ public class OemMetadataServiceTest {
             }
         } finally {
             audioFile.delete();
+            isolatedContext.unbindService(modernMediaScanner.getOemMetadataServiceConnection());
+        }
+    }
+
+    @Test
+    @EnableFlags({com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA,
+            com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA_UPDATE})
+    public void testTriggerOemMetadataUpdateWithPermission() throws Exception {
+        IsolatedContext isolatedContext = new IsolatedContext(mContext, "modern",
+                /* asFuseThread */ false);
+        ModernMediaScanner modernMediaScanner = new ModernMediaScanner(isolatedContext,
+                new TestConfigStore());
+        final File downloads = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        final File audioFile = new File(downloads, "audio.mp3");
+        try {
+            stage(R.raw.test_audio, audioFile);
+            Uri uri = modernMediaScanner.scanFile(audioFile, MediaScanner.REASON_UNKNOWN);
+            DatabaseHelper databaseHelper = isolatedContext.getExternalDatabase();
+            // Direct query on DB returns stored value of oem_metadata
+            try (Cursor c = databaseHelper.runWithoutTransaction(db -> db.query(
+                    "files", new String[]{FileColumns.OEM_METADATA, FileColumns._MODIFIER},
+                    "_id=?", new String[]{String.valueOf(ContentUris.parseId(uri))},
+                    null, null, null))) {
+                assertThat(c.getCount()).isEqualTo(1);
+                c.moveToNext();
+                byte[] oemData = c.getBlob(0);
+                int modifier = c.getInt(1);
+                assertThat(oemData).isNotNull();
+                Map<String, String> map = convertStringToOemMetadataMap(new String(oemData));
+                assertThat(map.keySet()).containsExactly("a", "b", "c", "d", "e");
+                assertThat(modifier).isEqualTo(FileColumns._MODIFIER_MEDIA_SCAN);
+            }
+
+            ContentValues contentValues = new ContentValues();
+            Map<String, String> updatedData = Map.of("a1", "b1", "a2", "b2");
+            contentValues.put(FileColumns.OEM_METADATA, updatedData.toString());
+            isolatedContext.getContentResolver().update(uri, contentValues, null);
+
+            try (Cursor c = databaseHelper.runWithoutTransaction(db -> db.query(
+                    "files", new String[]{FileColumns.OEM_METADATA, FileColumns._MODIFIER},
+                    "_id=?", new String[]{String.valueOf(ContentUris.parseId(uri))},
+                    null, null, null))) {
+                assertThat(c.getCount()).isEqualTo(1);
+                c.moveToNext();
+                byte[] oemData = c.getBlob(0);
+                int modifier = c.getInt(1);
+                assertThat(modifier).isEqualTo(FileColumns._MODIFIER_MEDIA_SCAN);
+                assertThat(oemData).isNotNull();
+                Map<String, String> map = convertStringToOemMetadataMap(new String(oemData));
+                assertThat(map.keySet()).containsExactly("a1", "a2");
+            }
+        } finally {
+            audioFile.delete();
+        }
+    }
+
+    @Test
+    @EnableFlags({com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA,
+            com.android.providers.media.flags.Flags.FLAG_ENABLE_OEM_METADATA_UPDATE})
+    public void testTriggerBulkUpdateOemMetadataInNextScan() throws Exception {
+        IsolatedContext isolatedContext = new IsolatedContext(mContext, "modern",
+                /* asFuseThread */ false);
+        ModernMediaScanner modernMediaScanner = new ModernMediaScanner(isolatedContext,
+                new TestConfigStore());
+        final File downloads = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        final File audioFile = new File(downloads, "audio.mp3");
+        try {
+            stage(R.raw.test_audio, audioFile);
+
+            Uri uri = modernMediaScanner.scanFile(audioFile, MediaScanner.REASON_UNKNOWN);
+
+            DatabaseHelper databaseHelper = isolatedContext.getExternalDatabase();
+            // Direct query on DB returns stored value of oem_metadata
+            try (Cursor c = databaseHelper.runWithoutTransaction(db -> db.query(
+                    "files", new String[]{FileColumns.OEM_METADATA, FileColumns._MODIFIER},
+                    "_id=?", new String[]{String.valueOf(ContentUris.parseId(uri))},
+                    null, null, null))) {
+                assertThat(c.getCount()).isEqualTo(1);
+                c.moveToNext();
+                byte[] oemData = c.getBlob(0);
+                int modifier = c.getInt(1);
+                assertThat(oemData).isNotNull();
+                Map<String, String> map = convertStringToOemMetadataMap(new String(oemData));
+                assertThat(map.keySet()).containsExactly("a", "b", "c", "d", "e");
+                assertThat(modifier).isEqualTo(FileColumns._MODIFIER_MEDIA_SCAN);
+            }
+
+            // Change service behavior to verify updated results. Add new key "f".
+            TestOemMetadataService.updateOemMetadataServiceData();
+            // OEM metadata should be allowed to update to null and modifier
+            // should now be set to _MODIFIER_CR as scan has not happened yet
+            MediaStore.bulkUpdateOemMetadataInNextScan(isolatedContext);
+            try (Cursor c = databaseHelper.runWithoutTransaction(db -> db.query(
+                    "files", new String[]{FileColumns.OEM_METADATA, FileColumns._MODIFIER},
+                    "_id=?", new String[]{String.valueOf(ContentUris.parseId(uri))},
+                    null, null, null))) {
+                assertThat(c.getCount()).isEqualTo(1);
+                c.moveToNext();
+                byte[] oemData = c.getBlob(0);
+                int modifier = c.getInt(1);
+                assertThat(oemData).isNull();
+                assertThat(modifier).isEqualTo(FileColumns._MODIFIER_CR);
+            }
+
+            // Trigger scan to allow OEM metadata update
+            MediaStore.scanFile(isolatedContext.getContentResolver(), audioFile);
+
+            try (Cursor c = databaseHelper.runWithoutTransaction(db -> db.query(
+                    "files", new String[]{FileColumns.OEM_METADATA, FileColumns._MODIFIER},
+                    "_id=?", new String[]{String.valueOf(ContentUris.parseId(uri))},
+                    null, null, null))) {
+                assertThat(c.getCount()).isEqualTo(1);
+                c.moveToNext();
+                byte[] oemData = c.getBlob(0);
+                int modifier = c.getInt(1);
+                assertThat(modifier).isEqualTo(FileColumns._MODIFIER_MEDIA_SCAN);
+                assertThat(oemData).isNotNull();
+                Map<String, String> map = convertStringToOemMetadataMap(new String(oemData));
+                assertThat(map.keySet()).containsExactly("a", "b", "c", "d", "e", "f");
+            }
+        } finally {
+            audioFile.delete();
+            TestOemMetadataService.resetOemMetadataServiceData();
         }
     }
 
@@ -274,4 +400,24 @@ public class OemMetadataServiceTest {
         mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);
         mServiceLatch.await(3, TimeUnit.SECONDS);
     }
+
+    public static Map<String, String> convertStringToOemMetadataMap(String stringMapping) {
+        Map<String, String> map = new HashMap<>();
+        if (stringMapping == null || stringMapping.isEmpty()) {
+            return map;
+        }
+        stringMapping = stringMapping.substring(1, stringMapping.length() - 1);
+        // Split into key-value pairs
+        String[] pairs = stringMapping.split(", ");
+
+        for (String pair : pairs) {
+            String[] keyValue = pair.split("=");
+            String key = keyValue[0];
+            String value = keyValue[1];
+            if (key != null) {
+                map.put(key, value);
+            }
+        }
+        return map;
+    }
 }
diff --git a/tests/src/com/android/providers/media/oemmetadataservices/TestOemMetadataService.java b/tests/src/com/android/providers/media/oemmetadataservices/TestOemMetadataService.java
index cdc4f71ce..ae1dcf8a2 100644
--- a/tests/src/com/android/providers/media/oemmetadataservices/TestOemMetadataService.java
+++ b/tests/src/com/android/providers/media/oemmetadataservices/TestOemMetadataService.java
@@ -27,6 +27,15 @@ import java.util.Set;
 
 public class TestOemMetadataService extends OemMetadataService {
 
+    static Map<String, String> sOemMetadata = new HashMap<>();
+
+    static {
+        sOemMetadata.put("a", "1");
+        sOemMetadata.put("b", "2");
+        sOemMetadata.put("c", "3");
+        sOemMetadata.put("d", "4");
+        sOemMetadata.put("e", "5");
+    }
 
     @Override
     public Set<String> onGetSupportedMimeTypes() {
@@ -35,12 +44,14 @@ public class TestOemMetadataService extends OemMetadataService {
 
     @Override
     public Map<String, String> onGetOemCustomData(@NonNull ParcelFileDescriptor pfd) {
-        Map<String, String> oemMetadata = new HashMap<>();
-        oemMetadata.put("a", "1");
-        oemMetadata.put("b", "2");
-        oemMetadata.put("c", "3");
-        oemMetadata.put("d", "4");
-        oemMetadata.put("e", "5");
-        return oemMetadata;
+        return sOemMetadata;
+    }
+
+    public static void updateOemMetadataServiceData() {
+        sOemMetadata.put("f", "6");
+    }
+
+    public static void resetOemMetadataServiceData() {
+        sOemMetadata.remove("f");
     }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/ItemsProviderTest.java b/tests/src/com/android/providers/media/photopicker/ItemsProviderTest.java
index f39da9c09..47ab3df69 100644
--- a/tests/src/com/android/providers/media/photopicker/ItemsProviderTest.java
+++ b/tests/src/com/android/providers/media/photopicker/ItemsProviderTest.java
@@ -33,6 +33,8 @@ import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeFalse;
+import static org.junit.Assume.assumeTrue;
 
 import android.Manifest;
 import android.app.Instrumentation;
@@ -49,6 +51,7 @@ import android.os.CancellationSignal;
 import android.os.Environment;
 import android.os.OperationCanceledException;
 import android.os.ParcelFileDescriptor;
+import android.os.UserManager;
 import android.provider.CloudMediaProviderContract;
 import android.provider.MediaStore;
 import android.util.Log;
@@ -216,6 +219,7 @@ public class ItemsProviderTest {
      */
     @Test
     public void testGetCategories_screenshots() throws Exception {
+        assumeFalse("Not testable in HSUM device", UserManager.isHeadlessSystemUserMode());
         Cursor c = mItemsProvider.getAllCategories(/* mimeType */ null, /* userId */ null,
                 /* cancellationSignal*/ null);
         assertThat(c.getCount()).isEqualTo(0);
@@ -251,6 +255,46 @@ public class ItemsProviderTest {
         }
     }
 
+    /**
+     * Tests {@link ItemsProvider#getAllCategories(String[], UserId, CancellationSignal)} to return
+     * correct info about {@link AlbumColumns#ALBUM_ID_SCREENSHOTS}.
+     * This test is specifically for HSUM devices since creating a top-level screenshots directory
+     * is not possible.
+     */
+    @Test
+    public void testGetCategoriesForHSUM_screenshots() throws Exception {
+        assumeTrue("Test only for HSUM device", UserManager.isHeadlessSystemUserMode());
+        Cursor c = mItemsProvider.getAllCategories(/* mimeType */ null, /* userId */ null,
+                /* cancellationSignal*/ null);
+        assertThat(c.getCount()).isEqualTo(0);
+
+        // Create 1 image file in Screenshots dir to test
+        final File screenshotsDir = getScreenshotsDir();
+        File imageFile = assertCreateNewImage(screenshotsDir);
+        // Create 1 image file in Screenshots dir of Downloads dir
+        final File screenshotsDirInDownloadsDir = getScreenshotsDirFromDownloadsDir();
+        File imageFileInScreenshotDirInDownloads =
+                assertCreateNewImage(screenshotsDirInDownloadsDir);
+
+        // This file should not be included since it's not a valid screenshot directory, even though
+        // it looks like one.
+        final File myAlbumScreenshotsDir =
+                new File(getPicturesDir(), "MyAlbum" + Environment.DIRECTORY_SCREENSHOTS);
+        final File myAlbumScreenshotsImg = assertCreateNewImage(myAlbumScreenshotsDir);
+
+        try {
+            assertGetCategoriesMatchMultiple(Arrays.asList(
+                    Pair.create(ALBUM_ID_SCREENSHOTS, 2),
+                    Pair.create(ALBUM_ID_DOWNLOADS, 1)
+            ));
+        } finally {
+            imageFile.delete();
+            imageFileInScreenshotDirInDownloads.delete();
+            myAlbumScreenshotsImg.delete();
+            myAlbumScreenshotsDir.delete();
+        }
+    }
+
     /**
      * Tests {@link ItemsProvider#getAllCategories(String[], UserId, CancellationSignal)} to return
      * correct info about {@link AlbumColumns#ALBUM_ID_SCREENSHOTS}.
@@ -1423,7 +1467,8 @@ public class ItemsProviderTest {
     private Uri prepareFileAndGetUri(File file, long lastModifiedTime) throws IOException {
         ensureParentExists(file.getParentFile());
 
-        assertThat(file.createNewFile()).isTrue();
+        file.createNewFile();
+        assertThat(file.exists()).isTrue();
 
         // Write 1 byte because 0byte files are not valid in the picker db
         try (FileOutputStream fos = new FileOutputStream(file)) {
diff --git a/tests/src/com/android/providers/media/photopicker/PickerSyncControllerTest.java b/tests/src/com/android/providers/media/photopicker/PickerSyncControllerTest.java
index ba98432fc..9dc227cc0 100644
--- a/tests/src/com/android/providers/media/photopicker/PickerSyncControllerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/PickerSyncControllerTest.java
@@ -25,6 +25,7 @@ import static com.android.providers.media.util.BackgroundThreadUtils.waitForIdle
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
@@ -59,6 +60,7 @@ import com.android.providers.media.photopicker.data.CloudProviderInfo;
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
 import com.android.providers.media.photopicker.data.PickerDbFacade;
 import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
 import com.android.providers.media.photopicker.util.exceptions.UnableToAcquireLockException;
 import com.android.providers.media.photopicker.v2.model.ProviderCollectionInfo;
 
@@ -2101,6 +2103,70 @@ public class PickerSyncControllerTest {
                 .that(mFacade.getCloudProvider()).isEqualTo(CLOUD_PRIMARY_PROVIDER_AUTHORITY);
     }
 
+    @Test
+    public void testIsFullSyncPending() throws RequestObsoleteException {
+        mController.setCloudProvider(/* authority */ CLOUD_PRIMARY_PROVIDER_AUTHORITY);
+        assertWithMessage("Full sync should be pending after setting the CMP.")
+                .that(mController.isFullSyncPending(CLOUD_PRIMARY_PROVIDER_AUTHORITY, false))
+                .isTrue();
+
+        mController.syncAllMedia();
+        assertWithMessage("Full sync should be completed after syncing with the CMP.")
+                .that(mController.isFullSyncPending(CLOUD_PRIMARY_PROVIDER_AUTHORITY, false))
+                .isFalse();
+
+        // First Page of data
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_1);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_2);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_3);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_4);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_5);
+        // Second Page of data
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_6);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_7);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_8);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_9);
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_10);
+        // Third Page of data
+        addMedia(mCloudFlakyMediaGenerator, CLOUD_ONLY_11);
+
+        mController.setCloudProvider(/* authority */ FLAKY_CLOUD_PROVIDER_AUTHORITY);
+        assertWithMessage("Full sync should be pending after setting the CMP.")
+                .that(mController.isFullSyncPending(FLAKY_CLOUD_PROVIDER_AUTHORITY, false))
+                .isTrue();
+
+        // FlakyCloudMediaProvider will throw errors on 2 out of 3 requests, if we sync once, it
+        // should not be able to complete the sync.
+        mController.syncAllMedia();
+        assertWithMessage("Full sync should still be pending because it was stopped in between.")
+                .that(mController.isFullSyncPending(FLAKY_CLOUD_PROVIDER_AUTHORITY, false))
+                .isTrue();
+
+        mController.syncAllMedia();
+        mController.syncAllMedia();
+        mController.syncAllMedia();
+        assertWithMessage("Full sync should be complete now.")
+                .that(mController.isFullSyncPending(FLAKY_CLOUD_PROVIDER_AUTHORITY, false))
+                .isFalse();
+    }
+
+    @Test
+    public void testIsFullSyncPendingForStaleCMP() throws RequestObsoleteException {
+        mController.setCloudProvider(/* authority */ CLOUD_PRIMARY_PROVIDER_AUTHORITY);
+        assertWithMessage("Full sync should be pending after setting the CMP.")
+                .that(mController.isFullSyncPending(CLOUD_PRIMARY_PROVIDER_AUTHORITY, false))
+                .isTrue();
+
+        mController.syncAllMedia();
+        assertWithMessage("Full sync should be completed after syncing with the CMP.")
+                .that(mController.isFullSyncPending(CLOUD_PRIMARY_PROVIDER_AUTHORITY, false))
+                .isFalse();
+
+        assertThrows(RequestObsoleteException.class,
+                () -> mController.isFullSyncPending(
+                        CLOUD_SECONDARY_PROVIDER_AUTHORITY, false));
+    }
+
     private static void addMedia(MediaGenerator generator, Pair<String, String> media) {
         generator.addMedia(media.first, media.second);
     }
diff --git a/tests/src/com/android/providers/media/photopicker/data/PickerDbFacadeTest.java b/tests/src/com/android/providers/media/photopicker/data/PickerDbFacadeTest.java
index 68438b176..45069df81 100644
--- a/tests/src/com/android/providers/media/photopicker/data/PickerDbFacadeTest.java
+++ b/tests/src/com/android/providers/media/photopicker/data/PickerDbFacadeTest.java
@@ -1459,7 +1459,7 @@ public class PickerDbFacadeTest {
         }
 
         // Assert invalid projection column
-        final String invalidColumn = "testInvalidColumn";
+        final String invalidColumn = "test invalid column";
         final String[] invalidProjection = new String[]{
                 PickerMediaColumns.DATE_TAKEN,
                 invalidColumn
@@ -1471,12 +1471,17 @@ public class PickerDbFacadeTest {
                     "Unexpected number of rows when asserting invalid projection column with "
                             + "cloud provider.")
                     .that(cr.getCount()).isEqualTo(1);
+            assertWithMessage("Unexpected number of columns in cursor")
+                    .that(cr.getColumnCount())
+                    .isEqualTo(2);
 
             cr.moveToFirst();
-            assertWithMessage(
-                    "Unexpected value of the invalidColumn with cloud provider.")
+            assertWithMessage("Unexpected value of the invalidColumn with cloud provider.")
                     .that(cr.getLong(cr.getColumnIndexOrThrow(invalidColumn)))
                     .isEqualTo(0);
+            assertWithMessage("Unexpected value of the invalidColumn with cloud provider.")
+                    .that(cr.getString(cr.getColumnIndexOrThrow(invalidColumn)))
+                    .isEqualTo(null);
             assertWithMessage(
                     "Unexpected value of PickerMediaColumns.DATE_TAKEN with cloud provider.")
                     .that(cr.getLong(cr.getColumnIndexOrThrow(PickerMediaColumns.DATE_TAKEN)))
diff --git a/tests/src/com/android/providers/media/photopicker/data/UserManagerStateTest.java b/tests/src/com/android/providers/media/photopicker/data/UserManagerStateTest.java
index 2807da353..f2fc38d9d 100644
--- a/tests/src/com/android/providers/media/photopicker/data/UserManagerStateTest.java
+++ b/tests/src/com/android/providers/media/photopicker/data/UserManagerStateTest.java
@@ -19,14 +19,25 @@ package com.android.providers.media.photopicker.data;
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertThrows;
+import static org.junit.Assume.assumeFalse;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
+import android.content.Intent;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.content.pm.UserProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.provider.MediaStore;
+import android.test.mock.MockContentProvider;
+import android.test.mock.MockContentResolver;
 
 import androidx.test.filters.SdkSuppress;
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -42,31 +53,70 @@ import java.util.List;
 
 @SdkSuppress(minSdkVersion = 31, codeName = "S")
 public class UserManagerStateTest {
-    private final UserHandle mPersonalUser = UserHandle.SYSTEM;
+    private final UserHandle mPersonalUser = UserHandle.of(UserHandle.myUserId());
     private final UserHandle mManagedUser = UserHandle.of(100); // like a managed profile
+    private final UserHandle mManagedUser2 = UserHandle.of(150); // like a managed profile
     private final UserHandle mOtherUser1 = UserHandle.of(101); // like a private profile
     private final UserHandle mOtherUser2 = UserHandle.of(102); // like a clone profile
-    private final UserHandle mOtherUser3 = UserHandle.of(103); //  like a invalid user
+    private final UserHandle mOtherUser3 = UserHandle.of(103); // like a invalid user
     private final Context mMockContext = mock(Context.class);
     private final UserManager mMockUserManager = mock(UserManager.class);
     private final PackageManager mMockPackageManager = mock(PackageManager.class);
     private UserManagerState mUserManagerState;
+    private MockContentResolver mMockContentResolver;
+    private MockContentProvider mMockContentProvider;
+
+    /**
+     * Class that exposes the @hide api [targetUserId] in order to supply proper values for
+     * reflection based code that is inspecting this field.
+     */
+    private static class ReflectedResolveInfo extends ResolveInfo {
+
+        @SuppressLint({"HidingField", "UnusedVariable"})
+        public int targetUserId;
+
+        ReflectedResolveInfo(int targetUserId) {
+            this.targetUserId = targetUserId;
+        }
+
+        @Override
+        public boolean isCrossProfileIntentForwarderActivity() {
+            return true;
+        }
+    }
 
     @Before
     public void setUp() throws Exception {
+
+        // Setup mock context to always return itself for various transforms.
         when(mMockContext.getApplicationContext()).thenReturn(mMockContext);
+        when(mMockContext.createPackageContextAsUser(any(), anyInt(), any(UserHandle.class)))
+                .thenReturn(mMockContext);
+        when(mMockContext.createContextAsUser(any(UserHandle.class), anyInt()))
+                .thenReturn(mMockContext);
+        when(mMockContext.getApplicationInfo())
+                .thenReturn(
+                        InstrumentationRegistry.getInstrumentation()
+                                .getContext()
+                                .getApplicationInfo());
+
+        // Mock out MediaProvider since certain logic waits on a ContentProviderClient
+        // for mediaprovider to be available.
+        mMockContentProvider = new MockContentProvider(mMockContext);
+        mMockContentResolver = new MockContentResolver(mMockContext);
+        mMockContentResolver.addProvider(MediaStore.AUTHORITY, mMockContentProvider);
+
+        // Mock out other platform apis.
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockContext.getContentResolver()).thenReturn(mMockContentResolver);
 
         // set Managed Profile identification
-        when(mMockUserManager.isManagedProfile(
-                mManagedUser.getIdentifier())).thenReturn(true);
-        when(mMockUserManager.isManagedProfile(
-                mPersonalUser.getIdentifier())).thenReturn(false);
-        when(mMockUserManager.isManagedProfile(
-                mOtherUser1.getIdentifier())).thenReturn(false);
-        when(mMockUserManager.isManagedProfile(
-                mOtherUser2.getIdentifier())).thenReturn(false);
-        when(mMockUserManager.isManagedProfile(
-                mOtherUser3.getIdentifier())).thenReturn(false);
+        when(mMockUserManager.isManagedProfile(mManagedUser.getIdentifier())).thenReturn(true);
+        when(mMockUserManager.isManagedProfile(mManagedUser2.getIdentifier())).thenReturn(true);
+        when(mMockUserManager.isManagedProfile(mPersonalUser.getIdentifier())).thenReturn(false);
+        when(mMockUserManager.isManagedProfile(mOtherUser1.getIdentifier())).thenReturn(false);
+        when(mMockUserManager.isManagedProfile(mOtherUser2.getIdentifier())).thenReturn(false);
+        when(mMockUserManager.isManagedProfile(mOtherUser3.getIdentifier())).thenReturn(false);
 
         // set all user profile parents
         when(mMockUserManager.getProfileParent(mPersonalUser)).thenReturn(null);
@@ -76,29 +126,37 @@ public class UserManagerStateTest {
         when(mMockUserManager.getProfileParent(mOtherUser3)).thenReturn(mPersonalUser);
 
         if (SdkLevel.isAtLeastV()) {
-            //Personal user
+            // Personal user
             UserProperties mPersonalUserProperties = new UserProperties.Builder().build();
 
-            UserProperties mManagedUserProperties = new UserProperties.Builder() // managed user
-                    .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE)
-                    .setCrossProfileContentSharingStrategy(
-                            UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION)
-                    .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_PAUSED)
-                    .build();
-
-            UserProperties mOtherUser1Properties = new UserProperties.Builder() // private user
-                    .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE)
-                    .setCrossProfileContentSharingStrategy(
-                            UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT)
-                    .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_HIDDEN)
-                    .build();
-
-            UserProperties mOtherUser2Properties = new UserProperties.Builder() // clone user
-                    .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_WITH_PARENT)
-                    .setCrossProfileContentSharingStrategy(
-                            UserProperties.CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT)
-                    .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_DEFAULT)
-                    .build();
+            UserProperties mManagedUserProperties =
+                    new UserProperties.Builder() // managed user
+                            .setShowInSharingSurfaces(
+                                    UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE)
+                            .setCrossProfileContentSharingStrategy(
+                                    UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION)
+                            .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_PAUSED)
+                            .build();
+
+            UserProperties mOtherUser1Properties =
+                    new UserProperties.Builder() // private user
+                            .setShowInSharingSurfaces(
+                                    UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE)
+                            .setCrossProfileContentSharingStrategy(
+                                    UserProperties
+                                            .CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT)
+                            .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_HIDDEN)
+                            .build();
+
+            UserProperties mOtherUser2Properties =
+                    new UserProperties.Builder() // clone user
+                            .setShowInSharingSurfaces(
+                                    UserProperties.SHOW_IN_SHARING_SURFACES_WITH_PARENT)
+                            .setCrossProfileContentSharingStrategy(
+                                    UserProperties
+                                            .CROSS_PROFILE_CONTENT_SHARING_DELEGATE_FROM_PARENT)
+                            .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_DEFAULT)
+                            .build();
 
             // get user properties
             when(mMockUserManager.getUserProperties(mPersonalUser))
@@ -109,86 +167,301 @@ public class UserManagerStateTest {
             when(mMockUserManager.getUserProperties(mOtherUser2)).thenReturn(mOtherUser2Properties);
         }
 
-        when(mMockContext.getSystemServiceName(UserManager.class)).thenReturn(
-                "mockUserManager");
+        when(mMockContext.getSystemServiceName(UserManager.class)).thenReturn("mockUserManager");
         when(mMockContext.getSystemService(UserManager.class)).thenReturn(mMockUserManager);
         when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
     }
 
+    @Test
+    public void testCrossProfileAccessWithDelegationVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV());
+
+        // Return a ResolveInfo for the correct managed profile.
+        when(mMockPackageManager.queryIntentActivitiesAsUser(
+                        any(Intent.class), anyInt(), any(UserHandle.class)))
+                .thenReturn(List.of());
+
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
+                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1));
+
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setIntentAndCheckRestrictions(new Intent());
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser)))
+                                    .isFalse();
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mOtherUser1)))
+                                    .isTrue();
+                        });
+    }
+
+    @Test
+    public void testCrossProfileAccessWithDelegationManagedToPrivateVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV());
+
+        // Return a ResolveInfo for the personal profile only.
+        when(mMockPackageManager.queryIntentActivitiesAsUser(
+                        any(Intent.class), anyInt(), eq(mManagedUser)))
+                .thenReturn(List.of(new ReflectedResolveInfo(mPersonalUser.getIdentifier())));
+
+        initializeUserManagerState(
+                UserId.of(mManagedUser),
+                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1));
+
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setIntentAndCheckRestrictions(new Intent());
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mPersonalUser)))
+                                    .isTrue();
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mOtherUser1)))
+                                    .isTrue();
+                        });
+    }
+
+    @Test
+    public void testCrossProfileAccessWithMultipleManagedProfilesIsAllowedVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV());
+
+        UserProperties mManagedUser2Properties =
+                new UserProperties.Builder() // managed user
+                        .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE)
+                        .setCrossProfileContentSharingStrategy(
+                                UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION)
+                        .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_PAUSED)
+                        .build();
+        when(mMockUserManager.getProfileParent(mManagedUser2)).thenReturn(mPersonalUser);
+        when(mMockUserManager.isManagedProfile(mManagedUser2.getIdentifier())).thenReturn(true);
+        when(mMockUserManager.getUserProperties(mManagedUser2)).thenReturn(mManagedUser2Properties);
+
+        // Return a ResolveInfo for the correct managed profile.
+        when(mMockPackageManager.queryIntentActivitiesAsUser(
+                        any(Intent.class), anyInt(), eq(mPersonalUser)))
+                .thenReturn(List.of(new ReflectedResolveInfo(mManagedUser2.getIdentifier())));
+
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
+                Arrays.asList(mPersonalUser, mManagedUser, mManagedUser2));
+
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setIntentAndCheckRestrictions(new Intent());
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser)))
+                                    .isFalse();
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser2)))
+                                    .isTrue();
+                        });
+    }
+
+    @Test
+    public void testCrossProfileAccessWithMultipleManagedProfilesIsNotAllowedVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV());
+
+        UserProperties mManagedUser2Properties =
+                new UserProperties.Builder() // managed user
+                        .setShowInSharingSurfaces(UserProperties.SHOW_IN_SHARING_SURFACES_SEPARATE)
+                        .setCrossProfileContentSharingStrategy(
+                                UserProperties.CROSS_PROFILE_CONTENT_SHARING_NO_DELEGATION)
+                        .setShowInQuietMode(UserProperties.SHOW_IN_QUIET_MODE_PAUSED)
+                        .build();
+        when(mMockUserManager.getProfileParent(mManagedUser2)).thenReturn(mPersonalUser);
+        when(mMockUserManager.isManagedProfile(mManagedUser2.getIdentifier())).thenReturn(true);
+        when(mMockUserManager.getUserProperties(mManagedUser2)).thenReturn(mManagedUser2Properties);
+
+        // Return a ResolveInfo for the OTHER managed profile.
+        when(mMockPackageManager.queryIntentActivitiesAsUser(
+                        any(Intent.class), anyInt(), eq(mPersonalUser)))
+                .thenReturn(List.of(new ReflectedResolveInfo(mManagedUser.getIdentifier())));
+
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
+                Arrays.asList(mPersonalUser, mManagedUser, mManagedUser2));
+
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setIntentAndCheckRestrictions(new Intent());
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser)))
+                                    .isTrue();
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser2)))
+                                    .isFalse();
+                        });
+    }
+
+    @Test
+    public void testCrossProfileAccessWithMultipleManagedProfilesIsAllowedUMinus() {
+        assumeFalse(SdkLevel.isAtLeastV());
+
+        when(mMockUserManager.getProfileParent(mManagedUser2)).thenReturn(mPersonalUser);
+        when(mMockUserManager.isManagedProfile(mManagedUser2.getIdentifier())).thenReturn(true);
+
+        // Return a ResolveInfo for the correct managed profile.
+        when(mMockPackageManager.queryIntentActivitiesAsUser(
+                        any(Intent.class), anyInt(), eq(mPersonalUser)))
+                .thenReturn(List.of(new ReflectedResolveInfo(mManagedUser2.getIdentifier())));
+
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
+                Arrays.asList(mPersonalUser, mManagedUser, mManagedUser2));
+
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setIntentAndCheckRestrictions(new Intent());
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser2)))
+                                    .isTrue();
+                        });
+    }
+
+    @Test
+    public void testCrossProfileAccessWithMultipleManagedProfilesIsNotAllowedUMinus() {
+        assumeFalse(SdkLevel.isAtLeastV());
+
+        when(mMockUserManager.getProfileParent(mManagedUser2)).thenReturn(mPersonalUser);
+        when(mMockUserManager.isManagedProfile(mManagedUser2.getIdentifier())).thenReturn(true);
+
+        // Return a ResolveInfo for the OTHER managed profile.
+        when(mMockPackageManager.queryIntentActivitiesAsUser(
+                        any(Intent.class), anyInt(), eq(mPersonalUser)))
+                .thenReturn(List.of(new ReflectedResolveInfo(mManagedUser.getIdentifier())));
+
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
+                Arrays.asList(mPersonalUser, mManagedUser, mManagedUser2));
+
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setIntentAndCheckRestrictions(new Intent());
+                            assertThat(
+                                            mUserManagerState.isCrossProfileAllowedToUser(
+                                                    UserId.of(mManagedUser2)))
+                                    .isFalse();
+                        });
+    }
+
     @Test
     public void testUserManagerStateThrowsErrorIfCalledFromNonMainThread() {
-        initializeUserManagerState(UserId.of(mPersonalUser),
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
                 Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
         assertThrows(IllegalStateException.class, () -> mUserManagerState.isMultiUserProfiles());
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.isManagedUserProfile(UserId.of(mManagedUser)));
-        assertThrows(IllegalStateException.class,
-                () -> mUserManagerState.getCurrentUserProfileId());
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class, () -> mUserManagerState.getCurrentUserProfileId());
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.getCrossProfileAllowedStatusForAll());
         assertThrows(IllegalStateException.class, () -> mUserManagerState.getAllUserProfileIds());
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.updateProfileOffValuesAndPostCrossProfileStatus());
-        assertThrows(IllegalStateException.class,
-                () -> mUserManagerState.waitForMediaProviderToBeAvailable(
-                        UserId.of(mPersonalUser)));
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mUserManagerState.waitForMediaProviderToBeAvailable(
+                                UserId.of(mPersonalUser)));
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.isCrossProfileAllowedToUser(UserId.of(mManagedUser)));
         assertThrows(IllegalStateException.class, () -> mUserManagerState.resetUserIds());
         assertThrows(IllegalStateException.class, () -> mUserManagerState.isCurrentUserSelected());
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.isBlockedByAdmin(UserId.of(mManagedUser)));
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.isProfileOff(UserId.of(mManagedUser)));
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.getShowInQuietMode(UserId.of(mOtherUser1)));
-        assertThrows(IllegalStateException.class,
+        assertThrows(
+                IllegalStateException.class,
                 () -> mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mManagedUser)));
-        assertThrows(IllegalStateException.class,
-                () -> mUserManagerState.isUserSelectedAsCurrentUserProfile(
-                        UserId.of(mPersonalUser)));
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mUserManagerState.isUserSelectedAsCurrentUserProfile(
+                                UserId.of(mPersonalUser)));
     }
 
     @Test
     public void testGetAllUserProfileIdsThatNeedToShowInPhotoPicker_currentUserIsPersonalUser() {
-        initializeUserManagerState(UserId.of(mPersonalUser),
-                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mManagedUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser), UserId.of(mManagedUser));
-
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-        });
+        initializeUserManagerState(
+                UserId.of(mPersonalUser),
+                Arrays.asList(mPersonalUser, mManagedUser));
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            List<UserId> userIdList =
+                                    Arrays.asList(
+                                            UserId.of(mPersonalUser),
+                                            UserId.of(mManagedUser));
+
+                            assertThat(mUserManagerState.getAllUserProfileIds())
+                                    .containsExactlyElementsIn(userIdList);
+                        });
     }
 
     @Test
     public void testGetAllUserProfileIdsThatNeedToShowInPhotoPicker_currentUserIsManagedUser() {
-        initializeUserManagerState(UserId.of(mManagedUser),
-                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mManagedUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser), UserId.of(mManagedUser));
-
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-        });
+        initializeUserManagerState(
+                UserId.of(mManagedUser),
+                Arrays.asList(mPersonalUser, mManagedUser));
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            List<UserId> userIdList =
+                                    Arrays.asList(
+                                            UserId.of(mPersonalUser),
+                                            UserId.of(mManagedUser));
+
+                            assertThat(mUserManagerState.getAllUserProfileIds())
+                                    .containsExactlyElementsIn(userIdList);
+                        });
     }
+
     @Test
-    public void testGetAllUserProfileIdsThatNeedToShowInPhotoPicker_currentUserIsOtherUser1() {
-        initializeUserManagerState(UserId.of(mOtherUser1),
-                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mManagedUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser), UserId.of(mManagedUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-        });
+    public void
+            testGetAllUserProfileIdsThatNeedToShowInPhotoPicker_currentUserIsOtherUser1VPlus() {
+        assumeTrue(SdkLevel.isAtLeastV());
+        initializeUserManagerState(
+                UserId.of(mOtherUser1),
+                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1));
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            List<UserId> userIdList =
+                                    Arrays.asList(
+                                            UserId.of(mPersonalUser),
+                                            UserId.of(mManagedUser),
+                                            UserId.of(mOtherUser1));
+
+                            assertThat(mUserManagerState.getAllUserProfileIds())
+                                    .containsExactlyElementsIn(userIdList);
+                        });
     }
 
     @Test
@@ -196,157 +469,108 @@ public class UserManagerStateTest {
         // if current user is personal and no other profile is available
         UserId currentUser = UserId.of(mPersonalUser);
         initializeUserManagerState(currentUser, Arrays.asList(mPersonalUser));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            assertThat(mUserManagerState.isMultiUserProfiles()).isFalse();
-
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mPersonalUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(Arrays.asList(UserId.of(mPersonalUser)));
-        });
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            assertThat(mUserManagerState.isMultiUserProfiles()).isFalse();
+
+                            assertThat(mUserManagerState.getCurrentUserProfileId())
+                                    .isEqualTo(UserId.of(mPersonalUser));
+                            assertThat(mUserManagerState.getAllUserProfileIds())
+                                    .containsExactlyElementsIn(
+                                            Arrays.asList(UserId.of(mPersonalUser)));
+                        });
     }
 
-
     @Test
     public void testUserIds_multiUserProfilesAvailable_currentUserIsPersonalUser() {
+        assumeFalse(SdkLevel.isAtLeastV());
         UserId currentUser = UserId.of(mPersonalUser);
 
         // if available user profiles are {personal , managed, otherUser1 }
-        initializeUserManagerState(currentUser,
-                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            assertThat(mUserManagerState.isMultiUserProfiles()).isTrue();
-
-            assertThat(mUserManagerState.getCurrentUserProfileId()).isEqualTo(UserId.of(
-                    mPersonalUser));
-
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mManagedUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser), UserId.of(mManagedUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-
-            assertThat(mUserManagerState.isManagedUserProfile(
-                    mUserManagerState.getCurrentUserProfileId())).isFalse();
-        });
-
-        // if available user profiles are {personal , otherUser1 }
-        initializeUserManagerState(currentUser, Arrays.asList(mPersonalUser, mOtherUser1));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-
-            if (SdkLevel.isAtLeastV()) {
-                assertThat(mUserManagerState.isMultiUserProfiles()).isTrue();
-            } else {
-                assertThat(mUserManagerState.isMultiUserProfiles()).isFalse();
-            }
-
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-        });
-
-
-        // if available user profiles are {personal , otherUser2 }
-        initializeUserManagerState(currentUser, Arrays.asList(mPersonalUser, mOtherUser2));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            assertThat(mUserManagerState.isMultiUserProfiles()).isFalse();
-
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mPersonalUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(Arrays.asList(UserId.of(mPersonalUser)));
-        });
+        initializeUserManagerState(
+                currentUser, Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1));
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            assertThat(mUserManagerState.isMultiUserProfiles()).isTrue();
+
+                            assertThat(mUserManagerState.getCurrentUserProfileId())
+                                    .isEqualTo(UserId.of(mPersonalUser));
+
+                            List<UserId> userIdList = Arrays.asList(
+                                                    UserId.of(mPersonalUser),
+                                                    UserId.of(mManagedUser));
+                            assertThat(mUserManagerState.getAllUserProfileIds())
+                                    .containsExactlyElementsIn(userIdList);
+
+                            assertThat(
+                                            mUserManagerState.isManagedUserProfile(
+                                                    mUserManagerState.getCurrentUserProfileId()))
+                                    .isFalse();
+                        });
     }
 
     @Test
-    public void testUserIds_multiUserProfilesAvailable_currentUserIsOtherUser2() {
-        UserId currentUser = UserId.of(mOtherUser2);
+    public void testUserIds_multiUserProfilesAvailable_currentUserIsPersonalUserVPlus() {
+        assumeTrue(SdkLevel.isAtLeastV());
+        UserId currentUser = UserId.of(mPersonalUser);
 
-        initializeUserManagerState(currentUser,
-                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            assertThat(mUserManagerState.isMultiUserProfiles()).isTrue();
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mOtherUser2));
-
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mManagedUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser), UserId.of(mManagedUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-
-        });
-
-        initializeUserManagerState(currentUser, Arrays.asList(mPersonalUser, mOtherUser2));
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            assertThat(mUserManagerState.isMultiUserProfiles()).isFalse();
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(Arrays.asList(UserId.of(mPersonalUser)));
-
-        });
+        // if available user profiles are {personal , managed, otherUser1 }
+        initializeUserManagerState(
+                currentUser, Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1));
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            assertThat(mUserManagerState.isMultiUserProfiles()).isTrue();
+
+                            assertThat(mUserManagerState.getCurrentUserProfileId())
+                                    .isEqualTo(UserId.of(mPersonalUser));
+
+                            List<UserId> userIdList =
+                                    Arrays.asList(
+                                            UserId.of(mPersonalUser),
+                                            UserId.of(mManagedUser),
+                                            UserId.of(mOtherUser1));
+                            assertThat(mUserManagerState.getAllUserProfileIds())
+                                    .containsExactlyElementsIn(userIdList);
+
+                            assertThat(
+                                            mUserManagerState.isManagedUserProfile(
+                                                    mUserManagerState.getCurrentUserProfileId()))
+                                    .isFalse();
+                        });
     }
 
     @Test
     public void testCurrentUser_AfterSettingASpecificUserAsCurrentUser() {
         UserId currentUser = UserId.of(mPersonalUser);
-        initializeUserManagerState(currentUser,
-                Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
+        initializeUserManagerState(
+                currentUser, Arrays.asList(mPersonalUser, mManagedUser, mOtherUser1, mOtherUser2));
 
         // set current user as managed profile
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mManagedUser));
-
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mManagedUser));
-            assertThat(mUserManagerState.isManagedUserProfile(
-                    mUserManagerState.getCurrentUserProfileId())).isTrue();
-        });
-
-        // set current user as otherUser2
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mOtherUser2));
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mManagedUser));
-        });
-
-        // set current user as otherUser1
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mOtherUser1));
-            UserHandle currentUserProfile = SdkLevel.isAtLeastV() ? mOtherUser1 : mManagedUser;
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(currentUserProfile));
-        });
-
-        // set current user as personalUser
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mPersonalUser));
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mPersonalUser));
-        });
-
-        // set current user otherUser3
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mOtherUser3));
-            assertThat(mUserManagerState.getCurrentUserProfileId())
-                    .isEqualTo(UserId.of(mPersonalUser));
-
-            List<UserId> userIdList = SdkLevel.isAtLeastV() ? Arrays.asList(
-                    UserId.of(mPersonalUser), UserId.of(mManagedUser), UserId.of(mOtherUser1))
-                    : Arrays.asList(UserId.of(mPersonalUser), UserId.of(mManagedUser));
-            assertThat(mUserManagerState.getAllUserProfileIds())
-                    .containsExactlyElementsIn(userIdList);
-        });
-
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState.setUserAsCurrentUserProfile(UserId.of(mManagedUser));
+
+                            assertThat(mUserManagerState.getCurrentUserProfileId())
+                                    .isEqualTo(UserId.of(mManagedUser));
+                            assertThat(
+                                            mUserManagerState.isManagedUserProfile(
+                                                    mUserManagerState.getCurrentUserProfileId()))
+                                    .isTrue();
+                        });
     }
 
-
-
     private void initializeUserManagerState(UserId current, List<UserHandle> usersOnDevice) {
         when(mMockUserManager.getUserProfiles()).thenReturn(usersOnDevice);
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
-            mUserManagerState = new UserManagerState.RuntimeUserManagerState(mMockContext, current);
-        });
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () -> {
+                            mUserManagerState =
+                                    new UserManagerState.RuntimeUserManagerState(
+                                            mMockContext, current);
+                        });
     }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/data/model/ItemTest.java b/tests/src/com/android/providers/media/photopicker/data/model/ItemTest.java
index b13db5fba..1cd26f9ea 100644
--- a/tests/src/com/android/providers/media/photopicker/data/model/ItemTest.java
+++ b/tests/src/com/android/providers/media/photopicker/data/model/ItemTest.java
@@ -45,6 +45,7 @@ import org.junit.runner.RunWith;
 
 import java.time.LocalDate;
 import java.time.ZoneId;
+import java.util.Locale;
 
 @RunWith(AndroidJUnit4.class)
 public class ItemTest {
@@ -62,7 +63,7 @@ public class ItemTest {
         final String mimeType = "image/png";
         final long duration = 1000;
         final Cursor cursor = generateCursorForItem(id, mimeType, dateTaken, generationModified,
-                duration, _SPECIAL_FORMAT_NONE);
+                duration, _SPECIAL_FORMAT_NONE, UserHandle.USER_CURRENT);
         cursor.moveToFirst();
 
         final Item item = new Item(cursor, UserId.CURRENT_USER);
@@ -88,10 +89,12 @@ public class ItemTest {
         final long generationModified = 1L;
         final String mimeType = "image/png";
         final long duration = 1000;
+        // Some userId other than current user, hence adding 10 to the current user.
+        final int testUser = UserHandle.USER_CURRENT + 10;
         final Cursor cursor = generateCursorForItem(id, mimeType, dateTaken, generationModified,
-                duration, _SPECIAL_FORMAT_NONE);
+                duration, _SPECIAL_FORMAT_NONE, testUser);
         cursor.moveToFirst();
-        final UserId userId = UserId.of(UserHandle.of(10));
+        final UserId userId = UserId.of(UserHandle.of(testUser));
 
         final Item item = new Item(cursor, userId);
 
@@ -101,7 +104,10 @@ public class ItemTest {
         assertThat(item.getMimeType()).isEqualTo(mimeType);
         assertThat(item.getDuration()).isEqualTo(duration);
         assertThat(item.getContentUri()).isEqualTo(
-                Uri.parse("content://10@com.android.providers.media.photopicker/media/1"));
+                Uri.parse(String.format(
+                        Locale.ROOT,
+                        "content://%d@com.android.providers.media.photopicker/media/1",
+                        testUser)));
 
         assertThat(item.isImage()).isTrue();
 
@@ -306,7 +312,7 @@ public class ItemTest {
     }
 
     private static Cursor generateCursorForItem(String id, String mimeType, long dateTaken,
-            long generationModified, long duration, int specialFormat) {
+            long generationModified, long duration, int specialFormat, int userId) {
         final MatrixCursor cursor = new MatrixCursor(MediaColumns.ALL_PROJECTION);
         cursor.addRow(new Object[] {
                 id,
@@ -322,7 +328,9 @@ public class ItemTest {
                 500, // height
                 0, // orientation
                 "/storage/emulated/0/foo", // data
-                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY
+                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY,
+                null, //owner_package_name
+                userId
                 }
         );
         return cursor;
diff --git a/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java
index d74709dfb..8ea42965e 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java
@@ -42,6 +42,7 @@ import android.database.Cursor;
 import android.database.MatrixCursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.net.Uri;
+import android.os.Bundle;
 import android.platform.test.annotations.EnableFlags;
 import android.provider.CloudMediaProviderContract;
 
@@ -56,12 +57,15 @@ import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
 import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
 import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
 import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.Mock;
 
@@ -125,7 +129,7 @@ public class MediaInMediaSetsSyncWorkerTest {
                 new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
                         .setInputData(
                                 new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, 56,
-                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, "mediaSetPickerId",
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, 1L,
                                         SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
                         .build();
 
@@ -165,7 +169,7 @@ public class MediaInMediaSetsSyncWorkerTest {
                 new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
                         .setInputData(
                                 new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
-                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, "mediaSetPickerId",
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, 1L,
                                         SYNC_WORKER_INPUT_AUTHORITY, "")))
                         .build();
 
@@ -179,11 +183,11 @@ public class MediaInMediaSetsSyncWorkerTest {
 
     @Test
     public void testMediaInMediaSetSyncWithCloudProvider() throws
-            ExecutionException, InterruptedException {
+            ExecutionException, InterruptedException, RequestObsoleteException {
 
         String categoryId = "categoryId";
         String auth = String.valueOf(SYNC_CLOUD_ONLY);
-        String mediaSetPickerId = "";
+        long mediaSetPickerId = 1L;
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add("img");
@@ -192,16 +196,23 @@ public class MediaInMediaSetsSyncWorkerTest {
                 mDatabase, c, categoryId, auth, mimeTypes);
         assertEquals("Count of inserted media sets should be equal to the cursor size",
                 /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, auth);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
         Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
-                mDatabase, categoryId, auth, mimeTypes);
+                mDatabase, requestParams);
         if (fetchMediaSetCursor.moveToFirst()) {
-            mediaSetPickerId = fetchMediaSetCursor.getString(
+            mediaSetPickerId = fetchMediaSetCursor.getLong(
                     fetchMediaSetCursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
         }
 
-        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
-        SearchProvider.setSearchResults(inputCursor);
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
+        SearchProvider.setMediaSetContents(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
@@ -247,7 +258,7 @@ public class MediaInMediaSetsSyncWorkerTest {
                                     ))
                     );
 
-                    assertEquals(mediaInMediaSetsTableCursor.getString(
+                    assertEquals((long) mediaInMediaSetsTableCursor.getLong(
                                     mediaInMediaSetsTableCursor.getColumnIndex(
                                             PickerSQLConstants.MediaInMediaSetsTableColumns
                                                     .MEDIA_SETS_PICKER_ID.getColumnName())),
@@ -291,13 +302,13 @@ public class MediaInMediaSetsSyncWorkerTest {
 
     @Test
     public void testMediaInMediaSetsSyncLocalProvider() throws
-            ExecutionException, InterruptedException {
+            ExecutionException, InterruptedException, RequestObsoleteException {
 
         doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
 
         String categoryId = "categoryId";
         String auth = String.valueOf(SYNC_LOCAL_ONLY);
-        String mediaSetPickerId = "";
+        long mediaSetPickerId = 1L;
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add("img");
@@ -306,16 +317,22 @@ public class MediaInMediaSetsSyncWorkerTest {
                 mDatabase, c, categoryId, auth, mimeTypes);
         assertEquals("Count of inserted media sets should be equal to the cursor size",
                 /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, auth);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
+        extras.putStringArrayList(MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
         Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
-                mDatabase, categoryId, auth, mimeTypes);
+                mDatabase, requestParams);
         if (fetchMediaSetCursor.moveToFirst()) {
-            mediaSetPickerId = fetchMediaSetCursor.getString(
+            mediaSetPickerId = fetchMediaSetCursor.getLong(
                     fetchMediaSetCursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
         }
 
-        final Cursor inputCursor = SearchProvider.DEFAULT_LOCAL_SEARCH_RESULTS;
-        SearchProvider.setSearchResults(inputCursor);
+        final Cursor inputCursor = SearchProvider.getDefaultLocalSearchResults();
+        SearchProvider.setMediaSetContents(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
@@ -361,7 +378,7 @@ public class MediaInMediaSetsSyncWorkerTest {
                                     ))
                     );
 
-                    assertEquals(mediaInMediaSetsTableCursor.getString(
+                    assertEquals((long) mediaInMediaSetsTableCursor.getLong(
                                     mediaInMediaSetsTableCursor.getColumnIndex(
                                             PickerSQLConstants.MediaInMediaSetsTableColumns
                                                     .MEDIA_SETS_PICKER_ID.getColumnName())),
@@ -388,6 +405,86 @@ public class MediaInMediaSetsSyncWorkerTest {
                 .markSyncCompleted(any());
     }
 
+    @Test
+    @Ignore("Enable when b/391639613 is fixed")
+    public void testMediaSetContentsSyncLoop() throws
+            ExecutionException, InterruptedException, RequestObsoleteException {
+
+        String categoryId = "categoryId";
+        String auth = String.valueOf(SYNC_CLOUD_ONLY);
+        long mediaSetPickerId = 1L;
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add("img");
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, categoryId, auth, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, auth);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
+        Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, requestParams);
+        if (fetchMediaSetCursor.moveToFirst()) {
+            mediaSetPickerId = fetchMediaSetCursor.getLong(
+                    fetchMediaSetCursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
+        }
+
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
+        final String repeatPageToken = "LOOP";
+        final Bundle bundle = new Bundle();
+        bundle.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, repeatPageToken);
+        inputCursor.setExtras(bundle);
+        SearchProvider.setMediaSetContents(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(new Data(
+                                Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, mediaSetPickerId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor mediaInMediaSetsTableCursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(mediaInMediaSetsTableCursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(mediaInMediaSetsTableCursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+        }
+
+        verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
     private Cursor getCursorForMediaSetInsertionTest() {
         String[] columns = new String[]{
                 CloudMediaProviderContract.MediaSetColumns.ID,
@@ -406,11 +503,11 @@ public class MediaInMediaSetsSyncWorkerTest {
 
     @Test
     public void testMediaInMediaSetSyncComplete() throws
-            ExecutionException, InterruptedException {
+            ExecutionException, InterruptedException, RequestObsoleteException {
 
         String categoryId = "categoryId";
         String auth = String.valueOf(SYNC_CLOUD_ONLY);
-        String mediaSetPickerId = "";
+        long mediaSetPickerId = 1L;
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add("img");
@@ -419,18 +516,24 @@ public class MediaInMediaSetsSyncWorkerTest {
                 mDatabase, c, categoryId, auth, mimeTypes);
         assertEquals("Count of inserted media sets should be equal to the cursor size",
                 /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, auth);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
+        extras.putStringArrayList(MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
         Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
-                mDatabase, categoryId, auth, mimeTypes);
+                mDatabase, requestParams);
         if (fetchMediaSetCursor.moveToFirst()) {
-            mediaSetPickerId = fetchMediaSetCursor.getString(
+            mediaSetPickerId = fetchMediaSetCursor.getLong(
                     fetchMediaSetCursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
         }
         MediaSetsDatabaseUtil.updateMediaInMediaSetSyncResumeKey(
                 mDatabase, mediaSetPickerId, SYNC_COMPLETE_RESUME_KEY);
 
-        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
-        SearchProvider.setSearchResults(inputCursor);
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
+        SearchProvider.setMediaSetContents(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
diff --git a/tests/src/com/android/providers/media/photopicker/sync/MediaSetsResetWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/MediaSetsResetWorkerTest.java
new file mode 100644
index 000000000..c318151d5
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/sync/MediaSetsResetWorkerTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_CATEGORY_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.initializeTestWorkManager;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_PROVIDER;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertAddMediaOperation;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getCloudMediaCursor;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.work.Data;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkInfo;
+import androidx.work.WorkManager;
+
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+
+public class MediaSetsResetWorkerTest {
+
+    private SQLiteDatabase mDatabase;
+    private PickerDbFacade mFacade;
+    private Context mContext;
+    private final String mMediaSetId = "mediaSetId";
+    private final String mCategoryId = "categoryId";
+    private final String mAuthority = "auth";
+    private final String mMimeType = "img";
+    private final String mDisplayName = "name";
+    private final String mCoverId = "id";
+    @Mock
+    private PickerSyncController mMockSyncController;
+    @Mock
+    private SyncTracker mLocalMediaSetsSyncTracker;
+    @Mock
+    private SyncTracker mCloudMediaSetsSyncTracker;
+
+    @Before
+    public void setup() {
+        initMocks(this);
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        PickerSyncController.setInstance(mMockSyncController);
+        SyncTrackerRegistry.setCloudMediaSetsSyncTracker(mCloudMediaSetsSyncTracker);
+        SyncTrackerRegistry.setLocalMediaSetsSyncTracker(mLocalMediaSetsSyncTracker);
+        initializeTestWorkManager(mContext);
+        final File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        final PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(
+                mContext, new PickerSyncLockManager(), LOCAL_PICKER_PROVIDER_AUTHORITY);
+        mFacade.setCloudProvider(CLOUD_PROVIDER);
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testMediaSetsAndMediaSetsContentCacheReset() throws
+            ExecutionException, InterruptedException, RequestObsoleteException {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        Long mediaSetPickerId = 1L;
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsResetWorker.class)
+                        .setInputData(new Data(Map.of(
+                                SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                SYNC_WORKER_INPUT_AUTHORITY, mAuthority)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursorFromMediaSetTable = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursorFromMediaSetTable)
+                    .isNotNull();
+            assertEquals(/*expected*/ 0, /*actual*/ cursorFromMediaSetTable.getCount());
+        }
+
+        try (Cursor cursorFromMediaInMediaSetTable = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursorFromMediaInMediaSetTable)
+                    .isNotNull();
+            assertEquals(/*expected */ 0, /*actual*/ cursorFromMediaInMediaSetTable.getCount());
+        }
+    }
+
+    private Cursor getCursorForMediaSetInsertionTest() {
+        String[] columns = new String[]{
+                CloudMediaProviderContract.MediaSetColumns.ID,
+                CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+        };
+
+        MatrixCursor cursor = new MatrixCursor(columns);
+        cursor.addRow(new Object[] { mMediaSetId, mDisplayName, mCoverId });
+
+        return cursor;
+    }
+
+    private ContentValues getContentValues(
+            String localId, String cloudId, Long mediaSetPickerId) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.CLOUD_ID.getColumnName(), cloudId);
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.LOCAL_ID.getColumnName(), localId);
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.MEDIA_SETS_PICKER_ID
+                        .getColumnName(),
+                mediaSetPickerId);
+        return contentValues;
+    }
+
+}
diff --git a/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java
index 3d0b36252..3733cc453 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java
@@ -39,6 +39,7 @@ import static org.mockito.MockitoAnnotations.initMocks;
 import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
 import android.platform.test.annotations.EnableFlags;
 import android.provider.CloudMediaProviderContract;
 
@@ -232,7 +233,7 @@ public class MediaSetsSyncWorkerTest {
         final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
         assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
 
-        Cursor cursorFromSearchProvider = SearchProvider.getCursorForMediaSetSyncTest();
+        Cursor cursorFromSearchProvider = SearchProvider.sMediaSets;
 
         try (Cursor cursorFromMediaSetTable = mDatabase.rawQuery(
                 new SelectSQLiteQueryBuilder(mDatabase).setTables(
@@ -280,7 +281,7 @@ public class MediaSetsSyncWorkerTest {
         final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
         assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
 
-        Cursor cursorFromSearchProvider = SearchProvider.getCursorForMediaSetSyncTest();
+        Cursor cursorFromSearchProvider = SearchProvider.sMediaSets;
 
         try (Cursor cursorFromMediaSetTable = mDatabase.rawQuery(
                 new SelectSQLiteQueryBuilder(mDatabase).setTables(
@@ -297,6 +298,60 @@ public class MediaSetsSyncWorkerTest {
         }
     }
 
+    @Test
+    public void testMediaSetsSyncLoop() throws
+            ExecutionException, InterruptedException {
+        // Setup
+        final String repeatPageToken = "LOOP";
+        final Cursor cursorFromSearchProvider =
+                SearchProvider.getDefaultCursorForMediaSetSyncTest();
+        final Bundle bundle = new Bundle();
+        bundle.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, repeatPageToken);
+        cursorFromSearchProvider.setExtras(bundle);
+        SearchProvider.setMediaSets(cursorFromSearchProvider);
+
+        // Run test
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursorFromMediaSetTable = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursorFromMediaSetTable)
+                    .isNotNull();
+            assertEquals(cursorFromMediaSetTable.getCount(), cursorFromSearchProvider.getCount());
+
+            compareMediaSetCursorsForMediaSetProperties(
+                    cursorFromMediaSetTable, cursorFromSearchProvider);
+        }
+
+        verify(mLocalMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mLocalMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mCloudMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mCloudMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
 
     private void compareMediaSetCursorsForMediaSetProperties(
             Cursor cursorFromMediaSetTable, Cursor cursorFromSearchProvider) {
diff --git a/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java b/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java
index 049655e47..59473d7e1 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java
@@ -16,13 +16,21 @@
 
 package com.android.providers.media.photopicker.sync;
 
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.EXPIRED_SUGGESTIONS_RESET;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.EXTRA_MIME_TYPES;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.IMMEDIATE_CLOUD_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SEARCH_RESULTS_FULL_CACHE_RESET;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SEARCH_PARTIAL_CACHE_RESET;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SEARCH_RESULTS_RESET_DELAY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SHOULD_SYNC_GRANTS;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_AND_CLOUD;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_CATEGORY_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_RESET_TYPE;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SEARCH_REQUEST_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
 import static com.android.providers.media.util.BackgroundThreadUtils.waitForIdle;
@@ -31,9 +39,10 @@ import static com.google.common.truth.Truth.assertThat;
 
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.MockitoAnnotations.initMocks;
@@ -42,6 +51,10 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.res.Resources;
 import android.os.Bundle;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 
 import androidx.work.ExistingPeriodicWorkPolicy;
 import androidx.work.ExistingWorkPolicy;
@@ -49,27 +62,40 @@ import androidx.work.OneTimeWorkRequest;
 import androidx.work.Operation;
 import androidx.work.PeriodicWorkRequest;
 import androidx.work.WorkContinuation;
+import androidx.work.WorkInfo;
 import androidx.work.WorkManager;
 import androidx.work.WorkRequest;
 
 import com.android.providers.media.TestConfigStore;
 import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.data.PickerSyncRequestExtras;
+import com.android.providers.media.photopicker.v2.model.MediaInMediaSetSyncRequestParams;
 import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
 
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
 
 public class PickerSyncManagerTest {
+    @Rule
+    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+
     private PickerSyncManager mPickerSyncManager;
     private TestConfigStore mConfigStore;
     @Mock
@@ -98,6 +124,9 @@ public class PickerSyncManagerTest {
         mConfigStore = new TestConfigStore();
         mConfigStore.enableCloudMediaFeatureAndSetAllowedCloudProviderPackages(
                 "com.hooli.super.awesome.cloudpicker");
+        final SettableFuture<List<WorkInfo>> listenableFuture = SettableFuture.create();
+        listenableFuture.set(List.of());
+        doReturn(listenableFuture).when(mMockWorkManager).getWorkInfosByTag(anyString());
     }
 
 
@@ -118,10 +147,10 @@ public class PickerSyncManagerTest {
     }
 
     @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     public void testSchedulePeriodicSyncs() {
         setupPickerSyncManager(/* schedulePeriodicSyncs */ true);
 
-        // The third call here comes from the EndlessWorker
         verify(mMockWorkManager, times(2))
                 .enqueueUniquePeriodicWork(anyString(),
                         any(),
@@ -155,11 +184,63 @@ public class PickerSyncManagerTest {
     }
 
     @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    public void testSchedulePeriodicSyncsWithSearchEnabled() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ true);
+
+        verify(mMockWorkManager, times(3))
+                .enqueueUniquePeriodicWork(anyString(),
+                        any(),
+                        mPeriodicWorkRequestArgumentCaptor.capture());
+
+        final PeriodicWorkRequest periodicWorkRequest =
+                mPeriodicWorkRequestArgumentCaptor.getAllValues().get(0);
+        assertThat(periodicWorkRequest.getWorkSpec().workerClassName)
+                .isEqualTo(ProactiveSyncWorker.class.getName());
+        assertThat(periodicWorkRequest.getWorkSpec().expedited).isFalse();
+        assertThat(periodicWorkRequest.getWorkSpec().isPeriodic()).isTrue();
+        assertThat(periodicWorkRequest.getWorkSpec().id).isNotNull();
+        assertThat(periodicWorkRequest.getWorkSpec().constraints.requiresCharging()).isTrue();
+        assertThat(periodicWorkRequest.getWorkSpec().constraints.requiresDeviceIdle()).isTrue();
+        assertThat(periodicWorkRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_AND_CLOUD);
+
+        final PeriodicWorkRequest periodicResetRequest =
+                mPeriodicWorkRequestArgumentCaptor.getAllValues().get(1);
+        assertThat(periodicResetRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaResetWorker.class.getName());
+        assertThat(periodicResetRequest.getWorkSpec().expedited).isFalse();
+        assertThat(periodicResetRequest.getWorkSpec().isPeriodic()).isTrue();
+        assertThat(periodicResetRequest.getWorkSpec().id).isNotNull();
+        assertThat(periodicResetRequest.getWorkSpec().constraints.requiresCharging()).isTrue();
+        assertThat(periodicResetRequest.getWorkSpec().constraints.requiresDeviceIdle()).isTrue();
+        assertThat(periodicResetRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_AND_CLOUD);
+
+        final PeriodicWorkRequest searchSuggestionsResetRequest =
+                mPeriodicWorkRequestArgumentCaptor.getAllValues().get(2);
+        assertThat(searchSuggestionsResetRequest.getWorkSpec().workerClassName)
+                .isEqualTo(SearchResetWorker.class.getName());
+        assertThat(searchSuggestionsResetRequest.getWorkSpec().expedited).isFalse();
+        assertThat(searchSuggestionsResetRequest.getWorkSpec().isPeriodic()).isTrue();
+        assertThat(searchSuggestionsResetRequest.getWorkSpec().id).isNotNull();
+        assertThat(searchSuggestionsResetRequest.getWorkSpec()
+                .constraints.requiresCharging()).isTrue();
+        assertThat(searchSuggestionsResetRequest.getWorkSpec()
+                .constraints.requiresDeviceIdle()).isTrue();
+        assertThat(searchSuggestionsResetRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_RESET_TYPE, -1))
+                .isEqualTo(EXPIRED_SUGGESTIONS_RESET);
+    }
+
+    @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
     public void testPeriodicWorkIsScheduledOnDeviceConfigChanges() {
 
         mConfigStore.disableCloudMediaFeature();
 
-
         setupPickerSyncManager(true);
 
         // Ensure no syncs have been scheduled yet.
@@ -173,8 +254,8 @@ public class PickerSyncManagerTest {
 
         waitForIdle();
 
-        // Ensure the syncs are now scheduled.
-        verify(mMockWorkManager, times(2))
+        // Ensure the media and album reset syncs are now scheduled.
+        verify(mMockWorkManager, atLeast(2))
                 .enqueueUniquePeriodicWork(anyString(),
                         any(),
                         mPeriodicWorkRequestArgumentCaptor.capture());
@@ -210,13 +291,76 @@ public class PickerSyncManagerTest {
         mConfigStore.disableCloudMediaFeature();
         waitForIdle();
 
+        // There should be 3 invocations, one for cancelling proactive media syncs,
+        // the other for albums reset and search reset syncs.
+        verify(mMockWorkManager, times(3)).cancelUniqueWork(anyString());
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    public void testOnDeviceConfigChangesWithSearchEnabled() {
+
+        mConfigStore.disableCloudMediaFeature();
+
+        setupPickerSyncManager(true);
+
+        // Ensure only search sync is scheduled
+        verify(mMockWorkManager, times(1))
+                .enqueueUniquePeriodicWork(anyString(),
+                        any(),
+                        mPeriodicWorkRequestArgumentCaptor.capture());
+        clearInvocations(mMockWorkManager);
+
+        mConfigStore.enableCloudMediaFeatureAndSetAllowedCloudProviderPackages(
+                "com.hooli.some.cloud.provider");
+
+        waitForIdle();
+
+        // Ensure the media and album reset syncs are now scheduled.
+        verify(mMockWorkManager, times(3))
+                .enqueueUniquePeriodicWork(anyString(),
+                        any(),
+                        mPeriodicWorkRequestArgumentCaptor.capture());
+
+        final PeriodicWorkRequest periodicWorkRequest =
+                mPeriodicWorkRequestArgumentCaptor.getAllValues().get(1);
+        assertThat(periodicWorkRequest.getWorkSpec().workerClassName)
+                .isEqualTo(ProactiveSyncWorker.class.getName());
+        assertThat(periodicWorkRequest.getWorkSpec().expedited).isFalse();
+        assertThat(periodicWorkRequest.getWorkSpec().isPeriodic()).isTrue();
+        assertThat(periodicWorkRequest.getWorkSpec().id).isNotNull();
+        assertThat(periodicWorkRequest.getWorkSpec().constraints.requiresCharging()).isTrue();
+        assertThat(periodicWorkRequest.getWorkSpec().constraints.requiresDeviceIdle()).isTrue();
+        assertThat(periodicWorkRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_AND_CLOUD);
+
+        final PeriodicWorkRequest periodicResetRequest =
+                mPeriodicWorkRequestArgumentCaptor.getAllValues().get(2);
+        assertThat(periodicResetRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaResetWorker.class.getName());
+        assertThat(periodicResetRequest.getWorkSpec().expedited).isFalse();
+        assertThat(periodicResetRequest.getWorkSpec().isPeriodic()).isTrue();
+        assertThat(periodicResetRequest.getWorkSpec().id).isNotNull();
+        assertThat(periodicResetRequest.getWorkSpec().constraints.requiresCharging()).isTrue();
+        assertThat(periodicResetRequest.getWorkSpec().constraints.requiresDeviceIdle()).isTrue();
+        assertThat(periodicResetRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_AND_CLOUD);
+
+        clearInvocations(mMockWorkManager);
+
+        mConfigStore.disableCloudMediaFeature();
+        waitForIdle();
+
+        // There should be 2 invocations, one for cancelling proactive media syncs,
+        // the other for albums reset.
         verify(mMockWorkManager, times(2)).cancelUniqueWork(anyString());
     }
 
     @Test
     public void testAdhocProactiveSyncLocalOnly() {
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
-        reset(mMockWorkManager);
 
         mPickerSyncManager.syncMediaProactively(/* localOnly */ true);
         verify(mMockWorkManager, times(1))
@@ -242,8 +386,6 @@ public class PickerSyncManagerTest {
     public void testAdhocProactiveSync() {
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
 
-        reset(mMockWorkManager);
-
         mPickerSyncManager.syncMediaProactively(/* localOnly */ false);
         verify(mMockWorkManager, times(1))
                 .enqueueUniqueWork(anyString(),
@@ -269,7 +411,6 @@ public class PickerSyncManagerTest {
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
 
         mConfigStore.setIsModernPickerEnabled(true);
-        reset(mMockWorkManager);
         mPickerSyncManager.syncMediaImmediately(new PickerSyncRequestExtras(/* albumId */null,
                 /* albumAuthority */ null, /* initLocalDataOnly */ true,
                 /* callingPackageUid */ 0, /* shouldSyncGrants */ true, null),
@@ -302,7 +443,6 @@ public class PickerSyncManagerTest {
         mConfigStore.setIsModernPickerEnabled(true);
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
 
-        reset(mMockWorkManager);
         mPickerSyncManager.syncMediaImmediately(new PickerSyncRequestExtras(/* albumId */null,
                 /* albumAuthority */ null, /* initLocalDataOnly */ true,
                 /* callingPackageUid */ 0, /* shouldSyncGrants */ false, null),
@@ -332,8 +472,6 @@ public class PickerSyncManagerTest {
         mConfigStore.setIsModernPickerEnabled(true);
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
 
-        reset(mMockWorkManager);
-
         mPickerSyncManager.syncMediaImmediately(new PickerSyncRequestExtras(/* albumId */null,
                 /* albumAuthority */ null, /* initLocalDataOnly */ false,
                 /* callingPackageUid */ 0, /* shouldSyncGrants */ false, null),
@@ -447,39 +585,10 @@ public class PickerSyncManagerTest {
                 .isEqualTo(SYNC_CLOUD_ONLY);
     }
 
-    private void setupPickerSyncManager(boolean schedulePeriodicSyncs) {
-        doReturn(mMockOperation).when(mMockWorkManager)
-                .enqueueUniquePeriodicWork(anyString(),
-                        any(ExistingPeriodicWorkPolicy.class),
-                        any(PeriodicWorkRequest.class));
-        doReturn(mMockOperation).when(mMockWorkManager)
-                .enqueueUniqueWork(anyString(),
-                        any(ExistingWorkPolicy.class),
-                        any(OneTimeWorkRequest.class));
-        doReturn(mMockWorkContinuation)
-                .when(mMockWorkManager)
-                .beginUniqueWork(
-                        anyString(), any(ExistingWorkPolicy.class), any(List.class));
-        // Handle .then chaining
-        doReturn(mMockWorkContinuation)
-                .when(mMockWorkContinuation)
-                .then(any(List.class));
-        doReturn(mMockOperation).when(mMockWorkContinuation).enqueue();
-        doReturn(mMockFuture).when(mMockOperation).getResult();
-
-        mPickerSyncManager = new PickerSyncManager(mMockWorkManager, mMockContext);
-        if (schedulePeriodicSyncs) {
-            mPickerSyncManager.schedulePeriodicSync(
-                    mConfigStore, /* periodicSyncInitialDelay */ 0L);
-        }
-        waitForIdle();
-    }
-
     @Test
     public void testSearchResultsLocalSync() {
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
 
-        reset(mMockWorkManager);
         mPickerSyncManager.syncSearchResultsForProvider(
                 /* searchRequestId */ 10,
                 SYNC_LOCAL_ONLY,
@@ -507,11 +616,125 @@ public class PickerSyncManagerTest {
                 .isEqualTo(10);
     }
 
+    @Test
+    public void testExistingSearchResultsSync() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        final int searchRequestId = 10;
+        final String authority = PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+
+        final SettableFuture<List<WorkInfo>> listenableFuture = SettableFuture.create();
+        final WorkInfo workInfo = new WorkInfo(
+                UUID.randomUUID(), WorkInfo.State.RUNNING, new HashSet<>());
+        final String tag = String.format(Locale.ROOT, "%s-%s-%s",
+                IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME, authority, searchRequestId);
+        listenableFuture.set(List.of(workInfo));
+        doReturn(listenableFuture).when(mMockWorkManager).getWorkInfosByTag(eq(tag));
+
+        mPickerSyncManager.syncSearchResultsForProvider(
+                searchRequestId,
+                SYNC_CLOUD_ONLY,
+                authority
+        );
+        verify(mMockWorkManager, times(0))
+                .enqueueUniqueWork(anyString(), any(), any(OneTimeWorkRequest.class));
+    }
+
+    @Test
+    public void testExistingMediaSetContentsSync() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        final int pickerMediaSetId = 10;
+        final String authority = PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+
+        final SettableFuture<List<WorkInfo>> listenableFuture = SettableFuture.create();
+        final WorkInfo workInfo = new WorkInfo(
+                UUID.randomUUID(), WorkInfo.State.RUNNING, new HashSet<>());
+        final String tag = String.format(Locale.ROOT, "%s-%s-%s",
+                IMMEDIATE_CLOUD_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME, authority, pickerMediaSetId);
+        listenableFuture.set(List.of(workInfo));
+        doReturn(listenableFuture).when(mMockWorkManager).getWorkInfosByTag(eq(tag));
+
+        Bundle extras = new Bundle();
+        extras.putString(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_AUTHORITY,
+                authority);
+        extras.putLong(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_PICKER_ID,
+                pickerMediaSetId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(authority)));
+
+        MediaInMediaSetSyncRequestParams requestParams = new MediaInMediaSetSyncRequestParams(
+                extras);
+        mPickerSyncManager.syncMediaInMediaSetForProvider(
+                requestParams,
+                SYNC_CLOUD_ONLY
+        );
+
+        verify(mMockWorkManager, times(0))
+                .enqueueUniqueWork(anyString(), any(), any(OneTimeWorkRequest.class));
+    }
+
+    @Test
+    public void testSearchResultsSyncIsScheduled() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        final int searchRequestId = 10;
+        final String authority = PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+
+        final SettableFuture<List<WorkInfo>> listenableFuture = SettableFuture.create();
+        final WorkInfo workInfo = new WorkInfo(
+                UUID.randomUUID(), WorkInfo.State.RUNNING, new HashSet<>());
+        final String tag = String.format(Locale.ROOT, "%s-%s-%s",
+                IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME, authority, searchRequestId + 1);
+        listenableFuture.set(List.of(workInfo));
+        doReturn(listenableFuture).when(mMockWorkManager).getWorkInfosByTag(eq(tag));
+
+        mPickerSyncManager.syncSearchResultsForProvider(
+                searchRequestId,
+                SYNC_CLOUD_ONLY,
+                authority
+        );
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(), any(OneTimeWorkRequest.class));
+    }
+
+    @Test
+    public void testMediaSetContentsSyncIsScheduled() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        final int pickerMediaSetId = 10;
+        final String authority = PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+
+        final SettableFuture<List<WorkInfo>> listenableFuture = SettableFuture.create();
+        final WorkInfo workInfo = new WorkInfo(
+                UUID.randomUUID(), WorkInfo.State.RUNNING, new HashSet<>());
+        final String tag = String.format(Locale.ROOT, "%s-%s-%s",
+                IMMEDIATE_CLOUD_MEDIA_IN_MEDIA_SET_SYNC_WORK_NAME,
+                authority, pickerMediaSetId + 1);
+        listenableFuture.set(List.of(workInfo));
+        doReturn(listenableFuture).when(mMockWorkManager).getWorkInfosByTag(eq(tag));
+
+        Bundle extras = new Bundle();
+        extras.putString(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_AUTHORITY,
+                authority);
+        extras.putLong(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_PICKER_ID,
+                pickerMediaSetId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(authority)));
+
+        MediaInMediaSetSyncRequestParams requestParams = new MediaInMediaSetSyncRequestParams(
+                extras);
+        mPickerSyncManager.syncMediaInMediaSetForProvider(
+                requestParams,
+                SYNC_CLOUD_ONLY
+        );
+
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(), any(OneTimeWorkRequest.class));
+    }
+
     @Test
     public void testSearchResultsCloudSync() {
         setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
 
-        reset(mMockWorkManager);
         mPickerSyncManager.syncSearchResultsForProvider(
                 /* searchRequestId */ 10,
                 SYNC_CLOUD_ONLY,
@@ -543,20 +766,157 @@ public class PickerSyncManagerTest {
     public void testMediaSetsSyncLocalProvider() {
         setupPickerSyncManager(/*schedulePeriodicSyncs*/ false);
 
-        reset(mMockWorkManager);
-
         String categoryId = "id";
         String[] mimeTypes = new String[] { "image/*" };
         Bundle extras = new Bundle();
-        extras.putString("authority", SearchProvider.AUTHORITY);
-        extras.putStringArray("mime_types", mimeTypes);
-        extras.putString("category_id", categoryId);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putStringArrayList(MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(Arrays.asList(mimeTypes)));
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
         extras.putStringArrayList("providers", new ArrayList<>(List.of(
                 PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY)));
 
         MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
 
         mPickerSyncManager.syncMediaSetsForProvider(requestParams, SYNC_LOCAL_ONLY);
+        verify(mMockWorkManager, times(1))
+                .beginUniqueWork(
+                        anyString(),
+                        any(ExistingWorkPolicy.class),
+                        mOneTimeWorkRequestListArgumentCaptor.capture());
+        verify(mMockWorkContinuation, times(1))
+                .then(mOneTimeWorkRequestListArgumentCaptor.capture());
+        verify(mMockWorkContinuation).enqueue();
+
+        final List<List<OneTimeWorkRequest>> workRequestList =
+                mOneTimeWorkRequestListArgumentCaptor.getAllValues();
+        assertThat(workRequestList.size()).isEqualTo(2);
+
+        WorkRequest resetRequest = workRequestList.get(0).get(0);
+        assertThat(resetRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaSetsResetWorker.class.getName());
+        assertThat(resetRequest.getWorkSpec().expedited).isTrue();
+        assertThat(resetRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(resetRequest.getWorkSpec().id).isNotNull();
+        assertThat(resetRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(resetRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_ONLY);
+        assertThat(resetRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
+                .isEqualTo(categoryId);
+        assertThat(resetRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_AUTHORITY))
+                .isEqualTo(SearchProvider.AUTHORITY);
+
+        WorkRequest syncRequest = workRequestList.get(1).get(0);
+        assertThat(syncRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaSetsSyncWorker.class.getName());
+        assertThat(syncRequest.getWorkSpec().expedited).isTrue();
+        assertThat(syncRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(syncRequest.getWorkSpec().id).isNotNull();
+        assertThat(syncRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(syncRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_ONLY);
+        assertThat(syncRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
+                .isEqualTo(categoryId);
+        assertThat(syncRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_AUTHORITY))
+                .isEqualTo(SearchProvider.AUTHORITY);
+        assertThat(syncRequest.getWorkSpec().input
+                .getStringArray(EXTRA_MIME_TYPES))
+                .isEqualTo(mimeTypes);
+    }
+
+    @Test
+    public void testMediaSetsSyncCloudProvider() {
+        setupPickerSyncManager(/*schedulePeriodicSyncs*/ false);
+
+        String categoryId = "id";
+        String[] mimeTypes = new String[] { "image/*" };
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putStringArrayList(MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(Arrays.asList(mimeTypes)));
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(
+                SearchProvider.AUTHORITY)));
+
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
+
+        mPickerSyncManager.syncMediaSetsForProvider(requestParams, SYNC_CLOUD_ONLY);
+        verify(mMockWorkManager, times(1))
+                .beginUniqueWork(
+                        anyString(),
+                        any(ExistingWorkPolicy.class),
+                        mOneTimeWorkRequestListArgumentCaptor.capture());
+        verify(mMockWorkContinuation, times(1))
+                .then(mOneTimeWorkRequestListArgumentCaptor.capture());
+        verify(mMockWorkContinuation).enqueue();
+
+        final List<List<OneTimeWorkRequest>> workRequestList =
+                mOneTimeWorkRequestListArgumentCaptor.getAllValues();
+        assertThat(workRequestList.size()).isEqualTo(2);
+
+        WorkRequest resetRequest = workRequestList.get(0).get(0);
+        assertThat(resetRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaSetsResetWorker.class.getName());
+        assertThat(resetRequest.getWorkSpec().expedited).isTrue();
+        assertThat(resetRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(resetRequest.getWorkSpec().id).isNotNull();
+        assertThat(resetRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(resetRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_CLOUD_ONLY);
+        assertThat(resetRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
+                .isEqualTo(categoryId);
+        assertThat(resetRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_AUTHORITY))
+                .isEqualTo(SearchProvider.AUTHORITY);
+
+        WorkRequest syncRequest = workRequestList.get(1).get(0);
+        assertThat(syncRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaSetsSyncWorker.class.getName());
+        assertThat(syncRequest.getWorkSpec().expedited).isTrue();
+        assertThat(syncRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(syncRequest.getWorkSpec().id).isNotNull();
+        assertThat(syncRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(syncRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_CLOUD_ONLY);
+        assertThat(syncRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
+                .isEqualTo(categoryId);
+        assertThat(syncRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_AUTHORITY))
+                .isEqualTo(SearchProvider.AUTHORITY);
+        assertThat(syncRequest.getWorkSpec().input
+                .getStringArray(EXTRA_MIME_TYPES))
+                .isEqualTo(mimeTypes);
+    }
+
+    @Test
+    public void testMediaInMediaSetSyncLocalProvider() {
+        setupPickerSyncManager(/*schedulePeriodicSyncs*/ false);
+
+        Long mediaSetPickerId = 1L;
+        Bundle extras = new Bundle();
+        extras.putString(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putLong(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_PICKER_ID,
+                mediaSetPickerId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(
+                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY)));
+
+        MediaInMediaSetSyncRequestParams requestParams = new MediaInMediaSetSyncRequestParams(
+                extras);
+
+        mPickerSyncManager.syncMediaInMediaSetForProvider(requestParams, SYNC_LOCAL_ONLY);
         verify(mMockWorkManager, times(1))
                 .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
 
@@ -566,7 +926,7 @@ public class PickerSyncManagerTest {
 
         WorkRequest workRequest = workRequestList.get(0);
         assertThat(workRequest.getWorkSpec().workerClassName)
-                .isEqualTo(MediaSetsSyncWorker.class.getName());
+                .isEqualTo(MediaInMediaSetsSyncWorker.class.getName());
         assertThat(workRequest.getWorkSpec().expedited).isTrue();
         assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
         assertThat(workRequest.getWorkSpec().id).isNotNull();
@@ -575,34 +935,32 @@ public class PickerSyncManagerTest {
                 .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
                 .isEqualTo(SYNC_LOCAL_ONLY);
         assertThat(workRequest.getWorkSpec().input
-                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
-                .isEqualTo(categoryId);
+                .getLong(SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, -1))
+                .isEqualTo(mediaSetPickerId);
         assertThat(workRequest.getWorkSpec().input
                 .getString(SYNC_WORKER_INPUT_AUTHORITY))
                 .isEqualTo(SearchProvider.AUTHORITY);
-        assertThat(workRequest.getWorkSpec().input
-                .getStringArray(EXTRA_MIME_TYPES))
-                .isEqualTo(mimeTypes);
     }
 
     @Test
-    public void testMediaSetsSyncCloudProvider() {
+    public void testMediaInMediaSetSyncCloudProvider() {
         setupPickerSyncManager(/*schedulePeriodicSyncs*/ false);
 
-        reset(mMockWorkManager);
-
-        String categoryId = "id";
-        String[] mimeTypes = new String[] { "image/*" };
+        Long mediaSetPickerId = 1L;
         Bundle extras = new Bundle();
-        extras.putString("authority", SearchProvider.AUTHORITY);
-        extras.putStringArray("mime_types", mimeTypes);
-        extras.putString("category_id", categoryId);
+        extras.putString(
+                MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putLong(
+                MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_PICKER_ID,
+                mediaSetPickerId);
         extras.putStringArrayList("providers", new ArrayList<>(List.of(
-                SearchProvider.AUTHORITY)));
+                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY)));
 
-        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
+        MediaInMediaSetSyncRequestParams requestParams = new MediaInMediaSetSyncRequestParams(
+                extras);
 
-        mPickerSyncManager.syncMediaSetsForProvider(requestParams, SYNC_CLOUD_ONLY);
+        mPickerSyncManager.syncMediaInMediaSetForProvider(requestParams, SYNC_CLOUD_ONLY);
         verify(mMockWorkManager, times(1))
                 .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
 
@@ -612,7 +970,7 @@ public class PickerSyncManagerTest {
 
         WorkRequest workRequest = workRequestList.get(0);
         assertThat(workRequest.getWorkSpec().workerClassName)
-                .isEqualTo(MediaSetsSyncWorker.class.getName());
+                .isEqualTo(MediaInMediaSetsSyncWorker.class.getName());
         assertThat(workRequest.getWorkSpec().expedited).isTrue();
         assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
         assertThat(workRequest.getWorkSpec().id).isNotNull();
@@ -621,13 +979,115 @@ public class PickerSyncManagerTest {
                 .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
                 .isEqualTo(SYNC_CLOUD_ONLY);
         assertThat(workRequest.getWorkSpec().input
-                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
-                .isEqualTo(categoryId);
+                .getLong(SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, -1))
+                .isEqualTo(mediaSetPickerId);
         assertThat(workRequest.getWorkSpec().input
                 .getString(SYNC_WORKER_INPUT_AUTHORITY))
                 .isEqualTo(SearchProvider.AUTHORITY);
+    }
+
+    @Test
+    public void testResetCloudSearchResults() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        mPickerSyncManager.resetCloudSearchCache(null);
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(),
+                        any(),
+                        mOneTimeWorkRequestArgumentCaptor.capture());
+
+        final OneTimeWorkRequest workRequest = mOneTimeWorkRequestArgumentCaptor.getValue();
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(SearchResetWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isTrue();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
         assertThat(workRequest.getWorkSpec().input
-                .getStringArray(EXTRA_MIME_TYPES))
-                .isEqualTo(mimeTypes);
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_CLOUD_ONLY);
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_RESET_TYPE, -1))
+                .isEqualTo(SEARCH_PARTIAL_CACHE_RESET);
+    }
+
+    @Test
+    public void testDelayedResetSearchCache() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        mPickerSyncManager.delayedResetSearchCache();
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(),
+                        any(),
+                        mOneTimeWorkRequestArgumentCaptor.capture());
+
+        final OneTimeWorkRequest workRequest = mOneTimeWorkRequestArgumentCaptor.getValue();
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(SearchResetWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isFalse();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_AND_CLOUD);
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_RESET_TYPE, -1))
+                .isEqualTo(SEARCH_RESULTS_FULL_CACHE_RESET);
+        assertThat(workRequest.getWorkSpec().initialDelay)
+                .isEqualTo(TimeUnit.MINUTES.toMillis(SEARCH_RESULTS_RESET_DELAY));
+        assertThat(workRequest.getWorkSpec().constraints.requiresDeviceIdle())
+                .isTrue();
+
+    }
+
+    @Test
+    public void testScheduleClearExpiredSuggestions() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        mPickerSyncManager.schedulePeriodicSearchSuggestionsReset();
+        verify(mMockWorkManager, times(1))
+                .enqueueUniquePeriodicWork(anyString(),
+                        any(),
+                        mPeriodicWorkRequestArgumentCaptor.capture());
+
+        final PeriodicWorkRequest workRequest =
+                mPeriodicWorkRequestArgumentCaptor.getAllValues().get(0);
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(SearchResetWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isFalse();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isTrue();
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_AND_CLOUD);
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_RESET_TYPE, -1))
+                .isEqualTo(EXPIRED_SUGGESTIONS_RESET);
+        assertThat(workRequest.getWorkSpec().constraints.requiresCharging()).isTrue();
+        assertThat(workRequest.getWorkSpec().constraints.requiresDeviceIdle()).isTrue();
+    }
+
+    private void setupPickerSyncManager(boolean schedulePeriodicSyncs) {
+        doReturn(mMockOperation).when(mMockWorkManager)
+                .enqueueUniquePeriodicWork(anyString(),
+                        any(ExistingPeriodicWorkPolicy.class),
+                        any(PeriodicWorkRequest.class));
+        doReturn(mMockOperation).when(mMockWorkManager)
+                .enqueueUniqueWork(anyString(),
+                        any(ExistingWorkPolicy.class),
+                        any(OneTimeWorkRequest.class));
+        doReturn(mMockWorkContinuation)
+                .when(mMockWorkManager)
+                .beginUniqueWork(
+                        anyString(), any(ExistingWorkPolicy.class), any(List.class));
+        // Handle .then chaining
+        doReturn(mMockWorkContinuation)
+                .when(mMockWorkContinuation)
+                .then(any(List.class));
+        doReturn(mMockOperation).when(mMockWorkContinuation).enqueue();
+        doReturn(mMockFuture).when(mMockOperation).getResult();
+
+        mPickerSyncManager = new PickerSyncManager(mMockWorkManager, mMockContext);
+        if (schedulePeriodicSyncs) {
+            mPickerSyncManager.schedulePeriodicSync(
+                    mConfigStore, /* periodicSyncInitialDelay */ 0L);
+        }
+        waitForIdle();
     }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java
index d6ea0c4e4..ca8112d5f 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java
@@ -21,6 +21,7 @@ import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_FACE
 
 import static com.android.providers.media.photopicker.PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SEARCH_REQUEST_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
 import static com.android.providers.media.photopicker.sync.SearchResultsSyncWorker.SYNC_COMPLETE_RESUME_KEY;
 import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.getCloudSearchResultsSyncInputData;
@@ -37,6 +38,7 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.MockitoAnnotations.initMocks;
 
+import android.annotation.NonNull;
 import android.content.ContentUris;
 import android.content.ContentValues;
 import android.content.Context;
@@ -44,6 +46,7 @@ import android.database.Cursor;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.net.Uri;
+import android.os.Bundle;
 import android.provider.CloudMediaProviderContract;
 
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -57,6 +60,7 @@ import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.SearchState;
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
 import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
 import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
 import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
@@ -83,6 +87,8 @@ public class SearchResultsSyncWorkerTest {
     private Context mContext;
     private SQLiteDatabase mDatabase;
     private PickerDbFacade mFacade;
+    private String mLocalAuthority;
+    private String mCloudAuthority;
 
     @Before
     public void setup() {
@@ -98,14 +104,18 @@ public class SearchResultsSyncWorkerTest {
         final File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
         dbPath.delete();
         final PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+
+        mLocalAuthority = LOCAL_PICKER_PROVIDER_AUTHORITY;
+        mCloudAuthority = SearchProvider.AUTHORITY;
+
         mDatabase = helper.getWritableDatabase();
         mFacade = new PickerDbFacade(
-                mContext, new PickerSyncLockManager(), LOCAL_PICKER_PROVIDER_AUTHORITY);
-        mFacade.setCloudProvider(SearchProvider.AUTHORITY);
+                mContext, new PickerSyncLockManager(), mLocalAuthority);
+        mFacade.setCloudProvider(mCloudAuthority);
 
-        doReturn(LOCAL_PICKER_PROVIDER_AUTHORITY).when(mMockSyncController).getLocalProvider();
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+        doReturn(mLocalAuthority).when(mMockSyncController).getLocalProvider();
+        doReturn(mCloudAuthority).when(mMockSyncController).getCloudProvider();
+        doReturn(mCloudAuthority).when(mMockSyncController)
                 .getCloudProviderOrDefault(any());
         doReturn(mFacade).when(mMockSyncController).getDbFacade();
         doReturn(mSearchState).when(mMockSyncController).getSearchState();
@@ -118,10 +128,17 @@ public class SearchResultsSyncWorkerTest {
     public void testInvalidSyncSource()
             throws ExecutionException, InterruptedException {
         // Setup
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                null,
+                "search text"
+        );
+        final int searchRequestId = saveSearchRequest(searchRequest);
+
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
                         .setInputData(
-                                getInvalidSearchResultsSyncInputData(/* searchRequestId */ 10))
+                                getInvalidSearchResultsSyncInputData(
+                                        searchRequestId, mCloudAuthority))
                         .build();
 
         // Test run
@@ -178,7 +195,44 @@ public class SearchResultsSyncWorkerTest {
         // Setup
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getLocalSearchResultsSyncInputData(/* searchRequestId */ 10))
+                        .setInputData(getLocalSearchResultsSyncInputData(
+                                /* searchRequestId */ 10, mLocalAuthority))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testMissingInputAuthority()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                null,
+                "search text"
+        );
+        final int searchRequestId = saveSearchRequest(searchRequest);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId)))
                         .build();
 
         // Test run
@@ -200,6 +254,41 @@ public class SearchResultsSyncWorkerTest {
                 .markSyncCompleted(any());
     }
 
+    @Test
+    public void testIncorrectInputAuthority()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                null,
+                "search text"
+        );
+        final int searchRequestId = saveSearchRequest(searchRequest);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, "random.authority"))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
     @Test
     public void testInvalidAlbumSuggestionsSearchRequestId()
             throws ExecutionException, InterruptedException {
@@ -208,22 +297,15 @@ public class SearchResultsSyncWorkerTest {
                 null,
                 "search text",
                 "media-set-id",
-                SearchProvider.AUTHORITY,
-                SEARCH_SUGGESTION_ALBUM,
-                null
+                mCloudAuthority,
+                SEARCH_SUGGESTION_ALBUM
         );
-
-        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
-        final int searchRequestId =
-                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
-
-        assertWithMessage("Could not find search request is the database " + searchRequest)
-                .that(searchRequestId)
-                .isNotEqualTo(-1);
+        final int searchRequestId = saveSearchRequest(searchRequest);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getLocalSearchResultsSyncInputData(searchRequestId))
+                        .setInputData(getLocalSearchResultsSyncInputData(
+                                searchRequestId, mLocalAuthority))
                         .build();
 
         // Test run
@@ -241,26 +323,17 @@ public class SearchResultsSyncWorkerTest {
         // Setup
         SearchTextRequest searchRequest = new SearchTextRequest(
                 null,
-                "search text",
-                null
+                "search text"
         );
+        final int searchRequestId = saveSearchRequest(searchRequest);
 
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
-
-        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
-        final int searchRequestId =
-                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
-
-        assertWithMessage("Could not find search request is the database " + searchRequest)
-                .that(searchRequestId)
-                .isNotEqualTo(-1);
-
-        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
         SearchProvider.setSearchResults(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getCloudSearchResultsSyncInputData(searchRequestId))
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, mCloudAuthority))
                         .build();
 
         // Test run
@@ -339,26 +412,20 @@ public class SearchResultsSyncWorkerTest {
         // Setup
         SearchTextRequest searchRequest = new SearchTextRequest(
                 null,
-                "search text",
-                null
+                "search text"
         );
+        final int searchRequestId = saveSearchRequest(searchRequest);
 
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
+        mLocalAuthority = SearchProvider.AUTHORITY;
+        doReturn(mLocalAuthority).when(mMockSyncController).getLocalProvider();
 
-        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
-        final int searchRequestId =
-                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
-
-        assertWithMessage("Could not find search request is the database " + searchRequest)
-                .that(searchRequestId)
-                .isNotEqualTo(-1);
-
-        final Cursor inputCursor = SearchProvider.DEFAULT_LOCAL_SEARCH_RESULTS;
+        final Cursor inputCursor = SearchProvider.getDefaultLocalSearchResults();
         SearchProvider.setSearchResults(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getLocalSearchResultsSyncInputData(searchRequestId))
+                        .setInputData(getLocalSearchResultsSyncInputData(
+                                searchRequestId, mLocalAuthority))
                         .build();
 
         // Test run
@@ -428,27 +495,18 @@ public class SearchResultsSyncWorkerTest {
                 null,
                 "search text",
                 "media-set-id",
-                LOCAL_PICKER_PROVIDER_AUTHORITY,
-                SEARCH_SUGGESTION_FACE,
-                null
+                mLocalAuthority,
+                SEARCH_SUGGESTION_FACE
         );
+        final int searchRequestId = saveSearchRequest(searchRequest);
 
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
-
-        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
-        final int searchRequestId =
-                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
-
-        assertWithMessage("Could not find search request is the database " + searchRequest)
-                .that(searchRequestId)
-                .isNotEqualTo(-1);
-
-        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
         SearchProvider.setSearchResults(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getCloudSearchResultsSyncInputData(searchRequestId))
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, mCloudAuthority))
                         .build();
 
         // Test run
@@ -529,27 +587,25 @@ public class SearchResultsSyncWorkerTest {
                 null,
                 "search text",
                 "media-set-id",
-                SearchProvider.AUTHORITY,
+                mCloudAuthority,
                 SEARCH_SUGGESTION_FACE,
-                "Random-resume-key"
+                "Random-local-resume-key",
+                "local-authority",
+                "Random-cloud-resume-key",
+                mCloudAuthority
         );
+        final int searchRequestId = saveSearchRequest(searchRequest);
 
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
-
-        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
-        final int searchRequestId =
-                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+        mLocalAuthority = SearchProvider.AUTHORITY;
+        doReturn(mLocalAuthority).when(mMockSyncController).getLocalProvider();
 
-        assertWithMessage("Could not find search request is the database " + searchRequest)
-                .that(searchRequestId)
-                .isNotEqualTo(-1);
-
-        final Cursor inputCursor = SearchProvider.DEFAULT_LOCAL_SEARCH_RESULTS;
+        final Cursor inputCursor = SearchProvider.getDefaultLocalSearchResults();
         SearchProvider.setSearchResults(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getLocalSearchResultsSyncInputData(searchRequestId))
+                        .setInputData(getLocalSearchResultsSyncInputData(
+                                searchRequestId, mLocalAuthority))
                         .build();
 
         // Test run
@@ -619,27 +675,280 @@ public class SearchResultsSyncWorkerTest {
                 null,
                 "search text",
                 "media-set-id",
-                LOCAL_PICKER_PROVIDER_AUTHORITY,
+                mLocalAuthority,
                 SEARCH_SUGGESTION_FACE,
-                SYNC_COMPLETE_RESUME_KEY
+                "Random-local-resume-key",
+                "local-authority",
+                SYNC_COMPLETE_RESUME_KEY,
+                mCloudAuthority
         );
+        final int searchRequestId = saveSearchRequest(searchRequest);
 
-        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
+        SearchProvider.setSearchResults(inputCursor);
 
-        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
-        final int searchRequestId =
-                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, mCloudAuthority))
+                        .build();
 
-        assertWithMessage("Could not find search request is the database " + searchRequest)
-                .that(searchRequestId)
-                .isNotEqualTo(-1);
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
 
-        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(0);
+        }
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testCloudSyncResumeInfoIsCleared()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                mLocalAuthority,
+                SEARCH_SUGGESTION_FACE
+        );
+        final int searchRequestId = saveSearchRequest(searchRequest);
+
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
+        SearchProvider.setSearchResults(inputCursor);
+
+        // Run the search results worker to sync with SearchProvider.
+        final OneTimeWorkRequest request1 =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, mCloudAuthority))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request1).getResult().get();
+
+        // Verify that sync happened
+        final WorkInfo workInfo1 = workManager.getWorkInfoById(request1.getId()).get();
+        assertThat(workInfo1.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+        }
+
+        final SearchRequest searchRequest1 =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestId);
+        assertWithMessage("Search details are null")
+                .that(searchRequest1)
+                .isNotNull();
+        assertWithMessage("Cloud sync authority is not as expected")
+                .that(searchRequest1.getCloudAuthority())
+                .isEqualTo(SearchProvider.AUTHORITY);
+        assertWithMessage("Cloud sync resume key is not as expected")
+                .that(searchRequest1.getCloudSyncResumeKey())
+                .isEqualTo(SYNC_COMPLETE_RESUME_KEY);
+
+        // Run the search results worker to sync with a random provider
+        final String newCloudAuthority = "random.authority";
+        doReturn(newCloudAuthority).when(mMockSyncController).getCloudProvider();
+        doReturn(newCloudAuthority).when(mMockSyncController).getCloudProviderOrDefault(any());
+        final OneTimeWorkRequest request2 =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, newCloudAuthority))
+                        .build();
+
+        workManager.enqueue(request2).getResult().get();
+
+        // Verify that the database was cleared.
+        final WorkInfo workInfo2 = workManager.getWorkInfoById(request2.getId()).get();
+        assertThat(workInfo2.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(0);
+        }
+
+        final SearchRequest searchRequest2 =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestId);
+        assertWithMessage("Search details are null")
+                .that(searchRequest2)
+                .isNotNull();
+        assertWithMessage("Cloud sync authority is not as expected")
+                .that(searchRequest2.getCloudAuthority())
+                .isNull();
+        assertWithMessage("Cloud sync resume key is not as expected")
+                .that(searchRequest2.getCloudSyncResumeKey())
+                .isNull();
+    }
+
+    @Test
+    public void testLocalSyncResumeInfoIsCleared()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                mLocalAuthority,
+                SEARCH_SUGGESTION_FACE
+        );
+        final int searchRequestId = saveSearchRequest(searchRequest);
+
+        mLocalAuthority = SearchProvider.AUTHORITY;
+        doReturn(mLocalAuthority).when(mMockSyncController).getLocalProvider();
+
+        final Cursor inputCursor = SearchProvider.getDefaultLocalSearchResults();
+        SearchProvider.setSearchResults(inputCursor);
+
+        // Run the search results worker to sync with SearchProvider.
+        final OneTimeWorkRequest request1 =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getLocalSearchResultsSyncInputData(
+                                searchRequestId, mLocalAuthority))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request1).getResult().get();
+
+        // Verify that sync happened
+        final WorkInfo workInfo1 = workManager.getWorkInfoById(request1.getId()).get();
+        assertThat(workInfo1.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+        }
+
+        final SearchRequest searchRequest1 =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestId);
+        assertWithMessage("Search details are null")
+                .that(searchRequest1)
+                .isNotNull();
+        assertWithMessage("Local sync authority is not as expected")
+                .that(searchRequest1.getLocalAuthority())
+                .isEqualTo(mLocalAuthority);
+        assertWithMessage("Local sync resume key is not as expected")
+                .that(searchRequest1.getLocalSyncResumeKey())
+                .isEqualTo(SYNC_COMPLETE_RESUME_KEY);
+
+        // Run the search results worker to sync with a random provider
+        final String newLocalAuthority = "random.authority";
+        doReturn(newLocalAuthority).when(mMockSyncController).getLocalProvider();
+        final OneTimeWorkRequest request2 =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getLocalSearchResultsSyncInputData(
+                                searchRequestId, newLocalAuthority))
+                        .build();
+        workManager.enqueue(request2).getResult().get();
+
+        // Verify that the database was cleared.
+        final WorkInfo workInfo2 = workManager.getWorkInfoById(request2.getId()).get();
+        assertThat(workInfo2.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(0);
+        }
+
+        final SearchRequest searchRequest2 =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestId);
+        assertWithMessage("Search details are null")
+                .that(searchRequest2)
+                .isNotNull();
+        assertWithMessage("Local sync authority is not as expected")
+                .that(searchRequest2.getLocalAuthority())
+                .isNull();
+        assertWithMessage("Local sync resume key is not as expected")
+                .that(searchRequest2.getLocalSyncResumeKey())
+                .isNull();
+    }
+
+    @Test
+    public void testSuggestionSearchSyncLoop()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                mLocalAuthority,
+                SEARCH_SUGGESTION_FACE
+        );
+        final int searchRequestId = saveSearchRequest(searchRequest);
+
+        final Cursor inputCursor = SearchProvider.getDefaultCloudSearchResults();
+        final String repeatPageToken = "LOOP";
+        final Bundle bundle = new Bundle();
+        bundle.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, repeatPageToken);
+        inputCursor.setExtras(bundle);
         SearchProvider.setSearchResults(inputCursor);
 
         final OneTimeWorkRequest request =
                 new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
-                        .setInputData(getCloudSearchResultsSyncInputData(searchRequestId))
+                        .setInputData(getCloudSearchResultsSyncInputData(
+                                searchRequestId, mCloudAuthority))
                         .build();
 
         // Test run
@@ -661,7 +970,7 @@ public class SearchResultsSyncWorkerTest {
 
             assertWithMessage("Cursor count is not as expected")
                     .that(cursor.getCount())
-                    .isEqualTo(0);
+                    .isEqualTo(inputCursor.getCount());
         }
 
         verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
@@ -674,4 +983,20 @@ public class SearchResultsSyncWorkerTest {
         verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
                 .markSyncCompleted(any());
     }
+
+    /**
+     * Saves the given search request in DB and asserts that it was saved.
+     * Returns the generated search request id.
+     */
+    private int saveSearchRequest(@NonNull SearchRequest searchRequest) {
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        return searchRequestId;
+    }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/sync/SyncTrackerTests.java b/tests/src/com/android/providers/media/photopicker/sync/SyncTrackerTests.java
index 1eac73a78..574580963 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/SyncTrackerTests.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/SyncTrackerTests.java
@@ -49,6 +49,19 @@ public class SyncTrackerTests {
         assertThat(futures.size()).isEqualTo(0);
     }
 
+    @Test
+    public void testMarkAllSyncsComplete() {
+        SyncTracker syncTracker = new SyncTracker();
+        syncTracker.createSyncFuture(UUID.randomUUID());
+        syncTracker.createSyncFuture(UUID.randomUUID());
+        syncTracker.createSyncFuture(UUID.randomUUID());
+        Collection<CompletableFuture<Object>> futures = syncTracker.pendingSyncFutures();
+        assertThat(futures.size()).isEqualTo(3);
+
+        syncTracker.markAllSyncsCompleted();
+        assertThat(futures.size()).isEqualTo(0);
+    }
+
     @Test
     public void testCompleteOnTimeoutSyncFuture()
             throws InterruptedException, ExecutionException, TimeoutException {
diff --git a/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java b/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java
index b21602e64..30f139c76 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java
@@ -32,6 +32,7 @@ import android.content.Intent;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.work.Configuration;
 import androidx.work.Data;
 import androidx.work.Worker;
@@ -109,19 +110,37 @@ public class SyncWorkerTestUtils {
                 SYNC_WORKER_INPUT_ALBUM_ID, albumId));
     }
 
-    public static Data getLocalSearchResultsSyncInputData(int searchRequestId) {
+    /**
+     * Returns input data for the SearchResultsSyncWorker to perform sync with the
+     * local provider.
+     */
+    public static Data getLocalSearchResultsSyncInputData(int searchRequestId,
+                                                          @NonNull String authority) {
         return new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
-                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId,
+                SYNC_WORKER_INPUT_AUTHORITY, authority));
     }
 
-    public static Data getCloudSearchResultsSyncInputData(int searchRequestId) {
+    /**
+     * Returns input data for the SearchResultsSyncWorker to perform sync with the
+     * cloud provider.
+     */
+    public static Data getCloudSearchResultsSyncInputData(int searchRequestId,
+                                                          @NonNull String authority) {
         return new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
-                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId,
+                SYNC_WORKER_INPUT_AUTHORITY, authority));
     }
 
-    public static Data getInvalidSearchResultsSyncInputData(int searchRequestId) {
+    /**
+     * Returns input data for the SearchResultsSyncWorker to perform sync with the
+     * an invalid sync source
+     */
+    public static Data getInvalidSearchResultsSyncInputData(int searchRequestId,
+                                                            @Nullable String authority) {
         return new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_AND_CLOUD,
-                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId,
+                SYNC_WORKER_INPUT_AUTHORITY, authority));
     }
 
     static <W extends Worker> W buildTestWorker(@NonNull Context context,
diff --git a/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java b/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java
index a5b4aa959..1f6c0d428 100644
--- a/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java
+++ b/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java
@@ -64,6 +64,7 @@ public class PickerDbTestUtils {
     public static final int STANDARD_MIME_TYPE_EXTENSION =
             CloudMediaProviderContract.MediaColumns.STANDARD_MIME_TYPE_EXTENSION_GIF;
     public static final String TEST_PACKAGE_NAME = "com.test.package";
+    public static final String TEST_DIFFERENT_PACKAGE_NAME = "com.test.different.package";
 
     public static final String LOCAL_PROVIDER = "com.local.provider";
     public static final String CLOUD_PROVIDER = "com.cloud.provider";
@@ -355,8 +356,7 @@ public class PickerDbTestUtils {
                 /* MEDIA_COVER_ID4 */ null
         };
 
-        MatrixCursor c = new MatrixCursor(
-                CloudMediaProviderContract.MediaCategoryColumns.ALL_PROJECTION);
+        MatrixCursor c = new MatrixCursor(projectionKey);
         c.addRow(projectionValue);
         return c;
     }
@@ -372,8 +372,8 @@ public class PickerDbTestUtils {
     }
 
     public static String getData(String authority, String displayName, String pickerSegmentType) {
-        return "/sdcard/.transforms/synthetic/" + pickerSegmentType + "/0/" + authority + "/media/"
-                + displayName;
+        return "/sdcard/.transforms/synthetic/" + pickerSegmentType + "/" + UserHandle.myUserId()
+                + "/" + authority + "/media/" + displayName;
     }
 
     public static void assertCloudAlbumCursor(Cursor cursor, String albumId, String displayName,
diff --git a/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java b/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java
index 02a1dbc7e..d4d904648 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java
@@ -16,6 +16,8 @@
 
 package com.android.providers.media.photopicker.v2;
 
+import static android.provider.MediaStore.PER_USER_RANGE;
+
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.ALBUM_ID;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_1;
@@ -24,8 +26,10 @@ import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLO
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_4;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_PROVIDER;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.DATE_TAKEN_MS;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.DURATION_MS;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.GENERATION_MODIFIED;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.GIF_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.HEIGHT;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.JPEG_IMAGE_MIME_TYPE;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_1;
@@ -34,9 +38,12 @@ import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOC
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_4;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_PROVIDER;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.MP4_VIDEO_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.ORIENTATION;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.PNG_IMAGE_MIME_TYPE;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.STANDARD_MIME_TYPE_EXTENSION;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.TEST_DIFFERENT_PACKAGE_NAME;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.TEST_PACKAGE_NAME;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.WIDTH;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertAddAlbumMediaOperation;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertAddMediaOperation;
 import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertInsertGrantsOperation;
@@ -53,6 +60,9 @@ import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
@@ -61,31 +71,44 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.MockitoAnnotations.initMocks;
 
+import android.Manifest;
+import android.compat.testing.PlatformCompatChangeRule;
+import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ProviderInfo;
 import android.database.Cursor;
+import android.database.MatrixCursor;
 import android.database.MergeCursor;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.CancellationSignal;
 import android.os.Process;
 import android.os.UserHandle;
+import android.platform.test.annotations.DisableFlags;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
 import android.provider.CloudMediaProviderContract;
 import android.provider.MediaStore;
 import android.test.mock.MockContentProvider;
 import android.test.mock.MockContentResolver;
 
 import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.SdkSuppress;
+import androidx.test.runner.AndroidJUnit4;
 import androidx.work.ExistingWorkPolicy;
 import androidx.work.OneTimeWorkRequest;
 import androidx.work.Operation;
+import androidx.work.WorkContinuation;
 import androidx.work.WorkManager;
 
+import com.android.providers.media.MediaProvider;
 import com.android.providers.media.PickerUriResolver;
 import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.CategoriesState;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.SearchState;
@@ -94,28 +117,41 @@ import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
 import com.android.providers.media.photopicker.data.PickerDbFacade;
 import com.android.providers.media.photopicker.data.model.UserId;
 import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
 import com.android.providers.media.photopicker.v2.model.MediaGroup;
+import com.android.providers.media.photopicker.v2.model.MediaInMediaSetSyncRequestParams;
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 import com.android.providers.media.photopicker.v2.model.MediaSource;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
 import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
 import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
 import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils;
 import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsQuery;
 
 import com.google.common.util.concurrent.ListenableFuture;
 
+import libcore.junit.util.compat.CoreCompatChangeRule.EnableCompatChanges;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
 import org.mockito.Mock;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.Executor;
 
+@RunWith(AndroidJUnit4.class)
 public class PickerDataLayerV2Test {
     @Mock
     private PickerSyncController mMockSyncController;
@@ -130,6 +166,8 @@ public class PickerDataLayerV2Test {
     @Mock
     private Operation mMockOperation;
     @Mock
+    private WorkContinuation mMockWorkContinuation;
+    @Mock
     private ListenableFuture<Operation.State.SUCCESS> mMockFuture;
     @Mock
     CategoriesState mCategoriesState;
@@ -139,6 +177,12 @@ public class PickerDataLayerV2Test {
     private TestContentProvider mLocalProvider;
     private TestContentProvider mCloudProvider;
 
+    @Rule
+    public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
+
+    @Rule
+    public final TestRule mCompatChangeRule = new PlatformCompatChangeRule();
+
 
     private static class TestContentProvider extends MockContentProvider {
         private Cursor mQueryResult = null;
@@ -178,11 +222,20 @@ public class PickerDataLayerV2Test {
         doReturn(LOCAL_PROVIDER).when(mMockSyncController).getLocalProvider();
         doReturn(CLOUD_PROVIDER).when(mMockSyncController).getCloudProvider();
         doReturn(CLOUD_PROVIDER).when(mMockSyncController).getCloudProviderOrDefault(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMediaSets(any(), any());
+        doReturn(true).when(mMockSyncController).shouldQueryLocalMediaSets(any());
         doReturn(mFacade).when(mMockSyncController).getDbFacade();
         doReturn(mSearchState).when(mMockSyncController).getSearchState();
         doReturn(mCategoriesState).when(mMockSyncController).getCategoriesState();
         doReturn(new PickerSyncLockManager()).when(mMockSyncController).getPickerSyncLockManager();
         doReturn(mMockContentResolver).when(mMockContext).getContentResolver();
+
+        androidx.test.platform.app.InstrumentationRegistry.getInstrumentation()
+                .getUiAutomation()
+                .adoptShellPermissionIdentity(
+                        Manifest.permission.LOG_COMPAT_CHANGE,
+                        Manifest.permission.READ_COMPAT_CHANGE_CONFIG,
+                        Manifest.permission.READ_DEVICE_CONFIG);
     }
 
     @After
@@ -467,7 +520,12 @@ public class PickerDataLayerV2Test {
                 /* writeCount */1);
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursorForMediaWithGrants,
                 /* writeCount */1);
-        int testUid = 123;
+        // testUid should be selected such that the userId computed from this uid later in the code
+        // flow matches the current userId. UserId is computed using
+        // PickerSyncController#uidToUser() where the userId = uid / PER_USER_RANGE.
+        // So testUid is =
+        // (a random number smaller than PER_USER_RANGE) + (PER_USER_RANGE * UserHandle.myUserId())
+        int testUid = 11 + (PER_USER_RANGE * UserHandle.myUserId());
         doReturn(mMockPackageManager)
                 .when(mMockContext).getPackageManager();
         String[] packageNames = new String[]{TEST_PACKAGE_NAME};
@@ -501,6 +559,188 @@ public class PickerDataLayerV2Test {
         }
     }
 
+    @Test
+    @EnableFlags(Flags.FLAG_REVOKE_ACCESS_OWNED_PHOTOS)
+    @EnableCompatChanges({MediaProvider.ENABLE_OWNED_PHOTOS})
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.BAKLAVA)
+    public void testPreGrantsForOwnedPhotos() {
+        assumeTrue(MediaProvider.isOwnedPhotosEnabled(Process.myUid()));
+
+        doReturn(mMockPackageManager)
+                .when(mMockContext).getPackageManager();
+        String[] packageNames = new String[]{TEST_PACKAGE_NAME};
+        doReturn(packageNames).when(mMockPackageManager).getPackagesForUid(Process.myUid());
+        Map<String, Integer> idVsExpectedPreGrantedValue = populateMediaAndMediaGrantsTable();
+        int totalCount = idVsExpectedPreGrantedValue.size();
+
+        try (Cursor cr = PickerDataLayerV2.queryMedia(
+                mMockContext, getMediaQueryExtras(Long.MAX_VALUE, Long.MAX_VALUE, /* pageSize */ 10,
+                        new ArrayList<>(List.of(LOCAL_PROVIDER)),
+                        new ArrayList<>(List.of("image/*")),
+                        MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP,
+                        /*callingUid*/ Process.myUid()))) {
+
+            assertWithMessage(
+                    "Unexpected number of rows in media query result")
+                    .that(cr.getCount()).isEqualTo(totalCount);
+
+            cr.moveToFirst();
+            for (int i = 0; i < totalCount; i++) {
+                int id = cr.getInt(cr.getColumnIndex("id"));
+                int isPreGranted = cr.getInt(cr.getColumnIndex("is_pre_granted"));
+                assertEquals(idVsExpectedPreGrantedValue.get(String.valueOf(id)).intValue(),
+                        isPreGranted);
+                cr.moveToNext();
+            }
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_REVOKE_ACCESS_OWNED_PHOTOS)
+    @EnableCompatChanges({MediaProvider.ENABLE_OWNED_PHOTOS})
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.BAKLAVA)
+    public void testPreGrantedCountForOwnedPhotos() {
+        assumeTrue(MediaProvider.isOwnedPhotosEnabled(Process.myUid()));
+
+        doReturn(mMockPackageManager)
+                .when(mMockContext).getPackageManager();
+        String[] packageNames = new String[]{TEST_PACKAGE_NAME};
+        doReturn(packageNames).when(mMockPackageManager).getPackagesForUid(0);
+        Map<String, Integer> idVsPreGranted = populateMediaAndMediaGrantsTable();
+        int totalPreGranted = (int) idVsPreGranted.values().stream()
+                .filter(preGranted -> Integer.valueOf(1).equals(preGranted))
+                .count();
+
+        Bundle queryArgs = new Bundle();
+        queryArgs.putInt(Intent.EXTRA_UID, 0);
+        try (Cursor cr = PickerDataLayerV2.fetchCountForPreGrantedItems(mMockContext, queryArgs)) {
+            cr.moveToFirst();
+            assertEquals(totalPreGranted, cr.getInt(cr.getColumnIndex(COLUMN_GRANTS_COUNT)));
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_REVOKE_ACCESS_OWNED_PHOTOS)
+    @EnableCompatChanges({MediaProvider.ENABLE_OWNED_PHOTOS})
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.BAKLAVA)
+    public void testPreviewForOwnedPhotos() {
+        assumeTrue(MediaProvider.isOwnedPhotosEnabled(Process.myUid()));
+
+        doReturn(mMockPackageManager)
+                .when(mMockContext).getPackageManager();
+        String[] packageNames = new String[]{TEST_PACKAGE_NAME};
+        doReturn(packageNames).when(mMockPackageManager).getPackagesForUid(0);
+
+        Map<String, Integer> idVsPreGranted = populateMediaAndMediaGrantsTable();
+        int totalPreGranted = (int) idVsPreGranted.values().stream()
+                .filter(preGranted -> Integer.valueOf(1).equals(preGranted))
+                .count();
+
+        Bundle queryArgs = getMediaQueryExtras(Long.MAX_VALUE, Long.MAX_VALUE, /* pageSize */ 10,
+                new ArrayList<>(List.of(LOCAL_PROVIDER)),
+                new ArrayList<>(List.of("image/*")),
+                MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP,
+                0);
+        queryArgs.putBoolean("is_preview_session", true);
+
+        try (Cursor cr = PickerDataLayerV2.queryPreviewMedia(mMockContext, queryArgs)) {
+            assertEquals(totalPreGranted, cr.getCount());
+            cr.moveToFirst();
+            for (int i = 0; i < totalPreGranted; i++) {
+                int id = cr.getInt(cr.getColumnIndex("id"));
+                int preGranted = cr.getInt(cr.getColumnIndex("is_pre_granted"));
+                assertEquals(1, (int) idVsPreGranted.get(String.valueOf(id)));
+                assertEquals(1, preGranted);
+                cr.moveToNext();
+            }
+        }
+    }
+
+    private Map<String, Integer> populateMediaAndMediaGrantsTable() {
+
+        Map<String, Integer> idVsExpectedPreGrantedValue = new HashMap<>();
+
+        // 1. ownerPackageName != TEST_PACKAGE_NAME and no media grants.
+        // preGranted should be false
+        Cursor cursorWithDifferentOwnerPackageName = getMediaCursorWithOwnerPackageNameAndUserId(
+                "101", TEST_DIFFERENT_PACKAGE_NAME);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursorWithDifferentOwnerPackageName,
+                /*writeCount*/ 1);
+        idVsExpectedPreGrantedValue.put("101", 0);
+
+        // 2. ownerPackageName == TEST_PACKAGE_NAME and no media grants.
+        // preGranted should be true
+        Cursor cursorWithCorrectOwnerPackageName = getMediaCursorWithOwnerPackageNameAndUserId(
+                "102", TEST_PACKAGE_NAME);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursorWithCorrectOwnerPackageName,
+                /*writeCount*/ 1);
+        idVsExpectedPreGrantedValue.put("102", 1);
+
+        // 3. ownerPackageName != TEST_PACKAGE_NAME
+        // and media_grants with packageName == TEST_PACKAGE_NAME.
+        // preGranted should be true
+        Cursor cursorWithCorrectMediaGrants = getMediaCursorWithOwnerPackageNameAndUserId(
+                "103", TEST_DIFFERENT_PACKAGE_NAME);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursorWithCorrectMediaGrants,
+                /*writeCount*/ 1);
+        assertInsertGrantsOperation(mFacade, getMediaGrantsCursor("103", TEST_PACKAGE_NAME,
+                0), /*writeCount*/ 1);
+        idVsExpectedPreGrantedValue.put("103", 1);
+
+        // 4. ownerPackageName != TEST_PACKAGE_NAME
+        // and media_grants with packageName != TEST_PACKAGE_NAME.
+        // preGranted should be false
+        Cursor cursorWithDifferentMediaGrants = getMediaCursorWithOwnerPackageNameAndUserId(
+                "104", TEST_DIFFERENT_PACKAGE_NAME);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursorWithDifferentMediaGrants,
+                /*writeCount*/ 1);
+        assertInsertGrantsOperation(mFacade, getMediaGrantsCursor("104",
+                TEST_DIFFERENT_PACKAGE_NAME, 0), /*writeCount*/ 1);
+        idVsExpectedPreGrantedValue.put("104", 0);
+
+        return idVsExpectedPreGrantedValue;
+    }
+
+    private Cursor getMediaCursorWithOwnerPackageNameAndUserId(String id, String ownerPackageName) {
+        String[] projectionKey = new String[]{
+                CloudMediaProviderContract.MediaColumns.ID,
+                CloudMediaProviderContract.MediaColumns.MEDIA_STORE_URI,
+                CloudMediaProviderContract.MediaColumns.DATE_TAKEN_MILLIS,
+                CloudMediaProviderContract.MediaColumns.SYNC_GENERATION,
+                CloudMediaProviderContract.MediaColumns.SIZE_BYTES,
+                CloudMediaProviderContract.MediaColumns.MIME_TYPE,
+                CloudMediaProviderContract.MediaColumns.STANDARD_MIME_TYPE_EXTENSION,
+                CloudMediaProviderContract.MediaColumns.DURATION_MILLIS,
+                CloudMediaProviderContract.MediaColumns.IS_FAVORITE,
+                CloudMediaProviderContract.MediaColumns.HEIGHT,
+                CloudMediaProviderContract.MediaColumns.WIDTH,
+                CloudMediaProviderContract.MediaColumns.ORIENTATION,
+                CloudMediaProviderContract.MediaColumns.OWNER_PACKAGE_NAME,
+                CloudMediaProviderContract.MediaColumns.USER_ID
+        };
+
+        String[] projectionValue = new String[]{
+                id,
+                null,
+                String.valueOf(DATE_TAKEN_MS),
+                String.valueOf(GENERATION_MODIFIED),
+                String.valueOf(1),
+                JPEG_IMAGE_MIME_TYPE,
+                String.valueOf(STANDARD_MIME_TYPE_EXTENSION),
+                String.valueOf(DURATION_MS),
+                String.valueOf(0),
+                String.valueOf(HEIGHT),
+                String.valueOf(WIDTH),
+                String.valueOf(ORIENTATION),
+                ownerPackageName,
+                String.valueOf(0)
+        };
+
+        MatrixCursor c = new MatrixCursor(projectionKey);
+        c.addRow(projectionValue);
+        return c;
+    }
+
     @Test
     public void testQueryLocalMediaForPreview() {
         Cursor cursorForMediaWithoutGrants = getMediaCursor(LOCAL_ID_1, DATE_TAKEN_MS + 1,
@@ -522,7 +762,12 @@ public class PickerDataLayerV2Test {
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursorForMediaWithGrantsButDeSelected,
                 /* writeCount */1);
 
-        int testUid = 123;
+        // testUid should be selected such that the userId computed from this uid later in the code
+        // flow matches the current userId. UserId is computed using
+        // PickerSyncController#uidToUser() where the userId = uid / PER_USER_RANGE.
+        // So testUid is =
+        // (a random number smaller than PER_USER_RANGE) + (PER_USER_RANGE * UserHandle.myUserId())
+        int testUid = 11 + (PER_USER_RANGE * UserHandle.myUserId());
         doReturn(mMockPackageManager)
                 .when(mMockContext).getPackageManager();
         String[] packageNames = new String[]{TEST_PACKAGE_NAME};
@@ -570,6 +815,77 @@ public class PickerDataLayerV2Test {
         }
     }
 
+    @Test
+    public void testQueryMediaSets() throws RequestObsoleteException {
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add("image/*");
+        String mediaSetId1 = "mediaSetId1";
+        String mediaSetId2 = "mediaSetId2";
+        String displayName1 = "displayName1";
+        String displayName2 = "displayName2";
+        String coverId1 = "56";
+        String coverId2 = "76";
+        String categoryId = "id";
+
+        String[] columns = new String[]{
+                CloudMediaProviderContract.MediaSetColumns.ID,
+                CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+        };
+
+        // Prep the media sets table
+        MatrixCursor cursor = new MatrixCursor(columns);
+        cursor.addRow(new Object[] { mediaSetId1, displayName1, coverId1 });
+        cursor.addRow(new Object[] { mediaSetId2, displayName2, coverId2  });
+
+        MediaSetsDatabaseUtil.cacheMediaSets(
+                mFacade.getDatabase(), cursor, categoryId,
+                SearchProvider.AUTHORITY, mimeTypes);
+
+        Bundle extras = new Bundle();
+        extras.putString(
+                MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<>(List.of("image/*")));
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, categoryId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+
+        try (Cursor mediaSets = PickerDataLayerV2.queryMediaSets(extras)) {
+            assertNotNull(mediaSets);
+            assertEquals(2, mediaSets.getCount());
+
+            if (mediaSets.moveToFirst()) {
+                String retrievedMediaSetId1 = mediaSets.getString(mediaSets.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName()));
+                assertEquals(mediaSetId1, retrievedMediaSetId1);
+                String retrievedDisplayName1 = mediaSets.getString(mediaSets.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaGroupResponseColumns.DISPLAY_NAME.getColumnName()));
+                assertEquals(retrievedDisplayName1, displayName1);
+                String retrievedUri1 = mediaSets.getString(mediaSets.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaGroupResponseColumns.UNWRAPPED_COVER_URI
+                                .getColumnName()
+                ));
+                assertTrue(retrievedUri1.contains(coverId1));
+
+                mediaSets.moveToNext();
+                String retrievedMediaSetId2 = mediaSets.getString(mediaSets.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName()));
+                assertEquals(mediaSetId2, retrievedMediaSetId2);
+                String retrievedDisplayName2 = mediaSets.getString(mediaSets.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaGroupResponseColumns.DISPLAY_NAME.getColumnName()));
+                assertEquals(retrievedDisplayName2, displayName2);
+                String retrievedUri2 = mediaSets.getString(mediaSets.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaGroupResponseColumns.UNWRAPPED_COVER_URI
+                                .getColumnName()
+                ));
+                assertTrue(retrievedUri2.contains(coverId2));
+
+            }
+        }
+    }
+
     @Test
     public void queryMediaOnlyLocalWithPreSelection() {
         Cursor cursorLocal1 = getMediaCursor(LOCAL_ID_1, DATE_TAKEN_MS, GENERATION_MODIFIED,
@@ -715,6 +1031,76 @@ public class PickerDataLayerV2Test {
     }
 
     @Test
+    public void testQueryMediaInMediaSet() throws RequestObsoleteException {
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        Long mediaSetPickerId = 1L;
+
+        int cloudRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mFacade.getDatabase(), List.of(
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId)
+                ), CLOUD_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted should be equal to the number of items in the cursor,",
+                /*expected*/cloudRowsInserted,
+                /*actual*/1);
+
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mFacade.getDatabase(), List.of(
+                        getContentValues(LOCAL_ID_1, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        extras.putLong(
+                MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_PICKER_ID,
+                mediaSetPickerId);
+        extras.putString(
+                MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_AUTHORITY,
+                LOCAL_PROVIDER);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.queryMediaInMediaSet(extras)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_1);
+        }
+    }
+
+
+    @Test
+    @DisableFlags(Flags.FLAG_REVOKE_ACCESS_OWNED_PHOTOS)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
     public void testFetchMediaGrantsCount() {
         int testUid = 123;
         int userId = PickerSyncController.uidToUserId(testUid);
@@ -750,7 +1136,7 @@ public class PickerDataLayerV2Test {
         Bundle input = new Bundle();
         input.putInt(Intent.EXTRA_UID, testUid);
 
-        try (Cursor cr = PickerDataLayerV2.fetchMediaGrantsCount(
+        try (Cursor cr = PickerDataLayerV2.fetchCountForPreGrantedItems(
                 mMockContext, input)) {
 
             // cursor should only contain 1 row that represents the count.
@@ -2293,8 +2679,8 @@ public class PickerDataLayerV2Test {
         assertThat(result).isNotNull();
         assertThat(result.getInt("search_request_id")).isEqualTo(1);
 
-        // Assert that both local and cloud syncs were scheduled
-        verify(mMockWorkManager, times(2))
+        // Assert that local sync, cloud sync and cache clearing work was scheduled
+        verify(mMockWorkManager, times(3))
                 .enqueueUniqueWork(anyString(), any(ExistingWorkPolicy.class),
                         any(OneTimeWorkRequest.class));
 
@@ -2309,6 +2695,39 @@ public class PickerDataLayerV2Test {
 
     @Test
     public void testTriggerMediaSetsSyncRequest() {
+        doReturn(true).when(mMockSyncController).shouldQueryLocalMediaSets(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMediaSets(any(), any());
+        doReturn(mMockWorkContinuation)
+                .when(mMockWorkManager)
+                .beginUniqueWork(
+                        anyString(), any(ExistingWorkPolicy.class), any(List.class));
+        // Handle .then chaining
+        doReturn(mMockWorkContinuation)
+                .when(mMockWorkContinuation)
+                .then(any(List.class));
+        doReturn(mMockOperation).when(mMockWorkContinuation).enqueue();
+        doReturn(mMockFuture).when(mMockOperation).getResult();
+
+        Bundle extras = new Bundle();
+        extras.putString(
+                MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putStringArray(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new String[] { "image/*" });
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, "id");
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+
+        PickerDataLayerV2.triggerMediaSetsSync(extras, mContext, mMockWorkManager);
+
+        // Assert that both local and cloud syncs were scheduled
+        verify(mMockWorkManager, times(1)).beginUniqueWork(
+                anyString(), any(ExistingWorkPolicy.class), any(List.class));
+        verify(mMockWorkContinuation, times(1)).then(any(List.class));
+        verify(mMockWorkContinuation, times(1)).enqueue();
+    }
+    @Test
+    public void testTriggerMediaInMediaSetSyncRequest() {
         doReturn(true).when(mMockSyncController).shouldQueryLocalMediaSets(any());
         doReturn(true).when(mMockSyncController).shouldQueryCloudMediaSets(any(), any());
         doReturn(mMockOperation).when(mMockWorkManager)
@@ -2317,12 +2736,13 @@ public class PickerDataLayerV2Test {
         doReturn(mMockFuture).when(mMockOperation).getResult();
 
         Bundle extras = new Bundle();
-        extras.putString("authority", SearchProvider.AUTHORITY);
-        extras.putStringArray("mime_types", new String[] { "image/*" });
-        extras.putString("category_id", "id");
+        extras.putString(
+                MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_AUTHORITY,
+                SearchProvider.AUTHORITY);
+        extras.putLong(MediaInMediaSetSyncRequestParams.KEY_PARENT_MEDIA_SET_PICKER_ID, 1);
         extras.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
 
-        PickerDataLayerV2.triggerMediaSetsSync(extras, mContext, mMockWorkManager);
+        PickerDataLayerV2.triggerMediaSyncForMediaSet(extras, mContext, mMockWorkManager);
 
         // Assert that both local and cloud syncs were scheduled
         verify(mMockWorkManager, times(1))
@@ -2364,6 +2784,11 @@ public class PickerDataLayerV2Test {
                     .that(cursor.getString(cursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName())))
                     .isEqualTo(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES);
+            assertWithMessage("Unexpected picker id")
+                    .that(cursor.getLong(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns
+                                    .PICKER_ID.getColumnName())))
+                    .isEqualTo(0L);
 
             cursor.moveToNext();
             assertWithMessage("Unexpected media group")
@@ -2372,20 +2797,29 @@ public class PickerDataLayerV2Test {
                                     PickerSQLConstants.MediaGroupResponseColumns
                                             .MEDIA_GROUP.getColumnName()))))
                     .isEqualTo(MediaGroup.ALBUM);
-
             assertWithMessage("Unexpected album id")
                     .that(cursor.getString(cursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName())))
                     .isEqualTo(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_CAMERA);
+            assertWithMessage("Unexpected picker id")
+                    .that(cursor.getLong(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns
+                                    .PICKER_ID.getColumnName())))
+                    .isEqualTo(1L);
 
             cursor.moveToNext();
-            // Assert that the next media groupd is people and pets category
+            // Assert that the next media group is people and pets category
             assertWithMessage("Unexpected media group")
                     .that(MediaGroup.valueOf(
                             cursor.getString(cursor.getColumnIndexOrThrow(
                                     PickerSQLConstants.MediaGroupResponseColumns
                                             .MEDIA_GROUP.getColumnName()))))
                     .isEqualTo(MediaGroup.CATEGORY);
+            assertWithMessage("Unexpected picker id")
+                    .that(cursor.getLong(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns
+                                    .PICKER_ID.getColumnName())))
+                    .isEqualTo(2L);
 
             cursor.moveToNext();
             assertWithMessage("Unexpected media group")
@@ -2394,21 +2828,24 @@ public class PickerDataLayerV2Test {
                                     PickerSQLConstants.MediaGroupResponseColumns
                                             .MEDIA_GROUP.getColumnName()))))
                     .isEqualTo(MediaGroup.ALBUM);
-
             assertWithMessage("Unexpected album id")
                     .that(cursor.getString(cursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName())))
                     .isEqualTo(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS);
+            assertWithMessage("Unexpected picker id")
+                    .that(cursor.getLong(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns
+                                    .PICKER_ID.getColumnName())))
+                    .isEqualTo(3L);
 
             cursor.moveToNext();
-            // Assert that the next media groupd is a cloud album
+            // Assert that the next media group is a cloud album
             assertWithMessage("Unexpected media group")
                     .that(MediaGroup.valueOf(
                             cursor.getString(cursor.getColumnIndexOrThrow(
                                     PickerSQLConstants.MediaGroupResponseColumns
                                             .MEDIA_GROUP.getColumnName()))))
                     .isEqualTo(MediaGroup.ALBUM);
-
             final Uri coverUri = Uri.parse(
                     cursor.getString(cursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaGroupResponseColumns
@@ -2416,6 +2853,11 @@ public class PickerDataLayerV2Test {
             assertWithMessage("Unexpected media group")
                     .that(coverUri.getLastPathSegment())
                     .isEqualTo(LOCAL_ID_1);
+            assertWithMessage("Unexpected picker id")
+                    .that(cursor.getLong(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns
+                                    .PICKER_ID.getColumnName())))
+                    .isEqualTo(4L);
         }
     }
 
@@ -2576,4 +3018,18 @@ public class PickerDataLayerV2Test {
         extras.putString("album_authority", albumAuthority);
         return extras;
     }
+
+    private ContentValues getContentValues(
+            String localId, String cloudId, Long mediaSetPickerId) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.CLOUD_ID.getColumnName(), cloudId);
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.LOCAL_ID.getColumnName(), localId);
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.MEDIA_SETS_PICKER_ID
+                        .getColumnName(),
+                mediaSetPickerId);
+        return contentValues;
+    }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java
index 238e1f72a..5a8920674 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java
@@ -30,8 +30,11 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.MockitoAnnotations.initMocks;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.database.Cursor;
+import android.net.Uri;
+import android.os.UserHandle;
 
 import androidx.test.InstrumentationRegistry;
 
@@ -177,4 +180,51 @@ public class MediaGroupCursorUtilsTest {
                 .that(result.size())
                 .isEqualTo(0);
     }
+
+    @Test
+    public void testGetLocalUri() {
+        final String cloudAuthority = "cloud.authority";
+        final String cloudMediaId = "cloud-id";
+        final String localMediaId = "local-id";
+        final Uri cloudUri = new Uri.Builder()
+                .scheme(ContentResolver.SCHEME_CONTENT)
+                .encodedAuthority(cloudAuthority)
+                .appendPath("media")
+                .appendPath(cloudMediaId)
+                .build();
+
+        final String localAuthority = PickerSyncController.getInstanceOrThrow().getLocalProvider();
+        final Uri expectedLocalUri = new Uri.Builder()
+                .scheme(ContentResolver.SCHEME_CONTENT)
+                .encodedAuthority(UserHandle.myUserId() + "@" + localAuthority)
+                .appendPath("media")
+                .appendPath(localMediaId)
+                .build();
+
+        final String actualLocalUri = MediaGroupCursorUtils.maybeGetLocalUri(
+                cloudUri.toString(), Map.of(cloudMediaId, localMediaId));
+
+        assertWithMessage("Mapped local uri is not as expected.")
+                .that(actualLocalUri)
+                .isEqualTo(expectedLocalUri.toString());
+    }
+
+    @Test
+    public void testGetLocalUriWithNoMapping() {
+        final String cloudAuthority = "cloud.authority";
+        final String cloudMediaId = "cloud-id";
+        final Uri cloudUri = new Uri.Builder()
+                .scheme(ContentResolver.SCHEME_CONTENT)
+                .encodedAuthority(cloudAuthority)
+                .appendPath("media")
+                .appendPath(cloudMediaId)
+                .build();
+
+        final String actualUri = MediaGroupCursorUtils.maybeGetLocalUri(
+                cloudUri.toString(), Map.of());
+
+        assertWithMessage("Returned uri is not as expected.")
+                .that(actualUri)
+                .isEqualTo(cloudUri.toString());
+    }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java
index b4eb2af3d..bdb7944d3 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java
@@ -58,6 +58,7 @@ import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
 import com.android.providers.media.photopicker.data.PickerDbFacade;
 import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
 
 import org.junit.After;
 import org.junit.Before;
@@ -100,7 +101,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryLocalMediaInMediaSet() {
+    public void testQueryLocalMediaInMediaSet() throws RequestObsoleteException {
         final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
@@ -108,7 +109,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         int cloudRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -158,7 +159,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryCloudMediaInMediaSet() {
+    public void testQueryCloudMediaInMediaSet() throws RequestObsoleteException {
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
@@ -166,7 +167,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -212,7 +213,8 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryMediaInMediaSetForSpecificMediaSetPickerId() {
+    public void testQueryMediaInMediaSetForSpecificMediaSetPickerId()
+            throws RequestObsoleteException {
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
@@ -220,8 +222,8 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
 
-        String mediaSetPickerId1 = "ms1";
-        String mediaSetPickerId2 = "ms2";
+        Long mediaSetPickerId1 = 1L;
+        Long mediaSetPickerId2 = 2L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -261,7 +263,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryMediaInMediaSetsSortOrder() {
+    public void testQueryMediaInMediaSetsSortOrder() throws RequestObsoleteException {
         final long dateTaken = 0L;
 
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, dateTaken + 1);
@@ -273,7 +275,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, dateTaken);
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -335,7 +337,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryMediaInMediaSetsPagination() {
+    public void testQueryMediaInMediaSetsPagination() throws RequestObsoleteException {
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
@@ -343,7 +345,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -384,7 +386,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryMediaInMediaSetsMimeTypeFilter() {
+    public void testQueryMediaInMediaSetsMimeTypeFilter() throws RequestObsoleteException {
         final Cursor cursor1 = getMediaCursor(CLOUD_ID_1, DATE_TAKEN_MS, GENERATION_MODIFIED,
                 /* mediaStoreUri */ null, /* sizeBytes */ 1, MP4_VIDEO_MIME_TYPE,
                 STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
@@ -402,7 +404,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
                 JPEG_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -453,7 +455,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryMediaInMediaSetsLocalProviderFilter() {
+    public void testQueryMediaInMediaSetsLocalProviderFilter() throws RequestObsoleteException {
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
@@ -463,7 +465,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, 0);
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -507,7 +509,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testQueryMediaInMediaSetsCloudProviderFilter() {
+    public void testQueryMediaInMediaSetsCloudProviderFilter() throws RequestObsoleteException {
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
@@ -517,7 +519,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, 0);
         assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -574,7 +576,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
     }
 
     @Test
-    public void testCacheMediaInMediaSet() {
+    public void testCacheMediaInMediaSet() throws RequestObsoleteException {
         final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
         final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
@@ -582,7 +584,7 @@ public class MediaInMediaSetsDatabaseUtilTest {
         final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
         assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
 
-        String mediaSetPickerId = "mediaSetPickerId";
+        Long mediaSetPickerId = 1L;
 
         int cloudRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
                 mDatabase, List.of(
@@ -607,8 +609,75 @@ public class MediaInMediaSetsDatabaseUtilTest {
                 1);
     }
 
+    @Test
+    public void testClearMediaInMediaSetCache() throws RequestObsoleteException {
+        // Insert data
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        Long mediaSetPickerId = 1L;
+        Long secondMediaSetPickerId = 2L;
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        final long secondCloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, secondMediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, secondMediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, secondMediaSetPickerId)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(secondCloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        // Clear the data
+        MediaInMediaSetsDatabaseUtil.clearMediaInMediaSetsCache(
+                mDatabase, List.of(mediaSetPickerId.toString()));
+
+        // Retrieved cursor for mediaSetPickerId should be empty
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(/*expected*/0, /*actual*/ mediaCursor.getCount());
+
+        // Retrieved cursor for secondmediaSetPickerId should be non-empty
+        Bundle secondExtras = new Bundle();
+        secondExtras.putInt("page_size", 100);
+        secondExtras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        secondExtras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery secondMediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                secondExtras, secondMediaSetPickerId);
+        Cursor secondMediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, secondMediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(secondMediaCursor);
+        assertEquals(/*expected*/3, /*actual*/ secondMediaCursor.getCount());
+
+    }
+
     private ContentValues getContentValues(
-            String localId, String cloudId, String mediaSetPickerId) {
+            String localId, String cloudId, Long mediaSetPickerId) {
         ContentValues contentValues = new ContentValues();
         contentValues.put(
                 PickerSQLConstants.MediaInMediaSetsTableColumns.CLOUD_ID.getColumnName(), cloudId);
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java
index 2aa00cbb4..432f76a32 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java
@@ -26,12 +26,15 @@ import android.content.Context;
 import android.database.Cursor;
 import android.database.MatrixCursor;
 import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
 import android.provider.CloudMediaProviderContract;
 import android.util.Pair;
 
 import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 
 import org.junit.After;
 import org.junit.Before;
@@ -69,7 +72,7 @@ public class MediaSetsDatabaseUtilsTest {
     }
 
     @Test
-    public void testInsertMediaSetMetadataIntoMediaSetsTable() {
+    public void testInsertMediaSetMetadataIntoMediaSetsTable() throws RequestObsoleteException {
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add(mMimeType);
@@ -81,14 +84,16 @@ public class MediaSetsDatabaseUtilsTest {
     }
 
     @Test
-    public void testInsertMediaSetMetadataIntoMediaTableMimeTypeFilter() {
+    public void testInsertMediaSetMetadataIntoMediaTableMimeTypeFilter()
+            throws RequestObsoleteException {
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> firstMimeTypeFilter = new ArrayList<>();
         firstMimeTypeFilter.add("image/*");
         firstMimeTypeFilter.add("video/*");
 
         int firstInsertionCount = MediaSetsDatabaseUtil.cacheMediaSets(
-                mDatabase, c, mCategoryId, mAuthority, firstMimeTypeFilter);
+                mDatabase, c, mCategoryId, mAuthority, firstMimeTypeFilter
+               );
         assertEquals("Count of inserted media sets should be equal to the cursor size",
                 /*expected*/ c.getCount(), /*actual*/ firstInsertionCount);
 
@@ -107,7 +112,7 @@ public class MediaSetsDatabaseUtilsTest {
     }
 
     @Test
-    public void testInsertMediaSetMetadataWhenMediaSetIdIsNull() {
+    public void testInsertMediaSetMetadataWhenMediaSetIdIsNull() throws RequestObsoleteException {
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add(mMimeType);
 
@@ -127,7 +132,7 @@ public class MediaSetsDatabaseUtilsTest {
     }
 
     @Test
-    public void testGetMediaSetMetadataForCategory() {
+    public void testGetMediaSetMetadataForCategory() throws RequestObsoleteException {
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add(mMimeType);
@@ -138,9 +143,16 @@ public class MediaSetsDatabaseUtilsTest {
         assertWithMessage("MediaSet metadata insertion failed")
                 .that(insertResult)
                 .isAtLeast(/* expected min row id */ 0);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, mAuthority);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, mCategoryId);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
 
         Cursor mediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
-                mDatabase, mCategoryId, mAuthority, mimeTypes);
+                mDatabase, requestParams);
         assertNotNull(mediaSetCursor);
         assertWithMessage("Cursor size should be greater than 0. Expected size: 1")
                 .that(mediaSetCursor.getCount())
@@ -154,7 +166,7 @@ public class MediaSetsDatabaseUtilsTest {
     }
 
     @Test
-    public void testUpdateAndGetMediaInMediaSetResumeKey() {
+    public void testUpdateAndGetMediaInMediaSetResumeKey() throws RequestObsoleteException {
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add(mMimeType);
@@ -164,11 +176,18 @@ public class MediaSetsDatabaseUtilsTest {
         // Assert successful insertion
         assertEquals("Count of inserted media sets should be equal to the cursor size",
                 /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, mAuthority);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, mCategoryId);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
         Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
-                mDatabase, mCategoryId, mAuthority, mimeTypes);
-        String mediaSetPickerId = "";
+                mDatabase, requestParams);
+        Long mediaSetPickerId = 1L;
         if (fetchMediaSetCursor.moveToFirst()) {
-            mediaSetPickerId = fetchMediaSetCursor.getString(
+            mediaSetPickerId = fetchMediaSetCursor.getLong(
                     fetchMediaSetCursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
         }
@@ -185,7 +204,8 @@ public class MediaSetsDatabaseUtilsTest {
     }
 
     @Test
-    public void testGetMediaSetIdAndMimeTypesUsingMediaSetPickerId() {
+    public void testGetMediaSetIdAndMimeTypesUsingMediaSetPickerId()
+            throws RequestObsoleteException {
         Cursor c = getCursorForMediaSetInsertionTest();
         List<String> mimeTypes = new ArrayList<>();
         mimeTypes.add(mMimeType);
@@ -195,11 +215,18 @@ public class MediaSetsDatabaseUtilsTest {
         // Assert successful insertion
         assertEquals("Count of inserted media sets should be equal to the cursor size",
                 /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, mAuthority);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, mCategoryId);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
         Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
-                mDatabase, mCategoryId, mAuthority, mimeTypes);
-        String mediaSetPickerId = "";
+                mDatabase, requestParams);
+        Long mediaSetPickerId = 1L;
         if (fetchMediaSetCursor.moveToFirst()) {
-            mediaSetPickerId = fetchMediaSetCursor.getString(
+            mediaSetPickerId = fetchMediaSetCursor.getLong(
                     fetchMediaSetCursor.getColumnIndexOrThrow(
                             PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
         }
@@ -210,6 +237,79 @@ public class MediaSetsDatabaseUtilsTest {
         assertTrue(Arrays.toString(retrievedData.second).contains(mMimeType));
     }
 
+    @Test
+    public void testGetMediaSetPickerIdsForCategoryId() {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        long mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        // Assert successful insertion
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+
+        List<String> mediaSetPickerIds = MediaSetsDatabaseUtil
+                .getMediaSetPickerIdsForGivenCategoryId(mDatabase, mCategoryId, mAuthority);
+        // Assert that the list has some sqlite generated ids
+        assertNotNull(mediaSetPickerIds);
+        assertTrue(!mediaSetPickerIds.isEmpty());
+    }
+
+    @Test
+    public void testClearMediaSetsCache() {
+        // Insert metadata into the table
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+
+        String secondCategoryId = "secCategoryId";
+        int mediaSetsInserted2 = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, secondCategoryId, mAuthority, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted2);
+
+
+        // Delete the inserted items
+        MediaSetsDatabaseUtil.clearMediaSetsCache(mDatabase, mCategoryId, mAuthority);
+
+        // Retrieved cursor should be empty for mCategoryId
+        Bundle extras = new Bundle();
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, mAuthority);
+        extras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, mCategoryId);
+        extras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
+
+        Cursor mediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, requestParams);
+        assertNotNull(mediaSetCursor);
+        assertEquals(/*expected*/ 0, /*actual*/ mediaSetCursor.getCount());
+
+        // Retrieved cursor should not be empty for secondCategoryId since only the media sets for
+        // mCategoryId have been deleted in the previous call
+        Bundle secondExtras = new Bundle();
+        secondExtras.putString(
+                MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_AUTHORITY, mAuthority);
+        secondExtras.putString(MediaSetsSyncRequestParams.KEY_PARENT_CATEGORY_ID, secondCategoryId);
+        secondExtras.putStringArrayList(
+                MediaSetsSyncRequestParams.KEY_MIME_TYPES,
+                new ArrayList<String>(mimeTypes));
+        MediaSetsSyncRequestParams secondRequestParams =
+                new MediaSetsSyncRequestParams(secondExtras);
+
+        Cursor secondMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, secondRequestParams);
+        assertNotNull(secondMediaSetCursor);
+        assertEquals(/*expected*/ 1, /*actual*/ secondMediaSetCursor.getCount());
+    }
+
     private Cursor getCursorForMediaSetInsertionTest() {
         String[] columns = new String[]{
                 CloudMediaProviderContract.MediaSetColumns.ID,
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java
index dcbf6fc09..2ddbd7b99 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java
@@ -85,8 +85,7 @@ public class SearchRequestDatabaseUtilTest {
                 "mountains",
                 "media-set-id",
                 "authority",
-                SEARCH_SUGGESTION_TEXT,
-                null
+                SEARCH_SUGGESTION_TEXT
         );
 
         final long firstInsertResult =
@@ -124,8 +123,7 @@ public class SearchRequestDatabaseUtilTest {
                 "mountains",
                 "media-set-id",
                 "authority",
-                SEARCH_SUGGESTION_TEXT,
-                null
+                SEARCH_SUGGESTION_TEXT
         );
 
         final long secondInsertResult =
@@ -154,8 +152,7 @@ public class SearchRequestDatabaseUtilTest {
                 "mountains",
                 "different-media-set-id",
                 "authority",
-                SEARCH_SUGGESTION_TEXT,
-                null
+                SEARCH_SUGGESTION_TEXT
         );
 
         final long fourthInsertResult =
@@ -233,11 +230,17 @@ public class SearchRequestDatabaseUtilTest {
     public void testGetSearchTextRequestDetails() {
         final List<String> mimeTypes = List.of("video/mp4", "image/*", "image/gif");
         final String searchText = "mountains";
-        final String resumeKey = "RANDOM_RESUME_KEY";
+        final String cloudResumeKey = "RANDOM_RESUME_KEY_CLOUD";
+        final String localResumeKey = "RANDOM_RESUME_KEY_LOCAL";
+        final String cloudAuthority = "com.random.cloud.authority";
+        final String localAuthority = "com.random.local.authority";
         SearchTextRequest searchRequest = new SearchTextRequest(
                 mimeTypes,
                 searchText,
-                resumeKey
+                localResumeKey,
+                localAuthority,
+                cloudResumeKey,
+                cloudAuthority
         );
 
         // Insert a search request
@@ -266,9 +269,18 @@ public class SearchRequestDatabaseUtilTest {
         assertWithMessage("Search request mime types are not as expected")
                 .that(resultSearchRequest.getMimeTypes())
                 .containsExactlyElementsIn(mimeTypes);
-        assertWithMessage("Search request resume key is not as expected")
-                .that(resultSearchRequest.getResumeKey())
-                .isEqualTo(resumeKey);
+        assertWithMessage("Search request cloud resume key is not as expected")
+                .that(resultSearchRequest.getCloudSyncResumeKey())
+                .isEqualTo(cloudResumeKey);
+        assertWithMessage("Search request cloud authority is not as expected")
+                .that(resultSearchRequest.getCloudAuthority())
+                .isEqualTo(cloudAuthority);
+        assertWithMessage("Search request local resume key is not as expected")
+                .that(resultSearchRequest.getLocalSyncResumeKey())
+                .isEqualTo(localResumeKey);
+        assertWithMessage("Search request local authority is not as expected")
+                .that(resultSearchRequest.getLocalAuthority())
+                .isEqualTo(localAuthority);
 
         final SearchTextRequest resultSearchTextRequest = (SearchTextRequest) resultSearchRequest;
         assertWithMessage("Search request search text is not as expected")
@@ -279,17 +291,22 @@ public class SearchRequestDatabaseUtilTest {
     @Test
     public void testGetSearchSuggestionRequestDetails() {
         final List<String> mimeTypes = List.of("video/mp4", "image/*", "image/gif");
-        final String resumeKey = "RANDOM_RESUME_KEY";
+        final String cloudResumeKey = "RANDOM_RESUME_KEY_CLOUD";
+        final String localResumeKey = "RANDOM_RESUME_KEY_LOCAL";
         final String mediaSetID = "MEDIA-SET-ID";
-        final String authority = "com.random.authority";
+        final String cloudAuthority = "com.random.cloud.authority";
+        final String localAuthority = "com.random.local.authority";
         final String suggestionType = SEARCH_SUGGESTION_LOCATION;
         SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
                 mimeTypes,
                 null,
                 mediaSetID,
-                authority,
+                cloudAuthority,
                 suggestionType,
-                resumeKey
+                localResumeKey,
+                localAuthority,
+                cloudResumeKey,
+                cloudAuthority
         );
 
         // Insert a search request
@@ -318,9 +335,18 @@ public class SearchRequestDatabaseUtilTest {
         assertWithMessage("Search request mime types are not as expected")
                 .that(resultSearchRequest.getMimeTypes())
                 .containsExactlyElementsIn(mimeTypes);
-        assertWithMessage("Search request resume key is not as expected")
-                .that(resultSearchRequest.getResumeKey())
-                .isEqualTo(resumeKey);
+        assertWithMessage("Search request cloud resume key is not as expected")
+                .that(resultSearchRequest.getCloudSyncResumeKey())
+                .isEqualTo(cloudResumeKey);
+        assertWithMessage("Search request cloud authority is not as expected")
+                .that(resultSearchRequest.getCloudAuthority())
+                .isEqualTo(cloudAuthority);
+        assertWithMessage("Search request local resume key is not as expected")
+                .that(resultSearchRequest.getLocalSyncResumeKey())
+                .isEqualTo(localResumeKey);
+        assertWithMessage("Search request local authority is not as expected")
+                .that(resultSearchRequest.getLocalAuthority())
+                .isEqualTo(localAuthority);
 
         final SearchSuggestionRequest resultSearchSuggestionRequest =
                 (SearchSuggestionRequest) resultSearchRequest;
@@ -332,7 +358,7 @@ public class SearchRequestDatabaseUtilTest {
                 .isEqualTo(mediaSetID);
         assertWithMessage("Search request search text is not as expected")
                 .that(resultSearchSuggestionRequest.getSearchSuggestion().getAuthority())
-                .isEqualTo(authority);
+                .isEqualTo(cloudAuthority);
         assertWithMessage("Search request search text is not as expected")
                 .that(resultSearchSuggestionRequest.getSearchSuggestion().getSearchSuggestionType())
                 .isEqualTo(suggestionType);
@@ -349,8 +375,7 @@ public class SearchRequestDatabaseUtilTest {
                 null,
                 mediaSetID,
                 authority,
-                suggestionType,
-                null
+                suggestionType
         );
 
         // Insert a search request
@@ -370,20 +395,178 @@ public class SearchRequestDatabaseUtilTest {
         // Fetch search details from search request ID
         final SearchRequest savedSearchRequest =
                 SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
-        assertWithMessage("Initial search request resume key is not null")
-                .that(savedSearchRequest.getResumeKey())
+        assertWithMessage("Search request is null")
+                .that(savedSearchRequest)
+                .isNotNull();
+        assertWithMessage("Initial search request cloud resume key is not null")
+                .that(savedSearchRequest.getCloudSyncResumeKey())
+                .isNull();
+        assertWithMessage("Initial search request cloud authority is not null")
+                .that(savedSearchRequest.getCloudAuthority())
+                .isNull();
+        assertWithMessage("Initial search request local sync resume key is not null")
+                .that(savedSearchRequest.getLocalSyncResumeKey())
+                .isNull();
+        assertWithMessage("Initial search request local authority is not null")
+                .that(savedSearchRequest.getLocalAuthority())
                 .isNull();
 
-        // Update resume key and save
-        final String randomResumeKey = "RAMDOM_RESUME_KEY";
-        savedSearchRequest.setResumeKey(randomResumeKey);
-        SearchRequestDatabaseUtil.updateResumeKey(mDatabase, searchRequestID, randomResumeKey);
+        // Update cloud resume key and save
+        final String cloudResumeKey = "CLOUD_RESUME_KEY";
+        final String cloudAuthority = "CLOUD_AUTHORITY";
+        SearchRequestDatabaseUtil.updateResumeKey(mDatabase, searchRequestID, cloudResumeKey,
+                cloudAuthority, /* isLocal */ false);
 
         // Fetch updated search details from search request ID
-        final SearchRequest updatedSearchRequest =
+        final SearchRequest updatedSearchRequest1 =
                 SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
-        assertWithMessage("Initial search request resume key is not null")
-                .that(updatedSearchRequest.getResumeKey())
-                .isEqualTo(randomResumeKey);
+        assertWithMessage("Search request is null")
+                .that(updatedSearchRequest1)
+                .isNotNull();
+        assertWithMessage("Search request cloud resume key is not as expected")
+                .that(updatedSearchRequest1.getCloudSyncResumeKey())
+                .isEqualTo(cloudResumeKey);
+        assertWithMessage("Search request cloud authority is not as expected")
+                .that(updatedSearchRequest1.getCloudAuthority())
+                .isEqualTo(cloudAuthority);
+        assertWithMessage("Search request local sync resume key is not null")
+                .that(updatedSearchRequest1.getLocalSyncResumeKey())
+                .isNull();
+        assertWithMessage("Initial search request local authority is not null")
+                .that(updatedSearchRequest1.getLocalAuthority())
+                .isNull();
+
+        // Update local resume key and save
+        final String localResumeKey = "LOCAL_RESUME_KEY";
+        final String localAuthority = "LOCAL_AUTHORITY";
+        SearchRequestDatabaseUtil.updateResumeKey(mDatabase, searchRequestID, localResumeKey,
+                localAuthority, /* isLocal */ true);
+
+        // Clear cloud resume key
+        SearchRequestDatabaseUtil.clearSyncResumeInfo(mDatabase, List.of(searchRequestID),
+                /* isLocal */ false);
+
+        // Fetch updated search details from search request ID
+        final SearchRequest updatedSearchRequest2 =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
+        assertWithMessage("Search request is null")
+                .that(updatedSearchRequest2)
+                .isNotNull();
+        assertWithMessage("Search request local resume key is not as expected")
+                .that(updatedSearchRequest2.getLocalSyncResumeKey())
+                .isEqualTo(localResumeKey);
+        assertWithMessage("Search request local authority is not as expected")
+                .that(updatedSearchRequest2.getLocalAuthority())
+                .isEqualTo(localAuthority);
+        assertWithMessage("Search request cloud sync resume key is not null")
+                .that(updatedSearchRequest2.getCloudSyncResumeKey())
+                .isNull();
+        assertWithMessage("Initial search request cloud authority is not null")
+                .that(updatedSearchRequest2.getCloudAuthority())
+                .isNull();
+    }
+
+    @Test
+    public void testGetSyncedRequestIds() {
+        // Insert a search request in the database.
+        final SearchTextRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "mountains"
+        );
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest1);
+
+        // Get search request ID
+        final int searchRequestID1 =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest1);
+        assertWithMessage("Search request ID should exist in DB")
+                .that(searchRequestID1)
+                .isAtLeast(0);
+
+        // Update local resume key and save
+        final String localResumeKey = "LOCAL_RESUME_KEY";
+        final String localAuthority = "LOCAL_AUTHORITY";
+        SearchRequestDatabaseUtil.updateResumeKey(mDatabase, searchRequestID1, localResumeKey,
+                localAuthority, /* isLocal */ true);
+
+        // Insert another search request in the database.
+        final SearchTextRequest searchRequest2 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "volcano"
+        );
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest2);
+
+        // Get search request ID
+        final int searchRequestID2 =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest2);
+        assertWithMessage("Search request ID should exist in DB")
+                .that(searchRequestID2)
+                .isAtLeast(0);
+
+        // Update cloud resume key and save
+        final String cloudResumeKey = "CLOUD_RESUME_KEY";
+        final String cloudAuthority = "CLOUD_AUTHORITY";
+        SearchRequestDatabaseUtil.updateResumeKey(mDatabase, searchRequestID2, cloudResumeKey,
+                cloudAuthority, /* isLocal */ false);
+
+        final List<Integer> localSyncedSearchRequests =
+                SearchRequestDatabaseUtil.getSyncedRequestIds(
+                        mDatabase,
+                        /* isLocal */ true
+                );
+        assertWithMessage("Unexpected count of search requests received.")
+                .that(localSyncedSearchRequests.size())
+                .isEqualTo(1);
+        assertWithMessage("Unexpected search request id.")
+                .that(localSyncedSearchRequests.get(0))
+                .isEqualTo(searchRequestID1);
+
+        final List<Integer> cloudSyncedSearchRequests =
+                SearchRequestDatabaseUtil.getSyncedRequestIds(
+                        mDatabase,
+                        /* isLocal */ false
+                );
+        assertWithMessage("Unexpected count of search requests received.")
+                .that(cloudSyncedSearchRequests.size())
+                .isEqualTo(1);
+        assertWithMessage("Unexpected search request id.")
+                .that(cloudSyncedSearchRequests.get(0))
+                .isEqualTo(searchRequestID2);
+    }
+
+    @Test
+    public void testClearAllSearchRequests() {
+        // Insert a search request in the database.
+        final SearchTextRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "mountains"
+        );
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest1);
+
+        // Insert another search request in the database.
+        final SearchTextRequest searchRequest2 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "volcano"
+        );
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest2);
+
+        assertWithMessage("Search request ID should exist in DB")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest1))
+                .isAtLeast(0);
+        assertWithMessage("Search request ID should exist in DB")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest2))
+                .isAtLeast(0);
+
+        final int deletedSearchRequestsCount =
+                SearchRequestDatabaseUtil.clearAllSearchRequests(mDatabase);
+
+        assertWithMessage("Incorrect search requests were deleted.")
+                .that(deletedSearchRequestsCount)
+                .isEqualTo(2);
+        assertWithMessage("Search request ID should not exist in DB")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest1))
+                .isEqualTo(-1);
+        assertWithMessage("Search request ID should not exist in DB")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest2))
+                .isEqualTo(-1);
     }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java
index 94b1ef6c3..0cc04f7ca 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java
@@ -124,7 +124,8 @@ public class SearchResultsDatabaseUtilTest {
 
         final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, CLOUD_PROVIDER, List.of(
-                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)));
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)),
+                /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -132,7 +133,8 @@ public class SearchResultsDatabaseUtilTest {
 
         final long localRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, LOCAL_PROVIDER, List.of(
-                        getContentValues(LOCAL_ID_1, null, searchRequestId1)));
+                        getContentValues(LOCAL_ID_1, null, searchRequestId1)),
+                /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(localRowsInsertedCount)
@@ -188,7 +190,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(null, CLOUD_ID_3, searchRequestId1),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -252,7 +254,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(null, CLOUD_ID_3, searchRequestId3),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId2),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -306,7 +308,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(null, CLOUD_ID_3, searchRequestId1),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -315,7 +317,7 @@ public class SearchResultsDatabaseUtilTest {
         final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, LOCAL_PROVIDER, List.of(
                         getContentValues(LOCAL_ID_4, null, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -387,7 +389,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(null, CLOUD_ID_3, searchRequestId1),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -396,7 +398,7 @@ public class SearchResultsDatabaseUtilTest {
         final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, LOCAL_PROVIDER, List.of(
                         getContentValues(LOCAL_ID_4, null, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -464,7 +466,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(null, CLOUD_ID_3, searchRequestId1),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -473,7 +475,7 @@ public class SearchResultsDatabaseUtilTest {
         final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, LOCAL_PROVIDER, List.of(
                         getContentValues(LOCAL_ID_4, null, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -532,7 +534,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(null, CLOUD_ID_3, searchRequestId1),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(cloudRowsInsertedCount)
@@ -541,7 +543,7 @@ public class SearchResultsDatabaseUtilTest {
         final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, LOCAL_PROVIDER, List.of(
                         getContentValues(LOCAL_ID_4, null, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -595,7 +597,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1),
                         getContentValues(LOCAL_ID_4, null, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -657,7 +659,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(LOCAL_ID_1, null, searchRequestId2),
                         getContentValues(LOCAL_ID_2, null, searchRequestId2),
                         getContentValues(LOCAL_ID_2, null, searchRequestId2)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -734,7 +736,7 @@ public class SearchResultsDatabaseUtilTest {
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId2),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
                         getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)
-                ));
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -804,12 +806,15 @@ public class SearchResultsDatabaseUtilTest {
         final int searchRequestId1 = 1;
 
         // Batch insert items in the search results table.
-        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+        long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_2, null, searchRequestId1)
+                ), /* cancellationSignal */ null);
+        rowsInsertedCount += SearchResultsDatabaseUtil.cacheSearchResults(
                 mDatabase, CLOUD_PROVIDER, List.of(
                         getContentValues(null, CLOUD_ID_1, searchRequestId1),
-                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
-                        getContentValues(LOCAL_ID_2, null, searchRequestId1)
-                ));
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)
+                ), /* cancellationSignal */ null);
 
         assertWithMessage("Unexpected number of rows inserted in the search results table")
                 .that(rowsInsertedCount)
@@ -846,6 +851,145 @@ public class SearchResultsDatabaseUtilTest {
         }
     }
 
+    @Test
+    public void testClearObsoleteSearchResults() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        final int searchRequestId1 = 1;
+        // Batch insert items in the search results table.
+        long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_2, null, searchRequestId1)
+                ), /* cancellationSignal */ null);
+        rowsInsertedCount += SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_1, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)
+                ), /* cancellationSignal */ null);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(2);
+
+        final Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(List.of(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        // Query items for searchRequestId
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+        }
+
+        // Clear search results received from the cloud provider.
+        SearchResultsDatabaseUtil.clearObsoleteSearchResults(mDatabase, List.of(searchRequestId1),
+                /* isLocal */ false);
+
+        // Verify cloud results have been cleared
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(1);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+        }
+
+        // Clear search results received from the local provider.
+        SearchResultsDatabaseUtil.clearObsoleteSearchResults(mDatabase, List.of(searchRequestId1),
+                /* isLocal */ true);
+
+        // Verify cloud results have been cleared
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(0);
+        }
+    }
+
+    @Test
+    public void testClearAllSearchResults() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+
+        final int searchRequestId1 = 1;
+        SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_1, null, searchRequestId1)
+                ), /* cancellationSignal */ null);
+        SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_1, searchRequestId1)
+                ), /* cancellationSignal */ null);
+
+        final Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(List.of(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        // Query items for searchRequestId
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+        }
+
+        // Clear all search results
+        SearchResultsDatabaseUtil.clearAllSearchResults(mDatabase);
+
+        // Query items for searchRequestId
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(0);
+        }
+    }
+
     private ContentValues getContentValues(String localId, String cloudId, int searchRequestId) {
         ContentValues contentValues = new ContentValues();
         contentValues.put(
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java
index 69af297d8..d38801741 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java
@@ -21,8 +21,12 @@ import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_HIST
 import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_FACE;
 import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_LOCATION;
 
+import static com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils.TTL_CACHED_SUGGESTIONS_IN_DAYS;
+import static com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils.TTL_HISTORY_SUGGESTIONS_IN_DAYS;
+
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
 import android.database.MatrixCursor;
@@ -35,6 +39,7 @@ import androidx.annotation.Nullable;
 import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
 import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
 import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
@@ -46,6 +51,7 @@ import org.junit.Test;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 public class SearchSuggestionsDatabaseUtilTest {
     private SQLiteDatabase mDatabase;
@@ -115,8 +121,7 @@ public class SearchSuggestionsDatabaseUtilTest {
                 null,
                 mediaSetID,
                 authority,
-                SEARCH_SUGGESTION_LOCATION,
-                null
+                SEARCH_SUGGESTION_LOCATION
         );
 
         SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
@@ -159,8 +164,7 @@ public class SearchSuggestionsDatabaseUtilTest {
                 null,
                 mediaSetID,
                 authority,
-                SEARCH_SUGGESTION_LOCATION,
-                null
+                SEARCH_SUGGESTION_LOCATION
         );
 
         SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
@@ -198,8 +202,7 @@ public class SearchSuggestionsDatabaseUtilTest {
                 null,
                 mediaSetId2,
                 authority2,
-                SEARCH_SUGGESTION_LOCATION,
-                null
+                SEARCH_SUGGESTION_LOCATION
         );
 
         SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
@@ -264,41 +267,44 @@ public class SearchSuggestionsDatabaseUtilTest {
                 null,
                 mediaSetId2,
                 authority2,
-                SEARCH_SUGGESTION_LOCATION,
-                null
+                SEARCH_SUGGESTION_LOCATION
         );
 
         SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
 
+        final String searchText3 = "Mormot";
+        final SearchTextRequest searchRequest3 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                searchText3
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest3);
+
         final List<SearchSuggestion> searchSuggestions =
                 SearchSuggestionsDatabaseUtils.getHistorySuggestions(
                         mDatabase,
                         getSearchSuggestionQuery(
                                 /* providers */ List.of(authority2),
                                 /* limit */ 10,
-                                /* historyLimit */ 1,
-                                /* prefix */ ""));
+                                /* historyLimit */ 2,
+                                /* prefix */ "mo"));
 
         assertWithMessage("Search history suggestions cannot be null")
                 .that(searchSuggestions)
                 .isNotNull();
         assertWithMessage("Unexpected number of search history suggestions.")
                 .that(searchSuggestions.size())
-                .isEqualTo(1);
+                .isEqualTo(2);
 
-        final SearchSuggestion result = searchSuggestions.get(0);
+        final SearchSuggestion suggestion1 = searchSuggestions.get(0);
         assertWithMessage("Search history search text is not as expected")
-                .that(result.getSearchText())
-                .isNull();
-        assertWithMessage("Search history media set id is not as expected")
-                .that(result.getMediaSetId())
-                .isEqualTo(mediaSetId2);
-        assertWithMessage("Search history authority is not as expected")
-                .that(result.getAuthority())
-                .isEqualTo(authority2);
-        assertWithMessage("Search history suggestion type is not as expected")
-                .that(result.getSearchSuggestionType())
-                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+                .that(suggestion1.getSearchText())
+                .isEqualTo(searchText3);
+
+        final SearchSuggestion suggestion2 = searchSuggestions.get(1);
+        assertWithMessage("Search history search text is not as expected")
+                .that(suggestion2.getSearchText())
+                .isEqualTo(searchText1);
     }
 
     @Test
@@ -316,8 +322,7 @@ public class SearchSuggestionsDatabaseUtilTest {
                 searchText2,
                 "mediaSetId",
                 "authority",
-                SEARCH_SUGGESTION_LOCATION,
-                null
+                SEARCH_SUGGESTION_LOCATION
         );
         SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
 
@@ -532,6 +537,66 @@ public class SearchSuggestionsDatabaseUtilTest {
                 .isEqualTo(searchSuggestion2.getSearchText());
     }
 
+    @Test
+    public void testSuggestionsCacheQueryLimit() {
+        final String searchText1 = "BUTTER";
+        final String mediaSetId1 = "MEDIA-SET-ID-1";
+        final String authority = "com.random.authority";
+        SearchSuggestion searchSuggestion1 = new SearchSuggestion(
+                searchText1,
+                mediaSetId1,
+                authority,
+                SEARCH_SUGGESTION_LOCATION,
+                /* coverMediaId */ null
+        );
+
+        final String searchText2 = "dragon";
+        final String mediaSetId2 = "MEDIA-SET-ID-2";
+        SearchSuggestion searchSuggestion2 = new SearchSuggestion(
+                searchText2,
+                mediaSetId2,
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+
+        final String searchText3 = "Butterfly";
+        final String mediaSetId3 = "MEDIA-SET-ID-3";
+        SearchSuggestion searchSuggestion3 = new SearchSuggestion(
+                searchText3,
+                mediaSetId3,
+                authority,
+                SEARCH_SUGGESTION_FACE,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(mDatabase, authority,
+                List.of(searchSuggestion1, searchSuggestion2, searchSuggestion3));
+
+        final List<SearchSuggestion> resultSearchSuggestions =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("test", authority),
+                                /* limit */ 2,
+                                /* historyLimit */ 3,
+                                /* prefix */ "but"));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions.size())
+                .isEqualTo(2);
+
+        assertWithMessage("Search search text is not as expected")
+                .that(resultSearchSuggestions.get(1).getSearchText())
+                .isEqualTo(searchSuggestion3.getSearchText());
+        assertWithMessage("Search search text is not as expected")
+                .that(resultSearchSuggestions.get(0).getSearchText())
+                .isEqualTo(searchSuggestion1.getSearchText());
+    }
+
     @Test
     public void testSaveSuggestionWithNullMediaSetId() {
         final String authority = "com.random.authority";
@@ -615,6 +680,199 @@ public class SearchSuggestionsDatabaseUtilTest {
                 .isEqualTo(1);
     }
 
+    @Test
+    public void testClearExpiredCachedSuggestions() {
+        final String authority = "com.random.authority";
+        SearchSuggestion searchSuggestion1 = new SearchSuggestion(
+                /* searchText */ null,
+                "media-set-id1",
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+        SearchSuggestion searchSuggestion2 = new SearchSuggestion(
+                /* searchText */ "test",
+                "media-set-id2",
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority, List.of(searchSuggestion1, searchSuggestion2));
+
+        final ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.CREATION_TIME_MS.getColumnName(),
+                System.currentTimeMillis()
+                        - TimeUnit.DAYS.toMillis(TTL_CACHED_SUGGESTIONS_IN_DAYS + 1));
+        mDatabase.update(
+                PickerSQLConstants.Table.SEARCH_SUGGESTION.name(),
+                contentValues,
+                PickerSQLConstants.SearchSuggestionsTableColumns.MEDIA_SET_ID.getColumnName()
+                        + " = 'media-set-id2'", null);
+
+        final int rowsDeletedCount =
+                SearchSuggestionsDatabaseUtils.clearExpiredCachedSearchSuggestions(mDatabase);
+        assertWithMessage("Unexpected number of expired cached suggestions deleted.")
+                .that(rowsDeletedCount)
+                .isEqualTo(1);
+    }
+
+    @Test
+    public void testClearExpiredHistorySuggestions() {
+        SearchRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "summer"
+        );
+        SearchRequest searchRequest2 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "coffee"
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest1);
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
+
+        final ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.SearchHistoryTableColumns.CREATION_TIME_MS.getColumnName(),
+                System.currentTimeMillis()
+                        - TimeUnit.DAYS.toMillis(TTL_HISTORY_SUGGESTIONS_IN_DAYS + 1));
+        mDatabase.update(
+                PickerSQLConstants.Table.SEARCH_HISTORY.name(),
+                contentValues,
+                PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName()
+                        + " = 'summer'", null);
+
+        final int rowsDeletedCount =
+                SearchSuggestionsDatabaseUtils.clearExpiredHistorySearchSuggestions(mDatabase);
+        assertWithMessage("Unexpected number of expired history suggestions deleted.")
+                .that(rowsDeletedCount)
+                .isEqualTo(1);
+    }
+
+    @Test
+    public void testClearCachedSuggestionsForAuthority() {
+        final String authority1 = "com.random.authority1";
+        final String authority2 = "com.random.authority2";
+        SearchSuggestion searchSuggestion1 = new SearchSuggestion(
+                /* searchText */ null,
+                "media-set-id1",
+                authority1,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+        SearchSuggestion searchSuggestion2 = new SearchSuggestion(
+                /* searchText */ "test",
+                "media-set-id2",
+                authority2,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority1, List.of(searchSuggestion1));
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority2, List.of(searchSuggestion2));
+
+        int rowsDeletedCount =
+                SearchSuggestionsDatabaseUtils.clearCachedSearchSuggestionsForAuthority(
+                        mDatabase, authority1);
+        assertWithMessage("Unexpected number of cached suggestions deleted.")
+                .that(rowsDeletedCount)
+                .isEqualTo(1);
+
+        rowsDeletedCount =
+                SearchSuggestionsDatabaseUtils.clearCachedSearchSuggestionsForAuthority(
+                        mDatabase, null);
+        assertWithMessage("Unexpected number of cached suggestions deleted.")
+                .that(rowsDeletedCount)
+                .isEqualTo(1);
+    }
+
+    @Test
+    public void testClearHistorySuggestionsForAuthority() {
+        final String authority1 = "com.random.authority1";
+        final String authority2 = "com.random.authority2";
+
+        SearchRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "summer"
+        );
+        SearchRequest searchRequest2 = new SearchSuggestionRequest(
+                /* mimeTypes */ null,
+                /* searchText */ null,
+                "media-set-id1",
+                authority1,
+                SEARCH_SUGGESTION_ALBUM
+        );
+        SearchRequest searchRequest3 = new SearchSuggestionRequest(
+                /* mimeTypes */ null,
+                /* searchText */ "test",
+                "media-set-id2",
+                authority2,
+                SEARCH_SUGGESTION_ALBUM
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest1);
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest3);
+
+        int rowsDeletedCount =
+                SearchSuggestionsDatabaseUtils.clearHistorySearchSuggestionsForAuthority(
+                        mDatabase, authority1);
+        assertWithMessage("Unexpected number of history suggestions deleted.")
+                .that(rowsDeletedCount)
+                .isEqualTo(1);
+
+        rowsDeletedCount =
+                SearchSuggestionsDatabaseUtils.clearHistorySearchSuggestionsForAuthority(
+                        mDatabase, null);
+        assertWithMessage("Unexpected number of history suggestions deleted.")
+                .that(rowsDeletedCount)
+                .isEqualTo(1);
+    }
+
+    @Test
+    public void testSaveDuplicateSearchHistorySuggestion() {
+        final String searchText = "mountains";
+        final SearchTextRequest searchRequest = new SearchTextRequest(
+                /* mimeTypes */ null,
+                searchText
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of(),
+                                /* limit */ 10));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(1);
+
+        final SearchSuggestion result = searchSuggestions.get(0);
+        assertWithMessage("Search history search text is not as expected")
+                .that(result.getSearchText())
+                .isEqualTo(searchText);
+        assertWithMessage("Search history media set id is not as expected")
+                .that(result.getMediaSetId())
+                .isNull();
+        assertWithMessage("Search history authority is not as expected")
+                .that(result.getAuthority())
+                .isNull();
+        assertWithMessage("Search history suggestion type is not as expected")
+                .that(result.getSearchSuggestionType())
+                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+    }
+
     private Cursor getCursor(@NonNull List<SearchSuggestion> searchSuggestions) {
         final MatrixCursor cursor = new MatrixCursor(
                 CloudMediaProviderContract.SearchSuggestionColumns.ALL_PROJECTION);
diff --git a/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java b/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java
index 0461e9aec..5e227385a 100644
--- a/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java
+++ b/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java
@@ -30,6 +30,7 @@ import static org.junit.Assert.assertTrue;
 
 import android.content.Context;
 import android.database.Cursor;
+import android.os.OperationCanceledException;
 import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.platform.test.flag.junit.CheckFlagsRule;
 import android.platform.test.flag.junit.DeviceFlagsValueProvider;
@@ -79,7 +80,7 @@ public class PickerSearchProviderClientTest {
     @Test
     public void testFetchSuggestedSearchResultsFromCmp() {
         Cursor cursor = mPickerSearchProviderClient.fetchSearchResultsFromCmp(
-                TEST_SEARCH_SUGGESTION_MEDIA_SET_ID, null, 1, 100,
+                TEST_SEARCH_SUGGESTION_MEDIA_SET_ID, null, 1, null, 100,
                 null, null);
         cursor.moveToFirst();
         assertEquals(TEST_MEDIA_ID_FROM_SUGGESTED_SEARCH, cursor.getString(cursor.getColumnIndex(
@@ -90,7 +91,7 @@ public class PickerSearchProviderClientTest {
     @Test
     public void testFetchTextSearchResultsFromCmp() {
         Cursor cursor = mPickerSearchProviderClient.fetchSearchResultsFromCmp(
-                null, "test", 1, 100,
+                null, "test", 1, null, 100,
                 null, null);
         cursor.moveToFirst();
         assertEquals(TEST_MEDIA_ID_FROM_TEXT_SEARCH, cursor.getString(cursor.getColumnIndex(
@@ -99,7 +100,7 @@ public class PickerSearchProviderClientTest {
     }
 
     @Test
-    public void testFetchMediasInMediaSetFromCmp() {
+    public void testFetchMediasInMediaSetFromCmp() throws OperationCanceledException {
         Cursor cursor = mPickerSearchProviderClient.fetchMediasInMediaSetFromCmp(TEST_MEDIA_SET_ID,
                 null, 100, CloudMediaProviderContract.SORT_ORDER_DESC_DATE_TAKEN,
                 null, null);
@@ -120,7 +121,7 @@ public class PickerSearchProviderClientTest {
     }
 
     @Test
-    public void testFetchMediaSetsFromCmp() {
+    public void testFetchMediaSetsFromCmp() throws OperationCanceledException {
         Cursor cursor = mPickerSearchProviderClient.fetchMediaSetsFromCmp(TEST_MEDIA_CATEGORY_ID,
                 null, 10, null, null);
         cursor.moveToFirst();
diff --git a/tests/src/com/android/providers/media/scan/ModernMediaScannerTest.java b/tests/src/com/android/providers/media/scan/ModernMediaScannerTest.java
index b3698d849..a87af175b 100644
--- a/tests/src/com/android/providers/media/scan/ModernMediaScannerTest.java
+++ b/tests/src/com/android/providers/media/scan/ModernMediaScannerTest.java
@@ -30,6 +30,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeFalse;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
@@ -49,6 +50,7 @@ import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
 import android.os.ParcelFileDescriptor;
+import android.os.UserManager;
 import android.platform.test.annotations.EnableFlags;
 import android.platform.test.flag.junit.SetFlagsRule;
 import android.provider.MediaStore;
@@ -468,6 +470,11 @@ public class ModernMediaScannerTest {
      */
     @Test
     public void testVisibleDefaultFolders() throws Exception {
+        // Skip test if running in Headless System User Mode
+        // We cannot create nomedia file in public directories for secondary users except
+        // in [Documents, Downloads].
+        assumeFalse(UserManager.isHeadlessSystemUserMode());
+
         final File root = new File("storage/emulated/0");
 
         assertVisibleFolder(root);
@@ -494,6 +501,10 @@ public class ModernMediaScannerTest {
      */
     @Test
     public void testVisibleRootWithNoMediaDirectory() throws Exception {
+        // Skip test if running in Headless System User Mode
+        // We cannot create test files in root directory for secondary users.
+        assumeFalse(UserManager.isHeadlessSystemUserMode());
+
         final File root = new File("storage/emulated/0");
         final File nomediaDir = new File(root, ".nomedia");
         final File file = new File(nomediaDir, "test.jpg");
@@ -949,8 +960,8 @@ public class ModernMediaScannerTest {
             assertThat(cursor.getCount()).isEqualTo(1);
         }
 
-        // Delete the pending file to make the row is stale
-        executeShellCommand("rm " + audio.getAbsolutePath());
+        // Delete the pending file to make the row is stale.
+        audio.delete();
         assertThat(audio.exists()).isFalse();
 
         // the row still exists
@@ -992,7 +1003,7 @@ public class ModernMediaScannerTest {
         }
 
         // Delete the pending file to make the row is stale
-        executeShellCommand("rm " + audio.getAbsolutePath());
+        audio.delete();
         assertThat(audio.exists()).isFalse();
 
         // the row still exists
@@ -1034,7 +1045,7 @@ public class ModernMediaScannerTest {
         }
 
         // Delete the trashed file to make the row is stale
-        executeShellCommand("rm " + audio.getAbsolutePath());
+        audio.delete();
         assertThat(audio.exists()).isFalse();
 
         // the row still exists
@@ -1076,7 +1087,7 @@ public class ModernMediaScannerTest {
         }
 
         // Delete the trashed file to make the row is stale
-        executeShellCommand("rm " + audio.getAbsolutePath());
+        audio.delete();
         assertThat(audio.exists()).isFalse();
 
         // the row still exists
@@ -1113,7 +1124,7 @@ public class ModernMediaScannerTest {
         }
 
         // Delete the file to make the row is stale
-        executeShellCommand("rm " + audio.getAbsolutePath());
+        audio.delete();
         assertThat(audio.exists()).isFalse();
 
         // the row still exists
diff --git a/tests/src/com/android/providers/media/util/FileUtilsTest.java b/tests/src/com/android/providers/media/util/FileUtilsTest.java
index 7c63807e5..637d4be80 100644
--- a/tests/src/com/android/providers/media/util/FileUtilsTest.java
+++ b/tests/src/com/android/providers/media/util/FileUtilsTest.java
@@ -73,6 +73,7 @@ import static org.junit.Assert.fail;
 import android.content.ContentValues;
 import android.os.Environment;
 import android.os.SystemProperties;
+import android.os.UserHandle;
 import android.provider.MediaStore;
 import android.provider.MediaStore.Audio.AudioColumns;
 import android.provider.MediaStore.MediaColumns;
@@ -935,8 +936,9 @@ public class FileUtilsTest {
     // Visibility of default dirs is tested in ModernMediaScannerTest#testVisibleDefaultFolders.
     @Test
     public void testIsDirectoryHidden() throws Exception {
+        int userId = UserHandle.myUserId();
         for (String prefix : new String[] {
-                "/storage/emulated/0",
+                String.format(Locale.ROOT, "/storage/emulated/%d", userId),
                 "/storage/0000-0000",
         }) {
             assertDirectoryNotHidden(new File(prefix));
@@ -945,7 +947,9 @@ public class FileUtilsTest {
             assertDirectoryHidden(new File(prefix + "/.meow"));
         }
 
-        final File nomediaFile = new File("storage/emulated/0/Download/meow", ".nomedia");
+        final File nomediaFile = new File(
+                String.format(Locale.ROOT, "storage/emulated/%d/Download/meow", userId),
+                ".nomedia");
         try {
             assertTrue(nomediaFile.getParentFile().mkdirs());
             assertTrue(nomediaFile.createNewFile());
@@ -1219,13 +1223,18 @@ public class FileUtilsTest {
 
     @Test
     public void testToAndFromFuseFile() throws Exception {
-        final File fuseFilePrimary = new File("/mnt/user/0/emulated/0/foo");
-        final File fuseFileSecondary = new File("/mnt/user/0/0000-0000/foo");
-
-        final File lowerFsFilePrimary = new File("/storage/emulated/0/foo");
+        int userId = UserHandle.myUserId();
+        final File fuseFilePrimary = new File(
+                String.format(Locale.ROOT, "/mnt/user/%d/emulated/%d/foo", userId, userId));
+        final File fuseFileSecondary = new File(
+                String.format(Locale.ROOT, "/mnt/user/%d/0000-0000/foo", userId));
+
+        final File lowerFsFilePrimary = new File(
+                String.format(Locale.ROOT, "/storage/emulated/%d/foo", userId));
         final File lowerFsFileSecondary = new File("/storage/0000-0000/foo");
 
-        final File unexpectedFile = new File("/mnt/pass_through/0/emulated/0/foo");
+        final File unexpectedFile = new File(
+                String.format(Locale.ROOT, "/mnt/pass_through/%d/emulated/%d/foo", userId, userId));
 
         assertThat(fromFuseFile(fuseFilePrimary)).isEqualTo(lowerFsFilePrimary);
         assertThat(fromFuseFile(fuseFileSecondary)).isEqualTo(lowerFsFileSecondary);
diff --git a/tests/src/com/android/providers/media/util/MimeTypeFixHandlerTest.java b/tests/src/com/android/providers/media/util/MimeTypeFixHandlerTest.java
new file mode 100644
index 000000000..738d2008e
--- /dev/null
+++ b/tests/src/com/android/providers/media/util/MimeTypeFixHandlerTest.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.ClipDescription;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Build;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Files.FileColumns;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.SdkSuppress;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.providers.media.flags.Flags;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Objects;
+import java.util.Optional;
+
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+public class MimeTypeFixHandlerTest {
+    @Rule public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
+
+    private SQLiteDatabase mDatabase;
+    private static final String FILES_TABLE_NAME = MediaStore.Files.TABLE;
+    private static final String DATABASE_FILE = "mime_type_fix.db";
+
+    @Before
+    public void setUp() throws Exception {
+        assumeTrue(Build.VERSION.SDK_INT == Build.VERSION_CODES.VANILLA_ICE_CREAM);
+        final Context context = InstrumentationRegistry.getTargetContext();
+
+        context.deleteDatabase(DATABASE_FILE);
+        mDatabase = Objects.requireNonNull(
+                context.openOrCreateDatabase(DATABASE_FILE, Context.MODE_PRIVATE, null));
+        MimeTypeFixHandler.loadMimeTypes(context);
+        createFilesTable();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        final Context context = InstrumentationRegistry.getTargetContext();
+
+        if (mDatabase != null) {
+            mDatabase.close();
+        }
+        context.deleteDatabase(DATABASE_FILE);
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_MIME_TYPE_FIX_FOR_ANDROID_15)
+    public void testGetMimeType() {
+        Optional<String> dwgMimeType = MimeTypeFixHandler.getMimeType("dwg");
+        assertTrue(dwgMimeType.isPresent());
+        assertEquals(ClipDescription.MIMETYPE_UNKNOWN, dwgMimeType.get());
+
+
+        Optional<String> avifMimeType = MimeTypeFixHandler.getMimeType("avif");
+        assertTrue(avifMimeType.isPresent());
+        assertEquals("image/avif", avifMimeType.get());
+
+
+        Optional<String> ecmascriptMimeType = MimeTypeFixHandler.getMimeType("es");
+        assertTrue(ecmascriptMimeType.isPresent());
+        assertEquals("application/ecmascript", ecmascriptMimeType.get());
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_MIME_TYPE_FIX_FOR_ANDROID_15)
+    public void testIsCorruptedMimeType() {
+        // jpeg present in mime.types mapping
+        assertFalse(MimeTypeFixHandler.isCorruptedMimeType("image/jpeg"));
+
+        // avif present in android.mime.types mapping
+        assertFalse(MimeTypeFixHandler.isCorruptedMimeType("image/avif"));
+
+        // dwg in corrupted mapping
+        assertTrue(MimeTypeFixHandler.isCorruptedMimeType("image/vnd.dwg"));
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_MIME_TYPE_FIX_FOR_ANDROID_15)
+    public void testGetExtFromMimeType() {
+        // jpeg present in mime.types mapping
+        Optional<String> jpegExtension = MimeTypeFixHandler.getExtFromMimeType("image/jpeg");
+        assertTrue(jpegExtension.isPresent());
+
+        // avif present in android.mime.types mapping
+        Optional<String> avifExtension = MimeTypeFixHandler.getExtFromMimeType("image/avif");
+        assertTrue(avifExtension.isPresent());
+
+        // dwg in corrupted mapping
+        Optional<String> dwgExtension = MimeTypeFixHandler.getExtFromMimeType("image/vnd.dwg");
+        assertFalse(dwgExtension.isPresent());
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_MIME_TYPE_FIX_FOR_ANDROID_15)
+    public void testUpdateUnsupportedMimeTypesForWrongEntries() {
+        createEntriesInFilesTable();
+
+        // Assert incorrect MIME types before the fix
+        try (Cursor cursor = getCursorFilesTable()) {
+            assertNotNull(cursor);
+
+            while (cursor.moveToNext()) {
+                int id = cursor.getInt(cursor.getColumnIndexOrThrow(FileColumns._ID));
+                String mimeType = cursor.getString(
+                        cursor.getColumnIndexOrThrow(FileColumns.MIME_TYPE));
+                int mediaType = cursor.getInt(cursor.getColumnIndexOrThrow(FileColumns.MEDIA_TYPE));
+
+                switch (id) {
+                    case 1: // dwg
+                        assertEquals("image/vnd.dwg", mimeType);
+                        assertEquals(FileColumns.MEDIA_TYPE_IMAGE, mediaType);
+                        break;
+                    case 2: // avif
+                        assertEquals("image/avif", mimeType);
+                        assertEquals(FileColumns.MEDIA_TYPE_IMAGE, mediaType);
+                        break;
+                    case 3: // ecmascript
+                        assertEquals("text/javascript", mimeType);
+                        assertEquals(FileColumns.MEDIA_TYPE_DOCUMENT, mediaType);
+                        break;
+                    default:
+                        fail("Unexpected _ID: " + id);
+                }
+            }
+        }
+
+        // fix the data
+        MimeTypeFixHandler.updateUnsupportedMimeTypes(mDatabase);
+
+        // Assert correct MIME types after the fix
+        try (Cursor cursor = getCursorFilesTable()) {
+            assertNotNull(cursor);
+
+            while (cursor.moveToNext()) {
+                int id = cursor.getInt(cursor.getColumnIndexOrThrow(FileColumns._ID));
+                String mimeType = cursor.getString(
+                        cursor.getColumnIndexOrThrow(FileColumns.MIME_TYPE));
+                int mediaType = cursor.getInt(cursor.getColumnIndexOrThrow(FileColumns.MEDIA_TYPE));
+
+                switch (id) {
+                    case 1: // dwg
+                        assertEquals(ClipDescription.MIMETYPE_UNKNOWN, mimeType);
+                        assertEquals(FileColumns.MEDIA_TYPE_NONE, mediaType);
+                        break;
+                    case 2: // avif
+                        assertEquals("image/avif", mimeType);
+                        assertEquals(FileColumns.MEDIA_TYPE_IMAGE, mediaType);
+                        break;
+                    case 3: // ecmascript
+                        assertEquals("application/ecmascript", mimeType);
+                        assertEquals(FileColumns.MEDIA_TYPE_NONE, mediaType);
+                        break;
+                    default:
+                        fail("Unexpected _ID: " + id);
+                }
+            }
+        }
+    }
+
+    private void createFilesTable() {
+        mDatabase.execSQL("DROP TABLE IF EXISTS " + FILES_TABLE_NAME + ";");
+        mDatabase.execSQL("CREATE TABLE " + FILES_TABLE_NAME + " ("
+                + FileColumns._ID + " INTEGER PRIMARY KEY, "
+                + FileColumns.DATA + " TEXT, "
+                + FileColumns.DISPLAY_NAME + " TEXT, "
+                + FileColumns.MIME_TYPE + " TEXT, "
+                + FileColumns.MEDIA_TYPE + " INTEGER);");
+    }
+
+    private Cursor getCursorFilesTable() {
+        String[] projections = new String[]{
+                FileColumns._ID,
+                FileColumns.DATA,
+                FileColumns.DISPLAY_NAME,
+                FileColumns.MIME_TYPE,
+                FileColumns.MEDIA_TYPE,
+        };
+
+        return mDatabase.query(
+                FILES_TABLE_NAME,
+                projections,
+                null,
+                null,
+                null,
+                null,
+                FileColumns._ID
+        );
+    }
+
+    private void createEntriesInFilesTable() {
+        // dwg in corrupted mime types
+        String dwgFileName = "image1.dwg";
+        insertFileRecord("/path/" + dwgFileName, "image/vnd.dwg",
+                FileColumns.MEDIA_TYPE_IMAGE, dwgFileName);
+
+        // avif in corrupted mime types but also in android_mime_types
+        String avifFileName = "image2.avif";
+        insertFileRecord("/path/" + avifFileName, "image/avif",
+                FileColumns.MEDIA_TYPE_IMAGE, avifFileName);
+
+        String ecamascriptFileName = "file1.es";
+        insertFileRecord("/path/" + ecamascriptFileName, "text/javascript",
+                FileColumns.MEDIA_TYPE_DOCUMENT, ecamascriptFileName);
+    }
+
+    private void insertFileRecord(String data, String mimeType, int mediaType, String displayName) {
+        String sql = "INSERT INTO " + FILES_TABLE_NAME + " ("
+                + FileColumns.DATA + ", "
+                + FileColumns.MIME_TYPE + ", "
+                + FileColumns.MEDIA_TYPE + ", "
+                + FileColumns.DISPLAY_NAME + ") "
+                + "VALUES (?, ?, ?, ?);";
+
+        mDatabase.execSQL(sql, new Object[]{data, mimeType, mediaType, displayName});
+    }
+}
diff --git a/tests/src/com/android/providers/media/util/PermissionUtilsTest.java b/tests/src/com/android/providers/media/util/PermissionUtilsTest.java
index 93def1738..7eb6c667b 100644
--- a/tests/src/com/android/providers/media/util/PermissionUtilsTest.java
+++ b/tests/src/com/android/providers/media/util/PermissionUtilsTest.java
@@ -21,6 +21,7 @@ import static android.Manifest.permission.MANAGE_EXTERNAL_STORAGE;
 import static android.Manifest.permission.MANAGE_MEDIA;
 import static android.Manifest.permission.UPDATE_APP_OPS_STATS;
 import static android.app.AppOpsManager.OPSTR_ACCESS_MEDIA_LOCATION;
+import static android.app.AppOpsManager.OPSTR_LEGACY_STORAGE;
 import static android.app.AppOpsManager.OPSTR_NO_ISOLATED_STORAGE;
 import static android.app.AppOpsManager.OPSTR_READ_MEDIA_AUDIO;
 import static android.app.AppOpsManager.OPSTR_READ_MEDIA_IMAGES;
@@ -44,6 +45,7 @@ import static com.android.providers.media.util.PermissionUtils.checkPermissionIn
 import static com.android.providers.media.util.PermissionUtils.checkPermissionManageMedia;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionManager;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadAudio;
+import static com.android.providers.media.util.PermissionUtils.checkPermissionReadForLegacyStorage;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadImages;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadStorage;
 import static com.android.providers.media.util.PermissionUtils.checkPermissionReadVideo;
@@ -105,6 +107,10 @@ public class PermissionUtilsTest {
             "com.android.providers.media.testapp.legacy", 1, false,
             "LegacyMediaProviderTestApp.apk");
 
+    private static final TestApp LEGACY_TEST_APP_33 = new TestApp("LegacyTestAppWithTargetSdk33",
+            "com.android.providers.media.testapp.legacywithtargetsdk33", 1, false,
+            "LegacyMediaProviderTestAppFor33.apk");
+
     private static final TestApp LEGACY_TEST_APP_35 = new TestApp("LegacyTestAppWithTargetSdk35",
             "com.android.providers.media.testapp.legacywithtargetsdk35", 1, false,
             "LegacyMediaProviderTestAppFor35.apk");
@@ -139,12 +145,18 @@ public class PermissionUtilsTest {
         assertThat(checkPermissionReadStorage(context, pid, uid, packageName, null)).isTrue();
         assertThat(checkPermissionWriteStorage(context, pid, uid, packageName, null)).isTrue();
 
-        assertThat(checkPermissionReadAudio(context, pid, uid, packageName, null, false)).isTrue();
-        assertThat(checkPermissionWriteAudio(context, pid, uid, packageName, null)).isFalse();
-        assertThat(checkPermissionReadVideo(context, pid, uid, packageName, null, false)).isTrue();
-        assertThat(checkPermissionWriteVideo(context, pid, uid, packageName, null)).isFalse();
-        assertThat(checkPermissionReadImages(context, pid, uid, packageName, null, false)).isTrue();
-        assertThat(checkPermissionWriteImages(context, pid, uid, packageName, null)).isFalse();
+        assertThat(checkPermissionReadAudio(context, pid, uid, packageName, null, false,
+                /* forDataDelivery */ true)).isTrue();
+        assertThat(checkPermissionWriteAudio(context, pid, uid, packageName, null,
+                /* forDataDelivery */ true)).isFalse();
+        assertThat(checkPermissionReadVideo(context, pid, uid, packageName, null, false,
+                /* forDataDelivery */ true)).isTrue();
+        assertThat(checkPermissionWriteVideo(context, pid, uid, packageName, null,
+                /* forDataDelivery */ true)).isFalse();
+        assertThat(checkPermissionReadImages(context, pid, uid, packageName, null, false,
+                /* forDataDelivery */ true)).isTrue();
+        assertThat(checkPermissionWriteImages(context, pid, uid, packageName, null,
+                /* forDataDelivery */ true)).isFalse();
         assertThat(checkPermissionInstallPackages(context, pid, uid, packageName, null)).isFalse();
     }
 
@@ -156,7 +168,7 @@ public class PermissionUtilsTest {
         final Context context = getContext();
         final int uid = android.os.Process.myUid();
         final String packageName = context.getPackageName();
-        assertThat(checkNoIsolatedStorageGranted(context, uid, packageName, null)).isFalse();
+        assertThat(checkNoIsolatedStorageGranted(context, uid, packageName)).isFalse();
     }
 
     @Test
@@ -171,7 +183,7 @@ public class PermissionUtilsTest {
             assertThat(checkPermissionShell(testAppUid)).isFalse();
             assertThat(
                     checkIsLegacyStorageGranted(getContext(), testAppUid, packageName,
-                            null, /* isTargetSdkAtLeastS */ false)).isFalse();
+                            /* isTargetSdkAtLeastS */ false)).isFalse();
             assertThat(
                     checkPermissionInstallPackages(getContext(), TEST_APP_PID, testAppUid,
                             packageName, null)).isFalse();
@@ -206,7 +218,7 @@ public class PermissionUtilsTest {
             assertThat(checkPermissionSelf(getContext(), TEST_APP_PID, testAppUid)).isFalse();
             assertThat(checkPermissionShell(testAppUid)).isFalse();
             assertThat(checkIsLegacyStorageGranted(getContext(), testAppUid, packageName,
-                        null,  /* isTargetSdkAtLeastV */ false)).isFalse();
+                    /* isTargetSdkAtLeastV */ false)).isFalse();
             assertThat(checkPermissionInstallPackages(
                         getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
             assertThat(checkPermissionAccessMtp(
@@ -236,7 +248,7 @@ public class PermissionUtilsTest {
             assertThat(checkPermissionSelf(getContext(), TEST_APP_PID, testAppUid)).isFalse();
             assertThat(checkPermissionShell(testAppUid)).isFalse();
             assertThat(checkIsLegacyStorageGranted(getContext(), testAppUid, packageName,
-                    null,  /* isTargetSdkAtLeastV */ true)).isFalse();
+                    /* isTargetSdkAtLeastV */ true)).isFalse();
             assertThat(checkPermissionInstallPackages(
                     getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
             assertThat(checkPermissionAccessMtp(
@@ -245,6 +257,44 @@ public class PermissionUtilsTest {
                     getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
             assertThat(checkPermissionReadStorage(
                     getContext(), TEST_APP_PID, testAppUid, packageName, null)).isTrue();
+            assertThat(checkPermissionReadForLegacyStorage(
+                    getContext(), TEST_APP_PID, testAppUid, packageName,
+                    null, /* isTargetSdkAtLeastT */ true)).isTrue();
+        } finally {
+            dropShellPermission();
+        }
+    }
+
+    @Test
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU, codeName = "Tiramisu")
+    public void testDefaultPermissionsOnLegacyTestAppWithTargetSdk33() throws Exception {
+        String packageName = LEGACY_TEST_APP_33.getPackageName();
+        int testAppUid = getContext().getPackageManager().getPackageUid(packageName, 0);
+        adoptShellPermission(UPDATE_APP_OPS_STATS, MANAGE_APP_OPS_MODES);
+
+        try {
+            assertThat(checkPermissionSelf(getContext(), TEST_APP_PID, testAppUid)).isFalse();
+            assertThat(checkPermissionShell(testAppUid)).isFalse();
+            assertThat(checkPermissionInstallPackages(
+                    getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
+            assertThat(checkPermissionAccessMtp(
+                    getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
+            assertThat(checkPermissionWriteStorage(
+                    getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
+
+            modifyAppOp(testAppUid, OPSTR_READ_MEDIA_IMAGES, AppOpsManager.MODE_ALLOWED);
+            modifyAppOp(testAppUid, OPSTR_READ_MEDIA_VIDEO, AppOpsManager.MODE_ALLOWED);
+            modifyAppOp(testAppUid, OPSTR_READ_MEDIA_AUDIO, AppOpsManager.MODE_ALLOWED);
+            modifyAppOp(testAppUid, OPSTR_LEGACY_STORAGE, AppOpsManager.MODE_ALLOWED);
+
+            assertThat(checkIsLegacyStorageGranted(getContext(), testAppUid,
+                    packageName,  /* isTargetSdkAtLeastV */ false)).isTrue();
+            // Since R_E_S is not granted, this is should return false
+            assertThat(checkPermissionReadStorage(
+                    getContext(), TEST_APP_PID, testAppUid, packageName, null)).isFalse();
+            assertThat(checkPermissionReadForLegacyStorage(
+                    getContext(), TEST_APP_PID, testAppUid, packageName,
+                    null, /* isTargetSdkAtLeastT */ true)).isTrue();
         } finally {
             dropShellPermission();
         }
@@ -273,7 +323,7 @@ public class PermissionUtilsTest {
 
             assertThat(
                     checkIsLegacyStorageGranted(getContext(), testAppUid, packageName,
-                            null, /* isTargetSdkAtLeastS */ false)).isFalse();
+                            /* isTargetSdkAtLeastS */ false)).isFalse();
             assertThat(
                     checkPermissionInstallPackages(getContext(), TEST_APP_PID, testAppUid,
                         packageName, null)).isFalse();
@@ -291,9 +341,9 @@ public class PermissionUtilsTest {
             assertMediaReadPermissions(TEST_APP_PID, testAppUid, packageName,
                 true /* targetSdkIsAtLeastT */, false /* expected */);
             assertThat(checkPermissionReadVisualUserSelected(getContext(), TEST_APP_PID, testAppUid,
-                    packageName, null, false)).isFalse();
+                    packageName, null, false, /* forDataDelivery */ true)).isFalse();
             assertThat(checkPermissionReadVisualUserSelected(getContext(), TEST_APP_PID, testAppUid,
-                    packageName, null, true)).isFalse();
+                    packageName, null, true, /* forDataDelivery */ true)).isFalse();
         } finally {
             dropShellPermission();
         }
@@ -322,7 +372,12 @@ public class PermissionUtilsTest {
 
             assertThat(
                     checkIsLegacyStorageGranted(getContext(), testAppUid, packageName,
-                            null, /* isTargetSdkAtLeastS */ false)).isTrue();
+                            /* isTargetSdkAtLeastS */ false)).isTrue();
+            assertThat(
+                    checkPermissionReadForLegacyStorage(getContext(), TEST_APP_PID,
+                            testAppUid, packageName,
+                            null, /* isTargetSdkAtLeastT */ false)).isTrue();
+
             assertThat(
                     checkPermissionInstallPackages(getContext(), TEST_APP_PID, testAppUid,
                             packageName, null)).isFalse();
@@ -423,18 +478,15 @@ public class PermissionUtilsTest {
 
         try {
             assertThat(
-                    checkNoIsolatedStorageGranted(getContext(), testAppUid, packageName,
-                            null)).isFalse();
+                    checkNoIsolatedStorageGranted(getContext(), testAppUid, packageName)).isFalse();
 
             modifyAppOp(testAppUid, OPSTR_NO_ISOLATED_STORAGE, AppOpsManager.MODE_ALLOWED);
             assertThat(
-                    checkNoIsolatedStorageGranted(getContext(), testAppUid, packageName,
-                            null)).isTrue();
+                    checkNoIsolatedStorageGranted(getContext(), testAppUid, packageName)).isTrue();
 
             modifyAppOp(testAppUid, OPSTR_NO_ISOLATED_STORAGE, AppOpsManager.MODE_ERRORED);
             assertThat(
-                    checkNoIsolatedStorageGranted(getContext(), testAppUid, packageName,
-                            null)).isFalse();
+                    checkNoIsolatedStorageGranted(getContext(), testAppUid, packageName)).isFalse();
         } finally {
             dropShellPermission();
         }
@@ -462,19 +514,19 @@ public class PermissionUtilsTest {
         try {
             assertThat(checkPermissionReadVisualUserSelected(getApplicationContext(), TEST_APP_PID,
                     testAppUid,
-                    packageName, null, targetSdkIsAtLeastT)).isTrue();
+                    packageName, null, targetSdkIsAtLeastT, /* forDataDelivery */ true)).isTrue();
 
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_VISUAL_USER_SELECTED,
                     AppOpsManager.MODE_ERRORED);
             assertThat(checkPermissionReadVisualUserSelected(getApplicationContext(), TEST_APP_PID,
                     testAppUid,
-                    packageName, null, targetSdkIsAtLeastT)).isFalse();
+                    packageName, null, targetSdkIsAtLeastT, /* forDataDelivery */ true)).isFalse();
 
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_VISUAL_USER_SELECTED,
                     AppOpsManager.MODE_ALLOWED);
             assertThat(checkPermissionReadVisualUserSelected(getApplicationContext(), TEST_APP_PID,
                     testAppUid,
-                    packageName, null, targetSdkIsAtLeastT)).isTrue();
+                    packageName, null, targetSdkIsAtLeastT, /* forDataDelivery */ true)).isTrue();
         } finally {
             dropShellPermission();
         }
@@ -487,15 +539,15 @@ public class PermissionUtilsTest {
         adoptShellPermission(UPDATE_APP_OPS_STATS, MANAGE_APP_OPS_MODES);
         try {
             assertThat(checkPermissionReadVideo(getContext(), TEST_APP_PID, testAppUid,
-                    packageName, null, isAtLeastT)).isTrue();
+                    packageName, null, isAtLeastT, /* forDataDelivery */ true)).isTrue();
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_VIDEO, AppOpsManager.MODE_ERRORED);
             assertThat(checkPermissionReadVideo(getContext(), TEST_APP_PID, testAppUid,
-                    packageName, null, isAtLeastT)).isFalse();
+                    packageName, null, isAtLeastT, /* forDataDelivery */ true)).isFalse();
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_VIDEO, AppOpsManager.MODE_ALLOWED);
             // Adding sleep before appops check to allow appops change to propagate
             SystemClock.sleep(200);
             assertThat(checkPermissionReadVideo(getContext(), TEST_APP_PID, testAppUid,
-                packageName, null, isAtLeastT)).isTrue();
+                packageName, null, isAtLeastT, /* forDataDelivery */ true)).isTrue();
         } finally {
             dropShellPermission();
         }
@@ -511,17 +563,17 @@ public class PermissionUtilsTest {
         try {
             assertThat(
                     checkPermissionWriteAudio(getContext(), TEST_APP_PID, testAppUid, packageName,
-                            null)).isFalse();
+                            null, /* forDataDelivery */ true)).isFalse();
 
             modifyAppOp(testAppUid, OPSTR_WRITE_MEDIA_AUDIO, AppOpsManager.MODE_ALLOWED);
             assertThat(
                     checkPermissionWriteAudio(getContext(), TEST_APP_PID, testAppUid, packageName,
-                            null)).isTrue();
+                            null, /* forDataDelivery */ true)).isTrue();
 
             modifyAppOp(testAppUid, OPSTR_WRITE_MEDIA_AUDIO, AppOpsManager.MODE_ERRORED);
             assertThat(
                     checkPermissionWriteAudio(getContext(), TEST_APP_PID, testAppUid, packageName,
-                            null)).isFalse();
+                            null, /* forDataDelivery */ true)).isFalse();
         } finally {
             dropShellPermission();
         }
@@ -545,17 +597,17 @@ public class PermissionUtilsTest {
         adoptShellPermission(UPDATE_APP_OPS_STATS, MANAGE_APP_OPS_MODES);
         try {
             assertThat(checkPermissionReadAudio(getContext(), TEST_APP_PID, testAppUid,
-                        packageName, null, isAtLeastT)).isTrue();
+                        packageName, null, isAtLeastT, /* forDataDelivery */ true)).isTrue();
 
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_AUDIO, AppOpsManager.MODE_ERRORED);
             assertThat(checkPermissionReadAudio(getContext(), TEST_APP_PID, testAppUid,
-                        packageName, null, isAtLeastT)).isFalse();
+                        packageName, null, isAtLeastT, /* forDataDelivery */ true)).isFalse();
 
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_AUDIO, AppOpsManager.MODE_ALLOWED);
             // Adding sleep before appops check to allow appops change to propagate
             SystemClock.sleep(200);
             assertThat(checkPermissionReadAudio(getContext(), TEST_APP_PID, testAppUid,
-                        packageName, null, isAtLeastT)).isTrue();
+                        packageName, null, isAtLeastT, /* forDataDelivery */ true)).isTrue();
         } finally {
             dropShellPermission();
         }
@@ -579,17 +631,17 @@ public class PermissionUtilsTest {
         adoptShellPermission(UPDATE_APP_OPS_STATS, MANAGE_APP_OPS_MODES);
         try {
             assertThat(checkPermissionReadImages(getContext(), TEST_APP_PID, testAppUid,
-                            packageName, null, isAtLeastT)).isTrue();
+                            packageName, null, isAtLeastT, /* forDataDelivery */ true)).isTrue();
 
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_IMAGES, AppOpsManager.MODE_ERRORED);
             assertThat(checkPermissionReadImages(getContext(), TEST_APP_PID, testAppUid,
-                            packageName, null, isAtLeastT)).isFalse();
+                            packageName, null, isAtLeastT, /* forDataDelivery */ true)).isFalse();
 
             modifyAppOp(testAppUid, OPSTR_READ_MEDIA_IMAGES, AppOpsManager.MODE_ALLOWED);
             // Adding sleep before appops check to allow appops change to propagate
             SystemClock.sleep(200);
             assertThat(checkPermissionReadImages(getContext(), TEST_APP_PID, testAppUid,
-                            packageName, null, isAtLeastT)).isTrue();
+                            packageName, null, isAtLeastT, /* forDataDelivery */ true)).isTrue();
         } finally {
             dropShellPermission();
         }
@@ -683,13 +735,17 @@ public class PermissionUtilsTest {
     static private void checkPermissionsForGallery(int uid, int pid, String packageName,
             boolean expected) {
         assertEquals(expected,
-                checkWriteImagesOrVideoAppOps(getContext(), uid, packageName, null));
+                checkWriteImagesOrVideoAppOps(getContext(), uid, packageName, null,
+                        /* forDataDelivery */ true));
         assertEquals(expected,
-                checkPermissionWriteImages(getContext(), pid, uid, packageName, null));
+                checkPermissionWriteImages(getContext(), pid, uid, packageName, null,
+                        /* forDataDelivery */ true));
         assertEquals(expected,
-                checkPermissionWriteVideo(getContext(), pid, uid, packageName, null));
+                checkPermissionWriteVideo(getContext(), pid, uid, packageName, null,
+                        /* forDataDelivery */ true));
         assertThat(
-                checkPermissionWriteAudio(getContext(), pid, uid, packageName, null))
+                checkPermissionWriteAudio(getContext(), pid, uid, packageName, null,
+                        /* forDataDelivery */ true))
                 .isFalse();
     }
 
@@ -698,14 +754,17 @@ public class PermissionUtilsTest {
         assertEquals(
                 expected,
                 checkPermissionReadAudio(
-                        getContext(), pid, uid, packageName, null, targetSdkIsAtLeastT));
+                        getContext(), pid, uid, packageName, null, targetSdkIsAtLeastT,
+                        /* forDataDelivery */ true));
         assertEquals(
                 expected,
                 checkPermissionReadImages(
-                        getContext(), pid, uid, packageName, null, targetSdkIsAtLeastT));
+                        getContext(), pid, uid, packageName, null, targetSdkIsAtLeastT,
+                        /* forDataDelivery */ true));
         assertEquals(
                 expected,
                 checkPermissionReadVideo(
-                        getContext(), pid, uid, packageName, null, targetSdkIsAtLeastT));
+                        getContext(), pid, uid, packageName, null, targetSdkIsAtLeastT,
+                        /* forDataDelivery */ true));
     }
 }
diff --git a/tests/test_app/LegacyTestAppWithTargetSdk33.xml b/tests/test_app/LegacyTestAppWithTargetSdk33.xml
new file mode 100644
index 000000000..541e5abcf
--- /dev/null
+++ b/tests/test_app/LegacyTestAppWithTargetSdk33.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.android.providers.media.testapp.legacywithtargetsdk33"
+          android:versionCode="1"
+          android:versionName="1.0">
+
+    <uses-sdk android:minSdkVersion="30" android:targetSdkVersion="33" />
+
+    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
+    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
+    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />
+
+    <application android:label="LegacyTestAppWithTargetSdk33"
+                 android:requestLegacyExternalStorage="true">
+        <activity android:name="com.android.providers.media.util.TestAppActivity"
+                  android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
```

