```diff
diff --git a/.bazelci/presubmit.yml b/.bazelci/presubmit.yml
index a52e48d..2d82098 100644
--- a/.bazelci/presubmit.yml
+++ b/.bazelci/presubmit.yml
@@ -2,7 +2,6 @@
 tasks:
   debian10:
     shell_commands:
-    - "sudo apt -y update && sudo apt -y install llvm-11-dev libclang-11-dev libncurses-dev"
-    - pip3 install absl-py clang==11
+    - "sudo apt -y update && sudo apt -y install llvm-11-dev libclang-11-dev libncurses-dev python3-clang-11"
     build_targets:
     - "..."
diff --git a/.bazelrc b/.bazelrc
index 4522b0f..5c57d3f 100644
--- a/.bazelrc
+++ b/.bazelrc
@@ -1,2 +1,6 @@
+# Enable Bazel modules by default. Projects using Sandboxed API may still use
+# a regular WORKSPACE ("Hybrid Mode").
+common --enable_bzlmod
+
 # Build in C++17 mode without a custom CROSSTOOL
 build --cxxopt=-std=c++17 --host_cxxopt=-std=c++17
diff --git a/.github/workflows/debian-sapi-generator-tool.yml b/.github/workflows/debian-sapi-generator-tool.yml
deleted file mode 100644
index 314e178..0000000
--- a/.github/workflows/debian-sapi-generator-tool.yml
+++ /dev/null
@@ -1,66 +0,0 @@
-name: debian-sapi-generator-tool
-on: push
-jobs:
-  build:
-    runs-on: ubuntu-latest
-    container: debian:10.13
-    steps:
-    - uses: actions/checkout@v3
-
-    - name: Cache dependencies
-      uses: actions/cache@v3
-      with:
-        key: debian-10.13-clang16
-        path: |
-          ${{github.workspace}}/build/_deps
-
-    - name: Install build tools
-      run: |
-        apt-get update
-        env DEBIAN_FRONTEND=noninteractive \
-          apt-get install -qy --no-install-recommends \
-            build-essential \
-            ca-certificates \
-            cmake \
-            file \
-            git \
-            gnupg \
-            libc6-dev \
-            lsb-release \
-            make \
-            ninja-build \
-            software-properties-common \
-            wget
-        wget https://apt.llvm.org/llvm.sh
-        chmod +x llvm.sh
-        ./llvm.sh 16 all
-
-    - name: Configure CMake
-      run: |
-        mkdir -p "$GITHUB_WORKSPACE/build"
-        cmake \
-          -S "$GITHUB_WORKSPACE" \
-          -B "$GITHUB_WORKSPACE/build" \
-          -G Ninja \
-          -DCMAKE_BUILD_TYPE=Release \
-          -DSAPI_ENABLE_CLANG_TOOL=ON \
-          -DSAPI_ENABLE_CLANG_TOOL_STATIC=ON
-
-    - name: Build
-      run: |
-        cmake \
-          --build "$GITHUB_WORKSPACE/build" \
-          --config Release \
-          --target sapi_generator_tool
-        ( \
-          cd "$GITHUB_WORKSPACE/build"; \
-          mv sandboxed_api/tools/clang_generator/sapi_generator_tool \
-            sapi_generator_tool-linux-x86_64; \
-        )
-
-    - name: Upload Build Artifact
-      uses: actions/upload-artifact@v3.1.2
-      with:
-        name: sapi_generator_tool-linux
-        path: ${{github.workspace}}/build/sapi_generator_tool-linux-x86_64
-
diff --git a/.github/workflows/fedora-cmake.yml b/.github/workflows/fedora-cmake.yml
index 9157dd5..a933168 100644
--- a/.github/workflows/fedora-cmake.yml
+++ b/.github/workflows/fedora-cmake.yml
@@ -13,8 +13,12 @@ jobs:
         include:
           - container: fedora:38
             compiler: gcc
-            compiler-version: 11  # Only used in cache action so far
-            ignore-errors: true  # Stack trace test fails on Fedora (issue #118)
+            compiler-version: 13
+            ignore-errors: false
+          - container: fedora:38
+            compiler: clang
+            compiler-version: 16
+            ignore-errors: false
     runs-on: ubuntu-latest
     continue-on-error: ${{ matrix.ignore-errors }}
 
@@ -51,12 +55,13 @@ jobs:
       run: |
         $RUN_CMD dnf update -y --quiet
         $RUN_CMD dnf install -y --quiet \
-          git make automake patch glibc-static libstdc++-static cmake \
-          ninja-build python3 python3-pip clang-devel libcap-devel
+          git make automake diffutils file patch glibc-static \
+          libstdc++-static cmake ninja-build python3 python3-pip \
+          python3-clang clang-devel libcap-devel
 
     - name: Create Build Environment
       run: |
-        $RUN_CMD pip3 install --progress-bar=off absl-py 'clang>=13,<14'
+        $RUN_CMD pip3 install --progress-bar=off absl-py
         $RUN_CMD cmake -E make_directory $GITHUB_WORKSPACE/build
 
     - name: Configure CMake
diff --git a/.github/workflows/generate-pre-release.yml b/.github/workflows/generator-tool.yml
similarity index 50%
rename from .github/workflows/generate-pre-release.yml
rename to .github/workflows/generator-tool.yml
index 8969e84..3e9d7bb 100644
--- a/.github/workflows/generate-pre-release.yml
+++ b/.github/workflows/generator-tool.yml
@@ -1,11 +1,71 @@
-name: generate-pre-release
-on:
-  workflow_run:
-    workflows: [debian-sapi-generator-tool]
-    types: [completed]
-    branches: [main]
+name: generator-tool
+on: push
 jobs:
+  build:
+    runs-on: ubuntu-latest
+    container: debian:10.13
+    steps:
+    - uses: actions/checkout@v3
+
+    - name: Cache dependencies
+      uses: actions/cache@v3
+      with:
+        key: debian-10.13-clang16
+        path: |
+          ${{github.workspace}}/build/_deps
+
+    - name: Install build tools
+      run: |
+        apt-get update
+        env DEBIAN_FRONTEND=noninteractive \
+          apt-get install -qy --no-install-recommends \
+            build-essential \
+            ca-certificates \
+            cmake \
+            file \
+            git \
+            gnupg \
+            libc6-dev \
+            lsb-release \
+            make \
+            ninja-build \
+            software-properties-common \
+            wget
+        wget https://apt.llvm.org/llvm.sh
+        chmod +x llvm.sh
+        ./llvm.sh 16 all
+
+    - name: Configure CMake
+      run: |
+        mkdir -p "$GITHUB_WORKSPACE/build"
+        cmake \
+          -S "$GITHUB_WORKSPACE" \
+          -B "$GITHUB_WORKSPACE/build" \
+          -G Ninja \
+          -DCMAKE_BUILD_TYPE=Release \
+          -DSAPI_ENABLE_CLANG_TOOL=ON \
+          -DSAPI_ENABLE_CLANG_TOOL_STATIC=ON
+
+    - name: Build
+      run: |
+        cmake \
+          --build "$GITHUB_WORKSPACE/build" \
+          --config Release \
+          --target sapi_generator_tool
+        ( \
+          cd "$GITHUB_WORKSPACE/build"; \
+          mv sandboxed_api/tools/clang_generator/sapi_generator_tool \
+            sapi_generator_tool-linux-x86_64; \
+        )
+
+    - name: Upload Build Artifact
+      uses: actions/upload-artifact@v3.1.2
+      with:
+        name: sapi_generator_tool-linux
+        path: ${{github.workspace}}/build/sapi_generator_tool-linux-x86_64
+
   prerelease:
+    needs: build
     runs-on: ubuntu-latest
     env:
       ARTIFACT_NAME: sapi_generator_tool-linux
@@ -58,3 +118,4 @@ jobs:
         prerelease: true
         files: |
           ${{github.workspace}}/build/sapi_generator_tool-linux-x86_64.tar.gz
+
diff --git a/.github/workflows/ubuntu-cmake-contrib.yml b/.github/workflows/ubuntu-cmake-contrib.yml
index 8d67218..7775a80 100644
--- a/.github/workflows/ubuntu-cmake-contrib.yml
+++ b/.github/workflows/ubuntu-cmake-contrib.yml
@@ -26,8 +26,10 @@ jobs:
         include:
           - compiler: clang
             compiler-version: 11
+            libclang-version: 11
           - compiler: gcc
             compiler-version: 10
+            libclang-version: 11
     runs-on: ${{ matrix.os }}
     continue-on-error: ${{ matrix.ignore-errors }}
 
@@ -55,14 +57,20 @@ jobs:
     - name: Install/configure Clang compiler toolchain
       if: matrix.compiler == 'clang'
       run: |
-        sudo apt-get install -qy clang-${{matrix.compiler-version}}
+        sudo apt-get install -qy \
+          clang-${{matrix.compiler-version}} \
+          libclang1-${{matrix.libclang-version}} \
+          python3-clang-${{matrix.libclang-version}}
         echo "CXX=clang++-${{matrix.compiler-version}}" >> $GITHUB_ENV
         echo "CC=clang-${{matrix.compiler-version}}" >> $GITHUB_ENV
 
     - name: Install/configure GCC compiler toolchain
       if: matrix.compiler == 'gcc'
       run: |
-        sudo apt-get install -qy g++-${{matrix.compiler-version}}
+        sudo apt-get install -qy \
+          g++-${{matrix.compiler-version}} \
+          libclang1-${{matrix.libclang-version}} \
+          python3-clang-${{matrix.libclang-version}}
         echo "CXX=g++-${{matrix.compiler-version}}" >> $GITHUB_ENV
         echo "CC=gcc-${{matrix.compiler-version}}" >> $GITHUB_ENV
 
@@ -78,7 +86,7 @@ jobs:
 
     - name: Create Build Environment
       run: |
-        pip3 install absl-py 'clang>=14,<15'
+        pip3 install absl-py
         cmake -E make_directory $GITHUB_WORKSPACE/build
 
     - name: Configure CMake
diff --git a/.github/workflows/ubuntu-cmake.yml b/.github/workflows/ubuntu-cmake.yml
index d18a6ea..9800cfa 100644
--- a/.github/workflows/ubuntu-cmake.yml
+++ b/.github/workflows/ubuntu-cmake.yml
@@ -16,58 +16,44 @@ jobs:
             compiler: clang
             compiler-version: 14
             libclang-version: 14
-            pip-clang-version: "14.0"
             ignore-errors: false
           - os: ubuntu-22.04
             compiler: clang
             compiler-version: 13
             libclang-version: 13
-            pip-clang-version: "13.0.1"
             ignore-errors: false
           - os: ubuntu-22.04
             compiler: clang
             compiler-version: 12
             libclang-version: 12
-            pip-clang-version: "12.0.1"
             ignore-errors: false
           # Ubuntu 22.04: Use preinstalled GCC 9.5.0, 10.4.0, 11.3.0, 12.1.0
           - os: ubuntu-22.04
             compiler: gcc
             compiler-version: 12
             libclang-version: 14
-            pip-clang-version: "14.0"
             ignore-errors: false
           - os: ubuntu-22.04
             compiler: gcc
             compiler-version: 11
             libclang-version: 14
-            pip-clang-version: "14.0"
             ignore-errors: false
           - os: ubuntu-22.04
             compiler: gcc
             compiler-version: 10
             libclang-version: 14
-            pip-clang-version: "14.0"
             ignore-errors: false
           - os: ubuntu-22.04
             compiler: gcc
             compiler-version: 9
             libclang-version: 14
-            pip-clang-version: "14.0"
             ignore-errors: false
           # Ubuntu 20.04
           - os: ubuntu-20.04
             compiler: gcc
             compiler-version: 8
             libclang-version: 12
-            pip-clang-version: "12.0.1"
             ignore-errors: false
-          - os: ubuntu-20.04
-            compiler: gcc
-            compiler-version: 7
-            libclang-version: 12
-            pip-clang-version: "12.0.1"
-            ignore-errors: true  # GCC 7 is best effort
     runs-on: ${{ matrix.os }}
     continue-on-error: ${{ matrix.ignore-errors }}
 
@@ -89,7 +75,8 @@ jobs:
       run: |
         sudo apt-get install -qy \
           clang-${{matrix.compiler-version}} \
-          libclang1-${{matrix.libclang-version}}
+          libclang1-${{matrix.libclang-version}} \
+          python3-clang-${{matrix.libclang-version}}
         echo "CXX=clang++-${{matrix.compiler-version}}" >> $GITHUB_ENV
         echo "CC=clang-${{matrix.compiler-version}}" >> $GITHUB_ENV
 
@@ -98,13 +85,14 @@ jobs:
       run: |
         sudo apt-get install -qy \
           g++-${{matrix.compiler-version}} \
-          libclang1-${{matrix.libclang-version}}
+          libclang1-${{matrix.libclang-version}} \
+          python3-clang-${{matrix.libclang-version}}
         echo "CXX=g++-${{matrix.compiler-version}}" >> $GITHUB_ENV
         echo "CC=gcc-${{matrix.compiler-version}}" >> $GITHUB_ENV
 
     - name: Create Build Environment
       run: |
-        pip3 install absl-py clang==${{matrix.pip-clang-version}}
+        pip3 install absl-py
         mkdir -p "$GITHUB_WORKSPACE/build"
 
     - name: Configure CMake
diff --git a/Android.bp b/Android.bp
index 982c851..f86bcaa 100644
--- a/Android.bp
+++ b/Android.bp
@@ -28,13 +28,12 @@ cc_defaults {
 cc_library {
     name: "sandboxed_api_proto",
     srcs: [
-        "sandboxed_api/proto_arg.proto",
         "sandboxed_api/sandbox2/comms_test.proto",
         "sandboxed_api/sandbox2/forkserver.proto",
         "sandboxed_api/sandbox2/logserver.proto",
         "sandboxed_api/sandbox2/mount_tree.proto",
-        "sandboxed_api/sandbox2/violation.proto",
         "sandboxed_api/sandbox2/unwind/unwind.proto",
+        "sandboxed_api/util/proto_arg.proto",
         "sandboxed_api/util/status.proto",
     ],
     proto: {
@@ -108,6 +107,7 @@ cc_library {
         "android/unwind.cc",
         "sandboxed_api/config.cc",
         "sandboxed_api/sandbox2/bpfdisassembler.cc",
+        "sandboxed_api/sandbox2/bpf_evaluator.cc",
         "sandboxed_api/sandbox2/buffer.cc",
         "sandboxed_api/sandbox2/client.cc",
         "sandboxed_api/sandbox2/comms.cc",
@@ -128,8 +128,10 @@ cc_library {
         "sandboxed_api/sandbox2/unwind/unwind.cc",
         "sandboxed_api/sandbox2/util.cc",
         "sandboxed_api/sandbox2/util/bpf_helper.c",
+        "sandboxed_api/sandbox2/util/deadline_manager.cc",
         "sandboxed_api/sandbox2/util/maps_parser.cc",
         "sandboxed_api/sandbox2/util/minielf.cc",
+        "sandboxed_api/sandbox2/util/pid_waiter.cc",
         "sandboxed_api/sandbox2/util/syscall_trap.cc",
         "sandboxed_api/util/temp_file.cc",
     ],
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c2b9704..0805e3d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -25,7 +25,6 @@ endif()
 project(SandboxedAPI C CXX ASM)
 include(CTest)
 
-# TODO(cblichmann): Enable for Android once support lands
 if(NOT CMAKE_SYSTEM_NAME MATCHES "Linux")
   message(FATAL_ERROR "Sandboxed API is only supported on Linux")
 endif()
diff --git a/MODULE.bazel b/MODULE.bazel
new file mode 100644
index 0000000..48bdff7
--- /dev/null
+++ b/MODULE.bazel
@@ -0,0 +1,48 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module(
+    name = "com_google_sandboxed_api",
+    version = "20241101.0",
+    bazel_compatibility = [">=7.1.1"],
+)
+
+bazel_dep(
+    name = "abseil-cpp",
+    version = "20240722.0",
+    repo_name = "com_google_absl",
+)
+bazel_dep(
+    name = "abseil-py",
+    version = "2.1.0",
+    repo_name = "com_google_absl_py",
+)
+bazel_dep(name = "bazel_skylib", version = "1.7.1")
+bazel_dep(
+    name = "google_benchmark",
+    version = "1.8.5",
+    repo_name = "com_google_benchmark",
+)
+bazel_dep(
+    name = "googletest",
+    version = "1.15.2",
+    repo_name = "com_google_googletest",
+)
+bazel_dep(
+    name = "protobuf",
+    version = "28.2",
+    repo_name = "com_google_protobuf",
+)
+bazel_dep(name = "rules_proto", version = "6.0.2")
+bazel_dep(name = "rules_python", version = "0.37.2")
diff --git a/MODULE.bazel.lock b/MODULE.bazel.lock
new file mode 100644
index 0000000..f661ff8
--- /dev/null
+++ b/MODULE.bazel.lock
@@ -0,0 +1,3817 @@
+{
+  "lockFileVersion": 11,
+  "registryFileHashes": {
+    "https://bcr.bazel.build/bazel_registry.json": "8a28e4aff06ee60aed2a8c281907fb8bcbf3b753c91fb5a5c57da3215d5b3497",
+    "https://bcr.bazel.build/modules/abseil-cpp/20210324.2/MODULE.bazel": "7cd0312e064fde87c8d1cd79ba06c876bd23630c83466e9500321be55c96ace2",
+    "https://bcr.bazel.build/modules/abseil-cpp/20211102.0/MODULE.bazel": "70390338f7a5106231d20620712f7cccb659cd0e9d073d1991c038eb9fc57589",
+    "https://bcr.bazel.build/modules/abseil-cpp/20230125.1/MODULE.bazel": "89047429cb0207707b2dface14ba7f8df85273d484c2572755be4bab7ce9c3a0",
+    "https://bcr.bazel.build/modules/abseil-cpp/20230802.0.bcr.1/MODULE.bazel": "1c8cec495288dccd14fdae6e3f95f772c1c91857047a098fad772034264cc8cb",
+    "https://bcr.bazel.build/modules/abseil-cpp/20230802.0/MODULE.bazel": "d253ae36a8bd9ee3c5955384096ccb6baf16a1b1e93e858370da0a3b94f77c16",
+    "https://bcr.bazel.build/modules/abseil-cpp/20240116.1/MODULE.bazel": "37bcdb4440fbb61df6a1c296ae01b327f19e9bb521f9b8e26ec854b6f97309ed",
+    "https://bcr.bazel.build/modules/abseil-cpp/20240116.2/MODULE.bazel": "73939767a4686cd9a520d16af5ab440071ed75cec1a876bf2fcfaf1f71987a16",
+    "https://bcr.bazel.build/modules/abseil-cpp/20240722.0/MODULE.bazel": "88668a07647adbdc14cb3a7cd116fb23c9dda37a90a1681590b6c9d8339a5b84",
+    "https://bcr.bazel.build/modules/abseil-cpp/20240722.0/source.json": "59af9f8a8a4817092624e21263fe1fb7d7951a3b06f0570c610c7e5a9caf5f29",
+    "https://bcr.bazel.build/modules/abseil-py/2.1.0/MODULE.bazel": "5ebe5bf853769c65707e5c28f216798f7a4b1042015e6a36e6d03094d94bec8a",
+    "https://bcr.bazel.build/modules/abseil-py/2.1.0/source.json": "0e8fc4f088ce07099c1cd6594c20c7ddbb48b4b3c0849b7d94ba94be88ff042b",
+    "https://bcr.bazel.build/modules/apple_support/1.13.0/MODULE.bazel": "7c8cdea7e031b7f9f67f0b497adf6d2c6a2675e9304ca93a9af6ed84eef5a524",
+    "https://bcr.bazel.build/modules/apple_support/1.15.1/MODULE.bazel": "a0556fefca0b1bb2de8567b8827518f94db6a6e7e7d632b4c48dc5f865bc7c85",
+    "https://bcr.bazel.build/modules/apple_support/1.15.1/source.json": "517f2b77430084c541bc9be2db63fdcbb7102938c5f64c17ee60ffda2e5cf07b",
+    "https://bcr.bazel.build/modules/apple_support/1.5.0/MODULE.bazel": "50341a62efbc483e8a2a6aec30994a58749bd7b885e18dd96aa8c33031e558ef",
+    "https://bcr.bazel.build/modules/aspect_bazel_lib/1.31.2/MODULE.bazel": "7bee702b4862612f29333590f4b658a5832d433d6f8e4395f090e8f4e85d442f",
+    "https://bcr.bazel.build/modules/aspect_bazel_lib/1.38.0/MODULE.bazel": "6307fec451ba9962c1c969eb516ebfe1e46528f7fa92e1c9ac8646bef4cdaa3f",
+    "https://bcr.bazel.build/modules/aspect_bazel_lib/1.40.3/MODULE.bazel": "668e6bcb4d957fc0e284316dba546b705c8d43c857f87119619ee83c4555b859",
+    "https://bcr.bazel.build/modules/aspect_bazel_lib/1.40.3/source.json": "f5a28b1320e5f444e798b4afc1465c8b720bfaec7522cca38a23583dffe85e6d",
+    "https://bcr.bazel.build/modules/aspect_rules_js/1.33.1/MODULE.bazel": "db3e7f16e471cf6827059d03af7c21859e7a0d2bc65429a3a11f005d46fc501b",
+    "https://bcr.bazel.build/modules/aspect_rules_js/1.39.0/MODULE.bazel": "aece421d479e3c31dc3e5f6d49a12acc2700457c03c556650ec7a0ff23fc0d95",
+    "https://bcr.bazel.build/modules/aspect_rules_js/1.39.0/source.json": "a8f93e4ad8843e8aa407fa5fd7c8b63a63846c0ce255371ff23384582813b13d",
+    "https://bcr.bazel.build/modules/aspect_rules_lint/0.12.0/MODULE.bazel": "e767c5dbfeb254ec03275a7701b5cfde2c4d2873676804bc7cb27ddff3728fed",
+    "https://bcr.bazel.build/modules/aspect_rules_lint/0.12.0/source.json": "9a3668e1ee219170e22c0e7f3ab959724c6198fdd12cd503fa10b1c6923a2559",
+    "https://bcr.bazel.build/modules/bazel_features/0.1.0/MODULE.bazel": "47011d645b0f949f42ee67f2e8775188a9cf4a0a1528aa2fa4952f2fd00906fd",
+    "https://bcr.bazel.build/modules/bazel_features/1.1.1/MODULE.bazel": "27b8c79ef57efe08efccbd9dd6ef70d61b4798320b8d3c134fd571f78963dbcd",
+    "https://bcr.bazel.build/modules/bazel_features/1.11.0/MODULE.bazel": "f9382337dd5a474c3b7d334c2f83e50b6eaedc284253334cf823044a26de03e8",
+    "https://bcr.bazel.build/modules/bazel_features/1.11.0/source.json": "c9320aa53cd1c441d24bd6b716da087ad7e4ff0d9742a9884587596edfe53015",
+    "https://bcr.bazel.build/modules/bazel_features/1.4.1/MODULE.bazel": "e45b6bb2350aff3e442ae1111c555e27eac1d915e77775f6fdc4b351b758b5d7",
+    "https://bcr.bazel.build/modules/bazel_features/1.9.1/MODULE.bazel": "8f679097876a9b609ad1f60249c49d68bfab783dd9be012faf9d82547b14815a",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.0.3/MODULE.bazel": "bcb0fd896384802d1ad283b4e4eb4d718eebd8cb820b0a2c3a347fb971afd9d8",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.1.1/MODULE.bazel": "1add3e7d93ff2e6998f9e118022c84d163917d912f5afafb3058e3d2f1545b5e",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.2.0/MODULE.bazel": "44fe84260e454ed94ad326352a698422dbe372b21a1ac9f3eab76eb531223686",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.2.1/MODULE.bazel": "f35baf9da0efe45fa3da1696ae906eea3d615ad41e2e3def4aeb4e8bc0ef9a7a",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.3.0/MODULE.bazel": "20228b92868bf5cfc41bda7afc8a8ba2a543201851de39d990ec957b513579c5",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.4.1/MODULE.bazel": "a0dcb779424be33100dcae821e9e27e4f2901d9dfd5333efe5ac6a8d7ab75e1d",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.4.2/MODULE.bazel": "3bd40978e7a1fac911d5989e6b09d8f64921865a45822d8b09e815eaa726a651",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.5.0/MODULE.bazel": "32880f5e2945ce6a03d1fbd588e9198c0a959bb42297b2cfaf1685b7bc32e138",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.6.1/MODULE.bazel": "8fdee2dbaace6c252131c00e1de4b165dc65af02ea278476187765e1a617b917",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.7.1/MODULE.bazel": "3120d80c5861aa616222ec015332e5f8d3171e062e3e804a2a0253e1be26e59b",
+    "https://bcr.bazel.build/modules/bazel_skylib/1.7.1/source.json": "f121b43eeefc7c29efbd51b83d08631e2347297c95aac9764a701f2a6a2bb953",
+    "https://bcr.bazel.build/modules/buildozer/7.1.2/MODULE.bazel": "2e8dd40ede9c454042645fd8d8d0cd1527966aa5c919de86661e62953cd73d84",
+    "https://bcr.bazel.build/modules/buildozer/7.1.2/source.json": "c9028a501d2db85793a6996205c8de120944f50a0d570438fcae0457a5f9d1f8",
+    "https://bcr.bazel.build/modules/gazelle/0.27.0/MODULE.bazel": "3446abd608295de6d90b4a8a118ed64a9ce11dcb3dda2dc3290a22056bd20996",
+    "https://bcr.bazel.build/modules/gazelle/0.30.0/MODULE.bazel": "f888a1effe338491f35f0e0e85003b47bb9d8295ccba73c37e07702d8d31c65b",
+    "https://bcr.bazel.build/modules/gazelle/0.30.0/source.json": "7af0779f99120aafc73be127615d224f26da2fc5a606b52bdffb221fd9efb737",
+    "https://bcr.bazel.build/modules/google_benchmark/1.8.2/MODULE.bazel": "a70cf1bba851000ba93b58ae2f6d76490a9feb74192e57ab8e8ff13c34ec50cb",
+    "https://bcr.bazel.build/modules/google_benchmark/1.8.5/MODULE.bazel": "9ba9b31b984022828a950e3300410977eda2e35df35584c6b0b2d0c2e52766b7",
+    "https://bcr.bazel.build/modules/google_benchmark/1.8.5/source.json": "2c9c685f9b496f125b9e3a9c696c549d1ed2f33b75830a2fb6ac94fab23c0398",
+    "https://bcr.bazel.build/modules/googletest/1.11.0/MODULE.bazel": "3a83f095183f66345ca86aa13c58b59f9f94a2f81999c093d4eeaa2d262d12f4",
+    "https://bcr.bazel.build/modules/googletest/1.14.0.bcr.1/MODULE.bazel": "22c31a561553727960057361aa33bf20fb2e98584bc4fec007906e27053f80c6",
+    "https://bcr.bazel.build/modules/googletest/1.14.0/MODULE.bazel": "cfbcbf3e6eac06ef9d85900f64424708cc08687d1b527f0ef65aa7517af8118f",
+    "https://bcr.bazel.build/modules/googletest/1.15.2/MODULE.bazel": "6de1edc1d26cafb0ea1a6ab3f4d4192d91a312fd2d360b63adaa213cd00b2108",
+    "https://bcr.bazel.build/modules/googletest/1.15.2/source.json": "dbdda654dcb3a0d7a8bc5d0ac5fc7e150b58c2a986025ae5bc634bb2cb61f470",
+    "https://bcr.bazel.build/modules/jsoncpp/1.9.5/MODULE.bazel": "31271aedc59e815656f5736f282bb7509a97c7ecb43e927ac1a37966e0578075",
+    "https://bcr.bazel.build/modules/jsoncpp/1.9.5/source.json": "4108ee5085dd2885a341c7fab149429db457b3169b86eb081fa245eadf69169d",
+    "https://bcr.bazel.build/modules/libpfm/4.11.0/MODULE.bazel": "45061ff025b301940f1e30d2c16bea596c25b176c8b6b3087e92615adbd52902",
+    "https://bcr.bazel.build/modules/libpfm/4.11.0/source.json": "caaffb3ac2b59b8aac456917a4ecf3167d40478ee79f15ab7a877ec9273937c9",
+    "https://bcr.bazel.build/modules/platforms/0.0.10/MODULE.bazel": "8cb8efaf200bdeb2150d93e162c40f388529a25852b332cec879373771e48ed5",
+    "https://bcr.bazel.build/modules/platforms/0.0.10/source.json": "f22828ff4cf021a6b577f1bf6341cb9dcd7965092a439f64fc1bb3b7a5ae4bd5",
+    "https://bcr.bazel.build/modules/platforms/0.0.4/MODULE.bazel": "9b328e31ee156f53f3c416a64f8491f7eb731742655a47c9eec4703a71644aee",
+    "https://bcr.bazel.build/modules/platforms/0.0.5/MODULE.bazel": "5733b54ea419d5eaf7997054bb55f6a1d0b5ff8aedf0176fef9eea44f3acda37",
+    "https://bcr.bazel.build/modules/platforms/0.0.6/MODULE.bazel": "ad6eeef431dc52aefd2d77ed20a4b353f8ebf0f4ecdd26a807d2da5aa8cd0615",
+    "https://bcr.bazel.build/modules/platforms/0.0.7/MODULE.bazel": "72fd4a0ede9ee5c021f6a8dd92b503e089f46c227ba2813ff183b71616034814",
+    "https://bcr.bazel.build/modules/platforms/0.0.8/MODULE.bazel": "9f142c03e348f6d263719f5074b21ef3adf0b139ee4c5133e2aa35664da9eb2d",
+    "https://bcr.bazel.build/modules/platforms/0.0.9/MODULE.bazel": "4a87a60c927b56ddd67db50c89acaa62f4ce2a1d2149ccb63ffd871d5ce29ebc",
+    "https://bcr.bazel.build/modules/protobuf/21.7/MODULE.bazel": "a5a29bb89544f9b97edce05642fac225a808b5b7be74038ea3640fae2f8e66a7",
+    "https://bcr.bazel.build/modules/protobuf/23.1/MODULE.bazel": "88b393b3eb4101d18129e5db51847cd40a5517a53e81216144a8c32dfeeca52a",
+    "https://bcr.bazel.build/modules/protobuf/24.4/MODULE.bazel": "7bc7ce5f2abf36b3b7b7c8218d3acdebb9426aeb35c2257c96445756f970eb12",
+    "https://bcr.bazel.build/modules/protobuf/28.2/MODULE.bazel": "c0c8e51757df486d0314fa290e174d707bad4a6c2aa5ccb08a4b4abd76a23e90",
+    "https://bcr.bazel.build/modules/protobuf/28.2/source.json": "31a22dd0dd25b579257b0c5821b527a9bc987b7c16cf111fbf31704c2786651b",
+    "https://bcr.bazel.build/modules/protobuf/3.19.0/MODULE.bazel": "6b5fbb433f760a99a22b18b6850ed5784ef0e9928a72668b66e4d7ccd47db9b0",
+    "https://bcr.bazel.build/modules/protobuf/3.19.2/MODULE.bazel": "532ffe5f2186b69fdde039efe6df13ba726ff338c6bc82275ad433013fa10573",
+    "https://bcr.bazel.build/modules/protobuf/3.19.6/MODULE.bazel": "9233edc5e1f2ee276a60de3eaa47ac4132302ef9643238f23128fea53ea12858",
+    "https://bcr.bazel.build/modules/pybind11_bazel/2.11.1/MODULE.bazel": "88af1c246226d87e65be78ed49ecd1e6f5e98648558c14ce99176da041dc378e",
+    "https://bcr.bazel.build/modules/pybind11_bazel/2.12.0/MODULE.bazel": "e6f4c20442eaa7c90d7190d8dc539d0ab422f95c65a57cc59562170c58ae3d34",
+    "https://bcr.bazel.build/modules/pybind11_bazel/2.12.0/source.json": "6900fdc8a9e95866b8c0d4ad4aba4d4236317b5c1cd04c502df3f0d33afed680",
+    "https://bcr.bazel.build/modules/re2/2023-09-01/MODULE.bazel": "cb3d511531b16cfc78a225a9e2136007a48cf8a677e4264baeab57fe78a80206",
+    "https://bcr.bazel.build/modules/re2/2024-07-02/MODULE.bazel": "0eadc4395959969297cbcf31a249ff457f2f1d456228c67719480205aa306daa",
+    "https://bcr.bazel.build/modules/re2/2024-07-02/source.json": "547d0111a9d4f362db32196fef805abbf3676e8d6afbe44d395d87816c1130ca",
+    "https://bcr.bazel.build/modules/rules_buf/0.1.1/MODULE.bazel": "6189aec18a4f7caff599ad41b851ab7645d4f1e114aa6431acf9b0666eb92162",
+    "https://bcr.bazel.build/modules/rules_buf/0.1.1/source.json": "021363d254f7438f3f10725355969c974bb2c67e0c28667782ade31a9cdb747f",
+    "https://bcr.bazel.build/modules/rules_cc/0.0.1/MODULE.bazel": "cb2aa0747f84c6c3a78dad4e2049c154f08ab9d166b1273835a8174940365647",
+    "https://bcr.bazel.build/modules/rules_cc/0.0.2/MODULE.bazel": "6915987c90970493ab97393024c156ea8fb9f3bea953b2f3ec05c34f19b5695c",
+    "https://bcr.bazel.build/modules/rules_cc/0.0.6/MODULE.bazel": "abf360251023dfe3efcef65ab9d56beefa8394d4176dd29529750e1c57eaa33f",
+    "https://bcr.bazel.build/modules/rules_cc/0.0.8/MODULE.bazel": "964c85c82cfeb6f3855e6a07054fdb159aced38e99a5eecf7bce9d53990afa3e",
+    "https://bcr.bazel.build/modules/rules_cc/0.0.9/MODULE.bazel": "836e76439f354b89afe6a911a7adf59a6b2518fafb174483ad78a2a2fde7b1c5",
+    "https://bcr.bazel.build/modules/rules_cc/0.0.9/source.json": "1f1ba6fea244b616de4a554a0f4983c91a9301640c8fe0dd1d410254115c8430",
+    "https://bcr.bazel.build/modules/rules_foreign_cc/0.10.1/MODULE.bazel": "b9527010e5fef060af92b6724edb3691970a5b1f76f74b21d39f7d433641be60",
+    "https://bcr.bazel.build/modules/rules_foreign_cc/0.10.1/source.json": "9300e71df0cdde0952f10afff1401fa664e9fc5d9ae6204660ba1b158d90d6a6",
+    "https://bcr.bazel.build/modules/rules_foreign_cc/0.9.0/MODULE.bazel": "c9e8c682bf75b0e7c704166d79b599f93b72cfca5ad7477df596947891feeef6",
+    "https://bcr.bazel.build/modules/rules_fuzzing/0.5.2/MODULE.bazel": "40c97d1144356f52905566c55811f13b299453a14ac7769dfba2ac38192337a8",
+    "https://bcr.bazel.build/modules/rules_fuzzing/0.5.2/source.json": "c8b1e2c717646f1702290959a3302a178fb639d987ab61d548105019f11e527e",
+    "https://bcr.bazel.build/modules/rules_go/0.33.0/MODULE.bazel": "a2b11b64cd24bf94f57454f53288a5dacfe6cb86453eee7761b7637728c1910c",
+    "https://bcr.bazel.build/modules/rules_go/0.38.1/MODULE.bazel": "fb8e73dd3b6fc4ff9d260ceacd830114891d49904f5bda1c16bc147bcc254f71",
+    "https://bcr.bazel.build/modules/rules_go/0.39.1/MODULE.bazel": "d34fb2a249403a5f4339c754f1e63dc9e5ad70b47c5e97faee1441fc6636cd61",
+    "https://bcr.bazel.build/modules/rules_go/0.39.1/source.json": "f21e042154010ae2c944ab230d572b17d71cdb27c5255806d61df6ccaed4354c",
+    "https://bcr.bazel.build/modules/rules_java/4.0.0/MODULE.bazel": "5a78a7ae82cd1a33cef56dc578c7d2a46ed0dca12643ee45edbb8417899e6f74",
+    "https://bcr.bazel.build/modules/rules_java/5.3.5/MODULE.bazel": "a4ec4f2db570171e3e5eb753276ee4b389bae16b96207e9d3230895c99644b86",
+    "https://bcr.bazel.build/modules/rules_java/6.3.0/MODULE.bazel": "a97c7678c19f236a956ad260d59c86e10a463badb7eb2eda787490f4c969b963",
+    "https://bcr.bazel.build/modules/rules_java/6.5.2/MODULE.bazel": "1d440d262d0e08453fa0c4d8f699ba81609ed0e9a9a0f02cd10b3e7942e61e31",
+    "https://bcr.bazel.build/modules/rules_java/7.1.0/MODULE.bazel": "30d9135a2b6561c761bd67bd4990da591e6bdc128790ce3e7afd6a3558b2fb64",
+    "https://bcr.bazel.build/modules/rules_java/7.6.5/MODULE.bazel": "481164be5e02e4cab6e77a36927683263be56b7e36fef918b458d7a8a1ebadb1",
+    "https://bcr.bazel.build/modules/rules_java/7.6.5/source.json": "a805b889531d1690e3c72a7a7e47a870d00323186a9904b36af83aa3d053ee8d",
+    "https://bcr.bazel.build/modules/rules_jvm_external/4.4.2/MODULE.bazel": "a56b85e418c83eb1839819f0b515c431010160383306d13ec21959ac412d2fe7",
+    "https://bcr.bazel.build/modules/rules_jvm_external/5.1/MODULE.bazel": "33f6f999e03183f7d088c9be518a63467dfd0be94a11d0055fe2d210f89aa909",
+    "https://bcr.bazel.build/modules/rules_jvm_external/5.2/MODULE.bazel": "d9351ba35217ad0de03816ef3ed63f89d411349353077348a45348b096615036",
+    "https://bcr.bazel.build/modules/rules_jvm_external/5.2/source.json": "10572111995bc349ce31c78f74b3c147f6b3233975c7fa5eff9211f6db0d34d9",
+    "https://bcr.bazel.build/modules/rules_license/0.0.3/MODULE.bazel": "627e9ab0247f7d1e05736b59dbb1b6871373de5ad31c3011880b4133cafd4bd0",
+    "https://bcr.bazel.build/modules/rules_license/0.0.7/MODULE.bazel": "088fbeb0b6a419005b89cf93fe62d9517c0a2b8bb56af3244af65ecfe37e7d5d",
+    "https://bcr.bazel.build/modules/rules_license/0.0.8/MODULE.bazel": "5669c6fe49b5134dbf534db681ad3d67a2d49cfc197e4a95f1ca2fd7f3aebe96",
+    "https://bcr.bazel.build/modules/rules_license/0.0.8/source.json": "ccfd3964cd0cd1739202efb8dbf9a06baab490e61e174b2ad4790f9c4e610beb",
+    "https://bcr.bazel.build/modules/rules_nodejs/5.8.2/MODULE.bazel": "6bc03c8f37f69401b888023bf511cb6ee4781433b0cb56236b2e55a21e3a026a",
+    "https://bcr.bazel.build/modules/rules_nodejs/5.8.2/source.json": "6e82cf5753d835ea18308200bc79b9c2e782efe2e2a4edc004a9162ca93382ca",
+    "https://bcr.bazel.build/modules/rules_pkg/0.7.0/MODULE.bazel": "df99f03fc7934a4737122518bb87e667e62d780b610910f0447665a7e2be62dc",
+    "https://bcr.bazel.build/modules/rules_pkg/0.7.0/source.json": "c2557066e0c0342223ba592510ad3d812d4963b9024831f7f66fd0584dd8c66c",
+    "https://bcr.bazel.build/modules/rules_proto/4.0.0/MODULE.bazel": "a7a7b6ce9bee418c1a760b3d84f83a299ad6952f9903c67f19e4edd964894e06",
+    "https://bcr.bazel.build/modules/rules_proto/5.3.0-21.7/MODULE.bazel": "e8dff86b0971688790ae75528fe1813f71809b5afd57facb44dad9e8eca631b7",
+    "https://bcr.bazel.build/modules/rules_proto/6.0.0-rc1/MODULE.bazel": "1e5b502e2e1a9e825eef74476a5a1ee524a92297085015a052510b09a1a09483",
+    "https://bcr.bazel.build/modules/rules_proto/6.0.2/MODULE.bazel": "ce916b775a62b90b61888052a416ccdda405212b6aaeb39522f7dc53431a5e73",
+    "https://bcr.bazel.build/modules/rules_proto/6.0.2/source.json": "17a2e195f56cb28d6bbf763e49973d13890487c6945311ed141e196fb660426d",
+    "https://bcr.bazel.build/modules/rules_python/0.10.2/MODULE.bazel": "cc82bc96f2997baa545ab3ce73f196d040ffb8756fd2d66125a530031cd90e5f",
+    "https://bcr.bazel.build/modules/rules_python/0.20.0/MODULE.bazel": "bfe14d17f20e3fe900b9588f526f52c967a6f281e47a1d6b988679bd15082286",
+    "https://bcr.bazel.build/modules/rules_python/0.22.1/MODULE.bazel": "26114f0c0b5e93018c0c066d6673f1a2c3737c7e90af95eff30cfee38d0bbac7",
+    "https://bcr.bazel.build/modules/rules_python/0.25.0/MODULE.bazel": "72f1506841c920a1afec76975b35312410eea3aa7b63267436bfb1dd91d2d382",
+    "https://bcr.bazel.build/modules/rules_python/0.28.0/MODULE.bazel": "cba2573d870babc976664a912539b320cbaa7114cd3e8f053c720171cde331ed",
+    "https://bcr.bazel.build/modules/rules_python/0.31.0/MODULE.bazel": "93a43dc47ee570e6ec9f5779b2e64c1476a6ce921c48cc9a1678a91dd5f8fd58",
+    "https://bcr.bazel.build/modules/rules_python/0.33.2/MODULE.bazel": "3e036c4ad8d804a4dad897d333d8dce200d943df4827cb849840055be8d2e937",
+    "https://bcr.bazel.build/modules/rules_python/0.37.2/MODULE.bazel": "b5ffde91410745750b6c13be1c5dc4555ef5bc50562af4a89fd77807fdde626a",
+    "https://bcr.bazel.build/modules/rules_python/0.37.2/source.json": "af5c224d27ec98a612b4dcbdc481e02502cd5a4b49d87f0093200a10a35383e9",
+    "https://bcr.bazel.build/modules/rules_python/0.4.0/MODULE.bazel": "9208ee05fd48bf09ac60ed269791cf17fb343db56c8226a720fbb1cdf467166c",
+    "https://bcr.bazel.build/modules/rules_rust/0.45.1/MODULE.bazel": "a69d0db3a958fab2c6520961e1b2287afcc8b36690fd31bbc4f6f7391397150d",
+    "https://bcr.bazel.build/modules/rules_rust/0.45.1/source.json": "28a181c6bc9d037bd2a8f2875908d821027def05f87af51b79277395c7b50c71",
+    "https://bcr.bazel.build/modules/stardoc/0.5.0/MODULE.bazel": "f9f1f46ba8d9c3362648eea571c6f9100680efc44913618811b58cc9c02cd678",
+    "https://bcr.bazel.build/modules/stardoc/0.5.1/MODULE.bazel": "1a05d92974d0c122f5ccf09291442580317cdd859f07a8655f1db9a60374f9f8",
+    "https://bcr.bazel.build/modules/stardoc/0.5.3/MODULE.bazel": "c7f6948dae6999bf0db32c1858ae345f112cacf98f174c7a8bb707e41b974f1c",
+    "https://bcr.bazel.build/modules/stardoc/0.5.4/MODULE.bazel": "6569966df04610b8520957cb8e97cf2e9faac2c0309657c537ab51c16c18a2a4",
+    "https://bcr.bazel.build/modules/stardoc/0.6.2/MODULE.bazel": "7060193196395f5dd668eda046ccbeacebfd98efc77fed418dbe2b82ffaa39fd",
+    "https://bcr.bazel.build/modules/stardoc/0.6.2/source.json": "d2ff8063b63b4a85e65fe595c4290f99717434fa9f95b4748a79a7d04dfed349",
+    "https://bcr.bazel.build/modules/upb/0.0.0-20220923-a547704/MODULE.bazel": "7298990c00040a0e2f121f6c32544bab27d4452f80d9ce51349b1a28f3005c43",
+    "https://bcr.bazel.build/modules/upb/0.0.0-20230516-61a97ef/MODULE.bazel": "c0df5e35ad55e264160417fd0875932ee3c9dda63d9fccace35ac62f45e1b6f9",
+    "https://bcr.bazel.build/modules/zlib/1.2.11/MODULE.bazel": "07b389abc85fdbca459b69e2ec656ae5622873af3f845e1c9d80fe179f3effa0",
+    "https://bcr.bazel.build/modules/zlib/1.2.12/MODULE.bazel": "3b1a8834ada2a883674be8cbd36ede1b6ec481477ada359cd2d3ddc562340b27",
+    "https://bcr.bazel.build/modules/zlib/1.3.1.bcr.3/MODULE.bazel": "af322bc08976524477c79d1e45e241b6efbeb918c497e8840b8ab116802dda79",
+    "https://bcr.bazel.build/modules/zlib/1.3.1.bcr.3/source.json": "2be409ac3c7601245958cd4fcdff4288be79ed23bd690b4b951f500d54ee6e7d",
+    "https://bcr.bazel.build/modules/zlib/1.3.1/MODULE.bazel": "751c9940dcfe869f5f7274e1295422a34623555916eb98c174c1e945594bf198"
+  },
+  "selectedYankedVersions": {},
+  "moduleExtensions": {
+    "@@apple_support~//crosstool:setup.bzl%apple_cc_configure_extension": {
+      "general": {
+        "bzlTransitiveDigest": "ltCGFbl/LQQZXn/LEMXfKX7pGwyqNiOCHcmiQW0tmjM=",
+        "usagesDigest": "2Jj0sTGzjx2KfYRjWYbL6DZ1bi8HL2roIAGfOViiul8=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "local_config_apple_cc_toolchains": {
+            "bzlFile": "@@apple_support~//crosstool:setup.bzl",
+            "ruleClassName": "_apple_cc_autoconf_toolchains",
+            "attributes": {}
+          },
+          "local_config_apple_cc": {
+            "bzlFile": "@@apple_support~//crosstool:setup.bzl",
+            "ruleClassName": "_apple_cc_autoconf",
+            "attributes": {}
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "apple_support~",
+            "bazel_tools",
+            "bazel_tools"
+          ]
+        ]
+      }
+    },
+    "@@aspect_bazel_lib~//lib:extensions.bzl%toolchains": {
+      "general": {
+        "bzlTransitiveDigest": "wbW/fEUW6Ya4TMFK5PPIgAwWuJm4AQFeqnOO5DbiZjw=",
+        "usagesDigest": "2yV4A8xZ6FZbGGe74q8xCktC2QFZ9qOJZI8VbIbhxtE=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "copy_directory_darwin_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_platform_repo",
+            "attributes": {
+              "platform": "darwin_amd64"
+            }
+          },
+          "copy_directory_darwin_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_platform_repo",
+            "attributes": {
+              "platform": "darwin_arm64"
+            }
+          },
+          "copy_directory_freebsd_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_platform_repo",
+            "attributes": {
+              "platform": "freebsd_amd64"
+            }
+          },
+          "copy_directory_linux_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_platform_repo",
+            "attributes": {
+              "platform": "linux_amd64"
+            }
+          },
+          "copy_directory_linux_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_platform_repo",
+            "attributes": {
+              "platform": "linux_arm64"
+            }
+          },
+          "copy_directory_windows_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_platform_repo",
+            "attributes": {
+              "platform": "windows_amd64"
+            }
+          },
+          "copy_directory_toolchains": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_directory_toolchain.bzl",
+            "ruleClassName": "copy_directory_toolchains_repo",
+            "attributes": {
+              "user_repository_name": "copy_directory"
+            }
+          },
+          "copy_to_directory_darwin_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_platform_repo",
+            "attributes": {
+              "platform": "darwin_amd64"
+            }
+          },
+          "copy_to_directory_darwin_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_platform_repo",
+            "attributes": {
+              "platform": "darwin_arm64"
+            }
+          },
+          "copy_to_directory_freebsd_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_platform_repo",
+            "attributes": {
+              "platform": "freebsd_amd64"
+            }
+          },
+          "copy_to_directory_linux_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_platform_repo",
+            "attributes": {
+              "platform": "linux_amd64"
+            }
+          },
+          "copy_to_directory_linux_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_platform_repo",
+            "attributes": {
+              "platform": "linux_arm64"
+            }
+          },
+          "copy_to_directory_windows_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_platform_repo",
+            "attributes": {
+              "platform": "windows_amd64"
+            }
+          },
+          "copy_to_directory_toolchains": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:copy_to_directory_toolchain.bzl",
+            "ruleClassName": "copy_to_directory_toolchains_repo",
+            "attributes": {
+              "user_repository_name": "copy_to_directory"
+            }
+          },
+          "jq_darwin_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:jq_toolchain.bzl",
+            "ruleClassName": "jq_platform_repo",
+            "attributes": {
+              "platform": "darwin_amd64",
+              "version": "1.6"
+            }
+          },
+          "jq_darwin_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:jq_toolchain.bzl",
+            "ruleClassName": "jq_platform_repo",
+            "attributes": {
+              "platform": "darwin_arm64",
+              "version": "1.6"
+            }
+          },
+          "jq_linux_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:jq_toolchain.bzl",
+            "ruleClassName": "jq_platform_repo",
+            "attributes": {
+              "platform": "linux_amd64",
+              "version": "1.6"
+            }
+          },
+          "jq_windows_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:jq_toolchain.bzl",
+            "ruleClassName": "jq_platform_repo",
+            "attributes": {
+              "platform": "windows_amd64",
+              "version": "1.6"
+            }
+          },
+          "jq": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:jq_toolchain.bzl",
+            "ruleClassName": "jq_host_alias_repo",
+            "attributes": {}
+          },
+          "jq_toolchains": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:jq_toolchain.bzl",
+            "ruleClassName": "jq_toolchains_repo",
+            "attributes": {
+              "user_repository_name": "jq"
+            }
+          },
+          "yq_darwin_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "darwin_amd64",
+              "version": "4.25.2"
+            }
+          },
+          "yq_darwin_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "darwin_arm64",
+              "version": "4.25.2"
+            }
+          },
+          "yq_linux_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "linux_amd64",
+              "version": "4.25.2"
+            }
+          },
+          "yq_linux_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "linux_arm64",
+              "version": "4.25.2"
+            }
+          },
+          "yq_linux_s390x": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "linux_s390x",
+              "version": "4.25.2"
+            }
+          },
+          "yq_linux_ppc64le": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "linux_ppc64le",
+              "version": "4.25.2"
+            }
+          },
+          "yq_windows_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_platform_repo",
+            "attributes": {
+              "platform": "windows_amd64",
+              "version": "4.25.2"
+            }
+          },
+          "yq": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_host_alias_repo",
+            "attributes": {}
+          },
+          "yq_toolchains": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:yq_toolchain.bzl",
+            "ruleClassName": "yq_toolchains_repo",
+            "attributes": {
+              "user_repository_name": "yq"
+            }
+          },
+          "coreutils_darwin_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:coreutils_toolchain.bzl",
+            "ruleClassName": "coreutils_platform_repo",
+            "attributes": {
+              "platform": "darwin_amd64",
+              "version": "0.0.16"
+            }
+          },
+          "coreutils_darwin_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:coreutils_toolchain.bzl",
+            "ruleClassName": "coreutils_platform_repo",
+            "attributes": {
+              "platform": "darwin_arm64",
+              "version": "0.0.16"
+            }
+          },
+          "coreutils_linux_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:coreutils_toolchain.bzl",
+            "ruleClassName": "coreutils_platform_repo",
+            "attributes": {
+              "platform": "linux_amd64",
+              "version": "0.0.16"
+            }
+          },
+          "coreutils_linux_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:coreutils_toolchain.bzl",
+            "ruleClassName": "coreutils_platform_repo",
+            "attributes": {
+              "platform": "linux_arm64",
+              "version": "0.0.16"
+            }
+          },
+          "coreutils_windows_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:coreutils_toolchain.bzl",
+            "ruleClassName": "coreutils_platform_repo",
+            "attributes": {
+              "platform": "windows_amd64",
+              "version": "0.0.16"
+            }
+          },
+          "coreutils_toolchains": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:coreutils_toolchain.bzl",
+            "ruleClassName": "coreutils_toolchains_repo",
+            "attributes": {
+              "user_repository_name": "coreutils"
+            }
+          },
+          "expand_template_darwin_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_platform_repo",
+            "attributes": {
+              "platform": "darwin_amd64"
+            }
+          },
+          "expand_template_darwin_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_platform_repo",
+            "attributes": {
+              "platform": "darwin_arm64"
+            }
+          },
+          "expand_template_freebsd_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_platform_repo",
+            "attributes": {
+              "platform": "freebsd_amd64"
+            }
+          },
+          "expand_template_linux_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_platform_repo",
+            "attributes": {
+              "platform": "linux_amd64"
+            }
+          },
+          "expand_template_linux_arm64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_platform_repo",
+            "attributes": {
+              "platform": "linux_arm64"
+            }
+          },
+          "expand_template_windows_amd64": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_platform_repo",
+            "attributes": {
+              "platform": "windows_amd64"
+            }
+          },
+          "expand_template_toolchains": {
+            "bzlFile": "@@aspect_bazel_lib~//lib/private:expand_template_toolchain.bzl",
+            "ruleClassName": "expand_template_toolchains_repo",
+            "attributes": {
+              "user_repository_name": "expand_template"
+            }
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "aspect_bazel_lib~",
+            "aspect_bazel_lib",
+            "aspect_bazel_lib~"
+          ],
+          [
+            "aspect_bazel_lib~",
+            "bazel_skylib",
+            "bazel_skylib~"
+          ],
+          [
+            "aspect_bazel_lib~",
+            "bazel_tools",
+            "bazel_tools"
+          ]
+        ]
+      }
+    },
+    "@@platforms//host:extension.bzl%host_platform": {
+      "general": {
+        "bzlTransitiveDigest": "xelQcPZH8+tmuOHVjL9vDxMnnQNMlwj0SlvgoqBkm4U=",
+        "usagesDigest": "hgylFkgWSg0ulUwWZzEM1aIftlUnbmw2ynWLdEfHnZc=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "host_platform": {
+            "bzlFile": "@@platforms//host:extension.bzl",
+            "ruleClassName": "host_platform_repo",
+            "attributes": {}
+          }
+        },
+        "recordedRepoMappingEntries": []
+      }
+    },
+    "@@rules_buf~//buf:extensions.bzl%ext": {
+      "general": {
+        "bzlTransitiveDigest": "gmPmM7QT5Jez2VVFcwbbMf/QWSRag+nJ1elFJFFTcn0=",
+        "usagesDigest": "1E3NeLCRI6VyKiersXVtONCbNopc5jIVqoHBOpcWb0A=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "rules_buf_toolchains": {
+            "bzlFile": "@@rules_buf~//buf/internal:toolchain.bzl",
+            "ruleClassName": "buf_download_releases",
+            "attributes": {
+              "version": "v1.27.0"
+            }
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "rules_buf~",
+            "bazel_tools",
+            "bazel_tools"
+          ]
+        ]
+      }
+    },
+    "@@rules_foreign_cc~//foreign_cc:extensions.bzl%tools": {
+      "general": {
+        "bzlTransitiveDigest": "a7qnESofmIRYId6wwGNPJ9kvExU80KrkxL281P3+lBE=",
+        "usagesDigest": "hK5/SjH6eu1u+V0YHRti+lZvw7Wb4oU6Raw6P0mAfDQ=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "rules_foreign_cc_framework_toolchain_linux": {
+            "bzlFile": "@@rules_foreign_cc~//foreign_cc/private/framework:toolchain.bzl",
+            "ruleClassName": "framework_toolchain_repository",
+            "attributes": {
+              "commands_src": "@rules_foreign_cc//foreign_cc/private/framework/toolchains:linux_commands.bzl",
+              "exec_compatible_with": [
+                "@platforms//os:linux"
+              ]
+            }
+          },
+          "rules_foreign_cc_framework_toolchain_freebsd": {
+            "bzlFile": "@@rules_foreign_cc~//foreign_cc/private/framework:toolchain.bzl",
+            "ruleClassName": "framework_toolchain_repository",
+            "attributes": {
+              "commands_src": "@rules_foreign_cc//foreign_cc/private/framework/toolchains:freebsd_commands.bzl",
+              "exec_compatible_with": [
+                "@platforms//os:freebsd"
+              ]
+            }
+          },
+          "rules_foreign_cc_framework_toolchain_windows": {
+            "bzlFile": "@@rules_foreign_cc~//foreign_cc/private/framework:toolchain.bzl",
+            "ruleClassName": "framework_toolchain_repository",
+            "attributes": {
+              "commands_src": "@rules_foreign_cc//foreign_cc/private/framework/toolchains:windows_commands.bzl",
+              "exec_compatible_with": [
+                "@platforms//os:windows"
+              ]
+            }
+          },
+          "rules_foreign_cc_framework_toolchain_macos": {
+            "bzlFile": "@@rules_foreign_cc~//foreign_cc/private/framework:toolchain.bzl",
+            "ruleClassName": "framework_toolchain_repository",
+            "attributes": {
+              "commands_src": "@rules_foreign_cc//foreign_cc/private/framework/toolchains:macos_commands.bzl",
+              "exec_compatible_with": [
+                "@platforms//os:macos"
+              ]
+            }
+          },
+          "rules_foreign_cc_framework_toolchains": {
+            "bzlFile": "@@rules_foreign_cc~//foreign_cc/private/framework:toolchain.bzl",
+            "ruleClassName": "framework_toolchain_repository_hub",
+            "attributes": {}
+          },
+          "cmake_src": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "filegroup(\n    name = \"all_srcs\",\n    srcs = glob([\"**\"]),\n    visibility = [\"//visibility:public\"],\n)\n",
+              "sha256": "f316b40053466f9a416adf981efda41b160ca859e97f6a484b447ea299ff26aa",
+              "strip_prefix": "cmake-3.23.2",
+              "urls": [
+                "https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2.tar.gz"
+              ]
+            }
+          },
+          "gnumake_src": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "filegroup(\n    name = \"all_srcs\",\n    srcs = glob([\"**\"]),\n    visibility = [\"//visibility:public\"],\n)\n",
+              "sha256": "581f4d4e872da74b3941c874215898a7d35802f03732bdccee1d4a7979105d18",
+              "strip_prefix": "make-4.4",
+              "urls": [
+                "https://mirror.bazel.build/ftpmirror.gnu.org/gnu/make/make-4.4.tar.gz",
+                "http://ftpmirror.gnu.org/gnu/make/make-4.4.tar.gz"
+              ]
+            }
+          },
+          "ninja_build_src": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "filegroup(\n    name = \"all_srcs\",\n    srcs = glob([\"**\"]),\n    visibility = [\"//visibility:public\"],\n)\n",
+              "sha256": "31747ae633213f1eda3842686f83c2aa1412e0f5691d1c14dbbcc67fe7400cea",
+              "strip_prefix": "ninja-1.11.1",
+              "urls": [
+                "https://github.com/ninja-build/ninja/archive/v1.11.1.tar.gz"
+              ]
+            }
+          },
+          "meson_src": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "exports_files([\"meson.py\"])\n\nfilegroup(\n    name = \"runtime\",\n    srcs = glob([\"mesonbuild/**\"]),\n    visibility = [\"//visibility:public\"],\n)\n",
+              "strip_prefix": "meson-1.1.1",
+              "url": "https://github.com/mesonbuild/meson/releases/download/1.1.1/meson-1.1.1.tar.gz"
+            }
+          },
+          "glib_dev": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "\nload(\"@rules_cc//cc:defs.bzl\", \"cc_library\")\n\ncc_import(\n    name = \"glib_dev\",\n    hdrs = glob([\"include/**\"]),\n    shared_library = \"@glib_runtime//:bin/libglib-2.0-0.dll\",\n    visibility = [\"//visibility:public\"],\n)\n        ",
+              "sha256": "bdf18506df304d38be98a4b3f18055b8b8cca81beabecad0eece6ce95319c369",
+              "urls": [
+                "https://download.gnome.org/binaries/win64/glib/2.26/glib-dev_2.26.1-1_win64.zip"
+              ]
+            }
+          },
+          "glib_src": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "\ncc_import(\n    name = \"msvc_hdr\",\n    hdrs = [\"msvc_recommended_pragmas.h\"],\n    visibility = [\"//visibility:public\"],\n)\n        ",
+              "sha256": "bc96f63112823b7d6c9f06572d2ad626ddac7eb452c04d762592197f6e07898e",
+              "strip_prefix": "glib-2.26.1",
+              "urls": [
+                "https://download.gnome.org/sources/glib/2.26/glib-2.26.1.tar.gz"
+              ]
+            }
+          },
+          "glib_runtime": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "\nexports_files(\n    [\n        \"bin/libgio-2.0-0.dll\",\n        \"bin/libglib-2.0-0.dll\",\n        \"bin/libgmodule-2.0-0.dll\",\n        \"bin/libgobject-2.0-0.dll\",\n        \"bin/libgthread-2.0-0.dll\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n        ",
+              "sha256": "88d857087e86f16a9be651ee7021880b3f7ba050d34a1ed9f06113b8799cb973",
+              "urls": [
+                "https://download.gnome.org/binaries/win64/glib/2.26/glib_2.26.1-1_win64.zip"
+              ]
+            }
+          },
+          "gettext_runtime": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "\ncc_import(\n    name = \"gettext_runtime\",\n    shared_library = \"bin/libintl-8.dll\",\n    visibility = [\"//visibility:public\"],\n)\n        ",
+              "sha256": "1f4269c0e021076d60a54e98da6f978a3195013f6de21674ba0edbc339c5b079",
+              "urls": [
+                "https://download.gnome.org/binaries/win64/dependencies/gettext-runtime_0.18.1.1-2_win64.zip"
+              ]
+            }
+          },
+          "pkgconfig_src": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "build_file_content": "filegroup(\n    name = \"all_srcs\",\n    srcs = glob([\"**\"]),\n    visibility = [\"//visibility:public\"],\n)\n",
+              "sha256": "6fc69c01688c9458a57eb9a1664c9aba372ccda420a02bf4429fe610e7e7d591",
+              "strip_prefix": "pkg-config-0.29.2",
+              "patches": [
+                "@@rules_foreign_cc~//toolchains:pkgconfig-detectenv.patch",
+                "@@rules_foreign_cc~//toolchains:pkgconfig-makefile-vc.patch"
+              ],
+              "urls": [
+                "https://pkgconfig.freedesktop.org/releases/pkg-config-0.29.2.tar.gz"
+              ]
+            }
+          },
+          "bazel_skylib": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.2.1/bazel-skylib-1.2.1.tar.gz",
+                "https://github.com/bazelbuild/bazel-skylib/releases/download/1.2.1/bazel-skylib-1.2.1.tar.gz"
+              ],
+              "sha256": "f7be3474d42aae265405a592bb7da8e171919d74c16f082a5457840f06054728"
+            }
+          },
+          "rules_python": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "sha256": "84aec9e21cc56fbc7f1335035a71c850d1b9b5cc6ff497306f84cced9a769841",
+              "strip_prefix": "rules_python-0.23.1",
+              "url": "https://github.com/bazelbuild/rules_python/archive/refs/tags/0.23.1.tar.gz"
+            }
+          },
+          "cmake-3.23.2-linux-aarch64": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2-linux-aarch64.tar.gz"
+              ],
+              "sha256": "f2654bf780b53f170bbbec44d8ac67d401d24788e590faa53036a89476efa91e",
+              "strip_prefix": "cmake-3.23.2-linux-aarch64",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"cmake_data\",\n    srcs = glob(\n        [\n            \"**\",\n        ],\n        exclude = [\n            \"WORKSPACE\",\n            \"WORKSPACE.bazel\",\n            \"BUILD\",\n            \"BUILD.bazel\",\n        ],\n    ),\n)\n\nnative_tool_toolchain(\n    name = \"cmake_tool\",\n    path = \"bin/cmake\",\n    target = \":cmake_data\",\n)\n"
+            }
+          },
+          "cmake-3.23.2-linux-x86_64": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2-linux-x86_64.tar.gz"
+              ],
+              "sha256": "aaced6f745b86ce853661a595bdac6c5314a60f8181b6912a0a4920acfa32708",
+              "strip_prefix": "cmake-3.23.2-linux-x86_64",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"cmake_data\",\n    srcs = glob(\n        [\n            \"**\",\n        ],\n        exclude = [\n            \"WORKSPACE\",\n            \"WORKSPACE.bazel\",\n            \"BUILD\",\n            \"BUILD.bazel\",\n        ],\n    ),\n)\n\nnative_tool_toolchain(\n    name = \"cmake_tool\",\n    path = \"bin/cmake\",\n    target = \":cmake_data\",\n)\n"
+            }
+          },
+          "cmake-3.23.2-macos-universal": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2-macos-universal.tar.gz"
+              ],
+              "sha256": "853a0f9af148c5ef47282ffffee06c4c9f257be2635936755f39ca13c3286c88",
+              "strip_prefix": "cmake-3.23.2-macos-universal/CMake.app/Contents",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"cmake_data\",\n    srcs = glob(\n        [\n            \"**\",\n        ],\n        exclude = [\n            \"WORKSPACE\",\n            \"WORKSPACE.bazel\",\n            \"BUILD\",\n            \"BUILD.bazel\",\n        ],\n    ),\n)\n\nnative_tool_toolchain(\n    name = \"cmake_tool\",\n    path = \"bin/cmake\",\n    target = \":cmake_data\",\n)\n"
+            }
+          },
+          "cmake-3.23.2-windows-i386": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2-windows-i386.zip"
+              ],
+              "sha256": "6a4fcd6a2315b93cb23c93507efccacc30c449c2bf98f14d6032bb226c582e07",
+              "strip_prefix": "cmake-3.23.2-windows-i386",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"cmake_data\",\n    srcs = glob(\n        [\n            \"**\",\n        ],\n        exclude = [\n            \"WORKSPACE\",\n            \"WORKSPACE.bazel\",\n            \"BUILD\",\n            \"BUILD.bazel\",\n        ],\n    ),\n)\n\nnative_tool_toolchain(\n    name = \"cmake_tool\",\n    path = \"bin/cmake.exe\",\n    target = \":cmake_data\",\n)\n"
+            }
+          },
+          "cmake-3.23.2-windows-x86_64": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2-windows-x86_64.zip"
+              ],
+              "sha256": "2329387f3166b84c25091c86389fb891193967740c9bcf01e7f6d3306f7ffda0",
+              "strip_prefix": "cmake-3.23.2-windows-x86_64",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"cmake_data\",\n    srcs = glob(\n        [\n            \"**\",\n        ],\n        exclude = [\n            \"WORKSPACE\",\n            \"WORKSPACE.bazel\",\n            \"BUILD\",\n            \"BUILD.bazel\",\n        ],\n    ),\n)\n\nnative_tool_toolchain(\n    name = \"cmake_tool\",\n    path = \"bin/cmake.exe\",\n    target = \":cmake_data\",\n)\n"
+            }
+          },
+          "cmake_3.23.2_toolchains": {
+            "bzlFile": "@@rules_foreign_cc~//toolchains:prebuilt_toolchains_repository.bzl",
+            "ruleClassName": "prebuilt_toolchains_repository",
+            "attributes": {
+              "repos": {
+                "cmake-3.23.2-linux-aarch64": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "cmake-3.23.2-linux-x86_64": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "cmake-3.23.2-macos-universal": [
+                  "@platforms//os:macos"
+                ],
+                "cmake-3.23.2-windows-i386": [
+                  "@platforms//cpu:x86_32",
+                  "@platforms//os:windows"
+                ],
+                "cmake-3.23.2-windows-x86_64": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ]
+              },
+              "tool": "cmake"
+            }
+          },
+          "ninja_1.11.1_linux": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/ninja-build/ninja/releases/download/v1.11.1/ninja-linux.zip"
+              ],
+              "sha256": "b901ba96e486dce377f9a070ed4ef3f79deb45f4ffe2938f8e7ddc69cfb3df77",
+              "strip_prefix": "",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"ninja_bin\",\n    srcs = [\"ninja\"],\n)\n\nnative_tool_toolchain(\n    name = \"ninja_tool\",\n    env = {\"NINJA\": \"$(execpath :ninja_bin)\"},\n    path = \"$(execpath :ninja_bin)\",\n    target = \":ninja_bin\",\n)\n"
+            }
+          },
+          "ninja_1.11.1_mac": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/ninja-build/ninja/releases/download/v1.11.1/ninja-mac.zip"
+              ],
+              "sha256": "482ecb23c59ae3d4f158029112de172dd96bb0e97549c4b1ca32d8fad11f873e",
+              "strip_prefix": "",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"ninja_bin\",\n    srcs = [\"ninja\"],\n)\n\nnative_tool_toolchain(\n    name = \"ninja_tool\",\n    env = {\"NINJA\": \"$(execpath :ninja_bin)\"},\n    path = \"$(execpath :ninja_bin)\",\n    target = \":ninja_bin\",\n)\n"
+            }
+          },
+          "ninja_1.11.1_win": {
+            "bzlFile": "@@bazel_tools//tools/build_defs/repo:http.bzl",
+            "ruleClassName": "http_archive",
+            "attributes": {
+              "urls": [
+                "https://github.com/ninja-build/ninja/releases/download/v1.11.1/ninja-win.zip"
+              ],
+              "sha256": "524b344a1a9a55005eaf868d991e090ab8ce07fa109f1820d40e74642e289abc",
+              "strip_prefix": "",
+              "build_file_content": "load(\"@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl\", \"native_tool_toolchain\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nfilegroup(\n    name = \"ninja_bin\",\n    srcs = [\"ninja.exe\"],\n)\n\nnative_tool_toolchain(\n    name = \"ninja_tool\",\n    env = {\"NINJA\": \"$(execpath :ninja_bin)\"},\n    path = \"$(execpath :ninja_bin)\",\n    target = \":ninja_bin\",\n)\n"
+            }
+          },
+          "ninja_1.11.1_toolchains": {
+            "bzlFile": "@@rules_foreign_cc~//toolchains:prebuilt_toolchains_repository.bzl",
+            "ruleClassName": "prebuilt_toolchains_repository",
+            "attributes": {
+              "repos": {
+                "ninja_1.11.1_linux": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "ninja_1.11.1_mac": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:macos"
+                ],
+                "ninja_1.11.1_win": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ]
+              },
+              "tool": "ninja"
+            }
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "rules_foreign_cc~",
+            "bazel_tools",
+            "bazel_tools"
+          ],
+          [
+            "rules_foreign_cc~",
+            "rules_foreign_cc",
+            "rules_foreign_cc~"
+          ]
+        ]
+      }
+    },
+    "@@rules_go~//go:extensions.bzl%go_sdk": {
+      "general": {
+        "bzlTransitiveDigest": "8NkcgnML0idfe+aSUrahYJPXCAotWV11d+LSLMy+Pv4=",
+        "usagesDigest": "X5aqZFHzd1sdmeEDb7EhtLQxpfWCqdD+QovvCyIB8hw=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "go_default_sdk": {
+            "bzlFile": "@@rules_go~//go/private:sdk.bzl",
+            "ruleClassName": "go_download_sdk_rule",
+            "attributes": {
+              "goos": "",
+              "goarch": "",
+              "sdks": {},
+              "urls": [
+                "https://dl.google.com/go/{}"
+              ],
+              "version": "1.19.8"
+            }
+          },
+          "go_toolchains": {
+            "bzlFile": "@@rules_go~//go/private:sdk.bzl",
+            "ruleClassName": "go_multiple_toolchains",
+            "attributes": {
+              "prefixes": [
+                "_0000_go_default_sdk_"
+              ],
+              "geese": [
+                ""
+              ],
+              "goarchs": [
+                ""
+              ],
+              "sdk_repos": [
+                "go_default_sdk"
+              ],
+              "sdk_types": [
+                "remote"
+              ],
+              "sdk_versions": [
+                "1.19.8"
+              ]
+            }
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "rules_go~",
+            "bazel_tools",
+            "bazel_tools"
+          ]
+        ]
+      }
+    },
+    "@@rules_nodejs~//nodejs:extensions.bzl%node": {
+      "general": {
+        "bzlTransitiveDigest": "xRRX0NuyvfLtjtzM4AqJgxdMSWWnLIw28rUUi10y6k0=",
+        "usagesDigest": "9IUJvk13jWE1kE+N3sP2y0mw9exjO9CGQ2oAgwKTNK4=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "nodejs_linux_amd64": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "linux_amd64",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs_linux_arm64": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "linux_arm64",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs_linux_s390x": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "linux_s390x",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs_linux_ppc64le": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "linux_ppc64le",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs_darwin_amd64": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "darwin_amd64",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs_darwin_arm64": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "darwin_arm64",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs_windows_amd64": {
+            "bzlFile": "@@rules_nodejs~//nodejs:repositories.bzl",
+            "ruleClassName": "node_repositories",
+            "attributes": {
+              "platform": "windows_amd64",
+              "node_version": "16.19.0"
+            }
+          },
+          "nodejs": {
+            "bzlFile": "@@rules_nodejs~//nodejs/private:nodejs_repo_host_os_alias.bzl",
+            "ruleClassName": "nodejs_repo_host_os_alias",
+            "attributes": {
+              "user_node_repository_name": "nodejs"
+            }
+          },
+          "nodejs_host": {
+            "bzlFile": "@@rules_nodejs~//nodejs/private:nodejs_repo_host_os_alias.bzl",
+            "ruleClassName": "nodejs_repo_host_os_alias",
+            "attributes": {
+              "user_node_repository_name": "nodejs"
+            }
+          },
+          "nodejs_toolchains": {
+            "bzlFile": "@@rules_nodejs~//nodejs/private:toolchains_repo.bzl",
+            "ruleClassName": "toolchains_repo",
+            "attributes": {
+              "user_node_repository_name": "nodejs"
+            }
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "rules_nodejs~",
+            "bazel_skylib",
+            "bazel_skylib~"
+          ],
+          [
+            "rules_nodejs~",
+            "bazel_tools",
+            "bazel_tools"
+          ]
+        ]
+      }
+    },
+    "@@rules_rust~//rust:extensions.bzl%rust": {
+      "general": {
+        "bzlTransitiveDigest": "WtmdqwlM3aa/7bmxjfh+PFDdL1lBLJuHAw7SGzzcl4s=",
+        "usagesDigest": "ElzJR5U/JYBUVkh3JnMDYgDbl5hTB0/+pB2cMOfl8IQ=",
+        "recordedFileInputs": {},
+        "recordedDirentsInputs": {},
+        "envVariables": {},
+        "generatedRepoSpecs": {
+          "rust_analyzer_1.78.0_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_analyzer_toolchain_tools_repository",
+            "attributes": {
+              "version": "1.78.0",
+              "iso_date": "",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_analyzer_1.78.0": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_analyzer_1.78.0_tools//:rust_analyzer_toolchain",
+              "toolchain_type": "@rules_rust//rust/rust_analyzer:toolchain_type",
+              "exec_compatible_with": [],
+              "target_compatible_with": []
+            }
+          },
+          "rust_darwin_aarch64__aarch64-apple-darwin__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "aarch64-apple-darwin",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_aarch64__aarch64-apple-darwin__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_aarch64__aarch64-apple-darwin__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ]
+            }
+          },
+          "rust_darwin_aarch64__aarch64-apple-darwin__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "aarch64-apple-darwin",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_aarch64__aarch64-apple-darwin__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_aarch64__aarch64-apple-darwin__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ]
+            }
+          },
+          "rust_darwin_aarch64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_aarch64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_aarch64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_darwin_aarch64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_aarch64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_aarch64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_darwin_aarch64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_aarch64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_aarch64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_darwin_aarch64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_aarch64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_aarch64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_darwin_aarch64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_darwin_aarch64__aarch64-apple-darwin__stable//:toolchain",
+                "@rust_darwin_aarch64__aarch64-apple-darwin__nightly//:toolchain",
+                "@rust_darwin_aarch64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_darwin_aarch64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_darwin_aarch64__wasm32-wasi__stable//:toolchain",
+                "@rust_darwin_aarch64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__aarch64-apple-darwin_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "aarch64-apple-darwin"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__aarch64-apple-darwin": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__aarch64-apple-darwin_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_windows_aarch64__aarch64-pc-windows-msvc__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "aarch64-pc-windows-msvc",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_aarch64__aarch64-pc-windows-msvc__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_aarch64__aarch64-pc-windows-msvc__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ]
+            }
+          },
+          "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "aarch64-pc-windows-msvc",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_aarch64__aarch64-pc-windows-msvc__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ]
+            }
+          },
+          "rust_windows_aarch64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_aarch64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_aarch64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_windows_aarch64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_aarch64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_aarch64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_windows_aarch64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_aarch64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_aarch64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_windows_aarch64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_aarch64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_aarch64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_windows_aarch64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_windows_aarch64__aarch64-pc-windows-msvc__stable//:toolchain",
+                "@rust_windows_aarch64__aarch64-pc-windows-msvc__nightly//:toolchain",
+                "@rust_windows_aarch64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_windows_aarch64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_windows_aarch64__wasm32-wasi__stable//:toolchain",
+                "@rust_windows_aarch64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "aarch64-pc-windows-msvc"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "aarch64-unknown-linux-gnu",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_aarch64__aarch64-unknown-linux-gnu__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ]
+            }
+          },
+          "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "aarch64-unknown-linux-gnu",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ]
+            }
+          },
+          "rust_linux_aarch64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_aarch64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_aarch64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_linux_aarch64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_aarch64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_aarch64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_linux_aarch64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_aarch64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_aarch64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_linux_aarch64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "aarch64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_aarch64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_aarch64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_linux_aarch64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_linux_aarch64__aarch64-unknown-linux-gnu__stable//:toolchain",
+                "@rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly//:toolchain",
+                "@rust_linux_aarch64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_linux_aarch64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_linux_aarch64__wasm32-wasi__stable//:toolchain",
+                "@rust_linux_aarch64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "aarch64-unknown-linux-gnu"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:aarch64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_darwin_x86_64__x86_64-apple-darwin__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-apple-darwin",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_x86_64__x86_64-apple-darwin__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_x86_64__x86_64-apple-darwin__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ]
+            }
+          },
+          "rust_darwin_x86_64__x86_64-apple-darwin__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-apple-darwin",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_x86_64__x86_64-apple-darwin__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_x86_64__x86_64-apple-darwin__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ]
+            }
+          },
+          "rust_darwin_x86_64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_x86_64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_darwin_x86_64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_x86_64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_darwin_x86_64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_x86_64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_darwin_x86_64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-apple-darwin",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_darwin_x86_64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_darwin_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_darwin_x86_64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_darwin_x86_64__x86_64-apple-darwin__stable//:toolchain",
+                "@rust_darwin_x86_64__x86_64-apple-darwin__nightly//:toolchain",
+                "@rust_darwin_x86_64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_darwin_x86_64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_darwin_x86_64__wasm32-wasi__stable//:toolchain",
+                "@rust_darwin_x86_64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-apple-darwin_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "x86_64-apple-darwin"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-apple-darwin": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__x86_64-apple-darwin_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:osx"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_windows_x86_64__x86_64-pc-windows-msvc__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-pc-windows-msvc",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_x86_64__x86_64-pc-windows-msvc__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_x86_64__x86_64-pc-windows-msvc__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ]
+            }
+          },
+          "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-pc-windows-msvc",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_x86_64__x86_64-pc-windows-msvc__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ]
+            }
+          },
+          "rust_windows_x86_64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_x86_64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_windows_x86_64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_x86_64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_windows_x86_64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_x86_64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_windows_x86_64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-pc-windows-msvc",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_windows_x86_64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_windows_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_windows_x86_64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_windows_x86_64__x86_64-pc-windows-msvc__stable//:toolchain",
+                "@rust_windows_x86_64__x86_64-pc-windows-msvc__nightly//:toolchain",
+                "@rust_windows_x86_64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_windows_x86_64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_windows_x86_64__wasm32-wasi__stable//:toolchain",
+                "@rust_windows_x86_64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "x86_64-pc-windows-msvc"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:windows"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-freebsd",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-unknown-freebsd",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_freebsd_x86_64__x86_64-unknown-freebsd__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ]
+            }
+          },
+          "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-freebsd",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-unknown-freebsd",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ]
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-freebsd",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_freebsd_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-freebsd",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_freebsd_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-freebsd",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_freebsd_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-freebsd",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_freebsd_x86_64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_freebsd_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_freebsd_x86_64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_freebsd_x86_64__x86_64-unknown-freebsd__stable//:toolchain",
+                "@rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly//:toolchain",
+                "@rust_freebsd_x86_64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_freebsd_x86_64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_freebsd_x86_64__wasm32-wasi__stable//:toolchain",
+                "@rust_freebsd_x86_64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "x86_64-unknown-freebsd"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:freebsd"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-unknown-linux-gnu",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_x86_64__x86_64-unknown-linux-gnu__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ]
+            }
+          },
+          "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "x86_64-unknown-linux-gnu",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ]
+            }
+          },
+          "rust_linux_x86_64__wasm32-unknown-unknown__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_x86_64__wasm32-unknown-unknown__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_linux_x86_64__wasm32-unknown-unknown__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-unknown-unknown",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_x86_64__wasm32-unknown-unknown__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:none"
+              ]
+            }
+          },
+          "rust_linux_x86_64__wasm32-wasi__stable_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "",
+              "version": "1.78.0",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_x86_64__wasm32-wasi__stable": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:stable"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_linux_x86_64__wasm32-wasi__nightly_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_tools_repository",
+            "attributes": {
+              "exec_triple": "x86_64-unknown-linux-gnu",
+              "allocator_library": "@rules_rust//ffi/cc/allocator_library",
+              "global_allocator_library": "@rules_rust//ffi/cc/global_allocator_library",
+              "target_triple": "wasm32-wasi",
+              "iso_date": "2024-05-02",
+              "version": "nightly",
+              "rustfmt_version": "nightly/2024-05-02",
+              "edition": "2021",
+              "dev_components": false,
+              "extra_rustc_flags": [],
+              "extra_exec_rustc_flags": [],
+              "opt_level": {},
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": []
+            }
+          },
+          "rust_linux_x86_64__wasm32-wasi__nightly": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rust_linux_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+              "target_settings": [
+                "@rules_rust//rust/toolchain/channel:nightly"
+              ],
+              "toolchain_type": "@rules_rust//rust:toolchain",
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": [
+                "@platforms//cpu:wasm32",
+                "@platforms//os:wasi"
+              ]
+            }
+          },
+          "rust_linux_x86_64": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rust_toolchain_set_repository",
+            "attributes": {
+              "toolchains": [
+                "@rust_linux_x86_64__x86_64-unknown-linux-gnu__stable//:toolchain",
+                "@rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly//:toolchain",
+                "@rust_linux_x86_64__wasm32-unknown-unknown__stable//:toolchain",
+                "@rust_linux_x86_64__wasm32-unknown-unknown__nightly//:toolchain",
+                "@rust_linux_x86_64__wasm32-wasi__stable//:toolchain",
+                "@rust_linux_x86_64__wasm32-wasi__nightly//:toolchain"
+              ]
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu_tools": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "rustfmt_toolchain_tools_repository",
+            "attributes": {
+              "version": "nightly",
+              "iso_date": "2024-05-02",
+              "sha256s": {},
+              "urls": [
+                "https://static.rust-lang.org/dist/{}.tar.xz"
+              ],
+              "auth": {},
+              "netrc": "",
+              "auth_patterns": {},
+              "exec_triple": "x86_64-unknown-linux-gnu"
+            }
+          },
+          "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu": {
+            "bzlFile": "@@rules_rust~//rust:repositories.bzl",
+            "ruleClassName": "toolchain_repository_proxy",
+            "attributes": {
+              "toolchain": "@rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu_tools//:rustfmt_toolchain",
+              "toolchain_type": "@rules_rust//rust/rustfmt:toolchain_type",
+              "target_settings": [],
+              "exec_compatible_with": [
+                "@platforms//cpu:x86_64",
+                "@platforms//os:linux"
+              ],
+              "target_compatible_with": []
+            }
+          },
+          "rust_toolchains": {
+            "bzlFile": "@@rules_rust~//rust/private:repository_utils.bzl",
+            "ruleClassName": "toolchain_repository_hub",
+            "attributes": {
+              "toolchain_names": [
+                "rust_analyzer_1.78.0",
+                "rust_darwin_aarch64__aarch64-apple-darwin__stable",
+                "rust_darwin_aarch64__aarch64-apple-darwin__nightly",
+                "rust_darwin_aarch64__wasm32-unknown-unknown__stable",
+                "rust_darwin_aarch64__wasm32-unknown-unknown__nightly",
+                "rust_darwin_aarch64__wasm32-wasi__stable",
+                "rust_darwin_aarch64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__aarch64-apple-darwin",
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__stable",
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly",
+                "rust_windows_aarch64__wasm32-unknown-unknown__stable",
+                "rust_windows_aarch64__wasm32-unknown-unknown__nightly",
+                "rust_windows_aarch64__wasm32-wasi__stable",
+                "rust_windows_aarch64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc",
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable",
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly",
+                "rust_linux_aarch64__wasm32-unknown-unknown__stable",
+                "rust_linux_aarch64__wasm32-unknown-unknown__nightly",
+                "rust_linux_aarch64__wasm32-wasi__stable",
+                "rust_linux_aarch64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu",
+                "rust_darwin_x86_64__x86_64-apple-darwin__stable",
+                "rust_darwin_x86_64__x86_64-apple-darwin__nightly",
+                "rust_darwin_x86_64__wasm32-unknown-unknown__stable",
+                "rust_darwin_x86_64__wasm32-unknown-unknown__nightly",
+                "rust_darwin_x86_64__wasm32-wasi__stable",
+                "rust_darwin_x86_64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__x86_64-apple-darwin",
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__stable",
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly",
+                "rust_windows_x86_64__wasm32-unknown-unknown__stable",
+                "rust_windows_x86_64__wasm32-unknown-unknown__nightly",
+                "rust_windows_x86_64__wasm32-wasi__stable",
+                "rust_windows_x86_64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc",
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable",
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly",
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__stable",
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly",
+                "rust_freebsd_x86_64__wasm32-wasi__stable",
+                "rust_freebsd_x86_64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd",
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable",
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly",
+                "rust_linux_x86_64__wasm32-unknown-unknown__stable",
+                "rust_linux_x86_64__wasm32-unknown-unknown__nightly",
+                "rust_linux_x86_64__wasm32-wasi__stable",
+                "rust_linux_x86_64__wasm32-wasi__nightly",
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu"
+              ],
+              "toolchain_labels": {
+                "rust_analyzer_1.78.0": "@rust_analyzer_1.78.0_tools//:rust_analyzer_toolchain",
+                "rust_darwin_aarch64__aarch64-apple-darwin__stable": "@rust_darwin_aarch64__aarch64-apple-darwin__stable_tools//:rust_toolchain",
+                "rust_darwin_aarch64__aarch64-apple-darwin__nightly": "@rust_darwin_aarch64__aarch64-apple-darwin__nightly_tools//:rust_toolchain",
+                "rust_darwin_aarch64__wasm32-unknown-unknown__stable": "@rust_darwin_aarch64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_darwin_aarch64__wasm32-unknown-unknown__nightly": "@rust_darwin_aarch64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_darwin_aarch64__wasm32-wasi__stable": "@rust_darwin_aarch64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_darwin_aarch64__wasm32-wasi__nightly": "@rust_darwin_aarch64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__aarch64-apple-darwin": "@rustfmt_nightly-2024-05-02__aarch64-apple-darwin_tools//:rustfmt_toolchain",
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__stable": "@rust_windows_aarch64__aarch64-pc-windows-msvc__stable_tools//:rust_toolchain",
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly": "@rust_windows_aarch64__aarch64-pc-windows-msvc__nightly_tools//:rust_toolchain",
+                "rust_windows_aarch64__wasm32-unknown-unknown__stable": "@rust_windows_aarch64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_windows_aarch64__wasm32-unknown-unknown__nightly": "@rust_windows_aarch64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_windows_aarch64__wasm32-wasi__stable": "@rust_windows_aarch64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_windows_aarch64__wasm32-wasi__nightly": "@rust_windows_aarch64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc": "@rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc_tools//:rustfmt_toolchain",
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable": "@rust_linux_aarch64__aarch64-unknown-linux-gnu__stable_tools//:rust_toolchain",
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly": "@rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly_tools//:rust_toolchain",
+                "rust_linux_aarch64__wasm32-unknown-unknown__stable": "@rust_linux_aarch64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_linux_aarch64__wasm32-unknown-unknown__nightly": "@rust_linux_aarch64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_linux_aarch64__wasm32-wasi__stable": "@rust_linux_aarch64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_linux_aarch64__wasm32-wasi__nightly": "@rust_linux_aarch64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu": "@rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu_tools//:rustfmt_toolchain",
+                "rust_darwin_x86_64__x86_64-apple-darwin__stable": "@rust_darwin_x86_64__x86_64-apple-darwin__stable_tools//:rust_toolchain",
+                "rust_darwin_x86_64__x86_64-apple-darwin__nightly": "@rust_darwin_x86_64__x86_64-apple-darwin__nightly_tools//:rust_toolchain",
+                "rust_darwin_x86_64__wasm32-unknown-unknown__stable": "@rust_darwin_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_darwin_x86_64__wasm32-unknown-unknown__nightly": "@rust_darwin_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_darwin_x86_64__wasm32-wasi__stable": "@rust_darwin_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_darwin_x86_64__wasm32-wasi__nightly": "@rust_darwin_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-apple-darwin": "@rustfmt_nightly-2024-05-02__x86_64-apple-darwin_tools//:rustfmt_toolchain",
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__stable": "@rust_windows_x86_64__x86_64-pc-windows-msvc__stable_tools//:rust_toolchain",
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly": "@rust_windows_x86_64__x86_64-pc-windows-msvc__nightly_tools//:rust_toolchain",
+                "rust_windows_x86_64__wasm32-unknown-unknown__stable": "@rust_windows_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_windows_x86_64__wasm32-unknown-unknown__nightly": "@rust_windows_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_windows_x86_64__wasm32-wasi__stable": "@rust_windows_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_windows_x86_64__wasm32-wasi__nightly": "@rust_windows_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc": "@rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc_tools//:rustfmt_toolchain",
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable": "@rust_freebsd_x86_64__x86_64-unknown-freebsd__stable_tools//:rust_toolchain",
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly": "@rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly_tools//:rust_toolchain",
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__stable": "@rust_freebsd_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly": "@rust_freebsd_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_freebsd_x86_64__wasm32-wasi__stable": "@rust_freebsd_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_freebsd_x86_64__wasm32-wasi__nightly": "@rust_freebsd_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd": "@rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd_tools//:rustfmt_toolchain",
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable": "@rust_linux_x86_64__x86_64-unknown-linux-gnu__stable_tools//:rust_toolchain",
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly": "@rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly_tools//:rust_toolchain",
+                "rust_linux_x86_64__wasm32-unknown-unknown__stable": "@rust_linux_x86_64__wasm32-unknown-unknown__stable_tools//:rust_toolchain",
+                "rust_linux_x86_64__wasm32-unknown-unknown__nightly": "@rust_linux_x86_64__wasm32-unknown-unknown__nightly_tools//:rust_toolchain",
+                "rust_linux_x86_64__wasm32-wasi__stable": "@rust_linux_x86_64__wasm32-wasi__stable_tools//:rust_toolchain",
+                "rust_linux_x86_64__wasm32-wasi__nightly": "@rust_linux_x86_64__wasm32-wasi__nightly_tools//:rust_toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu": "@rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu_tools//:rustfmt_toolchain"
+              },
+              "toolchain_types": {
+                "rust_analyzer_1.78.0": "@rules_rust//rust/rust_analyzer:toolchain_type",
+                "rust_darwin_aarch64__aarch64-apple-darwin__stable": "@rules_rust//rust:toolchain",
+                "rust_darwin_aarch64__aarch64-apple-darwin__nightly": "@rules_rust//rust:toolchain",
+                "rust_darwin_aarch64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_darwin_aarch64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_darwin_aarch64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_darwin_aarch64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__aarch64-apple-darwin": "@rules_rust//rust/rustfmt:toolchain_type",
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__stable": "@rules_rust//rust:toolchain",
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly": "@rules_rust//rust:toolchain",
+                "rust_windows_aarch64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_windows_aarch64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_windows_aarch64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_windows_aarch64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc": "@rules_rust//rust/rustfmt:toolchain_type",
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable": "@rules_rust//rust:toolchain",
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly": "@rules_rust//rust:toolchain",
+                "rust_linux_aarch64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_linux_aarch64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_linux_aarch64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_linux_aarch64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu": "@rules_rust//rust/rustfmt:toolchain_type",
+                "rust_darwin_x86_64__x86_64-apple-darwin__stable": "@rules_rust//rust:toolchain",
+                "rust_darwin_x86_64__x86_64-apple-darwin__nightly": "@rules_rust//rust:toolchain",
+                "rust_darwin_x86_64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_darwin_x86_64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_darwin_x86_64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_darwin_x86_64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-apple-darwin": "@rules_rust//rust/rustfmt:toolchain_type",
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__stable": "@rules_rust//rust:toolchain",
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly": "@rules_rust//rust:toolchain",
+                "rust_windows_x86_64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_windows_x86_64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_windows_x86_64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_windows_x86_64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc": "@rules_rust//rust/rustfmt:toolchain_type",
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable": "@rules_rust//rust:toolchain",
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly": "@rules_rust//rust:toolchain",
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_freebsd_x86_64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_freebsd_x86_64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd": "@rules_rust//rust/rustfmt:toolchain_type",
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable": "@rules_rust//rust:toolchain",
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly": "@rules_rust//rust:toolchain",
+                "rust_linux_x86_64__wasm32-unknown-unknown__stable": "@rules_rust//rust:toolchain",
+                "rust_linux_x86_64__wasm32-unknown-unknown__nightly": "@rules_rust//rust:toolchain",
+                "rust_linux_x86_64__wasm32-wasi__stable": "@rules_rust//rust:toolchain",
+                "rust_linux_x86_64__wasm32-wasi__nightly": "@rules_rust//rust:toolchain",
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu": "@rules_rust//rust/rustfmt:toolchain_type"
+              },
+              "exec_compatible_with": {
+                "rust_analyzer_1.78.0": [],
+                "rust_darwin_aarch64__aarch64-apple-darwin__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__aarch64-apple-darwin__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__wasm32-wasi__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rustfmt_nightly-2024-05-02__aarch64-apple-darwin": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__wasm32-wasi__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__wasm32-wasi__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_darwin_x86_64__x86_64-apple-darwin__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__x86_64-apple-darwin__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-apple-darwin": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ]
+              },
+              "target_compatible_with": {
+                "rust_analyzer_1.78.0": [],
+                "rust_darwin_aarch64__aarch64-apple-darwin__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__aarch64-apple-darwin__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_aarch64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_darwin_aarch64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_darwin_aarch64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_darwin_aarch64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__aarch64-apple-darwin": [],
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__aarch64-pc-windows-msvc__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_aarch64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_windows_aarch64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_windows_aarch64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_windows_aarch64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__aarch64-pc-windows-msvc": [],
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__stable": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__aarch64-unknown-linux-gnu__nightly": [
+                  "@platforms//cpu:aarch64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_aarch64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_linux_aarch64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_linux_aarch64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_linux_aarch64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__aarch64-unknown-linux-gnu": [],
+                "rust_darwin_x86_64__x86_64-apple-darwin__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__x86_64-apple-darwin__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:osx"
+                ],
+                "rust_darwin_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_darwin_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_darwin_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_darwin_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-apple-darwin": [],
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__x86_64-pc-windows-msvc__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:windows"
+                ],
+                "rust_windows_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_windows_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_windows_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_windows_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-pc-windows-msvc": [],
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__x86_64-unknown-freebsd__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:freebsd"
+                ],
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_freebsd_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_freebsd_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_freebsd_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-freebsd": [],
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__stable": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__x86_64-unknown-linux-gnu__nightly": [
+                  "@platforms//cpu:x86_64",
+                  "@platforms//os:linux"
+                ],
+                "rust_linux_x86_64__wasm32-unknown-unknown__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_linux_x86_64__wasm32-unknown-unknown__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:none"
+                ],
+                "rust_linux_x86_64__wasm32-wasi__stable": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rust_linux_x86_64__wasm32-wasi__nightly": [
+                  "@platforms//cpu:wasm32",
+                  "@platforms//os:wasi"
+                ],
+                "rustfmt_nightly-2024-05-02__x86_64-unknown-linux-gnu": []
+              }
+            }
+          }
+        },
+        "recordedRepoMappingEntries": [
+          [
+            "bazel_features~",
+            "bazel_features_globals",
+            "bazel_features~~version_extension~bazel_features_globals"
+          ],
+          [
+            "bazel_features~",
+            "bazel_features_version",
+            "bazel_features~~version_extension~bazel_features_version"
+          ],
+          [
+            "rules_rust~",
+            "bazel_features",
+            "bazel_features~"
+          ],
+          [
+            "rules_rust~",
+            "bazel_skylib",
+            "bazel_skylib~"
+          ],
+          [
+            "rules_rust~",
+            "bazel_tools",
+            "bazel_tools"
+          ],
+          [
+            "rules_rust~",
+            "rules_rust",
+            "rules_rust~"
+          ]
+        ]
+      }
+    }
+  }
+}
diff --git a/OWNERS b/OWNERS
index 10c046b..470b72d 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,2 +1,3 @@
 ellisr@google.com
 schuffelen@google.com
+include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/WORKSPACE b/WORKSPACE
index 3e4628e..b223f19 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -12,25 +12,44 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+# Workspace definition used when Bzlmod is disabled
 workspace(name = "com_google_sandboxed_api")
 
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
 load("//sandboxed_api/bazel:sapi_deps.bzl", "sapi_deps")
 
 # Load Sandboxed API dependencies
 sapi_deps()
 
 load("@bazel_skylib//lib:versions.bzl", "versions")
-load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
-load(
-    "//sandboxed_api/bazel:llvm_config.bzl",
-    "llvm_disable_optional_support_deps",
-)
-load("@com_google_protobuf//:protobuf_deps.bzl", "protobuf_deps")
 
 versions.check(minimum_bazel_version = "5.1.0")
 
+load("@rules_python//python:repositories.bzl", "py_repositories")
+
+py_repositories()
+
+load("@rules_python//python:pip.bzl", "pip_parse")
+
+pip_parse(
+    name = "pypi",
+    requirements_lock = "//sandboxed_api/tools/python_generator:requirements_lock.txt",
+)
+
+load("@pypi//:requirements.bzl", "install_deps")
+
+# Initialize repositories for all packages in requirements_lock.txt.
+install_deps()
+
+load("@com_google_protobuf//:protobuf_deps.bzl", "protobuf_deps")
+
 protobuf_deps()
 
+load(
+    "//sandboxed_api/bazel:llvm_config.bzl",
+    "llvm_disable_optional_support_deps",
+)
+
 llvm_disable_optional_support_deps()
 
 # zlib, only needed for examples
diff --git a/WORKSPACE.bzlmod b/WORKSPACE.bzlmod
new file mode 100644
index 0000000..103c166
--- /dev/null
+++ b/WORKSPACE.bzlmod
@@ -0,0 +1,51 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Workspace definition used when Bzlmod is enabled
+workspace(name = "com_google_sandboxed_api")
+
+load("@bazel_skylib//lib:versions.bzl", "versions")
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+load("//sandboxed_api/bazel:sapi_deps.bzl", "sapi_non_module_deps")
+
+versions.check(minimum_bazel_version = "7.1.1")
+
+sapi_non_module_deps()
+
+load(
+    "//sandboxed_api/bazel:llvm_config.bzl",
+    "llvm_disable_optional_support_deps",
+)
+
+llvm_disable_optional_support_deps()
+
+# zlib, only needed for examples
+http_archive(
+    name = "net_zlib",
+    build_file = "//sandboxed_api:bazel/external/zlib.BUILD",
+    patch_args = ["-p1"],
+    # This is a patch that removes the "OF" macro that is used in zlib function
+    # definitions. It is necessary, because libclang, the library used by the
+    # interface generator to parse C/C++ files contains a bug that manifests
+    # itself with macros like this.
+    # We are investigating better ways to avoid this issue. For most "normal"
+    # C and C++ headers, parsing just works.
+    patches = ["//sandboxed_api:bazel/external/zlib.patch"],
+    sha256 = "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1",  # 2020-04-23
+    strip_prefix = "zlib-1.2.11",
+    urls = [
+        "https://mirror.bazel.build/zlib.net/zlib-1.2.11.tar.gz",
+        "https://www.zlib.net/zlib-1.2.11.tar.gz",
+    ],
+)
diff --git a/android/sandboxed_api_glibc_compat.h b/android/sandboxed_api_glibc_compat.h
index 8211e98..cfc8c9b 100644
--- a/android/sandboxed_api_glibc_compat.h
+++ b/android/sandboxed_api_glibc_compat.h
@@ -40,3 +40,7 @@
 #ifndef PTRACE_O_EXITKILL
 #define PTRACE_O_EXITKILL (1 << 20)
 #endif
+
+#ifndef PTRACE_EVENT_STOP
+#define PTRACE_EVENT_STOP 128
+#endif
diff --git a/cmake/SapiBuildDefs.cmake b/cmake/SapiBuildDefs.cmake
index 3364282..908043d 100644
--- a/cmake/SapiBuildDefs.cmake
+++ b/cmake/SapiBuildDefs.cmake
@@ -180,7 +180,7 @@ function(add_sapi_library)
     list(JOIN _sapi_full_inputs "," _sapi_full_inputs)
     list(APPEND _sapi_generator_command
       "${SAPI_PYTHON3_EXECUTABLE}" -B
-      "${SAPI_SOURCE_DIR}/sandboxed_api/tools/generator2/sapi_generator.py"
+      "${SAPI_SOURCE_DIR}/sandboxed_api/tools/python_generator/sapi_generator.py"
       ${_sapi_generator_args}
       "--sapi_isystem=${_sapi_isystem}"
       "--sapi_in=${_sapi_full_inputs}"
diff --git a/cmake/abseil-cpp.cmake b/cmake/abseil-cpp.cmake
index e89df42..cc9d9fd 100644
--- a/cmake/abseil-cpp.cmake
+++ b/cmake/abseil-cpp.cmake
@@ -13,8 +13,8 @@
 # limitations under the License.
 
 FetchContent_Declare(absl
-  URL https://github.com/abseil/abseil-cpp/archive/8ebad34c3fa54a9ad2f46ca8cab98e75c4f750bf.zip  # 2023-08-24
-  URL_HASH SHA256=1ca4c7431b0818a10507af8eac34a1873e4e786a18ecd3f04d8faf3a0874e8bb
+  URL https://github.com/abseil/abseil-cpp/archive/61e47a454c81eb07147b0315485f476513cc1230.zip  # 2024-04-05
+  URL_HASH SHA256=9ba0e97acf7026f7479e24967866ba9560cf3256304b6c8932d2b1ab7d0dfcd2
 )
 set(ABSL_CXX_STANDARD ${SAPI_CXX_STANDARD} CACHE STRING "" FORCE)
 set(ABSL_PROPAGATE_CXX_STD ON CACHE BOOL "" FORCE)
diff --git a/cmake/protobuf.cmake b/cmake/protobuf.cmake
index 98c7fbf..7523f82 100644
--- a/cmake/protobuf.cmake
+++ b/cmake/protobuf.cmake
@@ -13,8 +13,8 @@
 # limitations under the License.
 
 FetchContent_Declare(protobuf
-  URL https://github.com/protocolbuffers/protobuf/releases/download/v23.4/protobuf-23.4.tar.gz
-  URL_HASH SHA256=a700a49470d301f1190a487a923b5095bf60f08f4ae4cac9f5f7c36883d17971
+  URL https://github.com/protocolbuffers/protobuf/releases/download/v28.2/protobuf-28.2.tar.gz  # 2024-09-18
+  URL_HASH SHA256=b2340aa47faf7ef10a0328190319d3f3bee1b24f426d4ce8f4253b6f27ce16db
 )
 
 set(protobuf_ABSL_PROVIDER "package" CACHE STRING "" FORCE)
diff --git a/contrib/brotli/utils/utils_brotli_dec.cc b/contrib/brotli/utils/utils_brotli_dec.cc
index 2e98ae7..9b21d51 100644
--- a/contrib/brotli/utils/utils_brotli_dec.cc
+++ b/contrib/brotli/utils/utils_brotli_dec.cc
@@ -23,7 +23,7 @@
 absl::Status BrotliDecoder::InitStructs() {
   SAPI_ASSIGN_OR_RETURN(
       BrotliDecoderState * state,
-      api_.BrotliDecoderCreateInstance(&null_ptr_, &null_ptr_, &null_ptr_));
+      api_.BrotliDecoderCreateInstance(nullptr, nullptr, nullptr));
 
   state_.SetRemote(state);
 
@@ -84,12 +84,11 @@ absl::StatusOr<BrotliDecoderResult> BrotliDecoder::Decompress(
 
   sapi::v::IntBase<size_t> sapi_avilable_out(0);
 
-  SAPI_ASSIGN_OR_RETURN(
-      BrotliDecoderResult ret,
-      api_.BrotliDecoderDecompressStream(
-          state_.PtrNone(), sapi_size_in.PtrBefore(),
-          sapi_opaque_buf_in.PtrBefore(), sapi_avilable_out.PtrBefore(),
-          &null_ptr_, &null_ptr_));
+  SAPI_ASSIGN_OR_RETURN(BrotliDecoderResult ret,
+                        api_.BrotliDecoderDecompressStream(
+                            state_.PtrNone(), sapi_size_in.PtrBefore(),
+                            sapi_opaque_buf_in.PtrBefore(),
+                            sapi_avilable_out.PtrBefore(), nullptr, nullptr));
 
   // Ignore output error, as we didn't provide any buffer.
   if (ret == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT) {
diff --git a/contrib/brotli/utils/utils_brotli_dec.h b/contrib/brotli/utils/utils_brotli_dec.h
index 1ce2182..12665ae 100644
--- a/contrib/brotli/utils/utils_brotli_dec.h
+++ b/contrib/brotli/utils/utils_brotli_dec.h
@@ -44,7 +44,6 @@ class BrotliDecoder {
   BrotliApi api_;
   absl::Status status;
   sapi::v::GenericPtr state_;
-  sapi::v::NullPtr null_ptr_;
 };
 
 #endif  // CONTRIB_BROTLI_UTILS_UTILS_BROTLI_DEC_H_
diff --git a/contrib/brotli/utils/utils_brotli_enc.cc b/contrib/brotli/utils/utils_brotli_enc.cc
index f9b7a7b..f34c252 100644
--- a/contrib/brotli/utils/utils_brotli_enc.cc
+++ b/contrib/brotli/utils/utils_brotli_enc.cc
@@ -23,7 +23,7 @@
 absl::Status BrotliEncoder::InitStructs() {
   SAPI_ASSIGN_OR_RETURN(
       BrotliEncoderState * state,
-      api_.BrotliEncoderCreateInstance(&null_ptr_, &null_ptr_, &null_ptr_));
+      api_.BrotliEncoderCreateInstance(nullptr, nullptr, nullptr));
 
   state_.SetRemote(state);
 
@@ -84,11 +84,11 @@ absl::Status BrotliEncoder::Compress(std::vector<uint8_t>& buf_in,
 
   sapi::v::IntBase<size_t> sapi_avilable_out(0);
 
-  SAPI_ASSIGN_OR_RETURN(
-      bool ret, api_.BrotliEncoderCompressStream(
-                    state_.PtrNone(), op, sapi_size_in.PtrBefore(),
-                    sapi_opaque_buf_in.PtrBefore(),
-                    sapi_avilable_out.PtrBefore(), &null_ptr_, &null_ptr_));
+  SAPI_ASSIGN_OR_RETURN(bool ret,
+                        api_.BrotliEncoderCompressStream(
+                            state_.PtrNone(), op, sapi_size_in.PtrBefore(),
+                            sapi_opaque_buf_in.PtrBefore(),
+                            sapi_avilable_out.PtrBefore(), nullptr, nullptr));
   if (!ret) {
     return absl::UnavailableError("Unable to compress input");
   }
diff --git a/contrib/brotli/utils/utils_brotli_enc.h b/contrib/brotli/utils/utils_brotli_enc.h
index ed1f25b..0c8c9ee 100644
--- a/contrib/brotli/utils/utils_brotli_enc.h
+++ b/contrib/brotli/utils/utils_brotli_enc.h
@@ -45,7 +45,6 @@ class BrotliEncoder {
   BrotliApi api_;
   absl::Status status;
   sapi::v::GenericPtr state_;
-  sapi::v::NullPtr null_ptr_;
 };
 
 #endif  // CONTRIB_BROTLI_UTILS_UTILS_BROTLI_ENC_H_
diff --git a/contrib/libidn2/libidn2_sapi.cc b/contrib/libidn2/libidn2_sapi.cc
index cb8f514..8e528fb 100644
--- a/contrib/libidn2/libidn2_sapi.cc
+++ b/contrib/libidn2/libidn2_sapi.cc
@@ -60,10 +60,9 @@ absl::StatusOr<std::string> IDN2Lib::idn2_register_u8(const char* ulabel,
     alabel_ptr.emplace(alabel);
   }
   sapi::v::GenericPtr ptr;
-  sapi::v::NullPtr null_ptr;
   const auto untrusted_res = api_.idn2_register_u8(
-      ulabel ? ulabel_ptr->PtrBefore() : &null_ptr,
-      alabel ? alabel_ptr->PtrBefore() : &null_ptr, ptr.PtrAfter(),
+      ulabel ? ulabel_ptr->PtrBefore() : nullptr,
+      alabel ? alabel_ptr->PtrBefore() : nullptr, ptr.PtrAfter(),
       IDN2_NFC_INPUT | IDN2_NONTRANSITIONAL);
   return this->ProcessErrors(untrusted_res, ptr);
 }
diff --git a/contrib/libxls/example/main.cc b/contrib/libxls/example/main.cc
index 78db873..46d4568 100644
--- a/contrib/libxls/example/main.cc
+++ b/contrib/libxls/example/main.cc
@@ -17,6 +17,7 @@
 
 #include <cstdlib>
 #include <fstream>
+#include <iomanip>
 #include <iostream>
 #include <string>
 #include <vector>
diff --git a/contrib/libzip/utils/utils_zip.cc b/contrib/libzip/utils/utils_zip.cc
index a039409..d9d8eb6 100644
--- a/contrib/libzip/utils/utils_zip.cc
+++ b/contrib/libzip/utils/utils_zip.cc
@@ -63,9 +63,8 @@ absl::Status LibZip::OpenRemote() {
   SAPI_ASSIGN_OR_RETURN(void* zipsource, CreateSourceFromFd(rfd_));
   zipsource_ = std::make_unique<sapi::v::RemotePtr>(zipsource);
 
-  sapi::v::NullPtr null_ptr;
   absl::StatusOr<zip_t*> status_or_zip =
-      api_.zip_open_from_source(&(*zipsource_), flags_, &null_ptr);
+      api_.zip_open_from_source(&(*zipsource_), flags_, nullptr);
   if (!status_or_zip.ok() || *status_or_zip == nullptr) {
     api_.zip_source_free(&(*zipsource_)).IgnoreError();
     zipsource_ = nullptr;
@@ -220,10 +219,8 @@ absl::StatusOr<uint64_t> LibZip::AddFile(const std::string& filename,
 }
 
 absl::StatusOr<void*> LibZip::CreateSourceFromFd(sapi::v::Fd& rfd) {
-  sapi::v::NullPtr null_ptr;
-
-  SAPI_ASSIGN_OR_RETURN(void* zipsource, api_.zip_read_fd_to_source(
-                                             rfd.GetRemoteFd(), &null_ptr));
+  SAPI_ASSIGN_OR_RETURN(void* zipsource,
+                        api_.zip_read_fd_to_source(rfd.GetRemoteFd(), nullptr));
   if (zipsource == nullptr) {
     return absl::UnavailableError("Unable to create buffer");
   }
diff --git a/contrib/uriparser/utils/utils_uriparser.cc b/contrib/uriparser/utils/utils_uriparser.cc
index c2d44f6..9933a76 100644
--- a/contrib/uriparser/utils/utils_uriparser.cc
+++ b/contrib/uriparser/utils/utils_uriparser.cc
@@ -168,10 +168,9 @@ absl::StatusOr<std::string> UriParser::GetUri(sapi::v::Struct<UriUriA>* uri) {
   }
 
   sapi::v::Array<char> buf(size.GetValue() + 1);
-  sapi::v::NullPtr null_ptr;
 
   SAPI_ASSIGN_OR_RETURN(ret, api_.uriToStringA(buf.PtrAfter(), uri->PtrNone(),
-                                               buf.GetSize(), &null_ptr));
+                                               buf.GetSize(), nullptr));
   if (ret != 0) {
     return absl::UnavailableError("Unable to Recomposing URI");
   }
diff --git a/oss-internship-2020/curl/examples/example4.cc b/oss-internship-2020/curl/examples/example4.cc
index c994125..6f7ef35 100644
--- a/oss-internship-2020/curl/examples/example4.cc
+++ b/oss-internship-2020/curl/examples/example4.cc
@@ -92,9 +92,8 @@ absl::Status Example4() {
 
     if (still_running.GetValue()) {
       // Wait for an event or timeout
-      sapi::v::NullPtr null_ptr;
       SAPI_ASSIGN_OR_RETURN(
-          curl_code, api.curl_multi_poll_sapi(&multi_handle, &null_ptr, 0, 1000,
+          curl_code, api.curl_multi_poll_sapi(&multi_handle, nullptr, 0, 1000,
                                               numfds.PtrBoth()));
       if (curl_code != 0) {
         return absl::UnavailableError(absl::StrCat(
diff --git a/oss-internship-2020/curl/sandbox.h b/oss-internship-2020/curl/sandbox.h
index 49cf7ad..b39f28b 100644
--- a/oss-internship-2020/curl/sandbox.h
+++ b/oss-internship-2020/curl/sandbox.h
@@ -22,6 +22,7 @@
 #include <cstdlib>
 
 #include "curl_sapi.sapi.h"  // NOLINT(build/include)
+#include "sandboxed_api/sandbox2/util/allow_unrestricted_networking.h"
 #include "sandboxed_api/sandbox2/util/bpf_helper.h"
 
 namespace curl {
@@ -62,7 +63,7 @@ class CurlSapiSandbox : public curl::CurlSandbox {
         .AllowSyscall(__NR_socket)
         .AllowSyscall(__NR_sysinfo)
         .AddDirectory("/lib")
-        .AllowUnrestrictedNetworking()
+        .Allow(sandbox2::UnrestrictedNetworking())
         .BuildOrDie();
   }
 };
diff --git a/oss-internship-2020/gdal/raster_to_gtiff/gtiff_converter.cc b/oss-internship-2020/gdal/raster_to_gtiff/gtiff_converter.cc
index 7cbd34d..b858440 100644
--- a/oss-internship-2020/gdal/raster_to_gtiff/gtiff_converter.cc
+++ b/oss-internship-2020/gdal/raster_to_gtiff/gtiff_converter.cc
@@ -51,7 +51,6 @@ absl::Status RasterToGTiffProcessor::Main() {
   sapi::v::RemotePtr driver_ptr(driver.value());
 
   sapi::v::ConstCStr out_file_full_path_ptr(out_file_full_path_.c_str());
-  sapi::v::NullPtr create_options;
 
   GDALDataType type = data_.bands.size() > 0
                           ? static_cast<GDALDataType>(data_.bands[0].data_type)
@@ -61,7 +60,7 @@ absl::Status RasterToGTiffProcessor::Main() {
       absl::StatusOr<GDALDatasetH> dataset,
       api.GDALCreate(&driver_ptr, out_file_full_path_ptr.PtrBefore(),
                      data_.width, data_.height, data_.bands.size(), type,
-                     &create_options));
+                     nullptr));
 
   TRANSACTION_FAIL_IF_NOT(dataset.value(), "Error creating dataset");
   sapi::v::RemotePtr dataset_ptr(dataset.value());
diff --git a/oss-internship-2020/libpng/examples/example1.cc b/oss-internship-2020/libpng/examples/example1.cc
index d9991f2..e3ad71c 100644
--- a/oss-internship-2020/libpng/examples/example1.cc
+++ b/oss-internship-2020/libpng/examples/example1.cc
@@ -44,10 +44,9 @@ absl::Status LibPNGMain(const std::string& infile, const std::string& outfile) {
 
   sapi::v::Array<uint8_t> buffer(PNG_IMAGE_SIZE(*image.mutable_data()));
 
-  sapi::v::NullPtr null = sapi::v::NullPtr();
-  SAPI_ASSIGN_OR_RETURN(result,
-                        api.png_image_finish_read(image.PtrBoth(), &null,
-                                                  buffer.PtrBoth(), 0, &null));
+  SAPI_ASSIGN_OR_RETURN(
+      result, api.png_image_finish_read(image.PtrBoth(), nullptr,
+                                        buffer.PtrBoth(), 0, nullptr));
   if (!result) {
     return absl::InternalError(
         absl::StrCat("finish read error: ", image.mutable_data()->message));
@@ -55,7 +54,7 @@ absl::Status LibPNGMain(const std::string& infile, const std::string& outfile) {
 
   SAPI_ASSIGN_OR_RETURN(result, api.png_image_write_to_file(
                                     image.PtrBoth(), outfile_var.PtrBefore(), 0,
-                                    buffer.PtrBoth(), 0, &null));
+                                    buffer.PtrBoth(), 0, nullptr));
   if (!result) {
     return absl::InternalError(
         absl::StrCat("write error: ", image.mutable_data()->message));
diff --git a/oss-internship-2020/libpng/examples/example2.cc b/oss-internship-2020/libpng/examples/example2.cc
index 1a5a986..8612fe2 100644
--- a/oss-internship-2020/libpng/examples/example2.cc
+++ b/oss-internship-2020/libpng/examples/example2.cc
@@ -63,10 +63,9 @@ absl::StatusOr<Data> ReadPng(LibPNGApi& api, absl::string_view infile) {
 
   absl::StatusOr<png_structp> status_or_png_structp;
   sapi::v::ConstCStr ver_string_var(PNG_LIBPNG_VER_STRING);
-  sapi::v::NullPtr null = sapi::v::NullPtr();
   SAPI_ASSIGN_OR_RETURN(
       status_or_png_structp,
-      api.png_create_read_struct_wrapper(ver_string_var.PtrBefore(), &null));
+      api.png_create_read_struct_wrapper(ver_string_var.PtrBefore(), nullptr));
 
   sapi::v::RemotePtr struct_ptr(status_or_png_structp.value());
   if (!struct_ptr.GetValue()) {
@@ -141,10 +140,9 @@ absl::Status WritePng(LibPNGApi& api, absl::string_view outfile, Data& data) {
 
   absl::StatusOr<png_structp> status_or_png_structp;
   sapi::v::ConstCStr ver_string_var(PNG_LIBPNG_VER_STRING);
-  sapi::v::NullPtr null = sapi::v::NullPtr();
   SAPI_ASSIGN_OR_RETURN(
       status_or_png_structp,
-      api.png_create_write_struct_wrapper(ver_string_var.PtrBefore(), &null));
+      api.png_create_write_struct_wrapper(ver_string_var.PtrBefore(), nullptr));
 
   sapi::v::RemotePtr struct_ptr(status_or_png_structp.value());
   if (!struct_ptr.GetValue()) {
@@ -176,7 +174,7 @@ absl::Status WritePng(LibPNGApi& api, absl::string_view outfile, Data& data) {
       &struct_ptr, data.row_pointers->PtrBefore(), data.height, data.rowbytes));
 
   SAPI_RETURN_IF_ERROR(api.png_setjmp(&struct_ptr));
-  SAPI_RETURN_IF_ERROR(api.png_write_end(&struct_ptr, &null));
+  SAPI_RETURN_IF_ERROR(api.png_write_end(&struct_ptr, nullptr));
 
   SAPI_RETURN_IF_ERROR(api.png_fclose(&file));
   return absl::OkStatus();
diff --git a/oss-internship-2020/libpng/tests/basic_test.cc b/oss-internship-2020/libpng/tests/basic_test.cc
index 176479b..24d546a 100644
--- a/oss-internship-2020/libpng/tests/basic_test.cc
+++ b/oss-internship-2020/libpng/tests/basic_test.cc
@@ -64,9 +64,8 @@ TEST(SandboxTest, ReadWrite) {
       << "image version changed";
 
   sapi::v::Array<uint8_t> buffer(PNG_IMAGE_SIZE(*image.mutable_data()));
-  sapi::v::NullPtr null = sapi::v::NullPtr();
-  status_or_int = api.png_image_finish_read(image.PtrBoth(), &null,
-                                            buffer.PtrBoth(), 0, &null);
+  status_or_int = api.png_image_finish_read(image.PtrBoth(), nullptr,
+                                            buffer.PtrBoth(), 0, nullptr);
   ASSERT_THAT(status_or_int, IsOk())
       << "fatal error when invoking png_image_finish_read";
   ASSERT_THAT(status_or_int.value(), IsTrue())
@@ -76,8 +75,9 @@ TEST(SandboxTest, ReadWrite) {
   ASSERT_THAT(image.mutable_data()->format, Eq(PNG_FORMAT_RGBA))
       << "image format changed";
 
-  status_or_int = api.png_image_write_to_file(
-      image.PtrBoth(), outfile_var.PtrBefore(), 0, buffer.PtrBoth(), 0, &null);
+  status_or_int =
+      api.png_image_write_to_file(image.PtrBoth(), outfile_var.PtrBefore(), 0,
+                                  buffer.PtrBoth(), 0, nullptr);
   ASSERT_THAT(status_or_int, IsOk())
       << "fatal error when invoking png_image_write_to_file";
   ASSERT_THAT(status_or_int.value(), IsTrue())
diff --git a/oss-internship-2020/libpng/tests/extended_test.cc b/oss-internship-2020/libpng/tests/extended_test.cc
index 4eb5de8..2bd0225 100644
--- a/oss-internship-2020/libpng/tests/extended_test.cc
+++ b/oss-internship-2020/libpng/tests/extended_test.cc
@@ -67,9 +67,8 @@ void ReadPng(LibPNGApi& api, absl::string_view infile, Data& data) {
   ASSERT_THAT(status_or_int.value(), Eq(0)) << infile << " is not a PNG file";
 
   sapi::v::ConstCStr ver_string_var(PNG_LIBPNG_VER_STRING);
-  sapi::v::NullPtr null = sapi::v::NullPtr();
   absl::StatusOr<png_structp> status_or_png_structp =
-      api.png_create_read_struct_wrapper(ver_string_var.PtrBefore(), &null);
+      api.png_create_read_struct_wrapper(ver_string_var.PtrBefore(), nullptr);
 
   ASSERT_THAT(status_or_png_structp, IsOk());
   sapi::v::RemotePtr struct_ptr(status_or_png_structp.value());
@@ -149,9 +148,8 @@ void WritePng(LibPNGApi& api, absl::string_view outfile, Data& data) {
   ASSERT_THAT(file.GetValue(), NotNull()) << "Could not open " << outfile;
 
   sapi::v::ConstCStr ver_string_var(PNG_LIBPNG_VER_STRING);
-  sapi::v::NullPtr null = sapi::v::NullPtr();
   absl::StatusOr<png_structp> status_or_png_structp =
-      api.png_create_write_struct_wrapper(ver_string_var.PtrBefore(), &null);
+      api.png_create_write_struct_wrapper(ver_string_var.PtrBefore(), nullptr);
   ASSERT_THAT(status_or_png_structp, IsOk());
 
   sapi::v::RemotePtr struct_ptr(status_or_png_structp.value());
@@ -185,7 +183,7 @@ void WritePng(LibPNGApi& api, absl::string_view outfile, Data& data) {
       IsOk());
 
   ASSERT_THAT(api.png_setjmp(&struct_ptr), IsOk());
-  ASSERT_THAT(api.png_write_end(&struct_ptr, &null), IsOk());
+  ASSERT_THAT(api.png_write_end(&struct_ptr, nullptr), IsOk());
 
   ASSERT_THAT(api.png_fclose(&file), IsOk());
 }
diff --git a/oss-internship-2020/libuv/examples/idle-basic.cc b/oss-internship-2020/libuv/examples/idle-basic.cc
index f4ed3ad..8b758cd 100644
--- a/oss-internship-2020/libuv/examples/idle-basic.cc
+++ b/oss-internship-2020/libuv/examples/idle-basic.cc
@@ -86,8 +86,7 @@ absl::Status IdleBasic() {
   }
 
   // Close idler
-  sapi::v::NullPtr null_ptr;
-  SAPI_RETURN_IF_ERROR(api.sapi_uv_close(&idler, &null_ptr));
+  SAPI_RETURN_IF_ERROR(api.sapi_uv_close(&idler, nullptr));
 
   // Close loop
   SAPI_ASSIGN_OR_RETURN(return_code, api.sapi_uv_loop_close(&loop));
diff --git a/oss-internship-2020/libuv/tests/CMakeLists.txt b/oss-internship-2020/libuv/tests/CMakeLists.txt
index 456efdd..7de6c90 100644
--- a/oss-internship-2020/libuv/tests/CMakeLists.txt
+++ b/oss-internship-2020/libuv/tests/CMakeLists.txt
@@ -29,6 +29,7 @@ target_link_libraries(tests
   uv_a
   uv_sapi
   sapi::sapi
+  sandbox2::allowlists_namespaces
 )
 
 gtest_discover_tests(tests)
diff --git a/oss-internship-2020/libuv/tests/test_os.cc b/oss-internship-2020/libuv/tests/test_os.cc
index a96a5ce..732ec3d 100644
--- a/oss-internship-2020/libuv/tests/test_os.cc
+++ b/oss-internship-2020/libuv/tests/test_os.cc
@@ -36,7 +36,7 @@ class UVTestOSSapiSandbox : public uv::UVSandbox {
         .AllowOpen()
         .AllowWrite()
         .AllowSyscalls({__NR_connect, __NR_socket})
-        .DisableNamespaces()
+        .DisableNamespaces(NamespacesToken())
         .BuildOrDie();
   }
 };
diff --git a/sandboxed_api/BUILD.bazel b/sandboxed_api/BUILD
similarity index 64%
rename from sandboxed_api/BUILD.bazel
rename to sandboxed_api/BUILD
index d255a21..7a76c66 100644
--- a/sandboxed_api/BUILD.bazel
+++ b/sandboxed_api/BUILD
@@ -12,10 +12,9 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
-package(default_visibility = ["//sandboxed_api:__subpackages__"])
+package(default_visibility = ["@com_google_sandboxed_api//sandboxed_api:__subpackages__"])
 
 licenses(["notice"])
 
@@ -31,12 +30,6 @@ cc_library(
     ],
 )
 
-sapi_proto_library(
-    name = "proto_arg",
-    srcs = ["proto_arg.proto"],
-    visibility = ["//visibility:public"],
-)
-
 cc_library(
     name = "embed_file",
     srcs = [
@@ -47,13 +40,25 @@ cc_library(
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
-        "//sandboxed_api/sandbox2:util",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/synchronization",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+    ],
+)
+
+cc_test(
+    name = "embed_file_test",
+    srcs = ["embed_file_test.cc"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":embed_file",
+        "@com_google_absl//absl/memory",
+        "@com_google_absl//absl/strings",
+        "@com_google_googletest//:gtest_main",
     ],
 )
 
@@ -74,22 +79,14 @@ cc_library(
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
+        ":call",
         ":config",
         ":embed_file",
+        ":var_type",
         ":vars",
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:runfiles",
-        "//sandboxed_api/util:status",
-        "@com_google_absl//absl/base",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/base:dynamic_annotations",
-        "@com_google_absl//absl/base:log_severity",
+        "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
@@ -100,6 +97,15 @@ cc_library(
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/synchronization",
         "@com_google_absl//absl/time",
+        "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -128,14 +134,12 @@ cc_library(
 cc_library(
     name = "vars",
     srcs = [
-        "proto_helper.cc",
         "rpcchannel.cc",
         "var_abstract.cc",
         "var_int.cc",
         "var_lenval.cc",
     ],
     hdrs = [
-        "proto_helper.h",
         "rpcchannel.h",
         "var_abstract.h",
         "var_array.h",
@@ -153,11 +157,7 @@ cc_library(
     deps = [
         ":call",
         ":lenval_core",
-        ":proto_arg_cc_proto",
         ":var_type",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
@@ -166,7 +166,13 @@ cc_library(
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/synchronization",
+        "@com_google_absl//absl/types:span",
         "@com_google_absl//absl/utility",
+        "@com_google_protobuf//:protobuf_lite",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/util:proto_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -179,13 +185,7 @@ cc_library(
     deps = [
         ":call",
         ":lenval_core",
-        ":proto_arg_cc_proto",
         ":var_type",
-        ":vars",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2:forkingclient",
-        "//sandboxed_api/sandbox2:logsink",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/base:dynamic_annotations",
         "@com_google_absl//absl/flags:parse",
@@ -196,6 +196,11 @@ cc_library(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_protobuf//:protobuf",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:forkingclient",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:logsink",
+        "@com_google_sandboxed_api//sandboxed_api/util:proto_arg_cc_proto",
+        "@com_google_sandboxed_api//sandboxed_api/util:proto_helper",
         "@org_sourceware_libffi//:libffi",
     ],
 )
@@ -208,15 +213,22 @@ cc_test(
     deps = [
         ":sapi",
         ":testing",
-        "//sandboxed_api/examples/stringop:stringop-sapi",
-        "//sandboxed_api/examples/stringop:stringop_params_cc_proto",
-        "//sandboxed_api/examples/sum:sum-sapi",
-        "//sandboxed_api/util:status_matchers",
+        ":vars",
+        "@com_google_absl//absl/log",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/time",
+        "@com_google_absl//absl/types:span",
         "@com_google_benchmark//:benchmark",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/examples/stringop:stringop-sapi",
+        "@com_google_sandboxed_api//sandboxed_api/examples/stringop:stringop_params_cc_proto",
+        "@com_google_sandboxed_api//sandboxed_api/examples/sum:sum-sapi",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:result",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -230,9 +242,9 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":config",
-        "//sandboxed_api/sandbox2:policybuilder",
-        "//sandboxed_api/sandbox2:testonly_allow_all_syscalls",
-        "//sandboxed_api/util:file_base",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:policybuilder",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:testonly_all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
     ],
 )
diff --git a/sandboxed_api/CMakeLists.txt b/sandboxed_api/CMakeLists.txt
index 11eba3c..1ebb55d 100644
--- a/sandboxed_api/CMakeLists.txt
+++ b/sandboxed_api/CMakeLists.txt
@@ -31,20 +31,6 @@ target_link_libraries(sapi_config
   PUBLIC absl::config
 )
 
-# sandboxed_api:proto_arg
-sapi_protobuf_generate_cpp(_sapi_proto_arg_pb_cc _sapi_proto_arg_pb_h
-  proto_arg.proto
-)
-add_library(sapi_proto_arg_proto ${SAPI_LIB_TYPE}
-  ${_sapi_proto_arg_pb_cc}
-  ${_sapi_proto_arg_pb_h}
-)
-add_library(sapi::proto_arg_proto ALIAS sapi_proto_arg_proto)
-target_link_libraries(sapi_proto_arg_proto PRIVATE
-  protobuf::libprotobuf
-  sapi::base
-)
-
 # sandboxed_api:embed_file
 add_library(sapi_embed_file ${SAPI_LIB_TYPE}
   embed_file.cc
@@ -56,10 +42,10 @@ target_link_libraries(sapi_embed_file
   PRIVATE absl::strings
           sandbox2::util
           sapi::base
-          sapi::fileops
           sapi::raw_logging
   PUBLIC absl::flat_hash_map
          absl::synchronization
+         sapi::fileops
 )
 
 # sandboxed_api:sapi
@@ -72,22 +58,24 @@ add_library(sapi_sapi ${SAPI_LIB_TYPE}
 add_library(sapi::sapi ALIAS sapi_sapi)
 target_link_libraries(sapi_sapi
   PRIVATE absl::base
+          absl::cleanup
           absl::dynamic_annotations
           absl::flat_hash_map
           absl::log
           absl::log_globals
+          absl::span
           absl::status
           absl::statusor
           absl::str_format
           absl::strings
           absl::synchronization
-          sandbox2::bpf_helper
+          sapi::call
           sapi::file_base
-          sapi::fileops
           sapi::runfiles
           sapi::strerror
           sandbox2::util
           sapi::embed_file
+          sapi::var_type
           sapi::vars
   PUBLIC absl::check
          absl::core_headers
@@ -128,8 +116,6 @@ target_link_libraries(sapi_var_type PRIVATE
 
 # sandboxed_api:vars
 add_library(sapi_vars ${SAPI_LIB_TYPE}
-  proto_helper.cc
-  proto_helper.h
   rpcchannel.cc
   rpcchannel.h
   var_abstract.cc
@@ -149,6 +135,7 @@ add_library(sapi_vars ${SAPI_LIB_TYPE}
 add_library(sapi::vars ALIAS sapi_vars)
 target_link_libraries(sapi_vars
   PRIVATE absl::core_headers
+          absl::span
           absl::status
           absl::statusor
           absl::str_format
@@ -156,13 +143,14 @@ target_link_libraries(sapi_vars
           absl::synchronization
           absl::utility
           sandbox2::comms
+          sandbox2::util
           sapi::base
           sapi::call
           sapi::lenval_core
-          sapi::proto_arg_proto
           sapi::status
           sapi::var_type
   PUBLIC absl::log
+         sapi::proto_helper
 )
 
 # sandboxed_api:client
@@ -188,11 +176,22 @@ target_link_libraries(sapi_client
           sapi::call
           sapi::lenval_core
           sapi::proto_arg_proto
-          sapi::vars
+          sapi::proto_helper
           ${CMAKE_DL_LIBS}
 )
 
 if(BUILD_TESTING AND SAPI_BUILD_TESTING AND NOT CMAKE_CROSSCOMPILING)
+  # sandboxed_api:embed_file_test
+  add_executable(embed_file_test
+    embed_file_test.cc
+  )
+  target_link_libraries(embed_file_test PRIVATE
+    absl::memory
+    absl::strings
+    sapi::embed_file
+    sapi::test_main
+  )
+
   # sandboxed_api:testing
   add_library(sapi_testing ${SAPI_LIB_TYPE}
     testing.cc
@@ -204,7 +203,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING AND NOT CMAKE_CROSSCOMPILING)
            sapi::file_base
            sapi::base
    PUBLIC sapi::config
-          sandbox2::allow_all_syscalls
+          sandbox2::allowlists_all_syscalls
           sandbox2::policybuilder
   )
 
@@ -226,6 +225,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING AND NOT CMAKE_CROSSCOMPILING)
     sapi::sum_sapi
     sapi::test_main
     sapi::testing
+    sapi::thread
   )
   gtest_discover_tests_xcompile(sapi_test)
 endif()
diff --git a/sandboxed_api/bazel/build_defs.bzl b/sandboxed_api/bazel/build_defs.bzl
index c0ac65c..bda79f9 100644
--- a/sandboxed_api/bazel/build_defs.bzl
+++ b/sandboxed_api/bazel/build_defs.bzl
@@ -18,6 +18,7 @@ _SAPI_LINUX_COPTS = [
     "-Wno-deprecated-declarations",
     "-Wno-narrowing",
     "-Wno-sign-compare",
+    "-Wunused-result",
 ]
 
 def sapi_platform_copts(copts = []):
@@ -28,6 +29,4 @@ def sapi_platform_copts(copts = []):
     """
 
     # Linux only for now.
-    return select({
-        "//conditions:default": _SAPI_LINUX_COPTS,
-    }) + copts
+    return _SAPI_LINUX_COPTS + copts
diff --git a/sandboxed_api/bazel/external/enum34.BUILD b/sandboxed_api/bazel/external/enum34.BUILD
deleted file mode 100644
index b5e3a8c..0000000
--- a/sandboxed_api/bazel/external/enum34.BUILD
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright 2019 Google LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   enum34 provides a backport of the enum module for Python 2.
-
-licenses(["notice"])  # MIT
-
-exports_files(["LICENSE"])
-
-py_library(
-    name = "enum",
-    srcs = ["enum34-1.1.6/enum/__init__.py"],
-    srcs_version = "PY2AND3",
-    visibility = ["//visibility:public"],
-)
diff --git a/sandboxed_api/bazel/external/libunwind.BUILD b/sandboxed_api/bazel/external/libunwind.BUILD
index d6bbe80..f66134e 100644
--- a/sandboxed_api/bazel/external/libunwind.BUILD
+++ b/sandboxed_api/bazel/external/libunwind.BUILD
@@ -130,7 +130,11 @@ cc_library(
     hdrs = [
         "include/config.h",
         "include/libunwind.h",
+        "include/libunwind-aarch64.h",
+        "include/libunwind-common.h",
+        "include/libunwind-dynamic.h",
         "include/libunwind-ptrace.h",
+        "include/libunwind-x86_64.h",
     ],
     copts = LIBUNWIND_COPTS + [
         # Assume our inferior doesn't have frame pointers, regardless of
@@ -139,6 +143,7 @@ cc_library(
         "-fno-common",
         "-Wno-cpp",  # Warning in src/ptrace/_UPT_get_dyn_info_list_addr.c
     ],
+    strip_include_prefix = "include",
     visibility = ["//visibility:public"],
     deps = [
         ":included_sources",
diff --git a/sandboxed_api/bazel/external/six.BUILD b/sandboxed_api/bazel/external/six.BUILD
deleted file mode 100644
index d46997a..0000000
--- a/sandboxed_api/bazel/external/six.BUILD
+++ /dev/null
@@ -1,23 +0,0 @@
-# Copyright 2019 Google LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Six provides simple utilities for wrapping over differences between Python 2
-# and Python 3.
-
-py_library(
-    name = "six",
-    srcs = ["six.py"],
-    srcs_version = "PY2AND3",
-    visibility = ["//visibility:public"],
-)
diff --git a/sandboxed_api/bazel/llvm_config.bzl b/sandboxed_api/bazel/llvm_config.bzl
index 025c532..54090c0 100644
--- a/sandboxed_api/bazel/llvm_config.bzl
+++ b/sandboxed_api/bazel/llvm_config.bzl
@@ -35,16 +35,17 @@ cc_library(
     includes = ["llvm-project-include"],
     linkopts = [
         "-lncurses",
-        "-lz",
-        "-L%{llvm_lib_dir}",
+        %{llvm_system_libs}
+        %{llvm_lib_dir}
         "-Wl,--start-group",
         %{llvm_libs}
         "-Wl,--end-group",
     ],
     visibility = ["@llvm-project//clang:__pkg__"],
 )
-# Fake support library
+# Fake llvm libraries
 cc_library(name = "Support", deps = ["@llvm-project//llvm:llvm"])
+cc_library(name = "config", deps = ["@llvm-project//llvm:llvm"])
 """
 
 SYSTEM_CLANG_BAZEL = """package(default_visibility = ["//visibility:public"])
@@ -55,56 +56,67 @@ cc_library(name = "driver", deps = ["@llvm-project//llvm:llvm"])
 cc_library(name = "format", deps = ["@llvm-project//llvm:llvm"])
 cc_library(name = "frontend", deps = ["@llvm-project//llvm:llvm"])
 cc_library(name = "lex", deps = ["@llvm-project//llvm:llvm"])
+cc_library(name = "serialization", deps = ["@llvm-project//llvm:llvm"])
 cc_library(name = "tooling", deps = ["@llvm-project//llvm:llvm"])
+cc_library(name = "tooling_core", deps = ["@llvm-project//llvm:llvm"])
 """
 
 def _use_system_llvm(ctx):
-    found = False
-
     # Look for LLVM in known places
-    llvm_dirs = ctx.execute(
-        ["ls", "-1f"] +
-        [
-            "/usr/lib/llvm-{}/include/llvm/Support/InitLLVM.h".format(ver)
-            for ver in [16, 15, 14, 13, 12, 11]  # Debian
-        ] + [
-            "/usr/include/llvm/Support/InitLLVM.h",  # Fedora and others
-        ],
+    llvm_config_tool = ctx.execute(
+        ["which"] +  # Prints all arguments it finds in the system PATH
+        ["llvm-config-{}".format(ver) for ver in range(20, 10, -1)] +
+        ["llvm-config"],
     ).stdout.splitlines()
-    if llvm_dirs:
-        llvm_dir = llvm_dirs[0].split("/include/llvm/")[0]
-        for suffix in ["llvm", "llvm-c", "clang", "clang-c"]:
-            ctx.symlink(
-                llvm_dir + "/include/" + suffix,
-                "llvm/llvm-project-include/" + suffix,
-            )
-
-        # Try to find the lib directory
-        lib_dirs = ctx.execute(
-            ["ls", "-d1f"] +
-            [llvm_dir + "/lib64", llvm_dir + "/lib"],
-        ).stdout.splitlines()
-        if lib_dirs:
-            found = True
-
-    if found:
-        # Create stub targets in sub-packages
-        lib_dir = lib_dirs[0]  # buildifier: disable=uninitialized
-        archives = ctx.execute(
-            ["find", ".", "-maxdepth", "1"] +
-            ["(", "-name", "libLLVM*.a", "-o", "-name", "libclang*.a", ")"],
-            working_directory = lib_dir,
-        ).stdout.splitlines()
-        lib_strs = sorted(["\"-l{}\",".format(a[5:-2]) for a in archives])
-
-        ctx.file(
-            "llvm/BUILD.bazel",
-            SYSTEM_LLVM_BAZEL_TEMPLATE
-                .replace("%{llvm_lib_dir}", lib_dir)
-                .replace("%{llvm_libs}", "\n".join(lib_strs)),
+    if not llvm_config_tool:
+        return False
+
+    llvm_config = ctx.execute([
+        llvm_config_tool[0],
+        "--link-static",
+        "--includedir",  # Output line 0
+        "--libdir",  # Output line 1
+        "--libs",  # Output line 2
+        "--system-libs",  # Output line 3
+        "engine",
+        "option",
+    ]).stdout.splitlines()
+    if not llvm_config:
+        return False
+
+    include_dir = llvm_config[0]
+    for suffix in ["llvm", "llvm-c", "clang", "clang-c"]:
+        ctx.symlink(
+            include_dir + "/" + suffix,
+            "llvm/llvm-project-include/" + suffix,
         )
-        ctx.file("clang/BUILD.bazel", SYSTEM_CLANG_BAZEL)
-    return found
+
+    system_libs = llvm_config[3].split(" ")
+    lib_dir = llvm_config[1].split(" ")[0]
+
+    # Sadly there's no easy way to get to the Clang library archives
+    archives = ctx.execute(
+        ["find", ".", "-maxdepth", "1"] +
+        ["(", "-name", "libLLVM*.a", "-o", "-name", "libclang*.a", ")"],
+        working_directory = lib_dir,
+    ).stdout.splitlines()
+    lib_strs = sorted(["\"-l{}\",".format(a[5:-2]) for a in archives])
+
+    ctx.file(
+        "llvm/BUILD.bazel",
+        SYSTEM_LLVM_BAZEL_TEMPLATE.replace(
+            "%{llvm_system_libs}",
+            "\n".join(["\"{}\",".format(s) for s in system_libs]),
+        ).replace(
+            "%{llvm_lib_dir}",
+            "\"-L{}\",".format(lib_dir),
+        ).replace(
+            "%{llvm_libs}",
+            "\n".join(lib_strs),
+        ),
+    )
+    ctx.file("clang/BUILD.bazel", SYSTEM_CLANG_BAZEL)
+    return True
 
 def _overlay_directories(ctx, src_path, target_path):
     bazel_path = src_path.get_child("utils").get_child("bazel")
diff --git a/sandboxed_api/bazel/proto.bzl b/sandboxed_api/bazel/proto.bzl
index e67e95e..6decf37 100644
--- a/sandboxed_api/bazel/proto.bzl
+++ b/sandboxed_api/bazel/proto.bzl
@@ -14,7 +14,7 @@
 
 """Generates proto targets in various languages."""
 
-load("@rules_proto//proto:defs.bzl", "proto_library")
+load("@com_google_protobuf//bazel:proto_library.bzl", "proto_library")
 
 def _cc_proto_library_name_from_proto_name(name):
     """Converts proto name to cc_proto_library name.
diff --git a/sandboxed_api/bazel/sapi.bzl b/sandboxed_api/bazel/sapi.bzl
index 386c32b..6c54127 100644
--- a/sandboxed_api/bazel/sapi.bzl
+++ b/sandboxed_api/bazel/sapi.bzl
@@ -14,10 +14,10 @@
 
 """Starlark rules for projects using Sandboxed API."""
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:embed_data.bzl", "sapi_cc_embed_data")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:embed_data.bzl", "sapi_cc_embed_data")
 load(
-    "//sandboxed_api/bazel:proto.bzl",
+    "@com_google_sandboxed_api//sandboxed_api/bazel:proto.bzl",
     _sapi_proto_library = "sapi_proto_library",
 )
 load("@bazel_tools//tools/cpp:toolchain_utils.bzl", "find_cpp_toolchain", "use_cpp_toolchain")
@@ -70,34 +70,6 @@ def sort_deps(deps):
     other_deps = [x for x in deps if not x.startswith(":")]
     return sorted(colon_deps) + sorted(other_deps)
 
-def cc_library_virtual_includes(target):
-    """Checks a target for virtual includes.
-
-    Those can be created by the deprecated `cc_inc_library` rule, or by using
-    a combination of `cc_library()`s `includes`, `include_prefix` and
-    `strip_include_prefix` attributes.
-
-    Args:
-      target: The Target to analyze
-    Returns:
-      A depset with include paths generated by cc_inc_library targets.
-    """
-    cc_ctx = target[CcInfo].compilation_context
-
-    includes = []
-    for f in cc_ctx.headers.to_list():
-        p = f.path
-        if not p.startswith("blaze-out") and not p.startswith("bazel-out"):
-            continue
-        for path_marker in ["/_virtual_includes/", "/_/"]:
-            i = p.find(path_marker)
-            if i == -1:
-                continue
-            includes.append(p[:i] + path_marker +
-                            p[i + len(path_marker):].split("/", 1)[0])
-
-    return depset(includes)
-
 def _sapi_interface_impl(ctx):
     cpp_toolchain = find_cpp_toolchain(ctx)
     generator = select_generator(ctx)
@@ -134,10 +106,6 @@ def _sapi_interface_impl(ctx):
     # Append all headers as dependencies
     input_files += cc_ctx.headers.to_list()
 
-    # Gather direct include paths as well as virtual ones
-    quote_includes = (cc_ctx.quote_includes.to_list() +
-                      cc_library_virtual_includes(ctx.attr.lib).to_list())
-
     if use_clang_generator:
         input_files += cpp_toolchain.all_files.to_list()
 
@@ -148,12 +116,14 @@ def _sapi_interface_impl(ctx):
         extra_flags.append("--extra-arg=-Wno-everything")
         extra_flags += ["--extra-arg=-D{}".format(d) for d in cc_ctx.defines.to_list()]
         extra_flags += ["--extra-arg=-isystem{}".format(i) for i in cc_ctx.system_includes.to_list()]
-        extra_flags += ["--extra-arg=-iquote{}".format(i) for i in quote_includes]
+        extra_flags += ["--extra-arg=-iquote{}".format(i) for i in cc_ctx.quote_includes.to_list()]
         extra_flags += ["--extra-arg=-isystem{}".format(d) for d in cpp_toolchain.built_in_include_directories]
+        extra_flags += ["--extra-arg=-I{}".format(d) for d in cc_ctx.includes.to_list()]
     else:
         append_all(extra_flags, "-D", cc_ctx.defines.to_list())
         append_all(extra_flags, "-isystem", cc_ctx.system_includes.to_list())
-        append_all(extra_flags, "-iquote", quote_includes)
+        append_all(extra_flags, "-iquote", cc_ctx.quote_includes.to_list())
+        append_all(extra_flags, "-I", cc_ctx.includes.to_list())
 
     if ctx.attr.input_files:
         for f in ctx.files.input_files:
@@ -218,17 +188,13 @@ sapi_interface = rule(
             values = [1, 2],
         ),
         "_generator_v1": make_exec_label(
-            "//sandboxed_api/tools/generator2:sapi_generator",
+            "//sandboxed_api/tools/python_generator:sapi_generator",
         ),
         "_generator_v2": make_exec_label(
             # TODO(cblichmann): Add prebuilt version of Clang based generator
-            "//sandboxed_api/tools/clang_generator:generator_tool",
-        ),
-        "_cc_toolchain": attr.label(
-            default = Label("@bazel_tools//tools/cpp:current_cc_toolchain"),
+            "@com_google_sandboxed_api//sandboxed_api/tools/clang_generator:generator_tool",
         ),
     },
-    output_to_genfiles = True,
     toolchains = use_cpp_toolchain(),
 )
 
@@ -255,7 +221,8 @@ def sapi_library(
         generator_version = 1,
         visibility = None,
         compatible_with = None,
-        default_copts = []):
+        default_copts = [],
+        exec_properties = {}):
     """Provides the implementation of a Sandboxed API library.
 
     Args:
@@ -287,7 +254,7 @@ def sapi_library(
       deps: Extra dependencies to add to the SAPI library
       tags: Extra tags to associate with the target
       generator_version: Which version the the interface generator to use
-        (experimental). Version 1 uses the Python/libclang based `generator2`,
+        (experimental). Version 1 uses the Python/libclang based `python_generator`,
         version 2 uses the newer C++ implementation that uses the full clang
         compiler front-end for parsing. Both emit equivalent Sandboxed APIs.
       visibility: Target visibility
@@ -295,6 +262,7 @@ def sapi_library(
         in addition to default-supported environments.
       default_copts: List of package level default copts, an additional
         attribute since copts already has default value.
+      exec_properties: Dict of executable properties to be passed to the generated binary targets.
     """
 
     common = {
@@ -323,7 +291,7 @@ def sapi_library(
     else:
         lib_hdrs += [generated_header]
 
-    default_deps = ["//sandboxed_api/sandbox2"]
+    default_deps = ["@com_google_sandboxed_api//sandboxed_api/sandbox2"]
 
     # Library that contains generated interface and sandboxed binary as a data
     # dependency. Add this as a dependency instead of original library.
@@ -339,9 +307,9 @@ def sapi_library(
                 "@com_google_absl//absl/base:core_headers",
                 "@com_google_absl//absl/status",
                 "@com_google_absl//absl/status:statusor",
-                "//sandboxed_api:sapi",
-                "//sandboxed_api/util:status",
-                "//sandboxed_api:vars",
+                "@com_google_sandboxed_api//sandboxed_api:sapi",
+                "@com_google_sandboxed_api//sandboxed_api/util:status",
+                "@com_google_sandboxed_api//sandboxed_api:vars",
             ] + deps +
             ([":" + name + "_embed"] if embed else []) +
             (default_deps if add_default_deps else []),
@@ -359,7 +327,7 @@ def sapi_library(
         malloc = malloc,
         deps = [
             ":" + name + ".lib",
-            "//sandboxed_api:client",
+            "@com_google_sandboxed_api//sandboxed_api:client",
         ],
         copts = default_copts,
         **common
diff --git a/sandboxed_api/bazel/sapi_deps.bzl b/sandboxed_api/bazel/sapi_deps.bzl
index 66b46a5..9d3f5ec 100644
--- a/sandboxed_api/bazel/sapi_deps.bzl
+++ b/sandboxed_api/bazel/sapi_deps.bzl
@@ -19,17 +19,71 @@ load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
 load("//sandboxed_api/bazel:llvm_config.bzl", "llvm_configure")
 load("//sandboxed_api/bazel:repositories.bzl", "autotools_repository")
 
+def sapi_non_module_deps():
+    """Loads non-modularized dependencies."""
+
+    # libcap
+    http_archive(
+        name = "org_kernel_libcap",
+        build_file = "@com_google_sandboxed_api//sandboxed_api:bazel/external/libcap.BUILD",
+        sha256 = "260b549c154b07c3cdc16b9ccc93c04633c39f4fb6a4a3b8d1fa5b8a9c3f5fe8",  # 2019-04-16
+        strip_prefix = "libcap-2.27",
+        urls = ["https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.27.tar.gz"],
+    )
+
+    # libffi
+    autotools_repository(
+        name = "org_sourceware_libffi",
+        build_file = "@com_google_sandboxed_api//sandboxed_api:bazel/external/libffi.BUILD",
+        sha256 = "653ffdfc67fbb865f39c7e5df2a071c0beb17206ebfb0a9ecb18a18f63f6b263",  # 2019-11-02
+        strip_prefix = "libffi-3.3-rc2",
+        urls = ["https://github.com/libffi/libffi/releases/download/v3.3-rc2/libffi-3.3-rc2.tar.gz"],
+    )
+
+    # libunwind
+    autotools_repository(
+        name = "org_gnu_libunwind",
+        build_file = "@com_google_sandboxed_api//sandboxed_api:bazel/external/libunwind.BUILD",
+        configure_args = [
+            "--disable-documentation",
+            "--disable-minidebuginfo",
+            "--disable-shared",
+            "--enable-ptrace",
+        ],
+        sha256 = "4a6aec666991fb45d0889c44aede8ad6eb108071c3554fcdff671f9c94794976",  # 2021-12-01
+        strip_prefix = "libunwind-1.6.2",
+        urls = ["https://github.com/libunwind/libunwind/releases/download/v1.6.2/libunwind-1.6.2.tar.gz"],
+    )
+
+    # LLVM/libclang
+    maybe(
+        llvm_configure,
+        name = "llvm-project",
+        commit = "2c494f094123562275ae688bd9e946ae2a0b4f8b",  # 2022-03-31
+        sha256 = "59b9431ae22f0ea5f2ce880925c0242b32a9e4f1ae8147deb2bb0fc19b53fa0d",
+        system_libraries = True,  # Prefer system libraries
+    )
+
 def sapi_deps():
     """Loads common dependencies needed to compile Sandboxed API."""
 
+    # Bazel rules_python
+    maybe(
+        http_archive,
+        name = "rules_python",
+        sha256 = "c6fb25d0ba0246f6d5bd820dd0b2e66b339ccc510242fd4956b9a639b548d113",  # 2024-10-27
+        strip_prefix = "rules_python-0.37.2",
+        urls = ["https://github.com/bazelbuild/rules_python/releases/download/0.37.2/rules_python-0.37.2.tar.gz"],
+    )
+
     # Bazel Skylib
     maybe(
         http_archive,
         name = "bazel_skylib",
-        sha256 = "66ffd9315665bfaafc96b52278f57c7e2dd09f5ede279ea6d39b2be471e7e3aa",
+        sha256 = "bc283cdfcd526a52c3201279cda4bc298652efa898b10b4db0837dc51652756f",  # 2024-06-03
         urls = [
-            "https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.4.2/bazel-skylib-1.4.2.tar.gz",
-            "https://github.com/bazelbuild/bazel-skylib/releases/download/1.4.2/bazel-skylib-1.4.2.tar.gz",
+            "https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.7.1/bazel-skylib-1.7.1.tar.gz",
+            "https://github.com/bazelbuild/bazel-skylib/releases/download/1.7.1/bazel-skylib-1.7.1.tar.gz",
         ],
     )
 
@@ -37,16 +91,16 @@ def sapi_deps():
     maybe(
         http_archive,
         name = "com_google_absl",
-        sha256 = "1ca4c7431b0818a10507af8eac34a1873e4e786a18ecd3f04d8faf3a0874e8bb",  # 2023-08-24
-        strip_prefix = "abseil-cpp-8ebad34c3fa54a9ad2f46ca8cab98e75c4f750bf",
-        urls = ["https://github.com/abseil/abseil-cpp/archive/8ebad34c3fa54a9ad2f46ca8cab98e75c4f750bf.zip"],
+        sha256 = "571549a0fa17ebf46f517541bb8d66fe369493963d463409fe61f2b8a44eb2dc",  # 2024-04-05
+        strip_prefix = "abseil-cpp-fa588813c4b2d931737bbe7c4b4f7fa6ed7509db",
+        urls = ["https://github.com/abseil/abseil-cpp/archive/fa588813c4b2d931737bbe7c4b4f7fa6ed7509db.zip"],
     )
     maybe(
         http_archive,
         name = "com_google_absl_py",
-        sha256 = "3d0278d88bbd52993f381d1e20887fa30f0556f6263b3f7bfcad62c69f39b38e",  # 2021-03-09
-        strip_prefix = "abseil-py-9954557f9df0b346a57ff82688438c55202d2188",
-        urls = ["https://github.com/abseil/abseil-py/archive/9954557f9df0b346a57ff82688438c55202d2188.zip"],
+        sha256 = "8a3d0830e4eb4f66c4fa907c06edf6ce1c719ced811a12e26d9d3162f8471758",  # 2024-01-16
+        strip_prefix = "abseil-py-2.1.0",
+        urls = ["https://github.com/abseil/abseil-py/archive/refs/tags/v2.1.0.tar.gz"],
     )
 
     # Abseil-py dependency for Python 2/3 compatiblity
@@ -63,42 +117,9 @@ def sapi_deps():
     maybe(
         http_archive,
         name = "com_google_protobuf",
-        sha256 = "a700a49470d301f1190a487a923b5095bf60f08f4ae4cac9f5f7c36883d17971",  # 2023-07-06
-        strip_prefix = "protobuf-23.4",
-        urls = ["https://github.com/protocolbuffers/protobuf/releases/download/v23.4/protobuf-23.4.tar.gz"],
-    )
-
-    # libcap
-    http_archive(
-        name = "org_kernel_libcap",
-        build_file = "@com_google_sandboxed_api//sandboxed_api:bazel/external/libcap.BUILD",
-        sha256 = "260b549c154b07c3cdc16b9ccc93c04633c39f4fb6a4a3b8d1fa5b8a9c3f5fe8",  # 2019-04-16
-        strip_prefix = "libcap-2.27",
-        urls = ["https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.27.tar.gz"],
-    )
-
-    # libffi
-    autotools_repository(
-        name = "org_sourceware_libffi",
-        build_file = "@com_google_sandboxed_api//sandboxed_api:bazel/external/libffi.BUILD",
-        sha256 = "653ffdfc67fbb865f39c7e5df2a071c0beb17206ebfb0a9ecb18a18f63f6b263",  # 2019-11-02
-        strip_prefix = "libffi-3.3-rc2",
-        urls = ["https://github.com/libffi/libffi/releases/download/v3.3-rc2/libffi-3.3-rc2.tar.gz"],
-    )
-
-    # libunwind
-    autotools_repository(
-        name = "org_gnu_libunwind",
-        build_file = "@com_google_sandboxed_api//sandboxed_api:bazel/external/libunwind.BUILD",
-        configure_args = [
-            "--disable-documentation",
-            "--disable-minidebuginfo",
-            "--disable-shared",
-            "--enable-ptrace",
-        ],
-        sha256 = "4a6aec666991fb45d0889c44aede8ad6eb108071c3554fcdff671f9c94794976",  # 2021-12-01
-        strip_prefix = "libunwind-1.6.2",
-        urls = ["https://github.com/libunwind/libunwind/releases/download/v1.6.2/libunwind-1.6.2.tar.gz"],
+        sha256 = "b2340aa47faf7ef10a0328190319d3f3bee1b24f426d4ce8f4253b6f27ce16db",  # 2024-09-18
+        strip_prefix = "protobuf-28.2",
+        urls = ["https://github.com/protocolbuffers/protobuf/releases/download/v28.2/protobuf-28.2.tar.gz"],
     )
 
     # GoogleTest/GoogleMock
@@ -119,11 +140,4 @@ def sapi_deps():
         urls = ["https://github.com/google/benchmark/archive/604f6fd3f4b34a84ec4eb4db81d842fa4db829cd.zip"],
     )
 
-    # LLVM/libclang
-    maybe(
-        llvm_configure,
-        name = "llvm-project",
-        commit = "2c494f094123562275ae688bd9e946ae2a0b4f8b",  # 2022-03-31
-        sha256 = "59b9431ae22f0ea5f2ce880925c0242b32a9e4f1ae8147deb2bb0fc19b53fa0d",
-        system_libraries = True,  # Prefer system libraries
-    )
+    sapi_non_module_deps()
diff --git a/sandboxed_api/client.cc b/sandboxed_api/client.cc
index 50c912c..4459d92 100644
--- a/sandboxed_api/client.cc
+++ b/sandboxed_api/client.cc
@@ -39,12 +39,11 @@
 #include "google/protobuf/message.h"
 #include "sandboxed_api/call.h"
 #include "sandboxed_api/lenval_core.h"
-#include "sandboxed_api/proto_arg.pb.h"
-#include "sandboxed_api/proto_helper.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/forkingclient.h"
 #include "sandboxed_api/sandbox2/logsink.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/util/proto_arg.pb.h"
+#include "sandboxed_api/util/proto_helper.h"
 #include "sandboxed_api/var_type.h"
 
 #include <ffi.h>
diff --git a/sandboxed_api/config.h b/sandboxed_api/config.h
index e8c61d1..7bf2904 100644
--- a/sandboxed_api/config.h
+++ b/sandboxed_api/config.h
@@ -102,7 +102,6 @@ namespace os {
 // Operating Systems known to Sandbox2
 enum Platform : uint16_t {
   kUnknown,
-  kAndroid,
   kLinux,
 };
 
@@ -113,17 +112,13 @@ namespace host_os {
 // Returns the current host OS platform if supported. If not supported,
 // returns platforms::kUnknown.
 constexpr os::Platform Platform() {
-#if defined(__ANDROID__)
-  return os::kAndroid;
-#elif defined(__linux__)
+#if defined(__linux__)
   return os::kLinux;
 #else
   return os::kUnknown;
 #endif
 }
 
-constexpr bool IsAndroid() { return Platform() == os::kAndroid; }
-
 constexpr bool IsLinux() { return Platform() == os::kLinux; }
 
 }  // namespace host_os
diff --git a/sandboxed_api/embed_file.cc b/sandboxed_api/embed_file.cc
index 62dfc5a..f274a59 100644
--- a/sandboxed_api/embed_file.cc
+++ b/sandboxed_api/embed_file.cc
@@ -31,6 +31,8 @@ namespace sapi {
 
 namespace {
 
+using ::sapi::file_util::fileops::FDCloser;
+
 #ifndef F_ADD_SEALS
 #define F_ADD_SEALS 1033
 #define F_SEAL_SEAL 0x0001
@@ -108,8 +110,8 @@ int EmbedFile::GetFdForFileToc(const FileToc* toc) {
     SAPI_RAW_VLOG(3,
                   "Returning pre-existing embed file entry for '%s', fd: %d "
                   "(orig name: '%s')",
-                  toc->name, entry->second, entry->first->name);
-    return entry->second;
+                  toc->name, entry->second.get(), entry->first->name);
+    return entry->second.get();
   }
 
   int embed_fd = CreateFdForFileToc(toc);
@@ -121,7 +123,7 @@ int EmbedFile::GetFdForFileToc(const FileToc* toc) {
   SAPI_RAW_VLOG(1, "Created new embed file entry for '%s' with fd: %d",
                 toc->name, embed_fd);
 
-  file_tocs_[toc] = embed_fd;
+  file_tocs_[toc] = FDCloser(embed_fd);
   return embed_fd;
 }
 
diff --git a/sandboxed_api/embed_file.h b/sandboxed_api/embed_file.h
index 131da31..a437c62 100644
--- a/sandboxed_api/embed_file.h
+++ b/sandboxed_api/embed_file.h
@@ -19,9 +19,12 @@
 #include "absl/base/thread_annotations.h"
 #include "absl/container/flat_hash_map.h"
 #include "absl/synchronization/mutex.h"
+#include "sandboxed_api/util/fileops.h"
 
 namespace sapi {
 
+class EmbedFileTestPeer;
+
 // The class provides primitives for converting FileToc structures into
 // executable files.
 class EmbedFile {
@@ -39,6 +42,7 @@ class EmbedFile {
   int GetDupFdForFileToc(const FileToc* toc);
 
  private:
+  friend class EmbedFileTestPeer;  // For testing.
   // Creates an executable file for a given FileToc, and return its
   // file-descriptors (-1 in case of errors).
   static int CreateFdForFileToc(const FileToc* toc);
@@ -46,7 +50,7 @@ class EmbedFile {
   EmbedFile() = default;
 
   // List of File TOCs and corresponding file-descriptors.
-  absl::flat_hash_map<const FileToc*, int> file_tocs_
+  absl::flat_hash_map<const FileToc*, file_util::fileops::FDCloser> file_tocs_
       ABSL_GUARDED_BY(file_tocs_mutex_);
   absl::Mutex file_tocs_mutex_;
 };
diff --git a/sandboxed_api/embed_file_test.cc b/sandboxed_api/embed_file_test.cc
new file mode 100644
index 0000000..cb82a85
--- /dev/null
+++ b/sandboxed_api/embed_file_test.cc
@@ -0,0 +1,86 @@
+#include "sandboxed_api/embed_file.h"
+
+#include <memory>
+#include <string>
+
+#include "sandboxed_api/file_toc.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "absl/memory/memory.h"
+#include "absl/strings/string_view.h"
+
+namespace sapi {
+
+class EmbedFileTestPeer {
+ public:
+  static std::unique_ptr<EmbedFile> NewInstance() {
+    return absl::WrapUnique(new EmbedFile());
+  }
+};
+
+namespace {
+
+using ::testing::Eq;
+using ::testing::Ne;
+
+constexpr absl::string_view kRegularContents = "Hello world!";
+constexpr FileToc kRegularToc = {
+    .name = "regular",
+    .data = kRegularContents.data(),
+    .size = kRegularContents.size(),
+    .md5digest = {},  // MD5 is unused in SAPI implementation
+};
+
+constexpr FileToc kFaultyToc = {
+    .name = "regular",
+    .data = nullptr,
+    .size = 100,
+    .md5digest = {},  // MD5 is unused in SAPI implementation
+};
+
+TEST(EmbedFileTest, GetRegularFd) {
+  std::unique_ptr<EmbedFile> embed_file = EmbedFileTestPeer::NewInstance();
+  int fd = embed_file->GetFdForFileToc(&kRegularToc);
+  EXPECT_THAT(fd, Ne(-1));
+}
+
+TEST(EmbedFileTest, DuplicateGetFdIsSame) {
+  std::unique_ptr<EmbedFile> embed_file = EmbedFileTestPeer::NewInstance();
+  int fd = embed_file->GetFdForFileToc(&kRegularToc);
+  EXPECT_THAT(fd, Ne(-1));
+  int fd2 = embed_file->GetFdForFileToc(&kRegularToc);
+  EXPECT_THAT(fd, Eq(fd2));
+}
+
+TEST(EmbedFileTest, GetDupFdReturnsFreshFd) {
+  std::unique_ptr<EmbedFile> embed_file = EmbedFileTestPeer::NewInstance();
+  int fd = embed_file->GetFdForFileToc(&kRegularToc);
+  EXPECT_THAT(fd, Ne(-1));
+  int dup_fd = embed_file->GetDupFdForFileToc(&kRegularToc);
+  EXPECT_THAT(fd, Ne(dup_fd));
+  close(dup_fd);
+}
+
+TEST(EmbedFileTest, FaultyTocFails) {
+  std::unique_ptr<EmbedFile> embed_file = EmbedFileTestPeer::NewInstance();
+  int fd = embed_file->GetFdForFileToc(&kFaultyToc);
+  EXPECT_THAT(fd, Eq(-1));
+  int dup_fd = embed_file->GetDupFdForFileToc(&kFaultyToc);
+  EXPECT_THAT(dup_fd, Eq(-1));
+}
+
+TEST(EmbedFileTest, OverlongNameTocFails) {
+  std::string overlong_name(1000, 'a');
+  FileToc overlong_name_toc = {
+      .name = overlong_name.c_str(),
+      .data = kRegularContents.data(),
+      .size = kRegularContents.size(),
+      .md5digest = {},  // MD5 is unused in SAPI implementation
+  };
+  std::unique_ptr<EmbedFile> embed_file = EmbedFileTestPeer::NewInstance();
+  int fd = embed_file->GetFdForFileToc(&overlong_name_toc);
+  EXPECT_THAT(fd, Eq(-1));
+}
+
+}  // namespace
+}  // namespace sapi
diff --git a/sandboxed_api/examples/hello_sapi/.bazelrc b/sandboxed_api/examples/hello_sapi/.bazelrc
index a68e070..27a79c6 100644
--- a/sandboxed_api/examples/hello_sapi/.bazelrc
+++ b/sandboxed_api/examples/hello_sapi/.bazelrc
@@ -1,2 +1,5 @@
+# Migration to Bzlmod is not ready yet
+common --noenable_bzlmod
+
 # Build in C++17 mode without a custom CROSSTOOL
-build --cxxopt=-std=c++17
+build --cxxopt=-std=c++17 --host_cxxopt=-std=c++17
diff --git a/sandboxed_api/examples/hello_sapi/BUILD.bazel b/sandboxed_api/examples/hello_sapi/BUILD
similarity index 100%
rename from sandboxed_api/examples/hello_sapi/BUILD.bazel
rename to sandboxed_api/examples/hello_sapi/BUILD
diff --git a/sandboxed_api/examples/hello_sapi/WORKSPACE.bazel b/sandboxed_api/examples/hello_sapi/WORKSPACE
similarity index 100%
rename from sandboxed_api/examples/hello_sapi/WORKSPACE.bazel
rename to sandboxed_api/examples/hello_sapi/WORKSPACE
diff --git a/sandboxed_api/examples/stringop/BUILD.bazel b/sandboxed_api/examples/stringop/BUILD
similarity index 75%
rename from sandboxed_api/examples/stringop/BUILD.bazel
rename to sandboxed_api/examples/stringop/BUILD
index e337152..bbef83c 100644
--- a/sandboxed_api/examples/stringop/BUILD.bazel
+++ b/sandboxed_api/examples/stringop/BUILD
@@ -14,11 +14,11 @@
 
 # Description: Example using dynamic length structures for Sandboxed API
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
-load("//sandboxed_api/bazel:sapi.bzl", "sapi_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:sapi.bzl", "sapi_library")
 
-package(default_visibility = ["//sandboxed_api:__subpackages__"])
+package(default_visibility = ["@com_google_sandboxed_api//sandboxed_api:__subpackages__"])
 
 licenses(["notice"])
 
@@ -36,8 +36,8 @@ cc_library(
     linkstatic = True,
     deps = [
         ":stringop_params_cc_proto",
-        "//sandboxed_api:lenval_core",
         "@com_google_absl//absl/base:core_headers",
+        "@com_google_sandboxed_api//sandboxed_api:lenval_core",
     ],
     alwayslink = True,
 )
@@ -71,15 +71,15 @@ cc_test(
     deps = [
         ":stringop-sapi",
         ":stringop_params_cc_proto",
-        "//sandboxed_api:sapi",
-        "//sandboxed_api:vars",
-        "//sandboxed_api/util:status",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:sapi",
+        "@com_google_sandboxed_api//sandboxed_api:vars",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
diff --git a/sandboxed_api/examples/sum/BUILD.bazel b/sandboxed_api/examples/sum/BUILD
similarity index 83%
rename from sandboxed_api/examples/sum/BUILD.bazel
rename to sandboxed_api/examples/sum/BUILD
index 803ca15..2ff4110 100644
--- a/sandboxed_api/examples/sum/BUILD.bazel
+++ b/sandboxed_api/examples/sum/BUILD
@@ -12,11 +12,11 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
-load("//sandboxed_api/bazel:sapi.bzl", "sapi_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:sapi.bzl", "sapi_library")
 
-package(default_visibility = ["//sandboxed_api:__subpackages__"])
+package(default_visibility = ["@com_google_sandboxed_api//sandboxed_api:__subpackages__"])
 
 licenses(["notice"])
 
@@ -80,8 +80,6 @@ cc_binary(
     deps = [
         ":sum-sapi",
         ":sum_params_cc_proto",
-        "//sandboxed_api:sapi",
-        "//sandboxed_api:vars",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/flags:parse",
@@ -92,6 +90,8 @@ cc_binary(
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api:sapi",
+        "@com_google_sandboxed_api//sandboxed_api:vars",
     ],
 )
 
diff --git a/sandboxed_api/examples/sum/main_sum.cc b/sandboxed_api/examples/sum/main_sum.cc
index 86f0086..19a2043 100644
--- a/sandboxed_api/examples/sum/main_sum.cc
+++ b/sandboxed_api/examples/sum/main_sum.cc
@@ -131,11 +131,10 @@ absl::Status SumTransaction::Main() {
   TRANSACTION_FAIL_IF_NOT(ret.GetValue() == 15, "puts('Hello World!!!') != 15");
 
   sapi::v::Int vp;
-  sapi::v::NullPtr nptr;
   LOG(INFO) << "Test whether pointer is NOT NULL - new pointers";
   SAPI_RETURN_IF_ERROR(f.testptr(vp.PtrBefore()));
   LOG(INFO) << "Test whether pointer is NULL";
-  SAPI_RETURN_IF_ERROR(f.testptr(&nptr));
+  SAPI_RETURN_IF_ERROR(f.testptr(nullptr));
 
   // Protobuf test.
   sumsapi::SumParamsProto proto;
diff --git a/sandboxed_api/examples/zlib/BUILD.bazel b/sandboxed_api/examples/zlib/BUILD
similarity index 83%
rename from sandboxed_api/examples/zlib/BUILD.bazel
rename to sandboxed_api/examples/zlib/BUILD
index 2193264..cfd6623 100644
--- a/sandboxed_api/examples/zlib/BUILD.bazel
+++ b/sandboxed_api/examples/zlib/BUILD
@@ -14,10 +14,10 @@
 
 # Description: Sandboxed API reimplementation of zlib's zpipe.c example.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:sapi.bzl", "sapi_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:sapi.bzl", "sapi_library")
 
-package(default_visibility = ["//sandboxed_api:__subpackages__"])
+package(default_visibility = ["@com_google_sandboxed_api//sandboxed_api:__subpackages__"])
 
 licenses(["notice"])
 
@@ -42,7 +42,6 @@ cc_binary(
     copts = sapi_platform_copts(),
     deps = [
         ":zlib-sapi",
-        "//sandboxed_api:vars",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/flags:parse",
@@ -51,6 +50,7 @@ cc_binary(
         "@com_google_absl//absl/log:initialize",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
+        "@com_google_sandboxed_api//sandboxed_api:vars",
     ],
 )
 
diff --git a/sandboxed_api/rpcchannel.cc b/sandboxed_api/rpcchannel.cc
index 7e76b05..4164aac 100644
--- a/sandboxed_api/rpcchannel.cc
+++ b/sandboxed_api/rpcchannel.cc
@@ -16,7 +16,6 @@
 
 #include <cstdint>
 #include <cstring>
-#include <string>
 
 #include "absl/log/log.h"
 #include "absl/status/status.h"
@@ -25,7 +24,6 @@
 #include "absl/synchronization/mutex.h"
 #include "sandboxed_api/call.h"
 #include "sandboxed_api/sandbox2/comms.h"
-#include "sandboxed_api/util/raw_logging.h"
 #include "sandboxed_api/util/status_macros.h"
 
 namespace sapi {
@@ -45,14 +43,9 @@ absl::StatusOr<FuncRet> RPCChannel::Return(v::Type exp_type) {
   uint32_t tag;
   size_t len;
   FuncRet ret;
-  if (!comms_->RecvTLV(&tag, &len, &ret, sizeof(ret))) {
+  if (!comms_->RecvTLV(&tag, &len, &ret, sizeof(ret), comms::kMsgReturn)) {
     return absl::UnavailableError("Receiving TLV value failed");
   }
-  if (tag != comms::kMsgReturn) {
-    LOG(ERROR) << "tag != comms::kMsgReturn (" << absl::StrCat(absl::Hex(tag))
-               << " != " << absl::StrCat(absl::Hex(comms::kMsgReturn)) << ")";
-    return absl::UnavailableError("Received TLV has incorrect tag");
-  }
   if (len != sizeof(FuncRet)) {
     LOG(ERROR) << "len != sizeof(FuncReturn) (" << len
                << " != " << sizeof(FuncRet) << ")";
diff --git a/sandboxed_api/sandbox.cc b/sandboxed_api/sandbox.cc
index 88b2696..3893e72 100644
--- a/sandboxed_api/sandbox.cc
+++ b/sandboxed_api/sandbox.cc
@@ -19,6 +19,8 @@
 #include <sys/uio.h>
 #include <syscall.h>
 
+#include <cstddef>
+#include <cstdint>
 #include <cstdio>
 #include <initializer_list>
 #include <memory>
@@ -26,6 +28,7 @@
 #include <utility>
 #include <vector>
 
+#include "sandboxed_api/file_toc.h"
 #include "absl/base/dynamic_annotations.h"
 #include "absl/base/macros.h"
 #include "absl/log/log.h"
@@ -33,7 +36,11 @@
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
+#include "absl/strings/string_view.h"
+#include "absl/synchronization/mutex.h"
 #include "absl/time/time.h"
+#include "absl/types/span.h"
+#include "sandboxed_api/call.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/embed_file.h"
 #include "sandboxed_api/rpcchannel.h"
@@ -42,23 +49,44 @@
 #include "sandboxed_api/sandbox2/policybuilder.h"
 #include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/sandbox2/sandbox2.h"
-#include "sandboxed_api/sandbox2/util/bpf_helper.h"
-#include "sandboxed_api/util/fileops.h"
+#include "sandboxed_api/sandbox2/util.h"
 #include "sandboxed_api/util/path.h"
-#include "sandboxed_api/util/raw_logging.h"
 #include "sandboxed_api/util/runfiles.h"
 #include "sandboxed_api/util/status_macros.h"
+#include "sandboxed_api/var_abstract.h"
+#include "sandboxed_api/var_array.h"
+#include "sandboxed_api/var_int.h"
+#include "sandboxed_api/var_ptr.h"
+#include "sandboxed_api/var_reg.h"
+#include "sandboxed_api/var_type.h"
 
 namespace sapi {
 
+Sandbox::Sandbox(const FileToc* embed_lib_toc) {
+  owned_fork_client_context_ =
+      std::make_unique<ForkClientContext>(embed_lib_toc);
+  fork_client_context_ = owned_fork_client_context_.get();
+}
+
+Sandbox::Sandbox(std::nullptr_t)
+    : Sandbox(static_cast<const FileToc*>(nullptr)) {}
+
 Sandbox::~Sandbox() {
   Terminate();
   // The forkserver will die automatically when the executor goes out of scope
   // and closes the comms object.
 }
 
+void Sandbox::SetForkClientContext(ForkClientContext* fork_client_context) {
+  fork_client_context_ = fork_client_context;
+  owned_fork_client_context_.reset();
+}
+
 // A generic policy which should work with majority of typical libraries, which
 // are single-threaded and require ~30 basic syscalls.
+//
+// IMPORTANT: This policy must be safe to use with
+// `Allow(sandbox2::UnrestrictedNetworking())`.
 void InitDefaultPolicyBuilder(sandbox2::PolicyBuilder* builder) {
   (*builder)
       .AllowRead()
@@ -98,8 +126,8 @@ void InitDefaultPolicyBuilder(sandbox2::PolicyBuilder* builder) {
                  << "(ASAN/MSAN/TSAN) sanitizer";
     builder->AllowLlvmSanitizers();
   }
-    builder->AddFile("/etc/localtime")
-        .AddTmpfs("/tmp", 1ULL << 30 /* 1GiB tmpfs (max size */);
+  builder->AddFile("/etc/localtime")
+      .AddTmpfs("/tmp", 1ULL << 30 /* 1GiB tmpfs (max size */);
 }
 
 void Sandbox::Terminate(bool attempt_graceful_exit) {
@@ -127,8 +155,10 @@ void Sandbox::Terminate(bool attempt_graceful_exit) {
     result = s2_->AwaitResult();
   }
 
-  if (result->final_status() == sandbox2::Result::OK &&
-      result->reason_code() == 0) {
+  if ((result->final_status() == sandbox2::Result::OK &&
+       result->reason_code() == 0) ||
+      (!attempt_graceful_exit &&
+       result->final_status() == sandbox2::Result::EXTERNAL_KILL)) {
     VLOG(2) << "Sandbox2 finished with: " << result->ToString();
   } else {
     LOG(WARNING) << "Sandbox2 finished with: " << result->ToString();
@@ -146,45 +176,52 @@ absl::Status Sandbox::Init(bool use_unotify_monitor) {
     return absl::OkStatus();
   }
 
-  // Initialize the forkserver if it is not already running.
-  if (!fork_client_) {
-    // If FileToc was specified, it will be used over any paths to the SAPI
-    // library.
-    std::string lib_path;
-    int embed_lib_fd = -1;
-    if (embed_lib_toc_ && !sapi::host_os::IsAndroid()) {
-      embed_lib_fd = EmbedFile::instance()->GetDupFdForFileToc(embed_lib_toc_);
-      if (embed_lib_fd == -1) {
-        PLOG(ERROR) << "Cannot create executable FD for TOC:'"
-                    << embed_lib_toc_->name << "'";
-        return absl::UnavailableError("Could not create executable FD");
+  sandbox2::ForkClient* fork_client;
+  {
+    absl::MutexLock lock(&fork_client_context_->mu_);
+    // Initialize the forkserver if it is not already running.
+    if (!fork_client_context_->client_) {
+      // If FileToc was specified, it will be used over any paths to the SAPI
+      // library.
+      std::string lib_path;
+      int embed_lib_fd = -1;
+      const FileToc* embed_lib_toc = fork_client_context_->embed_lib_toc_;
+      if (embed_lib_toc) {
+        embed_lib_fd = EmbedFile::instance()->GetDupFdForFileToc(embed_lib_toc);
+        if (embed_lib_fd == -1) {
+          PLOG(ERROR) << "Cannot create executable FD for TOC:'"
+                      << embed_lib_toc->name << "'";
+          return absl::UnavailableError("Could not create executable FD");
+        }
+        lib_path = embed_lib_toc->name;
+      } else {
+        lib_path = PathToSAPILib(GetLibPath());
+        if (lib_path.empty()) {
+          LOG(ERROR) << "SAPI library path is empty";
+          return absl::FailedPreconditionError("No SAPI library path given");
+        }
       }
-      lib_path = embed_lib_toc_->name;
-    } else {
-      lib_path = PathToSAPILib(GetLibPath());
-      if (lib_path.empty()) {
-        LOG(ERROR) << "SAPI library path is empty";
-        return absl::FailedPreconditionError("No SAPI library path given");
+      std::vector<std::string> args = {lib_path};
+      // Additional arguments, if needed.
+      GetArgs(&args);
+      std::vector<std::string> envs{};
+      // Additional envvars, if needed.
+      GetEnvs(&envs);
+
+      fork_client_context_->executor_ =
+          (embed_lib_fd >= 0)
+              ? std::make_unique<sandbox2::Executor>(embed_lib_fd, args, envs)
+              : std::make_unique<sandbox2::Executor>(lib_path, args, envs);
+
+      fork_client_context_->client_ =
+          fork_client_context_->executor_->StartForkServer();
+
+      if (!fork_client_context_->client_) {
+        LOG(ERROR) << "Could not start forkserver";
+        return absl::UnavailableError("Could not start the forkserver");
       }
     }
-    std::vector<std::string> args = {lib_path};
-    // Additional arguments, if needed.
-    GetArgs(&args);
-    std::vector<std::string> envs{};
-    // Additional envvars, if needed.
-    GetEnvs(&envs);
-
-    forkserver_executor_ =
-        (embed_lib_fd >= 0)
-            ? std::make_unique<sandbox2::Executor>(embed_lib_fd, args, envs)
-            : std::make_unique<sandbox2::Executor>(lib_path, args, envs);
-
-    fork_client_ = forkserver_executor_->StartForkServer();
-
-    if (!fork_client_) {
-      LOG(ERROR) << "Could not start forkserver";
-      return absl::UnavailableError("Could not start the forkserver");
-    }
+    fork_client = fork_client_context_->client_.get();
   }
 
     sandbox2::PolicyBuilder policy_builder;
@@ -195,7 +232,7 @@ absl::Status Sandbox::Init(bool use_unotify_monitor) {
   auto s2p = ModifyPolicy(&policy_builder);
 
   // Spawn new process from the forkserver.
-  auto executor = std::make_unique<sandbox2::Executor>(fork_client_.get());
+  auto executor = std::make_unique<sandbox2::Executor>(fork_client);
 
   executor
       // The client.cc code is capable of enabling sandboxing on its own.
@@ -224,6 +261,11 @@ absl::Status Sandbox::Init(bool use_unotify_monitor) {
   rpc_channel_ = std::make_unique<RPCChannel>(comms_);
 
   if (!res) {
+    // Allow recovering from a bad fork client state.
+    {
+      absl::MutexLock lock(&fork_client_context_->mu_);
+      fork_client_context_->client_.reset();
+    }
     Terminate();
     return absl::UnavailableError("Could not start the sandbox");
   }
@@ -422,6 +464,15 @@ absl::Status Sandbox::TransferFromSandboxee(v::Var* var) {
   return var->TransferFromSandboxee(rpc_channel(), pid());
 }
 
+absl::StatusOr<std::unique_ptr<sapi::v::Array<const uint8_t>>>
+Sandbox::AllocateAndTransferToSandboxee(absl::Span<const uint8_t> buffer) {
+  auto sapi_buffer = std::make_unique<sapi::v::Array<const uint8_t>>(
+      buffer.data(), buffer.size());
+  SAPI_RETURN_IF_ERROR(Allocate(sapi_buffer.get(), /*automatic_free=*/true));
+  SAPI_RETURN_IF_ERROR(TransferToSandboxee(sapi_buffer.get()));
+  return sapi_buffer;
+}
+
 absl::StatusOr<std::string> Sandbox::GetCString(const v::RemotePtr& str,
                                                 size_t max_length) {
   if (!is_active()) {
@@ -434,21 +485,11 @@ absl::StatusOr<std::string> Sandbox::GetCString(const v::RemotePtr& str,
         absl::StrCat("Target string too large: ", len, " > ", max_length));
   }
   std::string buffer(len, '\0');
-  struct iovec local = {
-      .iov_base = &buffer[0],
-      .iov_len = len,
-  };
-  struct iovec remote = {
-      .iov_base = str.GetValue(),
-      .iov_len = len,
-  };
-
-  ssize_t ret = process_vm_readv(pid_, &local, 1, &remote, 1, 0);
-  if (ret == -1) {
-    PLOG(WARNING) << "reading c-string failed: process_vm_readv(pid: " << pid_
-                  << " raddr: " << str.GetValue() << " size: " << len << ")";
-    return absl::UnavailableError("process_vm_readv failed");
-  }
+  SAPI_ASSIGN_OR_RETURN(
+      size_t ret,
+      sandbox2::util::ReadBytesFromPidInto(
+          pid_, reinterpret_cast<uintptr_t>(str.GetValue()),
+          absl::MakeSpan(reinterpret_cast<char*>(buffer.data()), len)));
   if (ret != len) {
     LOG(WARNING) << "partial read when reading c-string: process_vm_readv(pid: "
                  << pid_ << " raddr: " << str.GetValue() << " size: " << len
@@ -475,17 +516,6 @@ absl::Status Sandbox::SetWallTimeLimit(absl::Duration limit) const {
   return absl::OkStatus();
 }
 
-void Sandbox::Exit() const {
-  if (!is_active()) {
-    return;
-  }
-  s2_->set_walltime_limit(absl::Seconds(1));
-  if (!rpc_channel_->Exit().ok()) {
-    LOG(WARNING) << "rpc_channel->Exit() failed, killing PID: " << pid();
-    s2_->Kill();
-  }
-}
-
 std::unique_ptr<sandbox2::Policy> Sandbox::ModifyPolicy(
     sandbox2::PolicyBuilder* builder) {
   return builder->BuildOrDie();
diff --git a/sandboxed_api/sandbox.h b/sandboxed_api/sandbox.h
index b691e08..37afb9c 100644
--- a/sandboxed_api/sandbox.h
+++ b/sandboxed_api/sandbox.h
@@ -15,6 +15,8 @@
 #ifndef SANDBOXED_API_SANDBOX_H_
 #define SANDBOXED_API_SANDBOX_H_
 
+#include <cstddef>
+#include <cstdint>
 #include <ctime>
 #include <initializer_list>
 #include <memory>
@@ -22,12 +24,17 @@
 #include <vector>
 
 #include "sandboxed_api/file_toc.h"
+#include "absl/base/attributes.h"
 #include "absl/base/macros.h"
+#include "absl/base/thread_annotations.h"
 #include "absl/log/globals.h"
 #include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/strings/str_cat.h"
+#include "absl/synchronization/mutex.h"
 #include "absl/time/time.h"
+#include "absl/types/span.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/rpcchannel.h"
 #include "sandboxed_api/sandbox2/client.h"
@@ -39,18 +46,39 @@
 
 namespace sapi {
 
+// Context holding, potentially shared, fork client.
+class ForkClientContext {
+ public:
+  explicit ForkClientContext(const FileToc* embed_lib_toc)
+      : embed_lib_toc_(embed_lib_toc) {}
+
+ private:
+  friend class Sandbox;
+  const FileToc* embed_lib_toc_;
+  absl::Mutex mu_;
+  std::unique_ptr<sandbox2::ForkClient> client_ ABSL_GUARDED_BY(mu_);
+  std::unique_ptr<sandbox2::Executor> executor_ ABSL_GUARDED_BY(mu_);
+};
+
 // The Sandbox class represents the sandboxed library. It provides users with
 // means to communicate with it (make function calls, transfer memory).
 class Sandbox {
  public:
-  explicit Sandbox(const FileToc* embed_lib_toc)
-      : embed_lib_toc_(embed_lib_toc) {}
+  explicit Sandbox(
+      ForkClientContext* fork_client_context ABSL_ATTRIBUTE_LIFETIME_BOUND)
+      : fork_client_context_(fork_client_context) {}
+
+  explicit Sandbox(const FileToc* embed_lib_toc ABSL_ATTRIBUTE_LIFETIME_BOUND);
+
+  explicit Sandbox(std::nullptr_t);
 
   Sandbox(const Sandbox&) = delete;
   Sandbox& operator=(const Sandbox&) = delete;
 
   virtual ~Sandbox();
 
+  void SetForkClientContext(ForkClientContext* fork_client_context);
+
   // Initializes a new sandboxing session.
   absl::Status Init(bool use_unotify_monitor = false);
 
@@ -85,8 +113,8 @@ class Sandbox {
                   "Too many arguments to sapi::Sandbox::Call()");
     return Call(func, ret, {std::forward<Args>(args)...});
   }
-  absl::Status Call(const std::string& func, v::Callable* ret,
-                    std::initializer_list<v::Callable*> args);
+  virtual absl::Status Call(const std::string& func, v::Callable* ret,
+                            std::initializer_list<v::Callable*> args);
 
   // Allocates memory in the sandboxee, automatic_free indicates whether the
   // memory should be freed on the remote side when the 'var' goes out of scope.
@@ -98,11 +126,38 @@ class Sandbox {
   // Finds the address of a symbol in the sandboxee.
   absl::Status Symbol(const char* symname, void** addr);
 
-  // Transfers memory (both directions). Status is returned (memory transfer
-  // succeeded/failed).
+  // Transfers memory to the sandboxee's address space from the hostcode.
+  // Returns the status of the operation. Requires a v::Var object to be set up
+  // with a suitable memory buffer allocated in the hostcode.
+  //
+  // Example Usage:
+  //    std::string buffer(size_of_memory_in_sandboxee, ' ');
+  //    sapi::v::Array<uint8_t> sapi_buffer(
+  //       reinterpret_cast<uint8_t*>(buffer.data()), buffer.size());
+  //    SAPI_RETURN_IF_ERROR(sandbox.Allocate(&sapi_buffer));
+  //    SAPI_RETURN_IF_ERROR(sandbox.TransferFromSandboxee(&sapi_buffer));
   absl::Status TransferToSandboxee(v::Var* var);
+
+  // Transfers memory from the sandboxee's address space to the hostcode.
+  // Returns the status of the operation. Requires a v::Var object to be set up
+  // suitable memory buffer allocated in the hostcode. This call
+  // does not alter the memory in the sandboxee. It is therefore safe to
+  // const_cast `addr_of_memory_in_sandboxee` if necessary.
+  //
+  // Example Usage:
+  //    std::string buffer(size_of_memory_in_sandboxee, ' ');
+  //    sapi::v::Array<uint8_t> sapi_buffer(
+  //       reinterpret_cast<uint8_t*>(buffer.data()), buffer.size());
+  //    sapi_buffer.SetRemote(addr_of_memory_in_sandboxee);
+  //    SAPI_RETURN_IF_ERROR(sandbox.TransferFromSandboxee(&sapi_buffer));
   absl::Status TransferFromSandboxee(v::Var* var);
 
+  // Allocates and transfers a buffer to the sandboxee's address space from the
+  // hostcode. Returns a status on failure, or a unique_ptr to
+  // sapi::v::Array<const uint8_t> on success.
+  absl::StatusOr<std::unique_ptr<sapi::v::Array<const uint8_t>>>
+  AllocateAndTransferToSandboxee(absl::Span<const uint8_t> buffer);
+
   absl::StatusOr<std::string> GetCString(const v::RemotePtr& str,
                                          size_t max_length = 10ULL
                                                              << 20 /* 10 MiB*/
@@ -122,12 +177,12 @@ class Sandbox {
                                  static_cast<int>(absl::StderrThreshold())));
   }
 
- private:
   // Gets the environment variables passed to the sandboxee.
   virtual void GetEnvs(std::vector<std::string>* envs) const {
     // Do nothing by default.
   }
 
+ private:
   // Returns the sandbox policy. Subclasses can modify the default policy
   // builder, or return a completely new policy.
   virtual std::unique_ptr<sandbox2::Policy> ModifyPolicy(
@@ -147,13 +202,6 @@ class Sandbox {
   // Provides a custom notifier for sandboxee events. May return nullptr.
   virtual std::unique_ptr<sandbox2::Notify> CreateNotifier() { return nullptr; }
 
-  // Exits the sandboxee.
-  void Exit() const;
-
-  // The client to the library forkserver.
-  std::unique_ptr<sandbox2::ForkClient> fork_client_;
-  std::unique_ptr<sandbox2::Executor> forkserver_executor_;
-
   // The main sandbox2::Sandbox2 object.
   std::unique_ptr<sandbox2::Sandbox2> s2_;
   // Marks whether Sandbox2 result was already fetched.
@@ -174,6 +222,10 @@ class Sandbox {
   // FileTOC with the embedded library, takes precedence over GetLibPath if
   // present (not nullptr).
   const FileToc* embed_lib_toc_;
+
+  ForkClientContext* fork_client_context_;
+  // Set if the object owns the client context instance.
+  std::unique_ptr<ForkClientContext> owned_fork_client_context_;
 };
 
 }  // namespace sapi
diff --git a/sandboxed_api/sandbox2/BUILD.bazel b/sandboxed_api/sandbox2/BUILD
similarity index 63%
rename from sandboxed_api/sandbox2/BUILD.bazel
rename to sandboxed_api/sandbox2/BUILD
index 3b08b55..6a406bc 100644
--- a/sandboxed_api/sandbox2/BUILD.bazel
+++ b/sandboxed_api/sandbox2/BUILD
@@ -14,77 +14,38 @@
 
 # Description: sandbox2 is a C++ sandbox technology for Linux.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:embed_data.bzl", "sapi_cc_embed_data")
-load("//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:embed_data.bzl", "sapi_cc_embed_data")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
 
-package(default_visibility = ["//sandboxed_api:__subpackages__"])
+package(default_visibility = ["@com_google_sandboxed_api//sandboxed_api:__subpackages__"])
 
 licenses(["notice"])
 
 cc_library(
-    name = "allow_all_syscalls",
-    hdrs = ["allow_all_syscalls.h"],
-    copts = sapi_platform_copts(),
-    visibility = [
-        "//sandboxed_api/sandbox2:__pkg__",
-        "//sandboxed_api/sandbox2/examples/tool:__pkg__",
-    ],
-)
-
-cc_library(
-    name = "testonly_allow_all_syscalls",
-    testonly = True,
-    hdrs = ["allow_all_syscalls.h"],
-    copts = sapi_platform_copts(),
-    visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "trace_all_syscalls",
-    hdrs = ["trace_all_syscalls.h"],
-    copts = sapi_platform_copts(),
-    visibility = [
-        "//sandboxed_api/sandbox2:__pkg__",
-    ],
-)
-
-cc_library(
-    name = "testonly_trace_all_syscalls",
-    testonly = True,
-    hdrs = ["trace_all_syscalls.h"],
+    name = "bpfdisassembler",
+    srcs = ["bpfdisassembler.cc"],
+    hdrs = ["bpfdisassembler.h"],
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "allow_unrestricted_networking",
-    hdrs = ["allow_unrestricted_networking.h"],
-    copts = sapi_platform_copts(),
-    visibility = [
-        "//sandboxed_api/sandbox2:__pkg__",
-        "//sandboxed_api/sandbox2/examples/tool:__pkg__",
-        "//sandboxed_api/sandbox2/performance:__pkg__",
+    deps = [
+        "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/types:span",
     ],
 )
 
 cc_library(
-    name = "testonly_allow_unrestricted_networking",
-    testonly = True,
-    hdrs = ["allow_unrestricted_networking.h"],
-    copts = sapi_platform_copts(),
-    visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "bpfdisassembler",
-    srcs = ["bpfdisassembler.cc"],
-    hdrs = ["bpfdisassembler.h"],
+    name = "bpf_evaluator",
+    srcs = ["bpf_evaluator.cc"],
+    hdrs = ["bpf_evaluator.h"],
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -95,11 +56,10 @@ cc_library(
     copts = sapi_platform_copts(),
     deps = [
         ":syscall",
-        ":violation_cc_proto",
-        "//sandboxed_api:config",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api:config",
     ],
 )
 
@@ -113,11 +73,11 @@ cc_test(
         ":sanitizer",
         ":syscall",
         ":util",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/log:check",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -135,13 +95,14 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":util",
-        "//sandboxed_api:config",
         "@com_google_absl//absl/algorithm:container",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -152,9 +113,9 @@ cc_test(
     tags = ["no_qemu_user_mode"],
     deps = [
         ":syscall",
-        "//sandboxed_api:config",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:config",
     ],
 )
 
@@ -167,9 +128,9 @@ cc_library(
         ":regs",
         ":syscall",
         ":util",
-        "//sandboxed_api:config",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api:config",
     ],
 )
 
@@ -219,10 +180,10 @@ cc_library(
         ":comms",
         ":logserver",
         ":logsink",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -233,17 +194,15 @@ cc_library(
     copts = sapi_platform_copts(),
     deps = [
         ":bpfdisassembler",
-        ":comms",
         ":namespace",
         ":syscall",
-        ":violation_cc_proto",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2/network_proxy:filtering",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:raw_logging",
+        ":util",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/strings:string_view",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:filtering",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
     ],
 )
 
@@ -259,6 +218,7 @@ cc_library(
         ":util",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log",
+        "@com_google_absl//absl/strings:str_format",
     ],
 )
 
@@ -282,11 +242,11 @@ cc_binary(
         ":comms",
         ":forkserver",
         ":sanitizer",
-        "//sandboxed_api/sandbox2/unwind",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/log:globals",
         "@com_google_absl//absl/status",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/unwind",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -307,11 +267,6 @@ cc_library(
         ":forkserver_bin_embed",
         ":forkserver_cc_proto",
         ":util",
-        "//sandboxed_api:config",
-        "//sandboxed_api:embed_file",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/flags:flag",
@@ -320,6 +275,11 @@ cc_library(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/synchronization",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api:embed_file",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -350,9 +310,6 @@ cc_library(
         ":limits",
         ":namespace",
         ":util",
-        "//sandboxed_api:config",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
@@ -360,6 +317,8 @@ cc_library(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
     ],
 )
 
@@ -406,11 +365,6 @@ cc_library(
         ":stack_trace",
         ":syscall",
         ":util",
-        ":violation_cc_proto",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2/network_proxy:client",
-        "//sandboxed_api/sandbox2/network_proxy:filtering",
-        "//sandboxed_api/util:fileops",
         "@com_google_absl//absl/base",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/container:flat_hash_map",
@@ -420,9 +374,15 @@ cc_library(
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/time",
         "@com_google_absl//absl/types:optional",
         "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:map_exec",  # TODO b/371179394 - Remove this after migrating to Allow(MapExec).
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:filtering",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
     ],
 )
 
@@ -441,13 +401,6 @@ cc_library(
         ":policybuilder",
         ":regs",
         ":result",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2/unwind",
-        "//sandboxed_api/sandbox2/unwind:unwind_cc_proto",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/log",
@@ -457,6 +410,10 @@ cc_library(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/unwind:unwind_cc_proto",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -477,9 +434,6 @@ cc_library(
         ":sanitizer",
         ":syscall",
         ":util",
-        "//sandboxed_api:config",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/container:flat_hash_map",
@@ -487,12 +441,17 @@ cc_library(
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/log:vlog_is_on",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/synchronization",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:pid_waiter",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -502,6 +461,7 @@ cc_library(
     hdrs = ["monitor_unotify.h"],
     copts = sapi_platform_copts(),
     deps = [
+        ":bpf_evaluator",
         ":client",
         ":executor",
         ":forkserver_cc_proto",
@@ -509,10 +469,6 @@ cc_library(
         ":notify",
         ":policy",
         ":result",
-        "//sandboxed_api:config",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/log",
@@ -523,6 +479,10 @@ cc_library(
         "@com_google_absl//absl/synchronization",
         "@com_google_absl//absl/time",
         "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -548,23 +508,24 @@ cc_library(
         ":stack_trace",
         ":syscall",
         ":util",
-        "//sandboxed_api/sandbox2/network_proxy:client",
-        "//sandboxed_api/sandbox2/network_proxy:server",
-        "//sandboxed_api/util:file_helpers",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:strerror",
-        "//sandboxed_api/util:temp_file",
         "@com_google_absl//absl/base",
         "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/log:vlog_is_on",
         "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/synchronization",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:server",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_helpers",
+        "@com_google_sandboxed_api//sandboxed_api/util:strerror",
+        "@com_google_sandboxed_api//sandboxed_api/util:temp_file",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -574,19 +535,11 @@ cc_library(
     hdrs = ["policybuilder.h"],
     copts = sapi_platform_copts(),
     deps = [
-        ":allow_all_syscalls",
-        ":allow_unrestricted_networking",
+        ":forkserver_cc_proto",
         ":mounts",
         ":namespace",
         ":policy",
         ":syscall",
-        ":trace_all_syscalls",
-        ":violation_cc_proto",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2/network_proxy:filtering",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/log",
@@ -597,6 +550,18 @@ cc_library(
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/types:optional",
         "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:map_exec",  # TODO b/371179394 - Remove this after migrating to Allow(MapExec).
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:namespaces",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:seccomp_speculation",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:trace_all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:unrestricted_networking",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:filtering",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -614,13 +579,13 @@ cc_library(
         ":policy",
         ":sanitizer",
         ":syscall",
-        "//sandboxed_api/sandbox2/network_proxy:client",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -632,13 +597,13 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":util",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -657,10 +622,6 @@ cc_library(
         ":sanitizer",
         ":syscall",
         ":util",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:strerror",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/container:flat_hash_set",
@@ -668,6 +629,10 @@ cc_library(
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:strerror",
         "@org_kernel_libcap//:libcap",
     ],
 )
@@ -681,11 +646,11 @@ cc_library(
     deps = [
         ":comms",
         ":forkserver_cc_proto",
-        "//sandboxed_api/util:fileops",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/synchronization",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
     ],
 )
 
@@ -696,16 +661,16 @@ cc_library(
     copts = sapi_platform_copts(),
     deps = [
         ":mount_tree_cc_proto",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2/util:minielf",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:minielf",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -713,16 +678,17 @@ cc_test(
     name = "mounts_test",
     srcs = ["mounts_test.cc"],
     copts = sapi_platform_copts(),
-    data = ["//sandboxed_api/sandbox2/testcases:minimal_dynamic"],
+    data = ["@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:minimal_dynamic"],
     deps = [
+        ":mount_tree_cc_proto",
         ":mounts",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:status_matchers",
-        "//sandboxed_api/util:temp_file",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+        "@com_google_sandboxed_api//sandboxed_api/util:temp_file",
     ],
 )
 
@@ -732,12 +698,12 @@ cc_library(
     hdrs = ["namespace.h"],
     copts = sapi_platform_copts(),
     deps = [
+        ":forkserver_cc_proto",
         ":mounts",
-        ":violation_cc_proto",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -746,7 +712,7 @@ cc_test(
     srcs = ["namespace_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:namespace",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:namespace",
     ],
     tags = [
         "requires-net:external",
@@ -754,16 +720,18 @@ cc_test(
     deps = [
         ":namespace",
         ":sandbox2",
-        ":testonly_allow_all_syscalls",
-        "//sandboxed_api:config",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:status_matchers",
-        "//sandboxed_api/util:temp_file",
         "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:namespaces",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:testonly_all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:testonly_unrestricted_networking",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+        "@com_google_sandboxed_api//sandboxed_api/util:temp_file",
     ],
 )
 
@@ -778,7 +746,6 @@ cc_library(
         ":comms",
         ":forkserver",
         ":sanitizer",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
     ],
@@ -794,16 +761,19 @@ cc_library(
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
-        "//sandboxed_api:config",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:file_helpers",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
+        "@com_google_absl//absl/algorithm:container",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
+        "@com_google_absl//absl/types:span",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_helpers",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -825,21 +795,20 @@ cc_test(
     name = "buffer_test",
     srcs = ["buffer_test.cc"],
     copts = sapi_platform_copts(),
-    data = ["//sandboxed_api/sandbox2/testcases:buffer"],
+    data = ["@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:buffer"],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":buffer",
         ":sandbox2",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
 sapi_proto_library(
     name = "forkserver_proto",
     srcs = ["forkserver.proto"],
-    copts = sapi_platform_copts(),
     deps = [":mount_tree_proto"],
 )
 
@@ -856,18 +825,17 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":util",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
-        "//sandboxed_api/util:status_cc_proto",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/base:dynamic_annotations",
-        "@com_google_absl//absl/log:die_if_null",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_protobuf//:protobuf",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_cc_proto",
     ],
 )
 
@@ -883,13 +851,14 @@ cc_test(
     deps = [
         ":comms",
         ":comms_test_cc_proto",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/container:fixed_array",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -897,19 +866,18 @@ cc_test(
     name = "forkserver_test",
     srcs = ["forkserver_test.cc"],
     copts = sapi_platform_copts(),
-    data = ["//sandboxed_api/sandbox2/testcases:minimal"],
+    data = ["@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:minimal"],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":forkserver",
         ":forkserver_cc_proto",
         ":global_forkserver",
         ":sandbox2",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
     ],
 )
 
@@ -918,15 +886,15 @@ cc_test(
     srcs = ["limits_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:limits",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:limits",
     ],
     deps = [
         ":limits",
         ":sandbox2",
-        "//sandboxed_api:config",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -935,18 +903,21 @@ cc_test(
     srcs = ["notify_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:personality",
-        "//sandboxed_api/sandbox2/testcases:pidcomms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:minimal",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:personality",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:pidcomms",
     ],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":comms",
         ":sandbox2",
-        ":trace_all_syscalls",
-        "//sandboxed_api:testing",
         "@com_google_absl//absl/log",
+        "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:trace_all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -955,21 +926,23 @@ cc_test(
     srcs = ["policy_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:add_policy_on_syscalls",
-        "//sandboxed_api/sandbox2/testcases:malloc_system",
-        "//sandboxed_api/sandbox2/testcases:minimal",
-        "//sandboxed_api/sandbox2/testcases:minimal_dynamic",
-        "//sandboxed_api/sandbox2/testcases:policy",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:add_policy_on_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:malloc_system",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:minimal",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:minimal_dynamic",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:policy",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:posix_timers",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:sandbox_detection",
     ],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":sandbox2",
-        "//sandboxed_api:config",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -978,12 +951,12 @@ cc_test(
     srcs = ["sandbox2_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:abort",
-        "//sandboxed_api/sandbox2/testcases:custom_fork",
-        "//sandboxed_api/sandbox2/testcases:minimal",
-        "//sandboxed_api/sandbox2/testcases:sleep",
-        "//sandboxed_api/sandbox2/testcases:starve",
-        "//sandboxed_api/sandbox2/testcases:tsync",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:abort",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:custom_fork",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:minimal",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:sleep",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:starve",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:tsync",
     ],
     tags = [
         "local",
@@ -992,15 +965,16 @@ cc_test(
     deps = [
         ":fork_client",
         ":sandbox2",
-        "//sandboxed_api:config",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/synchronization",
         "@com_google_absl//absl/time",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
 
@@ -1009,8 +983,8 @@ cc_test(
     srcs = ["sanitizer_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:close_fds",
-        "//sandboxed_api/sandbox2/testcases:sanitizer",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:close_fds",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:sanitizer",
     ],
     tags = ["no_qemu_user_mode"],
     deps = [
@@ -1018,12 +992,12 @@ cc_test(
         ":sandbox2",
         ":sanitizer",
         ":util",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -1031,13 +1005,20 @@ cc_test(
     name = "util_test",
     srcs = ["util_test.cc"],
     copts = sapi_platform_copts(),
+    data = [
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:util_communicate",
+    ],
     deps = [
         ":util",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/cleanup",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/types:span",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -1047,23 +1028,23 @@ cc_test(
         "stack_trace_test.cc",
     ],
     copts = sapi_platform_copts(),
-    data = ["//sandboxed_api/sandbox2/testcases:symbolize"],
+    data = ["@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:symbolize"],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":global_forkserver",
         ":sandbox2",
         ":stack_trace",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/base:log_severity",
-        "@com_google_absl//absl/flags:flag",
-        "@com_google_absl//absl/flags:reflection",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/log:scoped_mock_log",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/time",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:testonly_all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:testonly_namespaces",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -1071,14 +1052,14 @@ cc_test(
     name = "ipc_test",
     srcs = ["ipc_test.cc"],
     copts = sapi_platform_copts(),
-    data = ["//sandboxed_api/sandbox2/testcases:ipc"],
+    data = ["@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:ipc"],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":comms",
         ":sandbox2",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -1088,15 +1069,7 @@ cc_library(
     hdrs = ["testing.h"],
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
-    deps = ["//sandboxed_api:testing"],
-)
-
-sapi_proto_library(
-    name = "violation_proto",
-    srcs = ["violation.proto"],
-    deps = [
-        ":mount_tree_proto",
-    ],
+    deps = ["@com_google_sandboxed_api//sandboxed_api:testing"],
 )
 
 cc_test(
@@ -1106,13 +1079,14 @@ cc_test(
     deps = [
         ":policy",
         ":policybuilder",
-        ":violation_cc_proto",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/status",
-        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:unrestricted_networking",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -1122,8 +1096,21 @@ cc_test(
     copts = sapi_platform_copts(),
     deps = [
         ":bpfdisassembler",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+    ],
+)
+
+cc_test(
+    name = "bpf_evaluator_test",
+    srcs = ["bpf_evaluator_test.cc"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":bpf_evaluator",
+        "@com_google_absl//absl/status",
+        "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -1132,17 +1119,16 @@ cc_test(
     srcs = ["network_proxy_test.cc"],
     copts = sapi_platform_copts(),
     data = [
-        "//sandboxed_api/sandbox2/testcases:network_proxy",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/testcases:network_proxy",
     ],
     tags = ["no_qemu_user_mode"],
     deps = [
         ":sandbox2",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/sandbox2/network_proxy:testing",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/status",
-        "@com_google_absl//absl/strings",
         "@com_google_absl//absl/time",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
diff --git a/sandboxed_api/sandbox2/CMakeLists.txt b/sandboxed_api/sandbox2/CMakeLists.txt
index b01c4d9..c6d0047 100644
--- a/sandboxed_api/sandbox2/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/CMakeLists.txt
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+add_subdirectory(allowlists)
 add_subdirectory(examples)
 add_subdirectory(unwind)
 add_subdirectory(util)
@@ -26,12 +27,21 @@ target_link_libraries(sandbox2_allow_all_syscalls PRIVATE
   sapi::base
 )
 
-# sandboxed_api/sandbox2:trace_all_syscalls
-add_library(sandbox2_trace_all_syscalls ${SAPI_LIB_TYPE}
-  trace_all_syscalls.h
+# sandboxed_api/sandbox2:allow_map_exec
+add_library(sandbox2_allow_map_exec ${SAPI_LIB_TYPE}
+  allow_map_exec.h
 )
-add_library(sandbox2::trace_all_syscalls ALIAS sandbox2_trace_all_syscalls)
-target_link_libraries(sandbox2_trace_all_syscalls PRIVATE
+add_library(sandbox2::allow_allow_map_exec ALIAS sandbox2_allow_map_exec)
+target_link_libraries(sandbox2_allow_map_exec PRIVATE
+  sapi::base
+)
+
+# sandboxed_api/sandbox2:allow_seccomp_speculation
+add_library(sandbox2_allow_seccomp_speculation ${SAPI_LIB_TYPE}
+  allow_seccomp_speculation.h
+)
+add_library(sandbox2::allow_seccomp_speculation ALIAS sandbox2_allow_seccomp_speculation)
+target_link_libraries(sandbox2_allow_seccomp_speculation PRIVATE
   sapi::base
 )
 
@@ -56,6 +66,21 @@ target_link_libraries(sandbox2_bpfdisassembler
           sapi::base
 )
 
+# sandboxed_api/sandbox2:bpf_evaluator
+add_library(sandbox2_bpf_evaluator ${SAPI_LIB_TYPE}
+  bpf_evaluator.cc
+  bpf_evaluator.h
+)
+add_library(sandbox2::bpf_evaluator ALIAS sandbox2_bpf_evaluator)
+target_link_libraries(sandbox2_bpf_evaluator
+  PUBLIC absl::span
+         absl::statusor
+  PRIVATE absl::status
+          absl::strings
+          sapi::base
+          sapi::status
+)
+
 # sandboxed_api/sandbox2:regs
 add_library(sandbox2_regs ${SAPI_LIB_TYPE}
   regs.cc
@@ -66,7 +91,6 @@ target_link_libraries(sandbox2_regs
   PUBLIC absl::status
          sapi::config
          sandbox2::syscall
-         sandbox2::violation_proto
   PRIVATE absl::core_headers
           absl::strings
           sapi::strerror
@@ -90,6 +114,7 @@ target_link_libraries(sandbox2_syscall
           absl::strings
           sandbox2::util
           sapi::base
+          sapi::status
   PUBLIC absl::log
 )
 
@@ -167,7 +192,7 @@ target_link_libraries(sandbox2_ipc PRIVATE
   sandbox2::network_proxy_client
   sandbox2::network_proxy_server
   sapi::base
-  sapi::raw_logging
+  sapi::thread
 )
 
 # sandboxed_api/sandbox2:policy
@@ -180,14 +205,12 @@ target_link_libraries(sandbox2_policy
  PRIVATE absl::strings
          sandbox2::bpf_helper
          sandbox2::bpfdisassembler
-         sandbox2::comms
          sandbox2::regs
          sandbox2::syscall
          sapi::base
          sapi::config
  PUBLIC sandbox2::network_proxy_filtering
         sandbox2::namespace
-        sandbox2::violation_proto
 )
 
 # sandboxed_api/sandbox2:notify
@@ -198,6 +221,7 @@ add_library(sandbox2::notify ALIAS sandbox2_notify)
 target_link_libraries(sandbox2_notify
   PUBLIC absl::core_headers
          absl::log
+         absl::str_format
          sandbox2::comms
          sandbox2::result
          sandbox2::syscall
@@ -362,7 +386,6 @@ target_link_libraries(sandbox2_sandbox2
           sandbox2::result
           sandbox2::syscall
           sandbox2::util
-          sandbox2::violation_proto
 )
 
 
@@ -385,13 +408,10 @@ target_link_libraries(sandbox2_stack_trace
           sandbox2::mounts
           sandbox2::policybuilder
           sandbox2::util
-          sandbox2::unwind
           sandbox2::unwind_proto
           sapi::base
-          sapi::config
           sapi::file_base
           sapi::fileops
-          sapi::raw_logging
           sapi::status
   PUBLIC absl::check
          absl::statusor
@@ -411,9 +431,14 @@ add_library(sandbox2_monitor_base ${SAPI_LIB_TYPE}
 )
 add_library(sandbox2::monitor_base ALIAS sandbox2_monitor_base)
 target_link_libraries(sandbox2_monitor_base
-  PRIVATE absl::cleanup
-          absl::status
+  PRIVATE absl::bind_front
+          absl::check
+          absl::cleanup
+          absl::flags
+          absl::log
+          absl::strings
           absl::time
+          absl::vlog_is_on
           sandbox2::client
           sandbox2::limits
           sandbox2::mounts
@@ -423,8 +448,8 @@ target_link_libraries(sandbox2_monitor_base
           sapi::file_helpers
           sapi::temp_file
           sapi::base
-          sapi::raw_logging
-  PUBLIC  absl::statusor
+  PUBLIC  absl::status
+          absl::statusor
           absl::synchronization
           sandbox2::comms
           sandbox2::executor
@@ -436,6 +461,7 @@ target_link_libraries(sandbox2_monitor_base
           sandbox2::policy
           sandbox2::result
           sandbox2::syscall
+          sapi::thread
 )
 
 # sandboxed_api/sandbox2:monitor_ptrace
@@ -445,8 +471,7 @@ add_library(sandbox2_monitor_ptrace ${SAPI_LIB_TYPE}
 )
 add_library(sandbox2::monitor_ptrace ALIAS sandbox2_monitor_ptrace)
 target_link_libraries(sandbox2_monitor_ptrace
-  PRIVATE absl::core_headers
-          absl::cleanup
+  PRIVATE absl::cleanup
           absl::flat_hash_set
           absl::flags
           absl::log
@@ -455,6 +480,7 @@ target_link_libraries(sandbox2_monitor_ptrace
           absl::str_format
           absl::strings
           absl::time
+          absl::vlog_is_on
           sapi::base
           sapi::config
           sapi::status
@@ -464,15 +490,17 @@ target_link_libraries(sandbox2_monitor_ptrace
           sandbox2::sanitizer
           sandbox2::util
   PUBLIC absl::check
+         absl::core_headers
          sandbox2::executor
          sandbox2::monitor_base
          sandbox2::notify
+         sandbox2::pid_waiter
          sandbox2::policy
          sandbox2::regs
          sandbox2::syscall
+         sapi::thread
          absl::synchronization
          absl::flat_hash_map
-         sapi::raw_logging
 )
 
 # sandboxed_api/sandbox2:monitor_unotify
@@ -492,6 +520,7 @@ target_link_libraries(sandbox2_monitor_unotify
           absl::strings
           absl::time
           sapi::base
+          sandbox2::bpf_evaluator
           sandbox2::client
           sandbox2::forkserver_proto
           sapi::config
@@ -501,10 +530,10 @@ target_link_libraries(sandbox2_monitor_unotify
          sandbox2::notify
          sandbox2::policy
          sandbox2::result
+         sapi::thread
          absl::statusor
          absl::synchronization
          sapi::fileops
-         sapi::raw_logging
 )
 
 # sandboxed_api/sandbox2:policybuilder
@@ -522,8 +551,14 @@ target_link_libraries(sandbox2_policybuilder
           sandbox2::bpf_helper
           sandbox2::namespace
           sandbox2::syscall
-          sandbox2::violation_proto
+          sandbox2::allowlists_all_syscalls
+          sandbox2::allowlists_map_exec
+          sandbox2::allowlists_namespaces
+          sandbox2::allowlists_seccomp_speculation
+          sandbox2::allowlists_trace_all_syscalls
+          sandbox2::allowlists_unrestricted_networking
           sapi::file_base
+          sapi::fileops
           sapi::status
   PUBLIC absl::check
          absl::core_headers
@@ -531,6 +566,7 @@ target_link_libraries(sandbox2_policybuilder
          absl::span
          absl::strings
          absl::statusor
+         sandbox2::forkserver_proto
          sandbox2::mounts
          sandbox2::network_proxy_filtering
          sandbox2::policy
@@ -658,7 +694,7 @@ target_link_libraries(sandbox2_namespace
           sapi::fileops
           sapi::base
           sapi::raw_logging
-  PUBLIC sandbox2::violation_proto
+  PUBLIC sandbox2::forkserver_proto
          sandbox2::mounts
 )
 
@@ -674,7 +710,6 @@ target_link_libraries(sandbox2_forkingclient
           absl::log
           sandbox2::sanitizer
           sapi::base
-          sapi::raw_logging
   PUBLIC sandbox2::client
          sandbox2::comms
          sandbox2::forkserver
@@ -687,7 +722,8 @@ add_library(sandbox2_util ${SAPI_LIB_TYPE}
 )
 add_library(sandbox2::util ALIAS sandbox2_util)
 target_link_libraries(sandbox2_util
-  PRIVATE absl::core_headers
+  PRIVATE absl::algorithm_container
+          absl::core_headers
           absl::str_format
           absl::strings
           sapi::config
@@ -696,7 +732,9 @@ target_link_libraries(sandbox2_util
           sapi::fileops
           sapi::base
           sapi::raw_logging
-  PUBLIC absl::status
+          sapi::status
+  PUBLIC absl::span
+         absl::status
          absl::statusor
 )
 target_compile_options(sandbox2_util PRIVATE
@@ -760,8 +798,7 @@ add_library(sandbox2_comms ${SAPI_LIB_TYPE}
 )
 add_library(sandbox2::comms ALIAS sandbox2_comms)
 target_link_libraries(sandbox2_comms
-  PRIVATE absl::die_if_null
-          absl::status
+  PRIVATE absl::status
           absl::statusor
           absl::str_format
           absl::strings
@@ -776,21 +813,6 @@ target_link_libraries(sandbox2_comms
          sapi::status
 )
 
-# sandboxed_api/sandbox2:violation_proto
-sapi_protobuf_generate_cpp(_sandbox2_violation_pb_cc _sandbox2_violation_pb_h
-  violation.proto
-)
-add_library(sandbox2_violation_proto ${SAPI_LIB_TYPE}
-  ${_sandbox2_violation_pb_cc}
-  ${_sandbox2_violation_pb_h}
-)
-add_library(sandbox2::violation_proto ALIAS sandbox2_violation_proto)
-target_link_libraries(sandbox2_violation_proto PRIVATE
-  protobuf::libprotobuf
-  sandbox2::mount_tree_proto
-  sapi::base
-)
-
 if(BUILD_TESTING AND SAPI_BUILD_TESTING)
   add_subdirectory(testcases)
 
@@ -844,6 +866,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     absl::strings
     sapi::file_base
     sandbox2::mounts
+    sandbox2::mount_tree_proto
     sapi::temp_file
     sapi::testing
     sapi::status_matchers
@@ -866,11 +889,12 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
   )
   target_link_libraries(sandbox2_namespace_test PRIVATE
     absl::check
+    absl::status
     absl::statusor
     absl::strings
-    sandbox2::allow_all_syscalls
-    sandbox2::allow_unrestricted_networking
-    sapi::config
+    sandbox2::allowlists_all_syscalls
+    sandbox2::allowlists_unrestricted_networking
+    sandbox2::allowlists_namespaces
     sapi::fileops
     sandbox2::namespace
     sandbox2::sandbox2
@@ -933,6 +957,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     sandbox2::comms_test_proto
     sapi::status_matchers
     sapi::test_main
+    sapi::thread
   )
   gtest_discover_tests_xcompile(sandbox2_comms_test)
 
@@ -953,7 +978,6 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     sandbox2::forkserver
     sandbox2::forkserver_proto
     sandbox2::sandbox2
-    sapi::raw_logging
     sapi::testing
     sapi::test_main
   )
@@ -995,15 +1019,18 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     OUTPUT_NAME notify_test
   )
   add_dependencies(sandbox2_notify_test
+    sandbox2::testcase_minimal
     sandbox2::testcase_personality
     sandbox2::testcase_pidcomms
   )
   target_link_libraries(sandbox2_notify_test PRIVATE
+    absl::status
     absl::strings
     sandbox2::comms
     sandbox2::regs
     sandbox2::sandbox2
-    sandbox2::trace_all_syscalls
+    sandbox2::allowlists_trace_all_syscalls
+    sapi::status_matchers
     sapi::testing
     sapi::test_main
   )
@@ -1025,6 +1052,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     sandbox2::testcase_minimal
     sandbox2::testcase_minimal_dynamic
     sandbox2::testcase_policy
+    sandbox2::testcase_posix_timers
   )
   target_link_libraries(sandbox2_policy_test PRIVATE
     absl::strings
@@ -1066,6 +1094,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     sapi::testing
     sapi::status_matchers
     sapi::test_main
+    sapi::thread
   )
   gtest_discover_tests_xcompile(sandbox2_sandbox2_test PROPERTIES
     ENVIRONMENT "TEST_TMPDIR=/tmp"
@@ -1107,12 +1136,19 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
   set_target_properties(sandbox2_util_test PROPERTIES
     OUTPUT_NAME util_test
   )
+  add_dependencies(sandbox2_sandbox2_test
+    sandbox2::testcase_util_communicate
+  )
   target_link_libraries(sandbox2_util_test PRIVATE
     sandbox2::util
+    absl::status
     absl::statusor
     absl::strings
+    absl::check
     absl::cleanup
+    absl::span
     sapi::status_matchers
+    sapi::testing
     sapi::test_main
   )
   gtest_discover_tests_xcompile(sandbox2_util_test)
@@ -1135,6 +1171,8 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     absl::status
     absl::strings
     absl::time
+    sandbox2::allowlists_all_syscalls
+    sandbox2::allowlists_namespaces
     sandbox2::global_forkserver
     sandbox2::sandbox2
     sandbox2::stack_trace
@@ -1184,10 +1222,12 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
             absl::log
             absl::status
             absl::statusor
+            sandbox2::allowlists_unrestricted_networking
             sandbox2::bpf_helper
             sandbox2::policy
             sandbox2::policybuilder
-            sandbox2::violation_proto
+            sapi::file_base
+            sapi::fileops
             sapi::testing
             sapi::status_matchers
             sapi::test_main
@@ -1214,6 +1254,25 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     ENVIRONMENT "TEST_SRCDIR=${PROJECT_BINARY_DIR}"
   )
 
+# sandboxed_api/sandbox2:bpf_evaluator_test
+  add_executable(sandbox2_bpf_evaluator_test
+    bpf_evaluator_test.cc
+  )
+  set_target_properties(sandbox2_bpf_evaluator_test PROPERTIES
+    OUTPUT_NAME bpf_evaluator_test
+  )
+  target_link_libraries(sandbox2_bpf_evaluator_test
+    PRIVATE sandbox2::bpf_evaluator
+            sandbox2::bpf_helper
+            absl::status
+            sapi::status_matchers
+            sapi::test_main
+  )
+  gtest_discover_tests_xcompile(sandbox2_bpf_evaluator_test PROPERTIES
+    ENVIRONMENT "TEST_TMPDIR=/tmp"
+    ENVIRONMENT "TEST_SRCDIR=${PROJECT_BINARY_DIR}"
+  )
+
   # sandboxed_api/sandbox2:network_proxy_test
   add_executable(sandbox2_network_proxy_test
     network_proxy_test.cc
@@ -1223,7 +1282,6 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
   )
   target_link_libraries(sandbox2_network_proxy_test
     PRIVATE absl::status
-            absl::strings
             absl::time
             sandbox2::sandbox2
             sandbox2::network_proxy_testing
diff --git a/sandboxed_api/sandbox2/allow_all_syscalls.h b/sandboxed_api/sandbox2/allow_all_syscalls.h
index 8b50608..ff30e39 100644
--- a/sandboxed_api/sandbox2/allow_all_syscalls.h
+++ b/sandboxed_api/sandbox2/allow_all_syscalls.h
@@ -15,13 +15,6 @@
 #ifndef SANDBOXED_API_SANDBOX2_ALLOW_ALL_SYSCALLS_H_
 #define SANDBOXED_API_SANDBOX2_ALLOW_ALL_SYSCALLS_H_
 
-namespace sandbox2 {
-
-class AllowAllSyscalls {
- public:
-  explicit AllowAllSyscalls() = default;
-};
-
-}  // namespace sandbox2
+#include "sandboxed_api/sandbox2/allowlists/all_syscalls.h"  // IWYU pragma: export
 
 #endif  // SANDBOXED_API_SANDBOX2_ALLOW_ALL_SYSCALLS_H_
diff --git a/sandboxed_api/sandbox2/allow_map_exec.h b/sandboxed_api/sandbox2/allow_map_exec.h
new file mode 100644
index 0000000..b4446c2
--- /dev/null
+++ b/sandboxed_api/sandbox2/allow_map_exec.h
@@ -0,0 +1,20 @@
+// Copyright 2025 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOW_MAP_EXEC_H_
+#define SANDBOXED_API_SANDBOX2_ALLOW_MAP_EXEC_H_
+
+#include "sandboxed_api/sandbox2/allowlists/map_exec.h"  // IWYU pragma: export
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOW_MAP_EXEC_H_
diff --git a/sandboxed_api/sandbox2/allow_seccomp_speculation.h b/sandboxed_api/sandbox2/allow_seccomp_speculation.h
new file mode 100644
index 0000000..25f7652
--- /dev/null
+++ b/sandboxed_api/sandbox2/allow_seccomp_speculation.h
@@ -0,0 +1,20 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOW_SECCOMP_SPECULATION_H_
+#define SANDBOXED_API_SANDBOX2_ALLOW_SECCOMP_SPECULATION_H_
+
+#include "sandboxed_api/sandbox2/allowlists/seccomp_speculation.h"  // IWYU pragma: export
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOW_SECCOMP_SPECULATION_H_
diff --git a/sandboxed_api/sandbox2/allow_unrestricted_networking.h b/sandboxed_api/sandbox2/allow_unrestricted_networking.h
index a290636..c59db37 100644
--- a/sandboxed_api/sandbox2/allow_unrestricted_networking.h
+++ b/sandboxed_api/sandbox2/allow_unrestricted_networking.h
@@ -15,13 +15,6 @@
 #ifndef SANDBOXED_API_SANDBOX2_ALLOW_UNRESTRICTED_NETWORKING_H_
 #define SANDBOXED_API_SANDBOX2_ALLOW_UNRESTRICTED_NETWORKING_H_
 
-namespace sandbox2 {
-
-class UnrestrictedNetworking {
- public:
-  explicit UnrestrictedNetworking() = default;
-};
-
-}  // namespace sandbox2
+#include "sandboxed_api/sandbox2/allowlists/unrestricted_networking.h"  // IWYU pragma: export
 
 #endif  // SANDBOXED_API_SANDBOX2_ALLOW_UNRESTRICTED_NETWORKING_H_
diff --git a/sandboxed_api/sandbox2/allowlists/BUILD b/sandboxed_api/sandbox2/allowlists/BUILD
new file mode 100644
index 0000000..670d305
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/BUILD
@@ -0,0 +1,114 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description: Collection of allowlist tokens that are used to visibility
+# restrict features in Sandbox2.
+#
+# In order to restrict these functionalities, you will need to remove the
+# default visibility in a target (currently //visibility:public) with the
+# appropriate visibility list for your targets.
+
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+
+licenses(["notice"])
+
+cc_library(
+    name = "all_syscalls",
+    hdrs = ["all_syscalls.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "testonly_all_syscalls",
+    testonly = True,
+    hdrs = ["all_syscalls.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "map_exec",
+    hdrs = ["map_exec.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "testonly_map_exec",
+    testonly = True,
+    hdrs = ["map_exec.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "seccomp_speculation",
+    hdrs = ["seccomp_speculation.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "testonly_seccomp_speculation",
+    testonly = True,
+    hdrs = ["seccomp_speculation.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "unrestricted_networking",
+    hdrs = ["unrestricted_networking.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "testonly_unrestricted_networking",
+    testonly = True,
+    hdrs = ["unrestricted_networking.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "namespaces",
+    hdrs = ["namespaces.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "testonly_namespaces",
+    testonly = True,
+    hdrs = ["namespaces.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "trace_all_syscalls",
+    hdrs = ["trace_all_syscalls.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "testonly_trace_all_syscalls",
+    testonly = True,
+    hdrs = ["trace_all_syscalls.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
diff --git a/sandboxed_api/sandbox2/allowlists/CMakeLists.txt b/sandboxed_api/sandbox2/allowlists/CMakeLists.txt
new file mode 100644
index 0000000..6a1910f
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/CMakeLists.txt
@@ -0,0 +1,75 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description: Collection of allowlist tokens that are used to visibility
+# restrict features in Sandbox2.
+
+# sandboxed_api/sandbox2/allowlists:all_syscalls
+add_library(sandbox2_allowlists_all_syscalls ${SAPI_LIB_TYPE}
+  all_syscalls.h
+)
+add_library(sandbox2::allowlists_all_syscalls ALIAS sandbox2_allowlists_all_syscalls)
+target_link_libraries(sandbox2_allowlists_all_syscalls PRIVATE
+  sapi::base
+)
+
+# sandboxed_api/sandbox2/allowlists:namespaces
+add_library(sandbox2_allowlists_namespaces ${SAPI_LIB_TYPE}
+  namespaces.h
+)
+add_library(sandbox2::allowlists_namespaces ALIAS
+  sandbox2_allowlists_namespaces)
+target_link_libraries(sandbox2_allowlists_namespaces PRIVATE
+  sapi::base
+)
+
+# sandboxed_api/sandbox2allowlists:map_exec
+add_library(sandbox2_allowlists_map_exec ${SAPI_LIB_TYPE}
+  map_exec.h
+)
+add_library(sandbox2::allowlists_map_exec ALIAS
+  sandbox2_allowlists_map_exec)
+target_link_libraries(sandbox2_allowlists_map_exec PRIVATE
+  sapi::base
+)
+
+# sandboxed_api/sandbox2/allowlists:seccomp_speculation
+add_library(sandbox2_allowlists_seccomp_speculation ${SAPI_LIB_TYPE}
+  seccomp_speculation.h
+)
+add_library(sandbox2::allowlists_seccomp_speculation ALIAS
+  sandbox2_allowlists_seccomp_speculation)
+target_link_libraries(sandbox2_allowlists_seccomp_speculation PRIVATE
+  sapi::base
+)
+
+# sandboxed_api/sandbox2/allowlists:unrestricted_networking
+add_library(sandbox2_allowlists_unrestricted_networking ${SAPI_LIB_TYPE}
+  unrestricted_networking.h
+)
+add_library(sandbox2::allowlists_unrestricted_networking ALIAS
+  sandbox2_allowlists_unrestricted_networking)
+target_link_libraries(sandbox2_allowlists_unrestricted_networking PRIVATE
+  sapi::base
+)
+
+# sandboxed_api/sandbox2/allowlists:trace_all_syscalls
+add_library(sandbox2_allowlists_trace_all_syscalls ${SAPI_LIB_TYPE}
+  trace_all_syscalls.h
+)
+add_library(sandbox2::allowlists_trace_all_syscalls ALIAS
+  sandbox2_allowlists_trace_all_syscalls)
+target_link_libraries(sandbox2_allowlists_trace_all_syscalls PRIVATE
+  sapi::base
+)
diff --git a/sandboxed_api/sandbox2/allowlists/all_syscalls.h b/sandboxed_api/sandbox2/allowlists/all_syscalls.h
new file mode 100644
index 0000000..f0bf96f
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/all_syscalls.h
@@ -0,0 +1,27 @@
+// Copyright 2023 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOWLISTS_ALL_SYSCALLS_H_
+#define SANDBOXED_API_SANDBOX2_ALLOWLISTS_ALL_SYSCALLS_H_
+
+namespace sandbox2 {
+
+class AllowAllSyscalls {
+ public:
+  explicit AllowAllSyscalls() = default;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOWLISTS_ALL_SYSCALLS_H_
diff --git a/sandboxed_api/sandbox2/allowlists/map_exec.h b/sandboxed_api/sandbox2/allowlists/map_exec.h
new file mode 100644
index 0000000..66d979f
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/map_exec.h
@@ -0,0 +1,27 @@
+// Copyright 2025 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOWLISTS_MAP_EXEC_H_
+#define SANDBOXED_API_SANDBOX2_ALLOWLISTS_MAP_EXEC_H_
+
+namespace sandbox2 {
+
+class MapExec {
+ public:
+  explicit MapExec() = default;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOWLISTS_MAP_EXEC_H_
diff --git a/sandboxed_api/sandbox2/allowlists/namespaces.h b/sandboxed_api/sandbox2/allowlists/namespaces.h
new file mode 100644
index 0000000..bc9b838
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/namespaces.h
@@ -0,0 +1,27 @@
+// Copyright 2025 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOWLISTS_NAMESPACES_H_
+#define SANDBOXED_API_SANDBOX2_ALLOWLISTS_NAMESPACES_H_
+
+namespace sandbox2 {
+
+class NamespacesToken {
+ public:
+  explicit NamespacesToken() = default;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOWLISTS_NAMESPACES_H_
diff --git a/sandboxed_api/sandbox2/allowlists/seccomp_speculation.h b/sandboxed_api/sandbox2/allowlists/seccomp_speculation.h
new file mode 100644
index 0000000..79db2d2
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/seccomp_speculation.h
@@ -0,0 +1,27 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOWLISTS_SECCOMP_SPECULATION_H_
+#define SANDBOXED_API_SANDBOX2_ALLOWLISTS_SECCOMP_SPECULATION_H_
+
+namespace sandbox2 {
+
+class SeccompSpeculation {
+ public:
+  explicit SeccompSpeculation() = default;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOWLISTS_SECCOMP_SPECULATION_H_
diff --git a/sandboxed_api/sandbox2/allowlists/trace_all_syscalls.h b/sandboxed_api/sandbox2/allowlists/trace_all_syscalls.h
new file mode 100644
index 0000000..b55d7f9
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/trace_all_syscalls.h
@@ -0,0 +1,27 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOWLISTS_TRACE_ALL_SYSCALLS_H_
+#define SANDBOXED_API_SANDBOX2_ALLOWLISTS_TRACE_ALL_SYSCALLS_H_
+
+namespace sandbox2 {
+
+class TraceAllSyscalls {
+ public:
+  explicit TraceAllSyscalls() = default;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOWLISTS_ALLOW_ALL_SYSCALLS_H_
diff --git a/sandboxed_api/sandbox2/allowlists/unrestricted_networking.h b/sandboxed_api/sandbox2/allowlists/unrestricted_networking.h
new file mode 100644
index 0000000..7054234
--- /dev/null
+++ b/sandboxed_api/sandbox2/allowlists/unrestricted_networking.h
@@ -0,0 +1,27 @@
+// Copyright 2023 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_ALLOWLISTS_UNRESTRICTED_NETWORKING_H_
+#define SANDBOXED_API_SANDBOX2_ALLOWLISTS_UNRESTRICTED_NETWORKING_H_
+
+namespace sandbox2 {
+
+class UnrestrictedNetworking {
+ public:
+  explicit UnrestrictedNetworking() = default;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_ALLOWLISTS_UNRESTRICTED_NETWORKING_H_
diff --git a/sandboxed_api/sandbox2/bpf_evaluator.cc b/sandboxed_api/sandbox2/bpf_evaluator.cc
new file mode 100644
index 0000000..944dde0
--- /dev/null
+++ b/sandboxed_api/sandbox2/bpf_evaluator.cc
@@ -0,0 +1,234 @@
+#include "sandboxed_api/sandbox2/bpf_evaluator.h"
+
+#include <linux/bpf_common.h>
+#include <linux/filter.h>
+#include <linux/seccomp.h>
+
+#include <cstdint>
+#include <cstring>
+#include <limits>
+#include <optional>
+
+#include "absl/status/status.h"
+#include "absl/status/statusor.h"
+#include "absl/strings/str_cat.h"
+#include "absl/types/span.h"
+#include "sandboxed_api/util/status_macros.h"
+
+namespace sandbox2::bpf {
+namespace {
+
+absl::StatusOr<uint32_t> EvaluateAlu(uint16_t op, uint32_t a, uint32_t b) {
+  switch (op) {
+    case BPF_ADD:
+      return a + b;
+    case BPF_SUB:
+      return a - b;
+    case BPF_MUL:
+      return a * b;
+    case BPF_DIV:
+      if (b == 0) {
+        return absl::InvalidArgumentError("Division by zero");
+      }
+      return a / b;
+    case BPF_OR:
+      return a | b;
+    case BPF_AND:
+      return a & b;
+    case BPF_XOR:
+      return a ^ b;
+    case BPF_LSH:
+      return a << b;
+    case BPF_RSH:
+      return a >> b;
+    case BPF_NEG:
+      return -a;
+    default:
+      return absl::InvalidArgumentError("Invalid ALU operation");
+  }
+}
+
+absl::StatusOr<bool> EvaluateCmp(uint16_t cmp, uint32_t a, uint32_t b) {
+  switch (cmp) {
+    case BPF_JEQ:
+      return a == b;
+    case BPF_JGT:
+      return a > b;
+    case BPF_JGE:
+      return a >= b;
+    case BPF_JSET:
+      return (a & b) != 0;
+    default:
+      return absl::InvalidArgumentError("Invalid jump operation");
+  }
+}
+
+class Interpreter {
+ public:
+  Interpreter(absl::Span<const sock_filter> prog,
+              const struct seccomp_data& data)
+      : prog_(prog), data_(data) {}
+  absl::StatusOr<uint32_t> Evaluate();
+
+ private:
+  absl::Status EvaluateSingleInstruction();
+
+  absl::Span<const sock_filter> prog_;
+  const struct seccomp_data& data_;
+  uint32_t pc_;
+  uint32_t accumulator_;
+  uint32_t x_reg_;
+  uint32_t mem_[16];
+  std::optional<uint32_t> result_;
+};
+
+absl::Status Interpreter::EvaluateSingleInstruction() {
+  if (pc_ >= prog_.size()) {
+    return absl::InvalidArgumentError("Out of bounds execution");
+  }
+  const sock_filter& inst = prog_[pc_];
+  uint32_t offset = 0;
+  switch (inst.code) {
+    case BPF_LD | BPF_W | BPF_ABS: {
+      constexpr uint32_t kAlignmentMask = 3;
+      if (inst.k & kAlignmentMask) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Misaligned read (", inst.k, ")"));
+      }
+      if (inst.k + sizeof(accumulator_) > sizeof(data_)) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Out of bounds read (", inst.k, ")"));
+      }
+      memcpy(&accumulator_, &(reinterpret_cast<const char*>(&data_)[inst.k]),
+             sizeof(accumulator_));
+      break;
+    }
+    case BPF_LD | BPF_W | BPF_LEN:
+      accumulator_ = sizeof(struct seccomp_data);
+      break;
+    case BPF_LDX | BPF_W | BPF_LEN:
+      x_reg_ = sizeof(struct seccomp_data);
+      break;
+    case BPF_LD | BPF_IMM:
+      accumulator_ = inst.k;
+      break;
+    case BPF_LDX | BPF_IMM:
+      x_reg_ = inst.k;
+      break;
+    case BPF_MISC | BPF_TAX:
+      x_reg_ = accumulator_;
+      break;
+    case BPF_MISC | BPF_TXA:
+      accumulator_ = x_reg_;
+      break;
+    case BPF_LD | BPF_MEM:
+      if (inst.k >= sizeof(mem_) / sizeof(mem_[0])) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Out of bounds memory load (", inst.k, " >= 16)"));
+      }
+      accumulator_ = mem_[inst.k];
+      break;
+    case BPF_LDX | BPF_MEM:
+      if (inst.k >= sizeof(mem_) / sizeof(mem_[0])) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Out of bounds memory load (", inst.k, " >= 16)"));
+      }
+      x_reg_ = mem_[inst.k];
+      break;
+    case BPF_ST:
+      if (inst.k >= sizeof(mem_) / sizeof(mem_[0])) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Out of bounds memory store (", inst.k, " >= 16)"));
+      }
+      mem_[inst.k] = accumulator_;
+      break;
+    case BPF_STX:
+      if (inst.k >= sizeof(mem_) / sizeof(mem_[0])) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Out of bounds memory store (", inst.k, " >= 16)"));
+      }
+      mem_[inst.k] = x_reg_;
+      break;
+    case BPF_RET | BPF_K:
+      result_ = inst.k;
+      return absl::OkStatus();
+    case BPF_RET | BPF_A:
+      result_ = accumulator_;
+      return absl::OkStatus();
+    case BPF_ALU | BPF_ADD | BPF_K:
+    case BPF_ALU | BPF_SUB | BPF_K:
+    case BPF_ALU | BPF_MUL | BPF_K:
+    case BPF_ALU | BPF_DIV | BPF_K:
+    case BPF_ALU | BPF_AND | BPF_K:
+    case BPF_ALU | BPF_OR | BPF_K:
+    case BPF_ALU | BPF_XOR | BPF_K:
+    case BPF_ALU | BPF_LSH | BPF_K:
+    case BPF_ALU | BPF_RSH | BPF_K:
+    case BPF_ALU | BPF_ADD | BPF_X:
+    case BPF_ALU | BPF_SUB | BPF_X:
+    case BPF_ALU | BPF_MUL | BPF_X:
+    case BPF_ALU | BPF_DIV | BPF_X:
+    case BPF_ALU | BPF_AND | BPF_X:
+    case BPF_ALU | BPF_OR | BPF_X:
+    case BPF_ALU | BPF_XOR | BPF_X:
+    case BPF_ALU | BPF_LSH | BPF_X:
+    case BPF_ALU | BPF_RSH | BPF_X:
+    case BPF_ALU | BPF_NEG: {
+      uint32_t val = BPF_SRC(inst.code) == BPF_K ? inst.k : x_reg_;
+      SAPI_ASSIGN_OR_RETURN(accumulator_,
+                            EvaluateAlu(BPF_OP(inst.code), accumulator_, val));
+      break;
+    }
+    case BPF_JMP | BPF_JA:
+      offset = inst.k;
+      break;
+    case BPF_JMP | BPF_JEQ | BPF_K:
+    case BPF_JMP | BPF_JGE | BPF_K:
+    case BPF_JMP | BPF_JGT | BPF_K:
+    case BPF_JMP | BPF_JSET | BPF_K:
+    case BPF_JMP | BPF_JEQ | BPF_X:
+    case BPF_JMP | BPF_JGE | BPF_X:
+    case BPF_JMP | BPF_JGT | BPF_X:
+    case BPF_JMP | BPF_JSET | BPF_X: {
+      uint32_t val = BPF_SRC(inst.code) == BPF_K ? inst.k : x_reg_;
+      SAPI_ASSIGN_OR_RETURN(bool cond,
+                            EvaluateCmp(BPF_OP(inst.code), accumulator_, val));
+      offset = cond ? inst.jt : inst.jf;
+      break;
+    }
+    default:
+      return absl::InvalidArgumentError(
+          absl::StrCat("Invalid instruction ", inst.code));
+  }
+  if (pc_ > std::numeric_limits<uint32_t>::max() - 1 ||
+      pc_ + 1 >= prog_.size()) {
+    return absl::InvalidArgumentError(
+        "Fall through to out of bounds execution");
+  }
+  pc_ += 1;
+  if (offset != 0 && (pc_ > std::numeric_limits<uint32_t>::max() - offset ||
+                      pc_ + offset >= prog_.size())) {
+    return absl::InvalidArgumentError("Out of bounds jump");
+  }
+  pc_ += offset;
+  return absl::OkStatus();
+}
+
+absl::StatusOr<uint32_t> Interpreter::Evaluate() {
+  pc_ = 0;
+  result_ = std::nullopt;
+  while (!result_.has_value()) {
+    SAPI_RETURN_IF_ERROR(EvaluateSingleInstruction());
+  }
+  return *result_;
+}
+
+}  // namespace
+
+absl::StatusOr<uint32_t> Evaluate(absl::Span<const sock_filter> prog,
+                                  const struct seccomp_data& data) {
+  Interpreter interpreter(prog, data);
+  return interpreter.Evaluate();
+}
+
+}  // namespace sandbox2::bpf
diff --git a/sandboxed_api/sandbox2/bpf_evaluator.h b/sandboxed_api/sandbox2/bpf_evaluator.h
new file mode 100644
index 0000000..256ab53
--- /dev/null
+++ b/sandboxed_api/sandbox2/bpf_evaluator.h
@@ -0,0 +1,22 @@
+#ifndef SANDBOXED_API_SANDBOX2_BPF_EVALUATOR_H_
+#define SANDBOXED_API_SANDBOX2_BPF_EVALUATOR_H_
+
+#include <linux/filter.h>
+#include <linux/seccomp.h>
+
+#include <cstdint>
+
+#include "absl/status/statusor.h"
+#include "absl/types/span.h"
+
+namespace sandbox2::bpf {
+
+// Evaluates a BPF program against a given seccomp_data.
+//
+// Returns the return value of the BPF program.
+absl::StatusOr<uint32_t> Evaluate(absl::Span<const sock_filter> prog,
+                                  const struct seccomp_data& data);
+
+}  // namespace sandbox2::bpf
+
+#endif  // SANDBOXED_API_SANDBOX2_BPF_EVALUATOR_H_
diff --git a/sandboxed_api/sandbox2/bpf_evaluator_test.cc b/sandboxed_api/sandbox2/bpf_evaluator_test.cc
new file mode 100644
index 0000000..7c59c15
--- /dev/null
+++ b/sandboxed_api/sandbox2/bpf_evaluator_test.cc
@@ -0,0 +1,304 @@
+#include "sandboxed_api/sandbox2/bpf_evaluator.h"
+
+#include <linux/filter.h>
+
+#include <cstdint>
+#include <tuple>
+#include <vector>
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "absl/status/status.h"
+#include "sandboxed_api/sandbox2/util/bpf_helper.h"
+#include "sandboxed_api/util/status_matchers.h"
+
+namespace sandbox2::bpf {
+namespace {
+
+using ::testing::Eq;
+
+TEST(EvaluatorTest, SimpleReturn) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {.nr = 1}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, ReturnAcumulator) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_IMM, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_A, 0),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {.nr = 1}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, SimpleJump) {
+  sock_filter prog[] = {
+      LOAD_SYSCALL_NR,
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 1, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {.nr = 1}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+  SAPI_ASSERT_OK_AND_ASSIGN(result, Evaluate(prog, {.nr = 2}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_KILL));
+}
+
+TEST(EvaluatorTest, AbsoluteJump) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_JMP + BPF_JA, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {.nr = 1}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_KILL));
+}
+
+TEST(EvaluatorTest, MemoryOps) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_IMM, 0),
+      BPF_STMT(BPF_LDX + BPF_IMM, 1),
+      BPF_STMT(BPF_STX, 5),
+      BPF_STMT(BPF_LD + BPF_MEM, 5),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 1, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, MemoryOps2) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LDX + BPF_IMM, 1),
+      BPF_STMT(BPF_LD + BPF_IMM, 0),
+      BPF_STMT(BPF_ST, 5),
+      BPF_STMT(BPF_LDX + BPF_MEM, 5),
+      BPF_STMT(BPF_LD + BPF_IMM, 1),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_X, 0, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_KILL));
+}
+
+TEST(EvaluatorTest, Txa) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LDX + BPF_IMM, 1),
+      BPF_STMT(BPF_LD + BPF_IMM, 0),
+      BPF_STMT(BPF_MISC + BPF_TXA, 0),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 1, 0, 2),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_X, 0, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, Tax) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LDX + BPF_IMM, 1),
+      BPF_STMT(BPF_LD + BPF_IMM, 0),
+      BPF_STMT(BPF_MISC + BPF_TAX, 0),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0, 0, 2),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_X, 0, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, LoadLen) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_LEN, 0),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, sizeof(struct seccomp_data), 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, LoadLenX) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LDX + BPF_LEN, 0),
+      BPF_STMT(BPF_LD + BPF_IMM, sizeof(struct seccomp_data)),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_X, 0, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+}
+
+TEST(EvaluatorTest, AllJumps) {
+  std::vector<std::tuple<sock_filter, uint32_t, uint32_t>> jumps = {
+      {BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 1, 0, 1), 1, 2},
+      {BPF_JUMP(BPF_JMP + BPF_JGT + BPF_K, 1, 0, 1), 2, 1},
+      {BPF_JUMP(BPF_JMP + BPF_JGE + BPF_K, 1, 0, 1), 1, 0},
+      {BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K, 3, 0, 1), 2, 12},
+  };
+  for (const auto& [jmp, allow_nr, kill_nr] : jumps) {
+    std::vector<sock_filter> prog = {
+        LOAD_SYSCALL_NR,
+    };
+    prog.push_back(jmp);
+    prog.push_back(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
+    prog.push_back(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL));
+    SAPI_ASSERT_OK_AND_ASSIGN(
+        uint32_t result, Evaluate(prog, {.nr = static_cast<int>(allow_nr)}));
+    EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+    SAPI_ASSERT_OK_AND_ASSIGN(
+        result, Evaluate(prog, {.nr = static_cast<int>(kill_nr)}));
+    EXPECT_THAT(result, Eq(SECCOMP_RET_KILL));
+  }
+}
+
+TEST(EvaluatorTest, Arithmetics) {
+  sock_filter prog[] = {
+      LOAD_SYSCALL_NR,
+      BPF_STMT(BPF_ALU + BPF_NEG, 1),
+      BPF_STMT(BPF_ALU + BPF_ADD + BPF_K, 11),
+      BPF_STMT(BPF_ALU + BPF_SUB + BPF_K, 5),
+      BPF_STMT(BPF_ALU + BPF_MUL + BPF_K, 2),
+      BPF_STMT(BPF_ALU + BPF_DIV + BPF_K, 10),
+      BPF_STMT(BPF_ALU + BPF_OR + BPF_K, 2),
+      BPF_STMT(BPF_ALU + BPF_AND + BPF_K, 1),
+      BPF_STMT(BPF_ALU + BPF_LSH + BPF_K, 4),
+      BPF_STMT(BPF_ALU + BPF_RSH + BPF_K, 1),
+      BPF_STMT(BPF_ALU + BPF_XOR + BPF_K, 17),
+      BPF_STMT(BPF_LDX + BPF_IMM, 2),
+      BPF_STMT(BPF_ALU + BPF_ADD + BPF_X, 1),
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 27, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
+  };
+  SAPI_ASSERT_OK_AND_ASSIGN(uint32_t result, Evaluate(prog, {.nr = 1}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_ALLOW));
+  SAPI_ASSERT_OK_AND_ASSIGN(result, Evaluate(prog, {.nr = 2}));
+  EXPECT_THAT(result, Eq(SECCOMP_RET_KILL));
+}
+
+TEST(EvaluatorTest, InvalidDivision) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_IMM, 1),
+      BPF_STMT(BPF_ALU + BPF_DIV + BPF_K, 0),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(Evaluate(prog, {}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument));
+}
+
+TEST(EvaluatorTest, InvalidAluOp) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_IMM, 1),
+      BPF_STMT(BPF_ALU + 0xe0 + BPF_K, 10),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(Evaluate(prog, {}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Invalid instruction 228"));
+}
+
+TEST(EvaluatorTest, InvalidJump) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_IMM, 1),
+      BPF_JUMP(BPF_JMP + 0xe0 + BPF_K, 1, 0, 0),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(Evaluate(prog, {}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Invalid instruction 229"));
+}
+
+TEST(EvaluatorTest, InvalidInst) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_ST + BPF_X, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(Evaluate(prog, {}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Invalid instruction 10"));
+}
+
+TEST(EvaluatorTest, EmptyProgram) {
+  EXPECT_THAT(Evaluate({}, {.nr = 1}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Out of bounds execution"));
+}
+
+TEST(EvaluatorTest, NoReturn) {
+  sock_filter prog[] = {
+      LOAD_SYSCALL_NR,
+  };
+  EXPECT_THAT(Evaluate(prog, {.nr = 1}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Fall through to out of bounds execution"));
+}
+
+TEST(EvaluatorTest, OutOfBoundsJump) {
+  sock_filter prog[] = {
+      LOAD_SYSCALL_NR,
+      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 1, 0, 1),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(
+      Evaluate(prog, {.nr = 2}),
+      sapi::StatusIs(absl::StatusCode::kInvalidArgument, "Out of bounds jump"));
+}
+
+TEST(EvaluatorTest, OutOfMemoryOps) {
+  std::vector<std::vector<sock_filter>> progs = {
+      {
+          BPF_STMT(BPF_LD + BPF_IMM, 1),
+          BPF_STMT(BPF_ST, 17),
+          BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      },
+      {
+          BPF_STMT(BPF_LDX + BPF_IMM, 1),
+          BPF_STMT(BPF_STX, 17),
+          BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      },
+      {
+          BPF_STMT(BPF_LD + BPF_MEM, 17),
+          BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      },
+      {
+          BPF_STMT(BPF_LDX + BPF_MEM, 17),
+          BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+      },
+  };
+  for (const std::vector<sock_filter>& prog : progs) {
+    EXPECT_THAT(Evaluate(prog, {}),
+                sapi::StatusIs(absl::StatusCode::kInvalidArgument));
+  }
+}
+
+TEST(EvaluatorTest, MisalignedLoad) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 3),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(Evaluate(prog, {}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Misaligned read (3)"));
+}
+
+TEST(EvaluatorTest, OutOfBoundsLoad) {
+  sock_filter prog[] = {
+      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4096),
+      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
+  };
+  EXPECT_THAT(Evaluate(prog, {}),
+              sapi::StatusIs(absl::StatusCode::kInvalidArgument,
+                             "Out of bounds read (4096)"));
+}
+
+}  // namespace
+}  // namespace sandbox2::bpf
diff --git a/sandboxed_api/sandbox2/client.cc b/sandboxed_api/sandbox2/client.cc
index 42953bc..da4ab7e 100644
--- a/sandboxed_api/sandbox2/client.cc
+++ b/sandboxed_api/sandbox2/client.cc
@@ -46,6 +46,8 @@
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/sandbox2/comms.h"
+#include "sandboxed_api/sandbox2/logsink.h"
+#include "sandboxed_api/sandbox2/network_proxy/client.h"
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/sanitizer.h"
 #include "sandboxed_api/sandbox2/syscall.h"
@@ -59,7 +61,8 @@
 namespace sandbox2 {
 namespace {
 
-void InitSeccompUnotify(sock_fprog prog, Comms* comms) {
+void InitSeccompUnotify(sock_fprog prog, Comms* comms,
+                        uint32_t seccomp_extra_flags) {
   // The policy might not allow sending the notify FD.
   // Create a separate thread that won't get the seccomp policy to send the FD.
   // Synchronize with it using plain atomics + seccomp TSYNC, so we don't need
@@ -108,17 +111,18 @@ void InitSeccompUnotify(sock_fprog prog, Comms* comms) {
   prog.len = ABSL_ARRAYSIZE(code);
   prog.filter = code;
   do {
-    result = syscall(
-        __NR_seccomp, SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,
-        reinterpret_cast<uintptr_t>(&prog), internal::kExecveMagic);
+    result =
+        syscall(__NR_seccomp, SECCOMP_SET_MODE_FILTER,
+                SECCOMP_FILTER_FLAG_TSYNC | seccomp_extra_flags,
+                reinterpret_cast<uintptr_t>(&prog), internal::kExecveMagic);
   } while (result == child);
   SAPI_RAW_CHECK(result == 0, "Enabling seccomp filter");
 }
 
-void InitSeccompRegular(sock_fprog prog) {
-  int result =
-      syscall(__NR_seccomp, SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,
-              reinterpret_cast<uintptr_t>(&prog));
+void InitSeccompRegular(sock_fprog prog, uint32_t seccomp_extra_flags) {
+  int result = syscall(__NR_seccomp, SECCOMP_SET_MODE_FILTER,
+                       SECCOMP_FILTER_FLAG_TSYNC | seccomp_extra_flags,
+                       reinterpret_cast<uintptr_t>(&prog));
   SAPI_RAW_PCHECK(result != -1, "setting seccomp filter");
   SAPI_RAW_PCHECK(result == 0,
                   "synchronizing threads using SECCOMP_FILTER_FLAG_TSYNC flag "
@@ -322,15 +326,17 @@ void Client::ApplyPolicyAndBecomeTracee() {
   // want ptrace at the last moment to avoid synchronization deadlocks.
   SAPI_RAW_CHECK(comms_->SendUint32(kClient2SandboxReady),
                  "receiving ready signal from executor");
-  uint32_t ret;  // wait for confirmation
-  SAPI_RAW_CHECK(comms_->RecvUint32(&ret),
+  uint32_t message;  // wait for confirmation
+  SAPI_RAW_CHECK(comms_->RecvUint32(&message),
                  "receving confirmation from executor");
-  if (ret == kSandbox2ClientUnotify) {
-    InitSeccompUnotify(prog, comms_);
+  uint32_t seccomp_extra_flags =
+      allow_speculation_ ? SECCOMP_FILTER_FLAG_SPEC_ALLOW : 0;
+  if (message == kSandbox2ClientUnotify) {
+    InitSeccompUnotify(prog, comms_, seccomp_extra_flags);
   } else {
-    SAPI_RAW_CHECK(ret == kSandbox2ClientDone,
+    SAPI_RAW_CHECK(message == kSandbox2ClientDone,
                    "invalid confirmation from executor");
-    InitSeccompRegular(prog);
+    InitSeccompRegular(prog, seccomp_extra_flags);
   }
 }
 
diff --git a/sandboxed_api/sandbox2/client.h b/sandboxed_api/sandbox2/client.h
index 241728d..36168c4 100644
--- a/sandboxed_api/sandbox2/client.h
+++ b/sandboxed_api/sandbox2/client.h
@@ -35,12 +35,15 @@ class Client {
  public:
   // Client is ready to be sandboxed.
   static constexpr uint32_t kClient2SandboxReady = 0x0A0B0C01;
+
   // Sandbox is ready to monitor the sandboxee.
   static constexpr uint32_t kSandbox2ClientDone = 0x0A0B0C02;
-  // Sandboxe should setup seccomp_unotify and send back the FD.
+
+  // Sandboxee should setup seccomp_unotify and send back the FD.
   static constexpr uint32_t kSandbox2ClientUnotify = 0x0A0B0C03;
 
   explicit Client(Comms* comms);
+  virtual ~Client() = default;
 
   Client(const Client&) = delete;
   Client& operator=(const Client&) = delete;
@@ -109,6 +112,8 @@ class Client {
 
   void PrepareEnvironment(int* preserved_fd = nullptr);
   void EnableSandbox();
+
+  bool allow_speculation_ = false;
 };
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/comms.cc b/sandboxed_api/sandbox2/comms.cc
index 522d0d6..efa809c 100644
--- a/sandboxed_api/sandbox2/comms.cc
+++ b/sandboxed_api/sandbox2/comms.cc
@@ -27,15 +27,15 @@
 #include <syscall.h>
 #include <unistd.h>
 
+#include <algorithm>
 #include <atomic>
 #include <cerrno>
 #include <cstdint>
 #include <cstdlib>
 #include <cstring>
-#include <functional>
 #include <memory>
+#include <optional>
 #include <string>
-#include <utility>
 #include <vector>
 
 #include "absl/base/dynamic_annotations.h"
@@ -60,7 +60,6 @@ class PotentiallyBlockingRegion {
     // Do nothing. Not defaulted to avoid "unused variable" warnings.
   }
 };
-
 namespace {
 
 using sapi::file_util::fileops::FDCloser;
@@ -109,7 +108,7 @@ socklen_t CreateSockaddrUn(const std::string& socket_name, bool abstract_uds,
 }
 }  // namespace
 
-Comms::Comms(int fd, absl::string_view name) : connection_fd_(fd) {
+Comms::Comms(int fd, absl::string_view name) : raw_comms_(RawCommsFdImpl(fd)) {
   // Generate a unique and meaningful socket name for this FD.
   // Note: getpid()/gettid() are non-blocking syscalls.
   if (name.empty()) {
@@ -128,7 +127,7 @@ Comms::Comms(Comms::DefaultConnectionTag) : Comms(GetDefaultCommsFd()) {}
 Comms::~Comms() { Terminate(); }
 
 int Comms::GetConnectionFD() const {
-  return connection_fd_.get();
+  return GetRawComms() == nullptr ? -1 : GetRawComms()->GetConnectionFD();
 }
 
 absl::StatusOr<ListeningComms> ListeningComms::Create(
@@ -204,7 +203,7 @@ absl::StatusOr<Comms> Comms::Connect(const std::string& socket_name,
 void Comms::Terminate() {
   state_ = State::kTerminated;
 
-  connection_fd_.Close();
+  raw_comms_ = std::unique_ptr<RawComms>();
   listening_comms_.reset();
 }
 
@@ -236,17 +235,19 @@ bool Comms::SendTLV(uint32_t tag, size_t length, const void* value) {
       .len = length,
   };
 
-  if (length + sizeof(tl) > kSendTLVTempBufferSize) {
-    if (!Send(&tl, sizeof(tl))) {
-      return false;
-    }
-    return Send(value, length);
-  }
+  const size_t inline_size =
+      std::min(length, kSendTLVTempBufferSize - sizeof(tl));
   uint8_t tlv[kSendTLVTempBufferSize];
   memcpy(tlv, &tl, sizeof(tl));
-  memcpy(reinterpret_cast<uint8_t*>(tlv) + sizeof(tl), value, length);
-
-  return Send(&tlv, sizeof(tl) + length);
+  memcpy(&tlv[sizeof(tl)], value, inline_size);
+  if (!Send(&tlv, sizeof(tl) + inline_size)) {
+    return false;
+  }
+  if (inline_size < length) {
+    return Send(reinterpret_cast<const uint8_t*>(value) + inline_size,
+                length - inline_size);
+  }
+  return true;
 }
 
 bool Comms::RecvString(std::string* v) {
@@ -256,6 +257,7 @@ bool Comms::RecvString(std::string* v) {
   }
 
   if (tag != kTagString) {
+    v->clear();
     SAPI_RAW_LOG(ERROR, "Expected (kTagString == 0x%x), got: 0x%x", kTagString,
                  tag);
     return false;
@@ -329,14 +331,12 @@ bool Comms::RecvFD(int* fd) {
       .msg_flags = 0,
   };
 
-  const auto op = [&msg](int fd) -> ssize_t {
-    PotentiallyBlockingRegion region;
-    // Use syscall, otherwise we would need to allow socketcall() on PPC.
-    return TEMP_FAILURE_RETRY(
-        util::Syscall(__NR_recvmsg, fd, reinterpret_cast<uintptr_t>(&msg), 0));
-  };
-  ssize_t len;
-  len = op(connection_fd_.get());
+  if (GetRawComms() == nullptr) {
+    SAPI_RAW_LOG(ERROR, "RecvFD: connection terminated");
+    return false;
+  }
+
+  ssize_t len = GetRawComms()->RawRecvMsg(&msg);
   if (len < 0) {
     if (IsFatalError(errno)) {
       Terminate();
@@ -412,14 +412,12 @@ bool Comms::SendFD(int fd) {
   msg.msg_controllen = sizeof(fd_msg);
   msg.msg_flags = 0;
 
-  const auto op = [&msg](int fd) -> ssize_t {
-    PotentiallyBlockingRegion region;
-    // Use syscall, otherwise we would need to whitelist socketcall() on PPC.
-    return TEMP_FAILURE_RETRY(
-        util::Syscall(__NR_sendmsg, fd, reinterpret_cast<uintptr_t>(&msg), 0));
-  };
-  ssize_t len;
-  len = op(connection_fd_.get());
+  if (GetRawComms() == nullptr) {
+    SAPI_RAW_LOG(ERROR, "SendFD: connection terminated");
+    return false;
+  }
+
+  ssize_t len = GetRawComms()->RawSendMsg(&msg);
   if (len == -1 && errno == EPIPE) {
     Terminate();
     SAPI_RAW_LOG(ERROR, "sendmsg(SCM_RIGHTS): Peer disconnected");
@@ -475,16 +473,52 @@ bool Comms::SendProtoBuf(const google::protobuf::MessageLite& message) {
 // All methods below are private, for internal use only.
 // *****************************************************************************
 
+int Comms::RawCommsFdImpl::GetConnectionFD() const {
+  return connection_fd_.get();
+}
+
+void Comms::RawCommsFdImpl::MoveToAnotherFd() {
+  SAPI_RAW_CHECK(connection_fd_.get() != -1,
+                 "Cannot move comms fd as it's not connected");
+  FDCloser new_fd(dup(connection_fd_.get()));
+  SAPI_RAW_CHECK(new_fd.get() != -1, "Failed to move comms to another fd");
+  connection_fd_.Swap(new_fd);
+}
+
+ssize_t Comms::RawCommsFdImpl::RawSend(const void* data, size_t len) {
+  PotentiallyBlockingRegion region;
+  return TEMP_FAILURE_RETRY(write(connection_fd_.get(), data, len));
+}
+
+ssize_t Comms::RawCommsFdImpl::RawRecv(void* data, size_t len) {
+  PotentiallyBlockingRegion region;
+  return TEMP_FAILURE_RETRY(read(connection_fd_.get(), data, len));
+}
+
+ssize_t Comms::RawCommsFdImpl::RawSendMsg(const void* msg) {
+  PotentiallyBlockingRegion region;
+  // Use syscall, otherwise we would need to allow socketcall() on PPC.
+  return TEMP_FAILURE_RETRY(util::Syscall(__NR_sendmsg, connection_fd_.get(),
+                                          reinterpret_cast<uintptr_t>(msg), 0));
+}
+
+ssize_t Comms::RawCommsFdImpl::RawRecvMsg(void* msg) {
+  PotentiallyBlockingRegion region;
+  // Use syscall, otherwise we would need to allow socketcall() on PPC.
+  return TEMP_FAILURE_RETRY(util::Syscall(__NR_recvmsg, connection_fd_.get(),
+                                          reinterpret_cast<uintptr_t>(msg), 0));
+}
+
 bool Comms::Send(const void* data, size_t len) {
+  if (GetRawComms() == nullptr) {
+    SAPI_RAW_LOG(ERROR, "Send: connection terminated");
+    return false;
+  }
+
   size_t total_sent = 0;
   const char* bytes = reinterpret_cast<const char*>(data);
-  const auto op = [bytes, len, &total_sent](int fd) -> ssize_t {
-    PotentiallyBlockingRegion region;
-    return TEMP_FAILURE_RETRY(write(fd, &bytes[total_sent], len - total_sent));
-  };
   while (total_sent < len) {
-    ssize_t s;
-      s = op(connection_fd_.get());
+    ssize_t s = GetRawComms()->RawSend(&bytes[total_sent], len - total_sent);
     if (s == -1 && errno == EPIPE) {
       Terminate();
       // We do not expect the other end to disappear.
@@ -510,15 +544,15 @@ bool Comms::Send(const void* data, size_t len) {
 }
 
 bool Comms::Recv(void* data, size_t len) {
+  if (GetRawComms() == nullptr) {
+    SAPI_RAW_LOG(ERROR, "Recv: connection terminated");
+    return false;
+  }
+
   size_t total_recv = 0;
   char* bytes = reinterpret_cast<char*>(data);
-  const auto op = [bytes, len, &total_recv](int fd) -> ssize_t {
-    PotentiallyBlockingRegion region;
-    return TEMP_FAILURE_RETRY(read(fd, &bytes[total_recv], len - total_recv));
-  };
   while (total_recv < len) {
-    ssize_t s;
-      s = op(connection_fd_.get());
+    ssize_t s = GetRawComms()->RawRecv(&bytes[total_recv], len - total_recv);
     if (s == -1) {
       SAPI_RAW_PLOG(ERROR, "read");
       if (IsFatalError(errno)) {
@@ -584,11 +618,16 @@ bool Comms::RecvTLVGeneric(uint32_t* tag, T* value) {
 }
 
 bool Comms::RecvTLV(uint32_t* tag, size_t* length, void* buffer,
-                    size_t buffer_size) {
+                    size_t buffer_size, std::optional<uint32_t> expected_tag) {
   if (!RecvTL(tag, length)) {
     return false;
   }
 
+  if (expected_tag.has_value() && *tag != *expected_tag) {
+    SAPI_RAW_LOG(ERROR, "Expected tag: 0x%08x, got: 0x%x", *expected_tag, *tag);
+    return false;
+  }
+
   if (*length == 0) {
     return true;
   }
@@ -605,14 +644,10 @@ bool Comms::RecvTLV(uint32_t* tag, size_t* length, void* buffer,
 bool Comms::RecvInt(void* buffer, size_t len, uint32_t tag) {
   uint32_t received_tag;
   size_t received_length;
-  if (!RecvTLV(&received_tag, &received_length, buffer, len)) {
+  if (!RecvTLV(&received_tag, &received_length, buffer, len, tag)) {
     return false;
   }
 
-  if (received_tag != tag) {
-    SAPI_RAW_LOG(ERROR, "Expected tag: 0x%08x, got: 0x%x", tag, received_tag);
-    return false;
-  }
   if (received_length != len) {
     SAPI_RAW_LOG(ERROR, "Expected length: %zu, got: %zu", len, received_length);
     return false;
@@ -636,11 +671,9 @@ bool Comms::SendStatus(const absl::Status& status) {
 }
 
 void Comms::MoveToAnotherFd() {
-  SAPI_RAW_CHECK(connection_fd_.get() != -1,
+  SAPI_RAW_CHECK(GetRawComms() != nullptr,
                  "Cannot move comms fd as it's not connected");
-  FDCloser new_fd(dup(connection_fd_.get()));
-  SAPI_RAW_CHECK(new_fd.get() != -1, "Failed to move comms to another fd");
-  connection_fd_.Swap(new_fd);
+  GetRawComms()->MoveToAnotherFd();
 }
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/comms.h b/sandboxed_api/sandbox2/comms.h
index adfe5be..b933737 100644
--- a/sandboxed_api/sandbox2/comms.h
+++ b/sandboxed_api/sandbox2/comms.h
@@ -28,15 +28,15 @@
 
 #include <cstddef>
 #include <cstdint>
-#include <functional>
 #include <limits>
 #include <memory>
+#include <optional>
 #include <string>
 #include <utility>
+#include <variant>
 #include <vector>
 
 #include "absl/base/attributes.h"
-#include "absl/log/die_if_null.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
@@ -145,7 +145,8 @@ class Comms {
   // by std::string.
   bool RecvTLV(uint32_t* tag, std::string* value);
   // Receives a TLV value into a specified buffer without allocating memory.
-  bool RecvTLV(uint32_t* tag, size_t* length, void* buffer, size_t buffer_size);
+  bool RecvTLV(uint32_t* tag, size_t* length, void* buffer, size_t buffer_size,
+               std::optional<uint32_t> expected_tag = std::nullopt);
 
   // Sends/receives various types of data.
   bool RecvUint8(uint8_t* v) { return RecvIntGeneric(v, kTagUint8); }
@@ -195,13 +196,39 @@ class Comms {
     using std::swap;
     swap(name_, other.name_);
     swap(abstract_uds_, other.abstract_uds_);
-    swap(connection_fd_, other.connection_fd_);
+    swap(raw_comms_, other.raw_comms_);
     swap(state_, other.state_);
     swap(listening_comms_, other.listening_comms_);
   }
 
   friend void swap(Comms& x, Comms& y) { return x.Swap(y); }
 
+ protected:
+  class RawComms {
+   public:
+    virtual ~RawComms() {};
+    virtual int GetConnectionFD() const = 0;
+    virtual void MoveToAnotherFd() = 0;
+    virtual ssize_t RawSend(const void* data, size_t len) = 0;
+    virtual ssize_t RawRecv(void* data, size_t len) = 0;
+    virtual ssize_t RawSendMsg(const void* msg) = 0;
+    virtual ssize_t RawRecvMsg(void* msg) = 0;
+  };
+
+  class RawCommsFdImpl : public RawComms {
+   public:
+    RawCommsFdImpl(int fd) : connection_fd_(fd) {}
+    int GetConnectionFD() const override;
+    void MoveToAnotherFd() override;
+    ssize_t RawSend(const void* data, size_t len) override;
+    ssize_t RawRecv(void* data, size_t len) override;
+    ssize_t RawSendMsg(const void* msg) override;
+    ssize_t RawRecvMsg(void* msg) override;
+
+   private:
+    sapi::file_util::fileops::FDCloser connection_fd_;
+  };
+
  private:
   friend class Client;
 
@@ -215,7 +242,7 @@ class Comms {
   // Connection parameters.
   std::string name_;
   bool abstract_uds_ = true;
-  sapi::file_util::fileops::FDCloser connection_fd_;
+  std::variant<std::unique_ptr<RawComms>, RawCommsFdImpl> raw_comms_;
 
   std::unique_ptr<ListeningComms> listening_comms_;
 
@@ -232,6 +259,27 @@ class Comms {
     size_t len;
   };
 
+  Comms(std::unique_ptr<RawComms> raw_comms)
+      : raw_comms_(std::move(raw_comms)) {
+    state_ = State::kConnected;
+  }
+
+  RawComms* GetRawComms() {
+    RawComms* raw_comms = std::get_if<RawCommsFdImpl>(&raw_comms_);
+    if (!raw_comms) {
+      raw_comms = std::get<std::unique_ptr<RawComms>>(raw_comms_).get();
+    }
+    return raw_comms;
+  }
+
+  const RawComms* GetRawComms() const {
+    const RawComms* raw_comms = std::get_if<RawCommsFdImpl>(&raw_comms_);
+    if (!raw_comms) {
+      raw_comms = std::get<std::unique_ptr<RawComms>>(raw_comms_).get();
+    }
+    return raw_comms;
+  }
+
   // Moves the comms fd to an other free file descriptor.
   void MoveToAnotherFd();
 
diff --git a/sandboxed_api/sandbox2/comms_test.cc b/sandboxed_api/sandbox2/comms_test.cc
index 970ba3a..557946c 100644
--- a/sandboxed_api/sandbox2/comms_test.cc
+++ b/sandboxed_api/sandbox2/comms_test.cc
@@ -25,7 +25,6 @@
 #include <functional>
 #include <memory>
 #include <string>
-#include <thread>  // NOLINT(build/c++11)
 #include <vector>
 
 #include "gmock/gmock.h"
@@ -37,15 +36,18 @@
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/sandbox2/comms_test.pb.h"
 #include "sandboxed_api/util/status_matchers.h"
+#include "sandboxed_api/util/thread.h"
+
+namespace sandbox2 {
+namespace {
 
 using ::sapi::IsOk;
 using ::sapi::StatusIs;
 using ::testing::Eq;
+using ::testing::IsEmpty;
 using ::testing::IsFalse;
 using ::testing::IsTrue;
 
-namespace sandbox2 {
-
 using CommunicationHandler = std::function<void(Comms* comms)>;
 
 constexpr char kProtoStr[] = "ABCD";
@@ -63,14 +65,14 @@ void HandleCommunication(const CommunicationHandler& a,
   Comms comms(sv[0]);
 
   // Start handler a.
-  std::thread remote([sv, &a]() {
+  sapi::Thread remote([sv, &a]() {
     Comms my_comms(sv[1]);
     a(&my_comms);
   });
 
   // Accept connection and run handler b.
   b(&comms);
-  remote.join();
+  remote.Join();
 }
 
 TEST(CommsTest, TestSendRecv8) {
@@ -196,13 +198,22 @@ TEST(CommsTest, TestSendRecvArray) {
   };
   auto b = [](Comms* comms) {
     // Send 1M bytes.
-    std::vector<uint8_t> buffer(1024 * 1024);
-    memset(buffer.data(), 0, buffer.size());
+    std::vector<uint8_t> buffer(1024 * 1024, 0);
     ASSERT_THAT(comms->SendBytes(buffer), IsTrue());
   };
   HandleCommunication(a, b);
 }
 
+TEST(CommsTest, TestSendRecvEmptyArray) {
+  auto a = [](Comms* comms) {
+    std::vector<uint8_t> buffer;
+    ASSERT_THAT(comms->RecvBytes(&buffer), IsTrue());
+    EXPECT_THAT(buffer, IsEmpty());
+  };
+  auto b = [](Comms* comms) { ASSERT_THAT(comms->SendBytes({}), IsTrue()); };
+  HandleCommunication(a, b);
+}
+
 TEST(CommsTest, TestSendRecvFD) {
   auto a = [](Comms* comms) {
     // Receive FD and test it.
@@ -210,6 +221,7 @@ TEST(CommsTest, TestSendRecvFD) {
     ASSERT_THAT(comms->RecvFD(&fd), IsTrue());
     EXPECT_GE(fd, 0);
     EXPECT_NE(fcntl(fd, F_GETFD), -1);
+    close(fd);
   };
   auto b = [](Comms* comms) {
     // Send our STDERR to the thread.
@@ -371,4 +383,89 @@ TEST(CommsTest, TestSendRecvBytes) {
   HandleCommunication(a, b);
 }
 
+TEST(CommsTest, SendRecvFailsAfterTerminate) {
+  auto a = [](Comms* comms) {
+    comms->Terminate();
+    ASSERT_THAT(comms->IsTerminated(), IsTrue());
+    EXPECT_THAT(comms->SendInt8(0), IsFalse());
+    EXPECT_THAT(comms->SendFD(STDERR_FILENO), IsFalse());
+    int8_t tmp;
+    EXPECT_THAT(comms->RecvInt8(&tmp), IsFalse());
+    std::string s;
+    EXPECT_THAT(comms->RecvString(&s), IsFalse());
+    std::vector<uint8_t> b;
+    EXPECT_THAT(comms->RecvBytes(&b), IsFalse());
+    int fd;
+    EXPECT_THAT(comms->RecvFD(&fd), IsFalse());
+    CommsTestMsg msg;
+    EXPECT_THAT(comms->RecvProtoBuf(&msg), IsFalse());
+  };
+  auto b = [](Comms* comms) {};
+  HandleCommunication(a, b);
+}
+
+TEST(CommsTest, RecvIntFailsOnTagMismatch) {
+  auto a = [](Comms* comms) {
+    int8_t tmp;
+    EXPECT_THAT(comms->RecvInt8(&tmp), IsFalse());
+  };
+  auto b = [](Comms* comms) { ASSERT_THAT(comms->SendUint8(0), IsTrue()); };
+  HandleCommunication(a, b);
+}
+
+TEST(CommsTest, RecvStringBytesFailsOnTagMismatch) {
+  auto a = [](Comms* comms) {
+    std::string s;
+    EXPECT_THAT(comms->RecvString(&s), IsFalse());
+    EXPECT_THAT(s, IsEmpty());
+    ASSERT_THAT(comms->SendString("hello"), IsTrue());
+  };
+  auto b = [](Comms* comms) {
+    ASSERT_THAT(comms->SendBytes({1, 0}), IsTrue());
+    std::vector<uint8_t> b;
+    EXPECT_THAT(comms->RecvBytes(&b), IsFalse());
+    EXPECT_THAT(b, IsEmpty());
+  };
+  HandleCommunication(a, b);
+}
+
+TEST(CommsTest, RecvFDFailsOnTagMismatch) {
+  auto a = [](Comms* comms) {
+    int fd;
+    EXPECT_THAT(comms->RecvFD(&fd), IsFalse());
+  };
+  auto b = [](Comms* comms) { ASSERT_THAT(comms->SendBytes({}), IsTrue()); };
+  HandleCommunication(a, b);
+}
+
+TEST(CommsTest, RecvProtoBufFailsOnTagMismatch) {
+  auto a = [](Comms* comms) {
+    CommsTestMsg msg;
+    EXPECT_THAT(comms->RecvProtoBuf(&msg), IsFalse());
+  };
+  auto b = [](Comms* comms) {
+    ASSERT_THAT(comms->SendString("hello"), IsTrue());
+  };
+  HandleCommunication(a, b);
+}
+
+TEST(ListeningCommsTest, AbstractSocket) {
+  static constexpr absl::string_view kSocketName = "s2_test_comms";
+  SAPI_ASSERT_OK_AND_ASSIGN(
+      ListeningComms listening_comms,
+      ListeningComms::Create(kSocketName, /*abstract_uds=*/true));
+  sapi::Thread remote([]() {
+    SAPI_ASSERT_OK_AND_ASSIGN(
+        Comms comms,
+        Comms::Connect(std::string(kSocketName), /*abstract_uds=*/true));
+    comms.SendBool(true);
+  });
+  SAPI_ASSERT_OK_AND_ASSIGN(Comms comms, listening_comms.Accept());
+  bool b;
+  ASSERT_THAT(comms.RecvBool(&b), IsTrue());
+  EXPECT_THAT(b, Eq(true));
+  remote.Join();
+}
+
+}  // namespace
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/examples/crc4/BUILD.bazel b/sandboxed_api/sandbox2/examples/crc4/BUILD
similarity index 68%
rename from sandboxed_api/sandbox2/examples/crc4/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/crc4/BUILD
index cb4913f..c7de51b 100644
--- a/sandboxed_api/sandbox2/examples/crc4/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/crc4/BUILD
@@ -19,10 +19,10 @@
 # - Using sandbox2::Comms for data exchange (IPC)
 # - Test to ensure sandbox executor runs sandboxee without issue
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -34,10 +34,6 @@ cc_binary(
     copts = sapi_platform_copts(),
     data = [":crc4bin"],
     deps = [
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:runfiles",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/log",
@@ -45,6 +41,11 @@ cc_binary(
         "@com_google_absl//absl/log:initialize",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:namespaces",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
     ],
 )
 
@@ -54,12 +55,12 @@ cc_binary(
     srcs = ["crc4bin.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2:util",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/strings:string_view",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
     ],
 )
 
@@ -73,10 +74,10 @@ cc_test(
         "no_qemu_user_mode",
     ],
     deps = [
-        "//sandboxed_api:testing",
-        "//sandboxed_api/sandbox2:util",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/log",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
diff --git a/sandboxed_api/sandbox2/examples/crc4/CMakeLists.txt b/sandboxed_api/sandbox2/examples/crc4/CMakeLists.txt
index 0d9e722..e0f85cc 100644
--- a/sandboxed_api/sandbox2/examples/crc4/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/examples/crc4/CMakeLists.txt
@@ -27,6 +27,7 @@ target_link_libraries(sandbox2_crc4sandbox PRIVATE
   absl::log_globals
   absl::log_initialize
   absl::log_severity
+  sandbox2::allowlists_namespaces
   sandbox2::bpf_helper
   sandbox2::comms
   sapi::runfiles
diff --git a/sandboxed_api/sandbox2/examples/crc4/crc4sandbox.cc b/sandboxed_api/sandbox2/examples/crc4/crc4sandbox.cc
index ab39168..13353e2 100644
--- a/sandboxed_api/sandbox2/examples/crc4/crc4sandbox.cc
+++ b/sandboxed_api/sandbox2/examples/crc4/crc4sandbox.cc
@@ -32,6 +32,7 @@
 #include "absl/base/log_severity.h"
 #include "absl/strings/string_view.h"
 #include "absl/time/time.h"
+#include "sandboxed_api/sandbox2/allowlists/namespaces.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/limits.h"
@@ -50,7 +51,8 @@ namespace {
 
 std::unique_ptr<sandbox2::Policy> GetPolicy() {
   return sandbox2::PolicyBuilder()
-      .DisableNamespaces()  // Safe, as we only allow I/O on existing FDs.
+      .DisableNamespaces(sandbox2::NamespacesToken())  // Safe, as we only allow
+                                                       // I/O on existing FDs.
       .AllowExit()
       .AddPolicyOnSyscalls(
           {
diff --git a/sandboxed_api/sandbox2/examples/custom_fork/BUILD.bazel b/sandboxed_api/sandbox2/examples/custom_fork/BUILD
similarity index 71%
rename from sandboxed_api/sandbox2/examples/custom_fork/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/custom_fork/BUILD
index 6703362..abc6a8a 100644
--- a/sandboxed_api/sandbox2/examples/custom_fork/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/custom_fork/BUILD
@@ -16,10 +16,10 @@
 # - create a custom fork-server, which will prepare and fork a sandboxee
 #   from the current process
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -31,17 +31,17 @@ cc_binary(
     copts = sapi_platform_copts(),
     data = [":custom_fork_bin"],
     deps = [
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2:fork_client",
-        "//sandboxed_api/util:runfiles",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/log:globals",
         "@com_google_absl//absl/log:initialize",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:fork_client",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
     ],
 )
 
@@ -51,13 +51,13 @@ cc_binary(
     srcs = ["custom_fork_bin.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2:forkingclient",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/log:globals",
         "@com_google_absl//absl/log:initialize",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:forkingclient",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
diff --git a/sandboxed_api/sandbox2/examples/network/BUILD.bazel b/sandboxed_api/sandbox2/examples/network/BUILD
similarity index 73%
rename from sandboxed_api/sandbox2/examples/network/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/network/BUILD
index 11baced..75cb8c8 100644
--- a/sandboxed_api/sandbox2/examples/network/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/network/BUILD
@@ -18,10 +18,10 @@
 # - strict syscall policy
 # - sandbox2::Comms for data exchange (IPC)
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -33,11 +33,6 @@ cc_binary(
     copts = sapi_platform_copts(),
     data = [":network_bin"],
     deps = [
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/network_proxy:testing",
-        "//sandboxed_api/util:runfiles",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/log",
@@ -46,6 +41,11 @@ cc_binary(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
     ],
 )
 
@@ -55,10 +55,10 @@ cc_binary(
     srcs = ["network_bin.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/strings:str_format",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
     ],
 )
 
diff --git a/sandboxed_api/sandbox2/examples/network_proxy/BUILD.bazel b/sandboxed_api/sandbox2/examples/network_proxy/BUILD
similarity index 71%
rename from sandboxed_api/sandbox2/examples/network_proxy/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/network_proxy/BUILD
index 7f94437..929c059 100644
--- a/sandboxed_api/sandbox2/examples/network_proxy/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/network_proxy/BUILD
@@ -14,10 +14,10 @@
 
 # The 'network proxy' example demonstrates how to use network proxy server.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -29,11 +29,6 @@ cc_binary(
     copts = sapi_platform_copts(),
     data = [":networkproxy_bin"],
     deps = [
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/network_proxy:testing",
-        "//sandboxed_api/util:runfiles",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
@@ -43,6 +38,11 @@ cc_binary(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
     ],
 )
 
@@ -52,11 +52,6 @@ cc_binary(
     srcs = ["networkproxy_bin.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/network_proxy:client",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
@@ -67,6 +62,11 @@ cc_binary(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/strings:string_view",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:client",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
diff --git a/sandboxed_api/sandbox2/examples/network_proxy/networkproxy_bin.cc b/sandboxed_api/sandbox2/examples/network_proxy/networkproxy_bin.cc
index 90ce982..5fbc47b 100644
--- a/sandboxed_api/sandbox2/examples/network_proxy/networkproxy_bin.cc
+++ b/sandboxed_api/sandbox2/examples/network_proxy/networkproxy_bin.cc
@@ -9,6 +9,7 @@
 #include <unistd.h>
 
 #include <cerrno>
+#include <cstdint>
 #include <cstring>
 
 #include "absl/base/log_severity.h"
diff --git a/sandboxed_api/sandbox2/examples/static/BUILD.bazel b/sandboxed_api/sandbox2/examples/static/BUILD
similarity index 76%
rename from sandboxed_api/sandbox2/examples/static/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/static/BUILD
index 917cb62..2805feb 100644
--- a/sandboxed_api/sandbox2/examples/static/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/static/BUILD
@@ -19,10 +19,10 @@
 # - communication with file descriptors and MapFd
 # - test to ensure sandbox executor runs sandboxee without issue
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -35,16 +35,17 @@ cc_binary(
     data = [":static_bin"],
     tags = ["no_qemu_user_mode"],
     deps = [
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:runfiles",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/log:globals",
         "@com_google_absl//absl/log:initialize",
+        "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
     ],
 )
 
@@ -54,9 +55,9 @@ cc_binary(
     name = "static_bin",
     srcs = ["static_bin.cc"],
     copts = sapi_platform_copts(),
-    features = [
-        "-pie",
-        "fully_static_link",  # link libc statically
+    linkopts = [
+        "-static-pie",
+        "-fuse-ld=bfd",
     ],
     linkstatic = 1,
 )
diff --git a/sandboxed_api/sandbox2/examples/static/CMakeLists.txt b/sandboxed_api/sandbox2/examples/static/CMakeLists.txt
index 2fffbfa..0f82cd6 100644
--- a/sandboxed_api/sandbox2/examples/static/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/examples/static/CMakeLists.txt
@@ -43,5 +43,5 @@ set_target_properties(sandbox2_static_bin PROPERTIES OUTPUT_NAME static_bin)
 add_executable(sandbox2::static_bin ALIAS sandbox2_static_bin)
 target_link_libraries(sandbox2_static_bin PRIVATE
   sapi::base
-  -static  # Fully static link
+  -static-pie  # Fully static link
 )
diff --git a/sandboxed_api/sandbox2/examples/static/static_sandbox.cc b/sandboxed_api/sandbox2/examples/static/static_sandbox.cc
index b60458a..175b4e5 100644
--- a/sandboxed_api/sandbox2/examples/static/static_sandbox.cc
+++ b/sandboxed_api/sandbox2/examples/static/static_sandbox.cc
@@ -33,6 +33,7 @@
 #include "absl/log/initialize.h"
 #include "absl/log/log.h"
 #include "absl/base/log_severity.h"
+#include "absl/strings/string_view.h"
 #include "absl/time/time.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/sandbox2/executor.h"
diff --git a/sandboxed_api/sandbox2/examples/tool/BUILD.bazel b/sandboxed_api/sandbox2/examples/tool/BUILD
similarity index 74%
rename from sandboxed_api/sandbox2/examples/tool/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/tool/BUILD
index 3f4c868..7988299 100644
--- a/sandboxed_api/sandbox2/examples/tool/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/tool/BUILD
@@ -20,10 +20,10 @@
 # - set limits, wall time, filesystem checks, asynchronous run
 # - test to ensure sandbox executor runs sandboxee without issue
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -34,11 +34,6 @@ cc_binary(
     srcs = ["sandbox2tool.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2:allow_all_syscalls",
-        "//sandboxed_api/sandbox2:util",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:fileops",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
@@ -50,6 +45,12 @@ cc_binary(
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:all_syscalls",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/allowlists:unrestricted_networking",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
     ],
 )
 
diff --git a/sandboxed_api/sandbox2/examples/tool/CMakeLists.txt b/sandboxed_api/sandbox2/examples/tool/CMakeLists.txt
index 2096ce1..7266cf2 100644
--- a/sandboxed_api/sandbox2/examples/tool/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/examples/tool/CMakeLists.txt
@@ -29,7 +29,8 @@ target_link_libraries(sandbox2_sandbox2tool PRIVATE
   absl::log_severity
   absl::strings
   absl::time
-  sandbox2::allow_all_syscalls
+  sandbox2::allowlists_all_syscalls
+  sandbox2::allowlists_unrestricted_networking
   sandbox2::bpf_helper
   sandbox2::sandbox2
   sandbox2::util
diff --git a/sandboxed_api/sandbox2/examples/tool/sandbox2tool.cc b/sandboxed_api/sandbox2/examples/tool/sandbox2tool.cc
index fdac290..4b9df56 100644
--- a/sandboxed_api/sandbox2/examples/tool/sandbox2tool.cc
+++ b/sandboxed_api/sandbox2/examples/tool/sandbox2tool.cc
@@ -47,7 +47,8 @@
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
 #include "absl/time/time.h"
-#include "sandboxed_api/sandbox2/allow_all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/unrestricted_networking.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/ipc.h"
 #include "sandboxed_api/sandbox2/limits.h"
@@ -167,7 +168,7 @@ int main(int argc, char* argv[]) {
   builder.DefaultAction(sandbox2::AllowAllSyscalls());
 
   if (absl::GetFlag(FLAGS_sandbox2tool_need_networking)) {
-    builder.AllowUnrestrictedNetworking();
+    builder.Allow(sandbox2::UnrestrictedNetworking());
   }
   if (absl::GetFlag(FLAGS_sandbox2tool_mount_tmp)) {
     builder.AddTmpfs("/tmp", /*size=*/4ULL << 20 /* 4 MiB */);
diff --git a/sandboxed_api/sandbox2/examples/zlib/BUILD.bazel b/sandboxed_api/sandbox2/examples/zlib/BUILD
similarity index 78%
rename from sandboxed_api/sandbox2/examples/zlib/BUILD.bazel
rename to sandboxed_api/sandbox2/examples/zlib/BUILD
index cfd71e1..72ce31b 100644
--- a/sandboxed_api/sandbox2/examples/zlib/BUILD.bazel
+++ b/sandboxed_api/sandbox2/examples/zlib/BUILD
@@ -12,10 +12,10 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -27,9 +27,6 @@ cc_binary(
     copts = sapi_platform_copts(),
     data = [":zpipe"],
     deps = [
-        "//sandboxed_api/sandbox2",
-        "//sandboxed_api/sandbox2/util:bpf_helper",
-        "//sandboxed_api/util:runfiles",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
         "@com_google_absl//absl/log",
@@ -38,6 +35,9 @@ cc_binary(
         "@com_google_absl//absl/log:initialize",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:bpf_helper",
+        "@com_google_sandboxed_api//sandboxed_api/util:runfiles",
     ],
 )
 
diff --git a/sandboxed_api/sandbox2/executor.cc b/sandboxed_api/sandbox2/executor.cc
index 00bf884..8bbe651 100644
--- a/sandboxed_api/sandbox2/executor.cc
+++ b/sandboxed_api/sandbox2/executor.cc
@@ -38,9 +38,9 @@
 #include "sandboxed_api/sandbox2/forkserver.pb.h"
 #include "sandboxed_api/sandbox2/global_forkclient.h"
 #include "sandboxed_api/sandbox2/ipc.h"
+#include "sandboxed_api/sandbox2/namespace.h"
 #include "sandboxed_api/sandbox2/util.h"
 #include "sandboxed_api/util/fileops.h"
-#include "sandboxed_api/util/raw_logging.h"
 
 namespace sandbox2 {
 
@@ -85,9 +85,9 @@ std::vector<std::string> Executor::CopyEnviron() {
   return util::CharPtrArray(environ).ToStringVector();
 }
 
-absl::StatusOr<SandboxeeProcess> Executor::StartSubProcess(int32_t clone_flags,
-                                                           const Namespace* ns,
-                                                           MonitorType type) {
+absl::StatusOr<SandboxeeProcess> Executor::StartSubProcess(
+    int32_t clone_flags, const Namespace* ns, bool allow_speculation,
+    MonitorType type) {
   if (started_) {
     return absl::FailedPreconditionError(
         "This executor has already been started");
@@ -96,9 +96,6 @@ absl::StatusOr<SandboxeeProcess> Executor::StartSubProcess(int32_t clone_flags,
   if (!path_.empty()) {
     exec_fd_ = file_util::fileops::FDCloser(open(path_.c_str(), O_PATH));
     if (exec_fd_.get() < 0) {
-      if (errno == ENOENT) {
-        return absl::ErrnoToStatus(errno, path_);
-      }
       return absl::ErrnoToStatus(errno,
                                  absl::StrCat("Could not open file ", path_));
     }
@@ -145,6 +142,7 @@ absl::StatusOr<SandboxeeProcess> Executor::StartSubProcess(int32_t clone_flags,
 
   if (ns) {
     clone_flags |= ns->clone_flags();
+    request.set_netns_mode(ns->netns_config());
     *request.mutable_mount_tree() = ns->mounts().GetMountTree();
     request.set_hostname(ns->hostname());
     request.set_allow_mount_propagation(ns->allow_mount_propagation());
@@ -152,6 +150,7 @@ absl::StatusOr<SandboxeeProcess> Executor::StartSubProcess(int32_t clone_flags,
 
   request.set_clone_flags(clone_flags);
   request.set_monitor_type(type);
+  request.set_allow_speculation(allow_speculation);
 
   SandboxeeProcess process;
 
diff --git a/sandboxed_api/sandbox2/executor.h b/sandboxed_api/sandbox2/executor.h
index 6f0ba0e..fd33311 100644
--- a/sandboxed_api/sandbox2/executor.h
+++ b/sandboxed_api/sandbox2/executor.h
@@ -40,6 +40,7 @@ namespace sandbox2 {
 // The sandbox2::Executor class is responsible for both creating and executing
 // new processes which will be sandboxed.
 class Executor final {
+
  public:
   Executor(const Executor&) = delete;
   Executor& operator=(const Executor&) = delete;
@@ -126,6 +127,7 @@ class Executor final {
   // For clone_flags refer to Linux' 'man 2 clone'.
   absl::StatusOr<SandboxeeProcess> StartSubProcess(
       int clone_flags, const Namespace* ns = nullptr,
+      bool allow_speculation = false,
       MonitorType type = FORKSERVER_MONITOR_PTRACE);
 
   // Whether the Executor has been started yet
diff --git a/sandboxed_api/sandbox2/fork_client.cc b/sandboxed_api/sandbox2/fork_client.cc
index 7ccc22f..fe507ec 100644
--- a/sandboxed_api/sandbox2/fork_client.cc
+++ b/sandboxed_api/sandbox2/fork_client.cc
@@ -16,6 +16,8 @@
 
 #include <sys/types.h>
 
+#include <cstdint>
+
 #include "absl/log/check.h"
 #include "absl/log/log.h"
 #include "absl/synchronization/mutex.h"
diff --git a/sandboxed_api/sandbox2/forkingclient.cc b/sandboxed_api/sandbox2/forkingclient.cc
index a43f576..945e7d1 100644
--- a/sandboxed_api/sandbox2/forkingclient.cc
+++ b/sandboxed_api/sandbox2/forkingclient.cc
@@ -23,7 +23,6 @@
 #include "absl/log/log.h"
 #include "sandboxed_api/sandbox2/forkserver.h"
 #include "sandboxed_api/sandbox2/sanitizer.h"
-#include "sandboxed_api/util/raw_logging.h"
 
 namespace sandbox2 {
 
diff --git a/sandboxed_api/sandbox2/forkserver.cc b/sandboxed_api/sandbox2/forkserver.cc
index c8b381b..6ee13b0 100644
--- a/sandboxed_api/sandbox2/forkserver.cc
+++ b/sandboxed_api/sandbox2/forkserver.cc
@@ -20,7 +20,6 @@
 #include <linux/filter.h>
 #include <linux/seccomp.h>
 #include <sched.h>
-#include <sys/eventfd.h>
 #include <sys/prctl.h>
 #include <sys/resource.h>
 #include <sys/socket.h>
@@ -114,6 +113,17 @@ void MoveFDs(std::initializer_list<std::pair<int*, int>> move_fds,
   }
 }
 
+struct Pipe {
+  FDCloser read;
+  FDCloser write;
+};
+
+Pipe CreatePipe() {
+  int pfds[2];
+  SAPI_RAW_PCHECK(pipe(pfds) == 0, "creating pipe");
+  return {FDCloser(pfds[0]), FDCloser(pfds[1])};
+}
+
 ABSL_ATTRIBUTE_NORETURN void RunInitProcess(pid_t main_pid, FDCloser pipe_fd) {
   if (prctl(PR_SET_NAME, "S2-INIT-PROC", 0, 0, 0) != 0) {
     SAPI_RAW_PLOG(WARNING, "prctl(PR_SET_NAME, 'S2-INIT-PROC')");
@@ -142,8 +152,9 @@ ABSL_ATTRIBUTE_NORETURN void RunInitProcess(pid_t main_pid, FDCloser pipe_fd) {
   }
   code.push_back(DENY);
 
-  struct sock_fprog prog {
-    .len = static_cast<uint16_t>(code.size()), .filter = code.data(),
+  struct sock_fprog prog{
+      .len = static_cast<uint16_t>(code.size()),
+      .filter = code.data(),
   };
 
   SAPI_RAW_CHECK(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == 0,
@@ -164,12 +175,12 @@ ABSL_ATTRIBUTE_NORETURN void RunInitProcess(pid_t main_pid, FDCloser pipe_fd) {
 
     if (info.si_pid == main_pid) {
       if (pipe_fd.get() >= 0) {
-        write(pipe_fd.get(), &info.si_code, sizeof(info.si_code));
-        write(pipe_fd.get(), &info.si_status, sizeof(info.si_status));
+        (void)write(pipe_fd.get(), &info.si_code, sizeof(info.si_code));
+        (void)write(pipe_fd.get(), &info.si_status, sizeof(info.si_status));
 
         rusage usage{};
         getrusage(RUSAGE_CHILDREN, &usage);
-        write(pipe_fd.get(), &usage, sizeof(usage));
+        (void)write(pipe_fd.get(), &usage, sizeof(usage));
       }
       _exit(0);
     }
@@ -193,8 +204,8 @@ absl::StatusOr<pid_t> ReceivePid(int signaling_fd) {
     char ctrl[CMSG_SPACE(sizeof(struct ucred))];
   } ucred_msg{};
 
-  struct msghdr msgh {};
-  struct iovec iov {};
+  struct msghdr msgh{};
+  struct iovec iov{};
 
   msgh.msg_iov = &iov;
   msgh.msg_iovlen = 1;
@@ -323,7 +334,8 @@ void ForkServer::LaunchChild(const ForkRequest& request, int execve_fd,
   signaling_fd.Close();
   status_fd.Close();
 
-  Client c(comms_);
+  Client client(comms_);
+  client.allow_speculation_ = request.allow_speculation();
 
   // Prepare the arguments before sandboxing (if needed), as doing it after
   // sandoxing can cause syscall violations (e.g. related to memory management).
@@ -342,12 +354,12 @@ void ForkServer::LaunchChild(const ForkRequest& request, int execve_fd,
     // The following client calls are basically SandboxMeHere. We split it so
     // that we can set up the envp after we received the file descriptors but
     // before we enable the syscall filter.
-    c.PrepareEnvironment(&execve_fd);
+    client.PrepareEnvironment(&execve_fd);
     if (comms_->GetConnectionFD() != Comms::kSandbox2ClientCommsFD) {
       envs.push_back(absl::StrCat(Comms::kSandbox2CommsFDEnvVar, "=",
                                   comms_->GetConnectionFD()));
     }
-    envs.push_back(c.GetFdMapEnvVar());
+    envs.push_back(client.GetFdMapEnvVar());
   }
 
   // Convert args and envs before enabling sandbox (it'll allocate which might
@@ -356,7 +368,7 @@ void ForkServer::LaunchChild(const ForkRequest& request, int execve_fd,
   util::CharPtrArray envp = util::CharPtrArray::FromStringVector(envs);
 
   if (should_sandbox) {
-    c.EnableSandbox();
+    client.EnableSandbox();
   }
 
   if (will_execve) {
@@ -393,21 +405,16 @@ pid_t ForkServer::ServeRequest() {
   uid_t uid = getuid();
   uid_t gid = getgid();
 
-  FDCloser pipe_fds[2];
-  {
-    int pfds[2] = {-1, -1};
-    if (fork_request.monitor_type() == FORKSERVER_MONITOR_UNOTIFY) {
-      SAPI_RAW_PCHECK(pipe(pfds) == 0, "creating status pipe");
-    }
-    pipe_fds[0] = FDCloser(pfds[0]);
-    pipe_fds[1] = FDCloser(pfds[1]);
+  Pipe pipe_fds;
+  if (fork_request.monitor_type() == FORKSERVER_MONITOR_UNOTIFY) {
+    pipe_fds = CreatePipe();
   }
 
   int socketpair_fds[2];
   SAPI_RAW_PCHECK(
       socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, socketpair_fds) == 0,
       "creating signaling socketpair");
-  for (int i = 0; i < 2; i++) {
+  for (int i = 0; i < 2; ++i) {
     int val = 1;
     SAPI_RAW_PCHECK(setsockopt(socketpair_fds[i], SOL_SOCKET, SO_PASSCRED, &val,
                                sizeof(val)) == 0,
@@ -428,6 +435,10 @@ pid_t ForkServer::ServeRequest() {
     if (initial_mntns_fd_ == -1) {
       CreateInitialNamespaces();
     }
+    if (fork_request.netns_mode() == NETNS_MODE_SHARED_PER_FORKSERVER &&
+        initial_netns_fd_ == -1) {
+      CreateForkserverSharedNetworkNamespace();
+    }
     // We first just fork a child, which will join the initial namespaces
     // Note: Not a regular fork() as one really needs to be single-threaded to
     //       setns and this is not the case with TSAN.
@@ -438,6 +449,11 @@ pid_t ForkServer::ServeRequest() {
                       "joining initial user namespace");
       SAPI_RAW_PCHECK(setns(initial_mntns_fd_, CLONE_NEWNS) != -1,
                       "joining initial mnt namespace");
+      if (fork_request.netns_mode() == NETNS_MODE_SHARED_PER_FORKSERVER) {
+        SAPI_RAW_PCHECK(setns(initial_netns_fd_, CLONE_NEWNET) != -1,
+                        "joining initial net namespace");
+        close(initial_netns_fd_);
+      }
       close(initial_userns_fd_);
       close(initial_mntns_fd_);
       // Do not create new userns it will be unshared later
@@ -468,21 +484,21 @@ pid_t ForkServer::ServeRequest() {
   // Child.
   if (sandboxee_pid == 0) {
     signaling_fds[0].Close();
-    pipe_fds[0].Close();
+    pipe_fds.read.Close();
     // Make sure we override the forkserver's comms fd
     comms_->Terminate();
     if (exec_fd != -1) {
       int signaling_fd = signaling_fds[1].Release();
-      int pipe_fd = pipe_fds[1].Release();
+      int pipe_fd = pipe_fds.write.Release();
       MoveFDs({{&exec_fd, Comms::kSandbox2TargetExecFD},
                {&comms_fd, Comms::kSandbox2ClientCommsFD}},
               {&signaling_fd, &pipe_fd});
       signaling_fds[1] = FDCloser(signaling_fd);
-      pipe_fds[1] = FDCloser(pipe_fd);
+      pipe_fds.write = FDCloser(pipe_fd);
     }
     *comms_ = Comms(comms_fd);
     LaunchChild(fork_request, exec_fd, uid, gid, std::move(signaling_fds[1]),
-                std::move(pipe_fds[1]), avoid_pivot_root);
+                std::move(pipe_fds.write), avoid_pivot_root);
     return sandboxee_pid;
   }
 
@@ -515,7 +531,7 @@ pid_t ForkServer::ServeRequest() {
   }
 
   // Parent.
-  pipe_fds[1].Close();
+  pipe_fds.write.Close();
   close(comms_fd);
   if (exec_fd >= 0) {
     close(exec_fd);
@@ -526,8 +542,8 @@ pid_t ForkServer::ServeRequest() {
       comms_->SendInt32(sandboxee_pid),
       absl::StrCat("Failed to send sandboxee PID: ", sandboxee_pid).c_str());
 
-  if (pipe_fds[0].get() >= 0) {
-    SAPI_RAW_CHECK(comms_->SendFD(pipe_fds[0].get()),
+  if (pipe_fds.read.get() >= 0) {
+    SAPI_RAW_CHECK(comms_->SendFD(pipe_fds.read.get()),
                    "Failed to send status pipe");
   }
   return sandboxee_pid;
@@ -595,10 +611,8 @@ void ForkServer::CreateInitialNamespaces() {
   gid_t gid = getgid();
 
   // Socket to synchronize so that we open ns fds before process dies
-  FDCloser create_efd(eventfd(0, EFD_CLOEXEC));
-  SAPI_RAW_PCHECK(create_efd.get() != -1, "creating eventfd");
-  FDCloser open_efd(eventfd(0, EFD_CLOEXEC));
-  SAPI_RAW_PCHECK(open_efd.get() != -1, "creating eventfd");
+  Pipe create_pipe = CreatePipe();
+  Pipe open_pipe = CreatePipe();
   pid_t pid = util::ForkWithFlags(CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD);
   if (pid == -1 && errno == EPERM && IsLikelyChrooted()) {
     SAPI_RAW_LOG(FATAL,
@@ -606,13 +620,15 @@ void ForkServer::CreateInitialNamespaces() {
                  "likely chrooted");
   }
   SAPI_RAW_PCHECK(pid != -1, "failed to fork initial namespaces process");
-  uint64_t value = 1;
+  char value = ' ';
   if (pid == 0) {
+    create_pipe.read.Close();
+    open_pipe.write.Close();
     Namespace::InitializeInitialNamespaces(uid, gid);
-    SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(write(create_efd.get(), &value,
+    SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(write(create_pipe.write.get(), &value,
                                              sizeof(value))) == sizeof(value),
                     "synchronizing initial namespaces creation");
-    SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(read(open_efd.get(), &value,
+    SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(read(open_pipe.read.get(), &value,
                                             sizeof(value))) == sizeof(value),
                     "synchronizing initial namespaces creation");
     SAPI_RAW_PCHECK(chroot("/realroot") == 0,
@@ -620,7 +636,9 @@ void ForkServer::CreateInitialNamespaces() {
     util::DumpCoverageData();
     _exit(0);
   }
-  SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(read(create_efd.get(), &value,
+  open_pipe.read.Close();
+  create_pipe.write.Close();
+  SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(read(create_pipe.read.get(), &value,
                                           sizeof(value))) == sizeof(value),
                   "synchronizing initial namespaces creation");
   initial_userns_fd_ = open(absl::StrCat("/proc/", pid, "/ns/user").c_str(),
@@ -629,7 +647,41 @@ void ForkServer::CreateInitialNamespaces() {
   initial_mntns_fd_ = open(absl::StrCat("/proc/", pid, "/ns/mnt").c_str(),
                            O_RDONLY | O_CLOEXEC);
   SAPI_RAW_PCHECK(initial_mntns_fd_ != -1, "getting initial mntns fd");
-  SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(write(open_efd.get(), &value,
+  SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(write(open_pipe.write.get(), &value,
+                                           sizeof(value))) == sizeof(value),
+                  "synchronizing initial namespaces creation");
+}
+
+void ForkServer::CreateForkserverSharedNetworkNamespace() {
+  Pipe create_pipe = CreatePipe();
+  Pipe open_pipe = CreatePipe();
+  pid_t pid = util::ForkWithFlags(SIGCHLD);
+  SAPI_RAW_PCHECK(pid != -1, "failed to fork shared netns process");
+  char value = ' ';
+  if (pid == 0) {
+    create_pipe.read.Close();
+    open_pipe.write.Close();
+    SAPI_RAW_PCHECK(setns(initial_userns_fd_, CLONE_NEWUSER) == 0,
+                    "joining initial user namespace");
+    SAPI_RAW_PCHECK(unshare(CLONE_NEWNET) == 0, "unsharing netns");
+    SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(write(create_pipe.write.get(), &value,
+                                             sizeof(value))) == sizeof(value),
+                    "synchronizing shared netns creation");
+    SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(read(open_pipe.read.get(), &value,
+                                            sizeof(value))) == sizeof(value),
+                    "synchronizing shared netns creation");
+    util::DumpCoverageData();
+    _exit(0);
+  }
+  open_pipe.read.Close();
+  create_pipe.write.Close();
+  SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(read(create_pipe.read.get(), &value,
+                                          sizeof(value))) == sizeof(value),
+                  "synchronizing shared netns creation");
+  initial_netns_fd_ = open(absl::StrCat("/proc/", pid, "/ns/net").c_str(),
+                           O_RDONLY | O_CLOEXEC);
+  SAPI_RAW_PCHECK(initial_netns_fd_ != -1, "getting initial netns fd");
+  SAPI_RAW_PCHECK(TEMP_FAILURE_RETRY(write(open_pipe.write.get(), &value,
                                            sizeof(value))) == sizeof(value),
                   "synchronizing initial namespaces creation");
 }
diff --git a/sandboxed_api/sandbox2/forkserver.h b/sandboxed_api/sandbox2/forkserver.h
index fd7b704..579229a 100644
--- a/sandboxed_api/sandbox2/forkserver.h
+++ b/sandboxed_api/sandbox2/forkserver.h
@@ -69,6 +69,9 @@ class ForkServer {
   // Creates initial namespaces used as a template for namespaced sandboxees
   void CreateInitialNamespaces();
 
+  // Creates a network namespace to be shared between sandboxees
+  void CreateForkserverSharedNetworkNamespace();
+
   // Prepares arguments for the upcoming execve (if execve was requested).
   static void PrepareExecveArgs(const ForkRequest& request,
                                 std::vector<std::string>* args,
@@ -90,6 +93,7 @@ class ForkServer {
   Comms* comms_;
   int initial_mntns_fd_ = -1;
   int initial_userns_fd_ = -1;
+  int initial_netns_fd_ = -1;
 };
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/forkserver.proto b/sandboxed_api/sandbox2/forkserver.proto
index 3caffe3..c14daa5 100644
--- a/sandboxed_api/sandbox2/forkserver.proto
+++ b/sandboxed_api/sandbox2/forkserver.proto
@@ -41,6 +41,26 @@ enum MonitorType {
   FORKSERVER_MONITOR_UNOTIFY = 2;
 }
 
+// Enum representing the net_ns mode, used by policybuilder, forkserver, and
+// executor.
+enum NetNsMode {
+  NETNS_MODE_UNSPECIFIED = 0;
+
+  // Create a new netns for each sandbox (default).
+  NETNS_MODE_PER_SANDBOXEE = 1;
+
+  // Do not create a netns.
+  // This will disable the network namespace isolation
+  // from the host and expose its network interfaces to the sandboxee (generally
+  // granting internet access).
+  // Networking syscalls must be allowed in the policy in order to use the
+  // network.
+  NETNS_MODE_NONE = 2;
+
+  // Create a netns shared by all sandboxees started by a forkserver.
+  NETNS_MODE_SHARED_PER_FORKSERVER = 3;
+}
+
 message ForkRequest {
   // List of arguments, starting with argv[0]
   repeated bytes args = 1;
@@ -53,8 +73,7 @@ message ForkRequest {
   // Clone flags for the new process
   optional int32 clone_flags = 4;
 
-  // Capabilities to keep when starting the sandboxee
-  repeated int32 capabilities = 5;
+  reserved 5;
 
   // The mount tree used for namespace initialization
   optional MountTree mount_tree = 6;
@@ -67,4 +86,10 @@ message ForkRequest {
 
   // Monitor type used by the sandbox
   optional MonitorType monitor_type = 9;
+
+  // Whether to allow speculative execution inside the sandboxee
+  optional bool allow_speculation = 10;
+
+  // Net namespace mode
+  optional NetNsMode netns_mode = 11;
 }
diff --git a/sandboxed_api/sandbox2/forkserver_test.cc b/sandboxed_api/sandbox2/forkserver_test.cc
index 1adf207..4208a3c 100644
--- a/sandboxed_api/sandbox2/forkserver_test.cc
+++ b/sandboxed_api/sandbox2/forkserver_test.cc
@@ -29,7 +29,6 @@
 #include "sandboxed_api/sandbox2/global_forkclient.h"
 #include "sandboxed_api/sandbox2/ipc.h"
 #include "sandboxed_api/testing.h"
-#include "sandboxed_api/util/raw_logging.h"
 
 namespace sandbox2 {
 
diff --git a/sandboxed_api/sandbox2/global_forkclient.cc b/sandboxed_api/sandbox2/global_forkclient.cc
index b014931..99783ab 100644
--- a/sandboxed_api/sandbox2/global_forkclient.cc
+++ b/sandboxed_api/sandbox2/global_forkclient.cc
@@ -147,7 +147,7 @@ int LaunchForkserver(void* vargs) {
 absl::StatusOr<std::unique_ptr<GlobalForkClient>> StartGlobalForkServer() {
   SAPI_RAW_LOG(INFO, "Starting global forkserver");
 
-  // Allow passing of a spearate forkserver_bin via flag
+  // Allow passing of a separate forkserver_bin via flag
   int exec_fd = -1;
   std::string bin_path = absl::GetFlag(FLAGS_sandbox2_forkserver_binary_path);
   if (!bin_path.empty()) {
@@ -158,10 +158,6 @@ absl::StatusOr<std::unique_ptr<GlobalForkClient>> StartGlobalForkServer() {
                               "--sandbox2_forkserver_binary_path (",
                               bin_path, ")"));
     }
-  } else if constexpr (sapi::host_os::IsAndroid()) {
-    return absl::FailedPreconditionError(
-        "sandbox2_forkserver_binary_path flag has to be set to the location of "
-        "the forkserver binary on Android");
   }
   if (exec_fd < 0) {
     // Extract the fd when it's owned by EmbedFile
diff --git a/sandboxed_api/sandbox2/ipc.cc b/sandboxed_api/sandbox2/ipc.cc
index 14f1ef8..8b5ffe0 100644
--- a/sandboxed_api/sandbox2/ipc.cc
+++ b/sandboxed_api/sandbox2/ipc.cc
@@ -23,14 +23,13 @@
 #include <string>
 #include <tuple>
 #include <vector>
-#include <thread>
 
 #include "absl/log/log.h"
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/logserver.h"
 #include "sandboxed_api/sandbox2/logsink.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 
@@ -106,8 +105,7 @@ void IPC::EnableLogServer() {
     LogServer log_server(fd);
     log_server.Run();
   };
-  std::thread log_thread{logger};
-  log_thread.detach();
+  sapi::Thread::StartDetachedThread(logger, "LogServer");
 }
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/logsink.cc b/sandboxed_api/sandbox2/logsink.cc
index abbb840..86f2604 100644
--- a/sandboxed_api/sandbox2/logsink.cc
+++ b/sandboxed_api/sandbox2/logsink.cc
@@ -17,7 +17,6 @@
 #include <unistd.h>
 
 #include <csignal>
-#include <cstdio>
 #include <string>
 
 #include "absl/base/log_severity.h"
diff --git a/sandboxed_api/sandbox2/monitor_base.cc b/sandboxed_api/sandbox2/monitor_base.cc
index 76978c9..a9d82b9 100644
--- a/sandboxed_api/sandbox2/monitor_base.cc
+++ b/sandboxed_api/sandbox2/monitor_base.cc
@@ -37,6 +37,7 @@
 #include "absl/flags/flag.h"
 #include "absl/log/check.h"
 #include "absl/log/log.h"
+#include "absl/log/vlog_is_on.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -47,6 +48,7 @@
 #include "sandboxed_api/sandbox2/client.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/executor.h"
+#include "sandboxed_api/sandbox2/forkserver.pb.h"
 #include "sandboxed_api/sandbox2/limits.h"
 #include "sandboxed_api/sandbox2/mounts.h"
 #include "sandboxed_api/sandbox2/namespace.h"
@@ -59,9 +61,9 @@
 #include "sandboxed_api/sandbox2/syscall.h"
 #include "sandboxed_api/sandbox2/util.h"
 #include "sandboxed_api/util/file_helpers.h"
-#include "sandboxed_api/util/raw_logging.h"
 #include "sandboxed_api/util/strerror.h"
 #include "sandboxed_api/util/temp_file.h"
+#include "sandboxed_api/util/thread.h"
 
 ABSL_FLAG(bool, sandbox2_report_on_sandboxee_signal, true,
           "Report sandbox2 sandboxee deaths caused by signals");
@@ -72,8 +74,6 @@ ABSL_FLAG(bool, sandbox2_report_on_sandboxee_timeout, true,
 ABSL_DECLARE_FLAG(bool, sandbox2_danger_danger_permit_all);
 ABSL_DECLARE_FLAG(std::string, sandbox2_danger_danger_permit_all_and_log);
 
-ABSL_DECLARE_FLAG(bool, sandbox_libunwind_crash_handler);
-
 namespace sandbox2 {
 namespace {
 
@@ -157,8 +157,8 @@ MonitorBase::~MonitorBase() {
   if (log_file_) {
     std::fclose(log_file_);
   }
-  if (network_proxy_server_) {
-    network_proxy_thread_.join();
+  if (network_proxy_thread_.IsJoinable()) {
+    network_proxy_thread_.Join();
   }
 }
 
@@ -184,7 +184,7 @@ void MonitorBase::Launch() {
   absl::Cleanup monitor_done = [this] { OnDone(); };
 
   const Namespace* ns = policy_->GetNamespaceOrNull();
-  if (SAPI_VLOG_IS_ON(1) && ns != nullptr) {
+  if (VLOG_IS_ON(1) && ns != nullptr) {
     std::vector<std::string> outside_entries;
     std::vector<std::string> inside_entries;
     ns->mounts().RecursivelyListMounts(
@@ -206,8 +206,8 @@ void MonitorBase::Launch() {
 
   // Get PID of the sandboxee.
   bool should_have_init = ns && (ns->clone_flags() & CLONE_NEWPID);
-  absl::StatusOr<SandboxeeProcess> process =
-      executor_->StartSubProcess(clone_flags, ns, type_);
+  absl::StatusOr<SandboxeeProcess> process = executor_->StartSubProcess(
+      clone_flags, ns, policy_->allow_speculation_, type_);
 
   if (!process.ok()) {
     LOG(ERROR) << "Starting sandboxed subprocess failed: " << process.status();
@@ -269,12 +269,22 @@ void MonitorBase::SetExitStatusCode(Result::StatusEnum final_status,
   result_.SetExitStatusCode(final_status, reason_code);
 }
 
+absl::Status MonitorBase::SendPolicy(const std::vector<sock_filter>& policy) {
+  if (!comms_->SendBytes(reinterpret_cast<const uint8_t*>(policy.data()),
+                         policy.size() * sizeof(sock_filter))) {
+    return absl::InternalError("Error while sending policy via comms");
+  }
+  return absl::OkStatus();
+}
+
 bool MonitorBase::InitSendPolicy() {
-  if (!policy_->SendPolicy(comms_, type_ == FORKSERVER_MONITOR_UNOTIFY)) {
-    LOG(ERROR) << "Couldn't send policy";
+  bool user_notif = type_ == FORKSERVER_MONITOR_UNOTIFY;
+  auto policy = policy_->GetPolicy(user_notif);
+  absl::Status status = SendPolicy(std::move(policy));
+  if (!status.ok()) {
+    LOG(ERROR) << "Couldn't send policy: " << status;
     return false;
   }
-
   return true;
 }
 
@@ -289,11 +299,7 @@ bool MonitorBase::InitSendCwd() {
 
 bool MonitorBase::InitApplyLimit(pid_t pid, int resource,
                                  const rlimit64& rlim) const {
-#if defined(__ANDROID__)
-  using RlimitResource = int;
-#else
   using RlimitResource = __rlimit_resource;
-#endif
 
   rlimit64 curr_limit;
   if (prlimit64(pid, static_cast<RlimitResource>(resource), nullptr,
@@ -333,13 +339,13 @@ bool MonitorBase::InitApplyLimits() {
 bool MonitorBase::InitSendIPC() { return ipc_->SendFdsOverComms(); }
 
 bool MonitorBase::WaitForSandboxReady() {
-  uint32_t tmp;
-  if (!comms_->RecvUint32(&tmp)) {
+  uint32_t message;
+  if (!comms_->RecvUint32(&message)) {
     LOG(ERROR) << "Couldn't receive 'Client::kClient2SandboxReady' message";
     return false;
   }
-  if (tmp != Client::kClient2SandboxReady) {
-    LOG(ERROR) << "Received " << tmp << " != Client::kClient2SandboxReady ("
+  if (message != Client::kClient2SandboxReady) {
+    LOG(ERROR) << "Received " << message << " != Client::kClient2SandboxReady ("
                << Client::kClient2SandboxReady << ")";
     return false;
   }
@@ -359,7 +365,7 @@ void MonitorBase::LogSyscallViolation(const Syscall& syscall) const {
   LOG(ERROR) << "SANDBOX VIOLATION : PID: " << syscall.pid() << ", PROG: '"
              << util::GetProgName(syscall.pid())
              << "' : " << syscall.GetDescription();
-  if (SAPI_VLOG_IS_ON(1)) {
+  if (VLOG_IS_ON(1)) {
     VLOG(1) << "Cmdline: " << util::GetCmdLine(syscall.pid());
     VLOG(1) << "Task Name: " << util::GetProcStatusLine(syscall.pid(), "Name");
     VLOG(1) << "Tgid: " << util::GetProcStatusLine(syscall.pid(), "Tgid");
@@ -401,9 +407,7 @@ void MonitorBase::LogSyscallViolationExplanation(const Syscall& syscall) const {
 bool MonitorBase::StackTraceCollectionPossible() const {
   // Only get the stacktrace if we are not in the libunwind sandbox (avoid
   // recursion).
-  if ((policy_->GetNamespace() ||
-       absl::GetFlag(FLAGS_sandbox_libunwind_crash_handler) == false) &&
-      executor_->libunwind_recursion_depth() <= 1) {
+  if (executor_->libunwind_recursion_depth() <= 1) {
     return true;
   }
   LOG(ERROR) << "Cannot collect stack trace. Unwind pid "
@@ -416,10 +420,12 @@ void MonitorBase::EnableNetworkProxyServer() {
   int fd = ipc_->ReceiveFd(NetworkProxyClient::kFDName);
 
   network_proxy_server_ = std::make_unique<NetworkProxyServer>(
-      fd, &policy_->allowed_hosts_.value(), pthread_self());
+      fd, &policy_->allowed_hosts_.value(),
+      [this] { NotifyNetworkViolation(); });
 
-  network_proxy_thread_ = std::thread(&NetworkProxyServer::Run,
-  network_proxy_server_.get());
+  network_proxy_thread_ =
+      sapi::Thread(network_proxy_server_.get(), &NetworkProxyServer::Run,
+                   "NetworkProxyServer");
 }
 
 bool MonitorBase::ShouldCollectStackTrace(Result::StatusEnum status) const {
diff --git a/sandboxed_api/sandbox2/monitor_base.h b/sandboxed_api/sandbox2/monitor_base.h
index c5296dd..73e68b3 100644
--- a/sandboxed_api/sandbox2/monitor_base.h
+++ b/sandboxed_api/sandbox2/monitor_base.h
@@ -24,10 +24,10 @@
 #include <cstdint>
 #include <cstdio>
 #include <memory>
-#include <thread>
 #include <string>
 #include <vector>
 
+#include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/synchronization/notification.h"
 #include "absl/time/time.h"
@@ -42,6 +42,7 @@
 #include "sandboxed_api/sandbox2/regs.h"
 #include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/sandbox2/syscall.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 
@@ -65,6 +66,9 @@ class MonitorBase {
   // that waits for connection requests from the sandboxee.
   void EnableNetworkProxyServer();
 
+  // Notifies the monitor that a network violation occurred.
+  virtual void NotifyNetworkViolation() = 0;
+
   pid_t pid() const { return process_.main_pid; }
 
   const Result& result() const { return result_; }
@@ -115,8 +119,14 @@ class MonitorBase {
   // Monitor type
   MonitorType type_ = FORKSERVER_MONITOR_PTRACE;
 
- private:
+ protected:
   // Sends Policy to the Client.
+  // Can be overridden by subclasses to save/modify policy before sending.
+  // Returns success/failure status.
+  virtual absl::Status SendPolicy(const std::vector<sock_filter>& policy);
+
+ private:
+  // Instantiates and sends Policy to the Client.
   // Returns success/failure status.
   bool InitSendPolicy();
 
@@ -154,7 +164,7 @@ class MonitorBase {
   // active.
   std::string comms_fd_dev_;
 
-  std::thread network_proxy_thread_;
+  sapi::Thread network_proxy_thread_;
 
   // Is the sandboxee forked from a custom forkserver?
   bool uses_custom_forkserver_;
diff --git a/sandboxed_api/sandbox2/monitor_ptrace.cc b/sandboxed_api/sandbox2/monitor_ptrace.cc
index fac743a..bda5c3a 100644
--- a/sandboxed_api/sandbox2/monitor_ptrace.cc
+++ b/sandboxed_api/sandbox2/monitor_ptrace.cc
@@ -27,7 +27,6 @@
 #include <cerrno>
 #include <cstdint>
 #include <ctime>
-#include <deque>
 #include <fstream>
 #include <ios>
 #include <memory>
@@ -44,6 +43,7 @@
 #include "absl/flags/flag.h"
 #include "absl/log/check.h"
 #include "absl/log/log.h"
+#include "absl/log/vlog_is_on.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -64,13 +64,21 @@
 #include "sandboxed_api/sandbox2/sanitizer.h"
 #include "sandboxed_api/sandbox2/syscall.h"
 #include "sandboxed_api/sandbox2/util.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/sandbox2/util/pid_waiter.h"
 #include "sandboxed_api/util/status_macros.h"
+#include "sandboxed_api/util/thread.h"
 
 ABSL_FLAG(bool, sandbox2_log_all_stack_traces, false,
           "If set, sandbox2 monitor will log stack traces of all monitored "
           "threads/processes that are reported to terminate with a signal.");
 
+ABSL_FLAG(bool, sandbox2_monitor_ptrace_use_deadline_manager, false,
+          "If set, ptrace monitor will use deadline manager to enforce "
+          "deadlines and as notification mechanism");
+
+ABSL_FLAG(bool, sandbox2_log_unobtainable_stack_traces_errors, true,
+          "If set, unobtainable stack trace will be logged as errors.");
+
 ABSL_FLAG(absl::Duration, sandbox2_stack_traces_collection_timeout,
           absl::Seconds(1),
           "How much time should be spent on logging threads' stack traces on "
@@ -82,77 +90,6 @@ ABSL_DECLARE_FLAG(bool, sandbox2_danger_danger_permit_all);
 namespace sandbox2 {
 namespace {
 
-// Since waitpid() is biased towards newer threads, we run the risk of starving
-// older threads if the newer ones raise a lot of events.
-// To avoid it, we use this class to gather all the waiting threads and then
-// return them one at a time on each call to Wait().
-// In this way, everyone gets their chance.
-class PidWaiter {
- public:
-  // Constructs a PidWaiter where the given priority_pid is checked first.
-  explicit PidWaiter(pid_t priority_pid) : priority_pid_(priority_pid) {}
-
-  // Returns the PID of a thread that needs attention, populating 'status' with
-  // the status returned by the waitpid() call. It returns 0 if no threads
-  // require attention at the moment, or -1 if there was an error, in which case
-  // the error value can be found in 'errno'.
-  int Wait(int* status) {
-    RefillStatuses();
-
-    if (statuses_.empty()) {
-      if (last_errno_ == 0) return 0;
-      errno = last_errno_;
-      last_errno_ = 0;
-      return -1;
-    }
-
-    const auto& entry = statuses_.front();
-    pid_t pid = entry.first;
-    *status = entry.second;
-    statuses_.pop_front();
-    return pid;
-  }
-
- private:
-  bool CheckStatus(pid_t pid) {
-    int status;
-    // It should be a non-blocking operation (hence WNOHANG), so this function
-    // returns quickly if there are no events to be processed.
-    pid_t ret =
-        waitpid(pid, &status, __WNOTHREAD | __WALL | WUNTRACED | WNOHANG);
-    if (ret < 0) {
-      last_errno_ = errno;
-      return true;
-    }
-    if (ret == 0) {
-      return false;
-    }
-    statuses_.emplace_back(ret, status);
-    return true;
-  }
-
-  void RefillStatuses() {
-    constexpr int kMaxIterations = 1000;
-    constexpr int kPriorityCheckPeriod = 100;
-    if (!statuses_.empty()) {
-      return;
-    }
-    for (int i = 0; last_errno_ == 0 && i < kMaxIterations; ++i) {
-      bool should_check_priority = (i % kPriorityCheckPeriod) == 0;
-      if (should_check_priority && CheckStatus(priority_pid_)) {
-        return;
-      }
-      if (!CheckStatus(-1)) {
-        break;
-      }
-    }
-  }
-
-  pid_t priority_pid_;
-  std::deque<std::pair<pid_t, int>> statuses_ = {};
-  int last_errno_ = 0;
-};
-
 // We could use the ProcMapsIterator, however we want the full file content.
 std::string ReadProcMaps(pid_t pid) {
   std::ifstream input(absl::StrCat("/proc/", pid, "/maps"),
@@ -210,6 +147,8 @@ PtraceMonitor::PtraceMonitor(Executor* executor, Policy* policy, Notify* notify)
   }
   external_kill_request_flag_.test_and_set(std::memory_order_relaxed);
   dump_stack_request_flag_.test_and_set(std::memory_order_relaxed);
+  use_deadline_manager_ =
+      absl::GetFlag(FLAGS_sandbox2_monitor_ptrace_use_deadline_manager);
 }
 
 bool PtraceMonitor::IsActivelyMonitoring() {
@@ -232,7 +171,9 @@ void PtraceMonitor::SetAdditionalResultInfo(std::unique_ptr<Regs> regs) {
   absl::StatusOr<std::vector<std::string>> stack_trace =
       GetAndLogStackTrace(result_.GetRegs());
   if (!stack_trace.ok()) {
-    LOG(ERROR) << "Could not obtain stack trace: " << stack_trace.status();
+    LOG_IF(ERROR,
+           absl::GetFlag(FLAGS_sandbox2_log_unobtainable_stack_traces_errors))
+        << "Could not obtain stack trace: " << stack_trace.status();
     return;
   }
   result_.set_stack_trace(*stack_trace);
@@ -265,25 +206,31 @@ bool PtraceMonitor::InterruptSandboxee() {
 #define __WPTRACEEVENT(x) ((x & 0xff0000) >> 16)
 
 void PtraceMonitor::NotifyMonitor() {
-  absl::ReaderMutexLock lock(&notify_mutex_);
-  if (thread_ != nullptr) {
-    pthread_kill(thread_->native_handle(), SIGCHLD);
+  if (use_deadline_manager_) {
+    pid_waiter_.Notify();
+  } else {
+    absl::MutexLock lock(&thread_mutex_);
+    if (thread_.IsJoinable()) {
+      pthread_kill(thread_.handle(), SIGCHLD);
+    }
   }
 }
 
 void PtraceMonitor::Join() {
-  absl::MutexLock lock(&notify_mutex_);
-  if (thread_) {
-    thread_->join();
+  absl::MutexLock lock(&thread_mutex_);
+  if (thread_.IsJoinable()) {
+    thread_.Join();
     CHECK(IsDone()) << "Monitor did not terminate";
     VLOG(1) << "Final execution status: " << result_.ToString();
     CHECK(result_.final_status() != Result::UNSET);
-    thread_.reset();
   }
 }
 
 void PtraceMonitor::RunInternal() {
-  thread_ = std::make_unique<std::thread>(&PtraceMonitor::Run, this);
+  {
+    absl::MutexLock lock(&thread_mutex_);
+    thread_ = sapi::Thread(this, &PtraceMonitor::Run, "sandbox2-Monitor");
+  }
 
   // Wait for the Monitor to set-up the sandboxee correctly (or fail while
   // doing that). From here on, it is safe to use the IPC object for
@@ -300,7 +247,7 @@ void PtraceMonitor::Run() {
   absl::Cleanup setup_notify = [this] { setup_notification_.Notify(); };
   // It'd be costly to initialize the sigset_t for each sigtimedwait()
   // invocation, so do it once per Monitor.
-  if (!InitSetupSignals()) {
+  if (!use_deadline_manager_ && !InitSetupSignals()) {
     SetExitStatusCode(Result::SETUP_ERROR, Result::FAILED_SIGNALS);
     return;
   }
@@ -317,7 +264,7 @@ void PtraceMonitor::Run() {
   std::move(setup_notify).Invoke();
 
   bool sandboxee_exited = false;
-  PidWaiter pid_waiter(process_.main_pid);
+  pid_waiter_.SetPriorityPid(process_.main_pid);
   int status;
   // All possible still running children of main process, will be killed due to
   // PTRACE_O_EXITKILL ptrace() flag.
@@ -361,13 +308,21 @@ void PtraceMonitor::Run() {
         break;
       }
     }
-
-    pid_t ret = pid_waiter.Wait(&status);
+    if (use_deadline_manager_) {
+      absl::Time effective_deadline = hard_deadline_;
+      if (deadline != 0 && hard_deadline_ == absl::InfiniteFuture()) {
+        effective_deadline = absl::FromUnixMillis(deadline);
+      }
+      pid_waiter_.SetDeadline(effective_deadline);
+    }
+    pid_t ret = pid_waiter_.Wait(&status);
     if (ret == 0) {
-      constexpr timespec ts = {kWakeUpPeriodSec, kWakeUpPeriodNSec};
-      int signo = sigtimedwait(&sset_, nullptr, &ts);
-      LOG_IF(ERROR, signo != -1 && signo != SIGCHLD)
-          << "Unknown signal received: " << signo;
+      if (!use_deadline_manager_) {
+        constexpr timespec ts = {kWakeUpPeriodSec, kWakeUpPeriodNSec};
+        int signo = sigtimedwait(&sset_, nullptr, &ts);
+        LOG_IF(ERROR, signo != -1 && signo != SIGCHLD)
+            << "Unknown signal received: " << signo;
+      }
       continue;
     }
 
@@ -376,7 +331,7 @@ void PtraceMonitor::Run() {
         LOG(ERROR) << "PANIC(). The main process has not exited yet, "
                    << "yet we haven't seen its exit event";
         SetExitStatusCode(Result::INTERNAL_ERROR, Result::FAILED_CHILD);
-      } else {
+      } else if (!use_deadline_manager_ || errno != EINTR) {
         PLOG(ERROR) << "waitpid() failed";
       }
       continue;
@@ -447,8 +402,14 @@ void PtraceMonitor::Run() {
             << result_.ToString();
         break;
       }
-      pid_t ret = pid_waiter.Wait(&status);
+      if (use_deadline_manager_) {
+        pid_waiter_.SetDeadline(deadline);
+      }
+      pid_t ret = pid_waiter_.Wait(&status);
       if (ret == -1) {
+        if (use_deadline_manager_ && errno == EINTR) {
+          continue;
+        }
         if (!log_stack_traces || ret != ECHILD) {
           PLOG(ERROR) << "waitpid() failed";
         }
@@ -463,8 +424,10 @@ void PtraceMonitor::Run() {
       }
 
       if (ret == 0) {
-        auto ts = absl::ToTimespec(left);
-        sigtimedwait(&sset_, nullptr, &ts);
+        if (!use_deadline_manager_) {
+          auto ts = absl::ToTimespec(left);
+          sigtimedwait(&sset_, nullptr, &ts);
+        }
         continue;
       }
 
@@ -520,87 +483,54 @@ bool PtraceMonitor::InitSetupSignals() {
   return true;
 }
 
-bool PtraceMonitor::InitPtraceAttach() {
-  if (process_.init_pid > 0) {
-    if (ptrace(PTRACE_SEIZE, process_.init_pid, 0, PTRACE_O_EXITKILL) != 0) {
-      if (errno != ESRCH) {
-        PLOG(ERROR) << "attaching to init process failed";
-      }
-      return false;
-    }
-  }
-
-  // Get a list of tasks.
-  absl::flat_hash_set<int> tasks;
-  if (auto task_list = sanitizer::GetListOfTasks(process_.main_pid);
-      task_list.ok()) {
-    tasks = *std::move(task_list);
-  } else {
-    LOG(ERROR) << "Could not get list of tasks: "
-               << task_list.status().message();
-    return false;
-  }
-
-  if (tasks.find(process_.main_pid) == tasks.end()) {
-    LOG(ERROR) << "The pid " << process_.main_pid
-               << " was not found in its own tasklist.";
-    return false;
-  }
-
-  // With TSYNC, we can allow threads: seccomp applies to all threads.
-  if (tasks.size() > 1) {
-    LOG(WARNING) << "PID " << process_.main_pid << " has " << tasks.size()
-                 << " threads,"
-                 << " at the time of call to SandboxMeHere. If you are seeing"
-                 << " more sandbox violations than expected, this might be"
-                 << " the reason why"
-                 << ".";
-  }
+absl::Status TryAttach(const absl::flat_hash_set<int>& tasks,
+                       absl::Time deadline,
+                       absl::flat_hash_set<int>& tasks_attached) {
+  constexpr intptr_t kPtraceOptions =
+      PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK |
+      PTRACE_O_TRACEVFORKDONE | PTRACE_O_TRACECLONE | PTRACE_O_TRACEEXEC |
+      PTRACE_O_TRACEEXIT | PTRACE_O_TRACESECCOMP | PTRACE_O_EXITKILL;
+  auto format_ptrace_error = [](int task, absl::string_view message) {
+    return absl::StrCat("ptrace(PTRACE_SEIZE, ", task, ", 0, ", "0x",
+                        absl::Hex(kPtraceOptions), "): ", message);
+  };
 
-  absl::flat_hash_set<int> tasks_attached;
+  absl::flat_hash_set<int> cur_tasks = tasks;
   int retries = 0;
-  absl::Time deadline = absl::Now() + absl::Seconds(2);
 
   // In some situations we allow ptrace to try again when it fails.
-  while (!tasks.empty()) {
-    absl::flat_hash_set<int> tasks_left;
-    for (int task : tasks) {
-      constexpr intptr_t options =
-          PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK |
-          PTRACE_O_TRACEVFORKDONE | PTRACE_O_TRACECLONE | PTRACE_O_TRACEEXEC |
-          PTRACE_O_TRACEEXIT | PTRACE_O_TRACESECCOMP | PTRACE_O_EXITKILL;
-      int ret = ptrace(PTRACE_SEIZE, task, 0, options);
+  while (!cur_tasks.empty()) {
+    absl::flat_hash_set<int> retry_tasks;
+    for (int task : cur_tasks) {
+      if (tasks_attached.contains(task)) {
+        continue;
+      }
+      int ret = ptrace(PTRACE_SEIZE, task, 0, kPtraceOptions);
       if (ret != 0) {
         if (errno == EPERM) {
           // Sometimes when a task is exiting we can get an EPERM from ptrace.
           // Let's try again up until the timeout in this situation.
-          PLOG(WARNING) << "ptrace(PTRACE_SEIZE, " << task << ", "
-                        << absl::StrCat("0x", absl::Hex(options))
-                        << "), trying again...";
-          tasks_left.insert(task);
+          PLOG(WARNING) << format_ptrace_error(task, "Retrying after EPERM");
+          retry_tasks.insert(task);
           continue;
         }
         if (errno == ESRCH) {
           // A task may have exited since we captured the task list, we will
           // allow things to continue after we log a warning.
-          PLOG(WARNING)
-              << "ptrace(PTRACE_SEIZE, " << task << ", "
-              << absl::StrCat("0x", absl::Hex(options))
-              << ") skipping exited task. Continuing with other tasks.";
+          PLOG(WARNING) << format_ptrace_error(
+              task, "Skipping exited task. Continuing with other tasks.");
           continue;
         }
         // Any other errno will be considered a failure.
-        PLOG(ERROR) << "ptrace(PTRACE_SEIZE, " << task << ", "
-                    << absl::StrCat("0x", absl::Hex(options)) << ") failed.";
-        return false;
+        return absl::ErrnoToStatus(errno, format_ptrace_error(task, "Failure"));
       }
       tasks_attached.insert(task);
     }
-    if (!tasks_left.empty()) {
-      if (absl::Now() < deadline) {
-        LOG(ERROR) << "Attaching to sandboxee timed out: could not attach to "
-                   << tasks_left.size() << " tasks";
-        return false;
+    if (!retry_tasks.empty()) {
+      if (absl::Now() >= deadline) {
+        return absl::DeadlineExceededError(absl::StrCat(
+            "Attaching to sandboxee timed out: could not attach to ",
+            cur_tasks.size(), " tasks"));
       }
       // Exponential Backoff.
       constexpr absl::Duration kInitialRetry = absl::Milliseconds(1);
@@ -610,23 +540,74 @@ bool PtraceMonitor::InitPtraceAttach() {
       absl::SleepFor(
           std::min({retry_interval, kMaxRetry, deadline - absl::Now()}));
     }
-    tasks = std::move(tasks_left);
+    cur_tasks = std::move(retry_tasks);
   }
 
-  // Get a list of tasks after attaching.
-  if (auto tasks_list = sanitizer::GetListOfTasks(process_.main_pid);
-      tasks_list.ok()) {
-    tasks = *std::move(tasks_list);
-  } else {
-    LOG(ERROR) << "Could not get list of tasks: "
-               << tasks_list.status().message();
+  return absl::OkStatus();
+}
+
+bool PtraceMonitor::InitPtraceAttach() {
+  if (process_.init_pid > 0) {
+    if (ptrace(PTRACE_SEIZE, process_.init_pid, 0, PTRACE_O_EXITKILL) != 0) {
+      if (errno != ESRCH) {
+        PLOG(ERROR) << "attaching to init process failed";
+      }
+      return false;
+    }
+  }
+
+  // Get a list of tasks.
+  absl::StatusOr<absl::flat_hash_set<int>> tasks =
+      sanitizer::GetListOfTasks(process_.main_pid);
+  if (!tasks.ok()) {
+    LOG(ERROR) << "Could not get list of tasks: " << tasks.status().message();
     return false;
   }
 
-  // Check that we attached to all the threads
-  if (tasks_attached != tasks) {
+  if (!tasks->contains(process_.main_pid)) {
     LOG(ERROR) << "The pid " << process_.main_pid
-               << " spawned new threads while we were trying to attach to it.";
+               << " was not found in its own tasklist.";
+    return false;
+  }
+
+  // With TSYNC, we can allow threads: seccomp applies to all threads.
+  if (tasks->size() > 1) {
+    LOG(WARNING) << "PID " << process_.main_pid << " has " << tasks->size()
+                 << " threads, at the time of call to SandboxMeHere(). If you "
+                    "are seeing more sandbox violations than expected, this "
+                    "might be the reason why"
+                 << ".";
+  }
+
+  absl::flat_hash_set<int> tasks_attached;
+  absl::Time deadline = absl::Now() + absl::Seconds(4);
+
+  constexpr int kMaxRetries = 3;
+  for (int retries = 0; retries < kMaxRetries && *tasks != tasks_attached;
+       ++retries) {
+    if (retries > 0) {
+      LOG(ERROR) << "PID " << process_.main_pid
+                 << " spawned new threads while we were trying to attach to it "
+                    "(attempt "
+                 << retries << "/" << kMaxRetries << ")";
+    }
+    if (absl::Status status = TryAttach(*tasks, deadline, tasks_attached);
+        !status.ok()) {
+      LOG(ERROR) << status.message();
+      return false;
+    }
+
+    // Get a list of tasks after attaching.
+    tasks = sanitizer::GetListOfTasks(process_.main_pid);
+    if (!tasks.ok()) {
+      LOG(ERROR) << "Could not get list of tasks: " << tasks.status().message();
+      return false;
+    }
+  }
+  if (*tasks != tasks_attached) {
+    LOG(ERROR) << "PID " << process_.main_pid
+               << " spawned new threads while we were trying to attach to it "
+                  "(retries exhausted)";
     return false;
   }
 
@@ -652,9 +633,8 @@ bool PtraceMonitor::InitPtraceAttach() {
 void PtraceMonitor::ActionProcessSyscall(Regs* regs, const Syscall& syscall) {
   // If the sandboxing is not enabled yet, allow the first __NR_execveat.
   if (syscall.nr() == __NR_execveat && !IsActivelyMonitoring()) {
-    VLOG(1) << "[PERMITTED/BEFORE_EXECVEAT]: "
-            << "SYSCALL ::: PID: " << regs->pid() << ", PROG: '"
-            << util::GetProgName(regs->pid())
+    VLOG(1) << "[PERMITTED/BEFORE_EXECVEAT]: " << "SYSCALL ::: PID: "
+            << regs->pid() << ", PROG: '" << util::GetProgName(regs->pid())
             << "' : " << syscall.GetDescription();
     ContinueProcess(regs->pid(), 0);
     return;
@@ -688,7 +668,7 @@ void PtraceMonitor::ActionProcessSyscall(Regs* regs, const Syscall& syscall) {
     return;
   }
 
-  ActionProcessSyscallViolation(regs, syscall, kSyscallViolation);
+  ActionProcessSyscallViolation(regs, syscall, ViolationType::kSyscall);
 }
 
 void PtraceMonitor::ActionProcessSyscallViolation(
@@ -739,7 +719,8 @@ void PtraceMonitor::EventPtraceSeccomp(pid_t pid, int event_msg) {
   // If the architecture of the syscall used is different that the current host
   // architecture, report a violation.
   if (syscall_arch != Syscall::GetHostArch()) {
-    ActionProcessSyscallViolation(&regs, syscall, kArchitectureSwitchViolation);
+    ActionProcessSyscallViolation(&regs, syscall,
+                                  ViolationType::kArchitectureSwitch);
     return;
   }
 
@@ -856,8 +837,9 @@ void PtraceMonitor::EventPtraceExit(pid_t pid, int event_msg) {
   // Process signaled due to seccomp violation.
   if (is_seccomp) {
     VLOG(1) << "PID: " << pid << " violation uncovered via the EXIT_EVENT";
-    ActionProcessSyscallViolation(
-        regs.get(), regs->ToSyscall(Syscall::GetHostArch()), kSyscallViolation);
+    ActionProcessSyscallViolation(regs.get(),
+                                  regs->ToSyscall(Syscall::GetHostArch()),
+                                  ViolationType::kSyscall);
     return;
   }
 
@@ -949,7 +931,7 @@ void PtraceMonitor::StateProcessStopped(pid_t pid, int status) {
 
     if (!stack_trace.ok()) {
       LOG(WARNING) << "FAILED TO GET SANDBOX STACK : " << stack_trace.status();
-    } else if (SAPI_VLOG_IS_ON(0)) {
+    } else if (VLOG_IS_ON(0)) {
       VLOG(0) << "SANDBOX STACK: PID: " << pid << ", [";
       for (const auto& frame : *stack_trace) {
         VLOG(0) << "  " << frame;
@@ -959,10 +941,6 @@ void PtraceMonitor::StateProcessStopped(pid_t pid, int status) {
     should_dump_stack_ = false;
   }
 
-#ifndef PTRACE_EVENT_STOP
-#define PTRACE_EVENT_STOP 128
-#endif
-
   if (is_syscall_exit) {
     VLOG(2) << "PID: " << pid << " syscall-exit-stop: " << event_msg;
     EventSyscallExit(pid);
diff --git a/sandboxed_api/sandbox2/monitor_ptrace.h b/sandboxed_api/sandbox2/monitor_ptrace.h
index 0c9570a..25abecd 100644
--- a/sandboxed_api/sandbox2/monitor_ptrace.h
+++ b/sandboxed_api/sandbox2/monitor_ptrace.h
@@ -21,8 +21,8 @@
 #include <atomic>
 #include <cstdint>
 #include <memory>
-#include <thread>
 
+#include "absl/base/thread_annotations.h"
 #include "absl/container/flat_hash_map.h"
 #include "absl/log/log.h"
 #include "absl/synchronization/mutex.h"
@@ -35,7 +35,8 @@
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/regs.h"
 #include "sandboxed_api/sandbox2/syscall.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/sandbox2/util/pid_waiter.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 
@@ -63,6 +64,7 @@ class PtraceMonitor : public MonitorBase {
       absl::Time deadline = absl::Now() + limit;
       deadline_millis_.store(absl::ToUnixMillis(deadline),
                              std::memory_order_relaxed);
+      NotifyMonitor();
     }
   }
 
@@ -76,6 +78,8 @@ class PtraceMonitor : public MonitorBase {
   void Join() override;
   void Run();
 
+  void NotifyNetworkViolation() override { NotifyMonitor(); }
+
   // Notifies monitor about a state change
   void NotifyMonitor();
 
@@ -119,11 +123,11 @@ class PtraceMonitor : public MonitorBase {
   void EventSyscallExit(pid_t pid);
 
   // Kills the main traced PID with PTRACE_KILL.
-  // Returns false if an error occured and process could not be killed.
+  // Returns false if an error occurred and process could not be killed.
   bool KillSandboxee();
 
   // Interrupts the main traced PID with PTRACE_INTERRUPT.
-  // Returns false if an error occured and process could not be interrupted.
+  // Returns false if an error occurred and process could not be interrupted.
   bool InterruptSandboxee();
 
   // Sets up required signal masks/handlers; prepare mask for sigtimedwait().
@@ -158,12 +162,15 @@ class PtraceMonitor : public MonitorBase {
   sigset_t sset_;
   // Deadline after which sandboxee get terminated via PTRACE_O_EXITKILL.
   absl::Time hard_deadline_ = absl::InfiniteFuture();
+  // PidWaiter for waiting for sandboxee events.
+  PidWaiter pid_waiter_;
+  // Whether to use deadline manager for deadline enforcement and notifications.
+  bool use_deadline_manager_ = false;
 
+  // Synchronizes joining the monitor thread.
+  absl::Mutex thread_mutex_;
   // Monitor thread object.
-  std::unique_ptr<std::thread> thread_;
-
-  // Synchronizes monitor thread deletion and notifying the monitor.
-  absl::Mutex notify_mutex_;
+  sapi::Thread ABSL_GUARDED_BY(thread_mutex_) thread_;
 };
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/monitor_unotify.cc b/sandboxed_api/sandbox2/monitor_unotify.cc
index cbf3a0c..4b25fc0 100644
--- a/sandboxed_api/sandbox2/monitor_unotify.cc
+++ b/sandboxed_api/sandbox2/monitor_unotify.cc
@@ -37,6 +37,7 @@
 #include "absl/time/time.h"
 #include "absl/types/span.h"
 #include "sandboxed_api/config.h"
+#include "sandboxed_api/sandbox2/bpf_evaluator.h"
 #include "sandboxed_api/sandbox2/client.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/forkserver.pb.h"
@@ -46,7 +47,17 @@
 #include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/status_macros.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/util/thread.h"
+
+#ifndef SECCOMP_RET_USER_NOTIF
+#define SECCOMP_RET_USER_NOTIF 0x7fc00000U /* notifies userspace */
+#endif
+
+#ifndef SECCOMP_USER_NOTIF_FLAG_CONTINUE
+#define SECCOMP_USER_NOTIF_FLAG_CONTINUE 1
+#endif
+
+#define DO_USER_NOTIF BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_USER_NOTIF)
 
 #ifndef SECCOMP_GET_NOTIF_SIZES
 #define SECCOMP_GET_NOTIF_SIZES 3
@@ -65,8 +76,9 @@ struct seccomp_notif_sizes {
 #define SECCOMP_IOWR(nr, type) _IOWR(SECCOMP_IOC_MAGIC, nr, type)
 #endif
 
-/* Flags for seccomp notification fd ioctl. */
+// Flags for seccomp notification fd ioctl.
 #define SECCOMP_IOCTL_NOTIF_RECV SECCOMP_IOWR(0, struct seccomp_notif)
+#define SECCOMP_IOCTL_NOTIF_SEND SECCOMP_IOWR(1, struct seccomp_notif_resp)
 #endif
 
 namespace sandbox2 {
@@ -162,7 +174,7 @@ UnotifyMonitor::UnotifyMonitor(Executor* executor, Policy* policy,
 }
 
 void UnotifyMonitor::RunInternal() {
-  thread_ = std::make_unique<std::thread>(&UnotifyMonitor::Run, this);
+  thread_ = sapi::Thread(this, &UnotifyMonitor::Run, "sandbox2-Monitor");
 
   // Wait for the Monitor to set-up the sandboxee correctly (or fail while
   // doing that). From here on, it is safe to use the IPC object for
@@ -170,6 +182,52 @@ void UnotifyMonitor::RunInternal() {
   setup_notification_.WaitForNotification();
 }
 
+absl::Status UnotifyMonitor::SendPolicy(
+    const std::vector<sock_filter>& policy) {
+  original_policy_ = policy;
+  std::vector<sock_filter> modified_policy = policy;
+  const sock_filter trace_action = SANDBOX2_TRACE;
+  for (sock_filter& filter : modified_policy) {
+    if ((filter.code == BPF_RET + BPF_K && filter.k == SECCOMP_RET_KILL) ||
+        (filter.code == trace_action.code && filter.k == trace_action.k)) {
+      filter = DO_USER_NOTIF;
+    }
+  }
+  return MonitorBase::SendPolicy(modified_policy);
+}
+
+void UnotifyMonitor::HandleViolation(const Syscall& syscall) {
+  ViolationType violation_type = syscall.arch() == Syscall::GetHostArch()
+                                     ? ViolationType::kSyscall
+                                     : ViolationType::kArchitectureSwitch;
+  LogSyscallViolation(syscall);
+  notify_->EventSyscallViolation(syscall, violation_type);
+  MaybeGetStackTrace(req_->pid, Result::VIOLATION);
+  SetExitStatusCode(Result::VIOLATION, syscall.nr());
+  notify_->EventSyscallViolation(syscall, violation_type);
+  result_.SetSyscall(std::make_unique<Syscall>(syscall));
+  KillSandboxee();
+}
+
+void UnotifyMonitor::AllowSyscallViaUnotify() {
+  memset(resp_.get(), 0, resp_size_);
+  resp_->id = req_->id;
+  resp_->val = 0;
+  resp_->error = 0;
+  resp_->flags = SECCOMP_USER_NOTIF_FLAG_CONTINUE;
+  if (ioctl(seccomp_notify_fd_.get(), SECCOMP_IOCTL_NOTIF_SEND, resp_.get()) !=
+      0) {
+    if (errno == ENOENT) {
+      VLOG(1) << "Unotify send failed with ENOENT";
+    } else {
+      LOG_IF(ERROR, errno == EINVAL)
+          << "Unotify send failed with EINVAL. Likely "
+             "SECCOMP_USER_NOTIF_FLAG_CONTINUE unsupported by the kernel.";
+      SetExitStatusCode(Result::INTERNAL_ERROR, Result::FAILED_NOTIFY);
+    }
+  }
+}
+
 void UnotifyMonitor::HandleUnotify() {
   memset(req_.get(), 0, req_size_);
   if (ioctl(seccomp_notify_fd_.get(), SECCOMP_IOCTL_NOTIF_RECV, req_.get()) !=
@@ -185,16 +243,31 @@ void UnotifyMonitor::HandleUnotify() {
                   {req_->data.args[0], req_->data.args[1], req_->data.args[2],
                    req_->data.args[3], req_->data.args[4], req_->data.args[5]},
                   req_->pid, 0, req_->data.instruction_pointer);
-  ViolationType violation_type = syscall.arch() == Syscall::GetHostArch()
-                                     ? kSyscallViolation
-                                     : kArchitectureSwitchViolation;
-  LogSyscallViolation(syscall);
-  notify_->EventSyscallViolation(syscall, violation_type);
-  MaybeGetStackTrace(req_->pid, Result::VIOLATION);
-  SetExitStatusCode(Result::VIOLATION, syscall.nr());
-  notify_->EventSyscallViolation(syscall, violation_type);
-  result_.SetSyscall(std::make_unique<Syscall>(syscall));
-  KillSandboxee();
+  absl::StatusOr<uint32_t> policy_ret =
+      bpf::Evaluate(original_policy_, req_->data);
+  if (!policy_ret.ok()) {
+    LOG(ERROR) << "Failed to evaluate policy: " << policy_ret.status();
+    SetExitStatusCode(Result::INTERNAL_ERROR, Result::FAILED_NOTIFY);
+  }
+  const sock_filter trace_action = SANDBOX2_TRACE;
+  bool should_trace = *policy_ret == trace_action.k;
+  Notify::TraceAction trace_response = Notify::TraceAction::kDeny;
+  if (should_trace) {
+    trace_response = notify_->EventSyscallTrace(syscall);
+  }
+  switch (trace_response) {
+    case Notify::TraceAction::kAllow:
+      AllowSyscallViaUnotify();
+      return;
+    case Notify::TraceAction::kDeny:
+      HandleViolation(syscall);
+      return;
+    case Notify::TraceAction::kInspectAfterReturn:
+      LOG(FATAL) << "TraceAction::kInspectAfterReturn not supported by unotify "
+                    "monitor";
+    default:
+      LOG(FATAL) << "Unknown TraceAction: " << static_cast<int>(trace_response);
+  }
 }
 
 void UnotifyMonitor::Run() {
@@ -223,7 +296,7 @@ void UnotifyMonitor::Run() {
   while (result_.final_status() == Result::UNSET) {
     int64_t deadline = deadline_millis_.load(std::memory_order_relaxed);
     absl::Duration remaining = absl::FromUnixMillis(deadline) - absl::Now();
-    if (deadline != 0 && remaining < absl::ZeroDuration()) {
+    if (deadline != 0 && remaining <= absl::ZeroDuration()) {
       VLOG(1) << "Sandbox process hit timeout due to the walltime timer";
       timed_out_ = true;
       MaybeGetStackTrace(process_.main_pid, Result::TIMEOUT);
@@ -267,7 +340,7 @@ void UnotifyMonitor::Run() {
     }
     if (pfds[2].revents & POLLIN) {
       uint64_t value = 0;
-      read(monitor_notify_fd_.get(), &value, sizeof(value));
+      (void)read(monitor_notify_fd_.get(), &value, sizeof(value));
       continue;
     }
     if (pfds[0].revents & POLLIN) {
@@ -340,6 +413,8 @@ bool UnotifyMonitor::InitSetupUnotify() {
   }
   req_size_ = sizes.seccomp_notif;
   req_.reset(static_cast<seccomp_notif*>(malloc(req_size_)));
+  resp_size_ = sizes.seccomp_notif_resp;
+  resp_.reset(static_cast<seccomp_notif_resp*>(malloc(resp_size_)));
   return true;
 }
 
@@ -359,7 +434,8 @@ void UnotifyMonitor::NotifyMonitor() {
     return;
   }
   uint64_t value = 1;
-  write(monitor_notify_fd_.get(), &value, sizeof(value));
+  PCHECK(write(monitor_notify_fd_.get(), &value, sizeof(value)) ==
+         sizeof(value));
 }
 
 bool UnotifyMonitor::KillSandboxee() {
@@ -380,12 +456,11 @@ void UnotifyMonitor::KillInit() {
 
 void UnotifyMonitor::Join() {
   absl::MutexLock lock(&notify_mutex_);
-  if (thread_) {
-    thread_->join();
+  if (thread_.IsJoinable()) {
+    thread_.Join();
     CHECK(IsDone()) << "Monitor did not terminate";
     VLOG(1) << "Final execution status: " << result_.ToString();
     CHECK(result_.final_status() != Result::UNSET);
-    thread_.reset();
     monitor_notify_fd_.Close();
   }
 }
diff --git a/sandboxed_api/sandbox2/monitor_unotify.h b/sandboxed_api/sandbox2/monitor_unotify.h
index ebd38fc..20b19b5 100644
--- a/sandboxed_api/sandbox2/monitor_unotify.h
+++ b/sandboxed_api/sandbox2/monitor_unotify.h
@@ -1,6 +1,8 @@
 #ifndef SANDBOXED_API_SANDBOX2_MONITOR_UNOTIFY_H_
 #define SANDBOXED_API_SANDBOX2_MONITOR_UNOTIFY_H_
 
+#include <linux/audit.h>
+#include <linux/filter.h>
 #include <linux/seccomp.h>
 #include <sys/sysinfo.h>
 #include <sys/types.h>
@@ -9,7 +11,6 @@
 #include <cstdint>
 #include <cstdlib>
 #include <memory>
-#include <thread>
 #include <string>
 #include <vector>
 
@@ -25,7 +26,7 @@
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/util/fileops.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 
@@ -36,6 +37,13 @@ struct seccomp_notif {
   __u32 flags;
   struct seccomp_data data;
 };
+
+struct seccomp_notif_resp {
+  __u64 id;
+  __s64 val;
+  __s32 error;
+  __u32 flags;
+};
 #endif
 
 class UnotifyMonitor : public MonitorBase {
@@ -66,19 +74,30 @@ class UnotifyMonitor : public MonitorBase {
     }
   }
 
+  void NotifyNetworkViolation() override { NotifyMonitor(); }
+
  private:
+  // Custom deleter for req_ and resp_ members which need to allocate space
+  // using malloc.
+  struct StdFreeDeleter {
+    void operator()(void* p) { std::free(p); }
+  };
+
   // Waits for events from monitored clients and signals from the main process.
   void RunInternal() override;
   void Join() override;
   void Run();
 
+  absl::Status SendPolicy(const std::vector<sock_filter>& policy) override;
   bool InitSetupUnotify();
   bool InitSetupNotifyEventFd();
   // Kills the main traced PID with SIGKILL.
-  // Returns false if an error occured and process could not be killed.
+  // Returns false if an error occurred and process could not be killed.
   bool KillSandboxee();
   void KillInit();
 
+  void AllowSyscallViaUnotify();
+  void HandleViolation(const Syscall& syscall);
   void HandleUnotify();
   void SetExitStatusFromStatusPipe();
 
@@ -91,6 +110,8 @@ class UnotifyMonitor : public MonitorBase {
   absl::Notification setup_notification_;
   sapi::file_util::fileops::FDCloser seccomp_notify_fd_;
   sapi::file_util::fileops::FDCloser monitor_notify_fd_;
+  // Original policy as configured by the user.
+  std::vector<sock_filter> original_policy_;
   // Deadline in Unix millis
   std::atomic<int64_t> deadline_millis_{0};
   // False iff external kill is requested
@@ -102,17 +123,19 @@ class UnotifyMonitor : public MonitorBase {
   bool external_kill_ = false;
   // Network violation occurred and process of killing sandboxee started
   bool network_violation_ = false;
-  // Is the sandboxee timed out
+  // Whether the sandboxee timed out
   bool timed_out_ = false;
 
   // Monitor thread object.
-  std::unique_ptr<std::thread> thread_;
+  sapi::Thread thread_;
 
   // Synchronizes monitor thread deletion and notifying the monitor.
   absl::Mutex notify_mutex_;
 
   size_t req_size_;
-  std::unique_ptr<seccomp_notif, decltype(std::free)*> req_{nullptr, std::free};
+  std::unique_ptr<seccomp_notif, StdFreeDeleter> req_;
+  size_t resp_size_;
+  std::unique_ptr<seccomp_notif_resp, StdFreeDeleter> resp_;
 };
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/mount_tree.proto b/sandboxed_api/sandbox2/mount_tree.proto
index 64fc811..12c7dbc 100644
--- a/sandboxed_api/sandbox2/mount_tree.proto
+++ b/sandboxed_api/sandbox2/mount_tree.proto
@@ -26,24 +26,24 @@ message MountTree {
   // FileNode represents a bind mount for a regular file using "outside" as the
   // source.
   message FileNode {
-    optional string outside = 2;
-    optional bool writable = 3;
+    string outside = 2;
+    bool writable = 3;
   }
 
   // DirNode is like FileNode but for directories.
   message DirNode {
-    optional string outside = 2;
-    optional bool writable = 3;
+    string outside = 2;
+    bool writable = 3;
   }
 
   // TmpfsNode mounts a tmpfs with given options.
   message TmpfsNode {
-    optional string tmpfs_options = 1;
+    string tmpfs_options = 1;
   }
 
   // RootNode is as special node for root of the MountTree
   message RootNode {
-    optional bool writable = 3;
+    bool writable = 3;
   }
 
   message Node {
@@ -61,4 +61,9 @@ message MountTree {
   // The node of the current path. If not set, we'll just create a directory at
   // this position.
   optional Node node = 2;
+
+  // Helps to keep a stable and deterministic order of mounts. Protobuf makes no
+  // guarantees about the order of map entries and may even randomize in certain
+  // build configurations.
+  int64 index = 3;
 }
diff --git a/sandboxed_api/sandbox2/mounts.cc b/sandboxed_api/sandbox2/mounts.cc
index 227d207..64ad26e 100644
--- a/sandboxed_api/sandbox2/mounts.cc
+++ b/sandboxed_api/sandbox2/mounts.cc
@@ -20,6 +20,7 @@
 #include <sys/statvfs.h>
 #include <unistd.h>
 
+#include <algorithm>
 #include <cerrno>
 #include <cstddef>
 #include <cstdint>
@@ -86,7 +87,6 @@ absl::Status ValidateInterpreter(absl::string_view interpreter) {
       "/lib64/ld64.so.2",            // PPC64
       "/lib/ld-linux-aarch64.so.1",  // AArch64
       "/lib/ld-linux-armhf.so.3",    // Arm
-      "/system/bin/linker64",        // android_arm64
   };
 
   if (!allowed_interpreters.contains(interpreter)) {
@@ -280,14 +280,19 @@ absl::Status Mounts::Insert(absl::string_view path,
 
   std::vector<absl::string_view> parts =
       absl::StrSplit(absl::StripPrefix(fixed_path, "/"), '/');
-  std::string final_part(parts.back());
-  parts.pop_back();
 
   MountTree* curtree = &mount_tree_;
-  for (absl::string_view part : parts) {
-    curtree = &(curtree->mutable_entries()
-                    ->insert({std::string(part), MountTree()})
-                    .first->second);
+  for (int i = 0; true; ++i) {
+    // ANDROID: std::string_view to std::string
+    auto [it, did_insert] =
+        curtree->mutable_entries()->emplace(std::string(parts[i]), MountTree());
+    if (did_insert) {
+      it->second.set_index(++mount_index_);
+    }
+    curtree = &it->second;
+    if (i == parts.size() - 1) {  // Final part
+      break;
+    }
     if (curtree->has_node() && curtree->node().has_file_node()) {
       return absl::FailedPreconditionError(
           absl::StrCat("Cannot insert ", path,
@@ -295,10 +300,6 @@ absl::Status Mounts::Insert(absl::string_view path,
     }
   }
 
-  curtree = &(curtree->mutable_entries()
-                  ->insert({final_part, MountTree()})
-                  .first->second);
-
   if (curtree->has_node()) {
     if (internal::IsEquivalentNode(curtree->node(), new_node)) {
       SAPI_RAW_LOG(INFO, "Inserting %s with the same value twice",
@@ -586,8 +587,7 @@ uint64_t GetMountFlagsFor(const std::string& path) {
 }
 
 std::string MountFlagsToString(uint64_t flags) {
-#define SAPI_MAP(x) \
-  { x, #x }
+#define SAPI_MAP(x) {x, #x}
   static constexpr std::pair<uint64_t, absl::string_view> kMap[] = {
       SAPI_MAP(MS_RDONLY),      SAPI_MAP(MS_NOSUID),
       SAPI_MAP(MS_NODEV),       SAPI_MAP(MS_NOEXEC),
@@ -638,11 +638,24 @@ void MountWithDefaults(const std::string& source, const std::string& target,
   int res = mount(source.c_str(), target.c_str(), fs_type, flags, option_str);
   if (res == -1) {
     if (errno == ENOENT) {
-      // File does not exist (anymore). This is e.g. the case when we're trying
-      // to gather stack-traces on SAPI crashes. The sandboxee application is a
+      // File does not exist (anymore). This may be the case when trying to
+      // gather stack-traces on SAPI crashes. The sandboxee application is a
       // memfd file that is not existing anymore.
-      SAPI_RAW_LOG(WARNING, "Could not mount %s: file does not exist",
-                   source.c_str());
+      // Check which file/dir of the call is actually missing.
+      bool have_source =
+          file_util::fileops::Exists(source, /*fully_resolve=*/true);
+      bool have_target =
+          file_util::fileops::Exists(target, /*fully_resolve=*/true);
+      const char* detail = "unknown error, source and target exist";
+      if (!have_source && !have_target) {
+        detail = "neither source nor target exist";
+      } else if (!have_source) {
+        detail = "source does not exist";
+      } else if (!have_target) {
+        detail = "target does not exist";
+      }
+      SAPI_RAW_LOG(WARNING, "Could not mount %s (source) to %s (target): %s",
+                   source.c_str(), target.c_str(), detail);
       return;
     }
     SAPI_RAW_PLOG(FATAL, "mounting %s to %s failed (flags=%s)", source, target,
@@ -674,9 +687,32 @@ void MountWithDefaults(const std::string& source, const std::string& target,
   }
 }
 
+using MapEntry = std::pair<absl::string_view, const MountTree*>;
+
+std::vector<MapEntry> GetSortedEntries(const MountTree& tree) {
+  std::vector<MapEntry> ordered;
+  ordered.reserve(tree.entries_size());
+  for (auto& entry : tree.entries()) {
+    ordered.emplace_back(entry.first, &entry.second);
+  }
+  std::sort(ordered.begin(), ordered.end(),
+            [](const MapEntry& a, const MapEntry& b) {
+              return a.second->index() < b.second->index();
+            });
+  return ordered;
+}
+
+bool IsSymlink(const std::string& path) {
+  struct stat sb;
+  if (stat(path.c_str(), &sb) == -1) {
+    return false;
+  }
+  return S_ISLNK(sb.st_mode);
+}
+
 // Traverses the MountTree to create all required files and perform the mounts.
-void CreateMounts(const MountTree& tree, const std::string& path,
-                  bool create_backing_files) {
+void CreateMounts(const MountTree& tree, const std::string& root_path,
+                  const std::string& path, bool create_backing_files) {
   // First, create the backing files if needed.
   if (create_backing_files) {
     switch (tree.node().node_case()) {
@@ -698,6 +734,17 @@ void CreateMounts(const MountTree& tree, const std::string& path,
     }
   }
 
+  if (IsSymlink(path)) {
+    std::string abs_path;
+    if (!file_util::fileops::ReadLinkAbsolute(path, &abs_path)) {
+      SAPI_RAW_LOG(WARNING, "could not resolve mount target path %s",
+                   path.c_str());
+    } else if (!absl::StartsWith(abs_path, absl::StrCat(root_path, "/"))) {
+      SAPI_RAW_LOG(ERROR, "Mount target not within chroot: %s resolved to %s",
+                   path.c_str(), abs_path.c_str());
+    }
+  }
+
   // Perform the actual mounts based on the node type.
   switch (tree.node().node_case()) {
     case MountTree::Node::kDirNode: {
@@ -735,16 +782,16 @@ void CreateMounts(const MountTree& tree, const std::string& path,
   }
 
   // Traverse the subtrees.
-  for (const auto& kv : tree.entries()) {
-    std::string new_path = sapi::file::JoinPath(path, kv.first);
-    CreateMounts(kv.second, new_path, create_backing_files);
+  for (const auto& [key, value] : GetSortedEntries(tree)) {
+    std::string new_path = sapi::file::JoinPath(path, key);
+    CreateMounts(*value, root_path, new_path, create_backing_files);
   }
 }
 
 }  // namespace
 
 void Mounts::CreateMounts(const std::string& root_path) const {
-  sandbox2::CreateMounts(mount_tree_, root_path, true);
+  sandbox2::CreateMounts(mount_tree_, root_path, root_path, true);
 }
 
 namespace {
@@ -768,9 +815,9 @@ void RecursivelyListMountsImpl(const MountTree& tree,
         absl::StrCat("tmpfs: ", node.tmpfs_node().tmpfs_options()));
   }
 
-  for (const auto& subentry : tree.entries()) {
-    RecursivelyListMountsImpl(subentry.second,
-                              absl::StrCat(tree_path, "/", subentry.first),
+  for (const auto& [key, value] : GetSortedEntries(tree)) {
+    std::string new_path = sapi::file::JoinPath(tree_path, key);
+    RecursivelyListMountsImpl(*value, absl::StrCat(tree_path, "/", key),
                               outside_entries, inside_entries);
   }
 }
diff --git a/sandboxed_api/sandbox2/mounts.h b/sandboxed_api/sandbox2/mounts.h
index 0a23f55..61df493 100644
--- a/sandboxed_api/sandbox2/mounts.h
+++ b/sandboxed_api/sandbox2/mounts.h
@@ -16,6 +16,7 @@
 #define SANDBOXED_API_SANDBOX2_MOUNTTREE_H_
 
 #include <cstddef>
+#include <cstdint>
 #include <string>
 #include <utility>
 #include <vector>
@@ -33,6 +34,7 @@ bool IsSameFile(const std::string& path1, const std::string& path2);
 bool IsWritable(const MountTree::Node& node);
 bool HasSameTarget(const MountTree::Node& n1, const MountTree::Node& n2);
 bool IsEquivalentNode(const MountTree::Node& n1, const MountTree::Node& n2);
+
 }  // namespace internal
 
 class Mounts {
@@ -102,6 +104,7 @@ class Mounts {
   absl::Status Insert(absl::string_view path, const MountTree::Node& node);
 
   MountTree mount_tree_;
+  int64_t mount_index_ = 0;  // Used to keep track of the mount insertion order
 };
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/mounts_test.cc b/sandboxed_api/sandbox2/mounts_test.cc
index 21490a2..b95c2a7 100644
--- a/sandboxed_api/sandbox2/mounts_test.cc
+++ b/sandboxed_api/sandbox2/mounts_test.cc
@@ -25,6 +25,8 @@
 #include "absl/status/status.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
+#include "absl/strings/string_view.h"
+#include "sandboxed_api/sandbox2/mount_tree.pb.h"
 #include "sandboxed_api/testing.h"
 #include "sandboxed_api/util/path.h"
 #include "sandboxed_api/util/status_matchers.h"
@@ -40,9 +42,9 @@ using ::sapi::GetTestSourcePath;
 using ::sapi::GetTestTempPath;
 using ::sapi::IsOk;
 using ::sapi::StatusIs;
+using ::testing::ElementsAreArray;
 using ::testing::Eq;
 using ::testing::StrEq;
-using ::testing::UnorderedElementsAreArray;
 
 constexpr size_t kTmpfsSize = 1024;
 
@@ -183,7 +185,7 @@ TEST(MountTreeTest, TestMultipleInsertion) {
 
 TEST(MountTreeTest, TestEvilNullByte) {
   Mounts mounts;
-  // create the filename with a null byte this way as g4 fix forces newlines
+  // Create the filename with a null byte this way as g4 fix forces newlines
   // otherwise.
   std::string filename = "/a/b";
   filename[2] = '\0';
@@ -214,20 +216,18 @@ TEST(MountTreeTest, TestMinimalDynamicBinary) {
 
 TEST(MountTreeTest, TestList) {
   struct TestCase {
-    const char* path;
-    const bool is_ro;
+    absl::string_view path;
+    bool is_ro;
   };
-  // clang-format off
   constexpr TestCase kTestCases[] = {
       // NOTE: Directories have a trailing '/'; files don't.
-      {"/a/b", true},
-      {"/a/c/", true},
-      {"/a/c/d/e/f/g", true},
-      {"/h", true},
-      {"/i/j/k", false},
-      {"/i/l/", false},
+      {"/a/b", true},          // File
+      {"/a/c/", true},         // Directory
+      {"/a/c/d/e/f/g", true},  // File
+      {"/h", true},            // File
+      {"/i/j/k", false},       // File
+      {"/i/l/", false},        // Directory
   };
-  // clang-format on
 
   Mounts mounts;
 
@@ -254,30 +254,24 @@ TEST(MountTreeTest, TestList) {
   std::vector<std::string> inside_entries;
   mounts.RecursivelyListMounts(&outside_entries, &inside_entries);
 
-  // clang-format off
-  EXPECT_THAT(
-      inside_entries,
-      UnorderedElementsAreArray({
-          "R /a/b",
-          "R /a/c/",
-          "R /a/c/d/e/f/g",
-          "R /h",
-          "W /i/j/k",
-          "W /i/l/",
-          "/d",
-      }));
-  EXPECT_THAT(
-      outside_entries,
-      UnorderedElementsAreArray({
-          absl::StrCat("/some/dir/", "a/b"),
-          absl::StrCat("/some/dir/", "a/c/"),
-          absl::StrCat("/some/dir/", "a/c/d/e/f/g"),
-          absl::StrCat("/some/dir/", "h"),
-          absl::StrCat("/some/dir/", "i/j/k"),
-          absl::StrCat("/some/dir/", "i/l/"),
-          absl::StrCat("tmpfs: size=", 1024*1024),
-      }));
-  // clang-format on
+  EXPECT_THAT(inside_entries, ElementsAreArray({
+                                  "R /a/b",
+                                  "R /a/c/",
+                                  "R /a/c/d/e/f/g",
+                                  "R /h",
+                                  "W /i/j/k",
+                                  "W /i/l/",
+                                  "/d",
+                              }));
+  EXPECT_THAT(outside_entries, ElementsAreArray({
+                                   absl::StrCat("/some/dir/", "a/b"),
+                                   absl::StrCat("/some/dir/", "a/c/"),
+                                   absl::StrCat("/some/dir/", "a/c/d/e/f/g"),
+                                   absl::StrCat("/some/dir/", "h"),
+                                   absl::StrCat("/some/dir/", "i/j/k"),
+                                   absl::StrCat("/some/dir/", "i/l/"),
+                                   absl::StrCat("tmpfs: size=", 1024 * 1024),
+                               }));
 }
 
 TEST(MountTreeTest, TestIsWritable) {
diff --git a/sandboxed_api/sandbox2/namespace.cc b/sandboxed_api/sandbox2/namespace.cc
index 9043ee3..89e8063 100644
--- a/sandboxed_api/sandbox2/namespace.cc
+++ b/sandboxed_api/sandbox2/namespace.cc
@@ -34,7 +34,8 @@
 #include <vector>
 
 #include "absl/strings/str_cat.h"
-#include "sandboxed_api/sandbox2/violation.pb.h"
+#include "sandboxed_api/sandbox2/forkserver.pb.h"
+#include "sandboxed_api/sandbox2/mounts.h"
 #include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/path.h"
 #include "sandboxed_api/util/raw_logging.h"
@@ -195,12 +196,16 @@ void LogFilesystem(const std::string& dir) {
 
 }  // namespace
 
-Namespace::Namespace(bool allow_unrestricted_networking, Mounts mounts,
-                     std::string hostname, bool allow_mount_propagation)
+Namespace::Namespace(Mounts mounts, std::string hostname,
+                     NetNsMode netns_config, bool allow_mount_propagation)
     : mounts_(std::move(mounts)),
       hostname_(std::move(hostname)),
-      allow_mount_propagation_(allow_mount_propagation) {
-  if (allow_unrestricted_networking) {
+      allow_mount_propagation_(allow_mount_propagation),
+      netns_config_(netns_config) {
+  // Remove the CLONE_NEWNET flag to allow networking, or for the shared netns.
+  // In the latter case, the flag will be added later on.
+  if (netns_config_ == NETNS_MODE_NONE ||
+      netns_config_ == NETNS_MODE_SHARED_PER_FORKSERVER) {
     clone_flags_ &= ~CLONE_NEWNET;
   }
 }
@@ -231,9 +236,10 @@ void Namespace::InitializeNamespaces(uid_t uid, gid_t gid, int32_t clone_flags,
     SAPI_RAW_PCHECK(chdir("/") != -1, "chdir / after chrooting real root");
   }
 
-  SAPI_RAW_PCHECK(mount("", "/proc", "proc", MS_NODEV | MS_NOEXEC | MS_NOSUID,
-                        nullptr) != -1,
-                  "Could not mount a new /proc"
+  SAPI_RAW_PCHECK(
+      mount("", "/proc", "proc", MS_NODEV | MS_NOEXEC | MS_NOSUID, nullptr) !=
+          -1,
+      "Could not mount a new /proc"
   );
 
   if (clone_flags & CLONE_NEWNET) {
@@ -353,10 +359,4 @@ void Namespace::InitializeInitialNamespaces(uid_t uid, gid_t gid) {
       "remounting rootfs read-only failed");
 }
 
-void Namespace::GetNamespaceDescription(
-    NamespaceDescription* pb_description) const {
-  pb_description->set_clone_flags(clone_flags_);
-  *pb_description->mutable_mount_tree_mounts() = mounts_.GetMountTree();
-}
-
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/namespace.h b/sandboxed_api/sandbox2/namespace.h
index fc6fbd0..dbb7e79 100644
--- a/sandboxed_api/sandbox2/namespace.h
+++ b/sandboxed_api/sandbox2/namespace.h
@@ -24,8 +24,8 @@
 #include <cstdint>
 #include <string>
 
+#include "sandboxed_api/sandbox2/forkserver.pb.h"
 #include "sandboxed_api/sandbox2/mounts.h"
-#include "sandboxed_api/sandbox2/violation.pb.h"
 
 namespace sandbox2 {
 
@@ -39,11 +39,10 @@ class Namespace final {
                                    bool allow_mount_propagation);
   static void InitializeInitialNamespaces(uid_t uid, gid_t gid);
 
-  Namespace(bool allow_unrestricted_networking, Mounts mounts,
-            std::string hostname, bool allow_mount_propagation);
+  Namespace(Mounts mounts, std::string hostname, NetNsMode netns_config,
+            bool allow_mount_propagation = false);
 
-  // Stores information about this namespace in the protobuf structure.
-  void GetNamespaceDescription(NamespaceDescription* pb_description) const;
+  NetNsMode netns_config() const { return netns_config_; }
 
   int32_t clone_flags() const { return clone_flags_; }
 
@@ -59,7 +58,8 @@ class Namespace final {
                          CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWNET;
   Mounts mounts_;
   std::string hostname_;
-  bool allow_mount_propagation_ = false;
+  bool allow_mount_propagation_;
+  NetNsMode netns_config_;
 };
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/namespace_test.cc b/sandboxed_api/sandbox2/namespace_test.cc
index 1553729..a059ce3 100644
--- a/sandboxed_api/sandbox2/namespace_test.cc
+++ b/sandboxed_api/sandbox2/namespace_test.cc
@@ -12,8 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include "sandboxed_api/sandbox2/namespace.h"
+#include "sandboxed_api/sandbox2/namespace.h"  // IWYU pragma: keep
 
+#include <asm-generic/unistd.h>
 #include <unistd.h>
 
 #include <cstdint>
@@ -27,10 +28,13 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/log/check.h"
+#include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
-#include "sandboxed_api/sandbox2/allow_all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/namespaces.h"
+#include "sandboxed_api/sandbox2/allowlists/unrestricted_networking.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/policybuilder.h"
@@ -61,7 +65,7 @@ using ::testing::Matcher;
 using ::testing::Ne;
 using ::testing::SizeIs;
 using ::testing::StartsWith;
-using ::testing::StrEq;  // sapi::google3-only(broken matchers)
+using ::testing::StrEq;
 
 std::string GetTestcaseBinPath(absl::string_view bin_name) {
   return GetTestSourcePath(absl::StrCat("sandbox2/testcases/", bin_name));
@@ -151,7 +155,7 @@ TEST(NamespaceTest, UserNamespaceWorks) {
     std::vector<std::string> result = RunSandboxeeWithArgsAndPolicy(
         path, {path, "2"},
         PolicyBuilder()
-            .DisableNamespaces()
+            .DisableNamespaces(NamespacesToken())
             .DefaultAction(AllowAllSyscalls())  // Do not restrict syscalls
             .BuildOrDie());
     EXPECT_THAT(result, ElementsAre(Ne("2")));
@@ -173,7 +177,7 @@ TEST(NamespaceTest, UserNamespaceIDMapWritten) {
     std::vector<std::string> result = RunSandboxeeWithArgsAndPolicy(
         path, {path, "3"},
         PolicyBuilder()
-            .DisableNamespaces()
+            .DisableNamespaces(NamespacesToken())
             .DefaultAction(AllowAllSyscalls())  // Do not restrict syscalls
             .BuildOrDie());
     EXPECT_THAT(result,
@@ -210,7 +214,7 @@ TEST(NamespaceTest, HostnameNone) {
   std::vector<std::string> result = RunSandboxeeWithArgsAndPolicy(
       path, {path, "7"},
       PolicyBuilder()
-          .DisableNamespaces()
+          .DisableNamespaces(NamespacesToken())
           .DefaultAction(AllowAllSyscalls())  // Do not restrict syscalls
           .BuildOrDie());
   EXPECT_THAT(result, ElementsAre(Ne("sandbox2")));
@@ -244,7 +248,7 @@ TEST(NamespaceTest, TestInterfacesNoNetwork) {
 TEST(NamespaceTest, TestInterfacesWithNetwork) {
   const std::string path = GetTestcaseBinPath("namespace");
   SAPI_ASSERT_OK_AND_ASSIGN(auto policy, CreateDefaultPermissiveTestPolicy(path)
-                                             .AllowUnrestrictedNetworking()
+                                             .Allow(UnrestrictedNetworking())
                                              .TryBuild());
 
   std::vector<std::string> result =
@@ -254,8 +258,61 @@ TEST(NamespaceTest, TestInterfacesWithNetwork) {
   EXPECT_THAT(result, SizeIs(Gt(1)));
 }
 
+TEST(NamespaceTest, TestNetNsModeForkServerShared) {
+  constexpr uint32_t kReadlink[] = {
+#ifdef __NR_readlink
+      __NR_readlink,
+#endif
+      __NR_readlinkat};
+
+  std::unique_ptr<sandbox2::Policy> policy;
+  const std::string path = GetTestcaseBinPath("namespace");
+  std::initializer_list<std::string> args = {path, "8"};
+
+  // Sandbox2 run without a ForkServer shared net_ns
+  SAPI_ASSERT_OK_AND_ASSIGN(policy, CreateDefaultPermissiveTestPolicy(path)
+                                        .AllowSyscalls(kReadlink)
+                                        .AddDirectory("/proc")
+                                        .TryBuild());
+  std::vector<std::string> result_individual_netns_run =
+      RunSandboxeeWithArgsAndPolicy(path, args, std::move(policy));
+  EXPECT_THAT(result_individual_netns_run, SizeIs(1));
+
+  // Two Sandbox2 runs with a ForkServer shared net_ns
+  SAPI_ASSERT_OK_AND_ASSIGN(policy, CreateDefaultPermissiveTestPolicy(path)
+                                        .AllowSyscalls(kReadlink)
+                                        .AddDirectory("/proc")
+                                        .UseForkServerSharedNetNs()
+                                        .TryBuild());
+  std::vector<std::string> result_one =
+      RunSandboxeeWithArgsAndPolicy(path, args, std::move(policy));
+  EXPECT_THAT(result_one.size(), Eq(1));
+
+  SAPI_ASSERT_OK_AND_ASSIGN(policy, CreateDefaultPermissiveTestPolicy(path)
+                                        .AllowSyscalls(kReadlink)
+                                        .AddDirectory("/proc")
+                                        .UseForkServerSharedNetNs()
+                                        .TryBuild());
+  std::vector<std::string> result_two =
+      RunSandboxeeWithArgsAndPolicy(path, args, std::move(policy));
+  EXPECT_THAT(result_two.size(), Eq(1));
+
+  EXPECT_THAT(result_one, Eq(result_two));
+  EXPECT_THAT(result_one, Ne(result_individual_netns_run));
+  EXPECT_THAT(result_two, Ne(result_individual_netns_run));
+}
+
+TEST(NamespaceTest, TestIncompatibleNetNsModes) {
+  const std::string path = GetTestcaseBinPath("namespace");
+  auto policy = CreateDefaultPermissiveTestPolicy(path)
+                    .Allow(UnrestrictedNetworking())
+                    .UseForkServerSharedNetNs()
+                    .TryBuild();
+  EXPECT_THAT(policy.status(),
+              sapi::StatusIs(absl::StatusCode::kFailedPrecondition));
+}
+
 TEST(NamespaceTest, TestFiles) {
-  SKIP_ANDROID;
   const std::string path = GetTestcaseBinPath("namespace");
   std::vector<std::string> result =
       RunSandboxeeWithArgsAndPolicy(path, {path, "6", "/"});
diff --git a/sandboxed_api/sandbox2/network_proxy/BUILD.bazel b/sandboxed_api/sandbox2/network_proxy/BUILD
similarity index 65%
rename from sandboxed_api/sandbox2/network_proxy/BUILD.bazel
rename to sandboxed_api/sandbox2/network_proxy/BUILD
index b2b48c6..aa0c59c 100644
--- a/sandboxed_api/sandbox2/network_proxy/BUILD.bazel
+++ b/sandboxed_api/sandbox2/network_proxy/BUILD
@@ -12,10 +12,10 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -27,11 +27,12 @@ cc_library(
     copts = sapi_platform_copts(),
     deps = [
         ":filtering",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/util:fileops",
+        "@com_google_absl//absl/functional:any_invocable",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
     ],
 )
 
@@ -42,12 +43,15 @@ cc_library(
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/util:syscall_trap",
-        "//sandboxed_api/util:status",
+        "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/synchronization",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:syscall_trap",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -57,12 +61,12 @@ cc_library(
     hdrs = ["filtering.h"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -72,9 +76,9 @@ cc_test(
     copts = sapi_platform_copts(),
     deps = [
         ":filtering",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/log:check",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
 
@@ -82,14 +86,16 @@ cc_library(
     name = "testing",
     srcs = ["testing.cc"],
     hdrs = ["testing.h"],
+    copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
     ],
 )
diff --git a/sandboxed_api/sandbox2/network_proxy/CMakeLists.txt b/sandboxed_api/sandbox2/network_proxy/CMakeLists.txt
index 3a5905d..86a2635 100644
--- a/sandboxed_api/sandbox2/network_proxy/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/network_proxy/CMakeLists.txt
@@ -22,7 +22,8 @@ target_link_libraries(sandbox2_network_proxy_server
  PRIVATE absl::status
          sapi::fileops
          sapi::base
- PUBLIC sandbox2::comms
+ PUBLIC absl::any_invocable
+        sandbox2::comms
         sandbox2::network_proxy_filtering
 )
 
@@ -49,15 +50,18 @@ add_library(sandbox2_network_proxy_client ${SAPI_LIB_TYPE}
   client.h
 )
 add_library(sandbox2::network_proxy_client ALIAS sandbox2_network_proxy_client)
-target_link_libraries(sandbox2_network_proxy_client PRIVATE
-  absl::strings
-  absl::synchronization
-  absl::log
-  sandbox2::comms
-  sandbox2::syscall_trap
-  sapi::strerror
-  sapi::base
-  sapi::status
+target_link_libraries(sandbox2_network_proxy_client
+ PUBLIC absl::core_headers
+        absl::status
+        absl::statusor
+        absl::synchronization
+        sandbox2::comms
+        sandbox2::syscall_trap
+        sapi::fileops
+ PRIVATE absl::strings
+         absl::log
+         sapi::base
+         sapi::status
 )
 
 # sandboxed_api/sandbox2/network_proxy:testing
@@ -66,16 +70,17 @@ add_library(sandbox2_network_proxy_testing ${SAPI_LIB_TYPE}
   testing.h
 )
 add_library(sandbox2::network_proxy_testing ALIAS sandbox2_network_proxy_testing)
-target_link_libraries(sandbox2_network_proxy_testing PRIVATE
-  absl::check
-  absl::core_headers
-  absl::memory
-  absl::status
-  absl::statusor
-  absl::strings
-  sapi::fileops
-  sapi::status
-  sapi::base
+target_link_libraries(sandbox2_network_proxy_testing
+ PUBLIC sapi::fileops
+        sapi::thread
+        absl::statusor
+ PRIVATE absl::check
+         absl::core_headers
+         absl::memory
+         absl::status
+         absl::strings
+         sapi::status
+         sapi::base
 )
 
 if(BUILD_TESTING AND SAPI_BUILD_TESTING)
diff --git a/sandboxed_api/sandbox2/network_proxy/client.cc b/sandboxed_api/sandbox2/network_proxy/client.cc
index d47d7f7..5d348b3 100644
--- a/sandboxed_api/sandbox2/network_proxy/client.cc
+++ b/sandboxed_api/sandbox2/network_proxy/client.cc
@@ -14,6 +14,7 @@
 
 #include "sandboxed_api/sandbox2/network_proxy/client.h"
 
+#include <fcntl.h>
 #include <sys/socket.h>
 #include <syscall.h>
 #include <unistd.h>
@@ -25,14 +26,16 @@
 #include "absl/status/status.h"
 #include "absl/synchronization/mutex.h"
 #include "sandboxed_api/sandbox2/util/syscall_trap.h"
+#include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/status_macros.h"
 
 namespace sandbox2 {
+using ::sapi::file_util::fileops::FDCloser;
 
 absl::Status NetworkProxyClient::Connect(int sockfd,
                                          const struct sockaddr* addr,
                                          socklen_t addrlen) {
-  absl::MutexLock lock(&mutex_);
+  int oldflags = fcntl(sockfd, F_GETFL, 0);
 
   // Check if socket is SOCK_STREAM
   int type;
@@ -46,29 +49,25 @@ absl::Status NetworkProxyClient::Connect(int sockfd,
     return absl::InvalidArgumentError(
         "Invalid socket, only SOCK_STREAM is allowed");
   }
+  SAPI_ASSIGN_OR_RETURN(FDCloser s, ConnectInternal(addr, addrlen));
+  if (fcntl(s.get(), F_SETFL, oldflags) != 0) {
+    return absl::InternalError("Failed to restore socket flags");
+  }
+  if (dup2(s.get(), sockfd) == -1) {
+    return absl::InternalError("Duplicating socket failed");
+  }
+  return absl::OkStatus();
+}
 
+absl::StatusOr<FDCloser> NetworkProxyClient::ConnectInternal(
+    const struct sockaddr* addr, socklen_t addrlen) {
+  absl::MutexLock lock(&mutex_);
   // Send sockaddr struct
   if (!comms_.SendBytes(reinterpret_cast<const uint8_t*>(addr), addrlen)) {
     errno = EIO;
     return absl::InternalError("Sending data to network proxy failed");
   }
 
-  SAPI_RETURN_IF_ERROR(ReceiveRemoteResult());
-
-  // Receive new socket
-  int s;
-  if (!comms_.RecvFD(&s)) {
-    errno = EIO;
-    return absl::InternalError("Receiving data from network proxy failed");
-  }
-  if (dup2(s, sockfd) == -1) {
-    close(s);
-    return absl::InternalError("Processing data from network proxy failed");
-  }
-  return absl::OkStatus();
-}
-
-absl::Status NetworkProxyClient::ReceiveRemoteResult() {
   int result;
   if (!comms_.RecvInt32(&result)) {
     errno = EIO;
@@ -78,7 +77,13 @@ absl::Status NetworkProxyClient::ReceiveRemoteResult() {
     errno = result;
     return absl::ErrnoToStatus(errno, "Error in network proxy server");
   }
-  return absl::OkStatus();
+
+  int sock;
+  if (!comms_.RecvFD(&sock)) {
+    errno = EIO;
+    return absl::InternalError("Receiving fd from network proxy failed");
+  }
+  return FDCloser(sock);
 }
 
 NetworkProxyClient* NetworkProxyHandler::network_proxy_client_ = nullptr;
diff --git a/sandboxed_api/sandbox2/network_proxy/client.h b/sandboxed_api/sandbox2/network_proxy/client.h
index 931a41d..34e74cd 100644
--- a/sandboxed_api/sandbox2/network_proxy/client.h
+++ b/sandboxed_api/sandbox2/network_proxy/client.h
@@ -19,10 +19,13 @@
 
 #include <cstdint>
 
+#include "absl/base/thread_annotations.h"
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "absl/synchronization/mutex.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/util/syscall_trap.h"
+#include "sandboxed_api/util/fileops.h"
 
 namespace sandbox2 {
 
@@ -40,12 +43,14 @@ class NetworkProxyClient {
   // back a connected socket.
   absl::Status Connect(int sockfd, const struct sockaddr* addr,
                        socklen_t addrlen);
+
  private:
-  Comms comms_;
-  absl::Status ReceiveRemoteResult();
+  absl::StatusOr<sapi::file_util::fileops::FDCloser> ConnectInternal(
+      const struct sockaddr* addr, socklen_t addrlen);
 
   // Needed to make the Proxy thread safe.
   absl::Mutex mutex_;
+  Comms comms_ ABSL_GUARDED_BY(mutex_);
 };
 
 class NetworkProxyHandler {
diff --git a/sandboxed_api/sandbox2/network_proxy/server.cc b/sandboxed_api/sandbox2/network_proxy/server.cc
index 1adc6b2..e0fbb19 100644
--- a/sandboxed_api/sandbox2/network_proxy/server.cc
+++ b/sandboxed_api/sandbox2/network_proxy/server.cc
@@ -15,7 +15,6 @@
 #include "sandboxed_api/sandbox2/network_proxy/server.h"
 
 #include <netinet/in.h>
-#include <pthread.h>
 #include <signal.h>
 #include <sys/socket.h>
 #include <sys/types.h>
@@ -28,6 +27,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/functional/any_invocable.h"
 #include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -39,12 +39,13 @@ namespace sandbox2 {
 
 namespace file_util = ::sapi::file_util;
 
-NetworkProxyServer::NetworkProxyServer(int fd, AllowedHosts* allowed_hosts,
-                                       pthread_t monitor_thread_id)
+NetworkProxyServer::NetworkProxyServer(
+    int fd, AllowedHosts* allowed_hosts,
+    absl::AnyInvocable<void()> notify_violation_fn)
     : violation_occurred_(false),
       comms_(std::make_unique<Comms>(fd)),
       fatal_error_(false),
-      monitor_thread_id_(monitor_thread_id),
+      notify_violation_fn_(std::move(notify_violation_fn)),
       allowed_hosts_(allowed_hosts) {}
 
 void NetworkProxyServer::ProcessConnectRequest() {
@@ -120,7 +121,7 @@ void NetworkProxyServer::NotifyViolation(const struct sockaddr* saddr) {
     violation_msg_ = std::string(result.status().message());
   }
   violation_occurred_.store(true, std::memory_order_release);
-  pthread_kill(monitor_thread_id_, SIGCHLD);
+  notify_violation_fn_();
 }
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/network_proxy/server.h b/sandboxed_api/sandbox2/network_proxy/server.h
index 0969542..b75a378 100644
--- a/sandboxed_api/sandbox2/network_proxy/server.h
+++ b/sandboxed_api/sandbox2/network_proxy/server.h
@@ -15,12 +15,11 @@
 #ifndef SANDBOXED_API_SANDBOX2_NETWORK_PROXY_SERVER_H_
 #define SANDBOXED_API_SANDBOX2_NETWORK_PROXY_SERVER_H_
 
-#include <pthread.h>
-
 #include <atomic>
 #include <memory>
 #include <string>
 
+#include "absl/functional/any_invocable.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/network_proxy/filtering.h"
 
@@ -33,7 +32,7 @@ namespace sandbox2 {
 class NetworkProxyServer {
  public:
   NetworkProxyServer(int fd, AllowedHosts* allowed_hosts,
-                     pthread_t monitor_thread_id);
+                     absl::AnyInvocable<void()> notify_violation);
 
   NetworkProxyServer(const NetworkProxyServer&) = delete;
   NetworkProxyServer& operator=(const NetworkProxyServer&) = delete;
@@ -61,7 +60,7 @@ class NetworkProxyServer {
 
   std::unique_ptr<Comms> comms_;
   bool fatal_error_;
-  pthread_t monitor_thread_id_;
+  absl::AnyInvocable<void()> notify_violation_fn_;
 
   // Contains list of allowed to connect hosts.
   AllowedHosts* allowed_hosts_;
diff --git a/sandboxed_api/sandbox2/network_proxy/testing.cc b/sandboxed_api/sandbox2/network_proxy/testing.cc
index ffc97a6..d83917b 100644
--- a/sandboxed_api/sandbox2/network_proxy/testing.cc
+++ b/sandboxed_api/sandbox2/network_proxy/testing.cc
@@ -23,7 +23,6 @@
 #include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <thread>
 #include <utility>
 
 #include "absl/base/macros.h"
@@ -33,6 +32,7 @@
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/status_macros.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 namespace {
@@ -92,7 +92,7 @@ void NetworkProxyTestServer::Stop() {
   }
   uint64_t value = 1;
   PCHECK(write(event_fd_.get(), &value, sizeof(value)) == sizeof(value));
-  thread_.join();
+  thread_.Join();
   event_fd_.Close();
   server_socket_.Close();
 }
@@ -115,7 +115,8 @@ void NetworkProxyTestServer::Run() {
 }
 
 void NetworkProxyTestServer::Spawn() {
-  thread_ = std::thread([this] { Run(); });
+  thread_ = sapi::Thread(this, &NetworkProxyTestServer::Run,
+                         "NetworkProxyTestServerThread");
 }
 
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/network_proxy/testing.h b/sandboxed_api/sandbox2/network_proxy/testing.h
index 2d4b6d2..94db304 100644
--- a/sandboxed_api/sandbox2/network_proxy/testing.h
+++ b/sandboxed_api/sandbox2/network_proxy/testing.h
@@ -16,11 +16,11 @@
 #define SANDBOXED_API_SANDBOX2_EXAMPLES_NETWORK_PROXY_NETWORKPROXY_LIB_H_
 
 #include <memory>
-#include <thread>
 #include <utility>
 
 #include "absl/status/statusor.h"
 #include "sandboxed_api/util/fileops.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 
@@ -46,7 +46,7 @@ class NetworkProxyTestServer {
         event_fd_(std::move(event_fd)) {}
   void Spawn();
   void Run();
-  std::thread thread_;
+  sapi::Thread thread_;
   int port_;
   sapi::file_util::fileops::FDCloser server_socket_;
   sapi::file_util::fileops::FDCloser event_fd_;
diff --git a/sandboxed_api/sandbox2/network_proxy_test.cc b/sandboxed_api/sandbox2/network_proxy_test.cc
index df1c984..a888998 100644
--- a/sandboxed_api/sandbox2/network_proxy_test.cc
+++ b/sandboxed_api/sandbox2/network_proxy_test.cc
@@ -17,6 +17,7 @@
 #include <cstdlib>
 #include <memory>
 #include <string>
+#include <tuple>
 #include <utility>
 #include <vector>
 
@@ -79,11 +80,11 @@ TEST(NetworkProxyTest, WrongIPv6) {
   EXPECT_THAT(builder.TryBuild(), StatusIs(absl::StatusCode::kInvalidArgument));
 }
 
-using NetworkProxyTest = ::testing::TestWithParam<bool>;
+using NetworkProxyTest = ::testing::TestWithParam<std::tuple<bool, bool>>;
 
 TEST_P(NetworkProxyTest, ProxyWithHandlerAllowed) {
   SKIP_SANITIZERS;
-  const bool ipv6 = GetParam();
+  const auto [ipv6, use_unotify] = GetParam();
   const std::string path =
       GetTestSourcePath("sandbox2/testcases/network_proxy");
   std::vector<std::string> args = {"network_proxy"};
@@ -104,6 +105,9 @@ TEST_P(NetworkProxyTest, ProxyWithHandlerAllowed) {
       .AllowLlvmCoverage()
       .AddLibrariesForBinary(path);
 
+  if (use_unotify) {
+    builder.CollectStacktracesOnSignal(false);
+  }
   if (ipv6) {
     builder.AllowIPv6("::1");
   } else {
@@ -113,6 +117,9 @@ TEST_P(NetworkProxyTest, ProxyWithHandlerAllowed) {
   SAPI_ASSERT_OK_AND_ASSIGN(auto policy, builder.TryBuild());
 
   Sandbox2 s2(std::move(executor), std::move(policy));
+  if (use_unotify) {
+    ASSERT_THAT(s2.EnableUnotifyMonitor(), sapi::IsOk());
+  }
   ASSERT_TRUE(s2.RunAsync());
 
   SAPI_ASSERT_OK_AND_ASSIGN(auto server, NetworkProxyTestServer::Start(ipv6));
@@ -125,7 +132,7 @@ TEST_P(NetworkProxyTest, ProxyWithHandlerAllowed) {
 
 TEST_P(NetworkProxyTest, ProxyWithHandlerNotAllowed) {
   SKIP_SANITIZERS;
-  const bool ipv6 = GetParam();
+  const auto [ipv6, use_unotify] = GetParam();
   const std::string path =
       GetTestSourcePath("sandbox2/testcases/network_proxy");
   std::vector<std::string> args = {"network_proxy"};
@@ -145,10 +152,15 @@ TEST_P(NetworkProxyTest, ProxyWithHandlerNotAllowed) {
       .AddNetworkProxyHandlerPolicy()
       .AllowLlvmCoverage()
       .AddLibrariesForBinary(path);
-
+  if (use_unotify) {
+    builder.CollectStacktracesOnSignal(false);
+  }
   SAPI_ASSERT_OK_AND_ASSIGN(auto policy, builder.TryBuild());
 
   Sandbox2 s2(std::move(executor), std::move(policy));
+  if (use_unotify) {
+    ASSERT_THAT(s2.EnableUnotifyMonitor(), sapi::IsOk());
+  }
   ASSERT_TRUE(s2.RunAsync());
 
   SAPI_ASSERT_OK_AND_ASSIGN(auto server, NetworkProxyTestServer::Start(ipv6));
@@ -161,7 +173,7 @@ TEST_P(NetworkProxyTest, ProxyWithHandlerNotAllowed) {
 
 TEST_P(NetworkProxyTest, ProxyWithoutHandlerAllowed) {
   SKIP_SANITIZERS;
-  const bool ipv6 = GetParam();
+  const auto [ipv6, use_unotify] = GetParam();
   const std::string path =
       GetTestSourcePath("sandbox2/testcases/network_proxy");
   std::vector<std::string> args = {"network_proxy", "--noconnect_with_handler"};
@@ -181,7 +193,9 @@ TEST_P(NetworkProxyTest, ProxyWithoutHandlerAllowed) {
       .AddNetworkProxyHandlerPolicy()
       .AllowLlvmCoverage()
       .AddLibrariesForBinary(path);
-
+  if (use_unotify) {
+    builder.CollectStacktracesOnSignal(false);
+  }
   if (ipv6) {
     builder.AllowIPv6("::1");
   } else {
@@ -191,6 +205,9 @@ TEST_P(NetworkProxyTest, ProxyWithoutHandlerAllowed) {
   SAPI_ASSERT_OK_AND_ASSIGN(auto policy, builder.TryBuild());
 
   Sandbox2 s2(std::move(executor), std::move(policy));
+  if (use_unotify) {
+    ASSERT_THAT(s2.EnableUnotifyMonitor(), sapi::IsOk());
+  }
   ASSERT_TRUE(s2.RunAsync());
 
   SAPI_ASSERT_OK_AND_ASSIGN(auto server, NetworkProxyTestServer::Start(ipv6));
@@ -237,7 +254,8 @@ TEST(NetworkProxyTest, ProxyNonExistantAddress) {
 }
 
 INSTANTIATE_TEST_SUITE_P(NetworkProxyTest, NetworkProxyTest,
-                         ::testing::Values(true, false));
+                         ::testing::Combine(::testing::Bool(),
+                                            ::testing::Bool()));
 
 }  // namespace
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/notify.h b/sandboxed_api/sandbox2/notify.h
index 0195428..ae4bfa6 100644
--- a/sandboxed_api/sandbox2/notify.h
+++ b/sandboxed_api/sandbox2/notify.h
@@ -19,8 +19,11 @@
 
 #include <sys/types.h>
 
+#include <cstdint>
+
 #include "absl/base/attributes.h"
 #include "absl/log/log.h"
+#include "absl/strings/str_format.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/sandbox2/syscall.h"
@@ -28,13 +31,20 @@
 
 namespace sandbox2 {
 
-enum ViolationType {
+enum class ViolationType : int {
   // A syscall disallowed by the policy was invoked.
-  kSyscallViolation,
+  kSyscall,
   // A syscall with cpu architecture not covered by the policy was invoked.
-  kArchitectureSwitchViolation,
+  kArchitectureSwitch,
 };
 
+template <typename Sink>
+void AbslStringify(Sink& sink, ViolationType e) {
+  absl::Format(
+      &sink, "%s",
+      e == ViolationType::kSyscall ? "kSyscall" : "kArchitectureSwitch");
+}
+
 class Notify {
  public:
   virtual ~Notify() = default;
diff --git a/sandboxed_api/sandbox2/notify_test.cc b/sandboxed_api/sandbox2/notify_test.cc
index 6942f50..19bf753 100644
--- a/sandboxed_api/sandbox2/notify_test.cc
+++ b/sandboxed_api/sandbox2/notify_test.cc
@@ -25,32 +25,28 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/log/log.h"
+#include "absl/status/status.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/string_view.h"
+#include "sandboxed_api/sandbox2/allowlists/trace_all_syscalls.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/policybuilder.h"
+#include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/sandbox2/sandbox2.h"
 #include "sandboxed_api/sandbox2/syscall.h"
-#include "sandboxed_api/sandbox2/trace_all_syscalls.h"
 #include "sandboxed_api/testing.h"
+#include "sandboxed_api/util/status_matchers.h"
 
 namespace sandbox2 {
 namespace {
 
 using ::sapi::CreateDefaultPermissiveTestPolicy;
 using ::sapi::GetTestSourcePath;
+using ::sapi::IsOk;
 using ::testing::Eq;
 
-// Allow typical syscalls and call SECCOMP_RET_TRACE for personality syscall,
-// chosen because unlikely to be called by a regular program.
-std::unique_ptr<Policy> NotifyTestcasePolicy(absl::string_view path) {
-  return CreateDefaultPermissiveTestPolicy(path)
-      .AddPolicyOnSyscall(__NR_personality, {SANDBOX2_TRACE})
-      .BuildOrDie();
-}
-
 // If syscall and its arguments don't match the expected ones, return the
 // opposite of the requested values (allow/disallow) to indicate an error.
 class PersonalityNotify : public Notify {
@@ -86,13 +82,45 @@ class PidCommsNotify : public Notify {
   }
 };
 
+class FinishedNotify : public Notify {
+ public:
+  bool IsFinished() { return finished_; }
+  bool EventStarted(pid_t pid, Comms* comms) override {
+    EXPECT_FALSE(finished_);
+    return true;
+  }
+  void EventFinished(const Result& result) override { finished_ = true; }
+
+ private:
+  bool finished_ = false;
+};
+
+class NotifyTest : public ::testing::TestWithParam<bool> {
+ public:
+  // Allow typical syscalls and call SECCOMP_RET_TRACE for personality syscall,
+  // chosen because unlikely to be called by a regular program.
+  std::unique_ptr<Policy> NotifyTestcasePolicy(absl::string_view path) {
+    sandbox2::PolicyBuilder builder =
+        CreateDefaultPermissiveTestPolicy(path).AddPolicyOnSyscall(
+            __NR_personality, {SANDBOX2_TRACE});
+    if (GetParam()) {
+      builder.CollectStacktracesOnSignal(false);
+    }
+    return builder.BuildOrDie();
+  }
+  absl::Status SetUpSandbox(Sandbox2* sandbox) {
+    return GetParam() ? sandbox->EnableUnotifyMonitor() : absl::OkStatus();
+  }
+};
+
 // Test EventSyscallTrap on personality syscall and allow it.
-TEST(NotifyTest, AllowPersonality) {
+TEST_P(NotifyTest, AllowPersonality) {
   const std::string path = GetTestSourcePath("sandbox2/testcases/personality");
   std::vector<std::string> args = {path};
   Sandbox2 s2(std::make_unique<Executor>(path, args),
               NotifyTestcasePolicy(path),
               std::make_unique<PersonalityNotify>(/*allow=*/true));
+  ASSERT_THAT(SetUpSandbox(&s2), IsOk());
   auto result = s2.Run();
 
   ASSERT_THAT(result.final_status(), Eq(Result::OK));
@@ -100,12 +128,13 @@ TEST(NotifyTest, AllowPersonality) {
 }
 
 // Test EventSyscallTrap on personality syscall and disallow it.
-TEST(NotifyTest, DisallowPersonality) {
+TEST_P(NotifyTest, DisallowPersonality) {
   const std::string path = GetTestSourcePath("sandbox2/testcases/personality");
   std::vector<std::string> args = {path};
   Sandbox2 s2(std::make_unique<Executor>(path, args),
               NotifyTestcasePolicy(path),
               std::make_unique<PersonalityNotify>(/*allow=*/false));
+  ASSERT_THAT(SetUpSandbox(&s2), IsOk());
   auto result = s2.Run();
 
   ASSERT_THAT(result.final_status(), Eq(Result::VIOLATION));
@@ -113,7 +142,7 @@ TEST(NotifyTest, DisallowPersonality) {
 }
 
 // Test EventStarted by exchanging data after started but before sandboxed.
-TEST(NotifyTest, PrintPidAndComms) {
+TEST_P(NotifyTest, PrintPidAndComms) {
   const std::string path = GetTestSourcePath("sandbox2/testcases/pidcomms");
   std::vector<std::string> args = {path};
   auto executor = std::make_unique<Executor>(path, args);
@@ -121,14 +150,34 @@ TEST(NotifyTest, PrintPidAndComms) {
 
   Sandbox2 s2(std::move(executor), NotifyTestcasePolicy(path),
               std::make_unique<PidCommsNotify>());
+  ASSERT_THAT(SetUpSandbox(&s2), IsOk());
   auto result = s2.Run();
 
   ASSERT_THAT(result.final_status(), Eq(Result::OK));
   EXPECT_THAT(result.reason_code(), Eq(33));
 }
 
+// Test EventFinished by exchanging data after started but before sandboxed.
+TEST_P(NotifyTest, EventFinished) {
+  const std::string path = GetTestSourcePath("sandbox2/testcases/minimal");
+  std::vector<std::string> args = {path};
+  auto executor = std::make_unique<Executor>(path, args);
+
+  auto notify = std::make_unique<FinishedNotify>();
+  FinishedNotify* notify_ptr = notify.get();
+  Sandbox2 s2(std::move(executor), NotifyTestcasePolicy(path),
+              std::move(notify));
+  ASSERT_THAT(SetUpSandbox(&s2), IsOk());
+  EXPECT_FALSE(notify_ptr->IsFinished());
+  auto result = s2.Run();
+  EXPECT_TRUE(notify_ptr->IsFinished());
+
+  ASSERT_THAT(result.final_status(), Eq(Result::OK));
+  EXPECT_THAT(result.reason_code(), Eq(0));
+}
+
 // Test EventSyscallTrap on personality syscall through TraceAllSyscalls
-TEST(NotifyTest, TraceAllAllowPersonality) {
+TEST_P(NotifyTest, TraceAllAllowPersonality) {
   const std::string path = GetTestSourcePath("sandbox2/testcases/personality");
   std::vector<std::string> args = {path};
   auto policy = CreateDefaultPermissiveTestPolicy(path)
@@ -137,11 +186,19 @@ TEST(NotifyTest, TraceAllAllowPersonality) {
   Sandbox2 s2(std::make_unique<Executor>(path, args),
               NotifyTestcasePolicy(path),
               std::make_unique<PersonalityNotify>(/*allow=*/true));
+
+  ASSERT_THAT(SetUpSandbox(&s2), IsOk());
   auto result = s2.Run();
 
   ASSERT_THAT(result.final_status(), Eq(Result::OK));
   EXPECT_THAT(result.reason_code(), Eq(22));
 }
 
+INSTANTIATE_TEST_SUITE_P(Notify, NotifyTest, ::testing::Values(false, true),
+                         [](const ::testing::TestParamInfo<bool>& info) {
+                           return info.param ? "UnotifyMonitor"
+                                             : "PtraceMonitor";
+                         });
+
 }  // namespace
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/policy.cc b/sandboxed_api/sandbox2/policy.cc
index 721abcf..0a5cac0 100644
--- a/sandboxed_api/sandbox2/policy.cc
+++ b/sandboxed_api/sandbox2/policy.cc
@@ -22,8 +22,10 @@
 #include <linux/filter.h>
 #include <linux/seccomp.h>
 #include <sched.h>
+#include <sys/mman.h>
 #include <syscall.h>
 
+#include <cerrno>
 #include <cstdint>
 #include <limits>
 #include <optional>
@@ -35,21 +37,14 @@
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/sandbox2/bpfdisassembler.h"
-#include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/syscall.h"
+#include "sandboxed_api/sandbox2/util.h"
 #include "sandboxed_api/sandbox2/util/bpf_helper.h"
-#include "sandboxed_api/util/raw_logging.h"
 
 #ifndef SECCOMP_FILTER_FLAG_NEW_LISTENER
 #define SECCOMP_FILTER_FLAG_NEW_LISTENER (1UL << 3)
 #endif
 
-#ifndef SECCOMP_RET_USER_NOTIF
-#define SECCOMP_RET_USER_NOTIF 0x7fc00000U /* notifies userspace */
-#endif
-
-#define DO_USER_NOTIF BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_USER_NOTIF)
-
 ABSL_FLAG(bool, sandbox2_danger_danger_permit_all, false,
           "Allow all syscalls, useful for testing");
 ABSL_FLAG(std::string, sandbox2_danger_danger_permit_all_and_log, "",
@@ -81,15 +76,6 @@ std::vector<sock_filter> Policy::GetPolicy(bool user_notif) const {
   // 3. Finish with default KILL action.
   policy.push_back(KILL);
 
-  // In seccomp_unotify mode replace all KILLS with unotify
-  if (user_notif) {
-    for (sock_filter& filter : policy) {
-      if (filter.code == BPF_RET + BPF_K && filter.k == SECCOMP_RET_KILL) {
-        filter = DO_USER_NOTIF;
-      }
-    }
-  }
-
   VLOG(2) << "Final policy:\n" << bpf::Disasm(policy);
   return policy;
 }
@@ -100,7 +86,6 @@ std::vector<sock_filter> Policy::GetPolicy(bool user_notif) const {
 // Produces a policy which returns SECCOMP_RET_TRACE instead of SECCOMP_RET_KILL
 // for the __NR_execve syscall, so the tracer can make a decision to allow or
 // disallow it depending on which occurrence of __NR_execve it was.
-// LINT.IfChange
 std::vector<sock_filter> Policy::GetDefaultPolicy(bool user_notif) const {
   bpf_labels l = {0};
 
@@ -112,7 +97,6 @@ std::vector<sock_filter> Policy::GetDefaultPolicy(bool user_notif) const {
         LOAD_ARCH,
         JNE32(Syscall::GetHostAuditArch(), DENY),
         LOAD_SYSCALL_NR,
-        // TODO(b/271400371) Use NOTIF_FLAG_CONTINUE once generally available
         JNE32(__NR_seccomp, JUMP(&l, past_seccomp_l)),
         ARG_32(3),
         JNE32(internal::kExecveMagic, JUMP(&l, past_seccomp_l)),
@@ -131,34 +115,43 @@ std::vector<sock_filter> Policy::GetDefaultPolicy(bool user_notif) const {
     };
   } else {
     policy = {
-      // If compiled arch is different from the runtime one, inform the Monitor.
-      LOAD_ARCH,
-      JEQ32(Syscall::GetHostAuditArch(), JUMP(&l, past_arch_check_l)),
+        // If compiled arch is different from the runtime one, inform the
+        // Monitor.
+        LOAD_ARCH,
+        JEQ32(Syscall::GetHostAuditArch(), JUMP(&l, past_arch_check_l)),
 #if defined(SAPI_X86_64)
-      JEQ32(AUDIT_ARCH_I386, TRACE(sapi::cpu::kX86)),  // 32-bit sandboxee
+        JEQ32(AUDIT_ARCH_I386, TRACE(sapi::cpu::kX86)),  // 32-bit sandboxee
 #endif
-      TRACE(sapi::cpu::kUnknown),
-      LABEL(&l, past_arch_check_l),
+        TRACE(sapi::cpu::kUnknown),
+        LABEL(&l, past_arch_check_l),
 
-      // After the policy is uploaded, forkserver will execve the sandboxee. We
-      // need to allow this execve but not others. Since BPF does not have
-      // state, we need to inform the Monitor to decide, and for that we use a
-      // magic value in syscall args 5. Note that this value is not supposed to
-      // be secret, but just an optimization so that the monitor is not
-      // triggered on every call to execveat.
-      LOAD_SYSCALL_NR,
-      JNE32(__NR_execveat, JUMP(&l, past_execveat_l)),
-      ARG_32(4),
-      JNE32(AT_EMPTY_PATH, JUMP(&l, past_execveat_l)),
-      ARG_32(5),
-      JNE32(internal::kExecveMagic, JUMP(&l, past_execveat_l)),
-      SANDBOX2_TRACE,
-      LABEL(&l, past_execveat_l),
+        // After the policy is uploaded, forkserver will execve the sandboxee.
+        // We need to allow this execve but not others. Since BPF does not have
+        // state, we need to inform the Monitor to decide, and for that we use a
+        // magic value in syscall args 5. Note that this value is not supposed
+        // to be secret, but just an optimization so that the monitor is not
+        // triggered on every call to execveat.
+        LOAD_SYSCALL_NR,
+        JNE32(__NR_execveat, JUMP(&l, past_execveat_l)),
+        ARG_32(4),
+        JNE32(AT_EMPTY_PATH, JUMP(&l, past_execveat_l)),
+        ARG_32(5),
+        JNE32(internal::kExecveMagic, JUMP(&l, past_execveat_l)),
+        SANDBOX2_TRACE,
+        LABEL(&l, past_execveat_l),
 
-      LOAD_SYSCALL_NR,
+        LOAD_SYSCALL_NR,
     };
   }
 
+  // Insert a custom syscall to signal the sandboxee it's running inside a
+  // sandbox.
+  // Executing a syscall with ID util::kMagicSyscallNo will return
+  // util::kMagicSyscallErr when the call by the sandboxee code is made inside
+  // the sandbox and ENOSYS when it is not inside the sandbox.
+  policy.insert(policy.end(), {SYSCALL(internal::kMagicSyscallNo,
+                                       ERRNO(internal::kMagicSyscallErr))});
+
   // Forbid ptrace because it's unsafe or too risky. The user policy can only
   // block (i.e. return an error instead of killing the process) but not allow
   // ptrace. This uses LOAD_SYSCALL_NR from above.
@@ -167,10 +160,36 @@ std::vector<sock_filter> Policy::GetDefaultPolicy(bool user_notif) const {
   }
 
   // If user policy doesn't mention it, then forbid bpf because it's unsafe or
-  // too risky.  This uses LOAD_SYSCALL_NR from above.
+  // too risky. This uses LOAD_SYSCALL_NR from above.
   if (!user_policy_handles_bpf_) {
     policy.insert(policy.end(), {JEQ32(__NR_bpf, DENY)});
   }
+
+  if (!allow_map_exec_) {
+    policy.insert(
+        policy.end(),
+        {
+#ifdef __NR_mmap
+            JNE32(__NR_mmap, JUMP(&l, past_map_exec_l)),
+#endif
+#ifdef __NR_mmap2  // Arm32
+            JNE32(__NR_mmap2, JUMP(&l, past_map_exec_l)),
+#endif
+            JNE32(__NR_mprotect, JUMP(&l, past_map_exec_l)),
+#ifdef __NR_pkey_mprotect
+            JNE32(__NR_pkey_mprotect, JUMP(&l, past_map_exec_l)),
+#endif
+            // Load "prot" argument, which is the same for all four syscalls.
+            ARG_32(2),
+            // Deny executable mappings. This also disallows them for all PKEYS
+            // (not just the default one).
+            JA32(PROT_EXEC, DENY),
+
+            LABEL(&l, past_map_exec_l),
+            LOAD_SYSCALL_NR,
+        });
+  }
+
 #ifndef CLONE_NEWCGROUP
 #define CLONE_NEWCGROUP 0x02000000
 #endif
@@ -220,49 +239,22 @@ std::vector<sock_filter> Policy::GetDefaultPolicy(bool user_notif) const {
 
   return policy;
 }
-// LINT.ThenChange(monitor_ptrace.cc)
 
 std::vector<sock_filter> Policy::GetTrackingPolicy() const {
   return {
-    LOAD_ARCH,
+      LOAD_ARCH,
 #if defined(SAPI_X86_64)
-        JEQ32(AUDIT_ARCH_X86_64, TRACE(sapi::cpu::kX8664)),
-        JEQ32(AUDIT_ARCH_I386, TRACE(sapi::cpu::kX86)),
+      JEQ32(AUDIT_ARCH_X86_64, TRACE(sapi::cpu::kX8664)),
+      JEQ32(AUDIT_ARCH_I386, TRACE(sapi::cpu::kX86)),
 #elif defined(SAPI_PPC64_LE)
-        JEQ32(AUDIT_ARCH_PPC64LE, TRACE(sapi::cpu::kPPC64LE)),
+      JEQ32(AUDIT_ARCH_PPC64LE, TRACE(sapi::cpu::kPPC64LE)),
 #elif defined(SAPI_ARM64)
-        JEQ32(AUDIT_ARCH_AARCH64, TRACE(sapi::cpu::kArm64)),
+      JEQ32(AUDIT_ARCH_AARCH64, TRACE(sapi::cpu::kArm64)),
 #elif defined(SAPI_ARM)
-        JEQ32(AUDIT_ARCH_ARM, TRACE(sapi::cpu::kArm)),
+      JEQ32(AUDIT_ARCH_ARM, TRACE(sapi::cpu::kArm)),
 #endif
-        TRACE(sapi::cpu::kUnknown),
+      TRACE(sapi::cpu::kUnknown),
   };
 }
 
-bool Policy::SendPolicy(Comms* comms, bool user_notif) const {
-  auto policy = GetPolicy(user_notif);
-  if (!comms->SendBytes(
-          reinterpret_cast<uint8_t*>(policy.data()),
-          static_cast<uint64_t>(policy.size()) * sizeof(sock_filter))) {
-    LOG(ERROR) << "Couldn't send policy";
-    return false;
-  }
-
-  return true;
-}
-
-void Policy::GetPolicyDescription(PolicyDescription* policy) const {
-  policy->set_user_bpf_policy(user_policy_.data(),
-                              user_policy_.size() * sizeof(sock_filter));
-  if (policy_builder_description_) {
-    *policy->mutable_policy_builder_description() =
-        *policy_builder_description_;
-  }
-
-  if (namespace_) {
-    namespace_->GetNamespaceDescription(
-        policy->mutable_namespace_description());
-  }
-}
-
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/policy.h b/sandboxed_api/sandbox2/policy.h
index 0f0385b..99500a3 100644
--- a/sandboxed_api/sandbox2/policy.h
+++ b/sandboxed_api/sandbox2/policy.h
@@ -29,7 +29,6 @@
 #include "sandboxed_api/sandbox2/namespace.h"
 #include "sandboxed_api/sandbox2/network_proxy/filtering.h"
 #include "sandboxed_api/sandbox2/syscall.h"  // IWYU pragma: export
-#include "sandboxed_api/sandbox2/violation.pb.h"
 
 #define SANDBOX2_TRACE         \
   BPF_STMT(BPF_RET + BPF_K,    \
@@ -44,7 +43,6 @@ namespace internal {
 inline constexpr uintptr_t kExecveMagic = 0x921c2c34;
 }  // namespace internal
 
-class Comms;
 class MonitorBase;
 class PolicyBuilder;
 
@@ -56,13 +54,6 @@ class Policy final {
   Policy(Policy&&) = delete;
   Policy& operator=(Policy&&) = delete;
 
-  // Stores information about the policy (and the policy builder if existing)
-  // in the protobuf structure.
-  void GetPolicyDescription(PolicyDescription* policy) const;
-
-  // Sends the policy over the IPC channel.
-  bool SendPolicy(Comms* comms, bool user_notif) const;
-
   // Returns the policy, but modifies it according to FLAGS and internal
   // requirements (message passing via Comms, Executor::WaitForExecve etc.).
   std::vector<sock_filter> GetPolicy(bool user_notif) const;
@@ -104,8 +95,8 @@ class Policy final {
   bool collect_stacktrace_on_kill_ = true;
   bool collect_stacktrace_on_exit_ = false;
 
-  // Optional pointer to a PolicyBuilder description pb object.
-  std::optional<PolicyBuilderDescription> policy_builder_description_;
+  bool allow_map_exec_ = false;
+  bool allow_speculation_ = false;
 
   // The policy set by the user.
   std::vector<sock_filter> user_policy_;
diff --git a/sandboxed_api/sandbox2/policy_test.cc b/sandboxed_api/sandbox2/policy_test.cc
index a1a192c..b4d5d0c 100644
--- a/sandboxed_api/sandbox2/policy_test.cc
+++ b/sandboxed_api/sandbox2/policy_test.cc
@@ -43,9 +43,9 @@ using ::sapi::GetTestSourcePath;
 using ::testing::Eq;
 
 #ifdef SAPI_X86_64
+
 // Test that 32-bit syscalls from 64-bit are disallowed.
 TEST(PolicyTest, AMD64Syscall32PolicyAllowed) {
-  SKIP_ANDROID;
   const std::string path = GetTestSourcePath("sandbox2/testcases/policy");
 
   std::vector<std::string> args = {path, "1"};
@@ -62,7 +62,6 @@ TEST(PolicyTest, AMD64Syscall32PolicyAllowed) {
 
 // Test that 32-bit syscalls from 64-bit for FS checks are disallowed.
 TEST(PolicyTest, AMD64Syscall32FsAllowed) {
-  SKIP_ANDROID;
   const std::string path = GetTestSourcePath("sandbox2/testcases/policy");
   std::vector<std::string> args = {path, "2"};
 
@@ -138,9 +137,6 @@ TEST(PolicyTest, BpfPtracePermissionDenied) {
 TEST(PolicyTest, IsattyAllowed) {
   SKIP_SANITIZERS;
   PolicyBuilder builder;
-  if constexpr (sapi::host_os::IsAndroid()) {
-    builder.DisableNamespaces().AllowDynamicStartup();
-  }
   builder.AllowStaticStartup()
       .AllowExit()
       .AllowRead()
@@ -156,14 +152,81 @@ TEST(PolicyTest, IsattyAllowed) {
   ASSERT_THAT(result.final_status(), Eq(Result::OK));
 }
 
-std::unique_ptr<Policy> MinimalTestcasePolicy(absl::string_view path = "") {
-  PolicyBuilder builder;
+PolicyBuilder PosixTimersPolicyBuilder(absl::string_view path) {
+  return PolicyBuilder()
+      // Required by google infra / logging.
+      .AllowDynamicStartup()
+      .AllowWrite()
+      .AllowSyscall(__NR_getcwd)
+      .AllowMmap()
+      .AllowMlock()
+      .AllowMkdir()
+      .AllowGetIDs()
+      .AllowExit()
+      .AllowRestartableSequences(PolicyBuilder::kAllowSlowFences)
+      .AllowSyscall(__NR_rt_sigtimedwait)
+      // Features used by the binary.
+      .AllowHandleSignals()
+      .AllowGetPIDs()
+      .AllowTime()
+      .AllowSleep()
+      .AllowAlarm()
+      // Posix timers themselves.
+      .AllowPosixTimers();
+}
 
-  if constexpr (sapi::host_os::IsAndroid()) {
-    builder.AllowDynamicStartup();
-    builder.DisableNamespaces();
+TEST(PolicyTest, PosixTimersWorkIfAllowed) {
+  SKIP_SANITIZERS;
+  const std::string path = GetTestSourcePath("sandbox2/testcases/posix_timers");
+  for (absl::string_view kind : {"SIGEV_NONE", "SIGEV_SIGNAL",
+                                 "SIGEV_THREAD_ID", "syscall(SIGEV_THREAD)"}) {
+    std::vector<std::string> args = {path, "--sigev_notify_kind",
+                                     std::string(kind)};
+
+    SAPI_ASSERT_OK_AND_ASSIGN(auto policy,
+                              PosixTimersPolicyBuilder(path).TryBuild());
+    auto executor = std::make_unique<Executor>(path, args);
+    Sandbox2 sandbox(std::move(executor), std::move(policy));
+    Result result = sandbox.Run();
+    EXPECT_EQ(result.final_status(), Result::OK) << kind;
   }
+}
+
+TEST(PolicyTest, PosixTimersCannotCreateThreadsIfThreadsAreProhibited) {
+  SKIP_SANITIZERS;
+  const std::string path = GetTestSourcePath("sandbox2/testcases/posix_timers");
+  std::vector<std::string> args = {
+      path,
+      // SIGEV_THREAD creates a thread as an implementation detail.
+      "--sigev_notify_kind=SIGEV_THREAD",
+  };
+
+  SAPI_ASSERT_OK_AND_ASSIGN(auto policy,
+                            PosixTimersPolicyBuilder(path).TryBuild());
+  auto executor = std::make_unique<Executor>(path, args);
+  Sandbox2 sandbox(std::move(executor), std::move(policy));
+  Result result = sandbox.Run();
+  EXPECT_EQ(result.final_status(), Result::VIOLATION);
+}
+
+TEST(PolicyTest, PosixTimersCanCreateThreadsIfThreadsAreAllowed) {
+  SKIP_SANITIZERS;
+  const std::string path = GetTestSourcePath("sandbox2/testcases/posix_timers");
+  std::vector<std::string> args = {path, "--sigev_notify_kind=SIGEV_THREAD"};
+
+  SAPI_ASSERT_OK_AND_ASSIGN(auto policy, PosixTimersPolicyBuilder(path)
+                                             .AllowFork()
+                                             // For Arm.
+                                             .AllowSyscall(__NR_madvise)
+                                             .TryBuild());
+  auto executor = std::make_unique<Executor>(path, args);
+  Sandbox2 sandbox(std::move(executor), std::move(policy));
+  Result result = sandbox.Run();
+  EXPECT_EQ(result.final_status(), Result::OK);
+}
 
+std::unique_ptr<Policy> MinimalTestcasePolicy(absl::string_view path = "") {
+  PolicyBuilder builder;
   builder.AllowStaticStartup().AllowExit().AllowLlvmCoverage();
   return builder.BuildOrDie();
 }
@@ -172,7 +235,6 @@ std::unique_ptr<Policy> MinimalTestcasePolicy(absl::string_view path = "") {
 // If this starts failing, it means something changed, maybe in the way we
 // compile static binaries, and we need to update the policy just above.
 TEST(MinimalTest, MinimalBinaryWorks) {
-  SKIP_ANDROID;
   SKIP_SANITIZERS;
   const std::string path = GetTestSourcePath("sandbox2/testcases/minimal");
   std::vector<std::string> args = {path};
@@ -192,14 +254,10 @@ TEST(MinimalTest, MinimalSharedBinaryWorks) {
   std::vector<std::string> args = {path};
 
   PolicyBuilder builder;
-
-  if constexpr (sapi::host_os::IsAndroid()) {
-    builder.DisableNamespaces();
-  } else {
-    builder.AddLibrariesForBinary(path);
-  }
-
-  builder.AllowDynamicStartup().AllowExit().AllowLlvmCoverage();
+  builder.AddLibrariesForBinary(path)
+      .AllowDynamicStartup()
+      .AllowExit()
+      .AllowLlvmCoverage();
   auto policy = builder.BuildOrDie();
 
   Sandbox2 s2(std::make_unique<Executor>(path, args), std::move(policy));
@@ -217,15 +275,6 @@ TEST(MallocTest, SystemMallocWorks) {
   std::vector<std::string> args = {path};
 
   PolicyBuilder builder;
-
-  if constexpr (sapi::host_os::IsAndroid()) {
-    builder.DisableNamespaces();
-    builder.AllowDynamicStartup();
-    builder.AllowSyscalls({
-        __NR_madvise,
-    });
-  }
-
   builder.AllowStaticStartup()
       .AllowSystemMalloc()
       .AllowExit()
@@ -251,11 +300,6 @@ TEST(MultipleSyscalls, AddPolicyOnSyscallsWorks) {
   std::vector<std::string> args = {path};
 
   PolicyBuilder builder;
-  if constexpr (sapi::host_os::IsAndroid()) {
-    builder.DisableNamespaces();
-    builder.AllowDynamicStartup();
-  }
-
   builder.AllowStaticStartup()
       .AllowTcMalloc()
       .AllowExit()
@@ -302,5 +346,23 @@ TEST(MultipleSyscalls, AddPolicyOnSyscallsWorks) {
   EXPECT_THAT(result.reason_code(), Eq(__NR_umask));
 }
 
+// Test that util::kMagicSyscallNo is returns ENOSYS or util::kMagicSyscallErr.
+TEST(PolicyTest, DetectSandboxSyscall) {
+  const std::string path =
+      GetTestSourcePath("sandbox2/testcases/sandbox_detection");
+  std::vector<std::string> args = {path};
+
+  SAPI_ASSERT_OK_AND_ASSIGN(auto policy,
+                            CreateDefaultPermissiveTestPolicy(path).TryBuild());
+  auto executor = std::make_unique<Executor>(path, args);
+  executor->set_enable_sandbox_before_exec(false);
+  Sandbox2 s2(std::move(executor), std::move(policy));
+  auto result = s2.Run();
+
+  // The test binary should exit with success.
+  ASSERT_THAT(result.final_status(), Eq(Result::OK));
+  EXPECT_THAT(result.reason_code(), Eq(0));
+}
+
 }  // namespace
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/policybuilder.cc b/sandboxed_api/sandbox2/policybuilder.cc
index 6fbda54..cdc9dd7 100644
--- a/sandboxed_api/sandbox2/policybuilder.cc
+++ b/sandboxed_api/sandbox2/policybuilder.cc
@@ -42,6 +42,7 @@
 #include <memory>
 #include <optional>
 #include <string>
+#include <type_traits>
 #include <utility>
 #include <vector>
 
@@ -55,14 +56,18 @@
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
 #include "sandboxed_api/config.h"
-#include "sandboxed_api/sandbox2/allow_all_syscalls.h"
-#include "sandboxed_api/sandbox2/allow_unrestricted_networking.h"
+#include "sandboxed_api/sandbox2/allowlists/all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/namespaces.h"
+#include "sandboxed_api/sandbox2/allowlists/seccomp_speculation.h"
+#include "sandboxed_api/sandbox2/allowlists/trace_all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/unrestricted_networking.h"
+#include "sandboxed_api/sandbox2/forkserver.pb.h"
 #include "sandboxed_api/sandbox2/namespace.h"
+#include "sandboxed_api/sandbox2/network_proxy/filtering.h"
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/syscall.h"
-#include "sandboxed_api/sandbox2/trace_all_syscalls.h"
 #include "sandboxed_api/sandbox2/util/bpf_helper.h"
-#include "sandboxed_api/sandbox2/violation.pb.h"
+#include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/path.h"
 
 #if defined(SAPI_X86_64)
@@ -71,9 +76,34 @@
 #include <asm/termbits.h>  // On PPC, TCGETS macro needs termios
 #endif
 
+#ifndef BPF_MAP_LOOKUP_ELEM
+#define BPF_MAP_LOOKUP_ELEM 1
+#endif
+#ifndef BPF_OBJ_GET
+#define BPF_OBJ_GET 7
+#endif
+#ifndef BPF_MAP_GET_NEXT_KEY
+#define BPF_MAP_GET_NEXT_KEY 4
+#endif
+#ifndef BPF_MAP_GET_NEXT_ID
+#define BPF_MAP_GET_NEXT_ID 12
+#endif
+#ifndef BPF_MAP_GET_FD_BY_ID
+#define BPF_MAP_GET_FD_BY_ID 14
+#endif
+#ifndef BPF_OBJ_GET_INFO_BY_FD
+#define BPF_OBJ_GET_INFO_BY_FD 15
+#endif
+
 #ifndef MAP_FIXED_NOREPLACE
 #define MAP_FIXED_NOREPLACE 0x100000
 #endif
+#ifndef MADV_POPULATE_READ
+#define MADV_POPULATE_READ 22  // Linux 5.14+
+#endif
+#ifndef MADV_POPULATE_WRITE  // Linux 5.14+
+#define MADV_POPULATE_WRITE 23
+#endif
 #ifndef PR_SET_VMA
 #define PR_SET_VMA 0x53564d41
 #endif
@@ -85,8 +115,30 @@ namespace sandbox2 {
 namespace {
 
 namespace file = ::sapi::file;
+namespace fileops = ::sapi::file_util::fileops;
+
+// Validates that the path is absolute and canonical.
+absl::StatusOr<std::string> ValidatePath(absl::string_view path,
+                                         bool allow_relative_path = false) {
+  if (path.empty()) {
+    return absl::InvalidArgumentError("Path must not be empty");
+  }
+
+  if (!file::IsAbsolutePath(path) && !allow_relative_path) {
+    return absl::InvalidArgumentError(
+        absl::StrCat("Path must be absolute: ", path));
+  }
 
-constexpr std::array<uint32_t, 2> kMmapSyscalls = {
+  std::string fixed_path = file::CleanPath(path);
+  if (fixed_path != path) {
+    return absl::InvalidArgumentError(
+        absl::StrCat("Path is not canonical: ", path));
+  }
+
+  return fixed_path;
+}
+
+constexpr uint32_t kMmapSyscalls[] = {
 #ifdef __NR_mmap2
     __NR_mmap2,
 #endif
@@ -95,6 +147,23 @@ constexpr std::array<uint32_t, 2> kMmapSyscalls = {
 #endif
 };
 
+constexpr bool CheckMapExec(uint32_t num) {
+  if (num == __NR_mprotect) {
+    return true;
+  }
+#ifdef __NR_pkey_mprotect
+  if (num == __NR_pkey_mprotect) {
+    return true;
+  }
+#endif
+  for (uint32_t mmap_syscall : kMmapSyscalls) {
+    if (num == mmap_syscall) {
+      return true;
+    }
+  }
+  return false;
+}
+
 bool CheckBpfBounds(const sock_filter& filter, size_t max_jmp) {
   if (BPF_CLASS(filter.code) == BPF_JMP) {
     if (BPF_OP(filter.code) == BPF_JA) {
@@ -116,14 +185,53 @@ bool IsOnReadOnlyDev(const std::string& path) {
 
 }  // namespace
 
-PolicyBuilder& PolicyBuilder::Allow(UnrestrictedNetworking tag) {
+PolicyBuilder& PolicyBuilder::DisableNamespaces(NamespacesToken) {
+  if (requires_namespaces_) {
+    SetError(absl::FailedPreconditionError(
+        "Namespaces cannot be both disabled and enabled. You're probably "
+        "using features that implicitly enable namespaces (SetHostname, "
+        "AddFile, AddDirectory, AddDataDependency, AddLibrariesForBinary "
+        "or similar)"));
+    return *this;
+  }
+  use_namespaces_ = false;
+  return *this;
+}
+
+PolicyBuilder& PolicyBuilder::Allow(MapExec) {
+  allow_map_exec_ = true;
+  return *this;
+}
+
+PolicyBuilder& PolicyBuilder::Allow(SeccompSpeculation) {
+  allow_speculation_ = true;
+  return *this;
+}
+
+PolicyBuilder& PolicyBuilder::Allow(UnrestrictedNetworking) {
   EnableNamespaces();  // NOLINT(clang-diagnostic-deprecated-declarations)
-  allow_unrestricted_networking_ = true;
+
+  if (netns_mode_ != NETNS_MODE_UNSPECIFIED) {
+    SetError(absl::FailedPreconditionError(absl::StrCat(
+        "Incompatible with other network namespaces modes. A sandbox can have "
+        "only one network namespace mode. Attempted to configure: ",
+        NetNsMode_Name(netns_mode_))));
+    return *this;
+  }
+
+  netns_mode_ = NETNS_MODE_NONE;
   return *this;
 }
 
 PolicyBuilder& PolicyBuilder::AllowSyscall(uint32_t num) {
-  if (handled_syscalls_.insert(num).second) {
+  if (handled_syscalls_.insert(num).second &&
+      allowed_syscalls_.insert(num).second) {
+    if (!allow_map_exec_ && CheckMapExec(num)) {
+      SetError(absl::FailedPreconditionError(
+          "Allowing unrestricted mmap/mprotect/pkey_mprotect requires "
+          "Allow(MapExec)."));
+      return *this;
+    }
     user_policy_.insert(user_policy_.end(), {SYSCALL(num, ALLOW)});
   }
   return *this;
@@ -145,7 +253,8 @@ PolicyBuilder& PolicyBuilder::BlockSyscallsWithErrno(
 }
 
 PolicyBuilder& PolicyBuilder::BlockSyscallWithErrno(uint32_t num, int error) {
-  if (handled_syscalls_.insert(num).second) {
+  if (handled_syscalls_.insert(num).second &&
+      blocked_syscalls_.insert(num).second) {
     user_policy_.insert(user_policy_.end(), {SYSCALL(num, ERRNO(error))});
     if (num == __NR_bpf) {
       user_policy_handles_bpf_ = true;
@@ -221,6 +330,10 @@ PolicyBuilder& PolicyBuilder::AllowExit() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowScudoMalloc() {
+  if (allowed_complex_.scudo_malloc) {
+    return *this;
+  }
+  allowed_complex_.scudo_malloc = true;
   AllowTime();
   AllowSyscalls({__NR_munmap, __NR_nanosleep});
   AllowFutexOp(FUTEX_WAKE);
@@ -259,10 +372,14 @@ PolicyBuilder& PolicyBuilder::AllowScudoMalloc() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowTcMalloc() {
+  if (allowed_complex_.tcmalloc) {
+    return *this;
+  }
+  allowed_complex_.tcmalloc = true;
   AllowTime();
   AllowRestartableSequences(kRequireFastFences);
-  AllowSyscalls(
-      {__NR_munmap, __NR_nanosleep, __NR_brk, __NR_mincore, __NR_membarrier});
+  AllowSyscalls({__NR_munmap, __NR_nanosleep, __NR_brk, __NR_mincore,
+                 __NR_membarrier, __NR_lseek});
   AllowLimitedMadvise();
   AllowPrctlSetVma();
   AllowPoll();
@@ -282,8 +399,8 @@ PolicyBuilder& PolicyBuilder::AllowTcMalloc() {
 
         // PROT_READ | PROT_WRITE
         ARG_32(3),  // flags
-        JNE32(MAP_ANONYMOUS | MAP_PRIVATE, JUMP(&labels, mmap_end)),
-        ALLOW,
+        JEQ32(MAP_ANONYMOUS | MAP_PRIVATE, ALLOW),
+        JUMP(&labels, mmap_end),
 
         // PROT_NONE
         LABEL(&labels, prot_none),
@@ -298,6 +415,10 @@ PolicyBuilder& PolicyBuilder::AllowTcMalloc() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowSystemMalloc() {
+  if (allowed_complex_.system_malloc) {
+    return *this;
+  }
+  allowed_complex_.system_malloc = true;
   AllowSyscalls({__NR_munmap, __NR_brk});
   AllowFutexOp(FUTEX_WAKE);
   AddPolicyOnSyscall(__NR_mremap, {
@@ -330,6 +451,10 @@ PolicyBuilder& PolicyBuilder::AllowLlvmSanitizers() {
   if constexpr (!sapi::sanitizers::IsAny()) {
     return *this;
   }
+  if (allowed_complex_.llvm_sanitizers) {
+    return *this;
+  }
+  allowed_complex_.llvm_sanitizers = true;
   // *san use a custom allocator that runs mmap/unmap under the hood.  For
   // example:
   // https://github.com/llvm/llvm-project/blob/596d534ac3524052df210be8d3c01a33b2260a42/compiler-rt/lib/asan/asan_allocator.cpp#L980
@@ -350,6 +475,7 @@ PolicyBuilder& PolicyBuilder::AllowLlvmSanitizers() {
   AddPolicyOnSyscall(__NR_madvise, {
                                        ARG_32(2),
                                        JEQ32(MADV_DONTDUMP, ALLOW),
+                                       JEQ32(MADV_DONTNEED, ALLOW),
                                        JEQ32(MADV_NOHUGEPAGE, ALLOW),
                                    });
   // Sanitizers read from /proc. For example:
@@ -365,6 +491,10 @@ PolicyBuilder& PolicyBuilder::AllowLlvmSanitizers() {
   // https://github.com/llvm/llvm-project/blob/9aa39481d9eb718e872993791547053a3c1f16d5/compiler-rt/lib/sanitizer_common/sanitizer_linux_libcdep.cpp#L150
   // https://sourceware.org/git/?p=glibc.git;a=blob;f=nptl/pthread_getattr_np.c;h=de7edfa0928224eb8375e2fe894d6677570fbb3b;hb=HEAD#l188
   AllowSyscall(__NR_sched_getaffinity);
+  // https://github.com/llvm/llvm-project/blob/3cabbf60393cc8d55fe635e35e89e5973162de33/compiler-rt/lib/interception/interception.h#L352
+#ifdef __ELF__
+  AllowDynamicStartup();
+#endif
   // https://github.com/llvm/llvm-project/blob/02c2b472b510ff55679844c087b66e7837e13dc2/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp#L434
 #ifdef __NR_readlink
   OverridableBlockSyscallWithErrno(__NR_readlink, ENOENT);
@@ -383,6 +513,10 @@ PolicyBuilder& PolicyBuilder::AllowLlvmCoverage() {
   if (!sapi::IsCoverageRun()) {
     return *this;
   }
+  if (allowed_complex_.llvm_coverage) {
+    return *this;
+  }
+  allowed_complex_.llvm_coverage = true;
   AllowStat();
   AllowGetPIDs();
   AllowOpen();
@@ -406,13 +540,26 @@ PolicyBuilder& PolicyBuilder::AllowLlvmCoverage() {
         LABEL(&labels, mmap_end),
     };
   });
-  AddDirectoryIfNamespaced(getenv("COVERAGE_DIR"), /*is_ro=*/false);
+  const char* coverage_dir = std::getenv("COVERAGE_DIR");
+  if (!coverage_dir || absl::string_view(coverage_dir).empty()) {
+    LOG(WARNING)
+        << "Environment variable COVERAGE is set but COVERAGE_DIR is not set. "
+           "No directory to collect coverage data will be added to the "
+           "sandbox.";
+    return *this;
+  }
+  AddDirectoryIfNamespaced(coverage_dir, /*is_ro=*/false);
   return *this;
 }
 
 PolicyBuilder& PolicyBuilder::AllowLimitedMadvise() {
+  if (allowed_complex_.limited_madvise) {
+    return *this;
+  }
+  allowed_complex_.limited_madvise = true;
   return AddPolicyOnSyscall(__NR_madvise, {
                                               ARG_32(2),
+                                              JEQ32(MADV_SEQUENTIAL, ALLOW),
                                               JEQ32(MADV_DONTNEED, ALLOW),
                                               JEQ32(MADV_REMOVE, ALLOW),
                                               JEQ32(MADV_HUGEPAGE, ALLOW),
@@ -420,7 +567,23 @@ PolicyBuilder& PolicyBuilder::AllowLimitedMadvise() {
                                           });
 }
 
+PolicyBuilder& PolicyBuilder::AllowMadvisePopulate() {
+  if (allowed_complex_.madvise_populate) {
+    return *this;
+  }
+  allowed_complex_.madvise_populate = true;
+  return AddPolicyOnSyscall(__NR_madvise, {
+                                              ARG_32(2),
+                                              JEQ32(MADV_POPULATE_READ, ALLOW),
+                                              JEQ32(MADV_POPULATE_WRITE, ALLOW),
+                                          });
+}
+
 PolicyBuilder& PolicyBuilder::AllowMmapWithoutExec() {
+  if (allowed_complex_.mmap_without_exec) {
+    return *this;
+  }
+  allowed_complex_.mmap_without_exec = true;
   return AddPolicyOnMmap({
       ARG_32(2),
       BPF_JUMP(BPF_JMP | BPF_JSET | BPF_K, PROT_EXEC, 1, 0),
@@ -428,10 +591,37 @@ PolicyBuilder& PolicyBuilder::AllowMmapWithoutExec() {
   });
 }
 
-PolicyBuilder& PolicyBuilder::AllowMmap() {
+PolicyBuilder& PolicyBuilder::AllowMprotectWithoutExec() {
+  if (allowed_complex_.mprotect_without_exec) {
+    return *this;
+  }
+  allowed_complex_.mprotect_without_exec = true;
+  return AddPolicyOnSyscall(
+      __NR_mprotect, {
+                         ARG_32(2),
+                         BPF_JUMP(BPF_JMP | BPF_JSET | BPF_K, PROT_EXEC, 1, 0),
+                         ALLOW,
+                     });
+}
+
+std::enable_if_t<builder_internal::is_type_complete_v<MapExec>, PolicyBuilder&>
+PolicyBuilder::AllowMmap() {
   return AllowSyscalls(kMmapSyscalls);
 }
 
+PolicyBuilder& PolicyBuilder::AllowMlock() {
+#ifdef __NR_mlock
+  AllowSyscall(__NR_mlock);
+#endif
+#ifdef __NR_munlock
+  AllowSyscall(__NR_munlock);
+#endif
+#ifdef __NR_mlock2
+  AllowSyscall(__NR_mlock2);
+#endif
+  return *this;
+}
+
 PolicyBuilder& PolicyBuilder::AllowOpen() {
 #ifdef __NR_creat
   AllowSyscall(__NR_creat);
@@ -626,6 +816,9 @@ PolicyBuilder& PolicyBuilder::AllowUtime() {
 #ifdef __NR_futimens
       __NR_futimens,
 #endif
+#ifdef __NR_futimesat
+      __NR_futimesat,
+#endif
 #ifdef __NR_utime
       __NR_utime,
 #endif
@@ -638,7 +831,28 @@ PolicyBuilder& PolicyBuilder::AllowUtime() {
   });
 }
 
+PolicyBuilder& PolicyBuilder::AllowSafeBpf() {
+  if (allowed_complex_.safe_bpf) {
+    return *this;
+  }
+  allowed_complex_.safe_bpf = true;
+  user_policy_handles_bpf_ = true;
+  return AddPolicyOnSyscall(__NR_bpf, {
+                                          ARG_32(1),
+                                          JEQ32(BPF_MAP_LOOKUP_ELEM, ALLOW),
+                                          JEQ32(BPF_OBJ_GET, ALLOW),
+                                          JEQ32(BPF_MAP_GET_NEXT_KEY, ALLOW),
+                                          JEQ32(BPF_MAP_GET_NEXT_ID, ALLOW),
+                                          JEQ32(BPF_MAP_GET_FD_BY_ID, ALLOW),
+                                          JEQ32(BPF_OBJ_GET_INFO_BY_FD, ALLOW),
+                                      });
+}
+
 PolicyBuilder& PolicyBuilder::AllowSafeFcntl() {
+  if (allowed_complex_.safe_fcntl) {
+    return *this;
+  }
+  allowed_complex_.safe_fcntl = true;
   return AddPolicyOnSyscalls({__NR_fcntl,
 #ifdef __NR_fcntl64
                               __NR_fcntl64
@@ -685,8 +899,19 @@ PolicyBuilder& PolicyBuilder::AllowAlarm() {
       __NR_setitimer});
 }
 
+PolicyBuilder& PolicyBuilder::AllowPosixTimers() {
+  return AllowSyscalls({
+      __NR_timer_create,
+      __NR_timer_delete,
+      __NR_timer_settime,
+      __NR_timer_gettime,
+      __NR_timer_getoverrun,
+  });
+}
+
 PolicyBuilder& PolicyBuilder::AllowHandleSignals() {
   return AllowSyscalls({
+      __NR_restart_syscall,
       __NR_rt_sigaction,
       __NR_rt_sigreturn,
       __NR_rt_sigprocmask,
@@ -709,6 +934,10 @@ PolicyBuilder& PolicyBuilder::AllowHandleSignals() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowTCGETS() {
+  if (allowed_complex_.tcgets) {
+    return *this;
+  }
+  allowed_complex_.tcgets = true;
   return AddPolicyOnSyscall(__NR_ioctl, {
                                             ARG_32(1),
                                             JEQ32(TCGETS, ALLOW),
@@ -752,43 +981,46 @@ PolicyBuilder& PolicyBuilder::AllowGetIDs() {
 
 PolicyBuilder& PolicyBuilder::AllowRestartableSequences(
     CpuFenceMode cpu_fence_mode) {
+  if (!allowed_complex_.slow_fences && !allowed_complex_.fast_fences) {
 #ifdef __NR_rseq
-  AllowSyscall(__NR_rseq);
-#endif
-  AddPolicyOnMmap([](bpf_labels& labels) -> std::vector<sock_filter> {
-    return {
-        ARG_32(2),  // prot
-        JNE32(PROT_READ | PROT_WRITE, JUMP(&labels, mmap_end)),
-
-        ARG_32(3),  // flags
-        JNE32(MAP_PRIVATE | MAP_ANONYMOUS, JUMP(&labels, mmap_end)),
+    AllowSyscall(__NR_rseq);
+#endif
+    AddPolicyOnMmap([](bpf_labels& labels) -> std::vector<sock_filter> {
+      return {
+          ARG_32(2),  // prot
+          JNE32(PROT_READ | PROT_WRITE, JUMP(&labels, mmap_end)),
+
+          ARG_32(3),  // flags
+          JEQ32(MAP_PRIVATE | MAP_ANONYMOUS, ALLOW),
+
+          LABEL(&labels, mmap_end),
+      };
+    });
+    AllowSyscall(__NR_getcpu);
+    AllowSyscall(__NR_membarrier);
+    AllowFutexOp(FUTEX_WAIT);
+    AllowFutexOp(FUTEX_WAKE);
+    AllowRead();
+    AllowOpen();
+    AllowPoll();
+    AllowSyscall(__NR_close);
+    AddPolicyOnSyscall(__NR_rt_sigprocmask, {
+                                                ARG_32(0),
+                                                JEQ32(SIG_SETMASK, ALLOW),
+                                            });
+    AllowPrctlSetVma();
 
-        ALLOW,
-        LABEL(&labels, mmap_end),
-    };
-  });
-  AllowSyscall(__NR_getcpu);
-  AllowSyscall(__NR_membarrier);
-  AllowFutexOp(FUTEX_WAIT);
-  AllowFutexOp(FUTEX_WAKE);
-  AllowRead();
-  AllowOpen();
-  AllowPoll();
-  AllowSyscall(__NR_close);
-  AddPolicyOnSyscall(__NR_rt_sigprocmask, {
-                                              ARG_32(0),
-                                              JEQ32(SIG_SETMASK, ALLOW),
-                                          });
-  AllowPrctlSetVma();
-  if (cpu_fence_mode == kAllowSlowFences) {
+    AddFileIfNamespaced("/proc/cpuinfo");
+    AddFileIfNamespaced("/proc/stat");
+    AddDirectoryIfNamespaced("/sys/devices/system/cpu");
+  }
+  if (cpu_fence_mode == kAllowSlowFences && !allowed_complex_.slow_fences) {
     AllowSyscall(__NR_sched_getaffinity);
     AllowSyscall(__NR_sched_setaffinity);
-  }
-  AddFileIfNamespaced("/proc/cpuinfo");
-  AddFileIfNamespaced("/proc/stat");
-  AddDirectoryIfNamespaced("/sys/devices/system/cpu");
-  if (cpu_fence_mode == kAllowSlowFences) {
     AddFileIfNamespaced("/proc/self/cpuset");
+    allowed_complex_.slow_fences = true;
+  } else if (cpu_fence_mode == kRequireFastFences) {
+    allowed_complex_.fast_fences = true;
   }
   return *this;
 }
@@ -811,6 +1043,10 @@ PolicyBuilder& PolicyBuilder::AllowGetPGIDs() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowGetRlimit() {
+  if (allowed_complex_.getrlimit) {
+    return *this;
+  }
+  allowed_complex_.getrlimit = true;
 #ifdef __NR_prlimit64
   AddPolicyOnSyscall(__NR_prlimit64, {ARG(2), JEQ64(0, 0, ALLOW)});
 #endif
@@ -839,6 +1075,10 @@ PolicyBuilder& PolicyBuilder::AllowSetRlimit() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowGetRandom() {
+  if (allowed_complex_.getrandom) {
+    return *this;
+  }
+  allowed_complex_.getrandom = true;
   return AddPolicyOnSyscall(__NR_getrandom, {
                                                 ARG_32(2),
                                                 JEQ32(0, ALLOW),
@@ -847,6 +1087,10 @@ PolicyBuilder& PolicyBuilder::AllowGetRandom() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowWipeOnFork() {
+  if (allowed_complex_.wipe_on_fork) {
+    return *this;
+  }
+  allowed_complex_.wipe_on_fork = true;
   // System headers may not be recent enough to include MADV_WIPEONFORK.
   static constexpr uint32_t kMadv_WipeOnFork = 18;
   // The -1 value is used by code to probe that the kernel returns -EINVAL for
@@ -861,6 +1105,10 @@ PolicyBuilder& PolicyBuilder::AllowWipeOnFork() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowLogForwarding() {
+  if (allowed_complex_.log_forwarding) {
+    return *this;
+  }
+  allowed_complex_.log_forwarding = true;
   AllowWrite();
   AllowSystemMalloc();
   AllowTcMalloc();
@@ -939,11 +1187,19 @@ PolicyBuilder& PolicyBuilder::AllowEventFd() {
 }
 
 PolicyBuilder& PolicyBuilder::AllowPrctlSetName() {
+  if (allowed_complex_.prctl_set_name) {
+    return *this;
+  }
+  allowed_complex_.prctl_set_name = true;
   AddPolicyOnSyscall(__NR_prctl, {ARG_32(0), JEQ32(PR_SET_NAME, ALLOW)});
   return *this;
 }
 
 PolicyBuilder& PolicyBuilder::AllowPrctlSetVma() {
+  if (allowed_complex_.prctl_set_vma) {
+    return *this;
+  }
+  allowed_complex_.prctl_set_vma = true;
   AddPolicyOnSyscall(__NR_prctl,
                      [](bpf_labels& labels) -> std::vector<sock_filter> {
                        return {
@@ -969,19 +1225,25 @@ PolicyBuilder& PolicyBuilder::AllowFutexOp(int op) {
 }
 
 PolicyBuilder& PolicyBuilder::AllowStaticStartup() {
+  if (allowed_complex_.static_startup) {
+    return *this;
+  }
+  allowed_complex_.static_startup = true;
   AllowGetRlimit();
   AllowSyscalls({
-    // These syscalls take a pointer, so no restriction.
-    __NR_uname, __NR_brk, __NR_set_tid_address,
+      // These syscalls take a pointer, so no restriction.
+      __NR_uname,
+      __NR_brk,
+      __NR_set_tid_address,
 
 #if defined(__ARM_NR_set_tls)
-        // libc sets the TLS during startup
-        __ARM_NR_set_tls,
+      // libc sets the TLS during startup
+      __ARM_NR_set_tls,
 #endif
 
-        // This syscall takes a pointer and a length.
-        // We could restrict length, but it might change, so not worth it.
-        __NR_set_robust_list,
+      // This syscall takes a pointer and a length.
+      // We could restrict length, but it might change, so not worth it.
+      __NR_set_robust_list,
   });
 
   AllowFutexOp(FUTEX_WAIT_BITSET);
@@ -1022,76 +1284,17 @@ PolicyBuilder& PolicyBuilder::AllowStaticStartup() {
   return *this;
 }
 
-PolicyBuilder& PolicyBuilder::AllowDynamicStartup() {
-#ifdef __ANDROID__
-  AllowSafeFcntl();
-  AllowGetIDs();
-  AllowGetPIDs();
-  AllowGetRandom();
-  AllowSyscalls({
-#ifdef __NR_fstatfs
-      __NR_fstatfs,
-#endif
-#ifdef __NR_fstatfs64
-      __NR_fstatfs64,
-#endif
-      __NR_readlinkat,
-      __NR_sched_getaffinity,
-      __NR_sched_getscheduler,
-  });
-  AllowHandleSignals();
-  AllowFutexOp(FUTEX_WAKE_PRIVATE);
-  AddPolicyOnSyscall(__NR_prctl,
-                     [](bpf_labels& labels) -> std::vector<sock_filter> {
-                       return {
-                           ARG_32(0),  // option
-                           JEQ32(PR_GET_DUMPABLE, ALLOW),
-                           JNE32(PR_SET_VMA, JUMP(&labels, prctl_end)),
-
-                           ARG_32(1),  // arg2
-                           JEQ32(PR_SET_VMA_ANON_NAME, ALLOW),
-
-                           LABEL(&labels, prctl_end),
-                       };
-                     });
-  AddPolicyOnSyscall(__NR_mremap,
-                     {
-                         ARG_32(3),
-                         JEQ32(MREMAP_MAYMOVE | MREMAP_FIXED, ALLOW),
-                     });
-  AddPolicyOnMmap([](bpf_labels& labels) -> std::vector<sock_filter> {
-    return {
-        ARG_32(2),  // prot
-        JEQ32(PROT_NONE, JUMP(&labels, prot_none)),
-        JEQ32(PROT_READ, JUMP(&labels, prot_read)),
-        JEQ32(PROT_READ | PROT_WRITE, JUMP(&labels, prot_RW_or_RX)),
-        JEQ32(PROT_READ | PROT_EXEC, JUMP(&labels, prot_RW_or_RX)),
-
-        // PROT_NONE
-        LABEL(&labels, prot_none),
-        ARG_32(3),  // flags
-        JEQ32(MAP_PRIVATE | MAP_ANONYMOUS, ALLOW),
-        JEQ32(MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, ALLOW),
-        JUMP(&labels, mmap_end),
-
-        // PROT_READ
-        LABEL(&labels, prot_read),
-        ARG_32(3),  // flags
-        JEQ32(MAP_SHARED, ALLOW),
-        JEQ32(MAP_PRIVATE, ALLOW),
-        JEQ32(MAP_PRIVATE | MAP_FIXED, ALLOW),
-        JUMP(&labels, mmap_end),
-
-        // PROT_READ | PROT_WRITE
-        // PROT_READ | PROT_EXEC
-        LABEL(&labels, prot_RW_or_RX),
-        ARG_32(3),  // flags
-        JEQ32(MAP_PRIVATE | MAP_FIXED, ALLOW),
-
-        LABEL(&labels, mmap_end),
-    };
-  });
-#endif
+std::enable_if_t<builder_internal::is_type_complete_v<MapExec>, PolicyBuilder&>
+PolicyBuilder::AllowDynamicStartup() {
+  if (!allow_map_exec_) {
+    SetError(absl::FailedPreconditionError(
+        "Allowing dynamic startup requires Allow(MapExec)."));
+    return *this;
+  }
+  if (allowed_complex_.dynamic_startup) {
+    return *this;
+  }
+  allowed_complex_.dynamic_startup = true;
 
   AllowAccess();
   AllowOpen();
@@ -1135,6 +1338,7 @@ PolicyBuilder& PolicyBuilder::AllowDynamicStartup() {
         LABEL(&labels, prot_exec),
         ARG_32(3),  // flags
         JEQ32(MAP_FILE | MAP_PRIVATE | MAP_DENYWRITE, ALLOW),
+        JEQ32(MAP_FILE | MAP_PRIVATE | MAP_DENYWRITE | MAP_FIXED, ALLOW),
 
         LABEL(&labels, mmap_end),
     };
@@ -1218,6 +1422,7 @@ PolicyBuilder& PolicyBuilder::AddPolicyOnSyscalls(
     uint8_t jt = out.size() - do_policy_loc;
     out.push_front(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, *it, jt, jf));
   }
+  custom_policy_syscalls_.insert(nums.begin(), nums.end());
   user_policy_.insert(user_policy_.end(), out.begin(), out.end());
   return *this;
 }
@@ -1250,25 +1455,6 @@ PolicyBuilder& PolicyBuilder::DefaultAction(TraceAllSyscalls) {
   return *this;
 }
 
-absl::StatusOr<std::string> PolicyBuilder::ValidateAbsolutePath(
-    absl::string_view path) {
-  if (!file::IsAbsolutePath(path)) {
-    return absl::InvalidArgumentError(
-        absl::StrCat("Path is not absolute: '", path, "'"));
-  }
-  return ValidatePath(path);
-}
-
-absl::StatusOr<std::string> PolicyBuilder::ValidatePath(
-    absl::string_view path) {
-  std::string fixed_path = file::CleanPath(path);
-  if (fixed_path != path) {
-    return absl::InvalidArgumentError(absl::StrCat(
-        "Path was not normalized. '", path, "' != '", fixed_path, "'"));
-  }
-  return fixed_path;
-}
-
 std::vector<sock_filter> PolicyBuilder::ResolveBpfFunc(BpfFunc f) {
   bpf_labels l = {0};
 
@@ -1292,44 +1478,45 @@ absl::StatusOr<std::unique_ptr<Policy>> PolicyBuilder::TryBuild() {
   }
 
   // Using `new` to access a non-public constructor.
-  auto output = absl::WrapUnique(new Policy());
+  auto policy = absl::WrapUnique(new Policy());
 
   if (already_built_) {
     return absl::FailedPreconditionError("Can only build policy once.");
   }
 
   if (use_namespaces_) {
-    if (allow_unrestricted_networking_ && hostname_ != kDefaultHostname) {
+    // If no specific netns mode is set, default to per-sandboxee.
+    if (netns_mode_ == NETNS_MODE_UNSPECIFIED) {
+      netns_mode_ = NETNS_MODE_PER_SANDBOXEE;
+    }
+    if (netns_mode_ == NETNS_MODE_NONE && hostname_ != kDefaultHostname) {
       return absl::FailedPreconditionError(
           "Cannot set hostname without network namespaces.");
     }
-    output->namespace_ =
-        Namespace(allow_unrestricted_networking_, std::move(mounts_), hostname_,
-                  allow_mount_propagation_);
+    policy->namespace_ = Namespace(std::move(mounts_), hostname_, netns_mode_,
+                                   allow_mount_propagation_);
   }
 
-  output->collect_stacktrace_on_signal_ = collect_stacktrace_on_signal_;
-  output->collect_stacktrace_on_violation_ = collect_stacktrace_on_violation_;
-  output->collect_stacktrace_on_timeout_ = collect_stacktrace_on_timeout_;
-  output->collect_stacktrace_on_kill_ = collect_stacktrace_on_kill_;
-  output->collect_stacktrace_on_exit_ = collect_stacktrace_on_exit_;
-  output->user_policy_ = std::move(user_policy_);
+  policy->allow_map_exec_ = allow_map_exec_;
+  policy->allow_speculation_ = allow_speculation_;
+  policy->collect_stacktrace_on_signal_ = collect_stacktrace_on_signal_;
+  policy->collect_stacktrace_on_violation_ = collect_stacktrace_on_violation_;
+  policy->collect_stacktrace_on_timeout_ = collect_stacktrace_on_timeout_;
+  policy->collect_stacktrace_on_kill_ = collect_stacktrace_on_kill_;
+  policy->collect_stacktrace_on_exit_ = collect_stacktrace_on_exit_;
+  policy->user_policy_ = std::move(user_policy_);
   if (default_action_) {
-    output->user_policy_.push_back(*default_action_);
+    policy->user_policy_.push_back(*default_action_);
   }
-  output->user_policy_.insert(output->user_policy_.end(),
+  policy->user_policy_.insert(policy->user_policy_.end(),
                               overridable_policy_.begin(),
                               overridable_policy_.end());
-  output->user_policy_handles_bpf_ = user_policy_handles_bpf_;
-  output->user_policy_handles_ptrace_ = user_policy_handles_ptrace_;
-
-  PolicyBuilderDescription pb_description;
+  policy->user_policy_handles_bpf_ = user_policy_handles_bpf_;
+  policy->user_policy_handles_ptrace_ = user_policy_handles_ptrace_;
 
-  StoreDescription(&pb_description);
-  output->policy_builder_description_ = pb_description;
-  output->allowed_hosts_ = std::move(allowed_hosts_);
+  policy->allowed_hosts_ = std::move(allowed_hosts_);
   already_built_ = true;
-  return std::move(output);
+  return std::move(policy);
 }
 
 PolicyBuilder& PolicyBuilder::AddFile(absl::string_view path, bool is_ro) {
@@ -1350,7 +1537,7 @@ PolicyBuilder& PolicyBuilder::AddFileIfNamespaced(absl::string_view path,
 PolicyBuilder& PolicyBuilder::AddFileAtIfNamespaced(absl::string_view outside,
                                                     absl::string_view inside,
                                                     bool is_ro) {
-  auto valid_outside = ValidateAbsolutePath(outside);
+  auto valid_outside = ValidatePath(outside);
   if (!valid_outside.ok()) {
     SetError(valid_outside.status());
     return *this;
@@ -1385,7 +1572,7 @@ PolicyBuilder& PolicyBuilder::AddLibrariesForBinary(
     absl::string_view path, absl::string_view ld_library_path) {
   EnableNamespaces();  // NOLINT(clang-diagnostic-deprecated-declarations)
 
-  auto valid_path = ValidatePath(path);
+  auto valid_path = ValidatePath(path, /*allow_relative_path=*/true);
   if (!valid_path.ok()) {
     SetError(valid_path.status());
     return *this;
@@ -1423,7 +1610,7 @@ PolicyBuilder& PolicyBuilder::AddDirectoryIfNamespaced(absl::string_view path,
 
 PolicyBuilder& PolicyBuilder::AddDirectoryAtIfNamespaced(
     absl::string_view outside, absl::string_view inside, bool is_ro) {
-  auto valid_outside = ValidateAbsolutePath(outside);
+  auto valid_outside = ValidatePath(outside);
   if (!valid_outside.ok()) {
     SetError(valid_outside.status());
     return *this;
@@ -1465,11 +1652,26 @@ PolicyBuilder& PolicyBuilder::AddTmpfs(absl::string_view inside, size_t size) {
   return *this;
 }
 
-// Use Allow(UnrestrictedNetworking()) instead.
+// Use Allow(sandbox2::UnrestrictedNetworking()) instead.
 PolicyBuilder& PolicyBuilder::AllowUnrestrictedNetworking() {
   return Allow(UnrestrictedNetworking());
 }
 
+PolicyBuilder& PolicyBuilder::UseForkServerSharedNetNs() {
+  EnableNamespaces();  // NOLINT(clang-diagnostic-deprecated-declarations)
+
+  if (netns_mode_ != NETNS_MODE_UNSPECIFIED) {
+    SetError(absl::FailedPreconditionError(absl::StrCat(
+        "Incompatible with other network namespaces modes. A sandbox can have "
+        "only one network namespace mode. Attempted to configure: ",
+        NetNsMode_Name(netns_mode_))));
+    return *this;
+  }
+
+  netns_mode_ = NETNS_MODE_SHARED_PER_FORKSERVER;
+  return *this;
+}
+
 PolicyBuilder& PolicyBuilder::SetHostname(absl::string_view hostname) {
   EnableNamespaces();  // NOLINT(clang-diagnostic-deprecated-declarations)
   hostname_ = std::string(hostname);
@@ -1512,6 +1714,7 @@ PolicyBuilder& PolicyBuilder::AddNetworkProxyPolicy() {
 
   allowed_hosts_ = AllowedHosts();
 
+  AllowSafeFcntl();
   AllowFutexOp(FUTEX_WAKE);
   AllowFutexOp(FUTEX_WAIT);
   AllowFutexOp(FUTEX_WAIT_BITSET);
@@ -1586,12 +1789,6 @@ PolicyBuilder& PolicyBuilder::SetRootWritable() {
   return *this;
 }
 
-void PolicyBuilder::StoreDescription(PolicyBuilderDescription* pb_description) {
-  for (const auto& handled_syscall : handled_syscalls_) {
-    pb_description->add_handled_syscalls(handled_syscall);
-  }
-}
-
 PolicyBuilder& PolicyBuilder::AllowIPv4(const std::string& ip_and_mask,
                                         uint32_t port) {
   if (!allowed_hosts_) {
@@ -1630,4 +1827,44 @@ PolicyBuilder& PolicyBuilder::SetError(const absl::Status& status) {
   return *this;
 }
 
+std::string PolicyBuilder::AnchorPathAbsolute(absl::string_view relative_path,
+                                              absl::string_view base) {
+  if (relative_path.empty()) {
+    LOG(ERROR) << "Passed relative_path is empty";
+    return "";
+  }
+
+  if (file::IsAbsolutePath(relative_path)) {
+    VLOG(3) << "Nothing to do, relative_path is absolute";
+    return std::string(relative_path);
+  }
+
+  std::string clean_path = file::CleanPath(relative_path);
+  if (absl::StartsWith(clean_path, "../") || clean_path == "..") {
+    LOG(ERROR)
+        << "Anchored path would be outside of base because relative_path: '"
+        << relative_path << "' starts with '..'";
+    return "";
+  }
+
+  if (file::IsAbsolutePath(base)) {
+    return file::CleanPath(file::JoinPath(base, clean_path));
+  }
+
+  std::string cwd = fileops::GetCWD();
+  if (cwd.empty()) {
+    LOG(ERROR) << "Failed to get current working directory";
+    return "";
+  }
+
+  if (base.empty()) {
+    VLOG(1) << "Using current working directory as base is empty";
+    // CWD is guaranteed to exist and clean_path is guaranteed to not start with
+    // '..'.
+    return file::CleanPath(file::JoinPath(cwd, clean_path));
+  }
+
+  return file::CleanPath(file::JoinPath(cwd, base, clean_path));
+}
+
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/policybuilder.h b/sandboxed_api/sandbox2/policybuilder.h
index 5485833..a5827b4 100644
--- a/sandboxed_api/sandbox2/policybuilder.h
+++ b/sandboxed_api/sandbox2/policybuilder.h
@@ -22,6 +22,7 @@
 #include <functional>
 #include <memory>
 #include <string>
+#include <type_traits>
 #include <utility>
 #include <vector>
 
@@ -34,6 +35,8 @@
 #include "absl/strings/string_view.h"
 #include "absl/types/optional.h"
 #include "absl/types/span.h"
+#include "sandboxed_api/sandbox2/allowlists/map_exec.h"  // Temporary
+#include "sandboxed_api/sandbox2/forkserver.pb.h"
 #include "sandboxed_api/sandbox2/mounts.h"
 #include "sandboxed_api/sandbox2/network_proxy/filtering.h"
 #include "sandboxed_api/sandbox2/policy.h"
@@ -43,19 +46,34 @@ struct bpf_labels;
 namespace sandbox2 {
 
 class AllowAllSyscalls;
+class NamespacesToken;
+class LoadUserBpfCodeFromFile;
+class MapExec;
+class SeccompSpeculation;
 class TraceAllSyscalls;
 class UnrestrictedNetworking;
 
+namespace builder_internal {
+
+template <typename, typename = void>
+constexpr bool is_type_complete_v = false;
+
+template <typename T>
+constexpr bool is_type_complete_v<T, std::void_t<decltype(sizeof(T))>> = true;
+
+}  // namespace builder_internal
+
 // PolicyBuilder is a helper class to simplify creation of policies. The builder
 // uses fluent interface for convenience and increased readability of policies.
 //
 // To build a policy you simply create a new builder object, call methods on it
-// specifying what you want and finally call BuildOrDie() to generate you
+// specifying what you want and finally call `BuildOrDie()` to generate you
 // policy.
 //
 // For instance this would generate a simple policy suitable for binaries doing
 // only computations:
 //
+// ```c++
 // std::unique_ptr<Policy> policy =
 //     PolicyBuilder()
 //       .AllowRead()
@@ -63,37 +81,47 @@ class UnrestrictedNetworking;
 //       .AllowExit()
 //       .AllowSystemMalloc()
 //       .BuildOrDie();
+// ```
 //
-// Note that operations are executed in the order they are dictated, though in
-// most cases this has no influence since the operations themselves commute.
+// Operations are executed in the order they are dictated, though in most cases
+// this has no influence since the operations themselves commute.
 //
 // For instance these two policies are equivalent:
 //
+// ```c++
 // auto policy = PolicyBuilder.AllowRead().AllowWrite().BuildOrDie();
 // auto policy = PolicyBuilder.AllowWrite().AllowRead().BuildOrDie();
+// ```
 //
 // While these two are not:
 //
+//
+// ```c++
 // auto policy = PolicyBuilder.AllowRead().BlockSyscallWithErrno(__NR_read, EIO)
 //                            .BuildOrDie();
 // auto policy = PolicyBuilder.BlockSyscallWithErrno(__NR_read, EIO).AllowRead()
 //                            .BuildOrDie();
+// ```
 //
 // In fact the first one is equivalent to:
 //
+// ```c++
 // auto policy = PolicyBuilder.AllowRead().BuildOrDie();
+// ```
 //
 // If you dislike the chained style, it is also possible to write the first
 // example as this:
 //
+// ```c++
 // PolicyBuilder builder;
 // builder.AllowRead();
 // builder.AllowWrite();
 // builder.AllowExit();
 // builder.AllowSystemMalloc();
 // auto policy = builder.BuildOrDie();
+// ```
 //
-// For a more complicated example, see examples/persistent/persistent_sandbox.cc
+// For a more complicated example, see examples/static/static_sandbox.cc
 class PolicyBuilder final {
  public:
   // Possible CPU fence modes for `AllowRestartableSequences()`
@@ -106,7 +134,9 @@ class PolicyBuilder final {
   };
 
   static constexpr absl::string_view kDefaultHostname = "sandbox2";
+
   // Seccomp takes a 16-bit filter length, so the limit would be 64k.
+  //
   // We set it lower so that there is for sure some room for the default policy.
   static constexpr size_t kMaxUserPolicyLength = 30000;
 
@@ -115,27 +145,74 @@ class PolicyBuilder final {
   // Appends code to allow visibility restricted policy functionality.
   //
   // For example:
-  // Allow(sandbox2::UnrestrictedNetworking);
+  // `Allow(sandbox2::UnrestrictedNetworking);`
   // This allows unrestricted network access by not creating a network
   // namespace.
   //
-  // Each type T is defined in an individual library and individually visibility
-  // restricted.
+  // Each `type T` is defined in an individual library and individually
+  // visibility restricted.
   template <typename... T>
   PolicyBuilder& Allow(T... tags) {
     return (Allow(tags), ...);
   }
 
+  // Disables the use of namespaces.
+  //
+  // The default security posture of Sandbox2 depends on the use of namespaces
+  // and syscall filters. By disabling namespaces, the default security posture
+  // is weakened.
+  //
+  // The consequence of disabling namespaces is that the sandboxee will be able
+  // to access the host's file system, network, and other resources if the
+  // appropriate syscalls are also allowed.
+  //
+  // Disabling namespaces is not recommended and should only be done if
+  // absolutely necessary.
+  PolicyBuilder& DisableNamespaces(NamespacesToken);
+
+  // Allows the use of memory mappings that are marked as executable.
+  //
+  // This applies to the mmap and mprotect syscalls and by default, mapped
+  // memory pages are not allowed to be marked as both writable and executable.
+  //
+  // The use of this API is usually only necessary for JIT engines. To
+  // actually allow executable mappings, the respective mmap()/mprotect()
+  // syscalls need to be added to the policy as well.
+  PolicyBuilder& Allow(MapExec);
+
+  // Allows the sandboxee to benefit from speculative execution.
+  //
+  // By default and on recent (6.x) kernels, additional mitigations are enabled
+  // to prevent speculative execution attacks. This call disables those
+  // mitigations to reclaim some of the performance overhead.
+  //
+  // NOTE: The performance benefits of using this API are highly dependent on
+  // the host CPU architecture and the workload running inside the sandbox.
+  // The Linux kernel will disable both the IBPB and STIBP mitigations for the
+  // the sandboxee on CPUs that support this.
+  //
+  // On newer AMD processors, such as Milan or Genoa, this leads to having fewer
+  // branch mispredictions and thus improved performance. However, forcing STIBP
+  // to be enabled on the machine level is even better, as those CPUs optimize
+  // for this.
+  //
+  // This is an advanced API, so users should make sure they understand the
+  // risks. Do not use in environments with untrusted code and/or data.
+  PolicyBuilder& Allow(SeccompSpeculation);
+
   // Allows unrestricted access to the network by *not* creating a network
-  // namespace. Note that this only disables the network namespace. To
-  // actually allow networking, you would also need to allow networking
-  // syscalls. Calling this function will enable use of namespaces
-  PolicyBuilder& Allow(UnrestrictedNetworking tag);
+  // namespace.
+  //
+  // This only disables the network namespace. To actually allow networking,
+  // you would also need to allow networking syscalls.
+  //
+  // NOTE: Requires namespace support.
+  PolicyBuilder& Allow(UnrestrictedNetworking);
 
-  // Appends code to allow a specific syscall
+  // Appends code to allow a specific syscall.
   PolicyBuilder& AllowSyscall(uint32_t num);
 
-  // Appends code to allow a number of syscalls
+  // Appends code to allow a number of syscalls.
   PolicyBuilder& AllowSyscalls(absl::Span<const uint32_t> nums);
 
   // Appends code to block a syscalls while setting errno to the error given.
@@ -146,6 +223,7 @@ class PolicyBuilder final {
   PolicyBuilder& BlockSyscallWithErrno(uint32_t num, int error);
 
   // Appends code to allow waiting for events on epoll file descriptors.
+  //
   // Allows these syscalls:
   // - epoll_wait
   // - epoll_pwait
@@ -153,6 +231,7 @@ class PolicyBuilder final {
   PolicyBuilder& AllowEpollWait();
 
   // Appends code to allow using epoll.
+  //
   // Allows these syscalls:
   // - epoll_create
   // - epoll_create1
@@ -163,24 +242,28 @@ class PolicyBuilder final {
   PolicyBuilder& AllowEpoll();
 
   // Appends code to allow initializing an inotify instance.
+  //
   // Allows these syscalls:
   // - inotify_init
   // - inotify_init1
   PolicyBuilder& AllowInotifyInit();
 
   // Appends code to allow synchronous I/O multiplexing.
+  //
   // Allows these syscalls:
   // - pselect6
   // - select
   PolicyBuilder& AllowSelect();
 
   // Appends code to allow exiting.
+  //
   // Allows these syscalls:
   // - exit
   // - exit_group
   PolicyBuilder& AllowExit();
 
   // Appends code to allow restartable sequences and necessary /proc files.
+  //
   // Allows these syscalls:
   // - rseq
   // - mmap(..., PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, ...)
@@ -205,18 +288,20 @@ class PolicyBuilder final {
   // If `cpu_fence_mode` is `kRequireFastFences`, RSEQ functionality may not
   // be enabled if fast CPU fences are not available.
   PolicyBuilder& AllowRestartableSequences(CpuFenceMode cpu_fence_mode);
-  ABSL_DEPRECATED("Use AllowRestartableSequences() instead")
+  ABSL_DEPRECATE_AND_INLINE()
   PolicyBuilder& AllowRestartableSequencesWithProcFiles(
       CpuFenceMode cpu_fence_mode) {
     return this->AllowRestartableSequences(cpu_fence_mode);
   }
 
   // Appends code to allow the scudo version of malloc, free and
-  // friends. This should be used in conjunction with namespaces. If scudo
+  // friends.
+  //
+  // This should be used in conjunction with namespaces. If scudo
   // options are passed to the sandboxee through an environment variable, access
   // to "/proc/self/environ" will have to be allowed by the policy.
   //
-  // Note: This function is tuned towards the secure scudo allocator. If you are
+  // NOTE: This function is tuned towards the secure scudo allocator. If you are
   //       using another implementation, this function might not be the most
   //       suitable.
   PolicyBuilder& AllowScudoMalloc();
@@ -224,7 +309,7 @@ class PolicyBuilder final {
   // Appends code to allow the system-allocator version of malloc, free and
   // friends.
   //
-  // Note: This function is tuned towards the malloc implementation in glibc. If
+  // NOTE: This function is tuned towards the malloc implementation in glibc. If
   //       you are using another implementation, this function might not be the
   //       most suitable.
   PolicyBuilder& AllowSystemMalloc();
@@ -233,30 +318,45 @@ class PolicyBuilder final {
   // friends.
   PolicyBuilder& AllowTcMalloc();
 
-  // Allows system calls typically used by the LLVM sanitizers (address
-  // sanitizer, memory sanitizer, and thread sanitizer). This method is
-  // intended as a best effort for adding system calls that are common to many
-  // binaries. It may not be fully inclusive of all potential system calls for
-  // all binaries.
+  // Appends code to allow syscalls typically used by the LLVM sanitizers: ASAN,
+  // MSAN, TSAN.
+  //
+  // NOTE: This method is intended as a best effort for adding syscalls that
+  // are common to many binaries. It may not be fully inclusive of all potential
+  // syscalls for all binaries.
   PolicyBuilder& AllowLlvmSanitizers();
 
-  // Allows system calls typically used by the LLVM coverage.
-  // This method is intended as a best effort.
+  // Appends code to allow syscalls typically used by the LLVM coverage.
+  //
+  // NOTE: This method is intended as a best effort.
   PolicyBuilder& AllowLlvmCoverage();
 
-  // Appends code to allow mmap. Specifically this allows mmap and mmap2 syscall
-  // on architectures where this syscalls exist.
-  // Prefer using AllowMmapWithoutExec as allowing mapping executable pages
+  // Appends code to unconditionally allow mmap. Specifically this allows mmap
+  // and mmap2 syscall on architectures where these syscalls exist.
+  //
+  // This function requires that targets :map_exec library to be linked
+  // against. Otherwise, the PolicyBuilder will fail to build the policy.
+  //
+  // Prefer using `AllowMmapWithoutExec()` as allowing mapping executable pages
   // makes exploitation easier.
-  PolicyBuilder& AllowMmap();
+  std::enable_if_t<builder_internal::is_type_complete_v<MapExec>,
+                   PolicyBuilder&>
+  AllowMmap();
 
   // Appends code to allow mmap calls that don't specify PROT_EXEC.
   PolicyBuilder& AllowMmapWithoutExec();
 
+  // Appends code to allow mprotect calls that don't specify PROT_EXEC.
+  PolicyBuilder& AllowMprotectWithoutExec();
+
+  // Appends code to allow mlock and munlock calls.
+  PolicyBuilder& AllowMlock();
+
   // Appends code to allow calling futex with the given operation.
   PolicyBuilder& AllowFutexOp(int op);
 
   // Appends code to allow opening and possibly creating files or directories.
+  //
   // Allows these syscalls:
   // - creat
   // - open
@@ -264,6 +364,7 @@ class PolicyBuilder final {
   PolicyBuilder& AllowOpen();
 
   // Appends code to allow calling stat, fstat and lstat.
+  //
   // Allows these syscalls:
   // - fstat
   // - fstat64
@@ -285,12 +386,14 @@ class PolicyBuilder final {
   PolicyBuilder& AllowStat();
 
   // Appends code to allow checking file permissions.
+  //
   // Allows these syscalls:
   // - access
   // - faccessat
   PolicyBuilder& AllowAccess();
 
   // Appends code to allow duplicating file descriptors.
+  //
   // Allows these syscalls:
   // - dup
   // - dup2
@@ -298,12 +401,14 @@ class PolicyBuilder final {
   PolicyBuilder& AllowDup();
 
   // Appends code to allow creating pipes.
+  //
   // Allows these syscalls:
   // - pipe
   // - pipe2
   PolicyBuilder& AllowPipe();
 
   // Appends code to allow changing file permissions.
+  //
   // Allows these syscalls:
   // - chmod
   // - fchmod
@@ -311,6 +416,7 @@ class PolicyBuilder final {
   PolicyBuilder& AllowChmod();
 
   // Appends code to allow changing file ownership.
+  //
   // Allows these syscalls:
   // - chown
   // - lchown
@@ -319,6 +425,7 @@ class PolicyBuilder final {
   PolicyBuilder& AllowChown();
 
   // Appends code to the policy to allow reading from file descriptors.
+  //
   // Allows these syscalls:
   // - read
   // - readv
@@ -327,6 +434,7 @@ class PolicyBuilder final {
   PolicyBuilder& AllowRead();
 
   // Appends code to the policy to allow writing to file descriptors.
+  //
   // Allows these syscalls:
   // - write
   // - writev
@@ -335,44 +443,62 @@ class PolicyBuilder final {
   PolicyBuilder& AllowWrite();
 
   // Appends code to allow reading directories.
+  //
   // Allows these syscalls:
   // - getdents
   // - getdents64
   PolicyBuilder& AllowReaddir();
 
   // Appends code to allow reading symbolic links.
+  //
   // Allows these syscalls:
   // - readlink
   // - readlinkat
   PolicyBuilder& AllowReadlink();
 
   // Appends code to allow creating links.
+  //
   // Allows these syscalls:
   // - link
   // - linkat
   PolicyBuilder& AllowLink();
 
   // Appends code to allow creating symbolic links.
+  //
   // Allows these syscalls:
   // - symlink
   // - symlinkat
   PolicyBuilder& AllowSymlink();
 
   // Appends code to allow creating directories.
+  //
   // Allows these syscalls:
   // - mkdir
   // - mkdirat
   PolicyBuilder& AllowMkdir();
 
   // Appends code to allow changing file timestamps.
+  //
   // Allows these syscalls:
   // - futimens
+  // - futimesat
   // - utime
   // - utimensat
   // - utimes
   PolicyBuilder& AllowUtime();
 
+  // Appends code to allow safe calls to bpf.
+  //
+  // Allows this syscall:
+  // - bpf
+  //
+  // The above is only allowed when the cmd is one of:
+  // BPF_MAP_LOOKUP_ELEM, BPF_OBJ_GET, BPF_MAP_GET_NEXT_KEY,
+  // BPF_MAP_GET_FD_BY_ID, BPF_OBJ_GET_INFO_BY_FD
+  PolicyBuilder& AllowSafeBpf();
+
   // Appends code to allow safe calls to fcntl.
+  //
   // Allows these syscalls:
   // - fcntl
   // - fcntl64 (on architectures where it exists)
@@ -383,29 +509,43 @@ class PolicyBuilder final {
   PolicyBuilder& AllowSafeFcntl();
 
   // Appends code to allow creating new processes.
+  //
   // Allows these syscalls:
   // - fork
   // - vfork
   // - clone
   //
-  // Note: while this function allows the calls, the default policy is run first
+  // NOTE: While this function allows the calls, the default policy is run first
   // and it has checks for dangerous flags which can create a violation. See
   // sandbox2/policy.cc for more details.
   PolicyBuilder& AllowFork();
 
   // Appends code to allow waiting for processes.
+  //
   // Allows these syscalls:
   // - waitpid (on architectures where it exists)
   // - wait4
   PolicyBuilder& AllowWait();
 
   // Appends code to allow setting alarms / interval timers.
+  //
   // Allows these syscalls:
   // - alarm (on architectures where it exists)
   // - setitimer
   PolicyBuilder& AllowAlarm();
 
+  // Appends code to allow setting posix timers.
+  //
+  // Allows these syscalls:
+  // - timer_create
+  // - timer_delete
+  // - timer_settime
+  // - timer_gettime
+  // - timer_getoverrun
+  PolicyBuilder& AllowPosixTimers();
+
   // Appends code to allow setting up signal handlers, returning from them, etc.
+  //
   // Allows these syscalls:
   // - rt_sigaction
   // - rt_sigreturn
@@ -417,11 +557,13 @@ class PolicyBuilder final {
   PolicyBuilder& AllowHandleSignals();
 
   // Appends code to allow doing the TCGETS ioctl.
+  //
   // Allows these syscalls:
   // - ioctl (when the first argument is TCGETS)
   PolicyBuilder& AllowTCGETS();
 
   // Appends code to allow to getting the current time.
+  //
   // Allows these syscalls:
   // - time
   // - gettimeofday
@@ -429,12 +571,15 @@ class PolicyBuilder final {
   PolicyBuilder& AllowTime();
 
   // Appends code to allow sleeping in the current thread.
+  //
   // Allow these syscalls:
   // - clock_nanosleep
   // - nanosleep
   PolicyBuilder& AllowSleep();
 
   // Appends code to allow getting the uid, euid, gid, etc.
+  //
+  // Allows these syscalls:
   // - getuid + geteuid + getresuid
   // - getgid + getegid + getresgid
   // - getuid32 + geteuid32 + getresuid32 (on architectures where they exist)
@@ -443,6 +588,7 @@ class PolicyBuilder final {
   PolicyBuilder& AllowGetIDs();
 
   // Appends code to allow getting the pid, ppid and tid.
+  //
   // Allows these syscalls:
   // - getpid
   // - getppid
@@ -450,36 +596,42 @@ class PolicyBuilder final {
   PolicyBuilder& AllowGetPIDs();
 
   // Appends code to allow getting process groups.
+  //
   // Allows these syscalls:
   // - getpgid
   // - getpgrp
   PolicyBuilder& AllowGetPGIDs();
 
   // Appends code to allow getting the rlimits.
+  //
   // Allows these syscalls:
   // - getrlimit
   // - ugetrlimit (on architectures where it exist)
   PolicyBuilder& AllowGetRlimit();
 
   // Appends code to allow setting the rlimits.
+  //
   // Allows these syscalls:
   // - setrlimit
   // - usetrlimit (on architectures where it exist)
   PolicyBuilder& AllowSetRlimit();
 
   // Appends code to allow reading random bytes.
+  //
   // Allows these syscalls:
   // - getrandom (with no flags or GRND_NONBLOCK)
   //
   PolicyBuilder& AllowGetRandom();
 
-  // Appends code to allow configuring wipe-on-fork memory
+  // Appends code to allow configuring wipe-on-fork memory.
+  //
   // Allows these syscalls:
   // - madvise (with advice equal to -1 or MADV_WIPEONFORK).
   PolicyBuilder& AllowWipeOnFork();
 
   // Enables syscalls required to use the logging support enabled via
-  // Client::SendLogsToSupervisor()
+  // `Client::SendLogsToSupervisor()`
+  //
   // Allows the following:
   // - Writes
   // - kill(0, SIGABRT) (for LOG(FATAL))
@@ -489,13 +641,15 @@ class PolicyBuilder final {
   PolicyBuilder& AllowLogForwarding();
 
   // Appends code to allow deleting files and directories.
+  //
   // Allows these syscalls:
   // - rmdir (if available)
   // - unlink (if available)
   // - unlinkat
   PolicyBuilder& AllowUnlink();
 
-  // Appends code to allow renaming files
+  // Appends code to allow renaming files.
+  //
   // Allows these syscalls:
   // - rename (if available)
   // - renameat
@@ -503,31 +657,32 @@ class PolicyBuilder final {
   PolicyBuilder& AllowRename();
 
   // Appends code to allow creating event notification file descriptors.
+  //
   // Allows these syscalls:
   // - eventfd (if available)
   // - eventfd2
   PolicyBuilder& AllowEventFd();
 
   // Appends code to allow polling files.
+  //
   // Allows these syscalls:
   // - poll (if available)
   // - ppoll
   PolicyBuilder& AllowPoll();
 
-  // Appends code to allow setting the name of a thread
+  // Appends code to allow setting the name of a thread.
+  //
   // Allows the following
   // - prctl(PR_SET_NAME, ...)
   PolicyBuilder& AllowPrctlSetName();
 
   // Appends code to allow setting a name for an anonymous memory region.
+  //
   // Allows the following
   // - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ...)
   PolicyBuilder& AllowPrctlSetVma();
 
-  // Enables the syscalls necessary to start a statically linked binary
-  //
-  // NOTE: This will call BlockSyscallWithErrno(__NR_readlink, ENOENT). If you
-  // do not want readlink blocked, put a different call before this call.
+  // Enables the syscalls necessary to start a statically linked binary.
   //
   // The current list of allowed syscalls are below. However you should *not*
   // depend on the specifics, as these will change whenever the startup code
@@ -543,23 +698,28 @@ class PolicyBuilder final {
   // - rt_sigprocmask(SIG_UNBLOCK, ...)
   // - arch_prctl(ARCH_SET_FS)
   //
-  // Additionally it will block calls to readlink.
+  // NOTE: This will call `BlockSyscallWithErrno(__NR_readlink, ENOENT)`. If you
+  // do not want readlink blocked, put a different call before this call.
   PolicyBuilder& AllowStaticStartup();
 
-  // In addition to syscalls allowed by AllowStaticStartup, also allow reading,
-  // seeking, mmapping and closing files. It does not allow opening them, as
-  // the mechanism for doing so depends on whether GetFs-checks are used or not.
-  PolicyBuilder& AllowDynamicStartup();
+  // Enables the syscalls necessary to start a dynamically linked binary.
+  //
+  // In addition to syscalls allowed by `AllowStaticStartup`, also allow
+  // reading, seeking, mmap()-ing and closing files.
+  std::enable_if_t<builder_internal::is_type_complete_v<MapExec>,
+                   PolicyBuilder&>
+  AllowDynamicStartup();
 
   // Appends a policy, which will be run on the specified syscall.
-  // This policy must be written without labels. If you need labels, use
+  //
+  // NOTE: This policy must be written without labels. If you need labels, use
   // the overloaded function passing a BpfFunc object instead of the
   // sock_filter.
   PolicyBuilder& AddPolicyOnSyscall(uint32_t num,
                                     absl::Span<const sock_filter> policy);
 
   // Appends a policy, which will be run on the specified syscall.
-  // This policy may use labels.
+  //
   // Example of how to use it:
   //  builder.AddPolicyOnSyscall(
   //      __NR_socket, [](bpf_labels& labels) -> std::vector<sock_filter> {
@@ -579,141 +739,178 @@ class PolicyBuilder final {
   //            JEQ(NETLINK_ROUTE, ALLOW),
   //        };
   //      });
+  //
+  // NOTE: This policy may use labels.
   PolicyBuilder& AddPolicyOnSyscall(uint32_t num, BpfFunc f);
 
   // Appends a policy, which will be run on the specified syscalls.
-  // This policy must be written without labels.
+  //
+  // NOTE: This policy must be written without labels.
   PolicyBuilder& AddPolicyOnSyscalls(absl::Span<const uint32_t> nums,
                                      absl::Span<const sock_filter> policy);
 
   // Appends a policy, which will be run on the specified syscalls.
-  // This policy may use labels.
+  //
+  // NOTE: This policy may use labels.
   PolicyBuilder& AddPolicyOnSyscalls(absl::Span<const uint32_t> nums,
                                      BpfFunc f);
 
-  // Equivalent to AddPolicyOnSyscalls(mmap_syscalls, policy), where
+  // Equivalent to `AddPolicyOnSyscalls(mmap_syscalls, policy)`, where
   // mmap_syscalls is a subset of {__NR_mmap, __NR_mmap2}, which exists on the
   // target architecture.
+  //
+  // NOTE: This policy must be written without labels.
   PolicyBuilder& AddPolicyOnMmap(absl::Span<const sock_filter> policy);
 
-  // Equivalent to AddPolicyOnSyscalls(mmap_syscalls, f), where mmap_syscalls
+  // Equivalent to `AddPolicyOnSyscalls(mmap_syscalls, f)`, where mmap_syscalls
   // is a subset of {__NR_mmap, __NR_mmap2}, which exists on the target
   // architecture.
+  //
+  // NOTE: This policy may use labels.
   PolicyBuilder& AddPolicyOnMmap(BpfFunc f);
 
-  // Builds the policy returning a unique_ptr to it. This should only be
-  // called once.
+  // Builds the policy returning a unique_ptr to it or status if an error
+  // happened.
+  //
+  // NOTE: This should only be called once.
   absl::StatusOr<std::unique_ptr<Policy>> TryBuild();
 
-  // Builds the policy returning a unique_ptr to it. This should only be
-  // called once. This function will abort if an error happened in any of the
-  // PolicyBuilder methods.
+  // Builds the policy returning a unique_ptr to it.
+  //
+  // NOTE: This function will abort if an error happened in any of the
+  // PolicyBuilder methods. This should only be called once.
   std::unique_ptr<Policy> BuildOrDie() { return TryBuild().value(); }
 
-  // Adds a bind-mount for a file from outside the namespace to inside. This
-  // will also create parent directories inside the namespace if needed.
+  // Adds a bind-mount for a file from outside the namespace to inside.
+  //
+  // This will also create parent directories inside the namespace if needed.
   //
-  // Calling these function will enable use of namespaces.
+  // NOTE: Requires namespace support.
   PolicyBuilder& AddFile(absl::string_view path, bool is_ro = true);
   PolicyBuilder& AddFileAt(absl::string_view outside, absl::string_view inside,
                            bool is_ro = true);
 
-  // Best-effort function that adds the libraries and linker required by a
-  // binary.
+  // Adds the libraries and linker required by a binary.
   //
-  // This does not add the binary itself, only the libraries it depends on.
+  // This does not add the binary itself, only the libraries it depends on. It
+  // should work correctly for most binaries, but you might need to tweak it in
+  // some cases. Run `ldd` yourself and use `AddFile` or `AddDirectory`.
   //
-  // This function should work correctly for most binaries, but you might need
-  // to tweak it in some cases.
+  // This function is safe even for untrusted/potentially malicious binaries. It
+  // adds libraries only from standard library dirs and ld_library_path.
   //
-  // This function is safe even for untrusted/potentially malicious binaries.
-  // It adds libraries only from standard library dirs and ld_library_path.
-  //
-  // run `ldd` yourself and use AddFile or AddDirectory.
+  // NOTE: Requires namespace support. This method is intended as a best effort
   PolicyBuilder& AddLibrariesForBinary(absl::string_view path,
                                        absl::string_view ld_library_path = {});
 
-  // Similar to AddLibrariesForBinary, but binary is specified with an open
-  // fd.
+  // Similar to `AddLibrariesForBinary`, but the binary is specified with an
+  // open fd.
+  //
+  // NOTE: Requires namespace support.
   PolicyBuilder& AddLibrariesForBinary(int fd,
                                        absl::string_view ld_library_path = {});
 
-  // Adds a bind-mount for a directory from outside the namespace to
-  // inside.  This will also create parent directories inside the namespace if
-  // needed.
+  // Adds a bind-mount for a directory from outside the namespace to inside.
+  //
+  // This will also create parent directories inside the namespace if needed.
+  //
+  // If the directory contains symlinks, they might still be inaccessible
+  // inside the sandbox (resulting in ENOENT). For example, the symlinks might
+  // point to a location outside the sandbox. Symlinks can be resolved using
+  // `sapi::file_util::fileops::ReadLink()`.
   //
-  // Calling these function will enable use of namespaces.
+  // NOTE: Requires namespace support.
   PolicyBuilder& AddDirectory(absl::string_view path, bool is_ro = true);
   PolicyBuilder& AddDirectoryAt(absl::string_view outside,
                                 absl::string_view inside, bool is_ro = true);
 
-  // Adds a tmpfs inside the namespace. This will also create parent
-  // directories inside the namespace if needed.
+  // Adds a tmpfs inside the namespace.
   //
-  // Calling this function will enable use of namespaces.
+  // This will also create parent directories inside the namespace if needed.
+  //
+  // NOTE: Requires namespace support.
   PolicyBuilder& AddTmpfs(absl::string_view inside, size_t size);
 
   // Allows unrestricted access to the network by *not* creating a network
-  // namespace. Note that this only disables the network namespace. To
-  // actually allow networking, you would also need to allow networking
-  // syscalls. Calling this function will enable use of namespaces.
+  // namespace. This only disables the network namespace. To actually allow
+  // networking, you would also need to allow networking syscalls. Calling this
+  // function will enable use of namespaces.
+  ABSL_DEPRECATED("Use Allow(sandbox2::UnrestrictedNetworking()) instead.")
   PolicyBuilder& AllowUnrestrictedNetworking();
 
+  // Enables a shared network namespace for all sandboxees that are started by
+  // the same forkserver.
+  //
+  // This results in sandboxed processes to run in the same shared network
+  // namespace instead of creating a separate network namespace for each
+  // sandboxed process started by the ForkServer process.
+  //
+  // NOTE: Requires namespace support.
+  //
+  // IMPORTANT: This is incompatible with AllowUnrestrictedNetworking.
+  PolicyBuilder& UseForkServerSharedNetNs();
+
   // Enables the use of namespaces.
   //
   // Namespaces are enabled by default.
   // This is a no-op.
   ABSL_DEPRECATED("Namespaces are enabled by default; no need to call this")
   PolicyBuilder& EnableNamespaces() {
-    CHECK(use_namespaces_) << "Namespaces cannot be both disabled and enabled";
+    if (!use_namespaces_) {
+      SetError(absl::FailedPreconditionError(
+          "Namespaces cannot be both disabled and enabled"));
+      return *this;
+    }
     requires_namespaces_ = true;
     return *this;
   }
 
-  // Disables the use of namespaces.
+  // Set hostname in the network namespace.
   //
-  // Call in order to use Sandbox2 without namespaces.
-  // This is not recommended.
-  PolicyBuilder& DisableNamespaces() {
-    CHECK(!requires_namespaces_)
-        << "Namespaces cannot be both disabled and enabled. You're probably "
-           "using features that implicitly enable namespaces (SetHostname, "
-           "AddFile, AddDirectory, AddDataDependency, AddLibrariesForBinary "
-           "or similar)";
-    use_namespaces_ = false;
-    return *this;
-  }
-
-  // Set hostname in the network namespace instead of default "sandbox2".
+  // The default hostname is "sandbox2".
+  //
+  // NOTE: Requires namespace support.
   //
-  // Calling this function will enable use of namespaces.
-  // It is an error to also call AllowUnrestrictedNetworking.
+  // IMPORTANT: This is incompatible with AllowUnrestrictedNetworking.
   PolicyBuilder& SetHostname(absl::string_view hostname);
 
   // Enables/disables stack trace collection on violations.
+  //
+  // NOTE: This is enabled by default.
   PolicyBuilder& CollectStacktracesOnViolation(bool enable);
 
   // Enables/disables stack trace collection on signals (e.g. crashes / killed
   // from a signal).
+  //
+  // NOTE: This is enabled by default.
   PolicyBuilder& CollectStacktracesOnSignal(bool enable);
 
   // Enables/disables stack trace collection on hitting a timeout.
+  //
+  // NOTE: This is enabled by default.
   PolicyBuilder& CollectStacktracesOnTimeout(bool enable);
 
   // Enables/disables stack trace collection on getting killed by the sandbox
-  // monitor / the user.
+  // monitor or the user.
+  //
+  // NOTE: This is disabled by default.
   PolicyBuilder& CollectStacktracesOnKill(bool enable);
 
   // Enables/disables stack trace collection on normal process exit.
+  //
+  // NOTE: This is disabled by default.
   PolicyBuilder& CollectStacktracesOnExit(bool enable);
 
   // Changes the default action to ALLOW.
-  // All syscalls not handled explicitly by the policy will thus be allowed.
-  // Do not use in environment with untrusted code and/or data, ask
-  // sandbox-team@ first if unsure.
+  //
+  // All syscalls not handled explicitly by the policy will thus be
+  // allowed.
+  //
+  // IMPORTANT: Do not use in environments with untrusted code and/or data.
   PolicyBuilder& DefaultAction(AllowAllSyscalls);
 
-  // Changes the default action to SANDBOX2_TRACE.
+  // Changes the default action to `SANDBOX2_TRACE`.
+  //
   // All syscalls not handled explicitly by the policy will be passed off to
   // the `sandbox2::Notify` implementation given to the `sandbox2::Sandbox2`
   // instance.
@@ -722,18 +919,21 @@ class PolicyBuilder final {
   ABSL_DEPRECATED("Use DefaultAction(sandbox2::AllowAllSyscalls()) instead")
   PolicyBuilder& DangerDefaultAllowAll();
 
-  // Allows syscalls that are necessary for the NetworkProxyClient
+  // Allows syscalls that are necessary for the NetworkProxyClient.
   PolicyBuilder& AddNetworkProxyPolicy();
 
   // Allows syscalls that are necessary for the NetworkProxyClient and
-  // the NetworkProxyHandler
+  // the NetworkProxyHandler.
   PolicyBuilder& AddNetworkProxyHandlerPolicy();
 
   // Makes root of the filesystem writeable
   // Not recommended
+  //
+  // NOTE: Requires namespace support.
   PolicyBuilder& SetRootWritable();
 
   // Changes mounts propagation from MS_PRIVATE to MS_SLAVE.
+  //
   PolicyBuilder& DangerAllowMountPropagation() {
     allow_mount_propagation_ = true;
     return *this;
@@ -743,14 +943,38 @@ class PolicyBuilder final {
   PolicyBuilder& AllowIPv4(const std::string& ip_and_mask, uint32_t port = 0);
   PolicyBuilder& AllowIPv6(const std::string& ip_and_mask, uint32_t port = 0);
 
+  // Returns the current status of the PolicyBuilder.
+  absl::Status GetStatus() { return last_status_; }
+
+  const Mounts& mounts() const { return mounts_; }
+
+  // Returns the absolute path for the given `relative_path`.
+  //
+  // If `relative_path` is absolute, it will be returned as is and `base` will
+  // be ignored.
+  //
+  // If `relative_path` is relative and `base` is not provided, it will be
+  // resolved relative to the current working directory.
+  //
+  // If `relative_path` is relative and an absolute `base` is provided, it will
+  // be resolved relative to `base`.
+  //
+  // If both, `relative_path` and `base` are relative, then first `base` will be
+  // resolved relative to the current working directory, and then
+  // `relative_path` will be resolved relative to `base`.
+  //
+  // In all cases where `relative_path` is relative, non-canonical paths will be
+  // canonicalized and the result must be anchored to the base directory. If the
+  // resulting path is outside the base directory, an error will be returned.
+  //
+  // On ERROR, such as `relative_path` is empty, an empty string is returned.
+  static std::string AnchorPathAbsolute(absl::string_view relative_path,
+                                        absl::string_view base = {});
+
  private:
   friend class PolicyBuilderPeer;  // For testing
   friend class StackTracePeer;
 
-  static absl::StatusOr<std::string> ValidateAbsolutePath(
-      absl::string_view path);
-  static absl::StatusOr<std::string> ValidatePath(absl::string_view path);
-
   // Similar to AddFile(At)/AddDirectory(At) but it won't force use of
   // namespaces - files will only be added to the namespace if it is not
   // disabled by the time of TryBuild().
@@ -764,9 +988,12 @@ class PolicyBuilder final {
                                             absl::string_view inside,
                                             bool is_ro = true);
 
-  // Allows a limited version of madvise
+  // Allows a limited version of madvise.
   PolicyBuilder& AllowLimitedMadvise();
 
+  // Allows MADV_POPULATE_READ and MADV_POPULATE_WRITE.
+  PolicyBuilder& AllowMadvisePopulate();
+
   // Traps instead of denying ptrace.
   PolicyBuilder& TrapPtrace();
 
@@ -781,19 +1008,20 @@ class PolicyBuilder final {
 
   std::vector<sock_filter> ResolveBpfFunc(BpfFunc f);
 
-  void StoreDescription(PolicyBuilderDescription* pb_description);
-
   // This function returns a PolicyBuilder so that we can use it in the status
-  // macros
+  // macros.
   PolicyBuilder& SetError(const absl::Status& status);
 
   Mounts mounts_;
   bool use_namespaces_ = true;
   bool requires_namespaces_ = false;
-  bool allow_unrestricted_networking_ = false;
+  NetNsMode netns_mode_ = NETNS_MODE_UNSPECIFIED;
+  bool allow_map_exec_ = true;  //  Temporary default while we migrate users.
+  bool allow_speculation_ = false;
   bool allow_mount_propagation_ = false;
   std::string hostname_ = std::string(kDefaultHostname);
 
+  // Stack trace collection
   bool collect_stacktrace_on_violation_ = true;
   bool collect_stacktrace_on_signal_ = true;
   bool collect_stacktrace_on_timeout_ = true;
@@ -807,12 +1035,40 @@ class PolicyBuilder final {
   bool user_policy_handles_bpf_ = false;
   bool user_policy_handles_ptrace_ = false;
   absl::flat_hash_set<uint32_t> handled_syscalls_;
+  absl::flat_hash_set<uint32_t> allowed_syscalls_;
+  absl::flat_hash_set<uint32_t> blocked_syscalls_;
+  absl::flat_hash_set<uint32_t> custom_policy_syscalls_;
 
   // Error handling
-  absl::Status last_status_;
+  absl::Status last_status_ = absl::OkStatus();
   bool already_built_ = false;
 
-  // Contains list of allowed hosts.
+  struct {
+    bool static_startup = false;
+    bool dynamic_startup = false;
+    bool system_malloc = false;
+    bool scudo_malloc = false;
+    bool tcmalloc = false;
+    bool llvm_sanitizers = false;
+    bool llvm_coverage = false;
+    bool limited_madvise = false;
+    bool madvise_populate = false;
+    bool mmap_without_exec = false;
+    bool mprotect_without_exec = false;
+    bool safe_bpf = false;
+    bool safe_fcntl = false;
+    bool tcgets = false;
+    bool slow_fences = false;
+    bool fast_fences = false;
+    bool getrlimit = false;
+    bool getrandom = false;
+    bool wipe_on_fork = false;
+    bool log_forwarding = false;
+    bool prctl_set_name = false;
+    bool prctl_set_vma = false;
+  } allowed_complex_;
+
+  // List of allowed hosts
   absl::optional<AllowedHosts> allowed_hosts_;
 };
 
diff --git a/sandboxed_api/sandbox2/policybuilder_test.cc b/sandboxed_api/sandbox2/policybuilder_test.cc
index 944eaa5..bf25dd2 100644
--- a/sandboxed_api/sandbox2/policybuilder_test.cc
+++ b/sandboxed_api/sandbox2/policybuilder_test.cc
@@ -18,18 +18,22 @@
 #include <unistd.h>
 
 #include <cerrno>
+#include <initializer_list>
 #include <memory>
 #include <string>
+#include <tuple>
+#include <utility>
 #include <vector>
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/status/status.h"
-#include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
+#include "sandboxed_api/sandbox2/allowlists/unrestricted_networking.h"
 #include "sandboxed_api/sandbox2/policy.h"
 #include "sandboxed_api/sandbox2/util/bpf_helper.h"
-#include "sandboxed_api/sandbox2/violation.pb.h"
+#include "sandboxed_api/util/fileops.h"
+#include "sandboxed_api/util/path.h"
 #include "sandboxed_api/util/status_matchers.h"
 
 namespace sandbox2 {
@@ -40,17 +44,14 @@ class PolicyBuilderPeer {
 
   int policy_size() const { return builder_->user_policy_.size(); }
 
-  static absl::StatusOr<std::string> ValidateAbsolutePath(
-      absl::string_view path) {
-    return PolicyBuilder::ValidateAbsolutePath(path);
-  }
-
  private:
   PolicyBuilder* builder_;
 };
 
 namespace {
 
+namespace fileops = ::sapi::file_util::fileops;
+
 using ::sapi::IsOk;
 using ::sapi::StatusIs;
 using ::testing::Eq;
@@ -89,8 +90,8 @@ TEST(PolicyBuilderTest, Testpolicy_size) {
   assert_increased();
 
   builder.AllowTCGETS(); assert_increased();
-  builder.AllowTCGETS(); assert_increased();
-  builder.AllowTCGETS(); assert_increased();
+  builder.AllowTCGETS(); assert_same();
+  builder.AllowTCGETS(); assert_same();
 
   builder.AddPolicyOnSyscall(__NR_fchmod, { ALLOW }); assert_increased();
   builder.AddPolicyOnSyscall(__NR_fchmod, { ALLOW }); assert_increased();
@@ -108,31 +109,114 @@ TEST(PolicyBuilderTest, Testpolicy_size) {
   builder.AddFile("/usr/bin/find"); assert_same();
   builder.AddDirectory("/bin"); assert_same();
   builder.AddTmpfs("/tmp", /*size=*/4ULL << 20 /* 4 MiB */); assert_same();
-  builder.AllowUnrestrictedNetworking(); assert_same();
+  builder.UseForkServerSharedNetNs(); assert_same();
+  builder.Allow(UnrestrictedNetworking()); assert_same();
   // clang-format on
 }
 
-TEST(PolicyBuilderTest, TestValidateAbsolutePath) {
-  for (auto const& bad_path : {
-           "..",
-           "a",
-           "a/b",
-           "a/b/c",
-           "/a/b/c/../d",
-           "/a/b/c/./d",
-           "/a/b/c//d",
-           "/a/b/c/d/",
-           "/a/bAAAAAAAAAAAAAAAAAAAAAA/c/d/",
-       }) {
-    EXPECT_THAT(PolicyBuilderPeer::ValidateAbsolutePath(bad_path),
-                StatusIs(absl::StatusCode::kInvalidArgument));
+TEST(PolicyBuilderTest, ApisWithPathValidation) {
+  const std::initializer_list<std::pair<absl::string_view, absl::StatusCode>>
+      kTestCases = {
+          {"/a", absl::StatusCode::kOk},
+          {"/a/b/c/d", absl::StatusCode::kOk},
+          {"/a/b/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", absl::StatusCode::kOk},
+          {"", absl::StatusCode::kInvalidArgument},
+          // Fails because we reject paths starting with '..'
+          {"..", absl::StatusCode::kInvalidArgument},
+          {"..a", absl::StatusCode::kInvalidArgument},
+          {"../a", absl::StatusCode::kInvalidArgument},
+          // Fails because is not absolute
+          {"a", absl::StatusCode::kInvalidArgument},
+          {"a/b", absl::StatusCode::kInvalidArgument},
+          {"a/b/c", absl::StatusCode::kInvalidArgument},
+          // Fails because '..' in path
+          {"/a/b/c/../d", absl::StatusCode::kInvalidArgument},
+          // Fails because '.' in path
+          {"/a/b/c/./d", absl::StatusCode::kInvalidArgument},
+          // Fails because '//' in path
+          {"/a/b/c//d", absl::StatusCode::kInvalidArgument},
+          // Fails because path ends with '/'
+          {"/a/b/c/d/", absl::StatusCode::kInvalidArgument},
+      };
+  for (auto const& [path, status] : kTestCases) {
+    EXPECT_THAT(PolicyBuilder().AddFile(path).TryBuild(), StatusIs(status));
+    EXPECT_THAT(PolicyBuilder().AddFileAt(path, "/input").TryBuild(),
+                StatusIs(status));
+    EXPECT_THAT(PolicyBuilder().AddDirectory(path).TryBuild(),
+                StatusIs(status));
+    EXPECT_THAT(PolicyBuilder().AddDirectoryAt(path, "/input").TryBuild(),
+                StatusIs(status));
   }
 
-  for (auto const& good_path :
-       {"/", "/a/b/c/d", "/a/b/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}) {
-    SAPI_ASSERT_OK_AND_ASSIGN(
-        std::string path, PolicyBuilderPeer::ValidateAbsolutePath(good_path));
-    EXPECT_THAT(path, StrEq(good_path));
+  // Fails because it attempts to mount to '/' inside
+  EXPECT_THAT(PolicyBuilder().AddFile("/").TryBuild(),
+              StatusIs(absl::StatusCode::kInternal));
+  EXPECT_THAT(PolicyBuilder().AddDirectory("/").TryBuild(),
+              StatusIs(absl::StatusCode::kInternal));
+
+  // Succeeds because it attempts to mount to '/' inside
+  EXPECT_THAT(PolicyBuilder().AddFileAt("/a", "/input").TryBuild(), IsOk());
+  EXPECT_THAT(PolicyBuilder().AddDirectoryAt("/a", "/input").TryBuild(),
+              IsOk());
+}
+
+TEST(PolicyBuilderTest, TestAnchorPathAbsolute) {
+  const std::initializer_list<
+      std::tuple<absl::string_view, absl::string_view, std::string>>
+      kTestCases = {
+          // relative_path is empty:
+          {"", "/base", ""},  // Error: relative path is empty
+          {"", "", ""},       // Error: relative path is empty
+
+          // relative_path is absolute:
+          {"/a/b/c/d", "/base", "/a/b/c/d"},
+          {"/a/../../../../../etc/passwd", "/base",
+           "/a/../../../../../etc/passwd"},
+          {"/a/b/c/d", "base", "/a/b/c/d"},
+          {"/a/b/c/d", "", "/a/b/c/d"},
+
+          // base is absolute:
+          {"a/b/c/d", "/base", "/base/a/b/c/d"},
+          {"a/b/c/d/", "/base", "/base/a/b/c/d"},
+          {"a/b/c//d", "/base", "/base/a/b/c/d"},
+          {"a/b/../d/", "/base", "/base/a/d"},
+          {"a/./b/c/", "/base", "/base/a/b/c"},
+          {"./a/b/c/", "/base", "/base/a/b/c"},
+          {"..foobar", "/base", "/base/..foobar"},
+          {"a/b/c/d", "/base/../foo/bar",
+           "/foo/bar/a/b/c/d"},         // Not an error because base is trusted.
+          {"a/../../d/", "/base", ""},  // Error: can't guarantee anchor
+          {"../a/b/c/", "/base", ""},   // Error: can't guarantee anchor
+          {"..", "/base", ""},          // Error: can't guarantee anchor
+
+          // base path is empty:
+          {"a/b/c", "", fileops::GetCWD() + "/a/b/c"},
+          {"a/../../../../c", "", ""},  // Error: can't guarantee anchor
+
+          // base is relative:
+          {"a/b/c/d", "base", fileops::GetCWD() + "/base/a/b/c/d"},
+          {"a/b/c/d/", "base", fileops::GetCWD() + "/base/a/b/c/d"},
+          {"a/b/c//d", "base", fileops::GetCWD() + "/base/a/b/c/d"},
+          {"a/b/../d/", "base", fileops::GetCWD() + "/base/a/d"},
+          {"a/./b/c/", "base", fileops::GetCWD() + "/base/a/b/c"},
+          {"./a/b/c/", "base", fileops::GetCWD() + "/base/a/b/c"},
+          {"..foobar", "base", fileops::GetCWD() + "/base/..foobar"},
+          {"a/../../d/", "base", ""},  // Error: can't guarantee anchor
+          {"../a/b/c/", "base", ""},   // Error: can't guarantee anchor
+          {"..", "base", ""},          // Error: can't guarantee anchor
+          {"a/b/c", ".base/foo/", fileops::GetCWD() + "/.base/foo/a/b/c"},
+          {"a/b/c", "./base/foo", fileops::GetCWD() + "/base/foo/a/b/c"},
+          {"a/b/c", "base/foo/../bar", fileops::GetCWD() + "/base/bar/a/b/c"},
+          {"a/b/c", "base/foo//bar/",
+           fileops::GetCWD() + "/base/foo/bar/a/b/c"},
+          {"a/b/c", "..base/foo", fileops::GetCWD() + "/..base/foo/a/b/c"},
+          {"a/b/c", "../base/foo",
+           sapi::file::CleanPath(fileops::GetCWD() + "/../base/foo/a/b/c")},
+          {"a/b/c", "..",
+           sapi::file::CleanPath(fileops::GetCWD() + "/../a/b/c")},
+      };
+  for (auto const& [path, base, result] : kTestCases) {
+    EXPECT_THAT(PolicyBuilder::AnchorPathAbsolute(path, base), StrEq(result));
   }
 }
 
@@ -156,7 +240,20 @@ TEST(PolicyBuilderTest, TestIsCopyable) {
   EXPECT_THAT(copy.TryBuild(), IsOk());
 }
 
-TEST(PolicyBuilderTest, CanBypassPtrace) {
+TEST(PolicyBuilderTest, CannotBypassBpf) {
+  PolicyBuilder builder;
+  builder.AddPolicyOnSyscall(__NR_bpf, {ALLOW})
+      .BlockSyscallWithErrno(__NR_bpf, ENOENT);
+  EXPECT_THAT(builder.TryBuild(), Not(IsOk()));
+}
+
+TEST(PolicyBuilderTest, CannotBypassAfterAllowSafeBpf) {
+  PolicyBuilder builder;
+  builder.AllowSafeBpf().AddPolicyOnSyscall(__NR_bpf, {ALLOW});
+  EXPECT_THAT(builder.TryBuild(), Not(IsOk()));
+}
+
+TEST(PolicyBuilderTest, CannotBypassPtrace) {
   PolicyBuilder builder;
   builder.AddPolicyOnSyscall(__NR_ptrace, {ALLOW})
       .BlockSyscallWithErrno(__NR_ptrace, ENOENT);
@@ -175,5 +272,23 @@ TEST(PolicyBuilderTest, AddPolicyOnSyscallJumpOutOfBounds) {
                              {BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 1, 2, 0)});
   EXPECT_THAT(builder.TryBuild(), StatusIs(absl::StatusCode::kInvalidArgument));
 }
+
+TEST(PolicyBuilderTest, TestAllowLlvmCoverage) {
+  ASSERT_THAT(setenv("COVERAGE", "1", 0), Eq(0));
+  ASSERT_THAT(setenv("COVERAGE_DIR", "/tmp", 0), Eq(0));
+  PolicyBuilder builder;
+  builder.AllowLlvmCoverage();
+  EXPECT_THAT(builder.TryBuild(), IsOk());
+  ASSERT_THAT(unsetenv("COVERAGE"), Eq(0));
+  ASSERT_THAT(unsetenv("COVERAGE_DIR"), Eq(0));
+}
+
+TEST(PolicyBuilderTest, TestAllowLlvmCoverageWithoutCoverageDir) {
+  ASSERT_THAT(setenv("COVERAGE", "1", 0), Eq(0));
+  PolicyBuilder builder;
+  builder.AllowLlvmCoverage();
+  EXPECT_THAT(builder.TryBuild(), IsOk());
+  ASSERT_THAT(unsetenv("COVERAGE"), Eq(0));
+}
 }  // namespace
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/regs.cc b/sandboxed_api/sandbox2/regs.cc
index 9224730..7161fab 100644
--- a/sandboxed_api/sandbox2/regs.cc
+++ b/sandboxed_api/sandbox2/regs.cc
@@ -210,74 +210,4 @@ int64_t Regs::GetReturnValue(sapi::cpu::Architecture syscall_arch) const {
   return -1;
 }
 
-void Regs::StoreRegisterValuesInProtobuf(RegisterValues* values) const {
-#if defined(SAPI_X86_64)
-  RegisterX8664* regs = values->mutable_register_x86_64();
-  regs->set_r15(user_regs_.r15);
-  regs->set_r14(user_regs_.r14);
-  regs->set_r13(user_regs_.r13);
-  regs->set_r12(user_regs_.r12);
-  regs->set_rbp(user_regs_.rbp);
-  regs->set_rbx(user_regs_.rbx);
-  regs->set_r11(user_regs_.r11);
-  regs->set_r10(user_regs_.r10);
-  regs->set_r9(user_regs_.r9);
-  regs->set_r8(user_regs_.r8);
-  regs->set_rax(user_regs_.rax);
-  regs->set_rcx(user_regs_.rcx);
-  regs->set_rdx(user_regs_.rdx);
-  regs->set_rsi(user_regs_.rsi);
-  regs->set_rdi(user_regs_.rdi);
-  regs->set_orig_rax(user_regs_.orig_rax);
-  regs->set_rip(user_regs_.rip);
-  regs->set_cs(user_regs_.cs);
-  regs->set_eflags(user_regs_.eflags);
-  regs->set_rsp(user_regs_.rsp);
-  regs->set_ss(user_regs_.ss);
-  regs->set_fs_base(user_regs_.fs_base);
-  regs->set_gs_base(user_regs_.gs_base);
-  regs->set_ds(user_regs_.ds);
-  regs->set_es(user_regs_.es);
-  regs->set_fs(user_regs_.fs);
-  regs->set_gs(user_regs_.gs);
-#elif defined(SAPI_PPC64_LE)
-  RegisterPowerpc64* regs = values->mutable_register_powerpc64();
-  for (int i = 0; i < ABSL_ARRAYSIZE(user_regs_.gpr); ++i) {
-    regs->add_gpr(user_regs_.gpr[i]);
-  }
-  regs->set_nip(user_regs_.nip);
-  regs->set_msr(user_regs_.msr);
-  regs->set_orig_gpr3(user_regs_.orig_gpr3);
-  regs->set_ctr(user_regs_.ctr);
-  regs->set_link(user_regs_.link);
-  regs->set_xer(user_regs_.xer);
-  regs->set_ccr(user_regs_.ccr);
-  regs->set_softe(user_regs_.softe);
-  regs->set_trap(user_regs_.trap);
-  regs->set_dar(user_regs_.dar);
-  regs->set_dsisr(user_regs_.dsisr);
-  regs->set_result(user_regs_.result);
-  regs->set_zero0(user_regs_.zero0);
-  regs->set_zero1(user_regs_.zero1);
-  regs->set_zero2(user_regs_.zero2);
-  regs->set_zero3(user_regs_.zero3);
-#elif defined(SAPI_ARM64)
-  RegisterAarch64* regs = values->mutable_register_aarch64();
-  for (int i = 0; i < ABSL_ARRAYSIZE(user_regs_.regs); ++i) {
-    regs->add_regs(user_regs_.regs[i]);
-  }
-  regs->set_sp(user_regs_.sp);
-  regs->set_pc(user_regs_.pc);
-  regs->set_pstate(user_regs_.pstate);
-#elif defined(SAPI_ARM)
-  RegisterArm* regs = values->mutable_register_arm();
-  for (int i = 0; i < ABSL_ARRAYSIZE(user_regs_.regs); ++i) {
-    regs->add_regs(user_regs_.regs[i]);
-  }
-  regs->set_pc(user_regs_.pc);
-  regs->set_cpsr(user_regs_.cpsr);
-  regs->set_orig_x0(user_regs_.orig_x0);
-#endif
-}
-
 }  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/regs.h b/sandboxed_api/sandbox2/regs.h
index 5d1e98d..b20cab9 100644
--- a/sandboxed_api/sandbox2/regs.h
+++ b/sandboxed_api/sandbox2/regs.h
@@ -25,7 +25,6 @@
 #include "absl/status/status.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/sandbox2/syscall.h"
-#include "sandboxed_api/sandbox2/violation.pb.h"
 
 namespace sandbox2 {
 
@@ -52,9 +51,6 @@ class Regs {
 
   pid_t pid() const { return pid_; }
 
-  // Stores register values in a protobuf structure.
-  void StoreRegisterValuesInProtobuf(RegisterValues* values) const;
-
  private:
   friend class StackTracePeer;
 
diff --git a/sandboxed_api/sandbox2/sandbox2.cc b/sandboxed_api/sandbox2/sandbox2.cc
index 95071ab..13fa1bc 100644
--- a/sandboxed_api/sandbox2/sandbox2.cc
+++ b/sandboxed_api/sandbox2/sandbox2.cc
@@ -107,21 +107,15 @@ void Sandbox2::Launch() {
     internal::SandboxPeer::spawn_fn_ = Sandbox2Peer::Spawn;
   });
 
-  // This is a technical limitation in our stack trace collection
-  // functionality.
-  LOG_IF(WARNING, !policy_->GetNamespace())
-      << "Using policy without namespaces, disabling stack traces on crash";
-
   monitor_ = CreateMonitor();
   monitor_->Launch();
 }
 
 absl::Status Sandbox2::EnableUnotifyMonitor() {
   if (notify_) {
-    LOG(WARNING) << "Running UnotifyMonitor with sandbox2::Notify is not fully "
-                    "supported. Runtime syscall decisions via "
-                    "EventSyscallTrap/EventSyscallTrace, notifications about "
-                    "signals via EventSignal will not work";
+    LOG(WARNING) << "Using unotify monitor with experimental support for "
+                    "notifications. Notifications about signals via "
+                    "EventSignal will not work.";
   }
   if (!policy_->GetNamespace()) {
     return absl::FailedPreconditionError(
diff --git a/sandboxed_api/sandbox2/sandbox2.h b/sandboxed_api/sandbox2/sandbox2.h
index 2467990..11e1ed4 100644
--- a/sandboxed_api/sandbox2/sandbox2.h
+++ b/sandboxed_api/sandbox2/sandbox2.h
@@ -85,16 +85,6 @@ class Sandbox2 final {
   // Returns whether sandboxing task has ended.
   bool IsTerminated() const;
 
-  // Sets a wall time limit on a running sandboxee, 0 to disarm.
-  // Limit is a timeout duration (e.g. 10 secs) not a deadline (e.g. 12:00).
-  // This can be useful in a persistent sandbox scenario, to impose a deadline
-  // for responses after each request and reset the deadline in between.
-  // Sandboxed API can be used to implement persistent sandboxes.
-  ABSL_DEPRECATED("Use set_walltime_limit() instead")
-  void SetWallTimeLimit(time_t limit) const {
-    this->set_walltime_limit(absl::Seconds(limit));
-  }
-
   // Sets a wall time limit on a running sandboxee, absl::ZeroDuration() to
   // disarm. This can be useful in a persistent sandbox scenario, to impose a
   // deadline for responses after each request and reset the deadline in
diff --git a/sandboxed_api/sandbox2/sandbox2_test.cc b/sandboxed_api/sandbox2/sandbox2_test.cc
index 828803f..7861d33 100644
--- a/sandboxed_api/sandbox2/sandbox2_test.cc
+++ b/sandboxed_api/sandbox2/sandbox2_test.cc
@@ -21,7 +21,6 @@
 #include <csignal>
 #include <memory>
 #include <string>
-#include <thread>  // NOLINT(build/c++11)
 #include <utility>
 #include <vector>
 
@@ -41,6 +40,7 @@
 #include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/testing.h"
 #include "sandboxed_api/util/status_matchers.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sandbox2 {
 namespace {
@@ -50,6 +50,7 @@ using ::sapi::GetTestSourcePath;
 using ::sapi::IsOk;
 using ::testing::Eq;
 using ::testing::IsEmpty;
+using ::testing::IsFalse;
 using ::testing::IsTrue;
 using ::testing::Lt;
 using ::testing::Ne;
@@ -77,8 +78,10 @@ TEST_P(Sandbox2Test, AbortWithoutCoreDumpReturnsSignaled) {
   };
   auto executor = std::make_unique<Executor>(path, args);
 
-  SAPI_ASSERT_OK_AND_ASSIGN(auto policy, CreateDefaultTestPolicy(path)
-                                             .TryBuild());
+  SAPI_ASSERT_OK_AND_ASSIGN(
+      auto policy,
+      CreateDefaultTestPolicy(path)
+          .TryBuild());
   Sandbox2 sandbox(std::move(executor), std::move(policy));
   ASSERT_THAT(SetUpSandbox(&sandbox), IsOk());
   auto result = sandbox.Run();
@@ -121,6 +124,7 @@ TEST(ExecutorTest, ExecutorFdConstructor) {
   Sandbox2 sandbox(std::move(executor), std::move(policy));
   auto result = sandbox.Run();
 
+  EXPECT_THAT(sandbox.IsTerminated(), IsTrue());
   ASSERT_EQ(result.final_status(), Result::OK);
 }
 
@@ -137,13 +141,37 @@ TEST_P(Sandbox2Test, SandboxeeExternalKill) {
   Sandbox2 sandbox(std::move(executor), std::move(policy));
   ASSERT_THAT(SetUpSandbox(&sandbox), IsOk());
   ASSERT_TRUE(sandbox.RunAsync());
-  sleep(1);
+  EXPECT_THAT(sandbox.IsTerminated(), IsFalse());
+  absl::SleepFor(absl::Seconds(1));
   sandbox.Kill();
   auto result = sandbox.AwaitResult();
+  EXPECT_THAT(sandbox.IsTerminated(), IsTrue());
   EXPECT_EQ(result.final_status(), Result::EXTERNAL_KILL);
   EXPECT_THAT(result.stack_trace(), IsEmpty());
 }
 
+TEST_P(Sandbox2Test, SandboxeeKillDontAwait) {
+  const std::string path = GetTestSourcePath("sandbox2/testcases/sleep");
+
+  std::vector<std::string> args = {path};
+  auto executor = std::make_unique<Executor>(path, args);
+
+  SAPI_ASSERT_OK_AND_ASSIGN(auto policy,
+                            CreateDefaultTestPolicy(path).TryBuild());
+  absl::Time kill_time;
+  {
+    Sandbox2 sandbox(std::move(executor), std::move(policy));
+    ASSERT_THAT(SetUpSandbox(&sandbox), IsOk());
+    ASSERT_TRUE(sandbox.RunAsync());
+    EXPECT_THAT(sandbox.IsTerminated(), IsFalse());
+    absl::SleepFor(absl::Seconds(1));
+    sandbox.Kill();
+    kill_time = absl::Now();
+  }
+  absl::Duration elapsed = absl::Now() - kill_time;
+  EXPECT_THAT(elapsed, Lt(absl::Milliseconds(200)));
+}
+
 // Tests that we do not collect stack traces if it was disabled (signaled).
 TEST_P(Sandbox2Test, SandboxeeTimeoutDisabledStacktraces) {
   const std::string path = GetTestSourcePath("sandbox2/testcases/sleep");
@@ -156,10 +184,13 @@ TEST_P(Sandbox2Test, SandboxeeTimeoutDisabledStacktraces) {
                                              .TryBuild());
   Sandbox2 sandbox(std::move(executor), std::move(policy));
   ASSERT_THAT(SetUpSandbox(&sandbox), IsOk());
+  absl::Time start_time = absl::Now();
   ASSERT_TRUE(sandbox.RunAsync());
   sandbox.set_walltime_limit(absl::Seconds(1));
   auto result = sandbox.AwaitResult();
   EXPECT_EQ(result.final_status(), Result::TIMEOUT);
+  auto elapsed = absl::Now() - start_time;
+  EXPECT_THAT(elapsed, Lt(absl::Seconds(2)));
   EXPECT_THAT(result.stack_trace(), IsEmpty());
 }
 
@@ -191,8 +222,8 @@ TEST_P(Sandbox2Test, SandboxeeNotKilledWhenStartingThreadFinishes) {
                             CreateDefaultTestPolicy(path).TryBuild());
   Sandbox2 sandbox(std::move(executor), std::move(policy));
   ASSERT_THAT(SetUpSandbox(&sandbox), IsOk());
-  std::thread sandbox_start_thread([&sandbox]() { sandbox.RunAsync(); });
-  sandbox_start_thread.join();
+  sapi::Thread sandbox_start_thread([&sandbox]() { sandbox.RunAsync(); });
+  sandbox_start_thread.Join();
   Result result = sandbox.AwaitResult();
   EXPECT_EQ(result.final_status(), Result::OK);
 }
diff --git a/sandboxed_api/sandbox2/stack_trace.cc b/sandboxed_api/sandbox2/stack_trace.cc
index 11f9b6f..30837c6 100644
--- a/sandboxed_api/sandbox2/stack_trace.cc
+++ b/sandboxed_api/sandbox2/stack_trace.cc
@@ -37,7 +37,6 @@
 #include "absl/strings/string_view.h"
 #include "absl/strings/strip.h"
 #include "absl/time/time.h"
-#include "sandboxed_api/config.h"
 #include "sandboxed_api/sandbox2/comms.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/limits.h"
@@ -47,18 +46,16 @@
 #include "sandboxed_api/sandbox2/policybuilder.h"
 #include "sandboxed_api/sandbox2/regs.h"
 #include "sandboxed_api/sandbox2/result.h"
-#include "sandboxed_api/sandbox2/unwind/unwind.h"
 #include "sandboxed_api/sandbox2/unwind/unwind.pb.h"
 #include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/path.h"
-#include "sandboxed_api/util/raw_logging.h"
 #include "sandboxed_api/util/status_macros.h"
 
 ABSL_FLAG(bool, sandbox_disable_all_stack_traces, false,
           "Completely disable stack trace collection for sandboxees");
 
-ABSL_FLAG(bool, sandbox_libunwind_crash_handler, true,
-          "Sandbox libunwind when handling violations (preferred)");
+ABSL_RETIRED_FLAG(bool, sandbox_libunwind_crash_handler, true,
+                  "Sandbox libunwind when handling violations (preferred)");
 
 namespace sandbox2 {
 namespace {
@@ -66,12 +63,9 @@ namespace {
 namespace file = ::sapi::file;
 namespace file_util = ::sapi::file_util;
 
-// Similar to GetStackTrace() but without using the sandbox to isolate
-// libunwind.
-absl::StatusOr<std::vector<std::string>> UnsafeGetStackTrace(pid_t pid) {
-  LOG(WARNING) << "Using non-sandboxed libunwind";
-  return RunLibUnwindAndSymbolizer(pid, kDefaultMaxFrames);
-}
+// Use a fake pid so that /proc/{pid}/maps etc. also exist in the new pid
+// namespace
+constexpr int kFakePid = 1;
 
 bool IsSameFile(const std::string& path, const std::string& other) {
   struct stat buf, other_buf;
@@ -92,9 +86,9 @@ bool IsSameFile(const std::string& path, const std::string& other) {
 class StackTracePeer {
  public:
   static absl::StatusOr<std::unique_ptr<Policy>> GetPolicy(
-      pid_t target_pid, const std::string& maps_file,
-      const std::string& app_path, const std::string& exe_path,
-      const Namespace* ns, bool uses_custom_forkserver);
+      const std::string& maps_file, const std::string& app_path,
+      const std::string& exe_path, const Namespace* ns,
+      bool uses_custom_forkserver);
 
   static absl::StatusOr<std::vector<std::string>> LaunchLibunwindSandbox(
       const Regs* regs, const Namespace* ns, bool uses_custom_forkserver,
@@ -102,11 +96,11 @@ class StackTracePeer {
 };
 
 absl::StatusOr<std::unique_ptr<Policy>> StackTracePeer::GetPolicy(
-    pid_t target_pid, const std::string& maps_file, const std::string& app_path,
+    const std::string& maps_file, const std::string& app_path,
     const std::string& exe_path, const Namespace* ns,
     bool uses_custom_forkserver) {
   PolicyBuilder builder;
-  if (uses_custom_forkserver) {
+  if (uses_custom_forkserver || ns == nullptr) {
     // Custom forkserver just forks, the binary is loaded outside of the
     // sandboxee's mount namespace.
     // Add all possible libraries without the need of parsing the binary
@@ -169,14 +163,15 @@ absl::StatusOr<std::unique_ptr<Policy>> StackTracePeer::GetPolicy(
 
       // Add proc maps.
       .AddFileAt(maps_file,
-                 file::JoinPath("/proc", absl::StrCat(target_pid), "maps"))
+                 file::JoinPath("/proc", absl::StrCat(kFakePid), "maps"))
       .AddFileAt(maps_file,
-                 file::JoinPath("/proc", absl::StrCat(target_pid), "task",
-                                absl::StrCat(target_pid), "maps"))
+                 file::JoinPath("/proc", absl::StrCat(kFakePid), "task",
+                                absl::StrCat(kFakePid), "maps"))
 
       // Add the binary itself.
       .AddFileAt(exe_path, app_path)
-      .AllowLlvmCoverage();
+      .AllowLlvmCoverage()
+      .AllowLlvmSanitizers();
 
   return builder.TryBuild();
 }
@@ -261,8 +256,8 @@ absl::StatusOr<std::vector<std::string>> StackTracePeer::LaunchLibunwindSandbox(
   // forkserver).
   SAPI_ASSIGN_OR_RETURN(
       std::unique_ptr<Policy> policy,
-      StackTracePeer::GetPolicy(pid, unwind_temp_maps_path, app_path, exe_path,
-                                ns, uses_custom_forkserver));
+      StackTracePeer::GetPolicy(unwind_temp_maps_path, app_path, exe_path, ns,
+                                uses_custom_forkserver));
 
   VLOG(1) << "Running libunwind sandbox";
   auto sandbox =
@@ -270,7 +265,7 @@ absl::StatusOr<std::vector<std::string>> StackTracePeer::LaunchLibunwindSandbox(
   Comms* comms = sandbox->comms();
 
   UnwindSetup msg;
-  msg.set_pid(pid);
+  msg.set_pid(kFakePid);
   msg.set_regs(reinterpret_cast<const char*>(&regs->user_regs_),
                sizeof(regs->user_regs_));
   msg.set_default_max_frames(kDefaultMaxFrames);
@@ -326,17 +321,6 @@ absl::StatusOr<std::vector<std::string>> GetStackTrace(
         "Could not obtain stacktrace, regs == nullptr");
   }
 
-  if (!absl::GetFlag(FLAGS_sandbox_libunwind_crash_handler)) {
-    return UnsafeGetStackTrace(regs->pid());
-  }
-
-  // Show a warning if sandboxed libunwind is requested but we're running in
-  // a sanitizer build (= we can't use sandboxed libunwind).
-  if (sapi::sanitizers::IsAny()) {
-    LOG(WARNING) << "Sanitizer build, using non-sandboxed libunwind";
-    return UnsafeGetStackTrace(regs->pid());
-  }
-
   return StackTracePeer::LaunchLibunwindSandbox(
       regs, ns, uses_custom_forkserver, recursion_depth);
 }
diff --git a/sandboxed_api/sandbox2/stack_trace_test.cc b/sandboxed_api/sandbox2/stack_trace_test.cc
index 6940953..281d12e 100644
--- a/sandboxed_api/sandbox2/stack_trace_test.cc
+++ b/sandboxed_api/sandbox2/stack_trace_test.cc
@@ -26,13 +26,12 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/base/log_severity.h"
-#include "absl/flags/declare.h"
-#include "absl/flags/flag.h"
-#include "absl/flags/reflection.h"
 #include "absl/log/check.h"
 #include "absl/log/scoped_mock_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/time/time.h"
+#include "sandboxed_api/sandbox2/allowlists/all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/namespaces.h"
 #include "sandboxed_api/sandbox2/executor.h"
 #include "sandboxed_api/sandbox2/global_forkclient.h"
 #include "sandboxed_api/sandbox2/policy.h"
@@ -43,8 +42,6 @@
 #include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/status_matchers.h"
 
-ABSL_DECLARE_FLAG(bool, sandbox_libunwind_crash_handler);
-
 namespace sandbox2 {
 
 class StackTraceTestPeer {
@@ -161,49 +158,41 @@ void SymbolizationWorksWithModifiedPolicy(
   SymbolizationWorksCommon(test_case);
 }
 
-TEST_P(StackTraceTest, SymbolizationWorksNonSandboxedLibunwind) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, false);
-
-  SymbolizationWorksCommon(GetParam());
+TEST_P(StackTraceTest, SymbolizationWorksWithoutnNamespaces) {
+  TestCase test_case = GetParam();
+  auto old_modify_policy = test_case.modify_policy;
+  test_case.modify_policy = [old_modify_policy](PolicyBuilder* builder) {
+    *builder = PolicyBuilder();
+    builder->DefaultAction(AllowAllSyscalls())
+        .DisableNamespaces(NamespacesToken());
+    if (old_modify_policy) {
+      old_modify_policy(builder);
+    }
+  };
+  SymbolizationWorksCommon(test_case);
 }
 
-TEST_P(StackTraceTest, SymbolizationWorksSandboxedLibunwind) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, true);
-
+TEST_P(StackTraceTest, SymbolizationWorks) {
   SymbolizationWorksCommon(GetParam());
 }
 
 TEST(StackTraceTest, SymbolizationWorksSandboxedLibunwindProcDirMounted) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, true);
-
   SymbolizationWorksWithModifiedPolicy(
       [](PolicyBuilder* builder) { builder->AddDirectory("/proc"); });
 }
 
 TEST(StackTraceTest, SymbolizationWorksSandboxedLibunwindProcFileMounted) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, true);
-
   SymbolizationWorksWithModifiedPolicy([](PolicyBuilder* builder) {
     builder->AddFile("/proc/sys/vm/overcommit_memory");
   });
 }
 
 TEST(StackTraceTest, SymbolizationWorksSandboxedLibunwindSysDirMounted) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, true);
-
   SymbolizationWorksWithModifiedPolicy(
       [](PolicyBuilder* builder) { builder->AddDirectory("/sys"); });
 }
 
 TEST(StackTraceTest, SymbolizationWorksSandboxedLibunwindSysFileMounted) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, true);
-
   SymbolizationWorksWithModifiedPolicy([](PolicyBuilder* builder) {
     builder->AddFile("/sys/devices/system/cpu/online");
   });
@@ -217,9 +206,6 @@ size_t FileCountInDirectory(const std::string& path) {
 }
 
 TEST(StackTraceTest, ForkEnterNsLibunwindDoesNotLeakFDs) {
-  absl::FlagSaver fs;
-  absl::SetFlag(&FLAGS_sandbox_libunwind_crash_handler, true);
-
   // Very first sanitization might create some fds (e.g. for initial
   // namespaces).
   SymbolizationWorksCommon({});
@@ -331,6 +317,13 @@ INSTANTIATE_TEST_SUITE_P(
             .final_status = Result::VIOLATION,
             .function_name = "ViolatePolicy",
             .full_function_description = "ViolatePolicy(int)",
+        },
+        TestCase{
+            .testname = "ViolatePolicyForked",
+            .testno = 5,
+            .final_status = Result::VIOLATION,
+            .function_name = "ViolatePolicy",
+            .full_function_description = "ViolatePolicy(int)",
         }),
     [](const ::testing::TestParamInfo<TestCase>& info) {
       return info.param.testname;
diff --git a/sandboxed_api/sandbox2/syscall.cc b/sandboxed_api/sandbox2/syscall.cc
index 57ca819..bd42f64 100644
--- a/sandboxed_api/sandbox2/syscall.cc
+++ b/sandboxed_api/sandbox2/syscall.cc
@@ -74,6 +74,10 @@ std::string Syscall::GetName() const {
   return absl::StrFormat("UNKNOWN[%d/0x%x]", nr_, nr_);
 }
 
+std::vector<syscalls::ArgData> Syscall::GetArgumentsData() const {
+  return SyscallTable::get(arch_).GetArgumentsData(nr_, args_.data(), pid_);
+}
+
 std::vector<std::string> Syscall::GetArgumentsDescription() const {
   return SyscallTable::get(arch_).GetArgumentsDescription(nr_, args_.data(),
                                                           pid_);
diff --git a/sandboxed_api/sandbox2/syscall.h b/sandboxed_api/sandbox2/syscall.h
index b4e5bd0..23d2015 100644
--- a/sandboxed_api/sandbox2/syscall.h
+++ b/sandboxed_api/sandbox2/syscall.h
@@ -27,6 +27,7 @@
 #include <vector>
 
 #include "sandboxed_api/config.h"  // IWYU pragma: export
+#include "sandboxed_api/sandbox2/syscall_defs.h"
 
 namespace sandbox2 {
 
@@ -59,7 +60,7 @@ class Syscall {
   uint64_t instruction_pointer() const { return ip_; }
 
   std::string GetName() const;
-
+  std::vector<syscalls::ArgData> GetArgumentsData() const;
   std::vector<std::string> GetArgumentsDescription() const;
   std::string GetDescription() const;
 
diff --git a/sandboxed_api/sandbox2/syscall_defs.cc b/sandboxed_api/sandbox2/syscall_defs.cc
index a7b41ed..da7555b 100644
--- a/sandboxed_api/sandbox2/syscall_defs.cc
+++ b/sandboxed_api/sandbox2/syscall_defs.cc
@@ -1,9 +1,19 @@
 #include "sandboxed_api/sandbox2/syscall_defs.h"
 
+#include <arpa/inet.h>
+#include <dirent.h>
+#include <linux/netlink.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <pwd.h>
+#include <poll.h> // ANDROID: changed from sys/poll.h
+#include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/un.h>
 
 #include <array>
 #include <cstdint>
+#include <optional>
 #include <string>
 #include <vector>
 
@@ -14,38 +24,79 @@
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
+#include "absl/types/span.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/sandbox2/util.h"
+#include "sandboxed_api/util/status_macros.h"
 
 namespace sandbox2 {
 
-std::string SyscallTable::Entry::GetArgumentDescription(uint64_t value,
-                                                        syscalls::ArgType type,
-                                                        pid_t pid) {
-  std::string ret = absl::StrFormat("%#x", value);
-  switch (type) {
-    case syscalls::kOct:
-      absl::StrAppendFormat(&ret, " [\\0%o]", value);
+namespace syscalls {
+
+absl::StatusOr<std::string> syscalls::ArgData::GetDescriptionImpl() const {
+  std::string formatted;
+  switch (type_) {
+    case kPath: {
+      SAPI_ASSIGN_OR_RETURN(std::string str, ReadAsString());
+      formatted = absl::StrFormat("'%s'", absl::CHexEscape(str));
+      break;
+    }
+    case kString: {
+      SAPI_ASSIGN_OR_RETURN(std::string str, ReadAsString());
+      formatted = absl::StrFormat("\"%s\"", absl::CHexEscape(str));
       break;
-    case syscalls::kPath:
-      if (auto path_or = util::ReadCPathFromPid(pid, value); path_or.ok()) {
-        absl::StrAppendFormat(&ret, " ['%s']",
-                              absl::CHexEscape(path_or.value()));
-      } else {
-        absl::StrAppend(&ret, " [unreadable path]");
-      }
+    }
+    case kFlags:
+      formatted = absl::StrFormat("\\0%o", value_);
       break;
-    case syscalls::kInt:
-      absl::StrAppendFormat(&ret, " [%d]", value);
+    case kSignal:
+      formatted = util::GetSignalName(value_);
       break;
-    default:
+    case kAddressFamily:
+      formatted = util::GetAddressFamily(value_);
       break;
+    case kInt:
+    case kResource:
+    case kIpcResource:
+    case kPid:
+    case kGid:
+    case kUid:
+    case kLen0:
+    case kLen1:
+    case kLen2:
+    case kLen3:
+    case kLen4:
+    case kLen5:
+      formatted = absl::StrCat(value_);
+      break;
+    case kPollFdArray:
+    case kSockaddr:
+    case kGen:
+    case kStruct:
+    case kPtr:
+    case kArray:
+    case kSharedAddress:
+    case kGidArray:
+      break;
+    default:
+      return absl::InternalError("Unable to format invalid type");
   }
-  return ret;
+
+  if (formatted.empty()) {
+    return absl::StrFormat("%#x", value_);
+  }
+  return absl::StrFormat("%#x [%s]", value_, formatted);
 }
 
+std::string ArgData::GetDescription() const {
+  return GetDescriptionImpl().value_or(
+      absl::StrFormat("%#x [unavailable]", value_));
+}
+
+}  // namespace syscalls
+
 absl::string_view SyscallTable::GetName(int syscall) const {
-  auto entry = GetEntry(syscall);
+  absl::StatusOr<SyscallTable::Entry> entry = GetEntry(syscall);
   if (!entry.ok()) {
     return "";
   }
@@ -100,23 +151,48 @@ absl::StatusOr<SyscallTable::Entry> SyscallTable::GetEntry(
   }
 }
 
-std::vector<std::string> SyscallTable::GetArgumentsDescription(
+constexpr SyscallTable::Entry kInvalidEntry =
+    MakeEntry(-1, "unknown_syscall", UnknownArguments());
+
+std::vector<syscalls::ArgData> SyscallTable::GetArgumentsData(
     int syscall, const uint64_t values[], pid_t pid) const {
-  static SyscallTable::Entry kInvalidEntry =
-      MakeEntry(-1, "", UnknownArguments());
-  auto entry = GetEntry(syscall);
-  if (!entry.ok()) {
-    entry = kInvalidEntry;
+  SyscallTable::Entry entry = GetEntry(syscall).value_or(kInvalidEntry);
+  // First do a length scan.
+  std::array<std::optional<uint64_t>, syscalls::kMaxArgs> lengths;
+  for (int i = 0; i < entry.GetNumArgs(); ++i) {
+    syscalls::ArgType type = entry.arg_types[i];
+    if (type == syscalls::kLen0) {
+      lengths[0] = values[i];
+    } else if (type == syscalls::kLen1) {
+      lengths[1] = values[i];
+    } else if (type == syscalls::kLen2) {
+      lengths[2] = values[i];
+    } else if (type == syscalls::kLen3) {
+      lengths[3] = values[i];
+    } else if (type == syscalls::kLen4) {
+      lengths[4] = values[i];
+    } else if (type == syscalls::kLen5) {
+      lengths[5] = values[i];
+    }
   }
 
-  int num_args = entry->GetNumArgs();
-  std::vector<std::string> rv;
-  rv.reserve(num_args);
-  for (int i = 0; i < num_args; ++i) {
-    rv.push_back(SyscallTable::Entry::GetArgumentDescription(
-        values[i], entry->arg_types[i], pid));
+  // Then get all verbose descriptions, passing the correct lengths where used.
+  std::vector<syscalls::ArgData> args;
+  for (int i = 0; i < entry.GetNumArgs(); ++i) {
+    const syscalls::ArgType type = entry.arg_types[i];
+    args.push_back(syscalls::ArgData(type, pid, values[i], lengths[i]));
   }
-  return rv;
+
+  return args;
+}
+
+std::vector<std::string> SyscallTable::GetArgumentsDescription(
+    int syscall, const uint64_t values[], pid_t pid) const {
+  std::vector<std::string> descriptions;
+  for (const syscalls::ArgData& arg : GetArgumentsData(syscall, values, pid)) {
+    descriptions.push_back(arg.GetDescription());
+  }
+  return descriptions;
 }
 
 namespace syscalls {
@@ -142,351 +218,354 @@ constexpr bool IsSorted(const Container& container, Compare comp) {
 // Syscall description table for Linux x86_64
 constexpr std::array kSyscallDataX8664 = {
     // clang-format off
-    MakeEntry(0, "read", kInt, kHex, kInt),
-    MakeEntry(1, "write", kInt, kHex, kInt),
-    MakeEntry(2, "open", kPath, kHex, kOct),
-    MakeEntry(3, "close", kInt),
-    MakeEntry(4, "stat", kPath, kGen),
-    MakeEntry(5, "fstat", kInt, kHex),
-    MakeEntry(6, "lstat", kPath, kGen),
-    MakeEntry(7, "poll", kGen, kInt, kInt),
-    MakeEntry(8, "lseek", kInt, kInt, kInt),
-    MakeEntry(9, "mmap", kHex, kInt, kHex, kHex, kInt, kInt),
-    MakeEntry(10, "mprotect", kHex, kInt, kHex),
-    MakeEntry(11, "munmap", kHex, kInt),
+
+    MakeEntry(0, "read", kResource, kArray, kLen1),
+    MakeEntry(1, "write", kResource, kArray, kLen1),
+    MakeEntry(2, "open", kPath, kFlags, kFlags),
+    MakeEntry(3, "close", kResource),
+    MakeEntry(4, "stat", kPath, kPtr),
+    MakeEntry(5, "fstat", kResource, kPtr),
+    MakeEntry(6, "lstat", kPath, kPtr),
+    MakeEntry(7, "poll", kPollFdArray, kLen0, kInt),
+    MakeEntry(8, "lseek", kResource, kInt, kFlags),
+    MakeEntry(9, "mmap", kPtr, kLen0, kFlags, kFlags, kResource, kInt),
+    MakeEntry(10, "mprotect", kPtr, kLen0, kFlags),
+    MakeEntry(11, "munmap", kPtr, kLen0),
     MakeEntry(12, "brk", kInt),
-    MakeEntry(13, "rt_sigaction", kSignal, kHex, kHex, kInt),
-    MakeEntry(14, "rt_sigprocmask", kInt, kHex, kHex, kInt),
+    MakeEntry(13, "rt_sigaction", kSignal, kPtr, kPtr, kLen4, kPtr),
+    MakeEntry(14, "rt_sigprocmask", kFlags, kPtr, kPtr, kLen1),
     MakeEntry(15, "rt_sigreturn"),
-    MakeEntry(16, "ioctl", kInt, kInt, kHex),
-    MakeEntry(17, "pread64", kInt, kHex, kInt, kInt),
-    MakeEntry(18, "pwrite64", kInt, kHex, kInt, kInt),
-    MakeEntry(19, "readv", kInt, kHex, kInt),
-    MakeEntry(20, "writev", kInt, kHex, kInt),
-    MakeEntry(21, "access", kPath, kOct),
-    MakeEntry(22, "pipe", kHex),
-    MakeEntry(23, "select", kInt, kHex, kHex, kHex, kHex),
+    MakeEntry(16, "ioctl", kResource, kInt, kArray),
+    MakeEntry(17, "pread64", kResource, kArray, kLen1, kInt),
+    MakeEntry(18, "pwrite64", kResource, kArray, kLen1, kInt),
+    MakeEntry(19, "readv", kResource, kArray, kLen1),
+    MakeEntry(20, "writev", kResource, kArray, kLen1),
+    MakeEntry(21, "access", kPath, kFlags),
+    MakeEntry(22, "pipe", kPtr),
+    MakeEntry(23, "select", kLen1, kPtr, kPtr, kPtr, kPtr),
     MakeEntry(24, "sched_yield"),
-    MakeEntry(25, "mremap", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(26, "msync", kHex, kInt, kInt),
-    MakeEntry(27, "mincore", kHex, kInt, kHex),
-    MakeEntry(28, "madvise", kHex, kInt, kInt),
-    MakeEntry(29, "shmget", kInt, kInt, kHex),
-    MakeEntry(30, "shmat", kInt, kHex, kHex),
-    MakeEntry(31, "shmctl", kInt, kInt, kHex),
-    MakeEntry(32, "dup", kInt),
-    MakeEntry(33, "dup2", kInt, kInt),
+    MakeEntry(25, "mremap", kPtr, kLen0, kLen4, kFlags, kPtr),
+    MakeEntry(26, "msync", kPtr, kLen0, kFlags),
+    MakeEntry(27, "mincore", kPtr, kLen0, kArray),
+    MakeEntry(28, "madvise", kPtr, kLen0, kFlags),
+    MakeEntry(29, "shmget", kInt, kLen3, kFlags, kPtr),
+    MakeEntry(30, "shmat", kIpcResource, kPtr, kFlags),
+    MakeEntry(31, "shmctl", kIpcResource, kInt, kArray),
+    MakeEntry(32, "dup", kResource),
+    MakeEntry(33, "dup2", kResource, kResource),
     MakeEntry(34, "pause"),
-    MakeEntry(35, "nanosleep", kHex, kHex),
-    MakeEntry(36, "getitimer", kInt, kHex),
+    MakeEntry(35, "nanosleep", kPtr, kPtr),
+    MakeEntry(36, "getitimer", kFlags, kPtr),
     MakeEntry(37, "alarm", kInt),
-    MakeEntry(38, "setitimer", kInt, kHex, kHex),
+    MakeEntry(38, "setitimer", kFlags, kPtr, kPtr),
     MakeEntry(39, "getpid"),
-    MakeEntry(40, "sendfile", kInt, kInt, kHex, kInt),
-    MakeEntry(41, "socket", kAddressFamily, kInt, kInt),
-    MakeEntry(42, "connect", kInt, kSockaddr, kInt),
-    MakeEntry(43, "accept", kInt, kSockaddr, kHex),
-    MakeEntry(44, "sendto", kInt, kHex, kInt, kHex, kSockaddr, kInt),
-    MakeEntry(45, "recvfrom", kInt, kHex, kInt, kHex, kSockaddr, kHex),
-    MakeEntry(46, "sendmsg", kInt, kSockmsghdr, kHex),
-    MakeEntry(47, "recvmsg", kInt, kHex, kInt),
-    MakeEntry(48, "shutdown", kInt, kInt),
-    MakeEntry(49, "bind", kInt, kSockaddr, kInt),
-    MakeEntry(50, "listen", kInt, kInt),
-    MakeEntry(51, "getsockname", kInt, kSockaddr, kHex),
-    MakeEntry(52, "getpeername", kInt, kSockaddr, kHex),
-    MakeEntry(53, "socketpair", kAddressFamily, kInt, kInt, kHex),
-    MakeEntry(54, "setsockopt", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(55, "getsockopt", kInt, kInt, kInt, kHex, kInt),
-    MakeEntry(56, "clone", kCloneFlag, kHex, kHex, kHex, kHex),
+    MakeEntry(40, "sendfile", kResource, kResource, kPtr, kInt),
+    MakeEntry(41, "socket", kFlags, kFlags, kInt),
+    MakeEntry(42, "connect", kResource, kSockaddr, kLen1),
+    MakeEntry(43, "accept", kResource, kPtr, kPtr),
+    MakeEntry(44, "sendto", kResource, kArray, kLen1, kFlags, kSockaddr, kLen4),
+    MakeEntry(45, "recvfrom", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
+    MakeEntry(46, "sendmsg", kResource, kPtr, kFlags),
+    MakeEntry(47, "recvmsg", kResource, kPtr, kFlags),
+    MakeEntry(48, "shutdown", kResource, kFlags),
+    MakeEntry(49, "bind", kResource, kSockaddr, kLen1),
+    MakeEntry(50, "listen", kResource, kInt),
+    MakeEntry(51, "getsockname", kResource, kPtr, kPtr),
+    MakeEntry(52, "getpeername", kResource, kPtr, kPtr),
+    MakeEntry(53, "socketpair", kFlags, kFlags, kInt, kPtr),
+    MakeEntry(54, "setsockopt", kResource, kInt, kInt, kArray, kLen3),
+    MakeEntry(55, "getsockopt", kResource, kInt, kInt, kArray, kPtr),
+    MakeEntry(56, "clone", kFlags, kArray, kPtr, kPtr, kArray),
     MakeEntry(57, "fork"),
     MakeEntry(58, "vfork"),
-    MakeEntry(59, "execve", kPath, kHex, kHex),
+    MakeEntry(59, "execve", kPath, kArray, kArray),
     MakeEntry(60, "exit", kInt),
-    MakeEntry(61, "wait4", kInt, kHex, kHex, kHex),
-    MakeEntry(62, "kill", kInt, kSignal),
-    MakeEntry(63, "uname", kInt),
-    MakeEntry(64, "semget", kInt, kInt, kHex),
-    MakeEntry(65, "semop", kInt, kHex, kInt),
-    MakeEntry(66, "semctl", kInt, kInt, kInt, kHex),
-    MakeEntry(67, "shmdt", kHex),
-    MakeEntry(68, "msgget", kInt, kHex),
-    MakeEntry(69, "msgsnd", kInt, kHex, kInt, kHex),
-    MakeEntry(70, "msgrcv", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(71, "msgctl", kInt, kInt, kHex),
-    MakeEntry(72, "fcntl", kInt, kInt, kHex),
-    MakeEntry(73, "flock", kInt, kInt),
-    MakeEntry(74, "fsync", kInt),
-    MakeEntry(75, "fdatasync", kInt),
+    MakeEntry(61, "wait4", kPid, kPtr, kFlags, kPtr),
+    MakeEntry(62, "kill", kPid, kSignal),
+    MakeEntry(63, "uname", kArray),
+    MakeEntry(64, "semget", kIpcResource, kFlags, kFlags),
+    MakeEntry(65, "semop", kIpcResource, kArray, kLen1),
+    MakeEntry(66, "semctl", kIpcResource, kFlags, kInt, kArray),
+    MakeEntry(67, "shmdt", kSharedAddress),
+    MakeEntry(68, "msgget", kIpcResource, kFlags),
+    MakeEntry(69, "msgsnd", kIpcResource, kPtr, kLen1, kFlags),
+    MakeEntry(70, "msgrcv", kIpcResource, kPtr, kLen1, kFlags, kFlags),
+    MakeEntry(71, "msgctl", kIpcResource, kInt, kArray),
+    MakeEntry(72, "fcntl", kResource, kFlags, kResource),
+    MakeEntry(73, "flock", kResource, kFlags),
+    MakeEntry(74, "fsync", kResource),
+    MakeEntry(75, "fdatasync", kResource),
     MakeEntry(76, "truncate", kPath, kInt),
-    MakeEntry(77, "ftruncate", kInt, kInt),
-    MakeEntry(78, "getdents", kInt, kHex, kInt),
-    MakeEntry(79, "getcwd", kHex, kInt),
+    MakeEntry(77, "ftruncate", kResource, kInt),
+    MakeEntry(78, "getdents", kResource, kArray, kLen1),
+    MakeEntry(79, "getcwd", kArray, kLen0),
     MakeEntry(80, "chdir", kPath),
-    MakeEntry(81, "fchdir", kInt),
+    MakeEntry(81, "fchdir", kResource),
     MakeEntry(82, "rename", kPath, kPath),
-    MakeEntry(83, "mkdir", kPath, kOct),
+    MakeEntry(83, "mkdir", kPath, kFlags),
     MakeEntry(84, "rmdir", kPath),
-    MakeEntry(85, "creat", kPath, kOct),
+    MakeEntry(85, "creat", kPath, kFlags),
     MakeEntry(86, "link", kPath, kPath),
     MakeEntry(87, "unlink", kPath),
     MakeEntry(88, "symlink", kPath, kPath),
-    MakeEntry(89, "readlink", kPath, kHex, kInt),
-    MakeEntry(90, "chmod", kPath, kOct),
-    MakeEntry(91, "fchmod", kInt, kOct),
-    MakeEntry(92, "chown", kPath, kInt, kInt),
-    MakeEntry(93, "fchown", kInt, kInt, kInt),
-    MakeEntry(94, "lchown", kPath, kInt, kInt),
-    MakeEntry(95, "umask", kHex),
-    MakeEntry(96, "gettimeofday", kHex, kHex),
-    MakeEntry(97, "getrlimit", kInt, kHex),
-    MakeEntry(98, "getrusage", kInt, kHex),
-    MakeEntry(99, "sysinfo", kHex),
-    MakeEntry(100, "times", kHex),
-    MakeEntry(101, "ptrace", kInt, kInt, kHex, kHex),
+    MakeEntry(89, "readlink", kPath, kArray, kLen1),
+    MakeEntry(90, "chmod", kPath, kFlags),
+    MakeEntry(91, "fchmod", kResource, kFlags),
+    MakeEntry(92, "chown", kPath, kUid, kGid),
+    MakeEntry(93, "fchown", kResource, kUid, kGid),
+    MakeEntry(94, "lchown", kPath, kUid, kGid),
+    MakeEntry(95, "umask", kFlags),
+    MakeEntry(96, "gettimeofday", kPtr, kPtr),
+    MakeEntry(97, "getrlimit", kFlags, kPtr),
+    MakeEntry(98, "getrusage", kFlags, kPtr),
+    MakeEntry(99, "sysinfo", kArray),
+    MakeEntry(100, "times", kPtr),
+    MakeEntry(101, "ptrace", kFlags, kPid),
     MakeEntry(102, "getuid"),
-    MakeEntry(103, "syslog", kInt, kHex, kInt),
+    MakeEntry(103, "syslog", kFlags, kArray, kLen1),
     MakeEntry(104, "getgid"),
-    MakeEntry(105, "setuid", kInt),
-    MakeEntry(106, "setgid", kInt),
+    MakeEntry(105, "setuid", kUid),
+    MakeEntry(106, "setgid", kGid),
     MakeEntry(107, "geteuid"),
     MakeEntry(108, "getegid"),
-    MakeEntry(109, "setpgid", kInt, kInt),
+    MakeEntry(109, "setpgid", kPid, kPid),
     MakeEntry(110, "getppid"),
-    MakeEntry(111, "getpgrp"),
+    MakeEntry(111, "getpgrp", kPid),
     MakeEntry(112, "setsid"),
-    MakeEntry(113, "setreuid", kInt, kInt),
-    MakeEntry(114, "setregid", kInt, kInt),
-    MakeEntry(115, "getgroups", kInt, kHex),
-    MakeEntry(116, "setgroups", kInt, kHex),
-    MakeEntry(117, "setresuid", kInt, kInt, kInt),
-    MakeEntry(118, "getresuid", kHex, kHex, kHex),
-    MakeEntry(119, "setresgid", kInt, kInt, kInt),
-    MakeEntry(120, "getresgid", kHex, kHex, kHex),
-    MakeEntry(121, "getpgid", kInt),
-    MakeEntry(122, "setfsuid", kInt),
-    MakeEntry(123, "setfsgid", kInt),
-    MakeEntry(124, "getsid", kInt),
-    MakeEntry(125, "capget", kHex, kHex),
-    MakeEntry(126, "capset", kHex, kHex),
-    MakeEntry(127, "rt_sigpending", kHex, kInt),
-    MakeEntry(128, "rt_sigtimedwait", kHex, kHex, kHex, kInt),
-    MakeEntry(129, "rt_sigqueueinfo", kInt, kSignal, kHex),
-    MakeEntry(130, "rt_sigsuspend", kHex, kInt),
-    MakeEntry(131, "sigaltstack", kHex, kHex),
-    MakeEntry(132, "utime", kPath, kHex),
-    MakeEntry(133, "mknod", kPath, kOct, kHex),
+    MakeEntry(113, "setreuid", kUid, kUid),
+    MakeEntry(114, "setregid", kGid, kGid),
+    MakeEntry(115, "getgroups", kLen1, kGidArray),
+    MakeEntry(116, "setgroups", kLen1, kGidArray),
+    MakeEntry(117, "setresuid", kUid, kUid, kUid),
+    MakeEntry(118, "getresuid", kPtr, kPtr, kPtr),
+    MakeEntry(119, "setresgid", kGid, kGid, kGid),
+    MakeEntry(120, "getresgid", kPtr, kPtr, kPtr),
+    MakeEntry(121, "getpgid", kPid),
+    MakeEntry(122, "setfsuid", kUid),
+    MakeEntry(123, "setfsgid", kGid),
+    MakeEntry(124, "getsid", kPid),
+    MakeEntry(125, "capget", kPtr, kPtr),
+    MakeEntry(126, "capset", kPtr, kPtr),
+    MakeEntry(127, "rt_sigpending", kPtr, kLen0),
+    MakeEntry(128, "rt_sigtimedwait", kPtr, kPtr, kPtr, kLen0),
+    MakeEntry(129, "rt_sigqueueinfo", kPid, kSignal, kPtr),
+    MakeEntry(130, "rt_sigsuspend", kPtr, kLen0),
+    MakeEntry(131, "sigaltstack", kPtr, kPtr),
+    MakeEntry(132, "utime", kPath, kPtr),
+    MakeEntry(133, "mknod", kPath, kFlags, kInt),
     MakeEntry(134, "uselib", kPath),
-    MakeEntry(135, "personality", kHex),
-    MakeEntry(136, "ustat", kHex, kHex),
-    MakeEntry(137, "statfs", kPath, kHex),
-    MakeEntry(138, "fstatfs", kInt, kHex),
-    MakeEntry(139, "sysfs", kInt, kInt, kInt),
-    MakeEntry(140, "getpriority", kInt, kInt),
-    MakeEntry(141, "setpriority", kInt, kInt, kInt),
-    MakeEntry(142, "sched_setparam", kInt, kHex),
-    MakeEntry(143, "sched_getparam", kInt, kHex),
-    MakeEntry(144, "sched_setscheduler", kInt, kInt, kHex),
-    MakeEntry(145, "sched_getscheduler", kInt),
+    MakeEntry(135, "personality", kFlags),
+    MakeEntry(136, "ustat", kInt, kPtr),
+    MakeEntry(137, "statfs", kPath, kArray),
+    MakeEntry(138, "fstatfs", kResource, kArray),
+    MakeEntry(139, "sysfs", kInt, kString),
+    MakeEntry(140, "getpriority", kFlags, kPid),
+    MakeEntry(141, "setpriority", kFlags, kPid, kInt),
+    MakeEntry(142, "sched_setparam", kPid, kPtr),
+    MakeEntry(143, "sched_getparam", kPid, kPtr),
+    MakeEntry(144, "sched_setscheduler", kPid, kFlags, kPtr),
+    MakeEntry(145, "sched_getscheduler", kPid),
     MakeEntry(146, "sched_get_priority_max", kInt),
     MakeEntry(147, "sched_get_priority_min", kInt),
-    MakeEntry(148, "sched_rr_get_interval", kInt, kHex),
-    MakeEntry(149, "mlock", kInt, kInt),
-    MakeEntry(150, "munlock", kInt, kInt),
-    MakeEntry(151, "mlockall", kHex),
+    MakeEntry(148, "sched_rr_get_interval", kPid, kPtr),
+    MakeEntry(149, "mlock", kPtr, kLen0),
+    MakeEntry(150, "munlock", kPtr, kLen0),
+    MakeEntry(151, "mlockall", kFlags),
     MakeEntry(152, "munlockall"),
     MakeEntry(153, "vhangup"),
-    MakeEntry(154, "modify_ldt", kInt, kHex, kInt),
+    MakeEntry(154, "modify_ldt", kInt, kPtr, kLen1),
     MakeEntry(155, "pivot_root", kPath, kPath),
-    MakeEntry(156, "_sysctl", kHex),
-    MakeEntry(157, "prctl", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(158, "arch_prctl", kInt, kHex),
-    MakeEntry(159, "adjtimex", kHex),
-    MakeEntry(160, "setrlimit", kInt, kHex),
+    MakeEntry(156, "_sysctl", kPtr),
+    MakeEntry(157, "prctl", kInt, kInt, kInt, kInt, kInt),
+    MakeEntry(158, "arch_prctl", kInt, kInt),
+    MakeEntry(159, "adjtimex", kArray),
+    MakeEntry(160, "setrlimit", kFlags, kPtr),
     MakeEntry(161, "chroot", kPath),
     MakeEntry(162, "sync"),
     MakeEntry(163, "acct", kPath),
-    MakeEntry(164, "settimeofday", kHex, kHex),
-    MakeEntry(165, "mount", kPath, kPath, kString, kHex, kGen),
-    MakeEntry(166, "umount2", kPath, kHex),
-    MakeEntry(167, "swapon", kPath, kHex),
+    MakeEntry(164, "settimeofday", kPtr, kPtr),
+    MakeEntry(165, "mount", kPtr, kPath, kString, kFlags, kString),
+    MakeEntry(166, "umount2", kPath, kFlags),
+    MakeEntry(167, "swapon", kPath, kFlags),
     MakeEntry(168, "swapoff", kPath),
-    MakeEntry(169, "reboot", kInt, kHex, kHex, kGen),
-    MakeEntry(170, "sethostname", kString, kInt),
-    MakeEntry(171, "setdomainname", kString, kInt),
+    MakeEntry(169, "reboot", kInt, kInt, kInt, kPtr),
+    MakeEntry(170, "sethostname", kString, kLen0),
+    MakeEntry(171, "setdomainname", kString, kLen0),
     MakeEntry(172, "iopl", kInt),
     MakeEntry(173, "ioperm", kInt, kInt, kInt),
     MakeEntry(174, "create_module", kString, kInt),
-    MakeEntry(175, "init_module", kGen, kInt, kString),
-    MakeEntry(176, "delete_module", kString, kHex),
-    MakeEntry(177, "get_kernel_syms", kHex),
+    MakeEntry(175, "init_module", kString, kLen0, kString),
+    MakeEntry(176, "delete_module", kString, kFlags),
+    MakeEntry(177, "get_kernel_syms", kInt),
     MakeEntry(178, "query_module", kString, kInt, kGen, kInt, kGen),
     MakeEntry(179, "quotactl", kInt, kPath, kInt, kGen),
-    MakeEntry(180, "nfsservctl", kInt, kGen, kGen),
+    MakeEntry(180, "nfsservctl", kInt, kPtr, kPtr),
     MakeEntry(181, "getpmsg", UnknownArguments()),
     MakeEntry(182, "putpmsg", UnknownArguments()),
     MakeEntry(183, "afs_syscall", UnknownArguments()),
     MakeEntry(184, "tuxcall", UnknownArguments()),
     MakeEntry(185, "security", UnknownArguments()),
     MakeEntry(186, "gettid"),
-    MakeEntry(187, "readahead", kInt, kInt, kInt),
-    MakeEntry(188, "setxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(189, "lsetxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(190, "fsetxattr", kInt, kString, kGen, kInt, kHex),
-    MakeEntry(191, "getxattr", kPath, kString, kGen, kInt),
-    MakeEntry(192, "lgetxattr", kPath, kString, kGen, kInt),
-    MakeEntry(193, "fgetxattr", kInt, kString, kGen, kInt),
-    MakeEntry(194, "listxattr", kPath, kGen, kInt),
-    MakeEntry(195, "llistxattr", kPath, kGen, kInt),
-    MakeEntry(196, "flistxattr", kInt, kGen, kInt),
-    MakeEntry(197, "removexattr", kPath, kString),
-    MakeEntry(198, "lremovexattr", kPath, kString),
-    MakeEntry(199, "fremovexattr", kInt, kString),
-    MakeEntry(200, "tkill", kInt, kSignal),
-    MakeEntry(201, "time", kHex),
-    MakeEntry(202, "futex", kGen, kInt, kInt, kGen, kGen, kInt),
-    MakeEntry(203, "sched_setaffinity", kInt, kInt, kHex),
-    MakeEntry(204, "sched_getaffinity", kInt, kInt, kHex),
-    MakeEntry(205, "set_thread_area", kHex),
-    MakeEntry(206, "io_setup", kInt, kHex),
-    MakeEntry(207, "io_destroy", kInt),
-    MakeEntry(208, "io_getevents", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(209, "io_submit", kInt, kInt, kHex),
-    MakeEntry(210, "io_cancel", kInt, kHex, kHex),
-    MakeEntry(211, "get_thread_area", kHex),
-    MakeEntry(212, "lookup_dcookie", kInt, kString, kInt),
+    MakeEntry(187, "readahead", kResource, kInt, kInt),
+    MakeEntry(188, "setxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(189, "lsetxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(190, "fsetxattr", kResource, kPtr, kString, kLen2, kFlags),
+    MakeEntry(191, "getxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(192, "lgetxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(193, "fgetxattr", kResource, kPtr, kArray, kLen2),
+    MakeEntry(194, "listxattr", kPath, kArray, kLen1),
+    MakeEntry(195, "llistxattr", kPath, kArray, kLen1),
+    MakeEntry(196, "flistxattr", kResource, kArray, kLen1),
+    MakeEntry(197, "removexattr", kPath, kPtr),
+    MakeEntry(198, "lremovexattr", kPath, kPtr),
+    MakeEntry(199, "fremovexattr", kResource, kPtr),
+    MakeEntry(200, "tkill", kPid, kSignal),
+    MakeEntry(201, "time", kPtr),
+    MakeEntry(202, "futex", kPtr, kFlags, kInt, kPtr, kPtr, kInt),
+    MakeEntry(203, "sched_setaffinity", kPid, kLen2, kPtr),
+    MakeEntry(204, "sched_getaffinity", kPid, kLen2, kPtr),
+    MakeEntry(205, "set_thread_area", kPtr),
+    MakeEntry(206, "io_setup", kInt, kPtr),
+    MakeEntry(207, "io_destroy", kStruct),
+    MakeEntry(208, "io_getevents", kStruct, kInt, kLen3, kArray, kPtr),
+    MakeEntry(209, "io_submit", kStruct, kLen2, kArray),
+    MakeEntry(210, "io_cancel", kStruct, kPtr, kPtr),
+    MakeEntry(211, "get_thread_area", kPtr),
+    MakeEntry(212, "lookup_dcookie", kInt, kArray, kLen1),
     MakeEntry(213, "epoll_create", kInt),
     MakeEntry(214, "epoll_ctl_old", UnknownArguments()),
     MakeEntry(215, "epoll_wait_old", UnknownArguments()),
-    MakeEntry(216, "remap_file_pages", kGen, kInt, kInt, kInt, kHex),
-    MakeEntry(217, "getdents64", kInt, kHex, kInt),
-    MakeEntry(218, "set_tid_address", kHex),
+    MakeEntry(216, "remap_file_pages", kPtr, kLen0, kFlags, kInt, kFlags),
+    MakeEntry(217, "getdents64", kResource, kArray, kLen1),
+    MakeEntry(218, "set_tid_address", kPtr),
     MakeEntry(219, "restart_syscall"),
-    MakeEntry(220, "semtimedop", kInt, kHex, kInt, kHex),
-    MakeEntry(221, "fadvise64", kInt, kInt, kInt, kInt),
-    MakeEntry(222, "timer_create", kInt, kHex, kHex),
-    MakeEntry(223, "timer_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(224, "timer_gettime", kInt, kHex),
-    MakeEntry(225, "timer_getoverrun", kInt),
-    MakeEntry(226, "timer_delete", kInt),
-    MakeEntry(227, "clock_settime", kInt, kHex),
-    MakeEntry(228, "clock_gettime", kInt, kHex),
-    MakeEntry(229, "clock_getres", kInt, kHex),
-    MakeEntry(230, "clock_nanosleep", kInt, kHex, kHex, kHex),
+    MakeEntry(220, "semtimedop", kIpcResource, kArray, kLen1, kPtr),
+    MakeEntry(221, "fadvise64", kResource, kInt, kInt, kFlags),
+    MakeEntry(222, "timer_create", kFlags, kPtr, kPtr),
+    MakeEntry(223, "timer_settime", kStruct, kFlags, kPtr, kPtr),
+    MakeEntry(224, "timer_gettime", kStruct, kPtr),
+    MakeEntry(225, "timer_getoverrun", kStruct),
+    MakeEntry(226, "timer_delete", kStruct),
+    MakeEntry(227, "clock_settime", kFlags, kPtr),
+    MakeEntry(228, "clock_gettime", kFlags, kPtr),
+    MakeEntry(229, "clock_getres", kFlags, kPtr),
+    MakeEntry(230, "clock_nanosleep", kFlags, kFlags, kPtr, kPtr),
     MakeEntry(231, "exit_group", kInt),
-    MakeEntry(232, "epoll_wait", kInt, kHex, kInt, kInt),
-    MakeEntry(233, "epoll_ctl", kInt, kInt, kInt, kHex),
-    MakeEntry(234, "tgkill", kInt, kInt, kSignal),
-    MakeEntry(235, "utimes", kPath, kHex),
+    MakeEntry(232, "epoll_wait", kResource, kArray, kLen1, kInt),
+    MakeEntry(233, "epoll_ctl", kResource, kInt, kResource, kPtr),
+    MakeEntry(234, "tgkill", kPid, kPid, kSignal),
+    MakeEntry(235, "utimes", kPath, kPtr),
     MakeEntry(236, "vserver", UnknownArguments()),
-    MakeEntry(237, "mbind", kGen, kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(238, "set_mempolicy", kInt, kHex, kInt),
-    MakeEntry(239, "get_mempolicy", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(240, "mq_open", kString, kHex, kOct, kHex),
+    MakeEntry(237, "mbind", kPtr, kLen0, kFlags, kPtr, kInt, kFlags),
+    MakeEntry(238, "set_mempolicy", kFlags, kPtr, kInt),
+    MakeEntry(239, "get_mempolicy", kPtr, kPtr, kInt, kPtr, kFlags),
+    MakeEntry(240, "mq_open", kString, kFlags, kFlags, kPtr),
     MakeEntry(241, "mq_unlink", kString),
-    MakeEntry(242, "mq_timedsend", kHex, kHex, kInt, kInt, kHex),
-    MakeEntry(243, "mq_timedreceive", kHex, kHex, kInt, kHex, kHex),
-    MakeEntry(244, "mq_notify", kHex, kHex),
-    MakeEntry(245, "mq_getsetattr", kHex, kHex, kHex),
-    MakeEntry(246, "kexec_load", kHex, kInt, kHex, kHex),
-    MakeEntry(247, "waitid", kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(248, "add_key", kString, kString, kGen, kInt, kInt),
-    MakeEntry(249, "request_key", kString, kString, kHex, kInt),
+    MakeEntry(242, "mq_timedsend", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(243, "mq_timedreceive", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(244, "mq_notify", kResource, kPtr),
+    MakeEntry(245, "mq_getsetattr", kResource, kPtr, kPtr),
+    MakeEntry(246, "kexec_load", kInt, kLen2, kArray, kFlags),
+    MakeEntry(247, "waitid", kFlags, kPid, kPtr, kFlags, kPtr),
+    MakeEntry(248, "add_key", kString, kPtr, kArray, kLen2, kStruct),
+    MakeEntry(249, "request_key", kString, kPtr, kString, kStruct),
     MakeEntry(250, "keyctl", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(251, "ioprio_set", kInt, kInt, kInt),
-    MakeEntry(252, "ioprio_get", kInt, kInt),
+    MakeEntry(251, "ioprio_set", kFlags, kPid, kFlags),
+    MakeEntry(252, "ioprio_get", kFlags, kUid),
     MakeEntry(253, "inotify_init"),
-    MakeEntry(254, "inotify_add_watch", kInt, kPath, kHex),
-    MakeEntry(255, "inotify_rm_watch", kInt, kInt),
-    MakeEntry(256, "migrate_pages", kInt, kInt, kHex, kHex),
-    MakeEntry(257, "openat", kInt, kPath, kHex, kOct),
-    MakeEntry(258, "mkdirat", kInt, kPath, kOct),
-    MakeEntry(259, "mknodat", kInt, kPath, kOct, kHex),
-    MakeEntry(260, "fchownat", kInt, kPath, kInt, kInt, kHex),
-    MakeEntry(261, "futimesat", kInt, kPath, kHex),
-    MakeEntry(262, "newfstatat", kInt, kPath, kHex, kHex),
-    MakeEntry(263, "unlinkat", kInt, kPath, kHex),
-    MakeEntry(264, "renameat", kInt, kPath, kInt, kPath),
-    MakeEntry(265, "linkat", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(266, "symlinkat", kPath, kInt, kPath),
-    MakeEntry(267, "readlinkat", kInt, kPath, kHex, kInt),
-    MakeEntry(268, "fchmodat", kInt, kPath, kOct),
-    MakeEntry(269, "faccessat", kInt, kPath, kInt, kHex),
-    MakeEntry(270, "pselect6", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(271, "ppoll", kHex, kInt, kHex, kHex, kInt),
-    MakeEntry(272, "unshare", kHex),
-    MakeEntry(273, "set_robust_list", kHex, kInt),
-    MakeEntry(274, "get_robust_list", kInt, kHex, kHex),
-    MakeEntry(275, "splice", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(276, "tee", kInt, kInt, kInt, kHex),
-    MakeEntry(277, "sync_file_range", kInt, kInt, kInt, kHex),
-    MakeEntry(278, "vmsplice", kInt, kHex, kInt, kInt),
-    MakeEntry(279, "move_pages", kInt, kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(280, "utimensat", kInt, kPath, kHex, kHex),
-    MakeEntry(281, "epoll_pwait", kInt, kHex, kInt, kInt, kHex, kInt),
-    MakeEntry(282, "signalfd", kInt, kHex, kHex),
-    MakeEntry(283, "timerfd_create", kInt, kHex),
+    MakeEntry(254, "inotify_add_watch", kResource, kPath, kFlags),
+    MakeEntry(255, "inotify_rm_watch", kResource, kResource),
+    MakeEntry(256, "migrate_pages", kPid, kInt, kPtr, kPtr),
+    MakeEntry(257, "openat", kResource, kPath, kFlags, kFlags),
+    MakeEntry(258, "mkdirat", kResource, kPath, kFlags),
+    MakeEntry(259, "mknodat", kResource, kPath, kFlags, kInt),
+    MakeEntry(260, "fchownat", kResource, kPath, kUid, kGid, kFlags),
+    MakeEntry(261, "futimesat", kResource, kPath, kPtr),
+    MakeEntry(262, "newfstatat", kInt, kPath, kPtr, kFlags),
+    MakeEntry(263, "unlinkat", kResource, kPath, kFlags),
+    MakeEntry(264, "renameat", kResource, kPath, kResource, kPath),
+    MakeEntry(265, "linkat", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(266, "symlinkat", kPath, kResource, kPath),
+    MakeEntry(267, "readlinkat", kResource, kPath, kArray, kLen2),
+    MakeEntry(268, "fchmodat", kResource, kPath, kFlags),
+    MakeEntry(269, "faccessat", kResource, kPath, kFlags),
+    MakeEntry(270, "pselect6", kLen1, kPtr, kPtr, kPtr, kPtr, kPtr),
+    MakeEntry(271, "ppoll", kPollFdArray, kLen0, kPtr, kPtr, kLen3),
+    MakeEntry(272, "unshare", kFlags),
+    MakeEntry(273, "set_robust_list", kPtr, kLen0),
+    MakeEntry(274, "get_robust_list", kPid, kPtr, kPtr),
+    MakeEntry(275, "splice", kResource, kPtr, kResource, kPtr, kInt, kFlags),
+    MakeEntry(276, "tee", kResource, kResource, kInt, kFlags),
+    MakeEntry(277, "sync_file_range", kResource, kInt, kInt, kFlags),
+    MakeEntry(278, "vmsplice", kResource, kArray, kLen1, kFlags),
+    MakeEntry(279, "move_pages", kPid, kLen2, kArray, kArray, kArray, kFlags),
+    MakeEntry(280, "utimensat", kResource, kPath, kPtr, kFlags),
+    MakeEntry(281, "epoll_pwait", kResource, kArray, kLen1, kInt, kPtr, kLen4),
+    MakeEntry(282, "signalfd", kResource, kPtr, kLen1),
+    MakeEntry(283, "timerfd_create", kFlags, kFlags),
     MakeEntry(284, "eventfd", kInt),
-    MakeEntry(285, "fallocate", kInt, kOct, kInt, kInt),
-    MakeEntry(286, "timerfd_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(287, "timerfd_gettime", kInt, kHex),
-    MakeEntry(288, "accept4", kInt, kHex, kHex, kInt),
-    MakeEntry(289, "signalfd4", kInt, kHex, kHex, kHex),
-    MakeEntry(290, "eventfd2", kInt, kHex),
-    MakeEntry(291, "epoll_create1", kHex),
-    MakeEntry(292, "dup3", kInt, kInt, kHex),
-    MakeEntry(293, "pipe2", kHex, kHex),
-    MakeEntry(294, "inotify_init1", kHex),
-    MakeEntry(295, "preadv", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(296, "pwritev", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(297, "rt_tgsigqueueinfo", kInt, kInt, kInt, kHex),
-    MakeEntry(298, "perf_event_open", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(299, "recvmmsg", kInt, kHex, kInt, kHex, kHex),
-    MakeEntry(300, "fanotify_init", kHex, kHex),
-    MakeEntry(301, "fanotify_mark", kInt, kHex, kHex, kInt, kPath),
-    MakeEntry(302, "prlimit64", kInt, kInt, kHex, kHex),
-    MakeEntry(303, "name_to_handle_at", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(304, "open_by_handle_at", kInt, kHex, kHex),
-    MakeEntry(305, "clock_adjtime", kInt, kHex),
-    MakeEntry(306, "syncfs", kInt),
-    MakeEntry(307, "sendmmsg", kInt, kHex, kInt, kHex),
-    MakeEntry(308, "setns", kInt, kHex),
-    MakeEntry(309, "getcpu", kHex, kHex, kHex),
-    MakeEntry(310, "process_vm_readv", kInt, kHex, kInt, kHex, kInt,
+    MakeEntry(285, "fallocate", kResource, kFlags, kInt, kInt),
+    MakeEntry(286, "timerfd_settime", kResource, kFlags, kPtr, kPtr),
+    MakeEntry(287, "timerfd_gettime", kResource, kPtr),
+    MakeEntry(288, "accept4", kResource, kPtr, kPtr, kFlags),
+    MakeEntry(289, "signalfd4", kResource, kPtr, kLen1, kFlags),
+    MakeEntry(290, "eventfd2", kInt, kFlags),
+    MakeEntry(291, "epoll_create1", kFlags),
+    MakeEntry(292, "dup3", kResource, kResource, kFlags),
+    MakeEntry(293, "pipe2", kPtr, kFlags),
+    MakeEntry(294, "inotify_init1", kFlags),
+    MakeEntry(295, "preadv", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(296, "pwritev", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(297, "rt_tgsigqueueinfo", kPid, kPid, kSignal, kPtr),
+    MakeEntry(298, "perf_event_open", kPtr, kPid, kInt, kResource, kFlags),
+    MakeEntry(299, "recvmmsg", kResource, kArray, kLen1, kFlags, kPtr),
+    MakeEntry(300, "fanotify_init", kFlags, kFlags),
+    MakeEntry(301, "fanotify_mark", kResource, kFlags, kFlags, kResource,
+              kPath),
+    MakeEntry(302, "prlimit64", kPid, kFlags, kPtr, kPtr),
+    MakeEntry(303, "name_to_handle_at", kResource, kPath, kPtr, kPtr, kFlags),
+    MakeEntry(304, "open_by_handle_at", kResource, kPtr, kFlags),
+    MakeEntry(305, "clock_adjtime", kFlags, kPtr),
+    MakeEntry(306, "syncfs", kResource),
+    MakeEntry(307, "sendmmsg", kResource, kArray, kLen1, kFlags),
+    MakeEntry(308, "setns", kResource, kFlags),
+    MakeEntry(309, "getcpu", kPtr, kPtr),
+    MakeEntry(310, "process_vm_readv", kPid, kArray, kLen1, kArray, kLen3,
               kInt),
-    MakeEntry(311, "process_vm_writev", kInt, kHex, kInt, kHex, kInt,
+    MakeEntry(311, "process_vm_writev", kPid, kArray, kLen1, kArray, kLen3,
               kInt),
-    MakeEntry(312, "kcmp", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(313, "finit_module", kInt, kString, kHex),
-    MakeEntry(314, "sched_setattr", kInt, kHex, kHex),
-    MakeEntry(315, "sched_getattr", kInt, kHex, kInt, kHex),
-    MakeEntry(316, "renameat2", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(317, "seccomp", kInt, kHex, kHex),
-    MakeEntry(318, "getrandom", kGen, kInt, kHex),
-    MakeEntry(319, "memfd_create", kString, kHex),
-    MakeEntry(320, "kexec_file_load", kInt, kInt, kInt, kString, kHex),
-    MakeEntry(321, "bpf", kInt, kHex, kInt),
-    MakeEntry(322, "execveat", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(323, "userfaultfd", kHex),
-    MakeEntry(324, "membarrier", kInt, kHex),
-    MakeEntry(325, "mlock2", kHex, kInt, kHex),
-    MakeEntry(326, "copy_file_range", kInt, kHex, kInt, kHex, kInt,
-              kHex),
-    MakeEntry(327, "preadv2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(328, "pwritev2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(329, "pkey_mprotect", kInt, kInt, kHex, kInt),
-    MakeEntry(330, "pkey_alloc", kInt, kInt),
+    MakeEntry(312, "kcmp", kPid, kPid, kFlags, kResource, kResource),
+    MakeEntry(313, "finit_module", kResource, kString, kFlags),
+    MakeEntry(314, "sched_setattr", kPid, kPtr, kInt),
+    MakeEntry(315, "sched_getattr", kPid, kPtr, kLen1, kInt),
+    MakeEntry(316, "renameat2", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(317, "seccomp", kInt, kFlags, kPtr),
+    MakeEntry(318, "getrandom", kArray, kLen0, kFlags),
+    MakeEntry(319, "memfd_create", kString, kFlags),
+    MakeEntry(320, "kexec_file_load", kInt, kInt, kInt, kString, kInt),
+    MakeEntry(321, "bpf", kInt, kPtr, kLen1),
+    MakeEntry(322, "execveat", kResource, kPath, kArray, kArray, kFlags),
+    MakeEntry(323, "userfaultfd", kFlags),
+    MakeEntry(324, "membarrier", kFlags, kInt),
+    MakeEntry(325, "mlock2", kPtr, kLen0, kFlags),
+    MakeEntry(326, "copy_file_range", kResource, kPtr, kResource, kPtr, kInt,
+              kFlags),
+    MakeEntry(327, "preadv2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(328, "pwritev2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(329, "pkey_mprotect", kPtr, kLen0, kFlags, kInt),
+    MakeEntry(330, "pkey_alloc", kInt, kFlags),
     MakeEntry(331, "pkey_free", kInt),
-    MakeEntry(332, "statx", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(333, "io_pgetevents", UnknownArguments()),
-    MakeEntry(334, "rseq", kHex, kInt, kHex, kHex),
-    MakeEntry(435, "clone3", kHex, kInt),
-    MakeEntry(436, "close_range", kInt, kInt, kHex),
-    MakeEntry(437, "openat2", kInt, kPath, kHex, kInt),
+    MakeEntry(332, "statx", kResource, kPath, kFlags, kFlags, kPtr),
+    MakeEntry(333, "io_pgetevents", kStruct, kInt, kLen3, kArray, kPtr, kPtr),
+    MakeEntry(334, "rseq", kPtr, kLen0, kFlags, kInt),
+    MakeEntry(435, "clone3", kPtr, kLen0),
+    MakeEntry(436, "close_range", kInt, kInt, kInt),
+    MakeEntry(437, "openat2", kInt, kPath, kInt, kInt),
     MakeEntry(438, "pidfd_getfd", UnknownArguments()),
-    MakeEntry(439, "faccessat2", kInt, kPath, kHex, kHex),
+    MakeEntry(439, "faccessat2", kInt, kPath, kInt, kInt),
     MakeEntry(440, "process_madvise", UnknownArguments()),
-    MakeEntry(441, "epoll_pwait2", UnknownArguments()),
+    MakeEntry(441, "epoll_pwait2", kResource, kArray, kLen1, kPtr, kPtr, kLen4),
     MakeEntry(442, "mount_setattr", UnknownArguments()),
     MakeEntry(443, "quotactl_fd", UnknownArguments()),
     MakeEntry(444, "landlock_create_ruleset", UnknownArguments()),
@@ -497,7 +576,7 @@ constexpr std::array kSyscallDataX8664 = {
     MakeEntry(449, "futex_waitv", UnknownArguments()),
     MakeEntry(450, "set_mempolicy_home_node", UnknownArguments()),
     MakeEntry(451, "cachestat", UnknownArguments()),
-    MakeEntry(452, "fchmodat2", kInt, kPath, kHex, kHex),
+    MakeEntry(452, "fchmodat2", kInt, kPath, kInt, kInt),
     MakeEntry(453, "map_shadow_stack", UnknownArguments()),
     MakeEntry(454, "futex_wake", UnknownArguments()),
     MakeEntry(455, "futex_wait", UnknownArguments()),
@@ -518,201 +597,201 @@ constexpr std::array kSyscallDataX8632 = {
     MakeEntry(0, "restart_syscall"),
     MakeEntry(1, "exit", kInt),
     MakeEntry(2, "fork"),
-    MakeEntry(3, "read", kInt, kHex, kInt),
-    MakeEntry(4, "write", kInt, kHex, kInt),
-    MakeEntry(5, "open", kPath, kHex, kOct),
-    MakeEntry(6, "close", kInt),
-    MakeEntry(7, "waitpid", kInt, kHex, kHex),
-    MakeEntry(8, "creat", kPath, kOct),
+    MakeEntry(3, "read", kResource, kArray, kLen1),
+    MakeEntry(4, "write", kResource, kArray, kLen1),
+    MakeEntry(5, "open", kPath, kFlags, kFlags),
+    MakeEntry(6, "close", kResource),
+    MakeEntry(7, "waitpid", kInt, kInt, kInt),
+    MakeEntry(8, "creat", kPath, kFlags),
     MakeEntry(9, "link", kPath, kPath),
     MakeEntry(10, "unlink", kPath),
-    MakeEntry(11, "execve", kPath, kHex, kHex),
+    MakeEntry(11, "execve", kPath, kArray, kArray),
     MakeEntry(12, "chdir", kPath),
-    MakeEntry(13, "time", kHex),
-    MakeEntry(14, "mknod", kPath, kOct, kHex),
-    MakeEntry(15, "chmod", kPath, kOct),
-    MakeEntry(16, "lchown", kPath, kInt, kInt),
+    MakeEntry(13, "time", kPtr),
+    MakeEntry(14, "mknod", kPath, kFlags, kInt),
+    MakeEntry(15, "chmod", kPath, kFlags),
+    MakeEntry(16, "lchown", kPath, kUid, kGid),
     MakeEntry(17, "break", UnknownArguments()),
     MakeEntry(18, "oldstat", UnknownArguments()),
-    MakeEntry(19, "lseek", kInt, kInt, kInt),
+    MakeEntry(19, "lseek", kResource, kInt, kFlags),
     MakeEntry(20, "getpid"),
-    MakeEntry(21, "mount", kPath, kPath, kString, kHex, kGen),
+    MakeEntry(21, "mount", kPtr, kPath, kString, kFlags, kString),
     MakeEntry(22, "umount", UnknownArguments()),
-    MakeEntry(23, "setuid", kInt),
+    MakeEntry(23, "setuid", kUid),
     MakeEntry(24, "getuid"),
     MakeEntry(25, "stime", UnknownArguments()),
-    MakeEntry(26, "ptrace", kHex, kHex, kHex, kHex),
+    MakeEntry(26, "ptrace", kFlags, kPid),
     MakeEntry(27, "alarm", kInt),
     MakeEntry(28, "oldfstat", UnknownArguments()),
     MakeEntry(29, "pause"),
-    MakeEntry(30, "utime", kPath, kHex),
+    MakeEntry(30, "utime", kPath, kPtr),
     MakeEntry(31, "stty", UnknownArguments()),
     MakeEntry(32, "gtty", UnknownArguments()),
-    MakeEntry(33, "access", kPath, kHex),
+    MakeEntry(33, "access", kPath, kInt),
     MakeEntry(34, "nice", UnknownArguments()),
     MakeEntry(35, "ftime", UnknownArguments()),
     MakeEntry(36, "sync"),
-    MakeEntry(37, "kill", kInt, kSignal),
+    MakeEntry(37, "kill", kPid, kSignal),
     MakeEntry(38, "rename", kPath, kPath),
-    MakeEntry(39, "mkdir", kPath, kOct),
+    MakeEntry(39, "mkdir", kPath, kFlags),
     MakeEntry(40, "rmdir", kPath),
-    MakeEntry(41, "dup", kInt),
-    MakeEntry(42, "pipe", kHex),
-    MakeEntry(43, "times", kHex),
+    MakeEntry(41, "dup", kResource),
+    MakeEntry(42, "pipe", kPtr),
+    MakeEntry(43, "times", kPtr),
     MakeEntry(44, "prof", UnknownArguments()),
     MakeEntry(45, "brk", kInt),
-    MakeEntry(46, "setgid", kInt),
+    MakeEntry(46, "setgid", kGid),
     MakeEntry(47, "getgid"),
     MakeEntry(48, "signal", UnknownArguments()),
     MakeEntry(49, "geteuid"),
     MakeEntry(50, "getegid"),
     MakeEntry(51, "acct", kPath),
-    MakeEntry(52, "umount2", kPath, kHex),
+    MakeEntry(52, "umount2", kPath, kFlags),
     MakeEntry(53, "lock", UnknownArguments()),
-    MakeEntry(54, "ioctl", kInt, kInt, kHex),
-    MakeEntry(55, "fcntl", kInt, kInt, kHex),
+    MakeEntry(54, "ioctl", kResource, kInt, kArray),
+    MakeEntry(55, "fcntl", kResource, kFlags, kResource),
     MakeEntry(56, "mpx", UnknownArguments()),
-    MakeEntry(57, "setpgid", kInt, kInt),
+    MakeEntry(57, "setpgid", kPid, kPid),
     MakeEntry(58, "ulimit", UnknownArguments()),
     MakeEntry(59, "oldolduname", UnknownArguments()),
-    MakeEntry(60, "umask", kHex),
+    MakeEntry(60, "umask", kFlags),
     MakeEntry(61, "chroot", kPath),
-    MakeEntry(62, "ustat", kHex, kHex),
-    MakeEntry(63, "dup2", kInt, kInt),
+    MakeEntry(62, "ustat", kInt, kPtr),
+    MakeEntry(63, "dup2", kResource, kResource),
     MakeEntry(64, "getppid"),
-    MakeEntry(65, "getpgrp"),
+    MakeEntry(65, "getpgrp", kPid),
     MakeEntry(66, "setsid"),
     MakeEntry(67, "sigaction", UnknownArguments()),
     MakeEntry(68, "sgetmask", UnknownArguments()),
     MakeEntry(69, "ssetmask", UnknownArguments()),
-    MakeEntry(70, "setreuid", kInt, kInt),
-    MakeEntry(71, "setregid", kInt, kInt),
+    MakeEntry(70, "setreuid", kUid, kUid),
+    MakeEntry(71, "setregid", kGid, kGid),
     MakeEntry(72, "sigsuspend", UnknownArguments()),
     MakeEntry(73, "sigpending", UnknownArguments()),
-    MakeEntry(74, "sethostname", kString, kInt),
-    MakeEntry(75, "setrlimit", kInt, kHex),
-    MakeEntry(76, "getrlimit", kInt, kHex),
-    MakeEntry(77, "getrusage", kInt, kHex),
-    MakeEntry(78, "gettimeofday", kHex, kHex),
-    MakeEntry(79, "settimeofday", kHex, kHex),
-    MakeEntry(80, "getgroups", kInt, kHex),
-    MakeEntry(81, "setgroups", kInt, kHex),
-    MakeEntry(82, "select", kInt, kHex, kHex, kHex, kHex),
+    MakeEntry(74, "sethostname", kString, kLen0),
+    MakeEntry(75, "setrlimit", kFlags, kPtr),
+    MakeEntry(76, "getrlimit", kFlags, kPtr),
+    MakeEntry(77, "getrusage", kFlags, kPtr),
+    MakeEntry(78, "gettimeofday", kPtr, kPtr),
+    MakeEntry(79, "settimeofday", kPtr, kPtr),
+    MakeEntry(80, "getgroups", kLen1, kGidArray),
+    MakeEntry(81, "setgroups", kLen1, kGidArray),
+    MakeEntry(82, "select", kLen1, kPtr, kPtr, kPtr, kPtr),
     MakeEntry(83, "symlink", kPath, kPath),
     MakeEntry(84, "oldlstat", UnknownArguments()),
-    MakeEntry(85, "readlink", kPath, kHex, kInt),
+    MakeEntry(85, "readlink", kPath, kArray, kLen1),
     MakeEntry(86, "uselib", kPath),
-    MakeEntry(87, "swapon", kPath, kHex),
-    MakeEntry(88, "reboot", kInt, kHex, kHex, kGen),
+    MakeEntry(87, "swapon", kPath, kFlags),
+    MakeEntry(88, "reboot", kInt, kInt, kInt, kPtr),
     MakeEntry(89, "readdir", UnknownArguments()),
-    MakeEntry(90, "mmap", kHex, kInt, kHex, kHex, kInt, kInt),
-    MakeEntry(91, "munmap", kHex, kInt),
+    MakeEntry(90, "mmap", kPtr, kLen0, kFlags, kFlags, kResource, kInt),
+    MakeEntry(91, "munmap", kPtr, kLen0),
     MakeEntry(92, "truncate", kPath, kInt),
-    MakeEntry(93, "ftruncate", kInt, kInt),
-    MakeEntry(94, "fchmod", kInt, kOct),
-    MakeEntry(95, "fchown", kInt, kInt, kInt),
-    MakeEntry(96, "getpriority", kInt, kInt),
-    MakeEntry(97, "setpriority", kInt, kInt, kInt),
+    MakeEntry(93, "ftruncate", kResource, kInt),
+    MakeEntry(94, "fchmod", kResource, kFlags),
+    MakeEntry(95, "fchown", kResource, kUid, kGid),
+    MakeEntry(96, "getpriority", kFlags, kPid),
+    MakeEntry(97, "setpriority", kFlags, kPid, kInt),
     MakeEntry(98, "profil", UnknownArguments()),
-    MakeEntry(99, "statfs", kPath, kHex),
-    MakeEntry(100, "fstatfs", kInt, kHex),
+    MakeEntry(99, "statfs", kPath, kArray),
+    MakeEntry(100, "fstatfs", kResource, kArray),
     MakeEntry(101, "ioperm", kInt, kInt, kInt),
     MakeEntry(102, "socketcall", UnknownArguments()),
-    MakeEntry(103, "syslog", kInt, kHex, kInt),
-    MakeEntry(104, "setitimer", kInt, kHex, kHex),
-    MakeEntry(105, "getitimer", kInt, kHex),
-    MakeEntry(106, "stat", kPath, kHex),
-    MakeEntry(107, "lstat", kPath, kHex),
-    MakeEntry(108, "fstat", kInt, kHex),
+    MakeEntry(103, "syslog", kFlags, kArray, kLen1),
+    MakeEntry(104, "setitimer", kFlags, kPtr, kPtr),
+    MakeEntry(105, "getitimer", kFlags, kPtr),
+    MakeEntry(106, "stat", kPath, kPtr),
+    MakeEntry(107, "lstat", kPath, kPtr),
+    MakeEntry(108, "fstat", kResource, kPtr),
     MakeEntry(109, "olduname", UnknownArguments()),
     MakeEntry(110, "iopl", kInt),
     MakeEntry(111, "vhangup"),
     MakeEntry(112, "idle", UnknownArguments()),
     MakeEntry(113, "vm86old", UnknownArguments()),
-    MakeEntry(114, "wait4", kInt, kHex, kHex, kHex),
+    MakeEntry(114, "wait4", kPid, kPtr, kFlags, kPtr),
     MakeEntry(115, "swapoff", kPath),
-    MakeEntry(116, "sysinfo", kHex),
+    MakeEntry(116, "sysinfo", kArray),
     MakeEntry(117, "ipc", UnknownArguments()),
-    MakeEntry(118, "fsync", kInt),
+    MakeEntry(118, "fsync", kResource),
     MakeEntry(119, "sigreturn", UnknownArguments()),
-    MakeEntry(120, "clone", kCloneFlag, kHex, kHex, kHex, kHex),
-    MakeEntry(121, "setdomainname", kString, kInt),
-    MakeEntry(122, "uname", kInt),
-    MakeEntry(123, "modify_ldt", kInt, kHex, kInt),
-    MakeEntry(124, "adjtimex", kHex),
-    MakeEntry(125, "mprotect", kHex, kInt, kHex),
+    MakeEntry(120, "clone", kFlags, kArray, kPtr, kPtr, kArray),
+    MakeEntry(121, "setdomainname", kString, kLen0),
+    MakeEntry(122, "uname", kArray),
+    MakeEntry(123, "modify_ldt", kInt, kPtr, kLen1),
+    MakeEntry(124, "adjtimex", kArray),
+    MakeEntry(125, "mprotect", kPtr, kLen0, kFlags),
     MakeEntry(126, "sigprocmask", UnknownArguments()),
     MakeEntry(127, "create_module", kString, kInt),
-    MakeEntry(128, "init_module", kGen, kInt, kString),
-    MakeEntry(129, "delete_module", kString, kHex),
-    MakeEntry(130, "get_kernel_syms", kHex),
+    MakeEntry(128, "init_module", kString, kLen0, kString),
+    MakeEntry(129, "delete_module", kString, kFlags),
+    MakeEntry(130, "get_kernel_syms", kInt),
     MakeEntry(131, "quotactl", kInt, kPath, kInt, kGen),
-    MakeEntry(132, "getpgid", kInt),
-    MakeEntry(133, "fchdir", kInt),
+    MakeEntry(132, "getpgid", kPid),
+    MakeEntry(133, "fchdir", kResource),
     MakeEntry(134, "bdflush", UnknownArguments()),
-    MakeEntry(135, "sysfs", kInt, kInt, kInt),
-    MakeEntry(136, "personality", kHex),
+    MakeEntry(135, "sysfs", kInt, kString),
+    MakeEntry(136, "personality", kFlags),
     MakeEntry(137, "afs_syscall", UnknownArguments()),
-    MakeEntry(138, "setfsuid", kInt),
-    MakeEntry(139, "setfsgid", kInt),
+    MakeEntry(138, "setfsuid", kUid),
+    MakeEntry(139, "setfsgid", kGid),
     MakeEntry(140, "_llseek", UnknownArguments()),
-    MakeEntry(141, "getdents", kInt, kHex, kInt),
+    MakeEntry(141, "getdents", kResource, kArray, kLen1),
     MakeEntry(142, "_newselect", UnknownArguments()),
-    MakeEntry(143, "flock", kInt, kInt),
-    MakeEntry(144, "msync", kHex, kInt, kInt),
-    MakeEntry(145, "readv", kInt, kHex, kInt),
-    MakeEntry(146, "writev", kInt, kHex, kInt),
-    MakeEntry(147, "getsid", kInt),
-    MakeEntry(148, "fdatasync", kInt),
-    MakeEntry(149, "_sysctl", kHex),
-    MakeEntry(150, "mlock", kInt, kInt),
-    MakeEntry(151, "munlock", kInt, kInt),
-    MakeEntry(152, "mlockall", kHex),
+    MakeEntry(143, "flock", kResource, kFlags),
+    MakeEntry(144, "msync", kPtr, kLen0, kFlags),
+    MakeEntry(145, "readv", kResource, kArray, kLen1),
+    MakeEntry(146, "writev", kResource, kArray, kLen1),
+    MakeEntry(147, "getsid", kPid),
+    MakeEntry(148, "fdatasync", kResource),
+    MakeEntry(149, "_sysctl", kPtr),
+    MakeEntry(150, "mlock", kPtr, kLen0),
+    MakeEntry(151, "munlock", kPtr, kLen0),
+    MakeEntry(152, "mlockall", kFlags),
     MakeEntry(153, "munlockall"),
-    MakeEntry(154, "sched_setparam", kInt, kHex),
-    MakeEntry(155, "sched_getparam", kInt, kHex),
-    MakeEntry(156, "sched_setscheduler", kInt, kInt, kHex),
-    MakeEntry(157, "sched_getscheduler", kInt),
+    MakeEntry(154, "sched_setparam", kPid, kPtr),
+    MakeEntry(155, "sched_getparam", kPid, kPtr),
+    MakeEntry(156, "sched_setscheduler", kPid, kFlags, kPtr),
+    MakeEntry(157, "sched_getscheduler", kPid),
     MakeEntry(158, "sched_yield"),
-    MakeEntry(159, "sched_get_priority_max", kHex),
-    MakeEntry(160, "sched_get_priority_min", kHex),
-    MakeEntry(161, "sched_rr_get_interval", kInt, kHex),
-    MakeEntry(162, "nanosleep", kHex, kHex),
-    MakeEntry(163, "mremap", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(164, "setresuid", kInt, kInt, kInt),
-    MakeEntry(165, "getresuid", kHex, kHex, kHex),
+    MakeEntry(159, "sched_get_priority_max", kInt),
+    MakeEntry(160, "sched_get_priority_min", kInt),
+    MakeEntry(161, "sched_rr_get_interval", kPid, kPtr),
+    MakeEntry(162, "nanosleep", kPtr, kPtr),
+    MakeEntry(163, "mremap", kPtr, kLen0, kLen4, kFlags, kPtr),
+    MakeEntry(164, "setresuid", kUid, kUid, kUid),
+    MakeEntry(165, "getresuid", kPtr, kPtr, kPtr),
     MakeEntry(166, "vm86", UnknownArguments()),
     MakeEntry(167, "query_module", kString, kInt, kGen, kInt, kGen),
-    MakeEntry(168, "poll", kGen, kInt, kInt),
-    MakeEntry(169, "nfsservctl", kInt, kGen, kGen),
-    MakeEntry(170, "setresgid", kInt, kInt, kInt),
-    MakeEntry(171, "getresgid", kHex, kHex, kHex),
-    MakeEntry(172, "prctl", kInt, kHex, kHex, kHex, kHex),
+    MakeEntry(168, "poll", kPollFdArray, kLen0, kInt),
+    MakeEntry(169, "nfsservctl", kInt, kPtr, kPtr),
+    MakeEntry(170, "setresgid", kGid, kGid, kGid),
+    MakeEntry(171, "getresgid", kPtr, kPtr, kPtr),
+    MakeEntry(172, "prctl", kInt, kInt, kInt, kInt, kInt),
     MakeEntry(173, "rt_sigreturn"),
-    MakeEntry(174, "rt_sigaction", kSignal, kHex, kHex, kInt),
-    MakeEntry(175, "rt_sigprocmask", kInt, kHex, kHex, kInt),
-    MakeEntry(176, "rt_sigpending", kHex, kInt),
-    MakeEntry(177, "rt_sigtimedwait", kHex, kHex, kHex, kInt),
-    MakeEntry(178, "rt_sigqueueinfo", kInt, kSignal, kHex),
-    MakeEntry(179, "rt_sigsuspend", kHex, kInt),
-    MakeEntry(180, "pread64", kInt, kHex, kInt, kInt),
-    MakeEntry(181, "pwrite64", kInt, kHex, kInt, kInt),
-    MakeEntry(182, "chown", kPath, kInt, kInt),
-    MakeEntry(183, "getcwd", kHex, kInt),
-    MakeEntry(184, "capget", kHex, kHex),
-    MakeEntry(185, "capset", kHex, kHex),
-    MakeEntry(186, "sigaltstack", kHex, kHex),
-    MakeEntry(187, "sendfile", kInt, kInt, kHex, kInt),
+    MakeEntry(174, "rt_sigaction", kSignal, kPtr, kPtr, kLen4, kPtr),
+    MakeEntry(175, "rt_sigprocmask", kFlags, kPtr, kPtr, kLen1),
+    MakeEntry(176, "rt_sigpending", kPtr, kLen0),
+    MakeEntry(177, "rt_sigtimedwait", kPtr, kPtr, kPtr, kLen0),
+    MakeEntry(178, "rt_sigqueueinfo", kPid, kSignal, kPtr),
+    MakeEntry(179, "rt_sigsuspend", kPtr, kLen0),
+    MakeEntry(180, "pread64", kResource, kArray, kLen1, kInt),
+    MakeEntry(181, "pwrite64", kResource, kArray, kLen1, kInt),
+    MakeEntry(182, "chown", kPath, kUid, kGid),
+    MakeEntry(183, "getcwd", kArray, kLen0),
+    MakeEntry(184, "capget", kPtr, kPtr),
+    MakeEntry(185, "capset", kPtr, kPtr),
+    MakeEntry(186, "sigaltstack", kPtr, kPtr),
+    MakeEntry(187, "sendfile", kResource, kResource, kPtr, kInt),
     MakeEntry(188, "getpmsg", UnknownArguments()),
     MakeEntry(189, "putpmsg", UnknownArguments()),
     MakeEntry(190, "vfork"),
     MakeEntry(191, "ugetrlimit", UnknownArguments()),
     MakeEntry(192, "mmap2", UnknownArguments()),
-    MakeEntry(193, "truncate64", kPath, kHex),
-    MakeEntry(194, "ftruncate64", kInt, kHex),
-    MakeEntry(195, "stat64", kPath, kHex),
-    MakeEntry(196, "lstat64", kPath, kHex),
-    MakeEntry(197, "fstat64", kInt, kHex),
+    MakeEntry(193, "truncate64", kPath, kInt),
+    MakeEntry(194, "ftruncate64", kInt, kInt),
+    MakeEntry(195, "stat64", kPath, kPtr),
+    MakeEntry(196, "lstat64", kPath, kPtr),
+    MakeEntry(197, "fstat64", kResource, kPtr),
     MakeEntry(198, "lchown32", kPath, kInt, kInt),
     MakeEntry(199, "getuid32", UnknownArguments()),
     MakeEntry(200, "getgid32", UnknownArguments()),
@@ -733,165 +812,168 @@ constexpr std::array kSyscallDataX8632 = {
     MakeEntry(215, "setfsuid32", UnknownArguments()),
     MakeEntry(216, "setfsgid32", UnknownArguments()),
     MakeEntry(217, "pivot_root", kPath, kPath),
-    MakeEntry(218, "mincore", kHex, kInt, kHex),
-    MakeEntry(219, "madvise", kHex, kInt, kInt),
-    MakeEntry(220, "getdents64", kInt, kHex, kInt),
+    MakeEntry(218, "mincore", kPtr, kLen0, kArray),
+    MakeEntry(219, "madvise", kPtr, kLen0, kFlags),
+    MakeEntry(220, "getdents64", kResource, kArray, kLen1),
     MakeEntry(221, "fcntl64", UnknownArguments()),
     MakeEntry(222, "unused1-222", UnknownArguments()),
     MakeEntry(223, "unused2-223", UnknownArguments()),
     MakeEntry(224, "gettid"),
-    MakeEntry(225, "readahead", kInt, kInt, kInt),
-    MakeEntry(226, "setxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(227, "lsetxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(228, "fsetxattr", kInt, kString, kGen, kInt, kHex),
-    MakeEntry(229, "getxattr", kPath, kString, kGen, kInt),
-    MakeEntry(230, "lgetxattr", kPath, kString, kGen, kInt),
-    MakeEntry(231, "fgetxattr", kInt, kString, kGen, kInt),
-    MakeEntry(232, "listxattr", kPath, kGen, kInt),
-    MakeEntry(233, "llistxattr", kPath, kGen, kInt),
-    MakeEntry(234, "flistxattr", kInt, kGen, kInt),
-    MakeEntry(235, "removexattr", kPath, kString),
-    MakeEntry(236, "lremovexattr", kPath, kString),
-    MakeEntry(237, "fremovexattr", kInt, kString),
-    MakeEntry(238, "tkill", kInt, kSignal),
-    MakeEntry(239, "sendfile64", UnknownArguments()),
-    MakeEntry(240, "futex", kGen, kInt, kInt, kGen, kGen, kInt),
-    MakeEntry(241, "sched_setaffinity", kInt, kInt, kHex),
-    MakeEntry(242, "sched_getaffinity", kInt, kInt, kHex),
-    MakeEntry(243, "set_thread_area", kHex),
-    MakeEntry(244, "get_thread_area", kHex),
-    MakeEntry(245, "io_setup", kInt, kHex),
-    MakeEntry(246, "io_destroy", kInt),
-    MakeEntry(247, "io_getevents", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(248, "io_submit", kInt, kInt, kHex),
-    MakeEntry(249, "io_cancel", kInt, kHex, kHex),
-    MakeEntry(250, "fadvise64", kInt, kInt, kInt, kInt),
+    MakeEntry(225, "readahead", kResource, kInt, kInt),
+    MakeEntry(226, "setxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(227, "lsetxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(228, "fsetxattr", kResource, kPtr, kString, kLen2, kFlags),
+    MakeEntry(229, "getxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(230, "lgetxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(231, "fgetxattr", kResource, kPtr, kArray, kLen2),
+    MakeEntry(232, "listxattr", kPath, kArray, kLen1),
+    MakeEntry(233, "llistxattr", kPath, kArray, kLen1),
+    MakeEntry(234, "flistxattr", kResource, kArray, kLen1),
+    MakeEntry(235, "removexattr", kPath, kPtr),
+    MakeEntry(236, "lremovexattr", kPath, kPtr),
+    MakeEntry(237, "fremovexattr", kResource, kPtr),
+    MakeEntry(238, "tkill", kPid, kSignal),
+    MakeEntry(239, "sendfile64", kResource, kResource, kPtr, kInt),
+    MakeEntry(240, "futex", kPtr, kFlags, kInt, kPtr, kPtr, kInt),
+    MakeEntry(241, "sched_setaffinity", kPid, kLen2, kPtr),
+    MakeEntry(242, "sched_getaffinity", kPid, kLen2, kPtr),
+    MakeEntry(243, "set_thread_area", kPtr),
+    MakeEntry(244, "get_thread_area", kPtr),
+    MakeEntry(245, "io_setup", kInt, kPtr),
+    MakeEntry(246, "io_destroy", kStruct),
+    MakeEntry(247, "io_getevents", kStruct, kInt, kLen3, kArray, kPtr),
+    MakeEntry(248, "io_submit", kStruct, kLen2, kArray),
+    MakeEntry(249, "io_cancel", kStruct, kPtr, kPtr),
+    MakeEntry(250, "fadvise64", kResource, kInt, kInt, kFlags),
     MakeEntry(251, "251-old_sys_set_zone_reclaim", UnknownArguments()),
     MakeEntry(252, "exit_group", kInt),
-    MakeEntry(253, "lookup_dcookie", kInt, kString, kInt),
+    MakeEntry(253, "lookup_dcookie", kInt, kArray, kLen1),
     MakeEntry(254, "epoll_create", kInt),
-    MakeEntry(255, "epoll_ctl", kInt, kInt, kInt, kHex),
-    MakeEntry(256, "epoll_wait", kInt, kHex, kInt, kInt),
-    MakeEntry(257, "remap_file_pages", kGen, kInt, kInt, kInt, kHex),
-    MakeEntry(258, "set_tid_address", kHex),
-    MakeEntry(259, "timer_create", kInt, kHex, kHex),
-    MakeEntry(260, "timer_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(261, "timer_gettime", kInt, kHex),
-    MakeEntry(262, "timer_getoverrun", kInt),
-    MakeEntry(263, "timer_delete", kInt),
-    MakeEntry(264, "clock_settime", kInt, kHex),
-    MakeEntry(265, "clock_gettime", kInt, kHex),
-    MakeEntry(266, "clock_getres", kInt, kHex),
-    MakeEntry(267, "clock_nanosleep", kInt, kHex, kHex, kHex),
+    MakeEntry(255, "epoll_ctl", kResource, kInt, kResource, kPtr),
+    MakeEntry(256, "epoll_wait", kResource, kArray, kLen1, kInt),
+    MakeEntry(257, "remap_file_pages", kPtr, kLen0, kFlags, kInt, kFlags),
+    MakeEntry(258, "set_tid_address", kPtr),
+    MakeEntry(259, "timer_create", kFlags, kPtr, kPtr),
+    MakeEntry(260, "timer_settime", kStruct, kFlags, kPtr, kPtr),
+    MakeEntry(261, "timer_gettime", kStruct, kPtr),
+    MakeEntry(262, "timer_getoverrun", kStruct),
+    MakeEntry(263, "timer_delete", kStruct),
+    MakeEntry(264, "clock_settime", kFlags, kPtr),
+    MakeEntry(265, "clock_gettime", kFlags, kPtr),
+    MakeEntry(266, "clock_getres", kFlags, kPtr),
+    MakeEntry(267, "clock_nanosleep", kFlags, kFlags, kPtr, kPtr),
     MakeEntry(268, "statfs64", UnknownArguments()),
     MakeEntry(269, "fstatfs64", UnknownArguments()),
-    MakeEntry(270, "tgkill", kInt, kInt, kSignal),
-    MakeEntry(271, "utimes", kPath, kHex),
+    MakeEntry(270, "tgkill", kPid, kPid, kSignal),
+    MakeEntry(271, "utimes", kPath, kPtr),
     MakeEntry(272, "fadvise64_64", UnknownArguments()),
     MakeEntry(273, "vserver", UnknownArguments()),
-    MakeEntry(274, "mbind", kGen, kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(275, "get_mempolicy", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(276, "set_mempolicy", kInt, kHex, kInt),
-    MakeEntry(277, "mq_open", kString, kHex, kOct, kHex),
+    MakeEntry(274, "mbind", kPtr, kLen0, kFlags, kPtr, kInt, kFlags),
+    MakeEntry(275, "get_mempolicy", kPtr, kPtr, kInt, kPtr, kFlags),
+    MakeEntry(276, "set_mempolicy", kFlags, kPtr, kInt),
+    MakeEntry(277, "mq_open", kString, kFlags, kFlags, kPtr),
     MakeEntry(278, "mq_unlink", kString),
-    MakeEntry(279, "mq_timedsend", kHex, kHex, kInt, kInt, kHex),
-    MakeEntry(280, "mq_timedreceive", kHex, kHex, kInt, kHex, kHex),
-    MakeEntry(281, "mq_notify", kHex, kHex),
-    MakeEntry(282, "mq_getsetattr", kHex, kHex, kHex),
-    MakeEntry(283, "kexec_load", kHex, kInt, kHex, kHex),
-    MakeEntry(284, "waitid", kInt, kInt, kHex, kInt, kHex),
+    MakeEntry(279, "mq_timedsend", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(280, "mq_timedreceive", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(281, "mq_notify", kResource, kPtr),
+    MakeEntry(282, "mq_getsetattr", kResource, kPtr, kPtr),
+    MakeEntry(283, "kexec_load", kInt, kLen2, kArray, kFlags),
+    MakeEntry(284, "waitid", kFlags, kPid, kPtr, kFlags, kPtr),
     MakeEntry(285, "285-old_sys_setaltroot", UnknownArguments()),
-    MakeEntry(286, "add_key", kString, kString, kGen, kInt, kInt),
-    MakeEntry(287, "request_key", kString, kString, kHex, kInt),
+    MakeEntry(286, "add_key", kString, kPtr, kArray, kLen2, kStruct),
+    MakeEntry(287, "request_key", kString, kPtr, kString, kStruct),
     MakeEntry(288, "keyctl", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(289, "ioprio_set", kInt, kInt, kInt),
-    MakeEntry(290, "ioprio_get", kInt, kInt),
+    MakeEntry(289, "ioprio_set", kFlags, kPid, kFlags),
+    MakeEntry(290, "ioprio_get", kFlags, kUid),
     MakeEntry(291, "inotify_init"),
-    MakeEntry(292, "inotify_add_watch", kInt, kPath, kHex),
-    MakeEntry(293, "inotify_rm_watch", kInt, kInt),
-    MakeEntry(294, "migrate_pages", kInt, kInt, kHex, kHex),
-    MakeEntry(295, "openat", kInt, kPath, kOct),
-    MakeEntry(296, "mkdirat", kInt, kPath, kOct),
-    MakeEntry(297, "mknodat", kInt, kPath, kOct, kHex),
-    MakeEntry(298, "fchownat", kInt, kPath, kInt, kInt, kHex),
-    MakeEntry(299, "futimesat", kInt, kPath, kHex),
-    MakeEntry(300, "fstatat64", UnknownArguments()),
-    MakeEntry(301, "unlinkat", kInt, kPath, kHex),
-    MakeEntry(302, "renameat", kInt, kPath, kInt, kPath),
-    MakeEntry(303, "linkat", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(304, "symlinkat", kPath, kInt, kPath),
-    MakeEntry(305, "readlinkat", kInt, kPath, kHex, kInt),
-    MakeEntry(306, "fchmodat", kInt, kPath, kOct, kHex),
-    MakeEntry(307, "faccessat", kInt, kPath, kHex, kHex),
-    MakeEntry(308, "pselect6", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(309, "ppoll", kHex, kInt, kHex, kHex, kInt),
-    MakeEntry(310, "unshare", kHex),
-    MakeEntry(311, "set_robust_list", kHex, kInt),
-    MakeEntry(312, "get_robust_list", kInt, kHex, kHex),
-    MakeEntry(313, "splice", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(314, "sync_file_range", kInt, kInt, kInt, kHex),
-    MakeEntry(315, "tee", kInt, kInt, kInt, kHex),
-    MakeEntry(316, "vmsplice", kInt, kHex, kInt, kInt),
-    MakeEntry(317, "move_pages", kInt, kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(318, "getcpu", kHex, kHex, kHex),
-    MakeEntry(319, "epoll_pwait", kInt, kHex, kInt, kInt, kHex, kInt),
-    MakeEntry(320, "utimensat", kInt, kPath, kHex, kHex),
-    MakeEntry(321, "signalfd", kInt, kHex, kHex),
-    MakeEntry(322, "timerfd_create", kInt, kHex),
+    MakeEntry(292, "inotify_add_watch", kResource, kPath, kFlags),
+    MakeEntry(293, "inotify_rm_watch", kResource, kResource),
+    MakeEntry(294, "migrate_pages", kPid, kInt, kPtr, kPtr),
+    MakeEntry(295, "openat", kResource, kPath, kFlags, kFlags),
+    MakeEntry(296, "mkdirat", kResource, kPath, kFlags),
+    MakeEntry(297, "mknodat", kResource, kPath, kFlags, kInt),
+    MakeEntry(298, "fchownat", kResource, kPath, kUid, kGid, kFlags),
+    MakeEntry(299, "futimesat", kResource, kPath, kPtr),
+    MakeEntry(300, "fstatat64", kInt, kPath, kPtr, kFlags),
+    MakeEntry(301, "unlinkat", kResource, kPath, kFlags),
+    MakeEntry(302, "renameat", kResource, kPath, kResource, kPath),
+    MakeEntry(303, "linkat", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(304, "symlinkat", kPath, kResource, kPath),
+    MakeEntry(305, "readlinkat", kResource, kPath, kArray, kLen2),
+    MakeEntry(306, "fchmodat", kResource, kPath, kFlags),
+    MakeEntry(307, "faccessat", kResource, kPath, kFlags),
+    MakeEntry(308, "pselect6", kLen1, kPtr, kPtr, kPtr, kPtr, kPtr),
+    MakeEntry(309, "ppoll", kPollFdArray, kLen0, kPtr, kPtr, kLen3),
+    MakeEntry(310, "unshare", kFlags),
+    MakeEntry(311, "set_robust_list", kPtr, kLen0),
+    MakeEntry(312, "get_robust_list", kPid, kPtr, kPtr),
+    MakeEntry(313, "splice", kResource, kPtr, kResource, kPtr, kInt, kFlags),
+    MakeEntry(314, "sync_file_range", kResource, kInt, kInt, kFlags),
+    MakeEntry(315, "tee", kResource, kResource, kInt, kFlags),
+    MakeEntry(316, "vmsplice", kResource, kArray, kLen1, kFlags),
+    MakeEntry(317, "move_pages", kPid, kLen2, kArray, kArray, kArray, kFlags),
+    MakeEntry(318, "getcpu", kPtr, kPtr),
+    MakeEntry(319, "epoll_pwait", kResource, kArray, kLen1, kInt, kPtr, kLen4),
+    MakeEntry(320, "utimensat", kResource, kPath, kPtr, kFlags),
+    MakeEntry(321, "signalfd", kResource, kPtr, kLen1),
+    MakeEntry(322, "timerfd_create", kFlags, kFlags),
     MakeEntry(323, "eventfd", kInt),
-    MakeEntry(324, "fallocate", kInt, kOct, kInt, kInt),
-    MakeEntry(325, "timerfd_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(326, "timerfd_gettime", kInt, kHex),
-    MakeEntry(327, "signalfd4", kInt, kHex, kHex, kHex),
-    MakeEntry(328, "eventfd2", kInt, kHex),
-    MakeEntry(329, "epoll_create1", kHex),
-    MakeEntry(330, "dup3", kInt, kInt, kHex),
-    MakeEntry(331, "pipe2", kHex, kHex),
-    MakeEntry(332, "inotify_init1", kHex),
-    MakeEntry(333, "preadv", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(334, "pwritev", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(335, "rt_tgsigqueueinfo", kInt, kInt, kInt, kHex),
-    MakeEntry(336, "perf_event_open", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(337, "recvmmsg", kInt, kHex, kInt, kHex, kHex),
-    MakeEntry(338, "fanotify_init", kHex, kHex),
-    MakeEntry(339, "fanotify_mark", kInt, kHex, kHex, kInt, kPath),
-    MakeEntry(340, "prlimit64", kInt, kInt, kHex, kHex),
-    MakeEntry(341, "name_to_handle_at", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(342, "open_by_handle_at", kInt, kHex, kHex),
-    MakeEntry(343, "clock_adjtime", kInt, kHex),
-    MakeEntry(344, "syncfs", kInt),
-    MakeEntry(345, "sendmmsg", kInt, kHex, kInt, kHex),
-    MakeEntry(346, "setns", kInt, kHex),
-    MakeEntry(347, "process_vm_readv", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(348, "process_vm_writev", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(349, "kcmp", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(350, "finit_module", kInt, kString, kHex),
-    MakeEntry(351, "sched_setattr", kInt, kHex, kHex),
-    MakeEntry(352, "sched_getattr", kInt, kHex, kInt, kHex),
-    MakeEntry(353, "renameat2", kHex, kPath, kHex, kPath, kHex, kHex),
-    MakeEntry(354, "seccomp", kInt, kHex, kHex),
-    MakeEntry(355, "getrandom", kGen, kInt, kHex),
-    MakeEntry(356, "memfd_create", kString, kHex),
-    MakeEntry(357, "bpf", kInt, kHex, kInt),
-    MakeEntry(435, "clone3", kHex, kInt),
-    MakeEntry(436, "close_range", kInt, kInt, kHex),
-    MakeEntry(437, "openat2", kInt, kPath, kHex, kInt),
-    MakeEntry(438, "pidfd_getfd", UnknownArguments()),
-    MakeEntry(439, "faccessat2", kInt, kPath, kHex, kHex),
-    MakeEntry(440, "process_madvise", UnknownArguments()),
-    MakeEntry(441, "epoll_pwait2", UnknownArguments()),
-    MakeEntry(442, "mount_setattr", UnknownArguments()),
+    MakeEntry(324, "fallocate", kResource, kFlags, kInt, kInt),
+    MakeEntry(325, "timerfd_settime", kResource, kFlags, kPtr, kPtr),
+    MakeEntry(326, "timerfd_gettime", kResource, kPtr),
+    MakeEntry(327, "signalfd4", kResource, kPtr, kLen1, kFlags),
+    MakeEntry(328, "eventfd2", kInt, kFlags),
+    MakeEntry(329, "epoll_create1", kFlags),
+    MakeEntry(330, "dup3", kResource, kResource, kFlags),
+    MakeEntry(331, "pipe2", kPtr, kFlags),
+    MakeEntry(332, "inotify_init1", kFlags),
+    MakeEntry(333, "preadv", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(334, "pwritev", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(335, "rt_tgsigqueueinfo", kPid, kPid, kSignal, kPtr),
+    MakeEntry(336, "perf_event_open", kPtr, kPid, kInt, kResource, kFlags),
+    MakeEntry(337, "recvmmsg", kResource, kArray, kLen1, kFlags, kPtr),
+    MakeEntry(338, "fanotify_init", kFlags, kFlags),
+    MakeEntry(339, "fanotify_mark", kResource, kFlags, kFlags, kResource,
+              kPath),
+    MakeEntry(340, "prlimit64", kPid, kFlags, kPtr, kPtr),
+    MakeEntry(341, "name_to_handle_at", kResource, kPath, kPtr, kPtr, kFlags),
+    MakeEntry(342, "open_by_handle_at", kResource, kPtr, kFlags),
+    MakeEntry(343, "clock_adjtime", kFlags, kPtr),
+    MakeEntry(344, "syncfs", kResource),
+    MakeEntry(345, "sendmmsg", kResource, kArray, kLen1, kFlags),
+    MakeEntry(346, "setns", kResource, kFlags),
+    MakeEntry(347, "process_vm_readv", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(348, "process_vm_writev", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(349, "kcmp", kPid, kPid, kFlags, kResource, kResource),
+    MakeEntry(350, "finit_module", kResource, kString, kFlags),
+    MakeEntry(351, "sched_setattr", kPid, kPtr, kInt),
+    MakeEntry(352, "sched_getattr", kPid, kPtr, kLen1, kInt),
+    MakeEntry(353, "renameat2", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(354, "seccomp", kInt, kFlags, kPtr),
+    MakeEntry(355, "getrandom", kArray, kLen0, kFlags),
+    MakeEntry(356, "memfd_create", kString, kFlags),
+    MakeEntry(357, "bpf", kInt, kPtr, kLen1),
+    MakeEntry(435, "clone3", kPtr, kLen0),
+    MakeEntry(436, "close_range", kResource, kResource, kFlags),
+    MakeEntry(437, "openat2", kResource, kPath, kPtr, kLen2),
+    MakeEntry(438, "pidfd_getfd", kResource, kResource, kInt),
+    MakeEntry(439, "faccessat2", kResource, kPath, kFlags, kFlags),
+    MakeEntry(440, "process_madvise", kResource, kArray, kLen1, kFlags, kInt),
+    MakeEntry(441, "epoll_pwait2", kResource, kArray, kLen1, kPtr, kPtr, kLen4),
+    MakeEntry(442, "mount_setattr", kResource, kPath, kFlags, kPtr, kLen3),
     MakeEntry(443, "quotactl_fd", UnknownArguments()),
-    MakeEntry(444, "landlock_create_ruleset", UnknownArguments()),
-    MakeEntry(445, "landlock_add_rule", UnknownArguments()),
-    MakeEntry(446, "landlock_restrict_self", UnknownArguments()),
-    MakeEntry(447, "memfd_secret", UnknownArguments()),
-    MakeEntry(448, "process_mrelease", UnknownArguments()),
-    MakeEntry(449, "futex_waitv", UnknownArguments()),
-    MakeEntry(450, "set_mempolicy_home_node", UnknownArguments()),
-    MakeEntry(451, "cachestat", UnknownArguments()),
-    MakeEntry(452, "fchmodat2", kInt, kPath, kHex, kHex),
-    MakeEntry(453, "map_shadow_stack", UnknownArguments()),
+    MakeEntry(444, "landlock_create_ruleset", kPtr, kLen0, kInt),
+    MakeEntry(445, "landlock_add_rule", kResource, kInt, kPtr, kInt),
+    MakeEntry(446, "landlock_restrict_self", kResource, kInt),
+    MakeEntry(447, "memfd_secret", kFlags),
+    MakeEntry(448, "process_mrelease", kResource, kInt),
+    MakeEntry(449, "futex_waitv", kArray, kLen0, kInt, kPtr, kFlags),
+    MakeEntry(450, "set_mempolicy_home_node", kPtr, kLen0, kInt, kInt),
+    MakeEntry(451, "cachestat", kResource, kPtr, kPtr, kInt),
+    MakeEntry(452, "fchmodat2", kInt, kPath, kInt, kInt),
+    MakeEntry(453, "map_shadow_stack", kPtr, kLen0, kFlags),
     MakeEntry(454, "futex_wake", UnknownArguments()),
     MakeEntry(455, "futex_wait", UnknownArguments()),
     MakeEntry(456, "futex_requeue", UnknownArguments()),
@@ -914,389 +996,395 @@ constexpr std::array kSyscallDataPPC64LE = {
     MakeEntry(0, "restart_syscall"),
     MakeEntry(1, "exit", kInt),
     MakeEntry(2, "fork"),
-    MakeEntry(3, "read", kInt, kHex, kInt),
-    MakeEntry(4, "write", kInt, kHex, kInt),
-    MakeEntry(5, "open", kPath, kHex, kOct),
-    MakeEntry(6, "close", kInt),
-    MakeEntry(7, "waitpid", kInt, kHex, kHex),
-    MakeEntry(8, "creat", kPath, kOct),
+    MakeEntry(3, "read", kResource, kArray, kLen1),
+    MakeEntry(4, "write", kResource, kArray, kLen1),
+    MakeEntry(5, "open", kPath, kFlags, kFlags),
+    MakeEntry(6, "close", kResource),
+    MakeEntry(7, "waitpid", kInt, kInt, kInt),
+    MakeEntry(8, "creat", kPath, kFlags),
     MakeEntry(9, "link", kPath, kPath),
     MakeEntry(10, "unlink", kPath),
-    MakeEntry(11, "execve", kPath, kHex, kHex),
+    MakeEntry(11, "execve", kPath, kArray, kArray),
     MakeEntry(12, "chdir", kPath),
-    MakeEntry(13, "time", kHex),
-    MakeEntry(14, "mknod", kPath, kOct, kHex),
-    MakeEntry(15, "chmod", kPath, kOct),
-    MakeEntry(16, "lchown", kPath, kInt, kInt),
+    MakeEntry(13, "time", kPtr),
+    MakeEntry(14, "mknod", kPath, kFlags, kInt),
+    MakeEntry(15, "chmod", kPath, kFlags),
+    MakeEntry(16, "lchown", kPath, kUid, kGid),
     MakeEntry(17, "break", UnknownArguments()),
     MakeEntry(18, "oldstat", UnknownArguments()),
-    MakeEntry(19, "lseek", kInt, kInt, kInt),
+    MakeEntry(19, "lseek", kResource, kInt, kFlags),
     MakeEntry(20, "getpid"),
-    MakeEntry(21, "mount", kPath, kPath, kString, kHex, kGen),
+    MakeEntry(21, "mount", kPtr, kPath, kString, kFlags, kString),
     MakeEntry(22, "umount", UnknownArguments()),
-    MakeEntry(23, "setuid", kInt),
+    MakeEntry(23, "setuid", kUid),
     MakeEntry(24, "getuid"),
     MakeEntry(25, "stime", UnknownArguments()),
-    MakeEntry(26, "ptrace", kInt, kInt, kHex, kHex),
+    MakeEntry(26, "ptrace", kFlags, kPid),
     MakeEntry(27, "alarm", kInt),
     MakeEntry(28, "oldfstat", UnknownArguments()),
     MakeEntry(29, "pause"),
-    MakeEntry(30, "utime", kPath, kHex),
+    MakeEntry(30, "utime", kPath, kPtr),
     MakeEntry(31, "stty", UnknownArguments()),
     MakeEntry(32, "gtty", UnknownArguments()),
-    MakeEntry(33, "access", kPath, kOct),
+    MakeEntry(33, "access", kPath, kFlags),
     MakeEntry(34, "nice", UnknownArguments()),
     MakeEntry(35, "ftime", UnknownArguments()),
     MakeEntry(36, "sync"),
-    MakeEntry(37, "kill", kInt, kSignal),
+    MakeEntry(37, "kill", kPid, kSignal),
     MakeEntry(38, "rename", kPath, kPath),
-    MakeEntry(39, "mkdir", kPath, kOct),
+    MakeEntry(39, "mkdir", kPath, kFlags),
     MakeEntry(40, "rmdir", kPath),
-    MakeEntry(41, "dup", kInt),
-    MakeEntry(42, "pipe", kHex),
-    MakeEntry(43, "times", kHex),
+    MakeEntry(41, "dup", kResource),
+    MakeEntry(42, "pipe", kPtr),
+    MakeEntry(43, "times", kPtr),
     MakeEntry(44, "prof", UnknownArguments()),
     MakeEntry(45, "brk", kInt),
-    MakeEntry(46, "setgid", kInt),
+    MakeEntry(46, "setgid", kGid),
     MakeEntry(47, "getgid"),
     MakeEntry(48, "signal", UnknownArguments()),
     MakeEntry(49, "geteuid"),
     MakeEntry(50, "getegid"),
     MakeEntry(51, "acct", kPath),
-    MakeEntry(52, "umount2", kPath, kHex),
+    MakeEntry(52, "umount2", kPath, kFlags),
     MakeEntry(53, "lock", UnknownArguments()),
-    MakeEntry(54, "ioctl", kInt, kInt, kHex),
-    MakeEntry(55, "fcntl", kInt, kInt, kHex),
+    MakeEntry(54, "ioctl", kResource, kInt, kArray),
+    MakeEntry(55, "fcntl", kResource, kFlags, kResource),
     MakeEntry(56, "mpx", UnknownArguments()),
-    MakeEntry(57, "setpgid", kInt, kInt),
+    MakeEntry(57, "setpgid", kPid, kPid),
     MakeEntry(58, "ulimit", UnknownArguments()),
     MakeEntry(59, "oldolduname", UnknownArguments()),
-    MakeEntry(60, "umask", kHex),
+    MakeEntry(60, "umask", kFlags),
     MakeEntry(61, "chroot", kPath),
-    MakeEntry(62, "ustat", kHex, kHex),
-    MakeEntry(63, "dup2", kInt, kInt),
+    MakeEntry(62, "ustat", kInt, kPtr),
+    MakeEntry(63, "dup2", kResource, kResource),
     MakeEntry(64, "getppid"),
-    MakeEntry(65, "getpgrp"),
+    MakeEntry(65, "getpgrp", kPid),
     MakeEntry(66, "setsid"),
     MakeEntry(67, "sigaction", UnknownArguments()),
     MakeEntry(68, "sgetmask", UnknownArguments()),
     MakeEntry(69, "ssetmask", UnknownArguments()),
-    MakeEntry(70, "setreuid", kInt, kInt),
-    MakeEntry(71, "setregid", kInt, kInt),
+    MakeEntry(70, "setreuid", kUid, kUid),
+    MakeEntry(71, "setregid", kGid, kGid),
     MakeEntry(72, "sigsuspend", UnknownArguments()),
     MakeEntry(73, "sigpending", UnknownArguments()),
-    MakeEntry(74, "sethostname", kString, kInt),
-    MakeEntry(75, "setrlimit", kInt, kHex),
-    MakeEntry(76, "getrlimit", kInt, kHex),
-    MakeEntry(77, "getrusage", kInt, kHex),
-    MakeEntry(78, "gettimeofday", kHex, kHex),
-    MakeEntry(79, "settimeofday", kHex, kHex),
-    MakeEntry(80, "getgroups", kInt, kHex),
-    MakeEntry(81, "setgroups", kInt, kHex),
-    MakeEntry(82, "select", kInt, kHex, kHex, kHex, kHex),
+    MakeEntry(74, "sethostname", kString, kLen0),
+    MakeEntry(75, "setrlimit", kFlags, kPtr),
+    MakeEntry(76, "getrlimit", kFlags, kPtr),
+    MakeEntry(77, "getrusage", kFlags, kPtr),
+    MakeEntry(78, "gettimeofday", kPtr, kPtr),
+    MakeEntry(79, "settimeofday", kPtr, kPtr),
+    MakeEntry(80, "getgroups", kLen1, kGidArray),
+    MakeEntry(81, "setgroups", kLen1, kGidArray),
+    MakeEntry(82, "select", kLen1, kPtr, kPtr, kPtr, kPtr),
     MakeEntry(83, "symlink", kPath, kPath),
     MakeEntry(84, "oldlstat", UnknownArguments()),
-    MakeEntry(85, "readlink", kPath, kHex, kInt),
+    MakeEntry(85, "readlink", kPath, kArray, kLen1),
     MakeEntry(86, "uselib", kPath),
-    MakeEntry(87, "swapon", kPath, kHex),
-    MakeEntry(88, "reboot", kInt, kHex, kHex, kGen),
+    MakeEntry(87, "swapon", kPath, kFlags),
+    MakeEntry(88, "reboot", kInt, kInt, kInt, kPtr),
     MakeEntry(89, "readdir", UnknownArguments()),
-    MakeEntry(90, "mmap", kHex, kInt, kHex, kHex, kInt, kInt),
-    MakeEntry(91, "munmap", kHex, kInt),
+    MakeEntry(90, "mmap", kPtr, kLen0, kFlags, kFlags, kResource, kInt),
+    MakeEntry(91, "munmap", kPtr, kLen0),
     MakeEntry(92, "truncate", kPath, kInt),
-    MakeEntry(93, "ftruncate", kInt, kInt),
-    MakeEntry(94, "fchmod", kInt, kOct),
-    MakeEntry(95, "fchown", kInt, kInt, kInt),
-    MakeEntry(96, "getpriority", kInt, kInt),
-    MakeEntry(97, "setpriority", kInt, kInt, kInt),
+    MakeEntry(93, "ftruncate", kResource, kInt),
+    MakeEntry(94, "fchmod", kResource, kFlags),
+    MakeEntry(95, "fchown", kResource, kUid, kGid),
+    MakeEntry(96, "getpriority", kFlags, kPid),
+    MakeEntry(97, "setpriority", kFlags, kPid, kInt),
     MakeEntry(98, "profil", UnknownArguments()),
-    MakeEntry(99, "statfs", kPath, kHex),
-    MakeEntry(100, "fstatfs", kInt, kHex),
+    MakeEntry(99, "statfs", kPath, kArray),
+    MakeEntry(100, "fstatfs", kResource, kArray),
     MakeEntry(101, "ioperm", kInt, kInt, kInt),
     MakeEntry(102, "socketcall", UnknownArguments()),
-    MakeEntry(103, "syslog", kInt, kHex, kInt),
-    MakeEntry(104, "setitimer", kInt, kHex, kHex),
-    MakeEntry(105, "getitimer", kInt, kHex),
-    MakeEntry(106, "stat", kPath, kGen),
-    MakeEntry(107, "lstat", kPath, kGen),
-    MakeEntry(108, "fstat", kInt, kHex),
+    MakeEntry(103, "syslog", kFlags, kArray, kLen1),
+    MakeEntry(104, "setitimer", kFlags, kPtr, kPtr),
+    MakeEntry(105, "getitimer", kFlags, kPtr),
+    MakeEntry(106, "stat", kPath, kPtr),
+    MakeEntry(107, "lstat", kPath, kPtr),
+    MakeEntry(108, "fstat", kResource, kPtr),
     MakeEntry(109, "olduname", UnknownArguments()),
     MakeEntry(110, "iopl", kInt),
     MakeEntry(111, "vhangup"),
     MakeEntry(112, "idle", UnknownArguments()),
     MakeEntry(113, "vm86", UnknownArguments()),
-    MakeEntry(114, "wait4", kInt, kHex, kHex, kHex),
+    MakeEntry(114, "wait4", kPid, kPtr, kFlags, kPtr),
     MakeEntry(115, "swapoff", kPath),
-    MakeEntry(116, "sysinfo", kHex),
+    MakeEntry(116, "sysinfo", kArray),
     MakeEntry(117, "ipc", UnknownArguments()),
-    MakeEntry(118, "fsync", kInt),
+    MakeEntry(118, "fsync", kResource),
     MakeEntry(119, "sigreturn", UnknownArguments()),
-    MakeEntry(120, "clone", kCloneFlag, kHex, kHex, kHex, kHex),
-    MakeEntry(121, "setdomainname", kString, kInt),
-    MakeEntry(122, "uname", kInt),
-    MakeEntry(123, "modify_ldt", kInt, kHex, kInt),
-    MakeEntry(124, "adjtimex", kHex),
-    MakeEntry(125, "mprotect", kHex, kInt, kHex),
+    MakeEntry(120, "clone", kFlags, kArray, kPtr, kPtr, kArray),
+    MakeEntry(121, "setdomainname", kString, kLen0),
+    MakeEntry(122, "uname", kArray),
+    MakeEntry(123, "modify_ldt", kInt, kPtr, kLen1),
+    MakeEntry(124, "adjtimex", kArray),
+    MakeEntry(125, "mprotect", kPtr, kLen0, kFlags),
     MakeEntry(126, "sigprocmask", UnknownArguments()),
     MakeEntry(127, "create_module", kString, kInt),
-    MakeEntry(128, "init_module", kGen, kInt, kString),
-    MakeEntry(129, "delete_module", kString, kHex),
-    MakeEntry(130, "get_kernel_syms", kHex),
+    MakeEntry(128, "init_module", kString, kLen0, kString),
+    MakeEntry(129, "delete_module", kString, kFlags),
+    MakeEntry(130, "get_kernel_syms", kInt),
     MakeEntry(131, "quotactl", kInt, kPath, kInt, kGen),
-    MakeEntry(132, "getpgid", kInt),
-    MakeEntry(133, "fchdir", kInt),
+    MakeEntry(132, "getpgid", kPid),
+    MakeEntry(133, "fchdir", kResource),
     MakeEntry(134, "bdflush", UnknownArguments()),
-    MakeEntry(135, "sysfs", kInt, kInt, kInt),
-    MakeEntry(136, "personality", kHex),
+    MakeEntry(135, "sysfs", kInt, kString),
+    MakeEntry(136, "personality", kFlags),
     MakeEntry(137, "afs_syscall", UnknownArguments()),
-    MakeEntry(138, "setfsuid", kInt),
-    MakeEntry(139, "setfsgid", kInt),
+    MakeEntry(138, "setfsuid", kUid),
+    MakeEntry(139, "setfsgid", kGid),
     MakeEntry(140, "_llseek", UnknownArguments()),
-    MakeEntry(141, "getdents", kInt, kHex, kInt),
+    MakeEntry(141, "getdents", kResource, kArray, kLen1),
     MakeEntry(142, "_newselect", UnknownArguments()),
-    MakeEntry(143, "flock", kInt, kInt),
-    MakeEntry(144, "msync", kHex, kInt, kInt),
-    MakeEntry(145, "readv", kInt, kHex, kInt),
-    MakeEntry(146, "writev", kInt, kHex, kInt),
-    MakeEntry(147, "getsid", kInt),
-    MakeEntry(148, "fdatasync", kInt),
-    MakeEntry(149, "_sysctl", kHex),
-    MakeEntry(150, "mlock", kInt, kInt),
-    MakeEntry(151, "munlock", kInt, kInt),
-    MakeEntry(152, "mlockall", kHex),
+    MakeEntry(143, "flock", kResource, kFlags),
+    MakeEntry(144, "msync", kPtr, kLen0, kFlags),
+    MakeEntry(145, "readv", kResource, kArray, kLen1),
+    MakeEntry(146, "writev", kResource, kArray, kLen1),
+    MakeEntry(147, "getsid", kPid),
+    MakeEntry(148, "fdatasync", kResource),
+    MakeEntry(149, "_sysctl", kPtr),
+    MakeEntry(150, "mlock", kPtr, kLen0),
+    MakeEntry(151, "munlock", kPtr, kLen0),
+    MakeEntry(152, "mlockall", kFlags),
     MakeEntry(153, "munlockall"),
-    MakeEntry(154, "sched_setparam", kInt, kHex),
-    MakeEntry(155, "sched_getparam", kInt, kHex),
-    MakeEntry(156, "sched_setscheduler", kInt, kInt, kHex),
-    MakeEntry(157, "sched_getscheduler", kInt),
+    MakeEntry(154, "sched_setparam", kPid, kPtr),
+    MakeEntry(155, "sched_getparam", kPid, kPtr),
+    MakeEntry(156, "sched_setscheduler", kPid, kFlags, kPtr),
+    MakeEntry(157, "sched_getscheduler", kPid),
     MakeEntry(158, "sched_yield"),
     MakeEntry(159, "sched_get_priority_max", kInt),
     MakeEntry(160, "sched_get_priority_min", kInt),
-    MakeEntry(161, "sched_rr_get_interval", kInt, kHex),
-    MakeEntry(162, "nanosleep", kHex, kHex),
-    MakeEntry(163, "mremap", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(164, "setresuid", kInt, kInt, kInt),
-    MakeEntry(165, "getresuid", kHex, kHex, kHex),
+    MakeEntry(161, "sched_rr_get_interval", kPid, kPtr),
+    MakeEntry(162, "nanosleep", kPtr, kPtr),
+    MakeEntry(163, "mremap", kPtr, kLen0, kLen4, kFlags, kPtr),
+    MakeEntry(164, "setresuid", kUid, kUid, kUid),
+    MakeEntry(165, "getresuid", kPtr, kPtr, kPtr),
     MakeEntry(166, "query_module", kString, kInt, kGen, kInt, kGen),
-    MakeEntry(167, "poll", kGen, kInt, kInt),
-    MakeEntry(168, "nfsservctl", kInt, kGen, kGen),
-    MakeEntry(169, "setresgid", kInt, kInt, kInt),
-    MakeEntry(170, "getresgid", kHex, kHex, kHex),
-    MakeEntry(171, "prctl", kInt, kHex, kHex, kHex, kHex),
+    MakeEntry(167, "poll", kPollFdArray, kLen0, kInt),
+    MakeEntry(168, "nfsservctl", kInt, kPtr, kPtr),
+    MakeEntry(169, "setresgid", kGid, kGid, kGid),
+    MakeEntry(170, "getresgid", kPtr, kPtr, kPtr),
+    MakeEntry(171, "prctl", kInt, kInt, kInt, kInt, kInt),
     MakeEntry(172, "rt_sigreturn"),
-    MakeEntry(173, "rt_sigaction", kSignal, kHex, kHex, kInt),
-    MakeEntry(174, "rt_sigprocmask", kInt, kHex, kHex, kInt),
-    MakeEntry(175, "rt_sigpending", kHex, kInt),
-    MakeEntry(176, "rt_sigtimedwait", kHex, kHex, kHex, kInt),
-    MakeEntry(177, "rt_sigqueueinfo", kInt, kSignal, kHex),
-    MakeEntry(178, "rt_sigsuspend", kHex, kInt),
-    MakeEntry(179, "pread64", kInt, kHex, kInt, kInt),
-    MakeEntry(180, "pwrite64", kInt, kHex, kInt, kInt),
-    MakeEntry(181, "chown", kPath, kInt, kInt),
-    MakeEntry(182, "getcwd", kHex, kInt),
-    MakeEntry(183, "capget", kHex, kHex),
-    MakeEntry(184, "capset", kHex, kHex),
-    MakeEntry(185, "sigaltstack", kHex, kHex),
-    MakeEntry(186, "sendfile", kInt, kInt, kHex, kInt),
+    MakeEntry(173, "rt_sigaction", kSignal, kPtr, kPtr, kLen4, kPtr),
+    MakeEntry(174, "rt_sigprocmask", kFlags, kPtr, kPtr, kLen1),
+    MakeEntry(175, "rt_sigpending", kPtr, kLen0),
+    MakeEntry(176, "rt_sigtimedwait", kPtr, kPtr, kPtr, kLen0),
+    MakeEntry(177, "rt_sigqueueinfo", kPid, kSignal, kPtr),
+    MakeEntry(178, "rt_sigsuspend", kPtr, kLen0),
+    MakeEntry(179, "pread64", kResource, kArray, kLen1, kInt),
+    MakeEntry(180, "pwrite64", kResource, kArray, kLen1, kInt),
+    MakeEntry(181, "chown", kPath, kUid, kGid),
+    MakeEntry(182, "getcwd", kArray, kLen0),
+    MakeEntry(183, "capget", kPtr, kPtr),
+    MakeEntry(184, "capset", kPtr, kPtr),
+    MakeEntry(185, "sigaltstack", kPtr, kPtr),
+    MakeEntry(186, "sendfile", kResource, kResource, kPtr, kInt),
     MakeEntry(187, "getpmsg", UnknownArguments()),
     MakeEntry(188, "putpmsg", UnknownArguments()),
     MakeEntry(189, "vfork"),
     MakeEntry(190, "ugetrlimit", UnknownArguments()),
-    MakeEntry(191, "readahead", kInt, kInt, kInt),
+    MakeEntry(191, "readahead", kResource, kInt, kInt),
     MakeEntry(192, "mmap2", UnknownArguments()),
     MakeEntry(193, "truncate64", UnknownArguments()),
     MakeEntry(194, "ftruncate64", UnknownArguments()),
-    MakeEntry(195, "stat64", UnknownArguments()),
-    MakeEntry(196, "lstat64", UnknownArguments()),
-    MakeEntry(197, "fstat64", UnknownArguments()),
+    MakeEntry(195, "stat64", kPath, kPtr),
+    MakeEntry(196, "lstat64", kPath, kPtr),
+    MakeEntry(197, "fstat64", kResource, kPtr),
     MakeEntry(198, "pciconfig_read", UnknownArguments()),
     MakeEntry(199, "pciconfig_write", UnknownArguments()),
     MakeEntry(200, "pciconfig_iobase", UnknownArguments()),
     MakeEntry(201, "multiplexer", UnknownArguments()),
-    MakeEntry(202, "getdents64", kInt, kHex, kInt),
+    MakeEntry(202, "getdents64", kResource, kArray, kLen1),
     MakeEntry(203, "pivot_root", kPath, kPath),
     MakeEntry(204, "fcntl64", UnknownArguments()),
-    MakeEntry(205, "madvise", kHex, kInt, kInt),
-    MakeEntry(206, "mincore", kHex, kInt, kHex),
+    MakeEntry(205, "madvise", kPtr, kLen0, kFlags),
+    MakeEntry(206, "mincore", kPtr, kLen0, kArray),
     MakeEntry(207, "gettid"),
-    MakeEntry(208, "tkill", kInt, kSignal),
-    MakeEntry(209, "setxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(210, "lsetxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(211, "fsetxattr", kInt, kString, kGen, kInt, kHex),
-    MakeEntry(212, "getxattr", kPath, kString, kGen, kInt),
-    MakeEntry(213, "lgetxattr", kPath, kString, kGen, kInt),
-    MakeEntry(214, "fgetxattr", kInt, kString, kGen, kInt),
-    MakeEntry(215, "listxattr", kPath, kGen, kInt),
-    MakeEntry(216, "llistxattr", kPath, kGen, kInt),
-    MakeEntry(217, "flistxattr", kInt, kGen, kInt),
-    MakeEntry(218, "removexattr", kPath, kString),
-    MakeEntry(219, "lremovexattr", kPath, kString),
-    MakeEntry(220, "fremovexattr", kInt, kString),
-    MakeEntry(221, "futex", kGen, kInt, kInt, kGen, kGen, kInt),
-    MakeEntry(222, "sched_setaffinity", kInt, kInt, kHex),
-    MakeEntry(223, "sched_getaffinity", kInt, kInt, kHex),
+    MakeEntry(208, "tkill", kPid, kSignal),
+    MakeEntry(209, "setxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(210, "lsetxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(211, "fsetxattr", kResource, kPtr, kString, kLen2, kFlags),
+    MakeEntry(212, "getxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(213, "lgetxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(214, "fgetxattr", kResource, kPtr, kArray, kLen2),
+    MakeEntry(215, "listxattr", kPath, kArray, kLen1),
+    MakeEntry(216, "llistxattr", kPath, kArray, kLen1),
+    MakeEntry(217, "flistxattr", kResource, kArray, kLen1),
+    MakeEntry(218, "removexattr", kPath, kPtr),
+    MakeEntry(219, "lremovexattr", kPath, kPtr),
+    MakeEntry(220, "fremovexattr", kResource, kPtr),
+    MakeEntry(221, "futex", kPtr, kFlags, kInt, kPtr, kPtr, kInt),
+    MakeEntry(222, "sched_setaffinity", kPid, kLen2, kPtr),
+    MakeEntry(223, "sched_getaffinity", kPid, kLen2, kPtr),
     MakeEntry(225, "tuxcall", UnknownArguments()),
-    MakeEntry(226, "sendfile64", UnknownArguments()),
-    MakeEntry(227, "io_setup", kInt, kHex),
-    MakeEntry(228, "io_destroy", kInt),
-    MakeEntry(229, "io_getevents", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(230, "io_submit", kInt, kInt, kHex),
-    MakeEntry(231, "io_cancel", kInt, kHex, kHex),
-    MakeEntry(232, "set_tid_address", kHex),
-    MakeEntry(233, "fadvise64", kInt, kInt, kInt, kInt),
+    MakeEntry(226, "sendfile64", kResource, kResource, kPtr, kInt),
+    MakeEntry(227, "io_setup", kInt, kPtr),
+    MakeEntry(228, "io_destroy", kStruct),
+    MakeEntry(229, "io_getevents", kStruct, kInt, kLen3, kArray, kPtr),
+    MakeEntry(230, "io_submit", kStruct, kLen2, kArray),
+    MakeEntry(231, "io_cancel", kStruct, kPtr, kPtr),
+    MakeEntry(232, "set_tid_address", kPtr),
+    MakeEntry(233, "fadvise64", kResource, kInt, kInt, kFlags),
     MakeEntry(234, "exit_group", kInt),
-    MakeEntry(235, "lookup_dcookie", kInt, kString, kInt),
+    MakeEntry(235, "lookup_dcookie", kInt, kArray, kLen1),
     MakeEntry(236, "epoll_create", kInt),
-    MakeEntry(237, "epoll_ctl", kInt, kInt, kInt, kHex),
-    MakeEntry(238, "epoll_wait", kInt, kHex, kInt, kInt),
-    MakeEntry(239, "remap_file_pages", kGen, kInt, kInt, kInt, kHex),
-    MakeEntry(240, "timer_create", kInt, kHex, kHex),
-    MakeEntry(241, "timer_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(242, "timer_gettime", kInt, kHex),
-    MakeEntry(243, "timer_getoverrun", kInt),
-    MakeEntry(244, "timer_delete", kInt),
-    MakeEntry(245, "clock_settime", kInt, kHex),
-    MakeEntry(246, "clock_gettime", kInt, kHex),
-    MakeEntry(247, "clock_getres", kInt, kHex),
-    MakeEntry(248, "clock_nanosleep", kInt, kHex, kHex, kHex),
+    MakeEntry(237, "epoll_ctl", kResource, kInt, kResource, kPtr),
+    MakeEntry(238, "epoll_wait", kResource, kArray, kLen1, kInt),
+    MakeEntry(239, "remap_file_pages", kPtr, kLen0, kFlags, kInt, kFlags),
+    MakeEntry(240, "timer_create", kFlags, kPtr, kPtr),
+    MakeEntry(241, "timer_settime", kStruct, kFlags, kPtr, kPtr),
+    MakeEntry(242, "timer_gettime", kStruct, kPtr),
+    MakeEntry(243, "timer_getoverrun", kStruct),
+    MakeEntry(244, "timer_delete", kStruct),
+    MakeEntry(245, "clock_settime", kFlags, kPtr),
+    MakeEntry(246, "clock_gettime", kFlags, kPtr),
+    MakeEntry(247, "clock_getres", kFlags, kPtr),
+    MakeEntry(248, "clock_nanosleep", kFlags, kFlags, kPtr, kPtr),
     MakeEntry(249, "swapcontext", UnknownArguments()),
-    MakeEntry(250, "tgkill", kInt, kInt, kSignal),
-    MakeEntry(251, "utimes", kPath, kHex),
+    MakeEntry(250, "tgkill", kPid, kPid, kSignal),
+    MakeEntry(251, "utimes", kPath, kPtr),
     MakeEntry(252, "statfs64", UnknownArguments()),
     MakeEntry(253, "fstatfs64", UnknownArguments()),
     MakeEntry(254, "fadvise64_64", UnknownArguments()),
     MakeEntry(255, "rtas", UnknownArguments()),
-    MakeEntry(256, "sys_debug_setcontext", kHex, kHex, kHex, kHex, kHex, kHex),
-    MakeEntry(258, "migrate_pages", kInt, kInt, kHex, kHex),
-    MakeEntry(259, "mbind", kGen, kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(260, "get_mempolicy", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(261, "set_mempolicy", kInt, kHex, kInt),
-    MakeEntry(262, "mq_open", kString, kHex, kOct, kHex),
+    MakeEntry(256, "sys_debug_setcontext", kInt, kInt, kInt, kInt, kInt, kInt),
+    MakeEntry(258, "migrate_pages", kPid, kInt, kPtr, kPtr),
+    MakeEntry(259, "mbind", kPtr, kLen0, kFlags, kPtr, kInt, kFlags),
+    MakeEntry(260, "get_mempolicy", kPtr, kPtr, kInt, kPtr, kFlags),
+    MakeEntry(261, "set_mempolicy", kFlags, kPtr, kInt),
+    MakeEntry(262, "mq_open", kString, kFlags, kFlags, kPtr),
     MakeEntry(263, "mq_unlink", kString),
-    MakeEntry(264, "mq_timedsend", kHex, kHex, kInt, kInt, kHex),
-    MakeEntry(265, "mq_timedreceive", kHex, kHex, kInt, kHex, kHex),
-    MakeEntry(266, "mq_notify", kHex, kHex),
-    MakeEntry(267, "mq_getsetattr", kHex, kHex, kHex),
-    MakeEntry(268, "kexec_load", kHex, kInt, kHex, kHex),
-    MakeEntry(269, "add_key", kString, kString, kGen, kInt, kInt),
-    MakeEntry(270, "request_key", kString, kString, kHex, kInt),
+    MakeEntry(264, "mq_timedsend", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(265, "mq_timedreceive", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(266, "mq_notify", kResource, kPtr),
+    MakeEntry(267, "mq_getsetattr", kResource, kPtr, kPtr),
+    MakeEntry(268, "kexec_load", kInt, kLen2, kArray, kFlags),
+    MakeEntry(269, "add_key", kString, kPtr, kArray, kLen2, kStruct),
+    MakeEntry(270, "request_key", kString, kPtr, kString, kStruct),
     MakeEntry(271, "keyctl", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(272, "waitid", kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(273, "ioprio_set", kInt, kInt, kInt),
-    MakeEntry(274, "ioprio_get", kInt, kInt),
+    MakeEntry(272, "waitid", kFlags, kPid, kPtr, kFlags, kPtr),
+    MakeEntry(273, "ioprio_set", kFlags, kPid, kFlags),
+    MakeEntry(274, "ioprio_get", kFlags, kUid),
     MakeEntry(275, "inotify_init"),
-    MakeEntry(276, "inotify_add_watch", kInt, kPath, kHex),
-    MakeEntry(277, "inotify_rm_watch", kInt, kInt),
+    MakeEntry(276, "inotify_add_watch", kResource, kPath, kFlags),
+    MakeEntry(277, "inotify_rm_watch", kResource, kResource),
     MakeEntry(278, "spu_run", UnknownArguments()),
     MakeEntry(279, "spu_create", UnknownArguments()),
-    MakeEntry(280, "pselect6", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(281, "ppoll", kHex, kInt, kHex, kHex, kInt),
-    MakeEntry(282, "unshare", kHex),
-    MakeEntry(283, "splice", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(284, "tee", kInt, kInt, kInt, kHex),
-    MakeEntry(285, "vmsplice", kInt, kHex, kInt, kInt),
-    MakeEntry(286, "openat", kInt, kPath, kHex, kOct),
-    MakeEntry(287, "mkdirat", kInt, kPath, kOct),
-    MakeEntry(288, "mknodat", kInt, kPath, kOct, kHex),
-    MakeEntry(289, "fchownat", kInt, kPath, kInt, kInt, kHex),
-    MakeEntry(290, "futimesat", kInt, kPath, kHex),
-    MakeEntry(291, "newfstatat", kInt, kPath, kHex, kHex),
-    MakeEntry(292, "unlinkat", kInt, kPath, kHex),
-    MakeEntry(293, "renameat", kInt, kPath, kInt, kPath),
-    MakeEntry(294, "linkat", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(295, "symlinkat", kPath, kInt, kPath),
-    MakeEntry(296, "readlinkat", kInt, kPath, kHex, kInt),
-    MakeEntry(297, "fchmodat", kInt, kPath, kOct),
-    MakeEntry(298, "faccessat", kInt, kPath, kInt, kHex),
-    MakeEntry(299, "get_robust_list", kInt, kHex, kHex),
-    MakeEntry(300, "set_robust_list", kHex, kInt),
-    MakeEntry(301, "move_pages", kInt, kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(302, "getcpu", kHex, kHex, kHex),
-    MakeEntry(303, "epoll_pwait", kInt, kHex, kInt, kInt, kHex, kInt),
-    MakeEntry(304, "utimensat", kInt, kPath, kHex, kHex),
-    MakeEntry(305, "signalfd", kInt, kHex, kHex),
-    MakeEntry(306, "timerfd_create", kInt, kHex),
+    MakeEntry(280, "pselect6", kLen1, kPtr, kPtr, kPtr, kPtr, kPtr),
+    MakeEntry(281, "ppoll", kPollFdArray, kLen0, kPtr, kPtr, kLen3),
+    MakeEntry(282, "unshare", kFlags),
+    MakeEntry(283, "splice", kResource, kPtr, kResource, kPtr, kInt, kFlags),
+    MakeEntry(284, "tee", kResource, kResource, kInt, kFlags),
+    MakeEntry(285, "vmsplice", kResource, kArray, kLen1, kFlags),
+    MakeEntry(286, "openat", kResource, kPath, kFlags, kFlags),
+    MakeEntry(287, "mkdirat", kResource, kPath, kFlags),
+    MakeEntry(288, "mknodat", kResource, kPath, kFlags, kInt),
+    MakeEntry(289, "fchownat", kResource, kPath, kUid, kGid, kFlags),
+    MakeEntry(290, "futimesat", kResource, kPath, kPtr),
+    MakeEntry(291, "newfstatat", kInt, kPath, kPtr, kFlags),
+    MakeEntry(292, "unlinkat", kResource, kPath, kFlags),
+    MakeEntry(293, "renameat", kResource, kPath, kResource, kPath),
+    MakeEntry(294, "linkat", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(295, "symlinkat", kPath, kResource, kPath),
+    MakeEntry(296, "readlinkat", kResource, kPath, kArray, kLen2),
+    MakeEntry(297, "fchmodat", kResource, kPath, kFlags),
+    MakeEntry(298, "faccessat", kResource, kPath, kFlags),
+    MakeEntry(299, "get_robust_list", kPid, kPtr, kPtr),
+    MakeEntry(300, "set_robust_list", kPtr, kLen0),
+    MakeEntry(301, "move_pages", kPid, kLen2, kArray, kArray, kArray, kFlags),
+    MakeEntry(302, "getcpu", kPtr, kPtr),
+    MakeEntry(303, "epoll_pwait", kResource, kArray, kLen1, kInt, kPtr, kLen4),
+    MakeEntry(304, "utimensat", kResource, kPath, kPtr, kFlags),
+    MakeEntry(305, "signalfd", kResource, kPtr, kLen1),
+    MakeEntry(306, "timerfd_create", kFlags, kFlags),
     MakeEntry(307, "eventfd", kInt),
     MakeEntry(308, "sync_file_range2", UnknownArguments()),
-    MakeEntry(309, "fallocate", kInt, kOct, kInt, kInt),
+    MakeEntry(309, "fallocate", kResource, kFlags, kInt, kInt),
     MakeEntry(310, "subpage_prot", UnknownArguments()),
-    MakeEntry(311, "timerfd_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(312, "timerfd_gettime", kInt, kHex),
-    MakeEntry(313, "signalfd4", kInt, kHex, kHex, kHex),
-    MakeEntry(314, "eventfd2", kInt, kHex),
-    MakeEntry(315, "epoll_create1", kHex),
-    MakeEntry(316, "dup3", kInt, kInt, kHex),
-    MakeEntry(317, "pipe2", kHex, kHex),
-    MakeEntry(318, "inotify_init1", kHex),
-    MakeEntry(319, "perf_event_open", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(320, "preadv", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(321, "pwritev", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(322, "rt_tgsigqueueinfo", kInt, kInt, kInt, kHex),
-    MakeEntry(323, "fanotify_init", kHex, kHex, kInt, kGen, kGen, kGen),
-    MakeEntry(324, "fanotify_mark", kInt, kHex, kHex, kInt, kPath),
-    MakeEntry(325, "prlimit64", kInt, kInt, kHex, kHex),
-    MakeEntry(326, "socket", kAddressFamily, kInt, kInt),
-    MakeEntry(327, "bind", kInt, kSockaddr, kInt),
-    MakeEntry(328, "connect", kInt, kSockaddr, kInt),
-    MakeEntry(329, "listen", kInt, kInt),
-    MakeEntry(330, "accept", kInt, kSockaddr, kHex),
-    MakeEntry(331, "getsockname", kInt, kSockaddr, kHex),
-    MakeEntry(332, "getpeername", kInt, kSockaddr, kHex),
-    MakeEntry(333, "socketpair", kAddressFamily, kInt, kInt, kHex),
+    MakeEntry(311, "timerfd_settime", kResource, kFlags, kPtr, kPtr),
+    MakeEntry(312, "timerfd_gettime", kResource, kPtr),
+    MakeEntry(313, "signalfd4", kResource, kPtr, kLen1, kFlags),
+    MakeEntry(314, "eventfd2", kInt, kFlags),
+    MakeEntry(315, "epoll_create1", kFlags),
+    MakeEntry(316, "dup3", kResource, kResource, kFlags),
+    MakeEntry(317, "pipe2", kPtr, kFlags),
+    MakeEntry(318, "inotify_init1", kFlags),
+    MakeEntry(319, "perf_event_open", kPtr, kPid, kInt, kResource, kFlags),
+    MakeEntry(320, "preadv", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(321, "pwritev", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(322, "rt_tgsigqueueinfo", kPid, kPid, kSignal, kPtr),
+    MakeEntry(323, "fanotify_init", kFlags, kFlags),
+    MakeEntry(324, "fanotify_mark", kResource, kFlags, kFlags, kResource,
+              kPath),
+    MakeEntry(325, "prlimit64", kPid, kFlags, kPtr, kPtr),
+    MakeEntry(326, "socket", kFlags, kFlags, kInt),
+    MakeEntry(327, "bind", kResource, kSockaddr, kLen1),
+    MakeEntry(328, "connect", kResource, kSockaddr, kLen1),
+    MakeEntry(329, "listen", kResource, kInt),
+    MakeEntry(330, "accept", kResource, kPtr, kPtr),
+    MakeEntry(331, "getsockname", kResource, kPtr, kPtr),
+    MakeEntry(332, "getpeername", kResource, kPtr, kPtr),
+    MakeEntry(333, "socketpair", kFlags, kFlags, kInt, kPtr),
     MakeEntry(334, "send", UnknownArguments()),
-    MakeEntry(335, "sendto", kInt, kGen, kInt, kHex, kSockaddr, kInt),
+    MakeEntry(335, "sendto", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
     MakeEntry(336, "recv", UnknownArguments()),
-    MakeEntry(337, "recvfrom", kInt, kHex, kInt, kHex, kSockaddr, kHex),
-    MakeEntry(338, "shutdown", kInt, kInt),
-    MakeEntry(339, "setsockopt", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(340, "getsockopt", kInt, kInt, kInt, kHex, kInt),
-    MakeEntry(341, "sendmsg", kInt, kSockmsghdr, kHex),
-    MakeEntry(342, "recvmsg", kInt, kHex, kInt),
-    MakeEntry(343, "recvmmsg", kInt, kHex, kInt, kHex, kHex),
-    MakeEntry(344, "accept4", kInt, kHex, kHex, kInt),
-    MakeEntry(345, "name_to_handle_at", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(346, "open_by_handle_at", kInt, kHex, kHex),
-    MakeEntry(347, "clock_adjtime", kInt, kHex),
-    MakeEntry(348, "syncfs", kInt),
-    MakeEntry(349, "sendmmsg", kInt, kHex, kInt, kHex),
-    MakeEntry(350, "setns", kInt, kHex),
-    MakeEntry(351, "process_vm_readv", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(352, "process_vm_writev", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(353, "finit_module", kInt, kString, kHex),
-    MakeEntry(354, "kcmp", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(355, "sched_setattr", kInt, kHex, kHex),
-    MakeEntry(356, "sched_getattr", kInt, kHex, kInt, kHex),
-    MakeEntry(357, "renameat2", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(358, "seccomp", kInt, kHex, kHex),
-    MakeEntry(359, "getrandom", kGen, kInt, kHex),
-    MakeEntry(360, "memfd_create", kString, kHex),
-    MakeEntry(361, "bpf", kInt, kHex, kInt),
-    MakeEntry(362, "execveat", kInt, kPath, kHex, kHex, kHex),
+    MakeEntry(337, "recvfrom", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
+    MakeEntry(338, "shutdown", kResource, kFlags),
+    MakeEntry(339, "setsockopt", kResource, kInt, kInt, kArray, kLen3),
+    MakeEntry(340, "getsockopt", kResource, kInt, kInt, kArray, kPtr),
+    MakeEntry(341, "sendmsg", kResource, kPtr, kFlags),
+    MakeEntry(342, "recvmsg", kResource, kPtr, kFlags),
+    MakeEntry(343, "recvmmsg", kResource, kArray, kLen1, kFlags, kPtr),
+    MakeEntry(344, "accept4", kResource, kPtr, kPtr, kFlags),
+    MakeEntry(345, "name_to_handle_at", kResource, kPath, kPtr, kPtr, kFlags),
+    MakeEntry(346, "open_by_handle_at", kResource, kPtr, kFlags),
+    MakeEntry(347, "clock_adjtime", kFlags, kPtr),
+    MakeEntry(348, "syncfs", kResource),
+    MakeEntry(349, "sendmmsg", kResource, kArray, kLen1, kFlags),
+    MakeEntry(350, "setns", kResource, kFlags),
+    MakeEntry(351, "process_vm_readv", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(352, "process_vm_writev", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(353, "finit_module", kResource, kString, kFlags),
+    MakeEntry(354, "kcmp", kPid, kPid, kFlags, kResource, kResource),
+    MakeEntry(355, "sched_setattr", kPid, kPtr, kInt),
+    MakeEntry(356, "sched_getattr", kPid, kPtr, kLen1, kInt),
+    MakeEntry(357, "renameat2", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(358, "seccomp", kInt, kFlags, kPtr),
+    MakeEntry(359, "getrandom", kArray, kLen0, kFlags),
+    MakeEntry(360, "memfd_create", kString, kFlags),
+    MakeEntry(361, "bpf", kInt, kPtr, kLen1),
+    MakeEntry(362, "execveat", kResource, kPath, kArray, kArray, kFlags),
     MakeEntry(363, "switch_endian", UnknownArguments()),
-    MakeEntry(364, "userfaultfd", kHex),
-    MakeEntry(365, "membarrier", kInt, kHex),
-    MakeEntry(378, "mlock2", kHex, kInt, kHex),
-    MakeEntry(379, "copy_file_range", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(380, "preadv2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(381, "pwritev2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(435, "clone3", kHex, kInt),
-    MakeEntry(436, "close_range", kInt, kInt, kHex),
-    MakeEntry(437, "openat2", kInt, kPath, kHex, kInt),
-    MakeEntry(438, "pidfd_getfd", UnknownArguments()),
-    MakeEntry(439, "faccessat2", kInt, kPath, kHex, kHex),
-    MakeEntry(440, "process_madvise", UnknownArguments()),
-    MakeEntry(441, "epoll_pwait2", UnknownArguments()),
-    MakeEntry(442, "mount_setattr", UnknownArguments()),
+    MakeEntry(364, "userfaultfd", kFlags),
+    MakeEntry(365, "membarrier", kFlags, kInt),
+    MakeEntry(378, "mlock2", kPtr, kLen0, kFlags),
+    MakeEntry(379, "copy_file_range", kResource, kPtr, kResource, kPtr, kInt,
+              kFlags),
+    MakeEntry(380, "preadv2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(381, "pwritev2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(435, "clone3", kPtr, kLen0),
+    MakeEntry(436, "close_range", kResource, kResource, kFlags),
+    MakeEntry(437, "openat2", kResource, kPath, kPtr, kLen2),
+    MakeEntry(438, "pidfd_getfd", kResource, kResource, kInt),
+    MakeEntry(439, "faccessat2", kResource, kPath, kFlags, kFlags),
+    MakeEntry(440, "process_madvise", kResource, kArray, kLen1, kFlags, kInt),
+    MakeEntry(441, "epoll_pwait2", kResource, kArray, kLen1, kPtr, kPtr, kLen4),
+    MakeEntry(442, "mount_setattr", kResource, kPath, kFlags, kPtr, kLen3),
     MakeEntry(443, "quotactl_fd", UnknownArguments()),
-    MakeEntry(444, "landlock_create_ruleset", UnknownArguments()),
-    MakeEntry(445, "landlock_add_rule", UnknownArguments()),
-    MakeEntry(446, "landlock_restrict_self", UnknownArguments()),
-    MakeEntry(448, "process_mrelease", UnknownArguments()),
-    MakeEntry(449, "futex_waitv", UnknownArguments()),
-    MakeEntry(450, "set_mempolicy_home_node", UnknownArguments()),
-    MakeEntry(451, "cachestat", UnknownArguments()),
-    MakeEntry(452, "fchmodat2", kInt, kPath, kHex, kHex),
-    MakeEntry(453, "map_shadow_stack", UnknownArguments()),
+    MakeEntry(444, "landlock_create_ruleset", kPtr, kLen0, kInt),
+    MakeEntry(445, "landlock_add_rule", kResource, kInt, kPtr, kInt),
+    MakeEntry(446, "landlock_restrict_self", kResource, kInt),
+    MakeEntry(448, "process_mrelease", kResource, kInt),
+    MakeEntry(449, "futex_waitv", kArray, kLen0, kInt, kPtr, kFlags),
+    MakeEntry(450, "set_mempolicy_home_node", kPtr, kLen0, kInt, kInt),
+    MakeEntry(451, "cachestat", kResource, kPtr, kPtr, kInt),
+    MakeEntry(452, "fchmodat2", kInt, kPath, kInt, kInt),
+    MakeEntry(453, "map_shadow_stack", kPtr, kLen0, kFlags),
     MakeEntry(454, "futex_wake", UnknownArguments()),
     MakeEntry(455, "futex_wait", UnknownArguments()),
     MakeEntry(456, "futex_requeue", UnknownArguments()),
@@ -1314,178 +1402,178 @@ static_assert(IsSorted(kSyscallDataPPC64LE, SyscallTable::Entry::BySyscallNr),
 // https://github.com/torvalds/linux/blob/v5.8/include/uapi/asm-generic/unistd.h
 constexpr std::array kSyscallDataArm64 = {
     // clang-format off
-    MakeEntry(0, "io_setup", kInt, kHex),
-    MakeEntry(1, "io_destroy", kInt),
-    MakeEntry(2, "io_submit", kInt, kInt, kHex),
-    MakeEntry(3, "io_cancel", kInt, kHex, kHex),
-    MakeEntry(4, "io_getevents", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(5, "setxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(6, "lsetxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(7, "fsetxattr", kInt, kString, kGen, kInt, kHex),
-    MakeEntry(8, "getxattr", kPath, kString, kGen, kInt),
-    MakeEntry(9, "lgetxattr", kPath, kString, kGen, kInt),
-    MakeEntry(10, "fgetxattr", kInt, kString, kGen, kInt),
-    MakeEntry(11, "listxattr", kPath, kGen, kInt),
-    MakeEntry(12, "llistxattr", kPath, kGen, kInt),
-    MakeEntry(13, "flistxattr", kInt, kGen, kInt),
-    MakeEntry(14, "removexattr", kPath, kString),
-    MakeEntry(15, "lremovexattr", kPath, kString),
-    MakeEntry(16, "fremovexattr", kInt, kString),
-    MakeEntry(17, "getcwd", kHex, kInt),
-    MakeEntry(18, "lookup_dcookie", kInt, kString, kInt),
-    MakeEntry(19, "eventfd2", kInt, kHex),
-    MakeEntry(20, "epoll_create1", kHex),
-    MakeEntry(21, "epoll_ctl", kInt, kInt, kInt, kHex),
-    MakeEntry(22, "epoll_pwait", kInt, kHex, kInt, kInt, kHex, kInt),
-    MakeEntry(23, "dup", kInt),
-    MakeEntry(24, "dup3", kInt, kInt, kHex),
-    MakeEntry(25, "fcntl", kInt, kInt, kHex),
-    MakeEntry(26, "inotify_init1", kHex),
-    MakeEntry(27, "inotify_add_watch", kInt, kPath, kHex),
-    MakeEntry(28, "inotify_rm_watch", kInt, kInt),
-    MakeEntry(29, "ioctl", kInt, kInt, kHex),
-    MakeEntry(30, "ioprio_set", kInt, kInt, kInt),
-    MakeEntry(31, "ioprio_get", kInt, kInt),
-    MakeEntry(32, "flock", kInt, kInt),
-    MakeEntry(33, "mknodat", kInt, kPath, kOct, kHex),
-    MakeEntry(34, "mkdirat", kInt, kPath, kOct),
-    MakeEntry(35, "unlinkat", kInt, kPath, kHex),
-    MakeEntry(36, "symlinkat", kPath, kInt, kPath),
-    MakeEntry(37, "linkat", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(38, "renameat", kInt, kPath, kInt, kPath),
-    MakeEntry(39, "umount2", kPath, kHex),
-    MakeEntry(40, "mount", kPath, kPath, kString, kHex, kGen),
+    MakeEntry(0, "io_setup", kInt, kPtr),
+    MakeEntry(1, "io_destroy", kStruct),
+    MakeEntry(2, "io_submit", kStruct, kLen2, kArray),
+    MakeEntry(3, "io_cancel", kStruct, kPtr, kPtr),
+    MakeEntry(4, "io_getevents", kStruct, kInt, kLen3, kArray, kPtr),
+    MakeEntry(5, "setxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(6, "lsetxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(7, "fsetxattr", kResource, kPtr, kString, kLen2, kFlags),
+    MakeEntry(8, "getxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(9, "lgetxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(10, "fgetxattr", kResource, kPtr, kArray, kLen2),
+    MakeEntry(11, "listxattr", kPath, kArray, kLen1),
+    MakeEntry(12, "llistxattr", kPath, kArray, kLen1),
+    MakeEntry(13, "flistxattr", kResource, kArray, kLen1),
+    MakeEntry(14, "removexattr", kPath, kPtr),
+    MakeEntry(15, "lremovexattr", kPath, kPtr),
+    MakeEntry(16, "fremovexattr", kResource, kPtr),
+    MakeEntry(17, "getcwd", kArray, kLen0),
+    MakeEntry(18, "lookup_dcookie", kInt, kArray, kLen1),
+    MakeEntry(19, "eventfd2", kInt, kFlags),
+    MakeEntry(20, "epoll_create1", kFlags),
+    MakeEntry(21, "epoll_ctl", kResource, kInt, kResource, kPtr),
+    MakeEntry(22, "epoll_pwait", kResource, kArray, kLen1, kInt, kPtr, kLen4),
+    MakeEntry(23, "dup", kResource),
+    MakeEntry(24, "dup3", kResource, kResource, kFlags),
+    MakeEntry(25, "fcntl", kResource, kFlags, kResource),
+    MakeEntry(26, "inotify_init1", kFlags),
+    MakeEntry(27, "inotify_add_watch", kResource, kPath, kFlags),
+    MakeEntry(28, "inotify_rm_watch", kResource, kResource),
+    MakeEntry(29, "ioctl", kResource, kInt, kArray),
+    MakeEntry(30, "ioprio_set", kFlags, kPid, kFlags),
+    MakeEntry(31, "ioprio_get", kFlags, kUid),
+    MakeEntry(32, "flock", kResource, kFlags),
+    MakeEntry(33, "mknodat", kResource, kPath, kFlags, kInt),
+    MakeEntry(34, "mkdirat", kResource, kPath, kFlags),
+    MakeEntry(35, "unlinkat", kResource, kPath, kFlags),
+    MakeEntry(36, "symlinkat", kPath, kResource, kPath),
+    MakeEntry(37, "linkat", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(38, "renameat", kResource, kPath, kResource, kPath),
+    MakeEntry(39, "umount2", kPath, kFlags),
+    MakeEntry(40, "mount", kPtr, kPath, kString, kFlags, kString),
     MakeEntry(41, "pivot_root", kPath, kPath),
-    MakeEntry(42, "nfsservctl", kInt, kGen, kGen),
-    MakeEntry(43, "statfs", kPath, kHex),
-    MakeEntry(44, "fstatfs", kInt, kHex),
+    MakeEntry(42, "nfsservctl", kInt, kPtr, kPtr),
+    MakeEntry(43, "statfs", kPath, kArray),
+    MakeEntry(44, "fstatfs", kResource, kArray),
     MakeEntry(45, "truncate", kPath, kInt),
-    MakeEntry(46, "ftruncate", kInt, kInt),
-    MakeEntry(47, "fallocate", kInt, kOct, kInt, kInt),
-    MakeEntry(48, "faccessat", kInt, kPath, kHex, kHex),
+    MakeEntry(46, "ftruncate", kResource, kInt),
+    MakeEntry(47, "fallocate", kResource, kFlags, kInt, kInt),
+    MakeEntry(48, "faccessat", kResource, kPath, kFlags),
     MakeEntry(49, "chdir", kPath),
-    MakeEntry(50, "fchdir", kInt),
+    MakeEntry(50, "fchdir", kResource),
     MakeEntry(51, "chroot", kPath),
-    MakeEntry(52, "fchmod", kInt, kOct),
-    MakeEntry(53, "fchmodat", kInt, kPath, kOct, kHex),
-    MakeEntry(54, "fchownat", kInt, kPath, kInt, kInt, kHex),
-    MakeEntry(55, "fchown", kInt, kInt, kInt),
-    MakeEntry(56, "openat", kGen, kPath, kOct, kHex, kGen, kGen),
-    MakeEntry(57, "close", kInt),
+    MakeEntry(52, "fchmod", kResource, kFlags),
+    MakeEntry(53, "fchmodat", kResource, kPath, kFlags),
+    MakeEntry(54, "fchownat", kResource, kPath, kUid, kGid, kFlags),
+    MakeEntry(55, "fchown", kResource, kUid, kGid),
+    MakeEntry(56, "openat", kResource, kPath, kFlags, kFlags),
+    MakeEntry(57, "close", kResource),
     MakeEntry(58, "vhangup"),
-    MakeEntry(59, "pipe2", kHex, kHex),
+    MakeEntry(59, "pipe2", kPtr, kFlags),
     MakeEntry(60, "quotactl", kInt, kPath, kInt, kGen),
-    MakeEntry(61, "getdents64", kInt, kHex, kInt),
-    MakeEntry(62, "lseek", kInt, kInt, kInt),
-    MakeEntry(63, "read", kInt, kHex, kInt),
-    MakeEntry(64, "write", kInt, kHex, kInt),
-    MakeEntry(65, "readv", kInt, kHex, kInt),
-    MakeEntry(66, "writev", kInt, kHex, kInt),
-    MakeEntry(67, "pread64", kInt, kHex, kInt, kInt),
-    MakeEntry(68, "pwrite64", kInt, kHex, kInt, kInt),
-    MakeEntry(69, "preadv", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(70, "pwritev", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(71, "sendfile", kInt, kInt, kHex, kInt),
-    MakeEntry(72, "pselect6", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(73, "ppoll", kHex, kInt, kHex, kHex, kInt),
-    MakeEntry(74, "signalfd4", kInt, kHex, kHex, kHex),
-    MakeEntry(75, "vmsplice", kInt, kHex, kInt, kInt),
-    MakeEntry(76, "splice", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(77, "tee", kInt, kInt, kInt, kHex),
-    MakeEntry(78, "readlinkat", kInt, kPath, kHex, kInt),
-    MakeEntry(79, "newfstatat", kInt, kPath, kHex, kHex),
-    MakeEntry(80, "fstat", kInt, kHex),
+    MakeEntry(61, "getdents64", kResource, kArray, kLen1),
+    MakeEntry(62, "lseek", kResource, kInt, kFlags),
+    MakeEntry(63, "read", kResource, kArray, kLen1),
+    MakeEntry(64, "write", kResource, kArray, kLen1),
+    MakeEntry(65, "readv", kResource, kArray, kLen1),
+    MakeEntry(66, "writev", kResource, kArray, kLen1),
+    MakeEntry(67, "pread64", kResource, kArray, kLen1, kInt),
+    MakeEntry(68, "pwrite64", kResource, kArray, kLen1, kInt),
+    MakeEntry(69, "preadv", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(70, "pwritev", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(71, "sendfile", kResource, kResource, kPtr, kInt),
+    MakeEntry(72, "pselect6", kLen1, kPtr, kPtr, kPtr, kPtr, kPtr),
+    MakeEntry(73, "ppoll", kPollFdArray, kLen0, kPtr, kPtr, kLen3),
+    MakeEntry(74, "signalfd4", kResource, kPtr, kLen1, kFlags),
+    MakeEntry(75, "vmsplice", kResource, kArray, kLen1, kFlags),
+    MakeEntry(76, "splice", kResource, kPtr, kResource, kPtr, kInt, kFlags),
+    MakeEntry(77, "tee", kResource, kResource, kInt, kFlags),
+    MakeEntry(78, "readlinkat", kResource, kPath, kArray, kLen2),
+    MakeEntry(79, "newfstatat", kInt, kPath, kPtr, kFlags),
+    MakeEntry(80, "fstat", kResource, kPtr),
     MakeEntry(81, "sync"),
-    MakeEntry(82, "fsync", kInt),
-    MakeEntry(83, "fdatasync", kInt),
-    MakeEntry(84, "sync_file_range", kInt, kInt, kInt, kHex),
-    MakeEntry(85, "timerfd_create", kInt, kHex),
-    MakeEntry(86, "timerfd_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(87, "timerfd_gettime", kInt, kHex),
-    MakeEntry(88, "utimensat", kInt, kPath, kHex, kHex),
+    MakeEntry(82, "fsync", kResource),
+    MakeEntry(83, "fdatasync", kResource),
+    MakeEntry(84, "sync_file_range", kResource, kInt, kInt, kFlags),
+    MakeEntry(85, "timerfd_create", kFlags, kFlags),
+    MakeEntry(86, "timerfd_settime", kResource, kFlags, kPtr, kPtr),
+    MakeEntry(87, "timerfd_gettime", kResource, kPtr),
+    MakeEntry(88, "utimensat", kResource, kPath, kPtr, kFlags),
     MakeEntry(89, "acct", kPath),
-    MakeEntry(90, "capget", kHex, kHex),
-    MakeEntry(91, "capset", kHex, kHex),
-    MakeEntry(92, "personality", kHex),
+    MakeEntry(90, "capget", kPtr, kPtr),
+    MakeEntry(91, "capset", kPtr, kPtr),
+    MakeEntry(92, "personality", kFlags),
     MakeEntry(93, "exit", kInt),
     MakeEntry(94, "exit_group", kInt),
-    MakeEntry(95, "waitid", kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(96, "set_tid_address", kHex),
-    MakeEntry(97, "unshare", kHex),
-    MakeEntry(98, "futex", kGen, kInt, kInt, kGen, kGen, kInt),
-    MakeEntry(99, "set_robust_list", kHex, kInt),
-    MakeEntry(100, "get_robust_list", kInt, kHex, kHex),
-    MakeEntry(101, "nanosleep", kHex, kHex),
-    MakeEntry(102, "getitimer", kInt, kHex),
-    MakeEntry(103, "setitimer", kInt, kHex, kHex),
-    MakeEntry(104, "kexec_load", kHex, kInt, kHex, kHex),
-    MakeEntry(105, "init_module", kGen, kInt, kString),
-    MakeEntry(106, "delete_module", kString, kHex),
-    MakeEntry(107, "timer_create", kInt, kHex, kHex),
-    MakeEntry(108, "timer_gettime", kInt, kHex),
-    MakeEntry(109, "timer_getoverrun", kInt),
-    MakeEntry(110, "timer_settime", kInt, kHex, kHex, kHex),
-    MakeEntry(111, "timer_delete", kInt),
-    MakeEntry(112, "clock_settime", kInt, kHex),
-    MakeEntry(113, "clock_gettime", kInt, kHex),
-    MakeEntry(114, "clock_getres", kInt, kHex),
-    MakeEntry(115, "clock_nanosleep", kInt, kHex, kHex, kHex),
-    MakeEntry(116, "syslog", kInt, kHex, kInt),
-    MakeEntry(117, "ptrace", kHex, kHex, kHex, kHex),
-    MakeEntry(118, "sched_setparam", kInt, kHex),
-    MakeEntry(119, "sched_setscheduler", kInt, kInt, kHex),
-    MakeEntry(120, "sched_getscheduler", kInt),
-    MakeEntry(121, "sched_getparam", kInt, kHex),
-    MakeEntry(122, "sched_setaffinity", kInt, kInt, kHex),
-    MakeEntry(123, "sched_getaffinity", kInt, kInt, kHex),
+    MakeEntry(95, "waitid", kFlags, kPid, kPtr, kFlags, kPtr),
+    MakeEntry(96, "set_tid_address", kPtr),
+    MakeEntry(97, "unshare", kFlags),
+    MakeEntry(98, "futex", kPtr, kFlags, kInt, kPtr, kPtr, kInt),
+    MakeEntry(99, "set_robust_list", kPtr, kLen0),
+    MakeEntry(100, "get_robust_list", kPid, kPtr, kPtr),
+    MakeEntry(101, "nanosleep", kPtr, kPtr),
+    MakeEntry(102, "getitimer", kFlags, kPtr),
+    MakeEntry(103, "setitimer", kFlags, kPtr, kPtr),
+    MakeEntry(104, "kexec_load", kInt, kLen2, kArray, kFlags),
+    MakeEntry(105, "init_module", kString, kLen0, kString),
+    MakeEntry(106, "delete_module", kString, kFlags),
+    MakeEntry(107, "timer_create", kFlags, kPtr, kPtr),
+    MakeEntry(108, "timer_gettime", kStruct, kPtr),
+    MakeEntry(109, "timer_getoverrun", kStruct),
+    MakeEntry(110, "timer_settime", kStruct, kFlags, kPtr, kPtr),
+    MakeEntry(111, "timer_delete", kStruct),
+    MakeEntry(112, "clock_settime", kFlags, kPtr),
+    MakeEntry(113, "clock_gettime", kFlags, kPtr),
+    MakeEntry(114, "clock_getres", kFlags, kPtr),
+    MakeEntry(115, "clock_nanosleep", kFlags, kFlags, kPtr, kPtr),
+    MakeEntry(116, "syslog", kFlags, kArray, kLen1),
+    MakeEntry(117, "ptrace", kFlags, kPid),
+    MakeEntry(118, "sched_setparam", kPid, kPtr),
+    MakeEntry(119, "sched_setscheduler", kPid, kFlags, kPtr),
+    MakeEntry(120, "sched_getscheduler", kPid),
+    MakeEntry(121, "sched_getparam", kPid, kPtr),
+    MakeEntry(122, "sched_setaffinity", kPid, kLen2, kPtr),
+    MakeEntry(123, "sched_getaffinity", kPid, kLen2, kPtr),
     MakeEntry(124, "sched_yield"),
-    MakeEntry(125, "sched_get_priority_max", kHex),
-    MakeEntry(126, "sched_get_priority_min", kHex),
-    MakeEntry(127, "sched_rr_get_interval", kInt, kHex),
+    MakeEntry(125, "sched_get_priority_max", kInt),
+    MakeEntry(126, "sched_get_priority_min", kInt),
+    MakeEntry(127, "sched_rr_get_interval", kPid, kPtr),
     MakeEntry(128, "restart_syscall"),
-    MakeEntry(129, "kill", kInt, kSignal),
-    MakeEntry(130, "tkill", kInt, kSignal),
-    MakeEntry(131, "tgkill", kInt, kInt, kSignal),
-    MakeEntry(132, "sigaltstack", kHex, kHex),
-    MakeEntry(133, "rt_sigsuspend", kHex, kInt),
-    MakeEntry(134, "rt_sigaction", kSignal, kHex, kHex, kInt),
-    MakeEntry(135, "rt_sigprocmask", kInt, kHex, kHex, kInt),
-    MakeEntry(136, "rt_sigpending", kHex, kInt),
-    MakeEntry(137, "rt_sigtimedwait", kHex, kHex, kHex, kInt),
-    MakeEntry(138, "rt_sigqueueinfo", kInt, kSignal, kHex),
+    MakeEntry(129, "kill", kPid, kSignal),
+    MakeEntry(130, "tkill", kPid, kSignal),
+    MakeEntry(131, "tgkill", kPid, kPid, kSignal),
+    MakeEntry(132, "sigaltstack", kPtr, kPtr),
+    MakeEntry(133, "rt_sigsuspend", kPtr, kLen0),
+    MakeEntry(134, "rt_sigaction", kSignal, kPtr, kPtr, kLen4, kPtr),
+    MakeEntry(135, "rt_sigprocmask", kFlags, kPtr, kPtr, kLen1),
+    MakeEntry(136, "rt_sigpending", kPtr, kLen0),
+    MakeEntry(137, "rt_sigtimedwait", kPtr, kPtr, kPtr, kLen0),
+    MakeEntry(138, "rt_sigqueueinfo", kPid, kSignal, kPtr),
     MakeEntry(139, "rt_sigreturn"),
-    MakeEntry(140, "setpriority", kInt, kInt, kInt),
-    MakeEntry(141, "getpriority", kInt, kInt),
-    MakeEntry(142, "reboot", kInt, kHex, kHex, kGen),
-    MakeEntry(143, "setregid", kInt, kInt),
-    MakeEntry(144, "setgid", kInt),
-    MakeEntry(145, "setreuid", kInt, kInt),
-    MakeEntry(146, "setuid", kInt),
-    MakeEntry(147, "setresuid", kInt, kInt, kInt),
-    MakeEntry(148, "getresuid", kHex, kHex, kHex),
-    MakeEntry(149, "setresgid", kInt, kInt, kInt),
-    MakeEntry(150, "getresgid", kHex, kHex, kHex),
-    MakeEntry(151, "setfsuid", kInt),
-    MakeEntry(152, "setfsgid", kInt),
-    MakeEntry(153, "times", kHex),
-    MakeEntry(154, "setpgid", kInt, kInt),
-    MakeEntry(155, "getpgid", kInt),
-    MakeEntry(156, "getsid", kInt),
+    MakeEntry(140, "setpriority", kFlags, kPid, kInt),
+    MakeEntry(141, "getpriority", kFlags, kPid),
+    MakeEntry(142, "reboot", kInt, kInt, kInt, kPtr),
+    MakeEntry(143, "setregid", kGid, kGid),
+    MakeEntry(144, "setgid", kGid),
+    MakeEntry(145, "setreuid", kUid, kUid),
+    MakeEntry(146, "setuid", kUid),
+    MakeEntry(147, "setresuid", kUid, kUid, kUid),
+    MakeEntry(148, "getresuid", kPtr, kPtr, kPtr),
+    MakeEntry(149, "setresgid", kGid, kGid, kGid),
+    MakeEntry(150, "getresgid", kPtr, kPtr, kPtr),
+    MakeEntry(151, "setfsuid", kUid),
+    MakeEntry(152, "setfsgid", kGid),
+    MakeEntry(153, "times", kPtr),
+    MakeEntry(154, "setpgid", kPid, kPid),
+    MakeEntry(155, "getpgid", kPid),
+    MakeEntry(156, "getsid", kPid),
     MakeEntry(157, "setsid"),
-    MakeEntry(158, "getgroups", kInt, kHex),
-    MakeEntry(159, "setgroups", kInt, kHex),
-    MakeEntry(160, "uname", kInt),
-    MakeEntry(161, "sethostname", kString, kInt),
-    MakeEntry(162, "setdomainname", kString, kInt),
-    MakeEntry(163, "getrlimit", kInt, kHex),
-    MakeEntry(164, "setrlimit", kInt, kHex),
-    MakeEntry(165, "getrusage", kInt, kHex),
-    MakeEntry(166, "umask", kHex),
-    MakeEntry(167, "prctl", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(168, "getcpu", kHex, kHex, kHex),
-    MakeEntry(169, "gettimeofday", kHex, kHex),
-    MakeEntry(170, "settimeofday", kHex, kHex),
-    MakeEntry(171, "adjtimex", kHex),
+    MakeEntry(158, "getgroups", kLen1, kGidArray),
+    MakeEntry(159, "setgroups", kLen1, kGidArray),
+    MakeEntry(160, "uname", kArray),
+    MakeEntry(161, "sethostname", kString, kLen0),
+    MakeEntry(162, "setdomainname", kString, kLen0),
+    MakeEntry(163, "getrlimit", kFlags, kPtr),
+    MakeEntry(164, "setrlimit", kFlags, kPtr),
+    MakeEntry(165, "getrusage", kFlags, kPtr),
+    MakeEntry(166, "umask", kFlags),
+    MakeEntry(167, "prctl", kInt, kInt, kInt, kInt, kInt),
+    MakeEntry(168, "getcpu", kPtr, kPtr),
+    MakeEntry(169, "gettimeofday", kPtr, kPtr),
+    MakeEntry(170, "settimeofday", kPtr, kPtr),
+    MakeEntry(171, "adjtimex", kArray),
     MakeEntry(172, "getpid"),
     MakeEntry(173, "getppid"),
     MakeEntry(174, "getuid"),
@@ -1493,117 +1581,123 @@ constexpr std::array kSyscallDataArm64 = {
     MakeEntry(176, "getgid"),
     MakeEntry(177, "getegid"),
     MakeEntry(178, "gettid"),
-    MakeEntry(179, "sysinfo", kHex),
-    MakeEntry(180, "mq_open", kString, kHex, kOct, kHex),
+    MakeEntry(179, "sysinfo", kArray),
+    MakeEntry(180, "mq_open", kString, kFlags, kFlags, kPtr),
     MakeEntry(181, "mq_unlink", kString),
-    MakeEntry(182, "mq_timedsend", kHex, kHex, kInt, kInt, kHex),
-    MakeEntry(183, "mq_timedreceive", kHex, kHex, kInt, kHex, kHex),
-    MakeEntry(184, "mq_notify", kHex, kHex),
-    MakeEntry(185, "mq_getsetattr", kHex, kHex, kHex),
-    MakeEntry(186, "msgget", kInt, kHex),
-    MakeEntry(187, "msgctl", kInt, kInt, kHex),
-    MakeEntry(188, "msgrcv", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(189, "msgsnd", kInt, kHex, kInt, kHex),
-    MakeEntry(190, "semget", kInt, kInt, kHex),
-    MakeEntry(191, "semctl", kInt, kInt, kInt, kHex),
-    MakeEntry(192, "semtimedop", kInt, kHex, kInt, kHex),
-    MakeEntry(193, "semop", kInt, kHex, kInt),
-    MakeEntry(194, "shmget", kInt, kInt, kHex),
-    MakeEntry(195, "shmctl", kInt, kInt, kHex),
-    MakeEntry(196, "shmat", kInt, kHex, kHex),
-    MakeEntry(197, "shmdt", kHex),
-    MakeEntry(198, "socket", kAddressFamily, kInt, kInt),
-    MakeEntry(199, "socketpair", kAddressFamily, kInt, kInt, kHex),
-    MakeEntry(200, "bind", kInt, kSockaddr, kInt),
-    MakeEntry(201, "listen", kInt, kInt),
-    MakeEntry(202, "accept", kInt, kSockaddr, kHex),
-    MakeEntry(203, "connect", kInt, kSockaddr, kInt),
-    MakeEntry(204, "getsockname", kInt, kSockaddr, kHex),
-    MakeEntry(205, "getpeername", kInt, kSockaddr, kHex),
-    MakeEntry(206, "sendto", kInt, kGen, kInt, kHex, kSockaddr, kInt),
-    MakeEntry(207, "recvfrom", kInt, kHex, kInt, kHex, kSockaddr, kHex),
-    MakeEntry(208, "setsockopt", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(209, "getsockopt", kInt, kInt, kInt, kHex, kInt),
-    MakeEntry(210, "shutdown", kInt, kInt),
-    MakeEntry(211, "sendmsg", kInt, kSockmsghdr, kHex),
-    MakeEntry(212, "recvmsg", kInt, kHex, kInt),
-    MakeEntry(213, "readahead", kInt, kInt, kInt),
+    MakeEntry(182, "mq_timedsend", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(183, "mq_timedreceive", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(184, "mq_notify", kResource, kPtr),
+    MakeEntry(185, "mq_getsetattr", kResource, kPtr, kPtr),
+    MakeEntry(186, "msgget", kIpcResource, kFlags),
+    MakeEntry(187, "msgctl", kIpcResource, kInt, kArray),
+    MakeEntry(188, "msgrcv", kIpcResource, kPtr, kLen1, kFlags, kFlags),
+    MakeEntry(189, "msgsnd", kIpcResource, kPtr, kLen1, kFlags),
+    MakeEntry(190, "semget", kIpcResource, kFlags, kFlags),
+    MakeEntry(191, "semctl", kIpcResource, kFlags, kInt, kArray),
+    MakeEntry(192, "semtimedop", kIpcResource, kArray, kLen1, kPtr),
+    MakeEntry(193, "semop", kIpcResource, kArray, kLen1),
+    MakeEntry(194, "shmget", kInt, kLen3, kFlags, kPtr),
+    MakeEntry(195, "shmctl", kIpcResource, kInt, kArray),
+    MakeEntry(196, "shmat", kIpcResource, kPtr, kFlags),
+    MakeEntry(197, "shmdt", kSharedAddress),
+    MakeEntry(198, "socket", kFlags, kFlags, kInt),
+    MakeEntry(199, "socketpair", kFlags, kFlags, kInt, kPtr),
+    MakeEntry(200, "bind", kResource, kSockaddr, kLen1),
+    MakeEntry(201, "listen", kResource, kInt),
+    MakeEntry(202, "accept", kResource, kPtr, kPtr),
+    MakeEntry(203, "connect", kResource, kSockaddr, kLen1),
+    MakeEntry(204, "getsockname", kResource, kPtr, kPtr),
+    MakeEntry(205, "getpeername", kResource, kPtr, kPtr),
+    MakeEntry(206, "sendto", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
+    MakeEntry(207, "recvfrom", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
+    MakeEntry(208, "setsockopt", kResource, kInt, kInt, kArray, kLen3),
+    MakeEntry(209, "getsockopt", kResource, kInt, kInt, kArray, kPtr),
+    MakeEntry(210, "shutdown", kResource, kFlags),
+    MakeEntry(211, "sendmsg", kResource, kPtr, kFlags),
+    MakeEntry(212, "recvmsg", kResource, kPtr, kFlags),
+    MakeEntry(213, "readahead", kResource, kInt, kInt),
     MakeEntry(214, "brk", kInt),
-    MakeEntry(215, "munmap", kHex, kInt),
-    MakeEntry(216, "mremap", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(217, "add_key", kString, kString, kGen, kInt, kInt),
-    MakeEntry(218, "request_key", kString, kString, kHex, kInt),
+    MakeEntry(215, "munmap", kPtr, kLen0),
+    MakeEntry(216, "mremap", kPtr, kLen0, kLen4, kFlags, kPtr),
+    MakeEntry(217, "add_key", kString, kPtr, kArray, kLen2, kStruct),
+    MakeEntry(218, "request_key", kString, kPtr, kString, kStruct),
     MakeEntry(219, "keyctl", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(220, "clone", kCloneFlag, kHex, kHex, kHex, kHex),
-    MakeEntry(221, "execve", kPath, kHex, kHex),
-    MakeEntry(222, "mmap", kHex, kInt, kHex, kHex, kInt, kInt),
-    MakeEntry(223, "fadvise64", kInt, kInt, kInt, kInt),
-    MakeEntry(224, "swapon", kPath, kHex),
+    MakeEntry(220, "clone", kFlags, kArray, kPtr, kPtr, kArray),
+    MakeEntry(221, "execve", kPath, kArray, kArray),
+    MakeEntry(222, "mmap", kPtr, kLen0, kFlags, kFlags, kResource, kInt),
+    MakeEntry(223, "fadvise64", kResource, kInt, kInt, kFlags),
+    MakeEntry(224, "swapon", kPath, kFlags),
     MakeEntry(225, "swapoff", kPath),
-    MakeEntry(226, "mprotect", kHex, kInt, kHex),
-    MakeEntry(227, "msync", kHex, kInt, kInt),
-    MakeEntry(228, "mlock", kInt, kInt),
-    MakeEntry(229, "munlock", kInt, kInt),
-    MakeEntry(230, "mlockall", kHex),
+    MakeEntry(226, "mprotect", kPtr, kLen0, kFlags),
+    MakeEntry(227, "msync", kPtr, kLen0, kFlags),
+    MakeEntry(228, "mlock", kPtr, kLen0),
+    MakeEntry(229, "munlock", kPtr, kLen0),
+    MakeEntry(230, "mlockall", kFlags),
     MakeEntry(231, "munlockall"),
-    MakeEntry(232, "mincore", kHex, kInt, kHex),
-    MakeEntry(233, "madvise", kHex, kInt, kInt),
-    MakeEntry(234, "remap_file_pages", kGen, kInt, kInt, kInt, kHex),
-    MakeEntry(235, "mbind", kGen, kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(236, "get_mempolicy", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(237, "set_mempolicy", kInt, kHex, kInt),
-    MakeEntry(238, "migrate_pages", kInt, kInt, kHex, kHex),
-    MakeEntry(239, "move_pages", kInt, kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(240, "rt_tgsigqueueinfo", kInt, kInt, kInt, kHex),
-    MakeEntry(241, "perf_event_open", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(242, "accept4", kInt, kHex, kHex, kInt),
-    MakeEntry(243, "recvmmsg", kInt, kHex, kInt, kHex, kHex),
-    MakeEntry(260, "wait4", kInt, kHex, kHex, kHex),
-    MakeEntry(261, "prlimit64", kInt, kInt, kHex, kHex),
-    MakeEntry(262, "fanotify_init", kHex, kHex),
-    MakeEntry(263, "fanotify_mark", kInt, kHex, kHex, kInt, kPath),
-    MakeEntry(264, "name_to_handle_at", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(265, "open_by_handle_at", kInt, kHex, kHex),
-    MakeEntry(266, "clock_adjtime", kInt, kHex),
-    MakeEntry(267, "syncfs", kInt),
-    MakeEntry(268, "setns", kInt, kHex),
-    MakeEntry(269, "sendmmsg", kInt, kHex, kInt, kHex),
-    MakeEntry(270, "process_vm_readv", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(271, "process_vm_writev", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(272, "kcmp", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(273, "finit_module", kInt, kString, kHex),
-    MakeEntry(274, "sched_setattr", kInt, kHex, kHex),
-    MakeEntry(275, "sched_getattr", kInt, kHex, kInt, kHex),
-    MakeEntry(276, "renameat2", kGen, kPath, kGen, kPath, kGen, kGen),
-    MakeEntry(277, "seccomp", kInt, kHex, kHex),
-    MakeEntry(278, "getrandom", kGen, kInt, kHex),
-    MakeEntry(279, "memfd_create", kString, kHex),
-    MakeEntry(280, "bpf", kInt, kHex, kInt),
-    MakeEntry(281, "execveat", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(282, "userfaultfd", kHex),
-    MakeEntry(283, "membarrier", kInt, kHex),
-    MakeEntry(284, "mlock2", kHex, kInt, kHex),
-    MakeEntry(285, "copy_file_range", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(286, "preadv2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(287, "pwritev2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(435, "clone3", kHex, kInt),
-    MakeEntry(436, "close_range", kInt, kInt, kHex),
-    MakeEntry(437, "openat2", kInt, kPath, kHex, kInt),
-    MakeEntry(438, "pidfd_getfd", UnknownArguments()),
-    MakeEntry(439, "faccessat2", kInt, kPath, kHex, kHex),
-    MakeEntry(440, "process_madvise", UnknownArguments()),
-    MakeEntry(441, "epoll_pwait2", UnknownArguments()),
-    MakeEntry(442, "mount_setattr", UnknownArguments()),
+    MakeEntry(232, "mincore", kPtr, kLen0, kArray),
+    MakeEntry(233, "madvise", kPtr, kLen0, kFlags),
+    MakeEntry(234, "remap_file_pages", kPtr, kLen0, kFlags, kInt, kFlags),
+    MakeEntry(235, "mbind", kPtr, kLen0, kFlags, kPtr, kInt, kFlags),
+    MakeEntry(236, "get_mempolicy", kPtr, kPtr, kInt, kPtr, kFlags),
+    MakeEntry(237, "set_mempolicy", kFlags, kPtr, kInt),
+    MakeEntry(238, "migrate_pages", kPid, kInt, kPtr, kPtr),
+    MakeEntry(239, "move_pages", kPid, kLen2, kArray, kArray, kArray, kFlags),
+    MakeEntry(240, "rt_tgsigqueueinfo", kPid, kPid, kSignal, kPtr),
+    MakeEntry(241, "perf_event_open", kPtr, kPid, kInt, kResource, kFlags),
+    MakeEntry(242, "accept4", kResource, kPtr, kPtr, kFlags),
+    MakeEntry(243, "recvmmsg", kResource, kArray, kLen1, kFlags, kPtr),
+    MakeEntry(260, "wait4", kPid, kPtr, kFlags, kPtr),
+    MakeEntry(261, "prlimit64", kPid, kFlags, kPtr, kPtr),
+    MakeEntry(262, "fanotify_init", kFlags, kFlags),
+    MakeEntry(263, "fanotify_mark", kResource, kFlags, kFlags, kResource,
+              kPath),
+    MakeEntry(264, "name_to_handle_at", kResource, kPath, kPtr, kPtr, kFlags),
+    MakeEntry(265, "open_by_handle_at", kResource, kPtr, kFlags),
+    MakeEntry(266, "clock_adjtime", kFlags, kPtr),
+    MakeEntry(267, "syncfs", kResource),
+    MakeEntry(268, "setns", kResource, kFlags),
+    MakeEntry(269, "sendmmsg", kResource, kArray, kLen1, kFlags),
+    MakeEntry(270, "process_vm_readv", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(271, "process_vm_writev", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(272, "kcmp", kPid, kPid, kFlags, kResource, kResource),
+    MakeEntry(273, "finit_module", kResource, kString, kFlags),
+    MakeEntry(274, "sched_setattr", kPid, kPtr, kInt),
+    MakeEntry(275, "sched_getattr", kPid, kPtr, kLen1, kInt),
+    MakeEntry(276, "renameat2", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(277, "seccomp", kInt, kFlags, kPtr),
+    MakeEntry(278, "getrandom", kArray, kLen0, kFlags),
+    MakeEntry(279, "memfd_create", kString, kFlags),
+    MakeEntry(280, "bpf", kInt, kPtr, kLen1),
+    MakeEntry(281, "execveat", kResource, kPath, kArray, kArray, kFlags),
+    MakeEntry(282, "userfaultfd", kFlags),
+    MakeEntry(283, "membarrier", kFlags, kInt),
+    MakeEntry(284, "mlock2", kPtr, kLen0, kFlags),
+    MakeEntry(285, "copy_file_range", kResource, kPtr, kResource, kPtr, kInt,
+              kFlags),
+    MakeEntry(286, "preadv2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(287, "pwritev2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(435, "clone3", kPtr, kLen0),
+    MakeEntry(436, "close_range", kResource, kResource, kFlags),
+    MakeEntry(437, "openat2", kResource, kPath, kPtr, kLen2),
+    MakeEntry(438, "pidfd_getfd", kResource, kResource, kInt),
+    MakeEntry(439, "faccessat2", kResource, kPath, kFlags, kFlags),
+    MakeEntry(440, "process_madvise", kResource, kArray, kLen1, kFlags, kInt),
+    MakeEntry(441, "epoll_pwait2", kResource, kArray, kLen1, kPtr, kPtr, kLen4),
+    MakeEntry(442, "mount_setattr", kResource, kPath, kFlags, kPtr, kLen3),
     MakeEntry(443, "quotactl_fd", UnknownArguments()),
-    MakeEntry(444, "landlock_create_ruleset", UnknownArguments()),
-    MakeEntry(445, "landlock_add_rule", UnknownArguments()),
-    MakeEntry(446, "landlock_restrict_self", UnknownArguments()),
-    MakeEntry(448, "process_mrelease", UnknownArguments()),
-    MakeEntry(449, "futex_waitv", UnknownArguments()),
-    MakeEntry(450, "set_mempolicy_home_node", UnknownArguments()),
-    MakeEntry(451, "cachestat", UnknownArguments()),
-    MakeEntry(452, "fchmodat2", kInt, kPath, kHex, kHex),
-    MakeEntry(453, "map_shadow_stack", UnknownArguments()),
+    MakeEntry(444, "landlock_create_ruleset", kPtr, kLen0, kInt),
+    MakeEntry(445, "landlock_add_rule", kResource, kInt, kPtr, kInt),
+    MakeEntry(446, "landlock_restrict_self", kResource, kInt),
+    MakeEntry(448, "process_mrelease", kResource, kInt),
+    MakeEntry(449, "futex_waitv", kArray, kLen0, kInt, kPtr, kFlags),
+    MakeEntry(450, "set_mempolicy_home_node", kPtr, kLen0, kInt, kInt),
+    MakeEntry(451, "cachestat", kResource, kPtr, kPtr, kInt),
+    MakeEntry(452, "fchmodat2", kInt, kPath, kInt, kInt),
+    MakeEntry(453, "map_shadow_stack", kPtr, kLen0, kFlags),
     MakeEntry(454, "futex_wake", UnknownArguments()),
     MakeEntry(455, "futex_wait", UnknownArguments()),
     MakeEntry(456, "futex_requeue", UnknownArguments()),
@@ -1621,372 +1715,378 @@ static_assert(IsSorted(kSyscallDataArm64, SyscallTable::Entry::BySyscallNr),
 constexpr std::array kSyscallDataArm32 = {
     // clang-format off
     MakeEntry(0, "restart_syscall"),
-    MakeEntry(1, "exit", kHex, kHex, kHex, kHex),
+    MakeEntry(1, "exit", kInt),
     MakeEntry(2, "fork"),
-    MakeEntry(3, "read", kInt, kHex, kInt),
-    MakeEntry(4, "write", kHex, kHex, kHex, kHex),
-    MakeEntry(5, "open", kPath, kHex, kOct),
-    MakeEntry(6, "close", kHex, kHex, kHex, kHex),
-    MakeEntry(8, "creat", kPath, kHex, kHex, kHex),
+    MakeEntry(3, "read", kResource, kArray, kLen1),
+    MakeEntry(4, "write", kResource, kArray, kLen1),
+    MakeEntry(5, "open", kPath, kFlags, kFlags),
+    MakeEntry(6, "close", kResource),
+    MakeEntry(8, "creat", kPath, kFlags),
     MakeEntry(9, "link", kPath, kPath),
     MakeEntry(10, "unlink", kPath),
-    MakeEntry(11, "execve", kPath, kHex, kHex),
+    MakeEntry(11, "execve", kPath, kArray, kArray),
     MakeEntry(12, "chdir", kPath),
-    MakeEntry(14, "mknod", kPath, kOct, kHex),
-    MakeEntry(15, "chmod", kPath, kOct),
-    MakeEntry(16, "lchown", kPath, kInt, kInt),
-    MakeEntry(19, "lseek", kInt, kInt, kInt),
+    MakeEntry(14, "mknod", kPath, kFlags, kInt),
+    MakeEntry(15, "chmod", kPath, kFlags),
+    MakeEntry(16, "lchown", kPath, kUid, kGid),
+    MakeEntry(19, "lseek", kResource, kInt, kFlags),
     MakeEntry(20, "getpid"),
-    MakeEntry(21, "mount", kPath, kPath, kString, kHex, kGen),
-    MakeEntry(23, "setuid", kInt),
+    MakeEntry(21, "mount", kPtr, kPath, kString, kFlags, kString),
+    MakeEntry(23, "setuid", kUid),
     MakeEntry(24, "getuid"),
-    MakeEntry(26, "ptrace", kHex, kHex, kHex, kHex),
+    MakeEntry(26, "ptrace", kFlags, kPid),
     MakeEntry(29, "pause"),
-    MakeEntry(33, "access", kPath, kHex),
-    MakeEntry(34, "nice", kHex, kHex, kHex, kHex),
+    MakeEntry(33, "access", kPath, kInt),
+    MakeEntry(34, "nice", kInt, kInt, kInt, kInt),
     MakeEntry(36, "sync"),
-    MakeEntry(37, "kill", kHex, kHex, kHex, kHex),
+    MakeEntry(37, "kill", kPid, kSignal),
     MakeEntry(38, "rename", kPath, kPath),
-    MakeEntry(39, "mkdir", kPath, kHex, kHex, kHex),
-    MakeEntry(40, "rmdir", kHex, kHex, kHex, kHex),
-    MakeEntry(41, "dup", kInt),
-    MakeEntry(42, "pipe", kHex),
-    MakeEntry(43, "times", kHex),
-    MakeEntry(45, "brk", kHex),
-    MakeEntry(46, "setgid", kInt),
+    MakeEntry(39, "mkdir", kPath, kFlags),
+    MakeEntry(40, "rmdir", kPath),
+    MakeEntry(41, "dup", kResource),
+    MakeEntry(42, "pipe", kPtr),
+    MakeEntry(43, "times", kPtr),
+    MakeEntry(45, "brk", kInt),
+    MakeEntry(46, "setgid", kGid),
     MakeEntry(47, "getgid"),
     MakeEntry(49, "geteuid"),
     MakeEntry(50, "getegid"),
-    MakeEntry(51, "acct", kHex, kHex, kHex, kHex),
-    MakeEntry(52, "umount2", kHex, kHex, kHex, kHex),
-    MakeEntry(54, "ioctl", kInt, kInt, kHex),
-    MakeEntry(55, "fcntl", kInt, kInt, kHex),
-    MakeEntry(57, "setpgid", kInt, kInt),
-    MakeEntry(60, "umask", kHex),
-    MakeEntry(61, "chroot", kHex, kHex, kHex, kHex),
-    MakeEntry(62, "ustat", kHex, kHex),
-    MakeEntry(63, "dup2", kGen, kGen),
+    MakeEntry(51, "acct", kPath),
+    MakeEntry(52, "umount2", kPath, kFlags),
+    MakeEntry(54, "ioctl", kResource, kInt, kArray),
+    MakeEntry(55, "fcntl", kResource, kFlags, kResource),
+    MakeEntry(57, "setpgid", kPid, kPid),
+    MakeEntry(60, "umask", kFlags),
+    MakeEntry(61, "chroot", kPath),
+    MakeEntry(62, "ustat", kInt, kPtr),
+    MakeEntry(63, "dup2", kResource, kResource),
     MakeEntry(64, "getppid"),
-    MakeEntry(65, "getpgrp"),
+    MakeEntry(65, "getpgrp", kPid),
     MakeEntry(66, "setsid"),
-    MakeEntry(67, "sigaction", kHex, kHex, kHex, kHex),
-    MakeEntry(70, "setreuid", kInt, kInt),
-    MakeEntry(71, "setregid", kInt, kInt),
-    MakeEntry(72, "sigsuspend", kHex, kHex, kHex, kHex),
-    MakeEntry(73, "sigpending", kHex, kHex, kHex, kHex),
-    MakeEntry(74, "sethostname", kString, kInt),
-    MakeEntry(75, "setrlimit", kInt, kHex),
-    MakeEntry(77, "getrusage", kInt, kHex),
-    MakeEntry(78, "gettimeofday", kHex, kHex),
-    MakeEntry(79, "settimeofday", kHex, kHex),
-    MakeEntry(80, "getgroups", kInt, kHex),
-    MakeEntry(81, "setgroups", kInt, kHex),
+    MakeEntry(67, "sigaction", kInt, kInt, kInt, kInt),
+    MakeEntry(70, "setreuid", kUid, kUid),
+    MakeEntry(71, "setregid", kGid, kGid),
+    MakeEntry(72, "sigsuspend", kInt, kInt, kInt, kInt),
+    MakeEntry(73, "sigpending", kInt, kInt, kInt, kInt),
+    MakeEntry(74, "sethostname", kString, kLen0),
+    MakeEntry(75, "setrlimit", kFlags, kPtr),
+    MakeEntry(77, "getrusage", kFlags, kPtr),
+    MakeEntry(78, "gettimeofday", kPtr, kPtr),
+    MakeEntry(79, "settimeofday", kPtr, kPtr),
+    MakeEntry(80, "getgroups", kLen1, kGidArray),
+    MakeEntry(81, "setgroups", kLen1, kGidArray),
     MakeEntry(83, "symlink", kPath, kPath),
-    MakeEntry(85, "readlink", kPath, kGen, kInt),
+    MakeEntry(85, "readlink", kPath, kArray, kLen1),
     MakeEntry(86, "uselib", kPath),
-    MakeEntry(87, "swapon", kHex, kHex, kHex, kHex),
-    MakeEntry(88, "reboot", kGen, kGen, kGen, kGen),
-    MakeEntry(91, "munmap", kHex, kHex),
-    MakeEntry(92, "truncate", kPath, kHex, kHex, kHex),
-    MakeEntry(93, "ftruncate", kInt, kInt),
-    MakeEntry(94, "fchmod", kInt, kOct),
-    MakeEntry(95, "fchown", kInt, kInt, kInt),
-    MakeEntry(96, "getpriority", kInt, kInt),
-    MakeEntry(97, "setpriority", kInt, kInt, kInt),
-    MakeEntry(99, "statfs", kPath, kHex),
-    MakeEntry(100, "fstatfs", kInt, kHex),
-    MakeEntry(103, "syslog", kInt, kHex, kInt),
-    MakeEntry(104, "setitimer", kInt, kHex, kHex),
-    MakeEntry(105, "getitimer", kInt, kHex),
-    MakeEntry(106, "stat", kPath, kGen),
-    MakeEntry(107, "lstat", kPath, kGen),
-    MakeEntry(108, "fstat", kHex, kHex, kHex, kHex),
+    MakeEntry(87, "swapon", kPath, kFlags),
+    MakeEntry(88, "reboot", kInt, kInt, kInt, kPtr),
+    MakeEntry(91, "munmap", kPtr, kLen0),
+    MakeEntry(92, "truncate", kPath, kInt),
+    MakeEntry(93, "ftruncate", kResource, kInt),
+    MakeEntry(94, "fchmod", kResource, kFlags),
+    MakeEntry(95, "fchown", kResource, kUid, kGid),
+    MakeEntry(96, "getpriority", kFlags, kPid),
+    MakeEntry(97, "setpriority", kFlags, kPid, kInt),
+    MakeEntry(99, "statfs", kPath, kArray),
+    MakeEntry(100, "fstatfs", kResource, kArray),
+    MakeEntry(103, "syslog", kFlags, kArray, kLen1),
+    MakeEntry(104, "setitimer", kFlags, kPtr, kPtr),
+    MakeEntry(105, "getitimer", kFlags, kPtr),
+    MakeEntry(106, "stat", kPath, kPtr),
+    MakeEntry(107, "lstat", kPath, kPtr),
+    MakeEntry(108, "fstat", kResource, kPtr),
     MakeEntry(111, "vhangup"),
-    MakeEntry(114, "wait4", kHex, kHex, kHex, kHex),
-    MakeEntry(115, "swapoff", kHex, kHex, kHex, kHex),
-    MakeEntry(116, "sysinfo", kHex),
-    MakeEntry(118, "fsync", kInt),
-    MakeEntry(119, "sigreturn", kHex, kHex, kHex, kHex),
-    MakeEntry(120, "clone", kCloneFlag, kHex, kHex, kHex, kHex),
-    MakeEntry(121, "setdomainname", kString, kInt),
-    MakeEntry(122, "uname", kInt),
-    MakeEntry(124, "adjtimex", kHex),
-    MakeEntry(125, "mprotect", kHex, kHex, kHex),
-    MakeEntry(126, "sigprocmask", kHex, kHex, kHex, kHex),
-    MakeEntry(128, "init_module", kGen, kInt, kString),
-    MakeEntry(129, "delete_module", kString, kHex),
-    MakeEntry(131, "quotactl", kHex, kHex, kHex, kHex),
-    MakeEntry(132, "getpgid", kInt),
-    MakeEntry(133, "fchdir", kInt),
-    MakeEntry(134, "bdflush", kHex, kHex, kHex, kHex),
-    MakeEntry(135, "sysfs", kInt, kInt, kInt),
-    MakeEntry(136, "personality", kHex),
-    MakeEntry(138, "setfsuid", kInt),
-    MakeEntry(139, "setfsgid", kInt),
-    MakeEntry(140, "_llseek", kHex, kHex, kHex, kHex),
-    MakeEntry(141, "getdents", kInt, kHex, kInt),
-    MakeEntry(142, "_newselect", kHex, kHex, kHex, kHex),
-    MakeEntry(143, "flock", kInt, kInt),
-    MakeEntry(144, "msync", kHex, kInt, kInt),
-    MakeEntry(145, "readv", kInt, kHex, kInt),
-    MakeEntry(146, "writev", kInt, kHex, kInt),
-    MakeEntry(147, "getsid", kInt),
-    MakeEntry(148, "fdatasync", kInt),
-    MakeEntry(149, "_sysctl", kHex),
-    MakeEntry(150, "mlock", kInt, kInt),
-    MakeEntry(151, "munlock", kInt, kInt),
-    MakeEntry(152, "mlockall", kHex),
+    MakeEntry(114, "wait4", kPid, kPtr, kFlags, kPtr),
+    MakeEntry(115, "swapoff", kPath),
+    MakeEntry(116, "sysinfo", kArray),
+    MakeEntry(118, "fsync", kResource),
+    MakeEntry(119, "sigreturn", kInt, kInt, kInt, kInt),
+    MakeEntry(120, "clone", kFlags, kArray, kPtr, kPtr, kArray),
+    MakeEntry(121, "setdomainname", kString, kLen0),
+    MakeEntry(122, "uname", kArray),
+    MakeEntry(124, "adjtimex", kArray),
+    MakeEntry(125, "mprotect", kPtr, kLen0, kFlags),
+    MakeEntry(126, "sigprocmask", kInt, kInt, kInt, kInt),
+    MakeEntry(128, "init_module", kString, kLen0, kString),
+    MakeEntry(129, "delete_module", kString, kFlags),
+    MakeEntry(131, "quotactl", kInt, kInt, kInt, kInt),
+    MakeEntry(132, "getpgid", kPid),
+    MakeEntry(133, "fchdir", kResource),
+    MakeEntry(134, "bdflush", kInt, kInt, kInt, kInt),
+    MakeEntry(135, "sysfs", kInt, kString),
+    MakeEntry(136, "personality", kFlags),
+    MakeEntry(138, "setfsuid", kUid),
+    MakeEntry(139, "setfsgid", kGid),
+    MakeEntry(140, "_llseek", kInt, kInt, kInt, kInt),
+    MakeEntry(141, "getdents", kResource, kArray, kLen1),
+    MakeEntry(142, "_newselect", kInt, kInt, kInt, kInt),
+    MakeEntry(143, "flock", kResource, kFlags),
+    MakeEntry(144, "msync", kPtr, kLen0, kFlags),
+    MakeEntry(145, "readv", kResource, kArray, kLen1),
+    MakeEntry(146, "writev", kResource, kArray, kLen1),
+    MakeEntry(147, "getsid", kPid),
+    MakeEntry(148, "fdatasync", kResource),
+    MakeEntry(149, "_sysctl", kPtr),
+    MakeEntry(150, "mlock", kPtr, kLen0),
+    MakeEntry(151, "munlock", kPtr, kLen0),
+    MakeEntry(152, "mlockall", kFlags),
     MakeEntry(153, "munlockall"),
-    MakeEntry(154, "sched_setparam", kInt, kHex),
-    MakeEntry(155, "sched_getparam", kInt, kHex),
-    MakeEntry(156, "sched_setscheduler", kInt, kInt, kHex),
-    MakeEntry(157, "sched_getscheduler", kInt),
+    MakeEntry(154, "sched_setparam", kPid, kPtr),
+    MakeEntry(155, "sched_getparam", kPid, kPtr),
+    MakeEntry(156, "sched_setscheduler", kPid, kFlags, kPtr),
+    MakeEntry(157, "sched_getscheduler", kPid),
     MakeEntry(158, "sched_yield"),
-    MakeEntry(159, "sched_get_priority_max", kHex),
-    MakeEntry(160, "sched_get_priority_min", kHex),
-    MakeEntry(161, "sched_rr_get_interval", kInt, kHex),
-    MakeEntry(162, "nanosleep", kHex, kHex),
-    MakeEntry(163, "mremap", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(164, "setresuid", kInt, kInt, kInt),
-    MakeEntry(165, "getresuid", kHex, kHex, kHex),
-    MakeEntry(168, "poll", kGen, kInt, kInt),
-    MakeEntry(169, "nfsservctl", kInt, kGen, kGen),
-    MakeEntry(170, "setresgid", kInt, kInt, kInt),
-    MakeEntry(171, "getresgid", kHex, kHex, kHex),
-    MakeEntry(172, "prctl", kInt, kHex, kHex, kHex, kHex),
+    MakeEntry(159, "sched_get_priority_max", kInt),
+    MakeEntry(160, "sched_get_priority_min", kInt),
+    MakeEntry(161, "sched_rr_get_interval", kPid, kPtr),
+    MakeEntry(162, "nanosleep", kPtr, kPtr),
+    MakeEntry(163, "mremap", kPtr, kLen0, kLen4, kFlags, kPtr),
+    MakeEntry(164, "setresuid", kUid, kUid, kUid),
+    MakeEntry(165, "getresuid", kPtr, kPtr, kPtr),
+    MakeEntry(168, "poll", kPollFdArray, kLen0, kInt),
+    MakeEntry(169, "nfsservctl", kInt, kPtr, kPtr),
+    MakeEntry(170, "setresgid", kGid, kGid, kGid),
+    MakeEntry(171, "getresgid", kPtr, kPtr, kPtr),
+    MakeEntry(172, "prctl", kInt, kInt, kInt, kInt, kInt),
     MakeEntry(173, "rt_sigreturn"),
-    MakeEntry(174, "rt_sigaction", kHex, kHex, kHex, kHex),
-    MakeEntry(175, "rt_sigprocmask", kGen, kGen, kGen, kGen),
-    MakeEntry(176, "rt_sigpending", kHex, kInt),
-    MakeEntry(177, "rt_sigtimedwait", kGen, kGen, kGen, kGen),
-    MakeEntry(178, "rt_sigqueueinfo", kInt, kSignal, kHex),
-    MakeEntry(179, "rt_sigsuspend", kHex, kInt),
-    MakeEntry(180, "pread64", kGen, kGen, kGen, kGen),
-    MakeEntry(181, "pwrite64", kGen, kGen, kGen, kGen),
-    MakeEntry(182, "chown", kHex, kHex, kHex, kHex),
-    MakeEntry(183, "getcwd", kHex, kInt),
-    MakeEntry(184, "capget", kHex, kHex),
-    MakeEntry(185, "capset", kHex, kHex),
-    MakeEntry(186, "sigaltstack", kHex, kHex),
-    MakeEntry(187, "sendfile", kGen, kGen, kGen, kGen),
+    MakeEntry(174, "rt_sigaction", kSignal, kPtr, kPtr, kLen4, kPtr),
+    MakeEntry(175, "rt_sigprocmask", kFlags, kPtr, kPtr, kLen1),
+    MakeEntry(176, "rt_sigpending", kPtr, kLen0),
+    MakeEntry(177, "rt_sigtimedwait", kPtr, kPtr, kPtr, kLen0),
+    MakeEntry(178, "rt_sigqueueinfo", kPid, kSignal, kPtr),
+    MakeEntry(179, "rt_sigsuspend", kPtr, kLen0),
+    MakeEntry(180, "pread64", kResource, kArray, kLen1, kInt),
+    MakeEntry(181, "pwrite64", kResource, kArray, kLen1, kInt),
+    MakeEntry(182, "chown", kPath, kUid, kGid),
+    MakeEntry(183, "getcwd", kArray, kLen0),
+    MakeEntry(184, "capget", kPtr, kPtr),
+    MakeEntry(185, "capset", kPtr, kPtr),
+    MakeEntry(186, "sigaltstack", kPtr, kPtr),
+    MakeEntry(187, "sendfile", kResource, kResource, kPtr, kInt),
     MakeEntry(190, "vfork"),
-    MakeEntry(191, "ugetrlimit", kHex, kHex, kHex, kHex),
-    MakeEntry(192, "mmap2", kHex, kHex, kHex, kHex),
-    MakeEntry(193, "truncate64", kHex, kHex, kHex, kHex),
-    MakeEntry(194, "ftruncate64", kHex, kHex, kHex, kHex),
-    MakeEntry(195, "stat64", kHex, kHex, kHex, kHex),
-    MakeEntry(196, "lstat64", kHex, kHex, kHex, kHex),
-    MakeEntry(197, "fstat64", kHex, kHex, kHex, kHex),
-    MakeEntry(198, "lchown32", kHex, kHex, kHex, kHex),
-    MakeEntry(199, "getuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(200, "getgid32", kHex, kHex, kHex, kHex),
-    MakeEntry(201, "geteuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(202, "getegid32", kHex, kHex, kHex, kHex),
-    MakeEntry(203, "setreuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(204, "setregid32", kHex, kHex, kHex, kHex),
-    MakeEntry(205, "getgroups32", kHex, kHex, kHex, kHex),
-    MakeEntry(206, "setgroups32", kHex, kHex, kHex, kHex),
-    MakeEntry(207, "fchown32", kHex, kHex, kHex, kHex),
-    MakeEntry(208, "setresuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(209, "getresuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(210, "setresgid32", kHex, kHex, kHex, kHex),
-    MakeEntry(211, "getresgid32", kHex, kHex, kHex, kHex),
-    MakeEntry(212, "chown32", kHex, kHex, kHex, kHex),
-    MakeEntry(213, "setuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(214, "setgid32", kHex, kHex, kHex, kHex),
-    MakeEntry(215, "setfsuid32", kHex, kHex, kHex, kHex),
-    MakeEntry(216, "setfsgid32", kHex, kHex, kHex, kHex),
-    MakeEntry(217, "getdents64", kInt, kHex, kInt),
-    MakeEntry(218, "pivot_root", kHex, kHex, kHex, kHex),
-    MakeEntry(219, "mincore", kHex, kInt, kHex),
-    MakeEntry(220, "madvise", kHex, kInt, kInt),
-    MakeEntry(221, "fcntl64", kHex, kHex, kHex, kHex),
+    MakeEntry(191, "ugetrlimit", kInt, kInt, kInt, kInt),
+    MakeEntry(192, "mmap2", kInt, kInt, kInt, kInt),
+    MakeEntry(193, "truncate64", kInt, kInt, kInt, kInt),
+    MakeEntry(194, "ftruncate64", kInt, kInt, kInt, kInt),
+    MakeEntry(195, "stat64", kPath, kPtr),
+    MakeEntry(196, "lstat64", kPath, kPtr),
+    MakeEntry(197, "fstat64", kResource, kPtr),
+    MakeEntry(198, "lchown32", kInt, kInt, kInt, kInt),
+    MakeEntry(199, "getuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(200, "getgid32", kInt, kInt, kInt, kInt),
+    MakeEntry(201, "geteuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(202, "getegid32", kInt, kInt, kInt, kInt),
+    MakeEntry(203, "setreuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(204, "setregid32", kInt, kInt, kInt, kInt),
+    MakeEntry(205, "getgroups32", kInt, kInt, kInt, kInt),
+    MakeEntry(206, "setgroups32", kInt, kInt, kInt, kInt),
+    MakeEntry(207, "fchown32", kInt, kInt, kInt, kInt),
+    MakeEntry(208, "setresuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(209, "getresuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(210, "setresgid32", kInt, kInt, kInt, kInt),
+    MakeEntry(211, "getresgid32", kInt, kInt, kInt, kInt),
+    MakeEntry(212, "chown32", kInt, kInt, kInt, kInt),
+    MakeEntry(213, "setuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(214, "setgid32", kInt, kInt, kInt, kInt),
+    MakeEntry(215, "setfsuid32", kInt, kInt, kInt, kInt),
+    MakeEntry(216, "setfsgid32", kInt, kInt, kInt, kInt),
+    MakeEntry(217, "getdents64", kResource, kArray, kLen1),
+    MakeEntry(218, "pivot_root", kPath, kPath),
+    MakeEntry(219, "mincore", kPtr, kLen0, kArray),
+    MakeEntry(220, "madvise", kPtr, kLen0, kFlags),
+    MakeEntry(221, "fcntl64", kInt, kInt, kInt, kInt),
     MakeEntry(224, "gettid"),
-    MakeEntry(225, "readahead", kInt, kInt, kInt),
-    MakeEntry(226, "setxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(227, "lsetxattr", kPath, kString, kGen, kInt, kHex),
-    MakeEntry(228, "fsetxattr", kInt, kString, kGen, kInt, kHex),
-    MakeEntry(229, "getxattr", kHex, kHex, kHex, kHex),
-    MakeEntry(230, "lgetxattr", kHex, kHex, kHex, kHex),
-    MakeEntry(231, "fgetxattr", kGen, kGen, kGen, kGen),
-    MakeEntry(232, "listxattr", kHex, kHex, kHex, kHex),
-    MakeEntry(233, "llistxattr", kHex, kHex, kHex, kHex),
-    MakeEntry(234, "flistxattr", kInt, kGen, kInt),
-    MakeEntry(235, "removexattr", kHex, kHex, kHex, kHex),
-    MakeEntry(236, "lremovexattr", kPath, kString),
-    MakeEntry(237, "fremovexattr", kInt, kString),
-    MakeEntry(238, "tkill", kHex, kHex, kHex, kHex),
-    MakeEntry(239, "sendfile64", kHex, kHex, kHex, kHex),
-    MakeEntry(240, "futex", kGen, kInt, kInt, kGen, kGen, kInt),
-    MakeEntry(241, "sched_setaffinity", kInt, kInt, kHex),
-    MakeEntry(242, "sched_getaffinity", kInt, kInt, kHex),
-    MakeEntry(243, "io_setup", kInt, kHex),
-    MakeEntry(244, "io_destroy", kInt),
-    MakeEntry(245, "io_getevents", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(246, "io_submit", kInt, kInt, kHex),
-    MakeEntry(247, "io_cancel", kInt, kHex, kHex),
-    MakeEntry(248, "exit_group", kHex, kHex, kHex, kHex),
-    MakeEntry(249, "lookup_dcookie", kInt, kString, kInt),
+    MakeEntry(225, "readahead", kResource, kInt, kInt),
+    MakeEntry(226, "setxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(227, "lsetxattr", kPath, kPtr, kString, kLen2, kFlags),
+    MakeEntry(228, "fsetxattr", kResource, kPtr, kString, kLen2, kFlags),
+    MakeEntry(229, "getxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(230, "lgetxattr", kPath, kPtr, kArray, kLen2),
+    MakeEntry(231, "fgetxattr", kResource, kPtr, kArray, kLen2),
+    MakeEntry(232, "listxattr", kPath, kArray, kLen1),
+    MakeEntry(233, "llistxattr", kPath, kArray, kLen1),
+    MakeEntry(234, "flistxattr", kResource, kArray, kLen1),
+    MakeEntry(235, "removexattr", kPath, kPtr),
+    MakeEntry(236, "lremovexattr", kPath, kPtr),
+    MakeEntry(237, "fremovexattr", kResource, kPtr),
+    MakeEntry(238, "tkill", kPid, kSignal),
+    MakeEntry(239, "sendfile64", kResource, kResource, kPtr, kInt),
+    MakeEntry(240, "futex", kPtr, kFlags, kInt, kPtr, kPtr, kInt),
+    MakeEntry(241, "sched_setaffinity", kPid, kLen2, kPtr),
+    MakeEntry(242, "sched_getaffinity", kPid, kLen2, kPtr),
+    MakeEntry(243, "io_setup", kInt, kPtr),
+    MakeEntry(244, "io_destroy", kStruct),
+    MakeEntry(245, "io_getevents", kStruct, kInt, kLen3, kArray, kPtr),
+    MakeEntry(246, "io_submit", kStruct, kLen2, kArray),
+    MakeEntry(247, "io_cancel", kStruct, kPtr, kPtr),
+    MakeEntry(248, "exit_group", kInt),
+    MakeEntry(249, "lookup_dcookie", kInt, kArray, kLen1),
     MakeEntry(250, "epoll_create", kInt),
-    MakeEntry(251, "epoll_ctl", kGen, kGen, kGen, kGen),
-    MakeEntry(252, "epoll_wait", kGen, kGen, kGen, kGen),
-    MakeEntry(253, "remap_file_pages", kGen, kInt, kInt, kInt, kHex),
-    MakeEntry(256, "set_tid_address", kHex),
-    MakeEntry(257, "timer_create", kInt, kHex, kHex),
-    MakeEntry(258, "timer_settime", kGen, kGen, kGen, kGen),
-    MakeEntry(259, "timer_gettime", kInt, kHex),
-    MakeEntry(260, "timer_getoverrun", kInt),
-    MakeEntry(261, "timer_delete", kInt),
-    MakeEntry(262, "clock_settime", kInt, kHex),
-    MakeEntry(263, "clock_gettime", kInt, kHex),
-    MakeEntry(264, "clock_getres", kInt, kHex),
-    MakeEntry(265, "clock_nanosleep", kGen, kGen, kGen, kGen),
-    MakeEntry(266, "statfs64", kHex, kHex, kHex, kHex),
-    MakeEntry(267, "fstatfs64", kHex, kHex, kHex, kHex),
-    MakeEntry(268, "tgkill", kHex, kHex, kHex, kHex),
-    MakeEntry(269, "utimes", kPath, kHex),
-    MakeEntry(271, "pciconfig_iobase", kHex, kHex, kHex, kHex),
-    MakeEntry(272, "pciconfig_read", kHex, kHex, kHex, kHex),
-    MakeEntry(273, "pciconfig_write", kHex, kHex, kHex, kHex),
-    MakeEntry(274, "mq_open", kGen, kGen, kGen, kGen),
+    MakeEntry(251, "epoll_ctl", kResource, kInt, kResource, kPtr),
+    MakeEntry(252, "epoll_wait", kResource, kArray, kLen1, kInt),
+    MakeEntry(253, "remap_file_pages", kPtr, kLen0, kFlags, kInt, kFlags),
+    MakeEntry(256, "set_tid_address", kPtr),
+    MakeEntry(257, "timer_create", kFlags, kPtr, kPtr),
+    MakeEntry(258, "timer_settime", kStruct, kFlags, kPtr, kPtr),
+    MakeEntry(259, "timer_gettime", kStruct, kPtr),
+    MakeEntry(260, "timer_getoverrun", kStruct),
+    MakeEntry(261, "timer_delete", kStruct),
+    MakeEntry(262, "clock_settime", kFlags, kPtr),
+    MakeEntry(263, "clock_gettime", kFlags, kPtr),
+    MakeEntry(264, "clock_getres", kFlags, kPtr),
+    MakeEntry(265, "clock_nanosleep", kFlags, kFlags, kPtr, kPtr),
+    MakeEntry(266, "statfs64", kInt, kInt, kInt, kInt),
+    MakeEntry(267, "fstatfs64", kInt, kInt, kInt, kInt),
+    MakeEntry(268, "tgkill", kPid, kPid, kSignal),
+    MakeEntry(269, "utimes", kPath, kPtr),
+    MakeEntry(271, "pciconfig_iobase", kInt, kInt, kInt, kInt),
+    MakeEntry(272, "pciconfig_read", kInt, kInt, kInt, kInt),
+    MakeEntry(273, "pciconfig_write", kInt, kInt, kInt, kInt),
+    MakeEntry(274, "mq_open", kString, kFlags, kFlags, kPtr),
     MakeEntry(275, "mq_unlink", kString),
-    MakeEntry(276, "mq_timedsend", kHex, kHex, kInt, kInt, kHex),
-    MakeEntry(277, "mq_timedreceive", kHex, kHex, kInt, kHex, kHex),
-    MakeEntry(278, "mq_notify", kHex, kHex),
-    MakeEntry(279, "mq_getsetattr", kHex, kHex, kHex),
-    MakeEntry(280, "waitid", kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(281, "socket", kAddressFamily, kInt, kInt),
-    MakeEntry(282, "bind", kInt, kSockaddr, kInt),
-    MakeEntry(283, "connect", kInt, kSockaddr, kInt),
-    MakeEntry(284, "listen", kInt, kInt),
-    MakeEntry(285, "accept", kInt, kSockaddr, kHex),
-    MakeEntry(286, "getsockname", kInt, kSockaddr, kHex),
-    MakeEntry(287, "getpeername", kInt, kSockaddr, kHex),
-    MakeEntry(288, "socketpair", kGen, kGen, kGen, kGen),
-    MakeEntry(289, "send", kHex, kHex, kHex, kHex),
-    MakeEntry(290, "sendto", kInt, kGen, kInt, kHex, kSockaddr, kInt),
-    MakeEntry(291, "recv", kHex, kHex, kHex, kHex),
-    MakeEntry(292, "recvfrom", kInt, kHex, kInt, kHex, kSockaddr, kHex),
-    MakeEntry(293, "shutdown", kInt, kInt),
-    MakeEntry(294, "setsockopt", kInt, kInt, kInt, kHex, kHex),
-    MakeEntry(295, "getsockopt", kInt, kInt, kInt, kHex, kInt),
-    MakeEntry(296, "sendmsg", kInt, kSockmsghdr, kHex),
-    MakeEntry(297, "recvmsg", kInt, kHex, kInt),
-    MakeEntry(298, "semop", kInt, kHex, kInt),
-    MakeEntry(299, "semget", kInt, kInt, kHex),
-    MakeEntry(300, "semctl", kInt, kInt, kInt, kHex),
-    MakeEntry(301, "msgsnd", kInt, kHex, kInt, kHex),
-    MakeEntry(302, "msgrcv", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(303, "msgget", kInt, kHex),
-    MakeEntry(304, "msgctl", kInt, kInt, kHex),
-    MakeEntry(305, "shmat", kInt, kHex, kHex),
-    MakeEntry(306, "shmdt", kHex),
-    MakeEntry(307, "shmget", kInt, kInt, kHex),
-    MakeEntry(308, "shmctl", kInt, kInt, kHex),
-    MakeEntry(309, "add_key", kString, kString, kGen, kInt, kInt),
-    MakeEntry(310, "request_key", kGen, kGen, kGen, kGen),
+    MakeEntry(276, "mq_timedsend", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(277, "mq_timedreceive", kResource, kArray, kLen1, kInt, kPtr),
+    MakeEntry(278, "mq_notify", kResource, kPtr),
+    MakeEntry(279, "mq_getsetattr", kResource, kPtr, kPtr),
+    MakeEntry(280, "waitid", kFlags, kPid, kPtr, kFlags, kPtr),
+    MakeEntry(281, "socket", kFlags, kFlags, kInt),
+    MakeEntry(282, "bind", kResource, kSockaddr, kLen1),
+    MakeEntry(283, "connect", kResource, kSockaddr, kLen1),
+    MakeEntry(284, "listen", kResource, kInt),
+    MakeEntry(285, "accept", kResource, kPtr, kPtr),
+    MakeEntry(286, "getsockname", kResource, kPtr, kPtr),
+    MakeEntry(287, "getpeername", kResource, kPtr, kPtr),
+    MakeEntry(288, "socketpair", kFlags, kFlags, kInt, kPtr),
+    MakeEntry(289, "send", kInt, kInt, kInt, kInt),
+    MakeEntry(290, "sendto", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
+    MakeEntry(291, "recv", kInt, kInt, kInt, kInt),
+    MakeEntry(292, "recvfrom", kResource, kArray, kLen1, kFlags, kSockaddr,
+              kLen4),
+    MakeEntry(293, "shutdown", kResource, kFlags),
+    MakeEntry(294, "setsockopt", kResource, kInt, kInt, kArray, kLen3),
+    MakeEntry(295, "getsockopt", kResource, kInt, kInt, kArray, kPtr),
+    MakeEntry(296, "sendmsg", kResource, kPtr, kFlags),
+    MakeEntry(297, "recvmsg", kResource, kPtr, kFlags),
+    MakeEntry(298, "semop", kIpcResource, kArray, kLen1),
+    MakeEntry(299, "semget", kIpcResource, kFlags, kFlags),
+    MakeEntry(300, "semctl", kIpcResource, kFlags, kInt, kArray),
+    MakeEntry(301, "msgsnd", kIpcResource, kPtr, kLen1, kFlags),
+    MakeEntry(302, "msgrcv", kIpcResource, kPtr, kLen1, kFlags, kFlags),
+    MakeEntry(303, "msgget", kIpcResource, kFlags),
+    MakeEntry(304, "msgctl", kIpcResource, kInt, kArray),
+    MakeEntry(305, "shmat", kIpcResource, kPtr, kFlags),
+    MakeEntry(306, "shmdt", kSharedAddress),
+    MakeEntry(307, "shmget", kInt, kLen3, kFlags, kPtr),
+    MakeEntry(308, "shmctl", kIpcResource, kInt, kArray),
+    MakeEntry(309, "add_key", kString, kPtr, kArray, kLen2, kStruct),
+    MakeEntry(310, "request_key", kString, kPtr, kString, kStruct),
     MakeEntry(311, "keyctl", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(312, "semtimedop", kInt, kHex, kInt, kHex),
-    MakeEntry(313, "vserver", kHex, kHex, kHex, kHex),
-    MakeEntry(314, "ioprio_set", kInt, kInt, kInt),
-    MakeEntry(315, "ioprio_get", kInt, kInt),
+    MakeEntry(312, "semtimedop", kIpcResource, kArray, kLen1, kPtr),
+    MakeEntry(313, "vserver", kInt, kInt, kInt, kInt),
+    MakeEntry(314, "ioprio_set", kFlags, kPid, kFlags),
+    MakeEntry(315, "ioprio_get", kFlags, kUid),
     MakeEntry(316, "inotify_init"),
-    MakeEntry(317, "inotify_add_watch", kInt, kPath, kHex),
-    MakeEntry(318, "inotify_rm_watch", kInt, kInt),
-    MakeEntry(319, "mbind", kGen, kInt, kInt, kHex, kInt, kHex),
-    MakeEntry(320, "get_mempolicy", kInt, kHex, kInt, kInt, kHex),
-    MakeEntry(321, "set_mempolicy", kInt, kHex, kInt),
-    MakeEntry(322, "openat", kGen, kPath, kOct, kHex, kGen, kGen),
-    MakeEntry(323, "mkdirat", kInt, kPath, kOct),
-    MakeEntry(324, "mknodat", kInt, kPath, kOct, kHex),
-    MakeEntry(325, "fchownat", kInt, kPath, kInt, kInt, kHex),
-    MakeEntry(326, "futimesat", kInt, kPath, kHex),
-    MakeEntry(327, "fstatat64", kHex, kHex, kHex, kHex),
-    MakeEntry(328, "unlinkat", kInt, kPath, kHex),
-    MakeEntry(329, "renameat", kGen, kPath, kGen, kPath),
-    MakeEntry(330, "linkat", kInt, kPath, kInt, kPath, kHex),
-    MakeEntry(331, "symlinkat", kPath, kGen, kPath),
-    MakeEntry(332, "readlinkat", kInt, kPath, kHex, kInt),
-    MakeEntry(333, "fchmodat", kInt, kPath, kOct, kHex),
-    MakeEntry(334, "faccessat", kInt, kPath, kHex, kHex),
-    MakeEntry(335, "pselect6", kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(336, "ppoll", kHex, kInt, kHex, kHex, kInt),
-    MakeEntry(337, "unshare", kHex),
-    MakeEntry(338, "set_robust_list", kGen, kGen),
-    MakeEntry(339, "get_robust_list", kInt, kHex, kHex),
-    MakeEntry(340, "splice", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(342, "tee", kGen, kGen, kGen, kGen),
-    MakeEntry(343, "vmsplice", kGen, kGen, kGen, kGen),
-    MakeEntry(344, "move_pages", kInt, kInt, kHex, kHex, kHex, kHex),
-    MakeEntry(345, "getcpu", kHex, kHex, kHex),
-    MakeEntry(346, "epoll_pwait", kInt, kHex, kInt, kInt, kHex, kInt),
-    MakeEntry(347, "kexec_load", kGen, kGen, kGen, kGen),
-    MakeEntry(348, "utimensat", kGen, kGen, kGen, kGen),
-    MakeEntry(349, "signalfd", kInt, kHex, kHex),
-    MakeEntry(350, "timerfd_create", kInt, kHex),
+    MakeEntry(317, "inotify_add_watch", kResource, kPath, kFlags),
+    MakeEntry(318, "inotify_rm_watch", kResource, kResource),
+    MakeEntry(319, "mbind", kPtr, kLen0, kFlags, kPtr, kInt, kFlags),
+    MakeEntry(320, "get_mempolicy", kPtr, kPtr, kInt, kPtr, kFlags),
+    MakeEntry(321, "set_mempolicy", kFlags, kPtr, kInt),
+    MakeEntry(322, "openat", kResource, kPath, kFlags, kFlags),
+    MakeEntry(323, "mkdirat", kResource, kPath, kFlags),
+    MakeEntry(324, "mknodat", kResource, kPath, kFlags, kInt),
+    MakeEntry(325, "fchownat", kResource, kPath, kUid, kGid, kFlags),
+    MakeEntry(326, "futimesat", kResource, kPath, kPtr),
+    MakeEntry(327, "fstatat64", kInt, kPath, kPtr, kFlags),
+    MakeEntry(328, "unlinkat", kResource, kPath, kFlags),
+    MakeEntry(329, "renameat", kResource, kPath, kResource, kPath),
+    MakeEntry(330, "linkat", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(331, "symlinkat", kPath, kResource, kPath),
+    MakeEntry(332, "readlinkat", kResource, kPath, kArray, kLen2),
+    MakeEntry(333, "fchmodat", kResource, kPath, kFlags),
+    MakeEntry(334, "faccessat", kResource, kPath, kFlags),
+    MakeEntry(335, "pselect6", kLen1, kPtr, kPtr, kPtr, kPtr, kPtr),
+    MakeEntry(336, "ppoll", kPollFdArray, kLen0, kPtr, kPtr, kLen3),
+    MakeEntry(337, "unshare", kFlags),
+    MakeEntry(338, "set_robust_list", kPtr, kLen0),
+    MakeEntry(339, "get_robust_list", kPid, kPtr, kPtr),
+    MakeEntry(340, "splice", kResource, kPtr, kResource, kPtr, kInt, kFlags),
+    MakeEntry(342, "tee", kResource, kResource, kInt, kFlags),
+    MakeEntry(343, "vmsplice", kResource, kArray, kLen1, kFlags),
+    MakeEntry(344, "move_pages", kPid, kLen2, kArray, kArray, kArray, kFlags),
+    MakeEntry(345, "getcpu", kPtr, kPtr),
+    MakeEntry(346, "epoll_pwait", kResource, kArray, kLen1, kInt, kPtr, kLen4),
+    MakeEntry(347, "kexec_load", kInt, kLen2, kArray, kFlags),
+    MakeEntry(348, "utimensat", kResource, kPath, kPtr, kFlags),
+    MakeEntry(349, "signalfd", kResource, kPtr, kLen1),
+    MakeEntry(350, "timerfd_create", kFlags, kFlags),
     MakeEntry(351, "eventfd", kInt),
-    MakeEntry(352, "fallocate", kGen, kGen, kGen, kGen),
-    MakeEntry(353, "timerfd_settime", kGen, kGen, kGen, kGen),
-    MakeEntry(354, "timerfd_gettime", kInt, kHex),
-    MakeEntry(355, "signalfd4", kGen, kGen, kGen, kGen),
-    MakeEntry(356, "eventfd2", kInt, kHex),
-    MakeEntry(357, "epoll_create1", kHex),
-    MakeEntry(358, "dup3", kGen, kGen, kGen),
-    MakeEntry(359, "pipe2", kHex, kHex),
-    MakeEntry(360, "inotify_init1", kHex),
-    MakeEntry(361, "preadv", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(362, "pwritev", kInt, kHex, kInt, kInt, kInt),
-    MakeEntry(363, "rt_tgsigqueueinfo", kGen, kGen, kGen, kGen),
-    MakeEntry(364, "perf_event_open", kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(365, "recvmmsg", kInt, kHex, kInt, kHex, kHex),
-    MakeEntry(366, "accept4", kGen, kGen, kGen, kGen),
-    MakeEntry(367, "fanotify_init", kHex, kHex, kHex, kHex),
-    MakeEntry(368, "fanotify_mark", kInt, kHex, kHex, kInt, kPath),
-    MakeEntry(369, "prlimit64", kHex, kHex, kHex, kHex),
-    MakeEntry(370, "name_to_handle_at", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(371, "open_by_handle_at", kHex, kHex, kHex, kHex),
-    MakeEntry(372, "clock_adjtime", kHex, kHex, kHex, kHex),
-    MakeEntry(373, "syncfs", kHex, kHex, kHex, kHex),
-    MakeEntry(374, "sendmmsg", kHex, kHex, kHex, kHex),
-    MakeEntry(375, "setns", kHex, kHex, kHex, kHex),
-    MakeEntry(376, "process_vm_readv", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(377, "process_vm_writev", kInt, kHex, kInt, kHex, kInt, kInt),
-    MakeEntry(378, "kcmp", kInt, kInt, kInt, kInt, kInt),
-    MakeEntry(379, "finit_module", kHex, kHex, kHex, kHex),
-    MakeEntry(380, "sched_setattr", kInt, kHex, kHex),
-    MakeEntry(381, "sched_getattr", kGen, kGen, kGen, kGen),
-    MakeEntry(382, "renameat2", kGen, kPath, kGen, kPath, kGen, kGen),
-    MakeEntry(383, "seccomp", kInt, kHex, kHex),
-    MakeEntry(384, "getrandom", kGen, kInt, kHex),
-    MakeEntry(385, "memfd_create", kString, kHex),
-    MakeEntry(386, "bpf", kHex, kHex, kHex, kHex),
-    MakeEntry(387, "execveat", kInt, kPath, kHex, kHex, kHex),
-    MakeEntry(388, "userfaultfd", kHex),
-    MakeEntry(389, "membarrier", kHex, kHex),
-    MakeEntry(390, "mlock2", kHex, kHex, kHex, kHex),
-    MakeEntry(391, "copy_file_range", kInt, kHex, kInt, kHex, kInt, kHex),
-    MakeEntry(392, "preadv2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(393, "pwritev2", kInt, kHex, kInt, kInt, kInt, kHex),
-    MakeEntry(400, "migrate_pages", kGen, kGen, kGen, kGen),
-    MakeEntry(401, "kexec_file_load", kInt, kInt, kInt, kString, kHex),
-    MakeEntry(435, "clone3", kHex, kInt),
-    MakeEntry(436, "close_range", kInt, kInt, kHex),
-    MakeEntry(437, "openat2", kInt, kPath, kHex, kInt),
-    MakeEntry(438, "pidfd_getfd", UnknownArguments()),
-    MakeEntry(439, "faccessat2", kInt, kPath, kHex, kHex),
-    MakeEntry(440, "process_madvise", UnknownArguments()),
-    MakeEntry(441, "epoll_pwait2", UnknownArguments()),
-    MakeEntry(442, "mount_setattr", UnknownArguments()),
+    MakeEntry(352, "fallocate", kResource, kFlags, kInt, kInt),
+    MakeEntry(353, "timerfd_settime", kResource, kFlags, kPtr, kPtr),
+    MakeEntry(354, "timerfd_gettime", kResource, kPtr),
+    MakeEntry(355, "signalfd4", kResource, kPtr, kLen1, kFlags),
+    MakeEntry(356, "eventfd2", kInt, kFlags),
+    MakeEntry(357, "epoll_create1", kFlags),
+    MakeEntry(358, "dup3", kResource, kResource, kFlags),
+    MakeEntry(359, "pipe2", kPtr, kFlags),
+    MakeEntry(360, "inotify_init1", kFlags),
+    MakeEntry(361, "preadv", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(362, "pwritev", kResource, kArray, kLen1, kInt, kInt),
+    MakeEntry(363, "rt_tgsigqueueinfo", kPid, kPid, kSignal, kPtr),
+    MakeEntry(364, "perf_event_open", kPtr, kPid, kInt, kResource, kFlags),
+    MakeEntry(365, "recvmmsg", kResource, kArray, kLen1, kFlags, kPtr),
+    MakeEntry(366, "accept4", kResource, kPtr, kPtr, kFlags),
+    MakeEntry(367, "fanotify_init", kFlags, kFlags),
+    MakeEntry(368, "fanotify_mark", kResource, kFlags, kFlags, kResource,
+              kPath),
+    MakeEntry(369, "prlimit64", kPid, kFlags, kPtr, kPtr),
+    MakeEntry(370, "name_to_handle_at", kResource, kPath, kPtr, kPtr, kFlags),
+    MakeEntry(371, "open_by_handle_at", kResource, kPtr, kFlags),
+    MakeEntry(372, "clock_adjtime", kFlags, kPtr),
+    MakeEntry(373, "syncfs", kResource),
+    MakeEntry(374, "sendmmsg", kResource, kArray, kLen1, kFlags),
+    MakeEntry(375, "setns", kResource, kFlags),
+    MakeEntry(376, "process_vm_readv", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(377, "process_vm_writev", kPid, kArray, kLen1, kArray, kLen3,
+              kInt),
+    MakeEntry(378, "kcmp", kPid, kPid, kFlags, kResource, kResource),
+    MakeEntry(379, "finit_module", kResource, kString, kFlags),
+    MakeEntry(380, "sched_setattr", kPid, kPtr, kInt),
+    MakeEntry(381, "sched_getattr", kPid, kPtr, kLen1, kInt),
+    MakeEntry(382, "renameat2", kResource, kPath, kResource, kPath, kFlags),
+    MakeEntry(383, "seccomp", kInt, kFlags, kPtr),
+    MakeEntry(384, "getrandom", kArray, kLen0, kFlags),
+    MakeEntry(385, "memfd_create", kString, kFlags),
+    MakeEntry(386, "bpf", kInt, kPtr, kLen1),
+    MakeEntry(387, "execveat", kResource, kPath, kArray, kArray, kFlags),
+    MakeEntry(388, "userfaultfd", kFlags),
+    MakeEntry(389, "membarrier", kFlags, kInt),
+    MakeEntry(390, "mlock2", kPtr, kLen0, kFlags),
+    MakeEntry(391, "copy_file_range", kResource, kPtr, kResource, kPtr, kInt,
+              kFlags),
+    MakeEntry(392, "preadv2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(393, "pwritev2", kResource, kArray, kLen1, kInt, kInt, kFlags),
+    MakeEntry(400, "migrate_pages", kPid, kInt, kPtr, kPtr),
+    MakeEntry(401, "kexec_file_load", kInt, kInt, kInt, kString, kInt),
+    MakeEntry(435, "clone3", kPtr, kLen0),
+    MakeEntry(436, "close_range", kResource, kResource, kFlags),
+    MakeEntry(437, "openat2", kResource, kPath, kPtr, kLen2),
+    MakeEntry(438, "pidfd_getfd", kResource, kResource, kInt),
+    MakeEntry(439, "faccessat2", kResource, kPath, kFlags, kFlags),
+    MakeEntry(440, "process_madvise", kResource, kArray, kLen1, kFlags, kInt),
+    MakeEntry(441, "epoll_pwait2", kResource, kArray, kLen1, kPtr, kPtr, kLen4),
+    MakeEntry(442, "mount_setattr", kResource, kPath, kFlags, kPtr, kLen3),
     MakeEntry(443, "quotactl_fd", UnknownArguments()),
-    MakeEntry(444, "landlock_create_ruleset", UnknownArguments()),
-    MakeEntry(445, "landlock_add_rule", UnknownArguments()),
-    MakeEntry(446, "landlock_restrict_self", UnknownArguments()),
-    MakeEntry(448, "process_mrelease", UnknownArguments()),
-    MakeEntry(449, "futex_waitv", UnknownArguments()),
-    MakeEntry(450, "set_mempolicy_home_node", UnknownArguments()),
-    MakeEntry(451, "cachestat", UnknownArguments()),
-    MakeEntry(452, "fchmodat2", kInt, kPath, kHex, kHex),
-    MakeEntry(453, "map_shadow_stack", UnknownArguments()),
+    MakeEntry(444, "landlock_create_ruleset", kPtr, kLen0, kInt),
+    MakeEntry(445, "landlock_add_rule", kResource, kInt, kPtr, kInt),
+    MakeEntry(446, "landlock_restrict_self", kResource, kInt),
+    MakeEntry(448, "process_mrelease", kResource, kInt),
+    MakeEntry(449, "futex_waitv", kArray, kLen0, kInt, kPtr, kFlags),
+    MakeEntry(450, "set_mempolicy_home_node", kPtr, kLen0, kInt, kInt),
+    MakeEntry(451, "cachestat", kResource, kPtr, kPtr, kInt),
+    MakeEntry(452, "fchmodat2", kInt, kPath, kInt, kInt),
+    MakeEntry(453, "map_shadow_stack", kPtr, kLen0, kFlags),
     MakeEntry(454, "futex_wake", UnknownArguments()),
     MakeEntry(455, "futex_wait", UnknownArguments()),
     MakeEntry(456, "futex_requeue", UnknownArguments()),
@@ -1995,11 +2095,11 @@ constexpr std::array kSyscallDataArm32 = {
     MakeEntry(459, "lsm_get_self_attr", UnknownArguments()),
     MakeEntry(460, "lsm_set_self_attr", UnknownArguments()),
     MakeEntry(461, "lsm_list_modules", UnknownArguments()),
-    MakeEntry(0xf0001, "ARM_breakpoint", kHex, kHex, kHex, kHex),
-    MakeEntry(0xf0002, "ARM_cacheflush", kHex, kHex, kHex, kHex),
-    MakeEntry(0xf0003, "ARM_usr26", kHex, kHex, kHex, kHex),
-    MakeEntry(0xf0004, "ARM_usr32", kHex, kHex, kHex, kHex),
-    MakeEntry(0xf0005, "ARM_set_tls", kHex, kHex, kHex, kHex),
+    MakeEntry(0xf0001, "ARM_breakpoint", UnknownArguments()),
+    MakeEntry(0xf0002, "ARM_cacheflush", UnknownArguments()),
+    MakeEntry(0xf0003, "ARM_usr26", UnknownArguments()),
+    MakeEntry(0xf0004, "ARM_usr32", UnknownArguments()),
+    MakeEntry(0xf0005, "ARM_set_tls", UnknownArguments()),
     // clang-format on
 };
 
diff --git a/sandboxed_api/sandbox2/syscall_defs.h b/sandboxed_api/sandbox2/syscall_defs.h
index 1fbf3dc..55b21f2 100644
--- a/sandboxed_api/sandbox2/syscall_defs.h
+++ b/sandboxed_api/sandbox2/syscall_defs.h
@@ -4,36 +4,200 @@
 #include <sys/types.h>
 
 #include <array>
+#include <cstddef>
 #include <cstdint>
+#include <optional>
 #include <string>
+#include <type_traits>
 #include <vector>
 
+#include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
 #include "sandboxed_api/config.h"
-#include "sandboxed_api/sandbox2/syscall.h"
+#include "sandboxed_api/sandbox2/util.h"
+#include "sandboxed_api/util/status_macros.h"
 
 namespace sandbox2 {
 namespace syscalls {
 
 constexpr int kMaxArgs = 6;
 
-// Type of a given syscall argument. Used with argument conversion routines.
 enum ArgType {
-  kGen = 1,
-  kInt,
   kPath,
-  kHex,
-  kOct,
-  kSocketCall,
-  kSocketCallPtr,
-  kSignal,
   kString,
+  kGen,
+  kStruct,
+  kPtr,
+  kArray,
+  kInt,
+  kFlags,
+  kResource,
+  kPid,
+  kSignal,
+  kIpcResource,
+  kSharedAddress,
+  kGid,
+  kUid,
+  // These kLenN types indicate that the argument is a length, and which
+  // other argument it applies to. I.e., if parameter 3 is type kPollFdArray,
+  // and parameter 4 has the length, then parameter 4 is of type kLen3.
+  kLen0,
+  kLen1,
+  kLen2,
+  kLen3,
+  kLen4,
+  kLen5,
   kAddressFamily,
+  kGidArray,
+  kPollFdArray,
   kSockaddr,
-  kSockmsghdr,
-  kCloneFlag,
+};
+
+constexpr absl::string_view ArgTypeToString(ArgType type) {
+  switch (type) {
+    case kPath:
+      return "path";
+    case kString:
+      return "string";
+    case kGen:
+      return "generic type";
+    case kStruct:
+      return "struct";
+    case kPtr:
+      return "pointer";
+    case kArray:
+      return "array";
+    case kInt:
+      return "int";
+    case kFlags:
+      return "flags";
+    case kResource:
+      return "resource";
+    case kPid:
+      return "pid";
+    case kSignal:
+      return "signal";
+    case kIpcResource:
+      return "ipc resource";
+    case kSharedAddress:
+      return "shared address";
+    case kGid:
+      return "gid";
+    case kUid:
+      return "uid";
+    case kLen0:
+      return "length of parameter 0";
+    case kLen1:
+      return "length of parameter 1";
+    case kLen2:
+      return "length of parameter 2";
+    case kLen3:
+      return "length of parameter 3";
+    case kLen4:
+      return "length of parameter 4";
+    case kLen5:
+      return "length of parameter 5";
+    case kAddressFamily:
+      return "address family";
+    case kGidArray:
+      return "gid array";
+    case kPollFdArray:
+      return "poll fd array";
+    case kSockaddr:
+      return "sockaddr struct";
+    default:
+      return "invalid type";
+  }
+}
+
+class ArgData {
+ public:
+  template <typename T>
+  struct StructArray {
+    std::vector<T> array;
+    bool truncated;
+  };
+
+  ArgData(syscalls::ArgType type, pid_t pid, uint64_t value,
+          std::optional<uint64_t> length = std::nullopt)
+      : type_(type), pid_(pid), value_(value), length_(length) {}
+
+  ArgType type() const { return type_; }
+  pid_t pid() const { return pid_; }
+  uint64_t value() const { return value_; }
+  std::optional<uint64_t> length() const { return length_; }
+
+  std::string GetDescription() const;
+
+  absl::StatusOr<std::string> ReadAsString() const {
+    return util::ReadCPathFromPid(pid_, value_);
+  }
+
+  template <typename T>
+  absl::StatusOr<T> ReadAsStruct() const {
+    if (length_.has_value() && *length_ < sizeof(T)) {
+      return absl::InternalError(absl::StrFormat(
+          "specified length [%llu] is not enough for to sizeof(%s) == %llu",
+          *length_, "(struct)", sizeof(T))); // ANDROID: typeid removed, no rtti
+    }
+    SAPI_ASSIGN_OR_RETURN(std::vector<uint8_t> b,
+                          util::ReadBytesFromPid(pid_, value_, sizeof(T)));
+    return BytesToStruct<T>(b);
+  }
+
+  template <typename T>
+  absl::StatusOr<StructArray<T>> ReadAsStructArray() const {
+    static uint64_t kMaxAllowedBytes = 1 << 20;  // 1MB
+
+    if (!length_.has_value()) {
+      return absl::InternalError("length is not set");
+    }
+
+    bool truncated = false;
+    uint64_t length = *length_ * sizeof(T);
+    if (length > kMaxAllowedBytes) {
+      truncated = true;
+      length = (kMaxAllowedBytes / sizeof(T)) * sizeof(T);
+    }
+
+    SAPI_ASSIGN_OR_RETURN(std::vector<uint8_t> b,
+                          util::ReadBytesFromPid(pid_, value_, length));
+    absl::Span<const uint8_t> bytes = absl::MakeSpan(b);
+    if (bytes.size() < length) {
+      return absl::InternalError("could not read full struct array");
+    }
+    std::vector<T> ret;
+    for (size_t i = 0; i < bytes.size(); i += sizeof(T)) {
+      SAPI_ASSIGN_OR_RETURN(T t, BytesToStruct<T>(bytes.subspan(i, sizeof(T))));
+      ret.push_back(t);
+    }
+
+    return StructArray<T>{std::move(ret), truncated};
+  }
+
+ private:
+  template <typename T>
+  static absl::StatusOr<T> BytesToStruct(absl::Span<const uint8_t> bytes) {
+    static_assert(std::is_pod<T>(), "Can only cast bytes to POD structs");
+    if (bytes.size() < sizeof(T)) {
+      return absl::InternalError(absl::StrFormat(
+          "bytes size [%llu] is not equal to sizeof(%s) == %llu", bytes.size(),
+          "struct", sizeof(T))); // ANDROID: typeid removed, no rtti
+    }
+    T t;
+    memcpy(&t, bytes.data(), sizeof(T));
+    return t;
+  }
+
+  absl::StatusOr<std::string> GetDescriptionImpl() const;
+
+  syscalls::ArgType type_;
+  pid_t pid_;
+  uint64_t value_;
+  std::optional<uint64_t> length_;
 };
 
 }  // namespace syscalls
@@ -50,10 +214,6 @@ class SyscallTable {
       return num_args;
     }
 
-    static std::string GetArgumentDescription(uint64_t value,
-                                              syscalls::ArgType type,
-                                              pid_t pid);
-
     static constexpr bool BySyscallNr(const SyscallTable::Entry& a,
                                       const SyscallTable::Entry& b) {
       return a.nr < b.nr;
@@ -72,6 +232,10 @@ class SyscallTable {
 
   absl::string_view GetName(int syscall) const;
 
+  std::vector<syscalls::ArgData> GetArgumentsData(int syscall,
+                                                  const uint64_t values[],
+                                                  pid_t pid) const;
+
   std::vector<std::string> GetArgumentsDescription(int syscall,
                                                    const uint64_t values[],
                                                    pid_t pid) const;
diff --git a/sandboxed_api/sandbox2/testcases/BUILD.bazel b/sandboxed_api/sandbox2/testcases/BUILD
similarity index 66%
rename from sandboxed_api/sandbox2/testcases/BUILD.bazel
rename to sandboxed_api/sandbox2/testcases/BUILD
index 7ba8141..f49485c 100644
--- a/sandboxed_api/sandbox2/testcases/BUILD.bazel
+++ b/sandboxed_api/sandbox2/testcases/BUILD
@@ -27,10 +27,10 @@
 # any networking and none of the functionality from cstdio/stdio.h (due to
 # auto-loading of locale-specific shared objecs).
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -41,7 +41,7 @@ cc_binary(
     srcs = ["abort.cc"],
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
-    deps = ["//sandboxed_api/util:raw_logging"],
+    deps = ["@com_google_sandboxed_api//sandboxed_api/util:raw_logging"],
 )
 
 cc_binary(
@@ -59,7 +59,7 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api/sandbox2:buffer",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:buffer",
     ],
 )
 
@@ -70,10 +70,10 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -115,9 +115,9 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -128,8 +128,22 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api:config",
         "@com_google_absl//absl/base:core_headers",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+    ],
+)
+
+cc_binary(
+    name = "sandbox_detection",
+    testonly = True,
+    srcs = ["sandbox_detection.cc"],
+    copts = sapi_platform_copts(),
+    features = ["fully_static_link"],
+    deps = [
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
     ],
 )
 
@@ -147,11 +161,11 @@ cc_binary(
     srcs = ["close_fds.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:sanitizer",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:sanitizer",
     ],
 )
 
@@ -187,9 +201,9 @@ cc_binary(
     features = ["fully_static_link"],
     deps = [
         ":symbolize_lib",
-        "//sandboxed_api/util:raw_logging",
         "@com_google_absl//absl/base:core_headers",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -200,8 +214,8 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
     ],
 )
 
@@ -228,12 +242,12 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:fileops",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
     ],
 )
 
@@ -243,11 +257,6 @@ cc_binary(
     srcs = ["network_proxy.cc"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2:client",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/network_proxy:client",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/base:log_severity",
         "@com_google_absl//absl/flags:flag",
         "@com_google_absl//absl/flags:parse",
@@ -259,6 +268,11 @@ cc_binary(
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/strings:string_view",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:client",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/network_proxy:client",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
@@ -269,8 +283,35 @@ cc_binary(
     copts = sapi_platform_copts(),
     features = ["fully_static_link"],
     deps = [
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2:forkingclient",
-        "//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:forkingclient",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+    ],
+)
+
+cc_binary(
+    name = "util_communicate",
+    testonly = True,
+    srcs = ["util_communicate.cc"],
+    copts = sapi_platform_copts(),
+)
+
+cc_binary(
+    name = "posix_timers",
+    testonly = True,
+    srcs = ["posix_timers.cc"],
+    copts = sapi_platform_copts(),
+    features = ["fully_static_link"],
+    linkopts = ["-lrt"],
+    deps = [
+        "@com_google_absl//absl/base:log_severity",
+        "@com_google_absl//absl/flags:flag",
+        "@com_google_absl//absl/flags:parse",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/log:globals",
+        "@com_google_absl//absl/log:initialize",
+        "@com_google_absl//absl/strings:string_view",
+        "@com_google_absl//absl/time",
     ],
 )
diff --git a/sandboxed_api/sandbox2/testcases/CMakeLists.txt b/sandboxed_api/sandbox2/testcases/CMakeLists.txt
index 43bde70..0ba0dd6 100644
--- a/sandboxed_api/sandbox2/testcases/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/testcases/CMakeLists.txt
@@ -151,8 +151,27 @@ set_target_properties(sandbox2_testcase_policy PROPERTIES
 target_link_libraries(sandbox2_testcase_policy PRIVATE
   -static
   absl::core_headers
+  sandbox2::client
+  sandbox2::comms
+  sandbox2::util
+  sapi::base
+)
+
+# sandboxed_api/sandbox2/testcases:sandbox_detection
+add_executable(sandbox2_testcase_sandbox_detection
+  sandbox_detection.cc
+)
+add_executable(sandbox2::testcase_policy ALIAS sandbox2_testcase_sandbox_detection)
+set_target_properties(sandbox2_testcase_sandbox_detection PROPERTIES
+  OUTPUT_NAME sandbox_detection
+)
+target_link_libraries(sandbox2_testcase_sandbox_detection PRIVATE
+  -static
+  absl::statusor
+  sandbox2::client
+  sandbox2::comms
+  sandbox2::util
   sapi::base
-  sapi::config
 )
 
 # sandboxed_api/sandbox2/testcases:sanitizer
@@ -337,4 +356,37 @@ target_link_libraries(sandbox2_testcase_custom_fork PRIVATE
   sapi::raw_logging
 )
 
+# sandboxed_api/sandbox2/testcases:util_communicate
+add_executable(sandbox2_testcase_util_communicate
+  util_communicate.cc
+)
+add_executable(sandbox2::testcase_util_communicate ALIAS sandbox2_testcase_util_communicate)
+set_target_properties(sandbox2_testcase_util_communicate PROPERTIES
+  OUTPUT_NAME util_communicate
+)
+target_link_libraries(sandbox2_testcase_util_communicate PRIVATE
+  sapi::base
+)
 
+# sandboxed_api/sandbox2/testcases:posix_timers
+add_executable(sandbox2_testcase_posix_timers
+  posix_timers.cc
+)
+add_executable(sandbox2::testcase_posix_timers ALIAS sandbox2_testcase_posix_timers)
+set_target_properties(sandbox2_testcase_posix_timers PROPERTIES
+  OUTPUT_NAME posix_timers
+)
+target_link_libraries(sandbox2_testcase_posix_timers PRIVATE
+  -static
+  -lrt
+  absl::check
+  absl::flags
+  absl::flags_parse
+  absl::log
+  absl::log_globals
+  absl::log_initialize
+  absl::log_severity
+  absl::strings
+  absl::time
+  sapi::base
+)
diff --git a/sandboxed_api/sandbox2/testcases/buffer.cc b/sandboxed_api/sandbox2/testcases/buffer.cc
index 94a070b..c25b030 100644
--- a/sandboxed_api/sandbox2/testcases/buffer.cc
+++ b/sandboxed_api/sandbox2/testcases/buffer.cc
@@ -17,6 +17,7 @@
 #include "sandboxed_api/sandbox2/buffer.h"
 
 #include <cstdint>
+#include <cstdlib>
 #include <utility>
 
 int main(int argc, char* argv[]) {
diff --git a/sandboxed_api/sandbox2/testcases/namespace.cc b/sandboxed_api/sandbox2/testcases/namespace.cc
index c37f7d4..4749a83 100644
--- a/sandboxed_api/sandbox2/testcases/namespace.cc
+++ b/sandboxed_api/sandbox2/testcases/namespace.cc
@@ -147,7 +147,15 @@ int main(int argc, char* argv[]) {
       result.push_back(hostname);
       break;
     }
-
+    case 8: {
+      constexpr char kNsNetPath[] = "/proc/self/ns/net";
+      std::string buf(100, '\0');
+      if (readlink(kNsNetPath, buf.data(), buf.size()) == -1) {
+        return -1;
+      }
+      result.push_back(buf);
+      break;
+    }
     default:
       return 1;
   }
diff --git a/sandboxed_api/sandbox2/testcases/posix_timers.cc b/sandboxed_api/sandbox2/testcases/posix_timers.cc
new file mode 100644
index 0000000..7308951
--- /dev/null
+++ b/sandboxed_api/sandbox2/testcases/posix_timers.cc
@@ -0,0 +1,117 @@
+#include <sys/syscall.h>
+#include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <atomic>
+#include <csignal>
+#include <string>
+
+#include "absl/base/log_severity.h"
+#include "absl/flags/flag.h"
+#include "absl/flags/parse.h"
+#include "absl/log/check.h"
+#include "absl/log/globals.h"
+#include "absl/log/initialize.h"
+#include "absl/log/log.h"
+#include "absl/strings/string_view.h"
+#include "absl/time/clock.h"
+#include "absl/time/time.h"
+
+ABSL_FLAG(std::string, sigev_notify_kind, "",
+          "The C name for the kind of POSIX timer to create (sigev_notify), or "
+          "\"syscall(SIGEV_THREAD)\" for a manual syscall approach which "
+          "checks that no threads were created.");
+
+int main(int argc, char* argv[]) {
+  absl::SetStderrThreshold(absl::LogSeverityAtLeast::kInfo);
+  absl::ParseCommandLine(argc, argv);
+  absl::InitializeLog();
+
+  static std::atomic<bool> timer_expired(false);
+  static std::atomic<pid_t> tid(0);
+  static_assert(std::atomic<pid_t>::is_always_lock_free);
+  // Handle SIGPROF by recording that it arrived.
+  signal(
+      SIGPROF, +[](int) {
+        timer_expired.store(true);
+        tid.store(syscall(__NR_gettid));
+      });
+
+  const std::string sigev_notify_kind = absl::GetFlag(FLAGS_sigev_notify_kind);
+  struct sigevent sev {};
+  sev.sigev_signo = SIGPROF;
+
+  if (sigev_notify_kind == "SIGEV_THREAD" ||
+      sigev_notify_kind == "syscall(SIGEV_THREAD)") {
+    sev.sigev_notify = SIGEV_THREAD;
+    sev.sigev_notify_function = +[](sigval_t) {
+      timer_expired.store(true);
+      tid.store(syscall(__NR_gettid));
+    };
+  } else if (sigev_notify_kind == "SIGEV_SIGNAL") {
+    sev.sigev_notify = SIGEV_SIGNAL;
+    sev.sigev_signo = SIGPROF;
+  } else if (sigev_notify_kind == "SIGEV_NONE") {
+    sev.sigev_notify = SIGEV_NONE;
+  } else if (sigev_notify_kind == "SIGEV_THREAD_ID") {
+    sev.sigev_notify = SIGEV_THREAD_ID;
+    sev.sigev_signo = SIGPROF;
+#ifndef sigev_notify_thread_id
+    sev._sigev_un._tid = syscall(__NR_gettid);
+#else
+    sev.sigev_notify_thread_id = syscall(__NR_gettid);
+#endif
+  } else {
+    LOG(QFATAL) << "Invalid --sigev_notify_kind: " << sigev_notify_kind;
+  }
+
+  struct itimerspec timerspec {};
+  timerspec.it_interval.tv_sec = 0;
+  timerspec.it_interval.tv_nsec = 1'000'000;
+  timerspec.it_value.tv_sec = 0;
+  timerspec.it_value.tv_nsec = 1'000'000;
+
+  if (sigev_notify_kind == "syscall(SIGEV_THREAD)") {
+    // Use raw syscalls.
+    int timer;
+    PCHECK(syscall(__NR_timer_create, CLOCK_REALTIME, &sev, &timer) == 0);
+    PCHECK(syscall(__NR_timer_settime, timer, 0, &timerspec, nullptr) == 0);
+
+    // Long enough to effectively guarantee that we see the notification.
+    absl::SleepFor(absl::Milliseconds(30));
+
+    PCHECK(syscall(__NR_timer_gettime, timer, &timerspec) == 0);
+    PCHECK(syscall(__NR_timer_getoverrun, timer) != -1);
+
+    PCHECK(syscall(__NR_timer_delete, timer) == 0);
+
+    // The syscall with SIGEV_THREAD doesn't spawn a thread, which we can verify
+    // by checking that the thread ID is the main thread.
+    CHECK_EQ(tid.load(), syscall(__NR_gettid));
+  } else {
+    timer_t timer;
+    PCHECK(timer_create(CLOCK_REALTIME, &sev, &timer) == 0);
+    PCHECK(timer_settime(timer, 0, &timerspec, nullptr) == 0);
+
+    // Long enough to effectively guarantee that we see the notification.
+    absl::SleepFor(absl::Milliseconds(30));
+
+    PCHECK(timer_gettime(timer, &timerspec) == 0);
+    PCHECK(timer_getoverrun(timer) != -1);
+
+    PCHECK(timer_delete(timer) == 0);
+  }
+
+  if (sigev_notify_kind == "SIGEV_THREAD" ||
+      sigev_notify_kind == "syscall(SIGEV_THREAD)" ||
+      sigev_notify_kind == "SIGEV_THREAD_ID" ||
+      sigev_notify_kind == "SIGEV_SIGNAL") {
+    CHECK(timer_expired.load());
+  } else {
+    CHECK_EQ(sigev_notify_kind, "SIGEV_NONE");
+    CHECK(!timer_expired.load());
+  }
+
+  return 0;
+}
diff --git a/sandboxed_api/sandbox2/testcases/sandbox_detection.cc b/sandboxed_api/sandbox2/testcases/sandbox_detection.cc
new file mode 100644
index 0000000..55abb3d
--- /dev/null
+++ b/sandboxed_api/sandbox2/testcases/sandbox_detection.cc
@@ -0,0 +1,68 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// A binary that tries to detect if it is running under sandbox2.
+
+#include <cstdio>
+#include <cstdlib>
+#include <string>
+
+#include "absl/status/statusor.h"
+#include "sandboxed_api/sandbox2/client.h"
+#include "sandboxed_api/sandbox2/comms.h"
+#include "sandboxed_api/sandbox2/util.h"
+
+namespace {
+
+int TestSandboxSyscall() {
+  absl::StatusOr<bool> is_running_under_sandbox2 =
+      sandbox2::util::IsRunningInSandbox2();
+  if (!is_running_under_sandbox2.ok()) {
+    printf("Failed to check if running under sandbox2: %s\n",
+           std::string(is_running_under_sandbox2.status().message()).c_str());
+    return EXIT_FAILURE;
+  }
+  if (*is_running_under_sandbox2) {
+    printf("Failed to correctly detect not running under sandbox2\n");
+    return EXIT_FAILURE;
+  }
+
+  // Activate the sandbox and call the util::kMagicSyscallNo syscall again.
+  auto comms = sandbox2::Comms(sandbox2::Comms::kSandbox2ClientCommsFD);
+  sandbox2::Client client(&comms);
+  client.SandboxMeHere();
+  is_running_under_sandbox2 = sandbox2::util::IsRunningInSandbox2();
+  if (!is_running_under_sandbox2.ok()) {
+    printf("Failed to check if running under sandbox2: %s\n",
+           std::string(is_running_under_sandbox2.status().message()).c_str());
+    return EXIT_FAILURE;
+  }
+  if (!*is_running_under_sandbox2) {
+    printf("Failed to correctly detect not running under sandbox2\n");
+    return EXIT_FAILURE;
+  }
+
+  return EXIT_SUCCESS;
+}
+
+}  // namespace
+
+int main(int argc, char* argv[]) {
+  // Disable buffering.
+  setbuf(stdin, nullptr);
+  setbuf(stdout, nullptr);
+  setbuf(stderr, nullptr);
+
+  return TestSandboxSyscall();
+}
diff --git a/sandboxed_api/sandbox2/testcases/symbolize.cc b/sandboxed_api/sandbox2/testcases/symbolize.cc
index 5022947..ec834fb 100644
--- a/sandboxed_api/sandbox2/testcases/symbolize.cc
+++ b/sandboxed_api/sandbox2/testcases/symbolize.cc
@@ -52,7 +52,8 @@ void ExitNormally(int x = 0) {
   IndirectLibcCall([x]() {
     // _exit is marked noreturn, which makes stack traces a bit trickier -
     // work around by using a volatile read
-    if (volatile int y = 1) {
+    volatile int y = 1;
+    if (y) {
       _exit(x);
     }
   });
@@ -80,6 +81,19 @@ void RunTest(int testno) {
     case 4:
       SleepForXSeconds(10);
       break;
+    case 5: {
+      constexpr int kMaxForks = 16;
+      for (int i = 0; i < kMaxForks; ++i) {
+        if (fork() == 0) {
+          if (i == kMaxForks - 1) {
+            ViolatePolicy();
+          }
+          break;
+        }
+      }
+      SleepForXSeconds(10);
+      break;
+    }
     default:
       SAPI_RAW_LOG(FATAL, "Unknown test case: %d", testno);
   }
diff --git a/sandboxed_api/sandbox2/testcases/util_communicate.cc b/sandboxed_api/sandbox2/testcases/util_communicate.cc
new file mode 100644
index 0000000..62098a4
--- /dev/null
+++ b/sandboxed_api/sandbox2/testcases/util_communicate.cc
@@ -0,0 +1,27 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// A binary to test util::Communicate.
+
+#include <iostream>
+
+int main(int argc, char* argv[], const char* env[]) {
+  std::cout << argc << '\n';
+  for (int i = 1; i < argc; ++i) {
+    std::cout << argv[i] << '\n';
+  }
+  for (const char** envp = env; *envp; ++envp) {
+    std::cout << *envp << '\n';
+  }
+}
diff --git a/sandboxed_api/sandbox2/trace_all_syscalls.h b/sandboxed_api/sandbox2/trace_all_syscalls.h
index d387cc3..43dc3b4 100644
--- a/sandboxed_api/sandbox2/trace_all_syscalls.h
+++ b/sandboxed_api/sandbox2/trace_all_syscalls.h
@@ -15,13 +15,6 @@
 #ifndef SANDBOXED_API_SANDBOX2_TRACE_ALL_SYSCALLS_H_
 #define SANDBOXED_API_SANDBOX2_TRACE_ALL_SYSCALLS_H_
 
-namespace sandbox2 {
-
-class TraceAllSyscalls {
- public:
-  explicit TraceAllSyscalls() = default;
-};
-
-}  // namespace sandbox2
+#include "sandboxed_api/sandbox2/allowlists/trace_all_syscalls.h"  // IWYU pragma: export
 
 #endif  // SANDBOXED_API_SANDBOX2_ALLOW_ALL_SYSCALLS_H_
diff --git a/sandboxed_api/sandbox2/unwind/BUILD.bazel b/sandboxed_api/sandbox2/unwind/BUILD
similarity index 61%
rename from sandboxed_api/sandbox2/unwind/BUILD.bazel
rename to sandboxed_api/sandbox2/unwind/BUILD
index e45be26..4de6b34 100644
--- a/sandboxed_api/sandbox2/unwind/BUILD.bazel
+++ b/sandboxed_api/sandbox2/unwind/BUILD
@@ -12,11 +12,11 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
 
 package(default_visibility = [
-    "//sandboxed_api/sandbox2:__subpackages__",
+    "@com_google_sandboxed_api//sandboxed_api/sandbox2:__subpackages__",
 ])
 
 licenses(["notice"])
@@ -27,8 +27,8 @@ cc_library(
     hdrs = ["ptrace_hook.h"],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/sandbox2/util:syscall_trap",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:syscall_trap",
     ],
 )
 
@@ -36,25 +36,22 @@ cc_library(
     name = "unwind",
     srcs = ["unwind.cc"],
     hdrs = ["unwind.h"],
-    copts = sapi_platform_copts([
-        # TODO(cblichmann): Remove this, fix bazel/external/libunwind.BUILD
-        "-Iexternal/org_gnu_libunwind/include",
-    ]),
+    copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
         ":ptrace_hook",
         ":unwind_cc_proto",
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2:comms",
-        "//sandboxed_api/sandbox2/util:maps_parser",
-        "//sandboxed_api/sandbox2/util:minielf",
-        "//sandboxed_api/util:file_helpers",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/cleanup",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:comms",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:maps_parser",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2/util:minielf",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_helpers",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
         "@org_gnu_libunwind//:unwind-ptrace",
     ],
 )
diff --git a/sandboxed_api/sandbox2/unwind/ptrace_hook.cc b/sandboxed_api/sandbox2/unwind/ptrace_hook.cc
index c73086f..5f864d5 100644
--- a/sandboxed_api/sandbox2/unwind/ptrace_hook.cc
+++ b/sandboxed_api/sandbox2/unwind/ptrace_hook.cc
@@ -29,12 +29,7 @@
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/sandbox2/util/syscall_trap.h"
 
-// Android doesn't use an enum for __ptrace_request, use int instead.
-#if defined(__ANDROID__)
-using PtraceRequest = int;
-#else
 using PtraceRequest = __ptrace_request;
-#endif
 
 namespace sandbox2 {
 namespace {
diff --git a/sandboxed_api/sandbox2/util.cc b/sandboxed_api/sandbox2/util.cc
index 2ed22d6..0925c9f 100644
--- a/sandboxed_api/sandbox2/util.cc
+++ b/sandboxed_api/sandbox2/util.cc
@@ -14,15 +14,19 @@
 
 #include "sandboxed_api/sandbox2/util.h"
 
+#include <fcntl.h>
+#include <linux/limits.h>
 #include <sched.h>
 #include <spawn.h>
 #include <sys/ptrace.h>
 #include <sys/resource.h>
+#include <sys/socket.h>
 #include <sys/uio.h>
 #include <sys/wait.h>
 #include <syscall.h>
 #include <unistd.h>
 
+#include <algorithm>
 #include <cerrno>
 #include <csetjmp>
 #include <cstddef>
@@ -33,6 +37,7 @@
 #include <utility>
 #include <vector>
 
+#include "absl/algorithm/container.h"
 #include "absl/base/attributes.h"
 #include "absl/base/macros.h"
 #include "absl/base/optimization.h"
@@ -46,13 +51,16 @@
 #include "absl/strings/str_replace.h"
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
+#include "absl/types/span.h"
 #include "sandboxed_api/config.h"
 #include "sandboxed_api/util/file_helpers.h"
 #include "sandboxed_api/util/fileops.h"
 #include "sandboxed_api/util/path.h"
 #include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/util/status_macros.h"
 
-namespace sandbox2::util {
+namespace sandbox2 {
+namespace util {
 
 namespace file = ::sapi::file;
 namespace file_util = ::sapi::file_util;
@@ -137,6 +145,19 @@ std::string GetProgName(pid_t pid) {
   return file_util::fileops::Basename(file_util::fileops::ReadLink(fname));
 }
 
+absl::StatusOr<std::string> GetResolvedFdLink(pid_t pid, uint32_t fd) {
+  // The proc/PID/fd directory contains links for all of that process' file
+  // descriptors. They'll show up as more informative strings (paths, sockets).
+  std::string fd_path = absl::StrFormat("/proc/%u/fd/%u", pid, fd);
+  std::string result(PATH_MAX, '\0');
+  ssize_t size = readlink(fd_path.c_str(), &result[0], PATH_MAX);
+  if (size < 0) {
+    return absl::ErrnoToStatus(size, "failed to read link");
+  }
+  result.resize(size);
+  return result;
+}
+
 std::string GetCmdLine(pid_t pid) {
   std::string fname = file::JoinPath("/proc", absl::StrCat(pid), "cmdline");
   std::string cmdline;
@@ -326,6 +347,29 @@ std::string GetSignalName(int signo) {
   return absl::StrFormat("%s [%d]", kSignalNames[signo], signo);
 }
 
+std::string GetAddressFamily(int addr_family) {
+  // Taken from definitions in `socket.h`. Each family's index in the array is
+  // also its integer value.
+  constexpr absl::string_view kAddressFamilies[] = {
+      "AF_UNSPEC",     "AF_UNIX",      "AF_INET",     "AF_AX25",
+      "AF_IPX",        "AF_APPLETALK", "AF_NETROM",   "AF_BRIDGE",
+      "AF_ATMPVC",     "AF_X25",       "AF_INET6",    "AF_ROSE",
+      "AF_DECnet",     "AF_NETBEUI",   "AF_SECURITY", "AF_KEY",
+      "AF_NETLINK",    "AF_PACKET",    "AF_ASH",      "AF_ECONET",
+      "AF_ATMSVC",     "AF_RDS",       "AF_SNA",      "AF_IRDA",
+      "AF_PPPOX",      "AF_WANPIPE",   "AF_LLC",      "AF_IB",
+      "AF_MPLS",       "AF_CAN",       "AF_TIPC",     "AF_BLUETOOTH",
+      "AF_IUCV",       "AF_RXRPC",     "AF_ISDN",     "AF_PHONET",
+      "AF_IEEE802154", "AF_CAIF",      "AF_ALG",      "AF_NFC",
+      "AF_VSOCK",      "AF_KCM",       "AF_QIPCRTR",  "AF_SMC",
+      "AF_XDP",        "AF_MCTP"};
+
+  if (addr_family < 0 && addr_family >= ABSL_ARRAYSIZE(kAddressFamilies)) {
+    return absl::StrFormat("UNKNOWN_ADDRESS_FAMILY [%d]", addr_family);
+  }
+  return std::string(kAddressFamilies[addr_family]);
+}
+
 std::string GetRlimitName(int resource) {
   switch (resource) {
     case RLIMIT_AS:
@@ -370,45 +414,255 @@ std::string GetPtraceEventName(int event) {
   }
 }
 
-absl::StatusOr<std::string> ReadCPathFromPid(pid_t pid, uintptr_t ptr) {
-  std::string path(PATH_MAX, '\0');
-  iovec local_iov[] = {{&path[0], path.size()}};
+namespace {
 
+// Transfer memory via process_vm_readv/process_vm_writev in page-aligned
+// chunks.
+absl::StatusOr<size_t> ProcessVmTransfer(bool is_read, pid_t pid, uintptr_t ptr,
+                                         absl::Span<char> data) {
+  // Input sanity checks.
+  if (data.empty()) {
+    return 0;
+  }
+
+  size_t total_bytes_transferred = 0;
+  while (!data.empty()) {
+    iovec local_iov = {data.data(), data.size()};
+    iovec remote_iov = {reinterpret_cast<void*>(ptr), data.size()};
+    ssize_t bytes_transferred =
+        is_read ? process_vm_readv(pid, &local_iov, 1, &remote_iov, 1, 0)
+                : process_vm_writev(pid, &local_iov, 1, &remote_iov, 1, 0);
+    if (bytes_transferred == 0) {
+      if (total_bytes_transferred > 0) {
+        return total_bytes_transferred;
+      }
+      return absl::NotFoundError(absl::StrFormat(
+          "Transfer was unsuccessful for PID: %d at address: %#x", pid, ptr));
+    } else if (bytes_transferred < 0) {
+      if (total_bytes_transferred > 0) {
+        return total_bytes_transferred;
+      }
+      return absl::ErrnoToStatus(
+          errno,
+          absl::StrFormat("transfer() failed for PID: %d at address: %#x", pid,
+                          ptr));
+    }
+    ptr += bytes_transferred;
+    data = data.subspan(bytes_transferred, data.size() - bytes_transferred);
+    total_bytes_transferred += bytes_transferred;
+  }
+  return total_bytes_transferred;
+}
+
+// Transfer memory via process_vm_readv.
+absl::StatusOr<size_t> ProcessVmReadInSplitChunks(pid_t pid, uintptr_t ptr,
+                                                  absl::Span<char> data) {
   static const uintptr_t page_size = getpagesize();
-  static const uintptr_t page_mask = ~(page_size - 1);
-  // See 'man process_vm_readv' for details on how to read NUL-terminated
-  // strings with this syscall.
-  size_t len1 = ((ptr + page_size) & page_mask) - ptr;
-  len1 = (len1 > path.size()) ? path.size() : len1;
-  size_t len2 = (path.size() <= len1) ? 0UL : path.size() - len1;
-  // Second iov is wrapping around to NULL ptr.
-  if ((ptr + len1) < ptr) {
-    len2 = 0UL;
-  }
-
-  iovec remote_iov[] = {
-      {reinterpret_cast<void*>(ptr), len1},
-      {reinterpret_cast<void*>(ptr + len1), len2},
-  };
-
-  SAPI_RAW_VLOG(4, "ReadCPathFromPid (iovec): len1: %zu, len2: %zu", len1,
-                len2);
-  if (process_vm_readv(pid, local_iov, ABSL_ARRAYSIZE(local_iov), remote_iov,
-                       ABSL_ARRAYSIZE(remote_iov), 0) < 0) {
+  static const uintptr_t page_mask = page_size - 1;
+
+  // Input sanity checks.
+  if (data.empty()) {
+    return 0;
+  }
+
+  // Repeatedly call process_vm_readv/writev in IOV_MAX iovec chunks.
+  size_t total_bytes_transferred = 0;
+  while (!data.empty()) {
+    // Stores all the necessary iovecs to move memory.
+    iovec local_iov = {data.data(), 0};
+    // Stores all the necessary iovecs to move memory.
+    std::vector<iovec> remote_iov;
+    // Each iovec should be contained to a single page.
+    while (!data.empty() && remote_iov.size() < IOV_MAX) {
+      size_t size_in_page = page_size - (ptr & page_mask);
+      size_t chunk_size = std::min(data.size(), size_in_page);
+      remote_iov.push_back({reinterpret_cast<void*>(ptr), chunk_size});
+      local_iov.iov_len += chunk_size;
+      ptr += chunk_size;
+      data = data.subspan(chunk_size, data.size() - chunk_size);
+    }
+    ssize_t bytes_transferred = process_vm_readv(
+        pid, &local_iov, 1, remote_iov.data(), remote_iov.size(), 0);
+    if (bytes_transferred == 0) {
+      if (total_bytes_transferred == 0) {
+        return absl::NotFoundError(absl::StrFormat(
+            "Transfer was unsuccessful for PID: %d at address: %#x", pid, ptr));
+      }
+      break;
+    } else if (bytes_transferred < 0) {
+      return absl::ErrnoToStatus(
+          errno,
+          absl::StrFormat("transfer() failed for PID: %d at address: %#x", pid,
+                          ptr));
+    }
+    total_bytes_transferred += bytes_transferred;
+    if (bytes_transferred < local_iov.iov_len) {
+      // Read to end of a mapped region (short of full transfer).
+      break;
+    }
+  }
+  return total_bytes_transferred;
+}
+
+// Open /proc/pid/mem file descriptor.
+absl::StatusOr<file_util::fileops::FDCloser> OpenProcMem(pid_t pid,
+                                                         bool is_read) {
+  auto path = absl::StrFormat("/proc/%d/mem", pid);
+  auto closer = file_util::fileops::FDCloser(
+      open(path.c_str(), is_read ? O_RDONLY : O_WRONLY));
+  if (closer.get() == -1) {
     return absl::ErrnoToStatus(
-        errno,
-        absl::StrFormat("process_vm_readv() failed for PID: %d at address: %#x",
-                        pid, reinterpret_cast<uintptr_t>(ptr)));
+        errno, absl::StrFormat("open() failed for PID: %d", pid));
   }
+  return closer;
+}
 
-  // Check for whether there's a NUL byte in the buffer. If not, it's an
-  // incorrect path (or >PATH_MAX).
-  auto pos = path.find('\0');
-  if (pos == std::string::npos) {
-    return absl::FailedPreconditionError(absl::StrCat(
-        "No NUL-byte inside the C string '", absl::CHexEscape(path), "'"));
+absl::StatusOr<size_t> ProcMemTransfer(bool is_read, pid_t pid, uintptr_t ptr,
+                                       absl::Span<char> data) {
+  if (data.empty()) {
+    return 0;
+  }
+
+  SAPI_ASSIGN_OR_RETURN(file_util::fileops::FDCloser fd_closer,
+                        OpenProcMem(pid, is_read));
+  size_t total_bytes_transferred = 0;
+  while (!data.empty()) {
+    ssize_t bytes_transfered =
+        is_read ? pread(fd_closer.get(), data.data(), data.size(), ptr)
+                : pwrite(fd_closer.get(), data.data(), data.size(), ptr);
+    if (bytes_transfered == 0) {
+      if (total_bytes_transferred == 0) {
+        return absl::NotFoundError(absl::StrFormat(
+            "Transfer was unsuccessful for PID: %d at address: %#x", pid, ptr));
+      }
+      break;
+    } else if (bytes_transfered < 0) {
+      if (total_bytes_transferred > 0) {
+        // Return number of bytes transferred until this error or end.
+        break;
+      }
+      // pread/write of /proc/<pid>mem returns EIO when ptr is unmapped.
+      if (errno == EIO) {
+        // Emulate returned error code from process_vm_readv.
+        errno = EFAULT;
+      }
+      return absl::ErrnoToStatus(
+          errno,
+          absl::StrFormat("transfer() failed for PID: %d at address: %#x", pid,
+                          ptr));
+    }
+    ptr += bytes_transfered;
+    data = data.subspan(bytes_transfered, data.size() - bytes_transfered);
+    total_bytes_transferred += bytes_transfered;
+  }
+  return total_bytes_transferred;
+}
+
+bool CheckIfProcessVmTransferWorks() {
+  // Fall-back to pread("/proc/$pid/mem") if process_vm_readv is unavailable.
+  static bool process_vm_transfer_works = []() {
+    constexpr char kMagic = 42;
+    char src = kMagic;
+    char dst = 0;
+    absl::StatusOr<size_t> read = internal::ReadBytesFromPidWithReadv(
+        getpid(), reinterpret_cast<uintptr_t>(&src), absl::MakeSpan(&dst, 1));
+    if (!read.ok() || *read != 1 || dst != kMagic) {
+      SAPI_RAW_LOG(WARNING,
+                   "This system does not seem to support the process_vm_readv()"
+                   " or process_vm_writev syscall. Falling back to transfers"
+                   " via /proc/pid/mem.");
+      return false;
+    }
+    return true;
+  }();
+  return process_vm_transfer_works;
+}
+
+}  // namespace
+
+namespace internal {
+
+absl::StatusOr<size_t> ReadBytesFromPidWithReadv(pid_t pid, uintptr_t ptr,
+                                                 absl::Span<char> data) {
+  return ProcessVmTransfer(true, pid, ptr, data);
+}
+
+absl::StatusOr<size_t> WriteBytesToPidWithWritev(pid_t pid, uintptr_t ptr,
+                                                 absl::Span<const char> data) {
+  return ProcessVmTransfer(
+      false, pid, ptr,
+      absl::MakeSpan(const_cast<char*>(data.data()), data.size()));
+}
+
+absl::StatusOr<size_t> ReadBytesFromPidWithProcMem(pid_t pid, uintptr_t ptr,
+                                                   absl::Span<char> data) {
+  return ProcMemTransfer(true, pid, ptr, data);
+}
+
+absl::StatusOr<size_t> ReadBytesFromPidWithReadvInSplitChunks(
+    pid_t pid, uintptr_t ptr, absl::Span<char> data) {
+  return ProcessVmReadInSplitChunks(pid, ptr, data);
+}
+
+absl::StatusOr<size_t> WriteBytesToPidWithProcMem(pid_t pid, uintptr_t ptr,
+                                                  absl::Span<const char> data) {
+  return ProcMemTransfer(
+      false, pid, ptr,
+      absl::MakeSpan(const_cast<char*>(data.data()), data.size()));
+}
+
+}  // namespace internal
+
+absl::StatusOr<size_t> ReadBytesFromPidInto(pid_t pid, uintptr_t ptr,
+                                            absl::Span<char> data) {
+  if (CheckIfProcessVmTransferWorks()) {
+    return internal::ReadBytesFromPidWithReadv(pid, ptr, data);
+  } else {
+    return internal::ReadBytesFromPidWithProcMem(pid, ptr, data);
+  }
+}
+
+absl::StatusOr<size_t> WriteBytesToPidFrom(pid_t pid, uintptr_t ptr,
+                                           absl::Span<const char> data) {
+  if (CheckIfProcessVmTransferWorks()) {
+    return internal::WriteBytesToPidWithWritev(pid, ptr, data);
+  } else {
+    return internal::WriteBytesToPidWithProcMem(pid, ptr, data);
+  }
+}
+
+absl::StatusOr<std::vector<uint8_t>> ReadBytesFromPid(pid_t pid, uintptr_t ptr,
+                                                      size_t size) {
+  // Allocate enough bytes to hold the entire size.
+  std::vector<uint8_t> bytes(size, 0);
+  size_t result;
+  if (CheckIfProcessVmTransferWorks()) {
+    SAPI_ASSIGN_OR_RETURN(
+        result,
+        ProcessVmReadInSplitChunks(
+            pid, ptr,
+            absl::MakeSpan(reinterpret_cast<char*>(bytes.data()), size)));
+  } else {
+    SAPI_ASSIGN_OR_RETURN(
+        result,
+        internal::ReadBytesFromPidWithProcMem(
+            pid, ptr,
+            absl::MakeSpan(reinterpret_cast<char*>(bytes.data()), size)));
+  }
+  // Ensure only successfully read bytes are returned.
+  bytes.resize(result);
+  return bytes;
+}
+
+absl::StatusOr<std::string> ReadCPathFromPid(pid_t pid, uintptr_t ptr) {
+  SAPI_ASSIGN_OR_RETURN(std::vector<uint8_t> bytes,
+                        ReadBytesFromPid(pid, ptr, PATH_MAX));
+  auto null_pos = absl::c_find(bytes, '\0');
+  std::string path(bytes.begin(), null_pos);
+  if (null_pos == bytes.end()) {
+    return absl::FailedPreconditionError(
+        absl::StrFormat("path '%s' is too long", absl::CHexEscape(path)));
   }
-  path.resize(pos);
   return path;
 }
 
@@ -430,4 +684,30 @@ int Execveat(int dirfd, const char* pathname, const char* const argv[],
   return res;
 }
 
-}  // namespace sandbox2::util
+absl::StatusOr<bool> IsRunningInSandbox2() {
+  // Check if the kMagicSyscallNo syscall is available.
+  int result = Syscall(sandbox2::internal::kMagicSyscallNo);
+  if (result == 0) {
+    // If this happens, then someone has implemented the kMagicSyscallNo syscall
+    // and it is returning 0.
+    return absl::InternalError(
+        "kMagicSyscallNo syscall succeeded unexpectedly");
+  }
+
+  // The caller is not running under a sandbox2.
+  if (errno == ENOSYS) {
+    return false;
+  }
+
+  // The caller is running under a sandbox2.
+  if (errno == sandbox2::internal::kMagicSyscallErr) {
+    return true;
+  }
+
+  // An unexpected errno was returned.
+  return absl::InternalError(absl::StrFormat(
+      "Unexpected errno for syscall kMagicSyscallNo: %d", errno));
+}
+
+}  // namespace util
+}  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/util.h b/sandboxed_api/sandbox2/util.h
index d171dc9..9cda752 100644
--- a/sandboxed_api/sandbox2/util.h
+++ b/sandboxed_api/sandbox2/util.h
@@ -20,15 +20,27 @@
 
 #include <sys/types.h>
 
+#include <cstddef>
 #include <cstdint>
 #include <string>
 #include <vector>
 
-#include "absl/base/attributes.h"
 #include "absl/base/macros.h"
 #include "absl/status/statusor.h"
+#include "absl/types/span.h"
 
-namespace sandbox2::util {
+namespace sandbox2 {
+
+namespace internal {
+
+// Magic values used to detect if the current process is running inside
+// Sandbox2.
+inline constexpr int64_t kMagicSyscallNo = 0xff000fdb;  // 4278194139
+inline constexpr int kMagicSyscallErr = 0x000000fdb;    // 4059
+
+}  // namespace internal
+
+namespace util {
 
 void DumpCoverageData();
 
@@ -54,7 +66,7 @@ class CharPtrArray {
 
 // Converts an array of char* (terminated by a nullptr, like argv, or environ
 // arrays), to an std::vector<std::string>.
-ABSL_DEPRECATED("Use CharPtrArray(arr).ToStringVector() instead")
+ABSL_DEPRECATE_AND_INLINE()
 inline void CharPtrArrToVecString(char* const* arr,
                                   std::vector<std::string>* vec) {
   *vec = sandbox2::util::CharPtrArray(arr).ToStringVector();
@@ -63,6 +75,9 @@ inline void CharPtrArrToVecString(char* const* arr,
 // Returns the program name (via /proc/self/comm) for a given PID.
 std::string GetProgName(pid_t pid);
 
+// Given a resource descriptor FD and a PID, returns link of /proc/PID/fds/FD.
+absl::StatusOr<std::string> GetResolvedFdLink(pid_t pid, uint32_t fd);
+
 // Returns the command line (via /proc/self/cmdline) for a given PID. The
 // argument separators '\0' are converted to spaces.
 std::string GetCmdLine(pid_t pid);
@@ -95,12 +110,53 @@ absl::StatusOr<int> Communicate(const std::vector<std::string>& argv,
 // Returns signal description.
 std::string GetSignalName(int signo);
 
+// Returns the socket address family as a string ("AF_INET", ...)
+std::string GetAddressFamily(int addr_family);
+
 // Returns rlimit resource name
 std::string GetRlimitName(int resource);
 
 // Returns ptrace event name
 std::string GetPtraceEventName(int event);
 
+namespace internal {
+// Reads `data`'s length of bytes from `ptr` in `pid`, returns number of bytes
+// read or an error.
+absl::StatusOr<size_t> ReadBytesFromPidWithReadv(pid_t pid, uintptr_t ptr,
+                                                 absl::Span<char> data);
+
+// Writes `data` to `ptr` in `pid`, returns number of bytes written or an error.
+absl::StatusOr<size_t> WriteBytesToPidWithWritev(pid_t pid, uintptr_t ptr,
+                                                 absl::Span<const char> data);
+
+// Reads `data`'s length of bytes from `ptr` in `pid`, returns number of bytes
+// read or an error.
+absl::StatusOr<size_t> ReadBytesFromPidWithReadvInSplitChunks(
+    pid_t pid, uintptr_t ptr, absl::Span<char> data);
+
+// Reads `data`'s length of bytes from `ptr` in `pid`, returns number of bytes
+// read or an error.
+absl::StatusOr<size_t> ReadBytesFromPidWithProcMem(pid_t pid, uintptr_t ptr,
+                                                   absl::Span<char> data);
+
+// Writes `data` to `ptr` in `pid`, returns number of bytes written or an error.
+absl::StatusOr<size_t> WriteBytesToPidWithProcMem(pid_t pid, uintptr_t ptr,
+                                                  absl::Span<const char> data);
+};  // namespace internal
+
+// Reads `data`'s length of bytes from `ptr` in `pid`, returns number of bytes
+// read or an error.
+absl::StatusOr<size_t> ReadBytesFromPidInto(pid_t pid, uintptr_t ptr,
+                                            absl::Span<char> data);
+
+// Writes `data` to `ptr` in `pid`, returns number of bytes written or an error.
+absl::StatusOr<size_t> WriteBytesToPidFrom(pid_t pid, uintptr_t remote_ptr,
+                                           absl::Span<const char> data);
+
+// Reads `size` bytes from the given `ptr` address, or returns an error.
+absl::StatusOr<std::vector<uint8_t>> ReadBytesFromPid(pid_t pid, uintptr_t ptr,
+                                                      size_t size);
+
 // Reads a path string (NUL-terminated, shorter than PATH_MAX) from another
 // process memory
 absl::StatusOr<std::string> ReadCPathFromPid(pid_t pid, uintptr_t ptr);
@@ -109,6 +165,10 @@ absl::StatusOr<std::string> ReadCPathFromPid(pid_t pid, uintptr_t ptr);
 int Execveat(int dirfd, const char* pathname, const char* const argv[],
              const char* const envp[], int flags, uintptr_t extra_arg = 0);
 
-}  // namespace sandbox2::util
+// Returns true if the current process is running inside Sandbox2.
+absl::StatusOr<bool> IsRunningInSandbox2();
+
+}  // namespace util
+}  // namespace sandbox2
 
 #endif  // SANDBOXED_API_SANDBOX2_UTIL_H_
diff --git a/sandboxed_api/sandbox2/util/BUILD b/sandboxed_api/sandbox2/util/BUILD
new file mode 100644
index 0000000..c003e71
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/BUILD
@@ -0,0 +1,179 @@
+# Copyright 2019 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+
+DEFAULT_VISIBILITY = [
+    "@com_google_sandboxed_api//sandboxed_api:__subpackages__",
+]
+
+package(default_visibility = DEFAULT_VISIBILITY)
+
+licenses(["notice"])
+
+cc_library(
+    name = "bpf_helper",
+    srcs = ["bpf_helper.c"],
+    hdrs = ["bpf_helper.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+)
+
+cc_test(
+    name = "bpf_helper_test",
+    srcs = ["bpf_helper_test.cc"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":bpf_helper",
+        "@com_google_absl//absl/strings",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+cc_library(
+    name = "minielf",
+    srcs = ["minielf.cc"],
+    hdrs = ["minielf.h"],
+    copts = sapi_platform_copts(),
+    visibility = ["//visibility:public"],
+    deps = [
+        "@com_google_absl//absl/base:endian",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
+    ],
+)
+
+cc_test(
+    name = "minielf_test",
+    srcs = ["minielf_test.cc"],
+    copts = sapi_platform_copts(),
+    data = [
+        ":testdata/chrome_grte_header",
+        ":testdata/hello_world",
+    ],
+    features = ["-dynamic_link_test_srcs"],  # see go/dynamic_link_test_srcs
+    deps = [
+        ":maps_parser",
+        ":minielf",
+        "@com_google_absl//absl/algorithm:container",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_helpers",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+    ],
+)
+
+cc_library(
+    name = "syscall_trap",
+    srcs = ["syscall_trap.cc"],
+    hdrs = ["syscall_trap.h"],
+    copts = sapi_platform_copts(),
+    deps = [
+        "@com_google_absl//absl/log:check",
+        "@com_google_sandboxed_api//sandboxed_api:config",
+    ],
+)
+
+cc_library(
+    name = "deadline_manager",
+    srcs = ["deadline_manager.cc"],
+    hdrs = ["deadline_manager.h"],
+    copts = sapi_platform_copts(),
+    deps = [
+        "@com_google_absl//absl/base",
+        "@com_google_absl//absl/base:core_headers",
+        "@com_google_absl//absl/base:no_destructor",
+        "@com_google_absl//absl/container:btree",
+        "@com_google_absl//absl/flags:flag",
+        "@com_google_absl//absl/functional:function_ref",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/strings:string_view",
+        "@com_google_absl//absl/synchronization",
+        "@com_google_absl//absl/time",
+        "@com_google_sandboxed_api//sandboxed_api/sandbox2:util",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
+    ],
+)
+
+cc_test(
+    name = "deadline_manager_test",
+    srcs = ["deadline_manager_test.cc"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":deadline_manager",
+        "@com_google_absl//absl/flags:flag",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/time",
+        "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
+    ],
+)
+
+cc_library(
+    name = "maps_parser",
+    srcs = ["maps_parser.cc"],
+    hdrs = ["maps_parser.h"],
+    copts = sapi_platform_copts(),
+    deps = [
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings",
+    ],
+)
+
+cc_test(
+    name = "maps_parser_test",
+    srcs = ["maps_parser_test.cc"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":maps_parser",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
+    ],
+)
+
+cc_library(
+    name = "pid_waiter",
+    srcs = ["pid_waiter.cc"],
+    hdrs = ["pid_waiter.h"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":deadline_manager",
+        "@com_google_absl//absl/base:core_headers",
+        "@com_google_absl//absl/cleanup",
+        "@com_google_absl//absl/synchronization",
+        "@com_google_absl//absl/time",
+    ],
+)
+
+cc_test(
+    name = "pid_waiter_test",
+    srcs = ["pid_waiter_test.cc"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":pid_waiter",
+        "@com_google_absl//absl/time",
+        "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/util:thread",
+    ],
+)
diff --git a/sandboxed_api/sandbox2/util/BUILD.bazel b/sandboxed_api/sandbox2/util/BUILD.bazel
deleted file mode 100644
index 89bc522..0000000
--- a/sandboxed_api/sandbox2/util/BUILD.bazel
+++ /dev/null
@@ -1,110 +0,0 @@
-# Copyright 2019 Google LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-
-_DEFAULT_VISIBILITY = [
-    "//sandboxed_api:__subpackages__",
-]
-
-package(default_visibility = _DEFAULT_VISIBILITY)
-
-package_group(
-    name = "minielf_users",
-    packages = [
-    ],
-)
-
-licenses(["notice"])
-
-cc_library(
-    name = "bpf_helper",
-    srcs = ["bpf_helper.c"],
-    hdrs = ["bpf_helper.h"],
-    visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "minielf",
-    srcs = ["minielf.cc"],
-    hdrs = ["minielf.h"],
-    copts = sapi_platform_copts(),
-    visibility = _DEFAULT_VISIBILITY + [":minielf_users"],
-    deps = [
-        "//sandboxed_api:config",
-        "//sandboxed_api/sandbox2:util",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:status",
-        "@com_google_absl//absl/base:endian",
-        "@com_google_absl//absl/status",
-        "@com_google_absl//absl/status:statusor",
-        "@com_google_absl//absl/strings",
-    ],
-)
-
-cc_test(
-    name = "minielf_test",
-    srcs = ["minielf_test.cc"],
-    copts = sapi_platform_copts(),
-    data = [
-        ":testdata/chrome_grte_header",
-        ":testdata/hello_world",
-    ],
-    features = ["-dynamic_link_test_srcs"],  # see go/dynamic_link_test_srcs
-    deps = [
-        ":maps_parser",
-        ":minielf",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:file_helpers",
-        "//sandboxed_api/util:status_matchers",
-        "@com_google_absl//absl/algorithm:container",
-        "@com_google_absl//absl/status:statusor",
-        "@com_google_googletest//:gtest_main",
-    ],
-)
-
-cc_library(
-    name = "syscall_trap",
-    srcs = ["syscall_trap.cc"],
-    hdrs = ["syscall_trap.h"],
-    copts = sapi_platform_copts(),
-    deps = [
-        "//sandboxed_api:config",
-        "@com_google_absl//absl/log:check",
-    ],
-)
-
-cc_library(
-    name = "maps_parser",
-    srcs = ["maps_parser.cc"],
-    hdrs = ["maps_parser.h"],
-    copts = sapi_platform_copts(),
-    deps = [
-        "@com_google_absl//absl/status",
-        "@com_google_absl//absl/status:statusor",
-        "@com_google_absl//absl/strings",
-    ],
-)
-
-cc_test(
-    name = "maps_parser_test",
-    srcs = ["maps_parser_test.cc"],
-    copts = sapi_platform_copts(),
-    deps = [
-        ":maps_parser",
-        "//sandboxed_api/util:status_matchers",
-        "@com_google_absl//absl/status:statusor",
-        "@com_google_googletest//:gtest_main",
-    ],
-)
diff --git a/sandboxed_api/sandbox2/util/CMakeLists.txt b/sandboxed_api/sandbox2/util/CMakeLists.txt
index c7297bb..93d7b4b 100644
--- a/sandboxed_api/sandbox2/util/CMakeLists.txt
+++ b/sandboxed_api/sandbox2/util/CMakeLists.txt
@@ -61,6 +61,46 @@ target_link_libraries(sandbox2_util_syscall_trap
           sapi::config
 )
 
+# sandboxed_api/sandbox2/util:pid_waiter
+add_library(sandbox2_util_pid_waiter ${SAPI_LIB_TYPE}
+  pid_waiter.cc
+  pid_waiter.h
+)
+add_library(sandbox2::pid_waiter ALIAS sandbox2_util_pid_waiter)
+target_link_libraries(sandbox2_util_pid_waiter
+  PUBLIC absl::core_headers
+         absl::cleanup
+         absl::synchronization
+         absl::time
+         sandbox2::deadline_manager
+  PRIVATE sapi::base
+)
+
+
+# sandboxed_api/sandbox2/util:deadline_manager
+add_library(sandbox2_util_deadline_manager ${SAPI_LIB_TYPE}
+  deadline_manager.cc
+  deadline_manager.h
+)
+add_library(sandbox2::deadline_manager ALIAS sandbox2_util_deadline_manager)
+target_link_libraries(sandbox2_util_deadline_manager
+  PUBLIC absl::btree
+         absl::core_headers
+         absl::flags
+         absl::function_ref
+         absl::no_destructor
+         absl::strings
+         absl::synchronization
+         absl::time
+         sapi::thread
+  PRIVATE absl::base
+          absl::check
+          absl::log
+          absl::strings
+          sandbox2::util
+          sapi::base
+)
+
 if(BUILD_TESTING AND SAPI_BUILD_TESTING)
   # sandboxed_api/sandbox2/util:minielf_test
   add_executable(sandbox2_minielf_test
@@ -103,4 +143,49 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     sapi::test_main
   )
   gtest_discover_tests_xcompile(sandbox2_maps_parser_test)
+
+  # sandboxed_api/sandbox2/util:bpf_helper_test
+  add_executable(sandbox2_bpf_helper_test
+    bpf_helper_test.cc
+  )
+  set_target_properties(sandbox2_bpf_helper_test PROPERTIES
+    OUTPUT_NAME bpf_helper_test
+  )
+  target_link_libraries(sandbox2_bpf_helper_test PRIVATE
+    absl::strings
+    sandbox2::bpf_helper
+    sapi::test_main
+  )
+  gtest_discover_tests_xcompile(sandbox2_bpf_helper_test)
+
+  # sandboxed_api/sandbox2/util:pid_waiter_test
+  add_executable(sandbox2_pid_waiter_test
+    pid_waiter_test.cc
+  )
+  set_target_properties(sandbox2_pid_waiter_test PROPERTIES
+    OUTPUT_NAME pid_waiter_test
+  )
+  target_link_libraries(sandbox2_pid_waiter_test PRIVATE
+    absl::time
+    sandbox2::pid_waiter
+    sapi::test_main
+    sapi::thread
+  )
+
+  # sandboxed_api/sandbox2/util:deadline_manager_test
+  add_executable(sandbox2_deadline_manager_test
+    deadline_manager_test.cc
+  )
+  set_target_properties(sandbox2_deadline_manager_test PROPERTIES
+    OUTPUT_NAME deadline_manager_test
+  )
+  target_link_libraries(sandbox2_deadline_manager_test PRIVATE
+    absl::check
+    absl::flags
+    absl::time
+    sandbox2::deadline_manager
+    sapi::test_main
+    sapi::thread
+  )
+  gtest_discover_tests_xcompile(sandbox2_deadline_manager_test)
 endif()
diff --git a/sandboxed_api/sandbox2/util/bpf_helper.c b/sandboxed_api/sandbox2/util/bpf_helper.c
index b12cebe..6893d1e 100644
--- a/sandboxed_api/sandbox2/util/bpf_helper.c
+++ b/sandboxed_api/sandbox2/util/bpf_helper.c
@@ -28,81 +28,80 @@
 #include <stdlib.h>
 #include <string.h>
 
-int bpf_resolve_jumps(struct bpf_labels *labels,
-		      struct sock_filter *filter, size_t count)
-{
-	size_t i;
-
-	if (count < 1 || count > BPF_MAXINSNS)
-		return -1;
-	/*
-	* Walk it once, backwards, to build the label table and do fixups.
-	* Since backward jumps are disallowed by BPF, this is easy.
-	*/
-	for (i = 0; i < count; ++i) {
-		size_t offset = count - i - 1;
-		struct sock_filter *instr = &filter[offset];
-		if (instr->code != (BPF_JMP+BPF_JA))
-			continue;
-		switch ((instr->jt<<8)|instr->jf) {
-		case (JUMP_JT<<8)|JUMP_JF:
-			if (labels->labels[instr->k].location == 0xffffffff) {
-				fprintf(stderr, "Unresolved label: '%s'\n",
-					labels->labels[instr->k].label);
-				return 1;
-			}
-			instr->k = labels->labels[instr->k].location -
-				    (offset + 1);
-			instr->jt = 0;
-			instr->jf = 0;
-			continue;
-		case (LABEL_JT<<8)|LABEL_JF:
-			if (labels->labels[instr->k].location != 0xffffffff) {
-				fprintf(stderr, "Duplicate label use: '%s'\n",
-					labels->labels[instr->k].label);
-				return 1;
-			}
-			labels->labels[instr->k].location = offset;
-			instr->k = 0; /* fall through */
-			instr->jt = 0;
-			instr->jf = 0;
-			continue;
-		}
-	}
-	return 0;
+int bpf_resolve_jumps(struct bpf_labels *labels, struct sock_filter *filter,
+                      size_t count) {
+  if (count < 1 || count > BPF_MAXINSNS) {
+    return -1;
+  }
+  if (labels->count > BPF_LABELS_MAX) {
+    return -1;
+  }
+  /*
+   * Walk it once, backwards, to build the label table and do fixups.
+   * Since backward jumps are disallowed by BPF, this is easy.
+   */
+  for (size_t i = 0; i < count; ++i) {
+    size_t offset = count - i - 1;
+    struct sock_filter *instr = &filter[offset];
+    if (instr->code != (BPF_JMP + BPF_JA)) {
+      continue;
+    }
+    if (instr->k >= labels->count) {
+      fprintf(stderr, "Label index out of bounds: '%d'\n", instr->k);
+      return 1;
+    }
+    switch ((instr->jt << 8) | instr->jf) {
+      case (JUMP_JT << 8) | JUMP_JF:
+        if (labels->labels[instr->k].location == 0xffffffff) {
+          fprintf(stderr, "Unresolved label: '%s'\n",
+                  labels->labels[instr->k].label);
+          return 1;
+        }
+        instr->k = labels->labels[instr->k].location - (offset + 1);
+        instr->jt = 0;
+        instr->jf = 0;
+        continue;
+      case (LABEL_JT << 8) | LABEL_JF:
+        if (labels->labels[instr->k].location != 0xffffffff) {
+          fprintf(stderr, "Duplicate label use: '%s'\n",
+                  labels->labels[instr->k].label);
+          return 1;
+        }
+        labels->labels[instr->k].location = offset;
+        instr->k = 0; /* fall through */
+        instr->jt = 0;
+        instr->jf = 0;
+        continue;
+    }
+  }
+  return 0;
 }
 
 /* Simple lookup table for labels. */
-__u32 seccomp_bpf_label(struct bpf_labels *labels, const char *label)
-{
-	struct __bpf_label *begin = labels->labels, *end;
-	int id;
+__u32 seccomp_bpf_label(struct bpf_labels *labels, const char *label) {
+  struct __bpf_label *begin = labels->labels;
+  struct __bpf_label *end = begin + labels->count;
 
-	if (labels->count == BPF_LABELS_MAX) {
-		fprintf(stderr, "Too many labels\n");
-		exit(1);
-	}
-	if (labels->count == 0) {
-		begin->label = label;
-		begin->location = 0xffffffff;
-		labels->count++;
-		return 0;
-	}
-	end = begin + labels->count;
-	for (id = 0; begin < end; ++begin, ++id) {
-		if (!strcmp(label, begin->label))
-			return id;
-	}
-	begin->label = label;
-	begin->location = 0xffffffff;
-	labels->count++;
-	return id;
+  if (labels->count > BPF_LABELS_MAX) {
+    return labels->count;
+  }
+  for (int id = 0; begin < end; ++begin, ++id) {
+    if (!strcmp(label, begin->label)) {
+      return id;
+    }
+  }
+  if (labels->count == BPF_LABELS_MAX) {
+    fprintf(stderr, "Too many labels\n");
+    return labels->count++;
+  }
+  begin->label = label;
+  begin->location = 0xffffffff;
+  return labels->count++;
 }
 
-void seccomp_bpf_print(struct sock_filter *filter, size_t count)
-{
-	struct sock_filter *end = filter + count;
-	for ( ; filter < end; ++filter)
-		printf("{ code=%u,jt=%u,jf=%u,k=%u },\n",
-			filter->code, filter->jt, filter->jf, filter->k);
+void seccomp_bpf_print(struct sock_filter *filter, size_t count) {
+  struct sock_filter *end = filter + count;
+  for (; filter < end; ++filter)
+    printf("{ code=%u,jt=%u,jf=%u,k=%u },\n", filter->code, filter->jt,
+           filter->jf, filter->k);
 }
diff --git a/sandboxed_api/sandbox2/util/bpf_helper_test.cc b/sandboxed_api/sandbox2/util/bpf_helper_test.cc
new file mode 100644
index 0000000..1f81c38
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/bpf_helper_test.cc
@@ -0,0 +1,89 @@
+#include "sandboxed_api/sandbox2/util/bpf_helper.h"
+
+#include <linux/filter.h>
+
+#include <string>
+#include <vector>
+
+#include "gtest/gtest.h"
+#include "absl/strings/str_cat.h"
+
+namespace {
+
+void AddMaxLabels(bpf_labels& labels) {
+  static std::vector<std::string>* label_strs = []() {
+    auto* label_strs = new std::vector<std::string>();
+    for (int i = 0; i < BPF_LABELS_MAX; ++i) {
+      label_strs->push_back(absl::StrCat("lbl", i));
+    }
+    return label_strs;
+  }();
+  for (int i = 0; i < BPF_LABELS_MAX; ++i) {
+    seccomp_bpf_label(&labels, (*label_strs)[i].c_str());
+  }
+}
+
+TEST(BpfHelperTest, MaxLabels) {
+  bpf_labels labels = {};
+  AddMaxLabels(labels);
+  std::vector<struct sock_filter> filter = {
+      ALLOW,
+  };
+  EXPECT_EQ(bpf_resolve_jumps(&labels, filter.data(), filter.size()), 0);
+}
+
+TEST(BpfHelperTest, LabelOverflow) {
+  bpf_labels labels = {};
+  AddMaxLabels(labels);
+  std::vector<struct sock_filter> filter = {
+      JUMP(&labels, overflow),
+      LABEL(&labels, overflow),
+      ALLOW,
+  };
+  filter.push_back(ALLOW);
+  EXPECT_NE(bpf_resolve_jumps(&labels, filter.data(), filter.size()), 0);
+}
+
+TEST(BpfHelperTest, UnresolvedLabel) {
+  bpf_labels labels = {};
+  std::vector<struct sock_filter> filter = {
+      JUMP(&labels, unresolved),
+      LABEL(&labels, unused),
+  };
+  filter.push_back(ALLOW);
+  EXPECT_NE(bpf_resolve_jumps(&labels, filter.data(), filter.size()), 0);
+}
+
+TEST(BpfHelperTest, BackwardJump) {
+  bpf_labels labels = {};
+  std::vector<struct sock_filter> filter = {
+      LABEL(&labels, backward),
+      JUMP(&labels, backward),
+  };
+  filter.push_back(ALLOW);
+  EXPECT_NE(bpf_resolve_jumps(&labels, filter.data(), filter.size()), 0);
+}
+
+TEST(BpfHelperTest, Duplicate) {
+  bpf_labels labels = {};
+  std::vector<struct sock_filter> filter = {
+      JUMP(&labels, dup),
+      LABEL(&labels, dup),
+      LABEL(&labels, dup),
+  };
+  filter.push_back(ALLOW);
+  EXPECT_NE(bpf_resolve_jumps(&labels, filter.data(), filter.size()), 0);
+}
+
+TEST(BpfHelperTest, OutOfBoundsLabel) {
+  bpf_labels labels = {};
+  std::vector<struct sock_filter> filter = {
+      JUMP(&labels, normal),
+      LABEL(&labels, normal),
+      BPF_JUMP(BPF_JMP + BPF_JA, 1, JUMP_JT, JUMP_JF),
+  };
+  filter.push_back(ALLOW);
+  EXPECT_NE(bpf_resolve_jumps(&labels, filter.data(), filter.size()), 0);
+}
+
+}  // namespace
diff --git a/sandboxed_api/sandbox2/util/deadline_manager.cc b/sandboxed_api/sandbox2/util/deadline_manager.cc
new file mode 100644
index 0000000..009559e
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/deadline_manager.cc
@@ -0,0 +1,199 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "sandboxed_api/sandbox2/util/deadline_manager.h"
+
+#include <sys/syscall.h>
+
+#include <algorithm>
+#include <csignal>
+#include <cstdint>
+#include <memory>
+#include <string>
+
+#include "absl/base/call_once.h"
+#include "absl/flags/flag.h"
+#include "absl/functional/function_ref.h"
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "absl/strings/str_cat.h"
+#include "absl/strings/string_view.h"
+#include "absl/synchronization/mutex.h"
+#include "absl/time/clock.h"
+#include "absl/time/time.h"
+#include "sandboxed_api/sandbox2/util.h"
+#include "sandboxed_api/util/thread.h"
+
+ABSL_FLAG(int, sandbox2_deadline_manager_signal, SIGRTMAX - 1,
+          "Signal to use for deadline notifications - must be not otherwise "
+          "used by the process (default: SIGRTMAX - 1)");
+
+namespace sandbox2 {
+namespace {
+constexpr int kFailedNotificationsThreshold = 32;
+
+absl::Time RoundUpTo(absl::Time time, absl::Duration resolution) {
+  return time == absl::InfiniteFuture()
+             ? absl::InfiniteFuture()
+             : absl::UnixEpoch() +
+                   absl::Ceil(time - absl::UnixEpoch(), resolution);
+}
+}  // namespace
+
+int DeadlineManager::signal_nr_ = -1;
+
+DeadlineRegistration::DeadlineRegistration(DeadlineManager& manager)
+    : manager_(manager) {
+  manager_.Register(*this);
+}
+
+DeadlineRegistration::~DeadlineRegistration() { manager_.Unregister(*this); }
+
+void DeadlineRegistration::SetDeadline(absl::Time deadline) {
+  if (deadline != last_deadline_) {
+    manager_.AdjustDeadline(*this, deadline);
+    last_deadline_ = deadline;
+  }
+}
+
+void DeadlineRegistration::ExecuteBlockingSyscall(
+    absl::FunctionRef<void()> blocking_fn) {
+  {
+    absl::MutexLock lock(&data_->mutex);
+    data_->tid = util::Syscall(__NR_gettid);
+    if (data_->notification_attempt > 0 || data_->deadline <= absl::Now()) {
+      return;
+    }
+    data_->in_blocking_fn = true;
+  }
+  blocking_fn();
+  {
+    absl::MutexLock lock(&data_->mutex);
+    data_->in_blocking_fn = false;
+  }
+}
+
+DeadlineManager::DeadlineManager(absl::string_view name) {
+  RegisterSignalHandler();
+  thread_ = sapi::Thread(this, &DeadlineManager::Run, name);
+}
+
+DeadlineManager::~DeadlineManager() {
+  {
+    absl::MutexLock lock(&registration_mutex_);
+    CHECK_EQ(registered_deadlines_, 0);
+  }
+  {
+    absl::MutexLock lock(&queue_mutex_);
+    cancelled_ = true;
+  }
+  if (thread_.IsJoinable()) {
+    thread_.Join();
+  }
+}
+
+void DeadlineManager::SignalHandler(int signal) {}
+
+void DeadlineManager::AdjustDeadline(DeadlineRegistration& registration,
+                                     absl::Time deadline) {
+  absl::MutexLock lock(&queue_mutex_);
+  queue_.erase(registration.data_.get());
+  absl::MutexLock data_lock(&registration.data_->mutex);
+  registration.data_->notification_attempt = 0;
+  registration.data_->deadline = RoundUpTo(deadline, kResolution);
+  if (deadline != absl::InfiniteFuture()) {
+    queue_.insert(registration.data_.get());
+  }
+}
+
+void DeadlineManager::RegisterSignalHandler() {
+  static absl::once_flag once;
+  absl::call_once(once, [] {
+    signal_nr_ = absl::GetFlag(FLAGS_sandbox2_deadline_manager_signal);
+    struct sigaction sa = {};
+    sa.sa_flags = 0;
+    sa.sa_handler = DeadlineManager::SignalHandler;
+    struct sigaction old = {};
+    PCHECK(sigaction(signal_nr_, &sa, &old) == 0);
+    // Verify that previously there was no handler set.
+    if (old.sa_flags & SA_SIGINFO) {
+      LOG_IF(WARNING, old.sa_sigaction != nullptr)
+          << "Signal handler was already registered";
+    } else {
+      LOG_IF(WARNING, old.sa_handler != nullptr)
+          << "Signal handler was already registered";
+    }
+    return true;
+  });
+}
+
+void DeadlineManager::VerifySignalHandler() {
+  struct sigaction old = {};
+  PCHECK(sigaction(signal_nr_, nullptr, &old) == 0);
+  auto describe = [](uintptr_t handler) -> std::string {
+    return absl::StrCat(absl::Hex(handler));
+  };
+  uintptr_t old_handler = (old.sa_flags & SA_SIGINFO)
+                              ? reinterpret_cast<uintptr_t>(old.sa_sigaction)
+                              : reinterpret_cast<uintptr_t>(old.sa_handler);
+  CHECK(old_handler ==
+        reinterpret_cast<uintptr_t>(DeadlineManager::SignalHandler))
+      << "Signal handler was overriden " << describe(old_handler);
+  CHECK((old.sa_flags & SA_RESTART) == 0)
+      << "SA_RESTART signal handler flag was overriden: "
+      << absl::Hex(old.sa_flags);
+}
+
+void DeadlineManager::Run() {
+  absl::Time next_deadline;
+  auto next_deadline_changed_or_cancelled = [this, &next_deadline]() -> bool {
+    queue_mutex_.AssertReaderHeld();
+    return (!queue_.empty() && next_deadline != (*queue_.begin())->deadline) ||
+           cancelled_;
+  };
+  absl::MutexLock lock(&queue_mutex_);
+  while (!cancelled_) {
+    next_deadline = absl::InfiniteFuture();
+    if (!queue_.empty()) {
+      next_deadline = (*queue_.begin())->deadline;
+    }
+    if (queue_mutex_.AwaitWithDeadline(
+            absl::Condition(&next_deadline_changed_or_cancelled),
+            next_deadline)) {
+      continue;
+    }
+    while (!queue_.empty() && (*queue_.begin())->deadline <= next_deadline) {
+      DeadlineRegistration::Data* entry = *queue_.begin();
+      queue_.erase(queue_.begin());
+      absl::MutexLock lock(&entry->mutex);
+      if (++entry->notification_attempt > kFailedNotificationsThreshold) {
+        VerifySignalHandler();
+      }
+      if (entry->in_blocking_fn) {
+        constexpr int kExponentialBackoffRate = 8;
+        constexpr int kMaxExponentialBackoff = 10;
+        int exp_backoff =
+            1 << std::min(entry->notification_attempt / kExponentialBackoffRate,
+                          kMaxExponentialBackoff);
+        absl::Time next_notification_time =
+            RoundUpTo(absl::Now() + kResolution * exp_backoff, kResolution);
+        util::Syscall(__NR_tgkill, getpid(), entry->tid, signal_nr_);
+        entry->deadline = next_notification_time;
+        queue_.insert(entry);
+      }
+    }
+  }
+}
+
+}  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/util/deadline_manager.h b/sandboxed_api/sandbox2/util/deadline_manager.h
new file mode 100644
index 0000000..ae38c5b
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/deadline_manager.h
@@ -0,0 +1,159 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_UTIL_DEADLINE_MANAGER_H_
+#define SANDBOXED_API_SANDBOX2_UTIL_DEADLINE_MANAGER_H_
+
+#include <cstddef>
+#include <memory>
+
+#include "absl/base/no_destructor.h"
+#include "absl/base/thread_annotations.h"
+#include "absl/container/btree_set.h"
+#include "absl/flags/declare.h"
+#include "absl/functional/function_ref.h"
+#include "absl/strings/string_view.h"
+#include "absl/synchronization/mutex.h"
+#include "absl/time/time.h"
+#include "sandboxed_api/util/thread.h"
+
+ABSL_DECLARE_FLAG(int, sandbox2_deadline_manager_signal);
+
+namespace sandbox2 {
+
+class DeadlineManager;
+
+// Interface for managing the deadline for a blocking syscall. The syscall
+// should be interruptible by a signal. On deadline expiration deadline manager
+// repeatedly sends a signal to the thread running potentially running the
+// blocking syscall until the provided functor returns. This repetition resolves
+// the race between signaling syscall execution and actually invoking the
+// blocking syscall.
+//
+// If the deadline is unlikely to be changed between multiple blocking syscalls,
+// it's more efficient to reuse a single registration object.
+class DeadlineRegistration {
+ public:
+  explicit DeadlineRegistration(DeadlineManager& manager);
+
+  DeadlineRegistration(const DeadlineRegistration&) = delete;
+  DeadlineRegistration& operator=(const DeadlineRegistration&) = delete;
+
+  // ANDROID: move assignment operator of 'DeadlineRegistration' is implicitly
+  // deleted because field 'manager_' is of reference type 'DeadlineManager &'
+  DeadlineRegistration(DeadlineRegistration&&) = delete;
+  DeadlineRegistration& operator=(DeadlineRegistration&&) = delete;
+
+  ~DeadlineRegistration();
+
+  // Executes a blocking syscall.
+  // The function is executed only if the deadline is not expired already.
+  // The syscall will be interrupted after the deadline.
+  void ExecuteBlockingSyscall(absl::FunctionRef<void()> blocking_fn);
+
+  // Sets the deadline for the blocking syscall.
+  // The deadline is rounded up to the next resolution boundary.
+  // Can be called from a different thread concurrently with a running blocking
+  // syscall.
+  void SetDeadline(absl::Time deadline);
+
+ private:
+  friend class DeadlineManager;
+
+  struct Data {
+    absl::Mutex mutex;
+    // Changed only under both DeadlineManager::queue_mutex_ and Data::mutex.
+    absl::Time deadline = absl::InfiniteFuture();
+    pid_t ABSL_GUARDED_BY(mutex) tid = -1;
+    bool ABSL_GUARDED_BY(mutex) in_blocking_fn = false;
+    int ABSL_GUARDED_BY(mutex) notification_attempt = 0;
+  };
+
+  DeadlineManager& manager_;
+  absl::Time last_deadline_ = absl::InfiniteFuture();
+  std::unique_ptr<Data> data_ = std::make_unique<Data>();
+};
+
+// Engine for delivering deadline notifications to threads. Runs a separate
+// thread which manages all the registered deadlines.
+// All deadlines are rounded up to resolution of DeadlineManager (10 ms) for the
+// purpose of batching notifications and reducing wakeups of the manager thread.
+class DeadlineManager {
+ public:
+  // Returns the global instance of the deadline manager.
+  static DeadlineManager& instance() {
+    static absl::NoDestructor<DeadlineManager> manager{
+        "deadline_manager-global"};
+    return *manager;
+  }
+  // Creates and starts the manager.
+  explicit DeadlineManager(absl::string_view name);
+
+  DeadlineManager(const DeadlineManager&) = delete;
+  DeadlineManager& operator=(const DeadlineManager&) = delete;
+
+  DeadlineManager(DeadlineManager&&) = delete;
+  DeadlineManager& operator=(DeadlineManager&&) = delete;
+
+  ~DeadlineManager();
+
+  // Adjusts the deadline for the registration.
+  // Prefer to use DeadlineRegistration::SetDeadline.
+  void AdjustDeadline(DeadlineRegistration& registration, absl::Time deadline);
+
+ private:
+  friend class DeadlineRegistration;
+  static constexpr absl::Duration kResolution = absl::Milliseconds(10);
+
+  struct ByDeadline {
+    bool operator()(const DeadlineRegistration::Data* a,
+                    const DeadlineRegistration::Data* b) const {
+      return a->deadline < b->deadline || (a->deadline == b->deadline && a < b);
+    }
+  };
+
+  static void RegisterSignalHandler();
+  static void SignalHandler(int signal);
+  static void VerifySignalHandler();
+
+  void Register(DeadlineRegistration& registration) {
+    absl::MutexLock lock(&registration_mutex_);
+    ++registered_deadlines_;
+  }
+  void Unregister(DeadlineRegistration& registration) {
+    {
+      absl::MutexLock lock(&queue_mutex_);
+      queue_.erase(registration.data_.get());
+    }
+    absl::MutexLock lock(&registration_mutex_);
+    --registered_deadlines_;
+  }
+  void Run();
+
+  static int signal_nr_;
+  sapi::Thread thread_;
+  absl::Mutex queue_mutex_;
+  bool cancelled_ ABSL_GUARDED_BY(queue_mutex_) = false;
+  // We only need an adjustable heap, but there is no widely available
+  // implementation \_()_/. Asymptotically it's the same and it should not
+  // matter at our scale.
+  absl::btree_set<DeadlineRegistration::Data*, ByDeadline> ABSL_GUARDED_BY(
+      queue_mutex_) queue_;
+  absl::Mutex registration_mutex_;
+  size_t registered_deadlines_ ABSL_GUARDED_BY(registration_mutex_) = 0;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_UTIL_DEADLINE_MANAGER_H_
diff --git a/sandboxed_api/sandbox2/util/deadline_manager_test.cc b/sandboxed_api/sandbox2/util/deadline_manager_test.cc
new file mode 100644
index 0000000..94e9d2a
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/deadline_manager_test.cc
@@ -0,0 +1,210 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "sandboxed_api/sandbox2/util/deadline_manager.h"
+
+#include <sys/syscall.h>
+
+#include <csignal>
+#include <ctime>
+
+#include "gtest/gtest.h"
+#include "absl/flags/flag.h"
+#include "absl/log/check.h"
+#include "absl/time/clock.h"
+#include "absl/time/time.h"
+#include "sandboxed_api/util/thread.h"
+
+namespace sandbox2 {
+namespace {
+
+TEST(DeadlineManagerTest, Basic) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  absl::Time start_time = absl::Now();
+  struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+  registration.SetDeadline(start_time + absl::Milliseconds(100));
+  registration.ExecuteBlockingSyscall(
+      [&] { ASSERT_EQ(nanosleep(&ts, nullptr), -1); });
+  absl::Duration elapsed = absl::Now() - start_time;
+  EXPECT_GE(elapsed, absl::Milliseconds(100));
+  EXPECT_LE(elapsed, absl::Milliseconds(200));
+}
+
+TEST(DeadlineManagerTest, NotifiesUntilFunctionReturns) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  absl::Time start_time = absl::Now();
+  struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+  registration.SetDeadline(start_time + absl::Milliseconds(100));
+  registration.ExecuteBlockingSyscall([&] {
+    // Double so that it needs to be notified twice.
+    ASSERT_EQ(nanosleep(&ts, nullptr), -1);
+    ASSERT_EQ(nanosleep(&ts, nullptr), -1);
+  });
+  absl::Duration elapsed = absl::Now() - start_time;
+  EXPECT_GE(elapsed, absl::Milliseconds(100));
+  EXPECT_LE(elapsed, absl::Milliseconds(200));
+}
+
+TEST(DeadlineManagerTest, DeadlineInThePast) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  registration.SetDeadline(absl::InfinitePast());
+  registration.ExecuteBlockingSyscall(
+      [&] { FAIL() << "Function should not be executed"; });
+}
+
+TEST(DeadlineManagerTest, DeadlineSetConcurrently) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  absl::Time start_time = absl::Now();
+  struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+  registration.ExecuteBlockingSyscall([&] {
+    sapi::Thread thread([&] {
+      absl::SleepFor(absl::Milliseconds(10));
+      registration.SetDeadline(start_time + absl::Milliseconds(100));
+    });
+    ASSERT_EQ(nanosleep(&ts, nullptr), -1);
+    thread.Join();
+  });
+  absl::Duration elapsed = absl::Now() - start_time;
+  EXPECT_GE(elapsed, absl::Milliseconds(100));
+  EXPECT_LE(elapsed, absl::Milliseconds(200));
+}
+
+TEST(DeadlineManagerTest, DeadlineInPastSetConcurrently) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  absl::Time start_time = absl::Now();
+  struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+  registration.ExecuteBlockingSyscall([&] {
+    sapi::Thread thread([&] {
+      absl::SleepFor(absl::Milliseconds(100));
+      registration.SetDeadline(absl::InfinitePast());
+    });
+    ASSERT_EQ(nanosleep(&ts, nullptr), -1);
+    thread.Join();
+  });
+  absl::Duration elapsed = absl::Now() - start_time;
+  EXPECT_GE(elapsed, absl::Milliseconds(100));
+  EXPECT_LE(elapsed, absl::Milliseconds(200));
+}
+
+TEST(DeadlineManagerTest, DeadlineReset) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  absl::Time start_time = absl::Now();
+  struct timespec ts = absl::ToTimespec(absl::Milliseconds(200));
+  registration.ExecuteBlockingSyscall([&] {
+    registration.SetDeadline(absl::InfiniteFuture());
+    ASSERT_EQ(nanosleep(&ts, nullptr), 0);
+  });
+  absl::Duration elapsed = absl::Now() - start_time;
+  EXPECT_GE(elapsed, absl::Milliseconds(200));
+}
+
+TEST(DeadlineManagerTest, CanBeReusedAfterExpiration) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  for (int i = 0; i < 3; ++i) {
+    absl::Time start_time = absl::Now();
+    struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+    registration.SetDeadline(start_time + absl::Milliseconds(100));
+    registration.ExecuteBlockingSyscall(
+        [&] { ASSERT_EQ(nanosleep(&ts, nullptr), -1); });
+    absl::Duration elapsed = absl::Now() - start_time;
+    EXPECT_GE(elapsed, absl::Milliseconds(100));
+    EXPECT_LE(elapsed, absl::Milliseconds(200));
+  }
+}
+
+TEST(DeadlineManagerTest, WorksInAThread) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  sapi::Thread thread([&] {
+    absl::Time start_time = absl::Now();
+    struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+    registration.SetDeadline(start_time + absl::Milliseconds(100));
+    registration.ExecuteBlockingSyscall(
+        [&] { ASSERT_EQ(nanosleep(&ts, nullptr), -1); });
+    absl::Duration elapsed = absl::Now() - start_time;
+    EXPECT_GE(elapsed, absl::Milliseconds(100));
+    EXPECT_LE(elapsed, absl::Milliseconds(200));
+  });
+  thread.Join();
+}
+
+TEST(DeadlineManagerTest, DetectsOverridenHandler) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  EXPECT_DEATH(
+      {
+        struct sigaction sa = {};
+        CHECK_EQ(
+            sigaction(absl::GetFlag(FLAGS_sandbox2_deadline_manager_signal),
+                      nullptr, &sa),
+            0);
+        sa.sa_handler = SIG_IGN;
+        CHECK_EQ(
+            sigaction(absl::GetFlag(FLAGS_sandbox2_deadline_manager_signal),
+                      &sa, nullptr),
+            0);
+        absl::Time start_time = absl::Now();
+        absl::Time sleep_until = start_time + absl::Seconds(5);
+        registration.SetDeadline(start_time + absl::Milliseconds(100));
+        registration.ExecuteBlockingSyscall([sleep_until] {
+          absl::Duration remaining = sleep_until - absl::Now();
+          while (remaining > absl::ZeroDuration()) {
+            struct timespec ts = absl::ToTimespec(remaining);
+            CHECK_EQ(nanosleep(&ts, nullptr), -1);
+            remaining = sleep_until - absl::Now();
+          }
+        });
+      },
+      "Signal handler was overriden");
+}
+
+TEST(DeadlineManagerTest, DetectsOverridenHandlerFlags) {
+  DeadlineManager manager("test");
+  DeadlineRegistration registration(manager);
+  EXPECT_DEATH(
+      {
+        struct sigaction sa = {};
+        CHECK_EQ(
+            sigaction(absl::GetFlag(FLAGS_sandbox2_deadline_manager_signal),
+                      nullptr, &sa),
+            0);
+        sa.sa_flags = SA_RESTART;
+        CHECK_EQ(
+            sigaction(absl::GetFlag(FLAGS_sandbox2_deadline_manager_signal),
+                      &sa, nullptr),
+            0);
+        absl::Time start_time = absl::Now();
+        absl::Time sleep_until = start_time + absl::Seconds(5);
+        registration.SetDeadline(start_time + absl::Milliseconds(100));
+        registration.ExecuteBlockingSyscall([sleep_until] {
+          absl::Duration remaining = sleep_until - absl::Now();
+          while (remaining > absl::ZeroDuration()) {
+            struct timespec ts = absl::ToTimespec(remaining);
+            CHECK_EQ(nanosleep(&ts, nullptr), -1);
+            remaining = sleep_until - absl::Now();
+          }
+        });
+      },
+      "SA_RESTART signal handler flag was overriden");
+}
+
+}  // namespace
+}  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/util/minielf_test.cc b/sandboxed_api/sandbox2/util/minielf_test.cc
index 10ddaa4..cccd97f 100644
--- a/sandboxed_api/sandbox2/util/minielf_test.cc
+++ b/sandboxed_api/sandbox2/util/minielf_test.cc
@@ -21,7 +21,6 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/algorithm/container.h"
-#include "absl/status/statusor.h"
 #include "sandboxed_api/sandbox2/util/maps_parser.h"
 #include "sandboxed_api/testing.h"
 #include "sandboxed_api/util/file_helpers.h"
diff --git a/sandboxed_api/sandbox2/util/pid_waiter.cc b/sandboxed_api/sandbox2/util/pid_waiter.cc
new file mode 100644
index 0000000..c76ac87
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/pid_waiter.cc
@@ -0,0 +1,120 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "sandboxed_api/sandbox2/util/pid_waiter.h"
+
+#include <sys/wait.h>
+
+#include <cerrno>
+#include <memory>
+
+#include "absl/cleanup/cleanup.h"
+#include "absl/synchronization/mutex.h"
+#include "absl/time/time.h"
+#include "sandboxed_api/sandbox2/util/deadline_manager.h"
+
+namespace sandbox2 {
+
+namespace {
+
+class OsWaitPid : public PidWaiter::WaitPidInterface {
+ public:
+  int WaitPid(pid_t pid, int* status, int flags) override {
+    return waitpid(pid, status, flags);
+  }
+};
+
+}  // namespace
+
+PidWaiter::PidWaiter(pid_t priority_pid)
+    : PidWaiter(priority_pid, std::make_unique<OsWaitPid>()) {}
+
+int PidWaiter::Wait(int* status) {
+  RefillStatuses();
+
+  if (statuses_.empty()) {
+    if (last_errno_ == 0) return 0;
+    errno = last_errno_;
+    last_errno_ = 0;
+    return -1;
+  }
+
+  const auto& entry = statuses_.front();
+  pid_t pid = entry.first;
+  *status = entry.second;
+  statuses_.pop_front();
+  return pid;
+}
+
+bool PidWaiter::CheckStatus(pid_t pid, bool blocking) {
+  int status;
+  int flags = __WNOTHREAD | __WALL | WUNTRACED;
+  if (!blocking) {
+    // It should be a non-blocking operation (hence WNOHANG), so this function
+    // returns quickly if there are no events to be processed.
+    flags |= WNOHANG;
+  }
+  pid_t ret = wait_pid_iface_->WaitPid(pid, &status, flags);
+  if (ret < 0) {
+    last_errno_ = errno;
+    return true;
+  }
+  if (ret == 0) {
+    return false;
+  }
+  statuses_.emplace_back(ret, status);
+  return true;
+}
+
+void PidWaiter::RefillStatuses() {
+  constexpr int kMaxIterations = 1000;
+  constexpr int kPriorityCheckPeriod = 100;
+  absl::Cleanup notify = [this] {
+    absl::MutexLock lock(&notify_mutex_);
+    notified_ = false;
+  };
+  if (!statuses_.empty()) {
+    return;
+  }
+  for (int i = 0; last_errno_ == 0 && i < kMaxIterations; ++i) {
+    bool should_check_priority =
+        priority_pid_ != -1 && (i % kPriorityCheckPeriod) == 0;
+    if (should_check_priority && CheckStatus(priority_pid_)) {
+      return;
+    }
+    if (!CheckStatus(-1)) {
+      break;
+    }
+  }
+  if (statuses_.empty()) {
+    DeadlineRegistration* deadline_registration = nullptr;
+    {
+      absl::MutexLock lock(&notify_mutex_);
+      if (deadline_ == absl::InfinitePast() || notified_) {
+        return;
+      }
+      if (!deadline_registration_.has_value()) {
+        deadline_registration_.emplace(DeadlineManager::instance());
+      }
+      deadline_registration_->SetDeadline(deadline_);
+      // DeadlineRegistration is only constructed once, so it's safe to use it
+      // outside of the lock.
+      deadline_registration = &*deadline_registration_;
+    }
+    deadline_registration->ExecuteBlockingSyscall(
+        [&] { CheckStatus(-1, /*blocking=*/true); });
+  }
+}
+
+}  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/util/pid_waiter.h b/sandboxed_api/sandbox2/util/pid_waiter.h
new file mode 100644
index 0000000..a13f884
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/pid_waiter.h
@@ -0,0 +1,95 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_SANDBOX2_UTIL_PID_WAITER_H_
+#define SANDBOXED_API_SANDBOX2_UTIL_PID_WAITER_H_
+
+#include <sys/wait.h>
+
+#include <deque>
+#include <memory>
+#include <optional>
+#include <utility>
+
+#include "absl/base/thread_annotations.h"
+#include "absl/synchronization/mutex.h"
+#include "absl/time/time.h"
+#include "sandboxed_api/sandbox2/util/deadline_manager.h"
+
+namespace sandbox2 {
+
+// Since waitpid() is biased towards newer threads, we run the risk of
+// starving older threads if the newer ones raise a lot of events. To avoid
+// it, we use this class to gather all the waiting threads and then return
+// them one at a time on each call to Wait(). In this way, everyone gets their
+// chance.
+class PidWaiter {
+ public:
+  // Interface for waitpid() to allow mocking it in tests.
+  class WaitPidInterface {
+   public:
+    virtual int WaitPid(pid_t pid, int* status, int flags) = 0;
+    virtual ~WaitPidInterface() = default;
+  };
+
+  // Constructs a PidWaiter where the given priority_pid is checked first.
+  explicit PidWaiter(pid_t priority_pid = -1);
+  PidWaiter(pid_t priority_pid,
+            std::unique_ptr<WaitPidInterface> wait_pid_iface)
+      : priority_pid_(priority_pid),
+        wait_pid_iface_(std::move(wait_pid_iface)) {};
+
+  // Returns the PID of a thread that needs attention, populating 'status'
+  // with the status returned by the waitpid() call. It returns 0 if no
+  // threads require attention at the moment, or -1 if there was an error, in
+  // which case the error value can be found in 'errno'.
+  int Wait(int* status);
+
+  void SetPriorityPid(pid_t pid) { priority_pid_ = pid; }
+
+  // Sets the deadline for the next Wait() call.
+  void SetDeadline(absl::Time deadline) {
+    absl::MutexLock lock(&notify_mutex_);
+    deadline_ = deadline;
+  }
+
+  // Breaks out of the current Wait operation, if there is one running
+  // concurrently. Otherwise, makes the next Wait non-blocking.
+  // Can be called concurrently with Wait and SetDeadline.
+  void Notify() {
+    absl::MutexLock lock(&notify_mutex_);
+    if (deadline_registration_.has_value()) {
+      deadline_registration_->SetDeadline(absl::InfinitePast());
+    }
+    notified_ = true;
+  }
+
+ private:
+  bool CheckStatus(pid_t pid, bool blocking = false);
+  void RefillStatuses();
+
+  pid_t priority_pid_;
+  std::deque<std::pair<pid_t, int>> statuses_;
+  std::unique_ptr<WaitPidInterface> wait_pid_iface_;
+  int last_errno_ = 0;
+  absl::Mutex notify_mutex_;
+  absl::Time deadline_ ABSL_GUARDED_BY(notify_mutex_) = absl::InfinitePast();
+  std::optional<DeadlineRegistration> deadline_registration_
+      ABSL_GUARDED_BY(notify_mutex_);
+  bool notified_ ABSL_GUARDED_BY(notify_mutex_) = false;
+};
+
+}  // namespace sandbox2
+
+#endif  // SANDBOXED_API_SANDBOX2_UTIL_PID_WAITER_H_
diff --git a/sandboxed_api/sandbox2/util/pid_waiter_test.cc b/sandboxed_api/sandbox2/util/pid_waiter_test.cc
new file mode 100644
index 0000000..38d95f7
--- /dev/null
+++ b/sandboxed_api/sandbox2/util/pid_waiter_test.cc
@@ -0,0 +1,225 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "sandboxed_api/sandbox2/util/pid_waiter.h"
+
+#include <cerrno>
+#include <ctime>
+#include <memory>
+#include <utility>
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "absl/time/clock.h"
+#include "absl/time/time.h"
+#include "sandboxed_api/util/thread.h"
+
+namespace sandbox2 {
+namespace {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Return;
+using ::testing::SetArgPointee;
+using ::testing::SetErrnoAndReturn;
+
+constexpr int kPrioStatus = 7 << 8;
+constexpr int kFirstStatus = 5 << 8;
+constexpr int kSecondStatus = 8 << 8;
+constexpr pid_t kPrioPid = 1;
+constexpr pid_t kFirstPid = 2;
+constexpr pid_t kSecondPid = 3;
+
+class MockWaitPid : public PidWaiter::WaitPidInterface {
+ public:
+  MOCK_METHOD(int, WaitPid, (pid_t, int*, int), (override));
+};
+
+TEST(PidWaiterTest, NoEvents) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid, WaitPid(_, _, _)).WillRepeatedly(Return(0));
+  PidWaiter waiter(1, std::move(mock_wait_pid));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), 0);
+}
+
+TEST(PidWaiterTest, NoProcess) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid, WaitPid(_, _, _))
+      .WillRepeatedly(SetErrnoAndReturn(ECHILD, -1));
+  PidWaiter waiter(1, std::move(mock_wait_pid));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), -1);
+  EXPECT_EQ(errno, ECHILD);
+}
+
+TEST(PidWaiterTest, PriorityRespected) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid, WaitPid(-1, _, _))
+      .WillOnce(DoAll(SetArgPointee<1>(kFirstStatus), Return(kFirstPid)))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(kPrioPid, _, _))
+      .WillOnce(DoAll(SetArgPointee<1>(kPrioStatus), Return(kPrioPid)))
+      .WillOnce(Return(0))
+      .WillRepeatedly(DoAll(SetArgPointee<1>(kPrioStatus), Return(kPrioPid)));
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), kPrioPid);
+  EXPECT_EQ(status, kPrioStatus);
+  EXPECT_EQ(waiter.Wait(&status), kFirstPid);
+  EXPECT_EQ(status, kFirstStatus);
+  EXPECT_EQ(waiter.Wait(&status), kPrioPid);
+  EXPECT_EQ(status, kPrioStatus);
+}
+
+TEST(PidWaiterTest, BatchesWaits) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid, WaitPid(kPrioPid, _, _))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(-1, _, _))
+      .Times(3)
+      .WillOnce(DoAll(SetArgPointee<1>(kFirstStatus), Return(kFirstPid)))
+      .WillOnce(DoAll(SetArgPointee<1>(kSecondStatus), Return(kSecondPid)))
+      .WillRepeatedly(Return(0));
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), kFirstPid);
+  EXPECT_EQ(status, kFirstStatus);
+}
+
+TEST(PidWaiterTest, ReturnsFromBatch) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid, WaitPid(kPrioPid, _, _))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(-1, _, _))
+      .Times(3)
+      .WillOnce(DoAll(SetArgPointee<1>(kFirstStatus), Return(kFirstPid)))
+      .WillOnce(DoAll(SetArgPointee<1>(kSecondStatus), Return(kSecondPid)))
+      .WillRepeatedly(Return(0));
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), kFirstPid);
+  EXPECT_EQ(status, kFirstStatus);
+  EXPECT_EQ(waiter.Wait(&status), kSecondPid);
+  EXPECT_EQ(status, kSecondStatus);
+}
+
+TEST(PidWaiterTest, ChangePriority) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid, WaitPid(kFirstPid, _, _))
+      .WillRepeatedly(DoAll(SetArgPointee<1>(kFirstStatus), Return(kFirstPid)));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(kSecondPid, _, _))
+      .WillRepeatedly(
+          DoAll(SetArgPointee<1>(kSecondStatus), Return(kSecondPid)));
+  PidWaiter waiter(kFirstPid, std::move(mock_wait_pid));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), kFirstPid);
+  EXPECT_EQ(status, kFirstStatus);
+  EXPECT_EQ(waiter.Wait(&status), kFirstPid);
+  EXPECT_EQ(status, kFirstStatus);
+  waiter.SetPriorityPid(kSecondPid);
+  EXPECT_EQ(waiter.Wait(&status), kSecondPid);
+  EXPECT_EQ(status, kSecondStatus);
+}
+
+TEST(PidWaiterTest, DeadlineRespected) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid,
+              WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED | WNOHANG))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED))
+      .WillRepeatedly([](int pid, int* status, int flags) {
+        struct timespec ts = absl::ToTimespec(absl::Seconds(1));
+        if (nanosleep(&ts, nullptr) == -1) {
+          return -1;
+        }
+        *status = kFirstPid;
+        return kFirstPid;
+      });
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  waiter.SetDeadline(absl::Now() + absl::Milliseconds(100));
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), -1);
+  EXPECT_EQ(errno, EINTR);
+}
+
+TEST(PidWaiterTest, NotifyConcurrent) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid,
+              WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED | WNOHANG))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED))
+      .WillRepeatedly([](int pid, int* status, int flags) {
+        struct timespec ts = absl::ToTimespec(absl::Seconds(2));
+        if (nanosleep(&ts, nullptr) == -1) {
+          return -1;
+        }
+        *status = kFirstPid;
+        return kFirstPid;
+      });
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  waiter.SetDeadline(absl::Now() + absl::Seconds(1));
+  sapi::Thread notify_thread([&] {
+    absl::SleepFor(absl::Milliseconds(100));
+    waiter.Notify();
+  });
+  int status;
+  absl::Time start = absl::Now();
+  EXPECT_EQ(waiter.Wait(&status), -1);
+  EXPECT_LT(absl::Now() - start, absl::Milliseconds(500));
+  EXPECT_EQ(errno, EINTR);
+}
+
+TEST(PidWaiterTest, NotifyNext) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid,
+              WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED | WNOHANG))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED))
+      .Times(0);
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  waiter.SetDeadline(absl::Now() + absl::Seconds(1));
+  waiter.Notify();
+  int status;
+  absl::Time start = absl::Now();
+  EXPECT_EQ(waiter.Wait(&status), 0);
+  EXPECT_LT(absl::Now() - start, absl::Milliseconds(500));
+}
+
+TEST(PidWaiterTest, DeadlineUnchangedAfterNotify) {
+  auto mock_wait_pid = std::make_unique<MockWaitPid>();
+  EXPECT_CALL(*mock_wait_pid,
+              WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED | WNOHANG))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(*mock_wait_pid, WaitPid(_, _, __WNOTHREAD | __WALL | WUNTRACED))
+      .WillRepeatedly([](int pid, int* status, int flags) {
+        struct timespec ts = absl::ToTimespec(absl::Milliseconds(500));
+        if (nanosleep(&ts, nullptr) == -1) {
+          return -1;
+        }
+        *status = kFirstPid;
+        return kFirstPid;
+      });
+  PidWaiter waiter(kPrioPid, std::move(mock_wait_pid));
+  waiter.SetDeadline(absl::Now() + absl::Milliseconds(900));
+  waiter.Notify();
+  int status;
+  EXPECT_EQ(waiter.Wait(&status), 0);
+  absl::SleepFor(absl::Milliseconds(500));
+  EXPECT_EQ(waiter.Wait(&status), -1);
+  EXPECT_EQ(errno, EINTR);
+}
+
+}  // namespace
+}  // namespace sandbox2
diff --git a/sandboxed_api/sandbox2/util_test.cc b/sandboxed_api/sandbox2/util_test.cc
index 52e58ea..25b4e1e 100644
--- a/sandboxed_api/sandbox2/util_test.cc
+++ b/sandboxed_api/sandbox2/util_test.cc
@@ -28,22 +28,28 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/cleanup/cleanup.h"
+#include "absl/log/check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
+#include "absl/types/span.h"
+#include "sandboxed_api/testing.h"
 #include "sandboxed_api/util/status_matchers.h"
 
 namespace sandbox2::util {
 namespace {
 
+using ::sapi::GetTestSourcePath;
 using ::sapi::IsOk;
 using ::testing::ElementsAre;
+using ::testing::ElementsAreArray;
 using ::testing::Eq;
 using ::testing::Gt;
 using ::testing::IsEmpty;
 using ::testing::IsTrue;
 using ::testing::Ne;
 using ::testing::Not;
+using ::testing::StartsWith;
 using ::testing::StrEq;
 
 constexpr absl::string_view kTestString = "This is a test string";
@@ -166,5 +172,272 @@ TEST(ReadCPathFromPidSplitPageTest, NearUnreadableMemory) {
   EXPECT_THAT(*read, Eq(kTestString));
 }
 
+TEST(CommunitacteTest, Normal) {
+  const std::string path =
+      GetTestSourcePath("sandbox2/testcases/util_communicate");
+  std::string output;
+  SAPI_ASSERT_OK_AND_ASSIGN(
+      int exit_code,
+      util::Communicate({path, "argv1", "argv2"}, {"env1", "env2"}, &output));
+  EXPECT_THAT(exit_code, Eq(0));
+  EXPECT_THAT(output, StartsWith("3\nargv1\nargv2\nenv1\nenv2\n"));
+}
+
+TEST(ReadBytesFromPidTest, Normal) {
+  absl::StatusOr<std::vector<uint8_t>> read = ReadBytesFromPid(
+      getpid(), reinterpret_cast<uintptr_t>(kTestString.data()),
+      kTestString.size());
+  EXPECT_THAT(*read, ElementsAreArray(kTestString));
+}
+
+TEST(ReadBytesFromPidTest, NearUnmappedMemory) {
+  const uintptr_t page_size = getpagesize();
+  ASSERT_LE(kTestString.size(), page_size);
+  char* res = reinterpret_cast<char*>(mmap(nullptr, 2 * page_size,
+                                           PROT_READ | PROT_WRITE,
+                                           MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(res, Ne(MAP_FAILED));
+  ASSERT_THAT(munmap(&res[page_size], page_size), Eq(0));
+  absl::Cleanup cleanup = [res, page_size]() {
+    ASSERT_THAT(munmap(res, page_size), Eq(0));
+  };
+  char* data = &res[page_size - kTestString.size()];
+  memcpy(data, kTestString.data(), kTestString.size());
+  absl::StatusOr<std::vector<uint8_t>> read = ReadBytesFromPid(
+      getpid(), reinterpret_cast<uintptr_t>(data), 2 * kTestString.size());
+  ASSERT_THAT(read, IsOk());
+  EXPECT_THAT(*read, ElementsAreArray(kTestString));
+}
+
+class ReadBytesFromPidIntoTest : public testing::TestWithParam<bool> {
+ protected:
+  absl::StatusOr<size_t> Read(pid_t pid, uintptr_t ptr, absl::Span<char> data) {
+    if (GetParam()) {
+      return internal::ReadBytesFromPidWithReadv(pid, ptr, data);
+    } else {
+      return internal::ReadBytesFromPidWithReadvInSplitChunks(pid, ptr, data);
+    }
+  }
+};
+
+TEST_P(ReadBytesFromPidIntoTest, Normal) {
+  char data[kTestString.size()] = {0};
+  absl::StatusOr<size_t> bytes_read =
+      Read(getpid(), reinterpret_cast<uintptr_t>(kTestString.data()),
+           absl::MakeSpan(data));
+  ASSERT_THAT(bytes_read, IsOk());
+  EXPECT_THAT(*bytes_read, Eq(kTestString.size()));
+  EXPECT_THAT(data, ElementsAreArray(kTestString));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, SplitPage) {
+  const uintptr_t page_size = getpagesize();
+  ASSERT_LE(kTestString.size(), page_size);
+  char* res = reinterpret_cast<char*>(mmap(nullptr, 2 * page_size,
+                                           PROT_READ | PROT_WRITE,
+                                           MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(res, Ne(MAP_FAILED));
+  absl::Cleanup cleanup = [res, page_size]() {
+    ASSERT_THAT(munmap(res, 2 * page_size), Eq(0));
+  };
+  char* data = &res[page_size - kTestString.size() / 2];
+  memcpy(data, kTestString.data(), kTestString.size());
+  char output[kTestString.size()];
+  absl::StatusOr<size_t> bytes_read =
+      Read(getpid(), reinterpret_cast<uintptr_t>(data), absl::MakeSpan(output));
+  ASSERT_THAT(bytes_read, IsOk());
+  EXPECT_THAT(*bytes_read, Eq(kTestString.size()));
+  EXPECT_THAT(output, ElementsAreArray(kTestString));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, InvalidPid) {
+  char data;
+  absl::StatusOr<size_t> bytes_read =
+      Read(-1, reinterpret_cast<uintptr_t>(&data), absl::MakeSpan(&data, 1));
+  ASSERT_THAT(bytes_read, Not(IsOk()));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, ZeroLength) {
+  char data;
+  absl::StatusOr<size_t> bytes_read = Read(
+      getpid(), reinterpret_cast<uintptr_t>(&data), absl::MakeSpan(&data, 0));
+  ASSERT_THAT(bytes_read, IsOk());
+  ASSERT_THAT(*bytes_read, Eq(0));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, ZeroLengthWithInvalidPid) {
+  char data;
+  absl::StatusOr<size_t> bytes_read =
+      Read(-1, reinterpret_cast<uintptr_t>(&data), absl::MakeSpan(&data, 0));
+  ASSERT_THAT(bytes_read, IsOk());
+  ASSERT_THAT(*bytes_read, Eq(0));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, UnmappedMemory) {
+  const uintptr_t page_size = getpagesize();
+  char* res =
+      reinterpret_cast<char*>(mmap(nullptr, page_size, PROT_READ | PROT_WRITE,
+                                   MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(res, Ne(MAP_FAILED));
+  ASSERT_THAT(munmap(res, page_size), Eq(0));
+  absl::StatusOr<size_t> bytes_read =
+      Read(getpid(), reinterpret_cast<uintptr_t>(res), absl::MakeSpan(res, 1));
+  ASSERT_THAT(bytes_read, Not(IsOk()));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, NearUnmappedMemory) {
+  const uintptr_t page_size = getpagesize();
+  char* res = reinterpret_cast<char*>(mmap(nullptr, 2 * page_size,
+                                           PROT_READ | PROT_WRITE,
+                                           MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(res, Ne(MAP_FAILED));
+  // Unmap second page so there's a gap.
+  ASSERT_THAT(munmap(&res[page_size], page_size), Eq(0));
+  absl::Cleanup cleanup = [res, page_size]() {
+    ASSERT_THAT(munmap(res, page_size), Eq(0));
+  };
+  char* data = &res[page_size - kTestString.size() / 2];
+  memcpy(data, kTestString.data(), kTestString.size() / 2);
+  char output[kTestString.size()];
+  absl::StatusOr<size_t> bytes_read =
+      Read(getpid(), reinterpret_cast<uintptr_t>(data), absl::MakeSpan(output));
+  ASSERT_THAT(bytes_read, IsOk());
+  EXPECT_THAT(*bytes_read, Eq(kTestString.size() / 2));
+  EXPECT_THAT(absl::MakeSpan(data, kTestString.size() / 2),
+              Eq(absl::MakeSpan(kTestString.data(), kTestString.size() / 2)));
+}
+
+TEST_P(ReadBytesFromPidIntoTest, ExceedIovMax) {
+  // Read one page past the max readable memory in one set of iovecs.
+  const uintptr_t page_size = getpagesize();
+  const size_t length = (IOV_MAX + 1) * page_size;
+  char* data = reinterpret_cast<char*>(mmap(nullptr, length + page_size,
+                                            PROT_READ | PROT_WRITE,
+                                            MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(data, Ne(MAP_FAILED));
+  // Unmap second page so there's a gap.
+  ASSERT_THAT(munmap(&data[length], page_size), Eq(0));
+  absl::Cleanup cleanup = [data, length]() {
+    ASSERT_THAT(munmap(data, length), Eq(0));
+  };
+  memset(data, 0x0e, length);
+  std::vector<char> output(length);
+  absl::StatusOr<size_t> bytes_read =
+      Read(getpid(), reinterpret_cast<uintptr_t>(data),
+           absl::MakeSpan(output.data(), length));
+  ASSERT_THAT(bytes_read, IsOk());
+  EXPECT_THAT(*bytes_read, Eq(length));
+  EXPECT_THAT(output, ElementsAreArray(data, length));
+}
+
+INSTANTIATE_TEST_SUITE_P(ReadBytesFromPidInto, ReadBytesFromPidIntoTest,
+                         testing::Values(true, false));
+
+class WriteBytesToPidFromTest : public testing::TestWithParam<bool> {
+ protected:
+  absl::StatusOr<size_t> Write(pid_t pid, uintptr_t ptr,
+                               absl::Span<const char> data) {
+    if (GetParam()) {
+      return internal::WriteBytesToPidWithWritev(pid, ptr, data);
+    } else {
+      return internal::WriteBytesToPidWithProcMem(pid, ptr, data);
+    }
+  };
+};
+
+TEST_P(WriteBytesToPidFromTest, Normal) {
+  char data[kTestString.size()] = {0};
+  absl::StatusOr<size_t> bytes_written =
+      Write(getpid(), reinterpret_cast<uintptr_t>(data), kTestString);
+  ASSERT_THAT(bytes_written, IsOk());
+  EXPECT_THAT(*bytes_written, Eq(kTestString.size()));
+  EXPECT_THAT(data, ElementsAreArray(kTestString));
+}
+
+TEST_P(WriteBytesToPidFromTest, SplitPage) {
+  const uintptr_t page_size = getpagesize();
+  ASSERT_LE(kTestString.size(), page_size);
+  char* res = reinterpret_cast<char*>(mmap(nullptr, 2 * page_size,
+                                           PROT_READ | PROT_WRITE,
+                                           MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(res, Ne(MAP_FAILED));
+  absl::Cleanup cleanup = [res, page_size]() {
+    ASSERT_THAT(munmap(res, 2 * page_size), Eq(0));
+  };
+  char* data = &res[page_size - kTestString.size() / 2];
+  absl::StatusOr<size_t> bytes_written =
+      Write(getpid(), reinterpret_cast<uintptr_t>(data), kTestString);
+  ASSERT_THAT(bytes_written, IsOk());
+  EXPECT_THAT(*bytes_written, Eq(kTestString.size()));
+  EXPECT_THAT(kTestString, ElementsAreArray(data, kTestString.size()));
+}
+
+TEST_P(WriteBytesToPidFromTest, InvalidPid) {
+  char data = 0;
+  absl::StatusOr<size_t> bytes_written =
+      Write(-1, reinterpret_cast<uintptr_t>(&data), absl::MakeSpan(&data, 1));
+  ASSERT_THAT(bytes_written, Not(IsOk()));
+}
+
+TEST_P(WriteBytesToPidFromTest, ZeroLength) {
+  char data = 0;
+  absl::StatusOr<size_t> bytes_written = Write(
+      getpid(), reinterpret_cast<uintptr_t>(&data), absl::MakeSpan(&data, 0));
+  ASSERT_THAT(bytes_written, IsOk());
+  ASSERT_THAT(*bytes_written, Eq(0));
+}
+
+TEST_P(WriteBytesToPidFromTest, ZeroLengthWithInvalidPid) {
+  char data = 0;
+  absl::StatusOr<size_t> bytes_written =
+      Write(-1, reinterpret_cast<uintptr_t>(&data), absl::MakeSpan(&data, 0));
+  ASSERT_THAT(bytes_written, IsOk());
+  ASSERT_THAT(*bytes_written, Eq(0));
+}
+
+TEST_P(WriteBytesToPidFromTest, NearUnmappedMemory) {
+  const uintptr_t page_size = getpagesize();
+  char* res = reinterpret_cast<char*>(mmap(nullptr, 2 * page_size,
+                                           PROT_READ | PROT_WRITE,
+                                           MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(res, Ne(MAP_FAILED));
+  ASSERT_THAT(munmap(&res[page_size], page_size), Eq(0));
+  absl::Cleanup cleanup = [res, page_size]() {
+    ASSERT_THAT(munmap(res, page_size), Eq(0));
+  };
+  char* data = &res[page_size - kTestString.size() / 2];
+  absl::StatusOr<size_t> bytes_written =
+      Write(getpid(), reinterpret_cast<uintptr_t>(data), kTestString);
+  ASSERT_THAT(bytes_written, IsOk());
+  EXPECT_THAT(*bytes_written, Eq(kTestString.size() / 2));
+  EXPECT_THAT(absl::MakeSpan(data, kTestString.size() / 2),
+              Eq(absl::MakeSpan(kTestString.data(), kTestString.size() / 2)));
+}
+
+TEST_P(WriteBytesToPidFromTest, ExceedIovMax) {
+  const uintptr_t page_size = getpagesize();
+  const size_t length = (IOV_MAX + 1) * page_size;
+  char* data = reinterpret_cast<char*>(mmap(nullptr, length + page_size,
+                                            PROT_READ | PROT_WRITE,
+                                            MAP_ANONYMOUS | MAP_PRIVATE, 0, 0));
+  ASSERT_THAT(data, Ne(MAP_FAILED));
+  // Unmap second page so there's a gap.
+  ASSERT_THAT(munmap(&data[length], page_size), Eq(0));
+  absl::Cleanup cleanup = [data, length]() {
+    ASSERT_THAT(munmap(data, length), Eq(0));
+  };
+  memset(data, 0, length);
+  const std::vector<char> src(length, 0x0e);
+  absl::StatusOr<size_t> bytes_written =
+      Write(getpid(), reinterpret_cast<uintptr_t>(data),
+            absl::MakeSpan(src.data(), length));
+  ASSERT_THAT(bytes_written, IsOk());
+  EXPECT_THAT(*bytes_written, Eq(length));
+  EXPECT_THAT(src, ElementsAreArray(data, length));
+}
+
+INSTANTIATE_TEST_SUITE_P(WriteBytesToPidFrom, WriteBytesToPidFromTest,
+                         testing::Values(true, false));
+
 }  // namespace
 }  // namespace sandbox2::util
diff --git a/sandboxed_api/sandbox2/violation.proto b/sandboxed_api/sandbox2/violation.proto
deleted file mode 100644
index 1622695..0000000
--- a/sandboxed_api/sandbox2/violation.proto
+++ /dev/null
@@ -1,150 +0,0 @@
-// Copyright 2019 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-syntax = "proto3";
-
-package sandbox2;
-
-import "sandboxed_api/sandbox2/mount_tree.proto";
-
-enum PBViolationType {
-  VIOLATION_TYPE_UNSPECIFIED = 0;
-  DISALLOWED_SYSCALL = 1;
-  RESOURCE_LIMIT_EXCEEDED = 2;
-  SYSCALL_ARCHITECTURE_MISMATCH = 3;
-}
-
-message RegisterX8664 {
-  uint64 r15 = 1;
-  uint64 r14 = 2;
-  uint64 r13 = 3;
-  uint64 r12 = 4;
-  uint64 rbp = 5;
-  uint64 rbx = 6;
-  uint64 r11 = 7;
-  uint64 r10 = 8;
-  uint64 r9 = 9;
-  uint64 r8 = 10;
-  uint64 rax = 11;
-  uint64 rcx = 12;
-  uint64 rdx = 13;
-  uint64 rsi = 14;
-  uint64 rdi = 15;
-  uint64 orig_rax = 16;
-  uint64 rip = 17;
-  uint64 cs = 18;
-  uint64 eflags = 19;
-  uint64 rsp = 20;
-  uint64 ss = 21;
-  uint64 fs_base = 22;
-  uint64 gs_base = 23;
-  uint64 ds = 24;
-  uint64 es = 25;
-  uint64 fs = 26;
-  uint64 gs = 27;
-}
-
-message RegisterPowerpc64 {
-  repeated uint64 gpr = 1;
-  uint64 nip = 2;
-  uint64 msr = 3;
-  uint64 orig_gpr3 = 4;
-  uint64 ctr = 5;
-  uint64 link = 6;
-  uint64 xer = 7;
-  uint64 ccr = 8;
-  uint64 softe = 9;
-  uint64 trap = 10;
-  uint64 dar = 11;
-  uint64 dsisr = 12;
-  uint64 result = 13;
-
-  uint64 zero0 = 14;
-  uint64 zero1 = 15;
-  uint64 zero2 = 16;
-  uint64 zero3 = 17;
-}
-
-message RegisterAarch64 {
-  repeated uint64 regs = 1;
-  uint64 sp = 2;
-  uint64 pc = 3;
-  uint64 pstate = 4;
-}
-
-message RegisterArm {
-  repeated uint32 regs = 1;
-  uint32 pc = 2;
-  uint32 cpsr = 3;
-  uint32 orig_x0 = 4;
-}
-
-message RegisterValues {
-  // Architecture architecture = 1;
-  oneof register_values {
-    RegisterX8664 register_x86_64 = 2;
-    RegisterPowerpc64 register_powerpc64 = 3;
-    RegisterAarch64 register_aarch64 = 4;
-    RegisterArm register_arm = 5;
-  }
-}
-
-message SyscallDescription {
-  int32 syscall = 1;
-  // Should we have a second one with the raw value?
-  // This would be redundant (We dump all registers) + should not be as useful
-  // for debugging as the decoded values.
-  repeated string argument = 2;
-  // Store the architecture of the desired syscall in here as well? Might be
-  // useful when the violation type was a change in syscall architecture.
-}
-
-message PolicyBuilderDescription {
-  repeated int32 handled_syscalls = 1;
-  repeated string bind_mounts = 2;
-  string built_at_sloc = 3;
-}
-
-message NamespaceDescription {
-  int32 clone_flags = 1;
-  // Do we want to have the mount tree in here?
-  MountTree mount_tree_mounts = 2;
-}
-
-message PolicyDescription {
-  bytes user_bpf_policy = 1;
-  reserved 2 to 5;
-  // This requires additional fields. (e.g. allowed syscall numbers)
-  PolicyBuilderDescription policy_builder_description = 6;
-
-  // namespace
-  NamespaceDescription namespace_description = 7;
-
-  repeated int32 capabilities = 8;
-}
-
-message Violation {
-  string legacy_fatal_message = 1;
-  PBViolationType violation_type = 2;
-  int32 pid = 3;
-  string prog_name = 4;
-  PolicyDescription policy = 5;
-  string stack_trace = 6;
-  SyscallDescription syscall_information = 7;
-  RegisterValues register_values = 8;
-  reserved 9;
-  string proc_maps = 10;
-  // Contains the received signal that caused the death if applicable.
-  int32 signal = 11;
-}
diff --git a/sandboxed_api/sapi_test.cc b/sandboxed_api/sapi_test.cc
index 6aa25ab..ec27c1f 100644
--- a/sandboxed_api/sapi_test.cc
+++ b/sandboxed_api/sapi_test.cc
@@ -13,34 +13,52 @@
 // limitations under the License.
 
 #include <fcntl.h>
+#include <limits.h>
+#include <sys/types.h>
 
+#include <cstddef>
+#include <cstdint>
 #include <memory>
 #include <string>
-#include <thread>  // NOLINT(build/c++11)
+#include <utility>
+#include <vector>
 
 #include "benchmark/benchmark.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
+#include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/strings/string_view.h"
 #include "absl/time/clock.h"
 #include "absl/time/time.h"
+#include "absl/types/span.h"
 #include "sandboxed_api/examples/stringop/stringop-sapi.sapi.h"
 #include "sandboxed_api/examples/stringop/stringop_params.pb.h"
 #include "sandboxed_api/examples/sum/sum-sapi.sapi.h"
 #include "sandboxed_api/sandbox.h"
+#include "sandboxed_api/sandbox2/result.h"
 #include "sandboxed_api/testing.h"
 #include "sandboxed_api/transaction.h"
+#include "sandboxed_api/util/status_macros.h"
 #include "sandboxed_api/util/status_matchers.h"
+#include "sandboxed_api/util/thread.h"
+#include "sandboxed_api/var_array.h"
+#include "sandboxed_api/var_int.h"
+#include "sandboxed_api/var_lenval.h"
+#include "sandboxed_api/var_reg.h"
+#include "sandboxed_api/var_struct.h"
 
 namespace sapi {
 namespace {
 
 using ::sapi::IsOk;
 using ::sapi::StatusIs;
+using ::testing::ContainerEq;
 using ::testing::Eq;
 using ::testing::Gt;
 using ::testing::HasSubstr;
+using ::testing::NotNull;
 
 // Functions that will be used during the benchmarks:
 
@@ -273,13 +291,13 @@ TEST(SandboxTest, NoRaceInConcurrentTerminate) {
   SumSandbox sandbox;
   ASSERT_THAT(sandbox.Init(), IsOk());
   SumApi api(&sandbox);
-  std::thread th([&sandbox] {
+  sapi::Thread th([&sandbox] {
     // Sleep so that the call already starts
     absl::SleepFor(absl::Seconds(1));
     sandbox.Terminate(/*attempt_graceful_exit=*/false);
   });
   EXPECT_THAT(api.sleep_for_sec(10), StatusIs(absl::StatusCode::kUnavailable));
-  th.join();
+  th.Join();
   const auto& result = sandbox.AwaitResult();
   EXPECT_THAT(result.final_status(), Eq(sandbox2::Result::EXTERNAL_KILL));
 }
@@ -303,5 +321,112 @@ TEST(SandboxTest, UseUnotifyMonitor) {
   EXPECT_THAT(result, Eq(3));
 }
 
+TEST(SandboxTest, AllocateAndTransferTest) {
+  std::string test_string("This is a test");
+  std::vector<uint8_t> test_string_vector(test_string.begin(),
+                                          test_string.end());
+
+  absl::Span<uint8_t> buffer_input(
+      reinterpret_cast<uint8_t*>(test_string_vector.data()),
+      test_string_vector.size());
+  std::vector<uint8_t> buffer_output(test_string_vector.size());
+
+  SumSandbox sandbox;
+  ASSERT_THAT(sandbox.Init(), IsOk());
+  SumApi api(&sandbox);
+
+  SAPI_ASSERT_OK_AND_ASSIGN(
+      auto sapi_array, sandbox.AllocateAndTransferToSandboxee(buffer_input));
+  ASSERT_THAT(sapi_array, NotNull());
+  sapi::v::Array<const uint8_t> sapi_buffer_output(
+      reinterpret_cast<const uint8_t*>(buffer_output.data()),
+      buffer_output.size());
+  sapi_buffer_output.SetRemote(sapi_array->GetRemote());
+  ASSERT_THAT(sandbox.TransferFromSandboxee(&sapi_buffer_output), IsOk());
+  EXPECT_THAT(test_string_vector, ContainerEq(buffer_output));
+}
+
+TEST(SandboxTest, AllocateAndTransferTestLarge) {
+  const size_t kLargeSize = getpagesize() * (IOV_MAX + 1);
+  const std::string test_string(kLargeSize, 'A');
+  std::vector<uint8_t> test_string_vector(test_string.begin(),
+                                          test_string.end());
+
+  absl::Span<uint8_t> buffer_input(
+      reinterpret_cast<uint8_t*>(test_string_vector.data()),
+      test_string_vector.size());
+  std::vector<uint8_t> buffer_output(test_string_vector.size());
+
+  SumSandbox sandbox;
+  ASSERT_THAT(sandbox.Init(), IsOk());
+  SumApi api(&sandbox);
+
+  SAPI_ASSERT_OK_AND_ASSIGN(
+      auto sapi_array, sandbox.AllocateAndTransferToSandboxee(buffer_input));
+  ASSERT_THAT(sapi_array, NotNull());
+  sapi::v::Array<const uint8_t> sapi_buffer_output(
+      reinterpret_cast<const uint8_t*>(buffer_output.data()),
+      buffer_output.size());
+  sapi_buffer_output.SetRemote(sapi_array->GetRemote());
+  ASSERT_THAT(sandbox.TransferFromSandboxee(&sapi_buffer_output), IsOk());
+  EXPECT_THAT(test_string_vector, ContainerEq(buffer_output));
+}
+
+TEST(VarsTest, MoveOperations) {
+  {
+    v::Array<const uint8_t> array_orig(128);  // Allocates locally
+    const uint8_t* data_before = array_orig.GetData();
+
+    v::Array<const uint8_t> array_new(std::move(array_orig));
+    array_orig = std::move(array_new);  // Move back
+
+    const uint8_t* data_after = array_orig.GetData();
+    EXPECT_THAT(data_before, Eq(data_after));
+  }
+  {
+    constexpr absl::string_view kData = "Physcially fit";
+    v::LenVal len_val_orig(kData.data(), kData.size());
+    const uint8_t* data_before = len_val_orig.GetData();
+
+    v::LenVal len_val_new(std::move(len_val_orig));
+    len_val_orig = std::move(len_val_new);  // Move back
+
+    const uint8_t* data_after = len_val_orig.GetData();
+    EXPECT_THAT(data_before, Eq(data_after));
+  }
+  {
+    stringop::StringDuplication underlying_proto;
+    SAPI_ASSERT_OK_AND_ASSIGN(
+        auto proto_orig,
+        v::Proto<stringop::StringDuplication>::FromMessage(underlying_proto));
+
+    v::Proto<stringop::StringDuplication> proto_new(std::move(proto_orig));
+    proto_orig = std::move(proto_new);  // Move back
+  }
+  {
+    v::Reg<uint64_t> reg_orig(0x414141);
+    uint64_t value_before = reg_orig.GetValue();
+
+    v::Reg<uint64_t> reg_new(std::move(reg_orig));
+    reg_orig = std::move(reg_new);  // Move back
+
+    uint64_t value_after = reg_orig.GetValue();
+    EXPECT_THAT(value_before, Eq(value_after));
+  }
+  {
+    struct MyStruct {
+      int member = 0x414141;
+    };
+    v::Struct<MyStruct> struct_orig;
+    MyStruct* data_before = struct_orig.mutable_data();
+
+    v::Struct<MyStruct> struct_new(std::move(struct_orig));
+    struct_orig = std::move(struct_new);  // Move back
+
+    MyStruct* data_after = struct_orig.mutable_data();
+    EXPECT_THAT(data_before, Eq(data_after));
+  }
+}
+
 }  // namespace
 }  // namespace sapi
diff --git a/sandboxed_api/testing.cc b/sandboxed_api/testing.cc
index 1a71a25..06ddbfd 100644
--- a/sandboxed_api/testing.cc
+++ b/sandboxed_api/testing.cc
@@ -19,7 +19,7 @@
 
 #include "absl/strings/string_view.h"
 #include "sandboxed_api/config.h"
-#include "sandboxed_api/sandbox2/allow_all_syscalls.h"
+#include "sandboxed_api/sandbox2/allowlists/all_syscalls.h"
 #include "sandboxed_api/sandbox2/policybuilder.h"
 #include "sandboxed_api/util/path.h"
 
@@ -30,12 +30,9 @@ sandbox2::PolicyBuilder CreateDefaultPermissiveTestPolicy(
   sandbox2::PolicyBuilder builder;
   // Don't restrict the syscalls at all.
   builder.DefaultAction(sandbox2::AllowAllSyscalls());
-  if (sapi::host_os::IsAndroid()) {
-    builder.DisableNamespaces();
-    return builder;
-  }
   if (IsCoverageRun()) {
-    builder.AddDirectory(getenv("COVERAGE_DIR"), /*is_ro=*/false);
+    builder.AddDirectory(absl::NullSafeStringView(getenv("COVERAGE_DIR")),
+                         /*is_ro=*/false);
   }
   if constexpr (sapi::sanitizers::IsAny()) {
     builder.AddLibrariesForBinary(bin_path);
diff --git a/sandboxed_api/testing.h b/sandboxed_api/testing.h
index e196bea..c0ea984 100644
--- a/sandboxed_api/testing.h
+++ b/sandboxed_api/testing.h
@@ -21,23 +21,6 @@
 #include "sandboxed_api/config.h"  // IWYU pragma: export
 #include "sandboxed_api/sandbox2/policybuilder.h"
 
-// The macro SKIP_ANDROID can be used in tests to skip running a
-// given test (by emitting 'retrun') when running on Android. Example:
-//
-//    TEST(Foo, Bar) {
-//      SKIP_ANDROID;
-//      [...]
-//      }
-//
-// The reason for this is because certain unit tests require the use of user
-// namespaces which are not present on Android.
-#define SKIP_ANDROID                            \
-  do {                                          \
-    if constexpr (sapi::host_os::IsAndroid()) { \
-      return;                                   \
-    }                                           \
-  } while (0)
-
 // The macro SKIP_SANITIZERS_AND_COVERAGE can be used in tests to skip running
 // a given test (by emitting 'return') when running under one of the sanitizers
 // (ASan, MSan, TSan) or under code coverage. Example:
diff --git a/sandboxed_api/tools/clang_generator/BUILD.bazel b/sandboxed_api/tools/clang_generator/BUILD
similarity index 74%
rename from sandboxed_api/tools/clang_generator/BUILD.bazel
rename to sandboxed_api/tools/clang_generator/BUILD
index 210a4f9..cc94354 100644
--- a/sandboxed_api/tools/clang_generator/BUILD.bazel
+++ b/sandboxed_api/tools/clang_generator/BUILD
@@ -12,7 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
 
 licenses(["notice"])
 
@@ -21,20 +21,22 @@ cc_library(
     srcs = [
         "diagnostics.cc",
         "emitter.cc",
+        "emitter_base.cc",
         "generator.cc",
         "types.cc",
     ],
     hdrs = [
         "diagnostics.h",
         "emitter.h",
+        "emitter_base.h",
         "generator.h",
         "types.h",
     ],
     copts = sapi_platform_copts(),
     deps = [
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/container:node_hash_set",
+        "@com_google_absl//absl/log",
         "@com_google_absl//absl/random",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
@@ -42,13 +44,18 @@ cc_library(
         "@com_google_absl//absl/strings:cord",
         "@com_google_absl//absl/strings:str_format",
         "@com_google_absl//absl/types:optional",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
         "@llvm-project//clang:ast",
         "@llvm-project//clang:basic",
         "@llvm-project//clang:format",
         "@llvm-project//clang:frontend",
         "@llvm-project//clang:lex",
+        "@llvm-project//clang:serialization",
         "@llvm-project//clang:tooling",
+        "@llvm-project//clang:tooling_core",
         "@llvm-project//llvm:Support",
+        "@llvm-project//llvm:config",
     ],
 )
 
@@ -62,17 +69,18 @@ cc_test(
     copts = sapi_platform_copts(),
     deps = [
         ":generator",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
         "@llvm-project//clang:basic",
         "@llvm-project//clang:frontend",
         "@llvm-project//clang:tooling",
         "@llvm-project//llvm:Support",
+        "@llvm-project//llvm:config",
     ],
 )
 
@@ -88,16 +96,18 @@ cc_binary(
     visibility = ["//visibility:public"],
     deps = [
         ":generator",
-        "//sandboxed_api/util:file_base",
-        "//sandboxed_api/util:file_helpers",
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:status",
+        "@com_google_absl//absl/base:core_headers",
+        "@com_google_absl//absl/base:no_destructor",
         "@com_google_absl//absl/status",
-        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_base",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_helpers",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
         "@llvm-project//clang:driver",
         "@llvm-project//clang:tooling",
         "@llvm-project//llvm:Support",
+        "@llvm-project//llvm:config",
     ],
 )
diff --git a/sandboxed_api/tools/clang_generator/CMakeLists.txt b/sandboxed_api/tools/clang_generator/CMakeLists.txt
index 8a373ef..31b1446 100644
--- a/sandboxed_api/tools/clang_generator/CMakeLists.txt
+++ b/sandboxed_api/tools/clang_generator/CMakeLists.txt
@@ -24,6 +24,8 @@ add_library(sapi_generator
   diagnostics.h
   emitter.h
   emitter.cc
+  emitter_base.h
+  emitter_base.cc
   generator.h
   generator.cc
   types.h
@@ -121,7 +123,10 @@ add_executable(sapi_generator_tool
   generator_tool.cc
 )
 target_link_libraries(sapi_generator_tool PRIVATE
-  absl::statusor
+  absl::base
+  absl::no_destructor
+  absl::status
+  absl::strings
   sapi::base
   sapi::file_base
   sapi::file_helpers
diff --git a/sandboxed_api/tools/clang_generator/compilation_database.cc b/sandboxed_api/tools/clang_generator/compilation_database.cc
index 879796b..7954457 100644
--- a/sandboxed_api/tools/clang_generator/compilation_database.cc
+++ b/sandboxed_api/tools/clang_generator/compilation_database.cc
@@ -23,11 +23,25 @@
 #include "absl/strings/string_view.h"
 #include "absl/strings/strip.h"
 #include "clang/Driver/Types.h"
+#include "clang/Tooling/ArgumentsAdjusters.h"
+#include "clang/Tooling/CommonOptionsParser.h"
 #include "clang/Tooling/CompilationDatabase.h"
+#include "llvm/Config/llvm-config.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Error.h"
 #include "llvm/Support/Path.h"
+#include "llvm/Support/raw_ostream.h"
 
 namespace sapi {
 
+static llvm::cl::SubCommand& GetAllSubCommands() {
+#if LLVM_VERSION_MAJOR >= 15
+  return llvm::cl::SubCommand::getAll();
+#else
+  return *llvm::cl::AllSubCommands;
+#endif
+}
+
 class WrappingCompilationDatabase : public clang::tooling::CompilationDatabase {
  public:
   explicit WrappingCompilationDatabase(
@@ -149,24 +163,24 @@ llvm::Error OptionsParser::init(int& argc, const char** argv,
                                 const char* overview) {
   static auto* build_path = new llvm::cl::opt<std::string>(
       "p", llvm::cl::desc("Build path"), llvm::cl::Optional,
-      llvm::cl::cat(category), llvm::cl::sub(*llvm::cl::AllSubCommands));
+      llvm::cl::cat(category), llvm::cl::sub(GetAllSubCommands()));
 
   static auto* source_paths = new llvm::cl::list<std::string>(
       llvm::cl::Positional, llvm::cl::desc("<source0> [... <sourceN>]"),
       occurrences_flag, llvm::cl::cat(category),
-      llvm::cl::sub(*llvm::cl::AllSubCommands));
+      llvm::cl::sub(GetAllSubCommands()));
 
   static auto* args_after = new llvm::cl::list<std::string>(
       "extra-arg",
       llvm::cl::desc(
           "Additional argument to append to the compiler command line"),
-      llvm::cl::cat(category), llvm::cl::sub(*llvm::cl::AllSubCommands));
+      llvm::cl::cat(category), llvm::cl::sub(GetAllSubCommands()));
 
   static auto* args_before = new llvm::cl::list<std::string>(
       "extra-arg-before",
       llvm::cl::desc(
           "Additional argument to prepend to the compiler command line"),
-      llvm::cl::cat(category), llvm::cl::sub(*llvm::cl::AllSubCommands));
+      llvm::cl::cat(category), llvm::cl::sub(GetAllSubCommands()));
 
   llvm::cl::ResetAllOptionOccurrences();
 
diff --git a/sandboxed_api/tools/clang_generator/compilation_database.h b/sandboxed_api/tools/clang_generator/compilation_database.h
index 7575df0..81bd2a7 100644
--- a/sandboxed_api/tools/clang_generator/compilation_database.h
+++ b/sandboxed_api/tools/clang_generator/compilation_database.h
@@ -17,13 +17,10 @@
 
 #include <memory>
 #include <string>
-#include <utility>
 #include <vector>
 
 #include "clang/Tooling/ArgumentsAdjusters.h"
-#include "clang/Tooling/CommonOptionsParser.h"
 #include "clang/Tooling/CompilationDatabase.h"
-#include "llvm/ADT/StringRef.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Error.h"
 
diff --git a/sandboxed_api/tools/clang_generator/diagnostics.cc b/sandboxed_api/tools/clang_generator/diagnostics.cc
index a8880be..8f02f85 100644
--- a/sandboxed_api/tools/clang_generator/diagnostics.cc
+++ b/sandboxed_api/tools/clang_generator/diagnostics.cc
@@ -23,6 +23,8 @@
 #include "absl/strings/string_view.h"
 #include "absl/types/optional.h"
 #include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/SourceLocation.h"
+#include "llvm/ADT/StringRef.h"
 
 namespace sapi {
 
diff --git a/sandboxed_api/tools/clang_generator/emitter.cc b/sandboxed_api/tools/clang_generator/emitter.cc
index ab14b0d..6e6086c 100644
--- a/sandboxed_api/tools/clang_generator/emitter.cc
+++ b/sandboxed_api/tools/clang_generator/emitter.cc
@@ -14,19 +14,14 @@
 
 #include "sandboxed_api/tools/clang_generator/emitter.h"
 
-#include <algorithm>
-#include <cstdint>
 #include <string>
 #include <utility>
 #include <vector>
 
 #include "absl/container/flat_hash_set.h"
-#include "absl/container/node_hash_set.h"
-#include "absl/random/random.h"
+#include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
-#include "absl/strings/ascii.h"
-#include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
@@ -36,30 +31,29 @@
 #include "absl/strings/strip.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
+#include "clang/AST/DeclBase.h"
 #include "clang/AST/DeclCXX.h"
-#include "clang/AST/DeclTemplate.h"
-#include "clang/AST/QualTypeNames.h"
 #include "clang/AST/Type.h"
-#include "clang/Format/Format.h"
 #include "sandboxed_api/tools/clang_generator/diagnostics.h"
+#include "sandboxed_api/tools/clang_generator/emitter_base.h"
 #include "sandboxed_api/tools/clang_generator/generator.h"
 #include "sandboxed_api/tools/clang_generator/types.h"
 #include "sandboxed_api/util/status_macros.h"
 
 namespace sapi {
 
-// Common file prolog with auto-generation notice.
+// Common header description with auto-generation notice.
+constexpr absl::string_view kHeaderDescription =
+    R"(// AUTO-GENERATED by the Sandboxed API generator.
+// Edits will be discarded when regenerating this file.)";
+
+// Common header file prolog with auto-generation notice.
 // Note: The includes will be adjusted by Copybara when converting to/from
 //       internal code. This is intentional.
 // Text template arguments:
 //   1. Header guard
-constexpr absl::string_view kHeaderProlog =
-    R"(// AUTO-GENERATED by the Sandboxed API generator.
-// Edits will be discarded when regenerating this file.
-
-#ifndef %1$s
-#define %1$s
-
+constexpr absl::string_view kHeaderIncludes =
+    R"(
 #include <cstdint>
 #include <type_traits>
 
@@ -71,9 +65,6 @@ constexpr absl::string_view kHeaderProlog =
 #include "sandboxed_api/vars.h"
 
 )";
-constexpr absl::string_view kHeaderEpilog =
-    R"(
-#endif  // %1$s)";
 
 // Text template arguments:
 //   1. Include for embedded sandboxee objects
@@ -81,18 +72,6 @@ constexpr absl::string_view kEmbedInclude = R"(#include "%1$s_embed.h"
 
 )";
 
-// Text template arguments:
-//   1. Namespace name
-constexpr absl::string_view kNamespaceBeginTemplate =
-    R"(
-namespace %1$s {
-
-)";
-constexpr absl::string_view kNamespaceEndTemplate =
-    R"(
-}  // namespace %1$s
-)";
-
 // Text template arguments:
 //   1. Class name
 //   2. Embedded object identifier
@@ -100,11 +79,17 @@ constexpr absl::string_view kEmbedClassTemplate = R"(
 // Sandbox with embedded sandboxee and default policy
 class %1$s : public ::sapi::Sandbox {
  public:
-  %1$s() : ::sapi::Sandbox(%2$s_embed_create()) {}
+  %1$s()
+      : ::sapi::Sandbox([]() {
+          static auto* fork_client_context =
+              new ::sapi::ForkClientContext(%2$s_embed_create());
+          return fork_client_context;
+        }()) {}
 };
 
 )";
 
+// Sandboxed API class template.
 // Text template arguments:
 //   1. Class name
 constexpr absl::string_view kClassHeaderTemplate = R"(
@@ -113,167 +98,21 @@ class %1$s {
  public:
   explicit %1$s(::sapi::Sandbox* sandbox) : sandbox_(sandbox) {}
 
+
   ABSL_DEPRECATED("Call sandbox() instead")
   ::sapi::Sandbox* GetSandbox() const { return sandbox(); }
   ::sapi::Sandbox* sandbox() const { return sandbox_; }
 )";
 
+// Sandboxed API class template footer.
 constexpr absl::string_view kClassFooterTemplate = R"(
  private:
   ::sapi::Sandbox* sandbox_;
 };
 )";
 
-namespace internal {
-
-absl::StatusOr<std::string> ReformatGoogleStyle(const std::string& filename,
-                                                const std::string& code,
-                                                int column_limit) {
-  // Configure code style based on Google style, but enforce pointer alignment
-  clang::format::FormatStyle style =
-      clang::format::getGoogleStyle(clang::format::FormatStyle::LK_Cpp);
-  style.DerivePointerAlignment = false;
-  style.PointerAlignment = clang::format::FormatStyle::PAS_Left;
-  if (column_limit >= 0) {
-    style.ColumnLimit = column_limit;
-  }
-
-  clang::tooling::Replacements replacements = clang::format::reformat(
-      style, code, llvm::ArrayRef(clang::tooling::Range(0, code.size())),
-      filename);
-
-  llvm::Expected<std::string> formatted_header =
-      clang::tooling::applyAllReplacements(code, replacements);
-  if (!formatted_header) {
-    return absl::InternalError(llvm::toString(formatted_header.takeError()));
-  }
-  return *formatted_header;
-}
-
-}  // namespace internal
-
-std::string GetIncludeGuard(absl::string_view filename) {
-  if (filename.empty()) {
-    static auto* bit_gen = new absl::BitGen();
-    return absl::StrCat(
-        // Copybara will transform the string. This is intentional.
-        "SANDBOXED_API_GENERATED_HEADER_",
-        absl::AsciiStrToUpper(absl::StrCat(
-            absl::Hex(absl::Uniform<uint64_t>(*bit_gen), absl::kZeroPad16))),
-        "_");
-  }
-
-  constexpr absl::string_view kUnderscorePrefix = "SAPI_";
-  std::string guard;
-  guard.reserve(filename.size() + kUnderscorePrefix.size() + 1);
-  for (auto c : filename) {
-    if (absl::ascii_isalpha(c)) {
-      guard += absl::ascii_toupper(c);
-      continue;
-    }
-    if (guard.empty()) {
-      guard = kUnderscorePrefix;
-    }
-    if (absl::ascii_isdigit(c)) {
-      guard += c;
-    } else if (guard.back() != '_') {
-      guard += '_';
-    }
-  }
-  if (!absl::EndsWith(guard, "_")) {
-    guard += '_';
-  }
-  return guard;
-}
-
-// Returns the namespace components of a declaration's qualified name.
-std::vector<std::string> GetNamespacePath(const clang::TypeDecl* decl) {
-  std::vector<std::string> comps;
-  for (const auto* ctx = decl->getDeclContext(); ctx; ctx = ctx->getParent()) {
-    if (const auto* nd = llvm::dyn_cast<clang::NamespaceDecl>(ctx)) {
-      comps.push_back(nd->getName().str());
-    }
-  }
-  std::reverse(comps.begin(), comps.end());
-  return comps;
-}
-
-std::string PrintRecordTemplateArguments(const clang::CXXRecordDecl* record) {
-  const auto* template_inst_decl = record->getTemplateInstantiationPattern();
-  if (!template_inst_decl) {
-    return "";
-  }
-  const auto* template_decl = template_inst_decl->getDescribedClassTemplate();
-  if (!template_decl) {
-    return "";
-  }
-  const auto* template_params = template_decl->getTemplateParameters();
-  if (!template_params) {
-    return "";
-  }
-  clang::ASTContext& context = record->getASTContext();
-  std::vector<std::string> params;
-  params.reserve(template_params->size());
-  for (const auto& template_param : *template_params) {
-    if (const auto* p =
-            llvm::dyn_cast<clang::NonTypeTemplateParmDecl>(template_param)) {
-      // TODO(cblichmann): Should be included by CollectRelatedTypes().
-      params.push_back(clang::TypeName::getFullyQualifiedName(
-          p->getType().getDesugaredType(context), context,
-          context.getPrintingPolicy()));
-    } else {  // Also covers template template parameters
-      params.push_back("typename");
-    }
-    absl::StrAppend(&params.back(), " /*",
-                    std::string(template_param->getName()), "*/");
-  }
-  return absl::StrCat("template <", absl::StrJoin(params, ", "), ">");
-}
-
-// Serializes the given Clang AST declaration back into compilable source code.
-std::string PrintDecl(const clang::Decl* decl) {
-  std::string pretty;
-  llvm::raw_string_ostream os(pretty);
-  decl->print(os);
-  return os.str();
-}
-
-// Returns the spelling for a given declaration will be emitted to the final
-// header. This may rewrite declarations (like converting typedefs to using,
-// etc.). Note that the resulting spelling will need to be wrapped inside a
-// namespace if the original declaration was inside one.
-std::string GetSpelling(const clang::Decl* decl) {
-  // TODO(cblichmann): Make types nicer
-  //   - Rewrite typedef to using
-  //   - Rewrite function pointers using std::add_pointer_t<>;
-
-  if (const auto* typedef_decl = llvm::dyn_cast<clang::TypedefNameDecl>(decl)) {
-    // Special case: anonymous enum/struct
-    if (auto* tag_decl = typedef_decl->getAnonDeclWithTypedefName()) {
-      return absl::StrCat("typedef ", PrintDecl(tag_decl), " ",
-                          ToStringView(typedef_decl->getName()));
-    }
-  }
-
-  if (const auto* record_decl = llvm::dyn_cast<clang::CXXRecordDecl>(decl)) {
-    if (record_decl->hasDefinition() &&
-        // Aggregates capture all C-like structs, but also structs with
-        // non-static members that have default initializers.
-        record_decl->isAggregate() &&
-        // Make sure to skip types with user-defined methods (including
-        // constructors).
-        record_decl->methods().empty()) {
-      return PrintDecl(decl);
-    }
-    // For unsupported types or types with no definition, only emit a forward
-    // declaration.
-    return absl::StrCat(PrintRecordTemplateArguments(record_decl),
-                        record_decl->isClass() ? "class " : "struct ",
-                        ToStringView(record_decl->getName()));
-  }
-  return PrintDecl(decl);
-}
-
+// Returns a unique name for a parameter. If `decl` has no name, a unique name
+// will be generated in the form of `unnamed<index>_`.
 std::string GetParamName(const clang::ParmVarDecl* decl, int index) {
   if (std::string name = decl->getName().str(); !name.empty()) {
     return absl::StrCat(name, "_");  // Suffix to avoid collisions
@@ -281,6 +120,8 @@ std::string GetParamName(const clang::ParmVarDecl* decl, int index) {
   return absl::StrCat("unnamed", index, "_");
 }
 
+// Returns a comment for the given function `decl` which represents the
+// unsandboxed function signature.
 absl::StatusOr<std::string> PrintFunctionPrototypeComment(
     const clang::FunctionDecl* decl) {
   const clang::ASTContext& context = decl->getASTContext();
@@ -313,25 +154,27 @@ absl::StatusOr<std::string> PrintFunctionPrototypeComment(
   return out;
 }
 
+// Emits the given function `decl` as SAPI function with a leading comment
+// documenting the unsandboxed function signature.
 absl::StatusOr<std::string> EmitFunction(const clang::FunctionDecl* decl) {
   const clang::QualType return_type = decl->getDeclaredReturnType();
+
+  // Skip functions returning record by value.
   if (return_type->isRecordType()) {
     return MakeStatusWithDiagnostic(
         decl->getBeginLoc(), absl::StatusCode::kCancelled,
-        "returning record by value, skipping function");
+        "Returning record by value, skipping function.");
   }
-  std::string out;
 
   SAPI_ASSIGN_OR_RETURN(std::string prototype,
                         PrintFunctionPrototypeComment(decl));
+  std::string out;
   absl::StrAppend(&out, "\n", prototype);
 
   auto function_name = ToStringView(decl->getName());
   const bool returns_void = return_type->isVoidType();
-
   const clang::ASTContext& context = decl->getASTContext();
 
-  // "Status<OptionalReturn> FunctionName("
   absl::StrAppend(&out, MapQualTypeReturn(context, return_type), " ",
                   function_name, "(");
 
@@ -341,15 +184,18 @@ absl::StatusOr<std::string> EmitFunction(const clang::FunctionDecl* decl) {
   };
   std::vector<ParameterInfo> params;
 
+  // Process the function parameter list.
   std::string print_separator;
   for (int i = 0; i < decl->getNumParams(); ++i) {
     const clang::ParmVarDecl* param = decl->getParamDecl(i);
+
+    // Skip functions with record parameters passed by value.
     if (param->getType()->isRecordType()) {
       return MakeStatusWithDiagnostic(
           param->getBeginLoc(), absl::StatusCode::kCancelled,
-          absl::StrCat("passing record parameter '",
+          absl::StrCat("Passing record parameter '",
                        ToStringView(param->getName()),
-                       "' by value, skipping function"));
+                       "' by value, skipping function."));
     }
 
     ParameterInfo& param_info = params.emplace_back();
@@ -363,31 +209,56 @@ absl::StatusOr<std::string> EmitFunction(const clang::FunctionDecl* decl) {
   }
 
   absl::StrAppend(&out, ") {\n");
+
+  // Declare the return value of the SAPI function.
   absl::StrAppend(&out, MapQualType(context, return_type), " v_ret_;\n");
+
+  // Declare the local variables for the parameters.
   for (const auto& [qual, name] : params) {
     if (!IsPointerOrReference(qual)) {
       absl::StrAppend(&out, MapQualType(context, qual), " v_", name, "(", name,
                       ");\n");
     }
   }
+
+  // Call the sandboxed function.
   absl::StrAppend(&out, "\nSAPI_RETURN_IF_ERROR(sandbox_->Call(\"",
                   function_name, "\", &v_ret_");
   for (const auto& [qual, name] : params) {
     absl::StrAppend(&out, ", ", IsPointerOrReference(qual) ? "" : "&v_", name);
   }
+
+  // End the sandboxed function call and return `ok` if the unsandboxed function
+  // returns void, or else return the value of the SAPI function.
   absl::StrAppend(&out, "));\nreturn ",
                   (returns_void ? "::absl::OkStatus()" : "v_ret_.GetValue()"),
                   ";\n}\n");
   return out;
 }
 
+// Emits the SAPI header.
 absl::StatusOr<std::string> EmitHeader(
     const std::vector<std::string>& function_definitions,
     const std::vector<const RenderedType*>& rendered_types,
     const GeneratorOptions& options) {
+  // Log a warning message if the number of requested functions is not equal to
+  // the number of functions generated.
+  if (!options.function_names.empty() &&
+      (options.function_names.size() != function_definitions.size())) {
+    LOG(WARNING) << "Generated output has fewer functions than expected - some "
+                    "function signatures might use language features that "
+                    "SAPI does not support. For debugging, we recommend you "
+                    "compare the list of functions in your sapi_library() rule "
+                    "with the generated *.sapi.h file. Expected: "
+                 << options.function_names.size()
+                 << ", generated: " << function_definitions.size();
+  }
   std::string out;
   const std::string include_guard = GetIncludeGuard(options.out_file);
+  absl::StrAppend(&out, kHeaderDescription);
   absl::StrAppendFormat(&out, kHeaderProlog, include_guard);
+  absl::StrAppend(&out, kHeaderIncludes);
+
   // When embedding the sandboxee, add embed header include
   if (!options.embed_name.empty()) {
     // Not using JoinPath() because even on Windows include paths use plain
@@ -433,14 +304,12 @@ absl::StatusOr<std::string> EmitHeader(
 
   // Optionally emit a default sandbox that instantiates an embedded sandboxee
   if (!options.embed_name.empty()) {
-    // TODO(cblichmann): Make the "Sandbox" suffix configurable.
     absl::StrAppendFormat(
         &out, kEmbedClassTemplate, absl::StrCat(options.name, "Sandbox"),
         absl::StrReplaceAll(options.embed_name, {{"-", "_"}}));
   }
 
   // Emit the actual Sandboxed API
-  // TODO(cblichmann): Make the "Api" suffix configurable or at least optional.
   absl::StrAppendFormat(&out, kClassHeaderTemplate,
                         absl::StrCat(options.name, "Api"));
   absl::StrAppend(&out, absl::StrJoin(function_definitions, "\n"));
@@ -454,66 +323,6 @@ absl::StatusOr<std::string> EmitHeader(
   return out;
 }
 
-void Emitter::EmitType(clang::TypeDecl* type_decl) {
-  if (!type_decl) {
-    return;
-  }
-
-  // Skip types defined in system headers.
-  // TODO(cblichmann): Instead of this and the hard-coded entities below, we
-  //                   should map types and add the correct (system) headers to
-  //                   the generated output.
-  if (type_decl->getASTContext().getSourceManager().isInSystemHeader(
-          type_decl->getBeginLoc())) {
-    return;
-  }
-
-  const std::vector<std::string> ns_path = GetNamespacePath(type_decl);
-  std::string ns_name;
-  if (!ns_path.empty()) {
-    const auto& ns_root = ns_path.front();
-    // Filter out declarations from the C++ standard library, from SAPI itself
-    // and from other well-known namespaces.
-    if (ns_root == "std" || ns_root == "__gnu_cxx" || ns_root == "sapi") {
-      return;
-    }
-    if (ns_root == "absl") {
-      // Skip Abseil internal namespaces
-      if (ns_path.size() > 1 && absl::EndsWith(ns_path[1], "_internal")) {
-        return;
-      }
-      // Skip types from Abseil that will already be included in the generated
-      // header.
-      if (auto name = ToStringView(type_decl->getName());
-          name == "CordMemoryAccounting" || name == "Duration" ||
-          name == "LogEntry" || name == "LogSeverity" || name == "Span" ||
-          name == "StatusCode" || name == "StatusToStringMode" ||
-          name == "SynchLocksHeld" || name == "SynchWaitParams" ||
-          name == "Time" || name == "string_view" || name == "tid_t") {
-        return;
-      }
-    }
-    // Skip Protocol Buffers namespaces
-    if (ns_root == "google" && ns_path.size() > 1 && ns_path[1] == "protobuf") {
-      return;
-    }
-    ns_name = absl::StrJoin(ns_path, "::");
-  }
-
-  std::string spelling = GetSpelling(type_decl);
-  if (const auto& [it, inserted] = rendered_types_.emplace(ns_name, spelling);
-      inserted) {
-    rendered_types_ordered_.push_back(&*it);
-  }
-}
-
-void Emitter::AddTypeDeclarations(
-    const std::vector<clang::TypeDecl*>& type_decls) {
-  for (clang::TypeDecl* type_decl : type_decls) {
-    EmitType(type_decl);
-  }
-}
-
 absl::Status Emitter::AddFunction(clang::FunctionDecl* decl) {
   if (rendered_functions_.insert(decl->getQualifiedNameAsString()).second) {
     SAPI_ASSIGN_OR_RETURN(std::string function, EmitFunction(decl));
diff --git a/sandboxed_api/tools/clang_generator/emitter.h b/sandboxed_api/tools/clang_generator/emitter.h
index f0f5996..c8b5a67 100644
--- a/sandboxed_api/tools/clang_generator/emitter.h
+++ b/sandboxed_api/tools/clang_generator/emitter.h
@@ -16,93 +16,37 @@
 #define SANDBOXED_API_TOOLS_CLANG_GENERATOR_EMITTER_H_
 
 #include <string>
-#include <utility>
 #include <vector>
 
-#include "absl/container/flat_hash_set.h"
-#include "absl/container/node_hash_set.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
-#include "absl/strings/string_view.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/Type.h"
-#include "sandboxed_api/tools/clang_generator/types.h"
+#include "sandboxed_api/tools/clang_generator/emitter_base.h"
 
 namespace sapi {
-namespace internal {
 
-absl::StatusOr<std::string> ReformatGoogleStyle(const std::string& filename,
-                                                const std::string& code,
-                                                int column_limit = -1);
-
-}  // namespace internal
-
-class GeneratorOptions;
-
-class RenderedType {
- public:
-  RenderedType(std::string ns_name, std::string spelling)
-      : ns_name(std::move(ns_name)), spelling(std::move(spelling)) {}
-
-  bool operator==(const RenderedType& other) const {
-    return ns_name == other.ns_name && spelling == other.spelling;
-  }
-
-  template <typename H>
-  friend H AbslHashValue(H h, RenderedType rt) {
-    return H::combine(std::move(h), rt.ns_name, rt.spelling);
-  }
-
-  std::string ns_name;
-  std::string spelling;
-};
+// Forward declaration to avoid circular dependencies.
+struct GeneratorOptions;
 
 // Responsible for emitting the actual textual representation of the generated
 // Sandboxed API header.
-class Emitter {
+class Emitter : public EmitterBase {
  public:
-  // Adds the declarations of previously collected types to the emitter,
-  // recording the spelling of each one. Types/declarations that are not
-  // supported by the current generator settings or that are unwanted or
-  // unnecessary are skipped. Other filtered types include C++ constructs or
-  // well-known standard library elements. The latter can be replaced by
-  // including the correct headers in the emitted header.
-  void AddTypeDeclarations(const std::vector<clang::TypeDecl*>& type_decls);
-
-  absl::Status AddFunction(clang::FunctionDecl* decl);
+  // Adds a function to the list of functions to be rendered. In addition, it
+  // stores the original and SAPI function information for safe drop-in
+  // generation.
+  absl::Status AddFunction(clang::FunctionDecl* decl) override;
 
   // Outputs a formatted header for a list of functions and their related types.
   absl::StatusOr<std::string> EmitHeader(const GeneratorOptions& options);
 
- private:
-  void EmitType(clang::TypeDecl* type_decl);
-
  protected:
-  // Stores namespaces and a list of spellings for types. Keeps track of types
-  // that have been rendered so far. Using a node_hash_set for pointer
-  // stability.
-  absl::node_hash_set<RenderedType> rendered_types_;
-
-  // A vector to preserve the order of type declarations needs to be preserved.
-  std::vector<const RenderedType*> rendered_types_ordered_;
-
-  // Fully qualified names of functions for the sandboxed API. Keeps track of
-  // functions that have been rendered so far.
-  absl::flat_hash_set<std::string> rendered_functions_;
-
   // Rendered function bodies, as a vector to preserve source order. This is
   // not strictly necessary, but makes the output look less surprising.
   std::vector<std::string> rendered_functions_ordered_;
 };
 
-// Constructs an include guard name for the given filename. The name is of the
-// same form as the include guards in this project and conforms to the Google
-// C++ style. For example,
-//   sandboxed_api/examples/zlib/zlib-sapi.sapi.h
-// will be mapped to
-//   SANDBOXED_API_EXAMPLES_ZLIB_ZLIB_SAPI_SAPI_H_
-std::string GetIncludeGuard(absl::string_view filename);
-
 }  // namespace sapi
 
 #endif  // SANDBOXED_API_TOOLS_CLANG_GENERATOR_EMITTER_H_
diff --git a/sandboxed_api/tools/clang_generator/emitter_base.cc b/sandboxed_api/tools/clang_generator/emitter_base.cc
new file mode 100644
index 0000000..91a3b1c
--- /dev/null
+++ b/sandboxed_api/tools/clang_generator/emitter_base.cc
@@ -0,0 +1,304 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "sandboxed_api/tools/clang_generator/emitter_base.h"
+
+#include <algorithm>
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include "absl/random/random.h"
+#include "absl/status/status.h"
+#include "absl/status/statusor.h"
+#include "absl/strings/ascii.h"
+#include "absl/strings/match.h"
+#include "absl/strings/str_cat.h"
+#include "absl/strings/str_join.h"
+#include "absl/strings/string_view.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/DeclBase.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/DeclTemplate.h"
+#include "clang/AST/QualTypeNames.h"
+#include "clang/Format/Format.h"
+#include "clang/Tooling/Core/Replacement.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/Error.h"
+#include "llvm/Support/raw_ostream.h"
+#include "sandboxed_api/tools/clang_generator/generator.h"
+
+namespace sapi {
+
+// Text template arguments:
+//   1. Include for embedded sandboxee objects
+constexpr absl::string_view kEmbedInclude = R"(#include "%1$s_embed.h"
+
+)";
+
+// Text template arguments:
+//   1. Class name
+//   2. Embedded object identifier
+constexpr absl::string_view kEmbedClassTemplate = R"(
+// Sandbox with embedded sandboxee and default policy
+class %1$s : public ::sapi::Sandbox {
+ public:
+  %1$s()
+      : ::sapi::Sandbox([]() {
+          static auto* fork_client_context =
+              new ::sapi::ForkClientContext(%2$s_embed_create());
+          return fork_client_context;
+        }()) {}
+};
+
+)";
+
+// Sandboxed API class template.
+// Text template arguments:
+//   1. Class name
+constexpr absl::string_view kClassHeaderTemplate = R"(
+// Sandboxed API
+class %1$s {
+ public:
+  explicit %1$s(::sapi::Sandbox* sandbox) : sandbox_(sandbox) {}
+
+  ABSL_DEPRECATED("Call sandbox() instead")
+  ::sapi::Sandbox* GetSandbox() const { return sandbox(); }
+  ::sapi::Sandbox* sandbox() const { return sandbox_; }
+)";
+
+// Sandboxed API class template footer.
+constexpr absl::string_view kClassFooterTemplate = R"(
+ private:
+  ::sapi::Sandbox* sandbox_;
+};
+)";
+
+namespace internal {
+
+absl::StatusOr<std::string> ReformatGoogleStyle(const std::string& filename,
+                                                const std::string& code,
+                                                int column_limit) {
+  // Configure code style based on Google style, but enforce pointer alignment
+  clang::format::FormatStyle style =
+      clang::format::getGoogleStyle(clang::format::FormatStyle::LK_Cpp);
+  style.DerivePointerAlignment = false;
+  style.PointerAlignment = clang::format::FormatStyle::PAS_Left;
+  if (column_limit >= 0) {
+    style.ColumnLimit = column_limit;
+  }
+
+  clang::tooling::Replacements replacements = clang::format::reformat(
+      style, code, llvm::ArrayRef(clang::tooling::Range(0, code.size())),
+      filename);
+
+  llvm::Expected<std::string> formatted_header =
+      clang::tooling::applyAllReplacements(code, replacements);
+  if (!formatted_header) {
+    return absl::InternalError(llvm::toString(formatted_header.takeError()));
+  }
+  return *formatted_header;
+}
+
+}  // namespace internal
+
+namespace {
+
+// Returns the namespace components of a declaration's qualified name.
+std::vector<std::string> GetNamespacePath(const clang::TypeDecl* decl) {
+  std::vector<std::string> comps;
+  for (const auto* ctx = decl->getDeclContext(); ctx; ctx = ctx->getParent()) {
+    if (const auto* nd = llvm::dyn_cast<clang::NamespaceDecl>(ctx)) {
+      comps.push_back(nd->getName().str());
+    }
+  }
+  std::reverse(comps.begin(), comps.end());
+  return comps;
+}
+
+// Returns the template arguments for a given record.
+std::string PrintRecordTemplateArguments(const clang::CXXRecordDecl* record) {
+  const auto* template_inst_decl = record->getTemplateInstantiationPattern();
+  if (!template_inst_decl) {
+    return "";
+  }
+  const auto* template_decl = template_inst_decl->getDescribedClassTemplate();
+  if (!template_decl) {
+    return "";
+  }
+  const auto* template_params = template_decl->getTemplateParameters();
+  if (!template_params) {
+    return "";
+  }
+  clang::ASTContext& context = record->getASTContext();
+  std::vector<std::string> params;
+  params.reserve(template_params->size());
+  for (const auto& template_param : *template_params) {
+    if (const auto* p =
+            llvm::dyn_cast<clang::NonTypeTemplateParmDecl>(template_param)) {
+      // TODO(cblichmann): Should be included by CollectRelatedTypes().
+      params.push_back(clang::TypeName::getFullyQualifiedName(
+          p->getType().getDesugaredType(context), context,
+          context.getPrintingPolicy()));
+    } else {  // Also covers template template parameters
+      params.push_back("typename");
+    }
+    absl::StrAppend(&params.back(), " /*",
+                    std::string(template_param->getName()), "*/");
+  }
+  return absl::StrCat("template <", absl::StrJoin(params, ", "), ">");
+}
+
+// Serializes the given Clang AST declaration back into compilable source code.
+std::string PrintDecl(const clang::Decl* decl) {
+  std::string pretty;
+  llvm::raw_string_ostream os(pretty);
+  decl->print(os);
+  return os.str();
+}
+
+// Returns the spelling for a given declaration will be emitted to the final
+// header. This may rewrite declarations (like converting typedefs to using,
+// etc.). Note that the resulting spelling will need to be wrapped inside a
+// namespace if the original declaration was inside one.
+std::string GetSpelling(const clang::Decl* decl) {
+  // TODO(cblichmann): Make types nicer
+  //   - Rewrite typedef to using
+  //   - Rewrite function pointers using std::add_pointer_t<>;
+
+  if (const auto* typedef_decl = llvm::dyn_cast<clang::TypedefNameDecl>(decl)) {
+    // Special case: anonymous enum/struct
+    if (auto* tag_decl = typedef_decl->getAnonDeclWithTypedefName()) {
+      return absl::StrCat("typedef ", PrintDecl(tag_decl), " ",
+                          ToStringView(typedef_decl->getName()));
+    }
+  }
+
+  if (const auto* record_decl = llvm::dyn_cast<clang::CXXRecordDecl>(decl)) {
+    if (record_decl->hasDefinition() &&
+        // Aggregates capture all C-like structs, but also structs with
+        // non-static members that have default initializers.
+        record_decl->isAggregate() &&
+        // Make sure to skip non-POD types with user-defined methods
+        // (including constructors).
+        (record_decl->isPOD() || record_decl->methods().empty())) {
+      return PrintDecl(decl);
+    }
+    // For unsupported types or types with no definition, only emit a forward
+    // declaration.
+    return absl::StrCat(PrintRecordTemplateArguments(record_decl),
+                        record_decl->isClass() ? "class " : "struct ",
+                        ToStringView(record_decl->getName()));
+  }
+  return PrintDecl(decl);
+}
+
+}  // namespace
+
+std::string GetIncludeGuard(absl::string_view filename) {
+  if (filename.empty()) {
+    static auto* bit_gen = new absl::BitGen();
+    return absl::StrCat(
+        // Copybara will transform the string. This is intentional.
+        "SANDBOXED_API_GENERATED_HEADER_",
+        absl::AsciiStrToUpper(absl::StrCat(
+            absl::Hex(absl::Uniform<uint64_t>(*bit_gen), absl::kZeroPad16))),
+        "_");
+  }
+
+  constexpr absl::string_view kUnderscorePrefix = "SAPI_";
+  std::string guard;
+  guard.reserve(filename.size() + kUnderscorePrefix.size() + 1);
+  for (auto c : filename) {
+    if (absl::ascii_isalpha(c)) {
+      guard += absl::ascii_toupper(c);
+      continue;
+    }
+    if (guard.empty()) {
+      guard = kUnderscorePrefix;
+    }
+    if (absl::ascii_isdigit(c)) {
+      guard += c;
+    } else if (guard.back() != '_') {
+      guard += '_';
+    }
+  }
+  if (!absl::EndsWith(guard, "_")) {
+    guard += '_';
+  }
+  return guard;
+}
+
+void EmitterBase::EmitType(clang::TypeDecl* type_decl) {
+  if (!type_decl) {
+    return;
+  }
+
+  // Skip types defined in system headers.
+  // TODO(cblichmann): Instead of this and the hard-coded entities below, we
+  //                   should map types and add the correct (system) headers to
+  //                   the generated output.
+  if (type_decl->getASTContext().getSourceManager().isInSystemHeader(
+          type_decl->getBeginLoc())) {
+    return;
+  }
+
+  const std::vector<std::string> ns_path = GetNamespacePath(type_decl);
+  std::string ns_name;
+  if (!ns_path.empty()) {
+    const auto& ns_root = ns_path.front();
+    // Filter out declarations from the C++ standard library, from SAPI itself
+    // and from other well-known namespaces.
+    if (ns_root == "std" || ns_root == "__gnu_cxx" || ns_root == "sapi") {
+      return;
+    }
+    if (ns_root == "absl") {
+      // Skip Abseil internal namespaces
+      if (ns_path.size() > 1 && absl::EndsWith(ns_path[1], "_internal")) {
+        return;
+      }
+      // Skip types from Abseil that will already be included in the generated
+      // header.
+      if (auto name = ToStringView(type_decl->getName());
+          name == "CordMemoryAccounting" || name == "Duration" ||
+          name == "LogEntry" || name == "LogSeverity" || name == "Span" ||
+          name == "StatusCode" || name == "StatusToStringMode" ||
+          name == "SynchLocksHeld" || name == "SynchWaitParams" ||
+          name == "Time" || name == "string_view" || name == "tid_t") {
+        return;
+      }
+    }
+    // Skip Protocol Buffers namespaces
+    if (ns_root == "google" && ns_path.size() > 1 && ns_path[1] == "protobuf") {
+      return;
+    }
+    ns_name = absl::StrJoin(ns_path, "::");
+  }
+
+  std::string spelling = GetSpelling(type_decl);
+  if (const auto& [it, inserted] = rendered_types_.emplace(ns_name, spelling);
+      inserted) {
+    rendered_types_ordered_.push_back(&*it);
+  }
+}
+
+void EmitterBase::AddTypeDeclarations(
+    const std::vector<clang::TypeDecl*>& type_decls) {
+  for (clang::TypeDecl* type_decl : type_decls) {
+    EmitType(type_decl);
+  }
+}
+
+}  // namespace sapi
diff --git a/sandboxed_api/tools/clang_generator/emitter_base.h b/sandboxed_api/tools/clang_generator/emitter_base.h
new file mode 100644
index 0000000..de16c85
--- /dev/null
+++ b/sandboxed_api/tools/clang_generator/emitter_base.h
@@ -0,0 +1,132 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_TOOLS_CLANG_GENERATOR_EMITTER_BASE_H_
+#define SANDBOXED_API_TOOLS_CLANG_GENERATOR_EMITTER_BASE_H_
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "absl/container/flat_hash_set.h"
+#include "absl/container/node_hash_set.h"
+#include "absl/status/status.h"
+#include "absl/status/statusor.h"
+#include "absl/strings/string_view.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/Type.h"
+
+namespace sapi {
+// TODO b/347118045 - Refactor the naming of internal namespaces across the
+// codebase.
+namespace internal {
+
+// Returns a string of the specified code reformatted to conform to the Google
+// style.
+// Ill-formed code will return an error status.
+absl::StatusOr<std::string> ReformatGoogleStyle(const std::string& filename,
+                                                const std::string& code,
+                                                int column_limit = -1);
+
+}  // namespace internal
+
+// Text template arguments:
+//   1. Namespace name
+inline constexpr absl::string_view kNamespaceBeginTemplate =
+    R"(
+namespace %1$s {
+
+)";
+
+// Text template arguments:
+//   1. Namespace name
+inline constexpr absl::string_view kNamespaceEndTemplate =
+    R"(
+}  // namespace %1$s
+)";
+
+// Text template arguments:
+//   1. Header guard
+inline constexpr absl::string_view kHeaderProlog =
+    R"(
+#ifndef %1$s
+#define %1$s
+
+)";
+
+// Text template arguments:
+//   1. Header guard
+inline constexpr absl::string_view kHeaderEpilog =
+    R"(
+#endif  // %1$s)";
+
+class RenderedType {
+ public:
+  RenderedType(std::string ns_name, std::string spelling)
+      : ns_name(std::move(ns_name)), spelling(std::move(spelling)) {}
+
+  bool operator==(const RenderedType& other) const {
+    return ns_name == other.ns_name && spelling == other.spelling;
+  }
+
+  template <typename H>
+  friend H AbslHashValue(H h, RenderedType rt) {
+    return H::combine(std::move(h), rt.ns_name, rt.spelling);
+  }
+
+  std::string ns_name;
+  std::string spelling;
+};
+
+class EmitterBase {
+ public:
+  virtual ~EmitterBase() = default;
+
+  // Adds the declarations of previously collected types to the emitter,
+  // recording the spelling of each one. Types/declarations that are not
+  // supported by the current generator settings or that are unwanted or
+  // unnecessary are skipped. Other filtered types include C++ constructs or
+  // well-known standard library elements. The latter can be replaced by
+  // including the correct headers in the emitted header.
+  void AddTypeDeclarations(const std::vector<clang::TypeDecl*>& type_decls);
+
+  // Adds the declarations of previously collected functions to the emitter.
+  virtual absl::Status AddFunction(clang::FunctionDecl* decl) = 0;
+
+  // Stores namespaces and a list of spellings for types. Keeps track of types
+  // that have been rendered so far. Using a node_hash_set for pointer
+  // stability.
+  absl::node_hash_set<RenderedType> rendered_types_;
+
+  // A vector to preserve the order of type declarations needs to be preserved.
+  std::vector<const RenderedType*> rendered_types_ordered_;
+
+  // Fully qualified names of functions for the sandboxed API. Keeps track of
+  // functions that have been rendered so far.
+  absl::flat_hash_set<std::string> rendered_functions_;
+
+ private:
+  void EmitType(clang::TypeDecl* type_decl);
+};
+
+// Constructs an include guard for the given filename. The generated string
+// conforms to the Google C++ style. For example,
+//   sandboxed_api/examples/zlib/zlib-sapi.sapi.h
+// will be mapped to
+//   SANDBOXED_API_EXAMPLES_ZLIB_ZLIB_SAPI_SAPI_H_
+std::string GetIncludeGuard(absl::string_view filename);
+
+}  // namespace sapi
+
+#endif  // SANDBOXED_API_TOOLS_CLANG_GENERATOR_EMITTER_BASE_H_
diff --git a/sandboxed_api/tools/clang_generator/emitter_test.cc b/sandboxed_api/tools/clang_generator/emitter_test.cc
index b69ad37..781ddf7 100644
--- a/sandboxed_api/tools/clang_generator/emitter_test.cc
+++ b/sandboxed_api/tools/clang_generator/emitter_test.cc
@@ -24,6 +24,7 @@
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
+#include "sandboxed_api/tools/clang_generator/emitter_base.h"
 #include "sandboxed_api/tools/clang_generator/frontend_action_test_util.h"
 #include "sandboxed_api/tools/clang_generator/generator.h"
 #include "sandboxed_api/util/status_matchers.h"
@@ -146,6 +147,36 @@ TEST_F(EmitterTest, TypedefNames) {
                   "struct tagC { int member; }", "typedef struct tagC C"));
 }
 
+TEST_F(EmitterTest, TypedefAnonymousWithFieldStructure) {
+  EmitterForTesting emitter;
+  ASSERT_THAT(
+      RunFrontendAction(
+          R"(struct A { int number; };
+             typedef struct { A member; } B;
+             extern "C" void Foo(B*);)",
+          std::make_unique<GeneratorAction>(emitter, GeneratorOptions())),
+      IsOk());
+
+  EXPECT_THAT(UglifyAll(emitter.SpellingsForNS("")),
+              ElementsAre("struct A { int number; }",
+                          "typedef struct { A member; } B"));
+}
+
+TEST_F(EmitterTest, NamedEnumWithoutTypedef) {
+  EmitterForTesting emitter;
+  ASSERT_THAT(
+      RunFrontendAction(
+          R"(enum Color { kRed, kGreen, kBlue };
+             typedef struct { enum Color member; } B;
+             extern "C" void Foo(B*);)",
+          std::make_unique<GeneratorAction>(emitter, GeneratorOptions())),
+      IsOk());
+
+  EXPECT_THAT(UglifyAll(emitter.SpellingsForNS("")),
+              ElementsAre("enum Color { kRed, kGreen, kBlue }",
+                          "typedef struct { enum Color member; } B"));
+}
+
 TEST_F(EmitterTest, NestedStruct) {
   EmitterForTesting emitter;
   ASSERT_THAT(
diff --git a/sandboxed_api/tools/clang_generator/frontend_action_test_util.cc b/sandboxed_api/tools/clang_generator/frontend_action_test_util.cc
index b29b71c..5573b26 100644
--- a/sandboxed_api/tools/clang_generator/frontend_action_test_util.cc
+++ b/sandboxed_api/tools/clang_generator/frontend_action_test_util.cc
@@ -31,7 +31,9 @@
 #include "clang/Basic/FileSystemOptions.h"
 #include "clang/Frontend/FrontendAction.h"
 #include "clang/Tooling/Tooling.h"
+#include "llvm/ADT/IntrusiveRefCntPtr.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/Config/llvm-config.h"
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/VirtualFileSystem.h"
 
@@ -39,8 +41,8 @@ namespace sapi {
 namespace internal {
 
 absl::Status RunClangTool(
-    const std::vector<std::string> command_line,
-    const absl::flat_hash_map<std::string, std::string> file_contents,
+    const std::vector<std::string>& command_line,
+    const absl::flat_hash_map<std::string, std::string>& file_contents,
     std::unique_ptr<clang::FrontendAction> action) {
   // Setup an in-memory virtual filesystem
   llvm::IntrusiveRefCntPtr<llvm::vfs::InMemoryFileSystem> fs(
diff --git a/sandboxed_api/tools/clang_generator/frontend_action_test_util.h b/sandboxed_api/tools/clang_generator/frontend_action_test_util.h
index 502d66a..2dcbb35 100644
--- a/sandboxed_api/tools/clang_generator/frontend_action_test_util.h
+++ b/sandboxed_api/tools/clang_generator/frontend_action_test_util.h
@@ -20,7 +20,6 @@
 #include <utility>
 #include <vector>
 
-#include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/container/flat_hash_map.h"
 #include "absl/memory/memory.h"
@@ -28,14 +27,13 @@
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "clang/Frontend/FrontendAction.h"
-#include "sandboxed_api/util/status_matchers.h"
 
 namespace sapi {
 namespace internal {
 
 absl::Status RunClangTool(
-    const std::vector<std::string> command_line,
-    const absl::flat_hash_map<std::string, std::string> file_contents,
+    const std::vector<std::string>& command_line,
+    const absl::flat_hash_map<std::string, std::string>& file_contents,
     std::unique_ptr<clang::FrontendAction> action);
 
 }  // namespace internal
diff --git a/sandboxed_api/tools/clang_generator/generator.cc b/sandboxed_api/tools/clang_generator/generator.cc
index ebfc162..a4e13f3 100644
--- a/sandboxed_api/tools/clang_generator/generator.cc
+++ b/sandboxed_api/tools/clang_generator/generator.cc
@@ -14,8 +14,8 @@
 
 #include "sandboxed_api/tools/clang_generator/generator.h"
 
+#include <cstddef>
 #include <memory>
-#include <optional>
 #include <string>
 #include <utility>
 #include <vector>
@@ -29,11 +29,15 @@
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/Type.h"
+#include "clang/Basic/Diagnostic.h"
 #include "clang/Basic/SourceLocation.h"
 #include "clang/Basic/SourceManager.h"
+#include "clang/Frontend/CompilerInvocation.h"
 #include "clang/Lex/PreprocessorOptions.h"
+#include "clang/Serialization/PCHContainerOperations.h"
+#include "clang/Tooling/Tooling.h"
 #include "sandboxed_api/tools/clang_generator/diagnostics.h"
-#include "sandboxed_api/tools/clang_generator/emitter.h"
+#include "sandboxed_api/tools/clang_generator/emitter_base.h"
 
 namespace sapi {
 namespace {
@@ -41,8 +45,8 @@ namespace {
 // Replaces the file extension of a path name.
 std::string ReplaceFileExtension(absl::string_view path,
                                  absl::string_view new_extension) {
-  auto last_slash = path.rfind('/');
-  auto pos = path.rfind('.', last_slash);
+  size_t last_slash = path.rfind('/');
+  size_t pos = path.rfind('.', last_slash);
   if (pos != absl::string_view::npos && last_slash != absl::string_view::npos) {
     pos += last_slash;
   }
@@ -114,11 +118,10 @@ void GeneratorASTConsumer::HandleTranslationUnit(clang::ASTContext& context) {
   if (!visitor_.TraverseDecl(context.getTranslationUnitDecl())) {
     ReportFatalError(context.getDiagnostics(),
                      context.getTranslationUnitDecl()->getBeginLoc(),
-                     "AST traversal exited early");
+                     "AST traversal exited early.");
     return;
   }
 
-  // TODO(cblichmann): Move below to emit all functions after traversing TUs.
   emitter_.AddTypeDeclarations(visitor_.collector().GetTypeDeclarations());
   for (clang::FunctionDecl* func : visitor_.functions()) {
     absl::Status status = emitter_.AddFunction(func);
@@ -146,9 +149,37 @@ bool GeneratorFactory::runInvocation(
   for (const auto& def : {
            // Enable code to detect whether it is being SAPI-ized
            "__SAPI__",
-           // TODO(b/222241644): Figure out how to deal with intrinsics properly
+           // TODO: b/222241644 - Figure out how to deal with intrinsics
+           // properly.
            // Note: The definitions below just need to parse, they don't need to
            //       compile into useful code.
+           // 3DNow!
+           "__builtin_ia32_femms=[](){}",
+           "__builtin_ia32_pavgusb=",
+           "__builtin_ia32_pf2id=",
+           "__builtin_ia32_pfacc=",
+           "__builtin_ia32_pfadd=",
+           "__builtin_ia32_pfcmpeq=",
+           "__builtin_ia32_pfcmpge=",
+           "__builtin_ia32_pfcmpgt=",
+           "__builtin_ia32_pfmax=",
+           "__builtin_ia32_pfmin=",
+           "__builtin_ia32_pfmul=",
+           "__builtin_ia32_pfrcp=",
+           "__builtin_ia32_pfrcpit1=",
+           "__builtin_ia32_pfrcpit2=",
+           "__builtin_ia32_pfrsqrt=",
+           "__builtin_ia32_pfrsqit1=",
+           "__builtin_ia32_pfsub=",
+           "__builtin_ia32_pfsubr=",
+           "__builtin_ia32_pi2fd=",
+           "__builtin_ia32_pmulhrw=",
+           "__builtin_ia32_pf2iw=",
+           "__builtin_ia32_pfnacc=",
+           "__builtin_ia32_pfpnacc=",
+           "__builtin_ia32_pi2fw=",
+           "__builtin_ia32_pswapdsf=",
+           "__builtin_ia32_pswapdsi=",
            // Intel
            "__builtin_ia32_cvtsbf162ss_32=[](auto)->long long{return 0;}",
            "__builtin_ia32_paddsb128=",
@@ -179,6 +210,115 @@ bool GeneratorFactory::runInvocation(
            "__builtin_ia32_reduce_add_q512=[](auto)->long long{return 0;}",
            "__builtin_ia32_reduce_mul_d512=[](auto)->long long{return 0;}",
            "__builtin_ia32_reduce_mul_q512=[](auto)->long long{return 0;}",
+
+           // SSE2
+           "__builtin_ia32_cvtpd2pi=[](auto)->long long{return 0;}",
+           "__builtin_ia32_cvtpi2pd=[](auto) -> __m128{return {0, 0, 0, 0};}",
+           "__builtin_ia32_cvtpi2ps=[](auto, auto)->__m128{return {0, 0, 0, "
+           "0};}",
+           "__builtin_ia32_cvtps2pi=[](auto)->long long{return 0;}",
+           "__builtin_ia32_cvttpd2pi=[](auto)->long long{return 0;}",
+           "__builtin_ia32_cvttps2pi=[](auto)->long long{return 0;}",
+           "__builtin_ia32_maskmovq=",
+           "__builtin_ia32_movntq=",
+           "__builtin_ia32_pabsb=",
+           "__builtin_ia32_pabsd=",
+           "__builtin_ia32_pabsw=",
+           "__builtin_ia32_packssdw=",
+           "__builtin_ia32_packsswb=",
+           "__builtin_ia32_packuswb=",
+           "__builtin_ia32_paddb=",
+           "__builtin_ia32_paddd=",
+           "__builtin_ia32_paddq=",
+           "__builtin_ia32_paddsb=",
+           "__builtin_ia32_paddsw=",
+           "__builtin_ia32_paddusb=",
+           "__builtin_ia32_paddusw=",
+           "__builtin_ia32_paddw=",
+           "__builtin_ia32_pand=",
+           "__builtin_ia32_pandn=",
+           "__builtin_ia32_pavgb=",
+           "__builtin_ia32_pavgw=",
+           "__builtin_ia32_pcmpeqb=",
+           "__builtin_ia32_pcmpeqd=",
+           "__builtin_ia32_pcmpeqw=",
+           "__builtin_ia32_pcmpgtb=",
+           "__builtin_ia32_pcmpgtd=",
+           "__builtin_ia32_pcmpgtw=",
+           "__builtin_ia32_phaddd=",
+           "__builtin_ia32_phaddsw=",
+           "__builtin_ia32_phaddw=",
+           "__builtin_ia32_phsubd=",
+           "__builtin_ia32_phsubsw=",
+           "__builtin_ia32_phsubw=",
+           "__builtin_ia32_pmaddubsw=",
+           "__builtin_ia32_pmaddwd=",
+           "__builtin_ia32_pmaxsw=",
+           "__builtin_ia32_pmaxub=",
+           "__builtin_ia32_pminsw=",
+           "__builtin_ia32_pminub=",
+           "__builtin_ia32_pmovmskb=[](auto)->long long{return 0;}",
+           "__builtin_ia32_pmulhrsw=",
+           "__builtin_ia32_pmulhuw=",
+           "__builtin_ia32_pmulhw=",
+           "__builtin_ia32_pmullw=",
+           "__builtin_ia32_pmuludq=",
+           "__builtin_ia32_por=",
+           "__builtin_ia32_psadbw=",
+           "__builtin_ia32_pshufb=",
+           "__builtin_ia32_psignb=",
+           "__builtin_ia32_psignd=",
+           "__builtin_ia32_psignw=",
+           "__builtin_ia32_pslld=",
+           "__builtin_ia32_pslldi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psllq=",
+           "__builtin_ia32_psllqi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psllw=",
+           "__builtin_ia32_psllwi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psrad=",
+           "__builtin_ia32_psradi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psraw=",
+           "__builtin_ia32_psrawi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psrld=",
+           "__builtin_ia32_psrldi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psrlq=",
+           "__builtin_ia32_psrlqi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psrlw=",
+           "__builtin_ia32_psrlwi=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_psubb=",
+           "__builtin_ia32_psubd=",
+           "__builtin_ia32_psubq=",
+           "__builtin_ia32_psubsb=",
+           "__builtin_ia32_psubsw=",
+           "__builtin_ia32_psubusb=",
+           "__builtin_ia32_psubusw=",
+           "__builtin_ia32_psubw=",
+           "__builtin_ia32_punpckhbw=",
+           "__builtin_ia32_punpckhdq=",
+           "__builtin_ia32_punpckhwd=",
+           "__builtin_ia32_punpcklbw=",
+           "__builtin_ia32_punpckldq=",
+           "__builtin_ia32_punpcklwd=",
+           "__builtin_ia32_pxor=",
+           "__builtin_ia32_vec_ext_v2si=",
+           "__builtin_ia32_vec_init_v2si=[](auto, auto)->long long{return 0;}",
+           "__builtin_ia32_vec_init_v4hi=[](auto, auto, auto, auto)->long "
+           "long{return 0;}",
+           "__builtin_ia32_vec_init_v8qi=[](auto, auto, auto, auto, auto, "
+           "auto, auto, auto)->long long{return 0;}",
+           // AVX
+           "__builtin_ia32_vpopcntb_128=",
+           "__builtin_ia32_vpopcntb_256=",
+           "__builtin_ia32_vpopcntb_512=",
+           "__builtin_ia32_vpopcntd_128=",
+           "__builtin_ia32_vpopcntd_256=",
+           "__builtin_ia32_vpopcntd_512=",
+           "__builtin_ia32_vpopcntq_128=",
+           "__builtin_ia32_vpopcntq_256=",
+           "__builtin_ia32_vpopcntq_512=",
+           "__builtin_ia32_vpopcntw_128=",
+           "__builtin_ia32_vpopcntw_256=",
+           "__builtin_ia32_vpopcntw_512=",
        }) {
     options.addMacroDef(def);
     // To avoid code to include header with compiler intrinsics, undefine a few
diff --git a/sandboxed_api/tools/clang_generator/generator.h b/sandboxed_api/tools/clang_generator/generator.h
index ce6b5fb..3431d86 100644
--- a/sandboxed_api/tools/clang_generator/generator.h
+++ b/sandboxed_api/tools/clang_generator/generator.h
@@ -29,8 +29,12 @@
 #include "clang/Frontend/CompilerInvocation.h"
 #include "clang/Frontend/FrontendAction.h"
 #include "clang/Lex/Preprocessor.h"
+#include "clang/Serialization/PCHContainerOperations.h"
 #include "clang/Tooling/Tooling.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Config/llvm-config.h"
 #include "sandboxed_api/tools/clang_generator/emitter.h"
+#include "sandboxed_api/tools/clang_generator/emitter_base.h"
 #include "sandboxed_api/tools/clang_generator/types.h"
 
 namespace sapi {
@@ -95,7 +99,7 @@ class GeneratorASTVisitor
 
 class GeneratorASTConsumer : public clang::ASTConsumer {
  public:
-  GeneratorASTConsumer(std::string in_file, Emitter& emitter,
+  GeneratorASTConsumer(std::string in_file, EmitterBase& emitter,
                        const GeneratorOptions& options)
       : in_file_(std::move(in_file)), visitor_(options), emitter_(emitter) {}
 
@@ -104,12 +108,12 @@ class GeneratorASTConsumer : public clang::ASTConsumer {
 
   std::string in_file_;
   GeneratorASTVisitor visitor_;
-  Emitter& emitter_;
+  EmitterBase& emitter_;
 };
 
 class GeneratorAction : public clang::ASTFrontendAction {
  public:
-  GeneratorAction(Emitter& emitter, const GeneratorOptions& options)
+  GeneratorAction(EmitterBase& emitter, const GeneratorOptions& options)
       : emitter_(emitter), options_(options) {}
 
  private:
@@ -126,14 +130,14 @@ class GeneratorAction : public clang::ASTFrontendAction {
 
   bool hasCodeCompletionSupport() const override { return false; }
 
-  Emitter& emitter_;
+  EmitterBase& emitter_;
   const GeneratorOptions& options_;
 };
 
 class GeneratorFactory : public clang::tooling::FrontendActionFactory {
  public:
   // Does not take ownership
-  GeneratorFactory(Emitter& emitter, const GeneratorOptions& options)
+  GeneratorFactory(EmitterBase& emitter, const GeneratorOptions& options)
       : emitter_(emitter), options_(options) {}
 
  private:
@@ -153,10 +157,11 @@ class GeneratorFactory : public clang::tooling::FrontendActionFactory {
       std::shared_ptr<clang::PCHContainerOperations> pch_container_ops,
       clang::DiagnosticConsumer* diag_consumer) override;
 
-  Emitter& emitter_;
+  EmitterBase& emitter_;
   const GeneratorOptions& options_;
 };
 
+// Returns the output filename for the given source file ending in .sapi.h.
 std::string GetOutputFilename(absl::string_view source_file);
 
 inline absl::string_view ToStringView(llvm::StringRef ref) {
diff --git a/sandboxed_api/tools/clang_generator/generator_tool.cc b/sandboxed_api/tools/clang_generator/generator_tool.cc
index 9fc0d41..31ad175 100644
--- a/sandboxed_api/tools/clang_generator/generator_tool.cc
+++ b/sandboxed_api/tools/clang_generator/generator_tool.cc
@@ -12,20 +12,23 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include <cstdio>
 #include <cstdlib>
 #include <memory>
 #include <string>
 #include <vector>
 
+#include "absl/base/attributes.h"
+#include "absl/base/no_destructor.h"
 #include "absl/status/status.h"
-#include "absl/status/statusor.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_format.h"
 #include "clang/Tooling/CommonOptionsParser.h"
 #include "clang/Tooling/CompilationDatabase.h"
+#include "clang/Tooling/Tooling.h"
 #include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Error.h"
 #include "sandboxed_api/tools/clang_generator/compilation_database.h"
+#include "sandboxed_api/tools/clang_generator/emitter.h"
 #include "sandboxed_api/tools/clang_generator/generator.h"
 #include "sandboxed_api/util/file_helpers.h"
 #include "sandboxed_api/util/fileops.h"
@@ -35,53 +38,63 @@
 namespace sapi {
 namespace {
 
-static auto* g_tool_category =
-    new llvm::cl::OptionCategory("Sandboxed API Options");
+absl::NoDestructor<llvm::cl::OptionCategory> g_tool_category(
+    "Sandboxed API Options");
 
-static auto* g_common_help =
-    new llvm::cl::extrahelp(clang::tooling::CommonOptionsParser::HelpMessage);
-static auto* g_extra_help = new llvm::cl::extrahelp(
+absl::NoDestructor<llvm::cl::extrahelp> g_common_help(
+    clang::tooling::CommonOptionsParser::HelpMessage);
+absl::NoDestructor<llvm::cl::extrahelp> g_extra_help(
     "Full documentation at: "
-    "<https://developers.google.com/code-sandboxing/sandboxed-api/>\n"
+    "<https://developers.google.com/code-sandboxing/sandboxed-api>\n"
     "Report bugs to <https://github.com/google/sandboxed-api/issues>\n");
 
 // Command line options
-static auto* g_sapi_embed_dir = new llvm::cl::opt<std::string>(
+absl::NoDestructor<llvm::cl::opt<std::string>> g_sapi_embed_dir(
     "sapi_embed_dir", llvm::cl::desc("Directory with embedded includes"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_embed_name = new llvm::cl::opt<std::string>(
+
+absl::NoDestructor<llvm::cl::opt<std::string>> g_sapi_embed_name(
     "sapi_embed_name", llvm::cl::desc("Identifier of the embed object"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_functions = new llvm::cl::list<std::string>(
+
+absl::NoDestructor<llvm::cl::list<std::string>> g_sapi_functions(
     "sapi_functions", llvm::cl::CommaSeparated,
     llvm::cl::desc("List of functions to generate a Sandboxed API for. If "
                    "empty, generates a SAPI for all functions found."),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_in = new llvm::cl::list<std::string>(
+
+ABSL_DEPRECATED("Pass the input files directly to the tool.")
+absl::NoDestructor<llvm::cl::list<std::string>> g_sapi_in(
     "sapi_in", llvm::cl::CommaSeparated,
-    llvm::cl::desc("List of input files to analyze (deprecated)"),
+    llvm::cl::desc("List of input files to analyze (DEPRECATED)"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_isystem = new llvm::cl::opt<std::string>(
+
+ABSL_DEPRECATED("Ignored for compatibility.")
+absl::NoDestructor<llvm::cl::opt<std::string>> g_sapi_isystem(
     "sapi_isystem",
-    llvm::cl::desc("Parameter file with extra system include paths (ignored "
-                   "for compatibility)"),
+    llvm::cl::desc(
+        "Parameter file with extra system include paths (DEPRECATED)"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_limit_scan_depth = new llvm::cl::opt<bool>(
+
+absl::NoDestructor<llvm::cl::opt<bool>> g_sapi_limit_scan_depth(
     "sapi_limit_scan_depth",
-    llvm::cl::desc(
-        "Whether to only scan for functions in the top-most translation unit"),
+    llvm::cl::desc("Whether to only scan for functions "
+                   "in the top-most translation unit"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_name = new llvm::cl::opt<std::string>(
+
+absl::NoDestructor<llvm::cl::opt<std::string>> g_sapi_name(
     "sapi_name", llvm::cl::desc("Name of the Sandboxed API library"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_ns = new llvm::cl::opt<std::string>(
+
+absl::NoDestructor<llvm::cl::opt<std::string>> g_sapi_ns(
     "sapi_ns", llvm::cl::desc("C++ namespace to wrap Sandboxed API class in"),
     llvm::cl::cat(*g_tool_category));
-static auto* g_sapi_out = new llvm::cl::opt<std::string>(
+
+absl::NoDestructor<llvm::cl::opt<std::string>> g_sapi_out(
     "sapi_out",
-    llvm::cl::desc(
-        "Output path of the generated header. If empty, simply appends .sapi.h "
-        "to the basename of the first source file specified."),
+    llvm::cl::desc("Output path of the generated header. If empty, simply "
+                   "appends .sapi.h "
+                   "to the basename of the first source file specified."),
     llvm::cl::cat(*g_tool_category));
 
 }  // namespace
@@ -89,14 +102,13 @@ static auto* g_sapi_out = new llvm::cl::opt<std::string>(
 GeneratorOptions GeneratorOptionsFromFlags(
     const std::vector<std::string>& sources) {
   GeneratorOptions options;
-  options.work_dir = sapi::file_util::fileops::GetCWD();
+  options.work_dir = file_util::fileops::GetCWD();
   options.set_function_names(*g_sapi_functions);
   for (const auto& input : sources) {
     // Keep absolute paths as is, turn
-    options.in_files.insert(
-        absl::StartsWith(input, "/")
-            ? input
-            : sapi::file::JoinPath(options.work_dir, input));
+    options.in_files.insert(absl::StartsWith(input, "/")
+                                ? input
+                                : file::JoinPath(options.work_dir, input));
   }
   options.set_limit_scan_depth(*g_sapi_limit_scan_depth);
   options.name = *g_sapi_name;
@@ -110,7 +122,7 @@ GeneratorOptions GeneratorOptionsFromFlags(
 
 absl::Status GeneratorMain(int argc, char* argv[]) {
   auto expected_opt_parser = OptionsParser::create(
-      argc, const_cast<const char**>(argv), *sapi::g_tool_category,
+      argc, const_cast<const char**>(argv), *g_tool_category,
       llvm::cl::ZeroOrMore,
       "Generates a Sandboxed API header for C/C++ translation units.");
   if (!expected_opt_parser) {
@@ -119,37 +131,37 @@ absl::Status GeneratorMain(int argc, char* argv[]) {
   OptionsParser& opt_parser = expected_opt_parser.get();
 
   std::vector<std::string> sources = opt_parser.getSourcePathList();
-  for (const auto& sapi_in : *sapi::g_sapi_in) {
+  for (const auto& sapi_in : *g_sapi_in) {  // NOLINT
     sources.push_back(sapi_in);
   }
   if (sources.empty()) {
-    return absl::InvalidArgumentError("error: no input files");
+    return absl::InvalidArgumentError("Error: No input files.");
   }
 
-  auto options = sapi::GeneratorOptionsFromFlags(sources);
-  sapi::Emitter emitter;
+  auto options = GeneratorOptionsFromFlags(sources);
 
   std::unique_ptr<clang::tooling::CompilationDatabase> db =
       FromCxxAjustedCompileCommands(
           NonOwningCompileCommands(opt_parser.getCompilations()));
   clang::tooling::ClangTool tool(*db, sources);
 
-  if (!g_sapi_isystem->empty()) {
+  if (!g_sapi_isystem->empty()) {  // NOLINT(deprecated)
     absl::FPrintF(
         stderr,
-        "note: ignoring deprecated command-line option: sapi_isystem\n");
+        "Note: Ignoring deprecated command-line option: sapi_isystem\n");
   }
 
-  if (int result = tool.run(
-          std::make_unique<sapi::GeneratorFactory>(emitter, options).get());
+  // Process SAPI header generation.
+  Emitter emitter;
+  if (int result =
+          tool.run(std::make_unique<GeneratorFactory>(emitter, options).get());
       result != 0) {
-    return absl::UnknownError("header generation failed");
+    return absl::UnknownError("Error: Header generation failed.");
   }
 
   SAPI_ASSIGN_OR_RETURN(std::string header, emitter.EmitHeader(options));
-
-  SAPI_RETURN_IF_ERROR(sapi::file::SetContents(options.out_file, header,
-                                               sapi::file::Defaults()));
+  SAPI_RETURN_IF_ERROR(
+      file::SetContents(options.out_file, header, file::Defaults()));
   return absl::OkStatus();
 }
 
diff --git a/sandboxed_api/tools/clang_generator/types.cc b/sandboxed_api/tools/clang_generator/types.cc
index b4c90c9..e5132b9 100644
--- a/sandboxed_api/tools/clang_generator/types.cc
+++ b/sandboxed_api/tools/clang_generator/types.cc
@@ -14,6 +14,7 @@
 
 #include "sandboxed_api/tools/clang_generator/types.h"
 
+#include <optional>
 #include <string>
 #include <vector>
 
@@ -23,6 +24,8 @@
 #include "clang/AST/Decl.h"
 #include "clang/AST/QualTypeNames.h"
 #include "clang/AST/Type.h"
+#include "llvm/Config/llvm-config.h"
+#include "llvm/Support/Casting.h"
 
 namespace sapi {
 namespace {
@@ -48,6 +51,19 @@ void TypeCollector::CollectRelatedTypes(clang::QualType qual) {
     return;
   }
 
+  if (const auto* record_type = qual->getAs<clang::RecordType>()) {
+    const clang::RecordDecl* decl = record_type->getDecl();
+    for (const clang::FieldDecl* field : decl->fields()) {
+      CollectRelatedTypes(field->getType());
+    }
+    // Do not collect structs/unions if they are declared within another
+    // record. The enclosing type is enough to reconstruct the AST when
+    // writing the header.
+    const clang::RecordDecl* outer = decl->getOuterLexicalRecordContext();
+    decl = outer ? outer : decl;
+    collected_.insert(clang::QualType(decl->getTypeForDecl(), 0));
+  }
+
   if (const auto* typedef_type = qual->getAs<clang::TypedefType>()) {
     clang::TypedefNameDecl* typedef_decl = typedef_type->getDecl();
     if (!typedef_decl->getAnonDeclWithTypedefName()) {
@@ -96,20 +112,6 @@ void TypeCollector::CollectRelatedTypes(clang::QualType qual) {
     collected_.insert(qual);
     return;
   }
-
-  if (const auto* record_type = qual->getAs<clang::RecordType>()) {
-    const clang::RecordDecl* decl = record_type->getDecl();
-    for (const clang::FieldDecl* field : decl->fields()) {
-      CollectRelatedTypes(field->getType());
-    }
-    // Do not collect structs/unions if they are declared within another
-    // record. The enclosing type is enough to reconstruct the AST when
-    // writing the header.
-    const clang::RecordDecl* outer = decl->getOuterLexicalRecordContext();
-    decl = outer ? outer : decl;
-    collected_.insert(clang::QualType(decl->getTypeForDecl(), 0));
-    return;
-  }
 }
 
 namespace {
@@ -124,6 +126,15 @@ std::string GetQualTypeName(const clang::ASTContext& context,
       unqual->isMemberFunctionPointerType()) {
     unqual = unqual->getPointeeType();
   }
+
+  if (unqual->isEnumeralType()) {
+    auto decl = unqual->getAsTagDecl();
+    if (decl) {
+      clang::PrintingPolicy policy = context.getPrintingPolicy();
+      policy.SuppressTagKeyword = false;  // keep enum keyword.
+      return clang::TypeName::getFullyQualifiedName(unqual, context, policy);
+    }
+  }
   return clang::TypeName::getFullyQualifiedName(unqual, context,
                                                 context.getPrintingPolicy());
 }
diff --git a/sandboxed_api/tools/clang_generator/types.h b/sandboxed_api/tools/clang_generator/types.h
index cbc9607..403fb29 100644
--- a/sandboxed_api/tools/clang_generator/types.h
+++ b/sandboxed_api/tools/clang_generator/types.h
@@ -18,7 +18,6 @@
 #include <string>
 #include <vector>
 
-#include "absl/container/flat_hash_set.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/Type.h"
diff --git a/sandboxed_api/tools/filewrapper/BUILD.bazel b/sandboxed_api/tools/filewrapper/BUILD
similarity index 69%
rename from sandboxed_api/tools/filewrapper/BUILD.bazel
rename to sandboxed_api/tools/filewrapper/BUILD
index 42356ca..2ab971d 100644
--- a/sandboxed_api/tools/filewrapper/BUILD.bazel
+++ b/sandboxed_api/tools/filewrapper/BUILD
@@ -12,8 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:embed_data.bzl", "sapi_cc_embed_data")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:embed_data.bzl", "sapi_cc_embed_data")
 
 licenses(["notice"])
 
@@ -25,11 +25,11 @@ cc_binary(
     copts = sapi_platform_copts(),
     visibility = ["//visibility:public"],
     deps = [
-        "//sandboxed_api/util:fileops",
-        "//sandboxed_api/util:raw_logging",
-        "//sandboxed_api/util:strerror",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
+        "@com_google_sandboxed_api//sandboxed_api/util:fileops",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
+        "@com_google_sandboxed_api//sandboxed_api/util:strerror",
     ],
 )
 
@@ -45,9 +45,9 @@ cc_test(
     data = ["testdata/filewrapper_embedded.bin"],
     deps = [
         ":filewrapper_embedded",
-        "//sandboxed_api:testing",
-        "//sandboxed_api/util:file_helpers",
-        "//sandboxed_api/util:status_matchers",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+        "@com_google_sandboxed_api//sandboxed_api/util:file_helpers",
+        "@com_google_sandboxed_api//sandboxed_api/util:status_matchers",
     ],
 )
diff --git a/sandboxed_api/tools/generator2/BUILD.bazel b/sandboxed_api/tools/python_generator/BUILD
similarity index 86%
rename from sandboxed_api/tools/generator2/BUILD.bazel
rename to sandboxed_api/tools/python_generator/BUILD
index 31f0055..7601eb3 100644
--- a/sandboxed_api/tools/generator2/BUILD.bazel
+++ b/sandboxed_api/tools/python_generator/BUILD
@@ -12,8 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:sapi.bzl", "sapi_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:sapi.bzl", "sapi_library")
 
 licenses(["notice"])
 
@@ -82,11 +82,11 @@ cc_binary(
     copts = sapi_platform_copts(),
     deps = [
         ":tests_sapi_generator",
-        "//sandboxed_api:sapi",
-        "//sandboxed_api:vars",
-        "//sandboxed_api/util:status",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
+        "@com_google_sandboxed_api//sandboxed_api:sapi",
+        "@com_google_sandboxed_api//sandboxed_api:vars",
+        "@com_google_sandboxed_api//sandboxed_api/util:status",
     ],
 )
 
diff --git a/sandboxed_api/tools/generator2/build_test.sh b/sandboxed_api/tools/python_generator/build_test.sh
similarity index 100%
rename from sandboxed_api/tools/generator2/build_test.sh
rename to sandboxed_api/tools/python_generator/build_test.sh
diff --git a/sandboxed_api/tools/generator2/code.py b/sandboxed_api/tools/python_generator/code.py
similarity index 91%
rename from sandboxed_api/tools/generator2/code.py
rename to sandboxed_api/tools/python_generator/code.py
index 969ab91..4c62168 100644
--- a/sandboxed_api/tools/generator2/code.py
+++ b/sandboxed_api/tools/python_generator/code.py
@@ -16,13 +16,37 @@
 from __future__ import absolute_import
 from __future__ import division
 from __future__ import print_function
-from ctypes import util
+from ctypes import util  # pylint: disable=unused-import
+import glob  # pylint: disable=unused-import
 import itertools
 import os
+import sys  # pylint: disable=unused-import
 # pylint: disable=unused-import
-from typing import (Text, List, Optional, Set, Dict, Callable, IO,
-                    Generator as Gen, Tuple, Union, Sequence)  # pyformat: disable
+from typing import (
+    Text,
+    List,
+    Optional,
+    Set,
+    Dict,
+    Callable,
+    IO,
+    Generator as Gen,
+    Tuple,
+    Union,
+    Sequence,
+)
 # pylint: enable=unused-import
+
+# Use Python bindings to libclang that are in installed on the system.
+for p in glob.glob(
+    # Default system path on Debian
+    '/usr/lib/python*/dist-packages'
+) + glob.glob(
+    # Fedora and others
+    '/usr/lib/python*/site-packages'
+):
+  sys.path.append(p)
+
 from clang import cindex
 
 
@@ -30,37 +54,8 @@ _PARSE_OPTIONS = (
     cindex.TranslationUnit.PARSE_SKIP_FUNCTION_BODIES
     | cindex.TranslationUnit.PARSE_INCOMPLETE |
     # for include directives
-    cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD)
-
-
-def _init_libclang():
-  """Finds and initializes the libclang library."""
-  if cindex.Config.loaded:
-    return
-  # Try to find libclang in the standard location and a few versioned paths
-  # that are used on Debian (and others). If LD_LIBRARY_PATH is set, it is
-  # used as well.
-  for version in [
-      '',
-      '16',
-      '15',
-      '14',
-      '13',
-      '12',
-      '11',
-      '10',
-      '9',
-      '8',
-      '7',
-      '6.0',
-      '5.0',
-      '4.0',
-  ]:
-    libname = 'clang' + ('-' + version if version else '')
-    libclang = util.find_library(libname)
-    if libclang:
-      cindex.Config.set_library_file(libclang)
-      break
+    cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD
+)
 
 
 def get_header_guard(path):
@@ -111,7 +106,6 @@ TYPE_MAPPING = {
     cindex.TypeKind.DOUBLE: '::sapi::v::Reg<double>',
     cindex.TypeKind.LONGDOUBLE: '::sapi::v::Reg<long double>',
     cindex.TypeKind.SCHAR: '::sapi::v::SChar',
-    cindex.TypeKind.SHORT: '::sapi::v::Short',
     cindex.TypeKind.BOOL: '::sapi::v::Bool',
 }
 
@@ -587,8 +581,17 @@ class Function(object):
 class _TranslationUnit(object):
   """Class wrapping clang's _TranslationUnit. Provides extra utilities."""
 
-  def __init__(self, path, tu, limit_scan_depth=False):
-    # type: (Text, cindex.TranslationUnit, bool) -> None
+  def __init__(self, path, tu, limit_scan_depth=False, func_names=None):
+    # type: (Text, cindex.TranslationUnit, bool, Optional[List[Text]]) -> None
+    """Initializes the translation unit.
+
+    Args:
+      path: path to source of the tranlation unit
+      tu: cindex tranlation unit
+      limit_scan_depth: whether scan should be limited to single file
+      func_names: list of function names to take into consideration, empty means
+        all functions.
+    """
     self.path = path
     self.limit_scan_depth = limit_scan_depth
     self._tu = tu
@@ -599,6 +602,7 @@ class _TranslationUnit(object):
     self.defines = {}
     self.required_defines = set()
     self.types_to_skip = set()
+    self.func_names = func_names or []
 
   def _process(self):
     # type: () -> None
@@ -631,6 +635,9 @@ class _TranslationUnit(object):
           self.forward_decls[Type(self, cursor.type)] = cursor
         if (cursor.kind == cindex.CursorKind.FUNCTION_DECL and
             cursor.linkage != cindex.LinkageKind.INTERNAL):
+          # Skip non-interesting functions
+          if self.func_names and cursor.spelling not in self.func_names:
+            continue
           if self.limit_scan_depth:
             if (cursor.location and cursor.location.file.name == self.path):
               self.functions.add(Function(self, cursor))
@@ -639,8 +646,7 @@ class _TranslationUnit(object):
 
   def get_functions(self):
     # type: () -> Set[Function]
-    if not self._processed:
-      self._process()
+    self._process()
     return self.functions
 
   def _walk_preorder(self):
@@ -664,33 +670,41 @@ class _TranslationUnit(object):
 class Analyzer(object):
   """Class responsible for analysis."""
 
+  # pylint: disable=line-too-long
   @staticmethod
-  def process_files(input_paths, compile_flags, limit_scan_depth=False):
-    # type: (Text, List[Text], bool) -> List[_TranslationUnit]
+  def process_files(
+      input_paths, compile_flags, limit_scan_depth=False, func_names=None
+  ):
+    # type: (Text, List[Text], bool, Optional[List[Text]]) -> List[_TranslationUnit]
     """Processes files with libclang and returns TranslationUnit objects."""
-    _init_libclang()
 
     tus = []
     for path in input_paths:
       tu = Analyzer._analyze_file_for_tu(
-          path, compile_flags=compile_flags, limit_scan_depth=limit_scan_depth)
+          path,
+          compile_flags=compile_flags,
+          limit_scan_depth=limit_scan_depth,
+          func_names=func_names,
+      )
       tus.append(tu)
     return tus
 
   # pylint: disable=line-too-long
   @staticmethod
-  def _analyze_file_for_tu(path,
-                           compile_flags=None,
-                           test_file_existence=True,
-                           unsaved_files=None,
-                           limit_scan_depth=False):
-    # type: (Text, Optional[List[Text]], bool, Optional[Tuple[Text, Union[Text, IO[Text]]]], bool) -> _TranslationUnit
+  def _analyze_file_for_tu(
+      path,
+      compile_flags=None,
+      test_file_existence=True,
+      unsaved_files=None,
+      limit_scan_depth=False,
+      func_names=None,
+  ):
+    # type: (Text, Optional[List[Text]], bool, Optional[Tuple[Text, Union[Text, IO[Text]]]], bool, Optional[List[Text]]) -> _TranslationUnit
     """Returns Analysis object for given path."""
     compile_flags = compile_flags or []
     if test_file_existence and not os.path.isfile(path):
       raise IOError('Path {} does not exist.'.format(path))
 
-    _init_libclang()
     index = cindex.Index.create()  # type: cindex.Index
     # TODO(szwl): hack until I figure out how python swig does that.
     # Headers will be parsed as C++. C libs usually have
@@ -702,11 +716,11 @@ class Analyzer(object):
     return _TranslationUnit(
         path,
         index.parse(
-            path,
-            args=args,
-            unsaved_files=unsaved_files,
-            options=_PARSE_OPTIONS),
-        limit_scan_depth=limit_scan_depth)
+            path, args=args, unsaved_files=unsaved_files, options=_PARSE_OPTIONS
+        ),
+        limit_scan_depth=limit_scan_depth,
+        func_names=func_names,
+    )
 
 
 class Generator(object):
@@ -718,10 +732,16 @@ class Generator(object):
   GUARD_START = ('#ifndef {0}\n' '#define {0}')
   GUARD_END = '#endif  // {}'
   EMBED_INCLUDE = '#include "{}"'
-  EMBED_CLASS = ('class {0}Sandbox : public ::sapi::Sandbox {{\n'
-                 ' public:\n'
-                 '  {0}Sandbox() : ::sapi::Sandbox({1}_embed_create()) {{}}\n'
-                 '}};')
+  EMBED_CLASS = '''
+class {0}Sandbox : public ::sapi::Sandbox {{
+  public:
+    {0}Sandbox()
+      : ::sapi::Sandbox([]() {{
+          static auto* fork_client_context =
+              new ::sapi::ForkClientContext({1}_embed_create());
+          return fork_client_context;
+        }}()) {{}}
+}};'''
 
   def __init__(self, translation_units):
     # type: (List[cindex.TranslationUnit]) -> None
@@ -734,22 +754,21 @@ class Generator(object):
     """
     self.translation_units = translation_units
     self.functions = None
-    _init_libclang()
-
-  def generate(self,
-               name,
-               function_names,
-               namespace=None,
-               output_file=None,
-               embed_dir=None,
-               embed_name=None):
+
+  def generate(
+      self,
+      name,
+      namespace=None,
+      output_file=None,
+      embed_dir=None,
+      embed_name=None,
+  ):
     # pylint: disable=line-too-long
-    # type: (Text, List[Text], Optional[Text], Optional[Text], Optional[Text], Optional[Text]) -> Text
+    # type: (Text, Optional[Text], Optional[Text], Optional[Text], Optional[Text]) -> Text
     """Generates structures, functions and typedefs.
 
     Args:
       name: name of the class that will contain generated interface
-      function_names: list of function names to export to the interface
       namespace: namespace of the interface
       output_file: path to the output file, used to generate header guards;
         defaults to None that does not generate the guard #include directives;
@@ -760,9 +779,9 @@ class Generator(object):
     Returns:
       generated interface as a string
     """
-    related_types = self._get_related_types(function_names)
+    related_types = self._get_related_types()
     forward_decls = self._get_forward_decls(related_types)
-    functions = self._get_functions(function_names)
+    functions = self._get_functions()
     related_types = [(t.stringify() + ';') for t in related_types]
     defines = self._get_defines()
 
@@ -777,18 +796,15 @@ class Generator(object):
     }
     return self.format_template(**api)
 
-  def _get_functions(self, func_names=None):
-    # type: (Optional[List[Text]]) -> List[Function]
+  def _get_functions(self):
+    # type: () -> List[Function]
     """Gets Function objects that will be used to generate interface."""
     if self.functions is not None:
       return self.functions
     self.functions = []
     # TODO(szwl): for d in translation_unit.diagnostics:, handle that
     for translation_unit in self.translation_units:
-      self.functions += [
-          f for f in translation_unit.get_functions()
-          if not func_names or f.name in func_names
-      ]
+      self.functions += translation_unit.get_functions()
     # allow only nonmangled functions - C++ overloads are not handled in
     # code generation
     self.functions = [f for f in self.functions if not f.is_mangled()]
@@ -798,8 +814,8 @@ class Generator(object):
     self.functions.sort(key=lambda x: x.name)
     return self.functions
 
-  def _get_related_types(self, func_names=None):
-    # type: (Optional[List[Text]]) -> List[Type]
+  def _get_related_types(self):
+    # type: () -> List[Type]
     """Gets type definitions related to chosen functions.
 
     Types related to one function will land in the same translation unit,
@@ -807,19 +823,14 @@ class Generator(object):
     This is necessary as we can't compare types from two different translation
     units.
 
-    Args:
-      func_names: list of function names to take into consideration, empty means
-        all functions.
-
     Returns:
       list of types in correct (ready to render) order
     """
     processed = set()
-    fn_related_types = set()
     types = []
     types_to_skip = set()
 
-    for f in self._get_functions(func_names):
+    for f in self._get_functions():
       fn_related_types = f.get_related_types()
       types += sorted(r for r in fn_related_types if r not in processed)
       processed.update(fn_related_types)
diff --git a/sandboxed_api/tools/generator2/code_test.py b/sandboxed_api/tools/python_generator/code_test.py
similarity index 88%
rename from sandboxed_api/tools/generator2/code_test.py
rename to sandboxed_api/tools/python_generator/code_test.py
index 8ef6057..2f6ec3f 100644
--- a/sandboxed_api/tools/generator2/code_test.py
+++ b/sandboxed_api/tools/python_generator/code_test.py
@@ -19,8 +19,8 @@ from __future__ import print_function
 from absl.testing import absltest
 from absl.testing import parameterized
 from clang import cindex
-from com_google_sandboxed_api.sandboxed_api.tools.generator2 import code
-from com_google_sandboxed_api.sandboxed_api.tools.generator2 import code_test_util
+from com_google_sandboxed_api.sandboxed_api.tools.python_generator import code
+from com_google_sandboxed_api.sandboxed_api.tools.python_generator import code_test_util
 
 CODE = """
 typedef int(fun*)(int,int);
@@ -33,15 +33,20 @@ struct a {
 """
 
 
-def analyze_string(content, path='tmp.cc', limit_scan_depth=False):
+def analyze_string(
+    content, path='tmp.cc', limit_scan_depth=False, func_names=None
+):
   """Returns Analysis object for in memory content."""
-  return analyze_strings(path, [(path, content)], limit_scan_depth)
+  return analyze_strings(path, [(path, content)], limit_scan_depth, func_names)
 
 
-def analyze_strings(path, unsaved_files, limit_scan_depth=False):
+def analyze_strings(
+    path, unsaved_files, limit_scan_depth=False, func_names=None
+):
   """Returns Analysis object for in memory content."""
-  return code.Analyzer._analyze_file_for_tu(path, None, False, unsaved_files,
-                                            limit_scan_depth)
+  return code.Analyzer._analyze_file_for_tu(
+      path, None, False, unsaved_files, limit_scan_depth, func_names
+  )
 
 
 class CodeAnalysisTest(parameterized.TestCase):
@@ -88,10 +93,17 @@ class CodeAnalysisTest(parameterized.TestCase):
         for x in translation_unit._walk_preorder()
         if x.kind != cindex.CursorKind.MACRO_DEFINITION
     ]
-    self.assertListEqual(cursor_kinds, [
-        cindex.CursorKind.TRANSLATION_UNIT, cindex.CursorKind.LINKAGE_SPEC,
-        cindex.CursorKind.FUNCTION_DECL, cindex.CursorKind.PARM_DECL
-    ])
+    for kind in [
+        cindex.CursorKind.TRANSLATION_UNIT,
+        cindex.CursorKind.FUNCTION_DECL,
+        cindex.CursorKind.PARM_DECL,
+    ]:
+      self.assertIn(kind, cursor_kinds)
+    self.assertTrue(
+        cindex.CursorKind.LINKAGE_SPEC in cursor_kinds
+        # Older libclang versions to not have a cursor type for linkage specs
+        or cindex.CursorKind.UNEXPOSED_DECL in cursor_kinds
+    )
 
   @parameterized.named_parameters(
       ('1:', '/tmp/test.h', 'tmp', 'tmp/test.h'),
@@ -123,11 +135,16 @@ class CodeAnalysisTest(parameterized.TestCase):
       }
     """
     functions = [
-        'function_a', 'types_1', 'types_2', 'types_3', 'types_4', 'types_5',
-        'types_6'
+        'function_a',
+        'types_1',
+        'types_2',
+        'types_3',
+        'types_4',
+        'types_5',
+        'types_6',
     ]
-    generator = code.Generator([analyze_string(body)])
-    result = generator.generate('Test', functions, 'sapi::Tests', None, None)
+    generator = code.Generator([analyze_string(body, func_names=functions)])
+    result = generator.generate('Test', 'sapi::Tests', None, None)
     self.assertMultiLineEqual(code_test_util.CODE_GOLD, result)
 
   def testElaboratedArgument(self):
@@ -135,18 +152,18 @@ class CodeAnalysisTest(parameterized.TestCase):
       struct x { int a; };
       extern "C" int function(struct x a) { return a.a; }
     """
-    generator = code.Generator([analyze_string(body)])
+    generator = code.Generator([analyze_string(body, func_names=['function'])])
     with self.assertRaisesRegex(ValueError, r'Elaborate.*mapped.*'):
-      generator.generate('Test', ['function'], 'sapi::Tests', None, None)
+      generator.generate('Test', 'sapi::Tests', None, None)
 
   def testElaboratedArgument2(self):
     body = """
       typedef struct { int a; char b; } x;
       extern "C" int function(x a) { return a.a; }
     """
-    generator = code.Generator([analyze_string(body)])
+    generator = code.Generator([analyze_string(body, func_names=['function'])])
     with self.assertRaisesRegex(ValueError, r'Elaborate.*mapped.*'):
-      generator.generate('Test', ['function'], 'sapi::Tests', None, None)
+      generator.generate('Test', 'sapi::Tests', None, None)
 
   def testGetMappedType(self):
     body = """
@@ -155,7 +172,7 @@ class CodeAnalysisTest(parameterized.TestCase):
       extern "C" uint function(uintp a) { return *a; }
     """
     generator = code.Generator([analyze_string(body)])
-    result = generator.generate('Test', [], 'sapi::Tests', None, None)
+    result = generator.generate('Test', 'sapi::Tests', None, None)
     self.assertMultiLineEqual(code_test_util.CODE_GOLD_MAPPED, result)
 
   @parameterized.named_parameters(
@@ -170,11 +187,16 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertEqual(code.get_header_guard(path), expected)
 
   @parameterized.named_parameters(
-      ('function with return value and arguments',
-       'extern "C" int function(bool arg_bool, char* arg_ptr);',
-       ['arg_bool', 'arg_ptr']),
-      ('function without return value and no arguments',
-       'extern "C" void function();', []),
+      (
+          'function with return value and arguments',
+          'extern "C" int function(bool arg_bool, char* arg_ptr);',
+          ['arg_bool', 'arg_ptr'],
+      ),
+      (
+          'function without return value and no arguments',
+          'extern "C" void function();',
+          [],
+      ),
   )
   def testArgumentNames(self, body, names):
     generator = code.Generator([analyze_string(body)])
@@ -182,7 +204,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(functions, 1)
     self.assertLen(functions[0].argument_types, len(names))
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
     for t in functions[0].argument_types:
       self.assertIn(t.name, names)
 
@@ -203,7 +225,7 @@ class CodeAnalysisTest(parameterized.TestCase):
       }
     """
     generator = code.Generator([analyze_string(body)])
-    result = generator.generate('Test', [], 'sapi::Tests', None, None)
+    result = generator.generate('Test', 'sapi::Tests', None, None)
     self.assertMultiLineEqual(code_test_util.CODE_ENUM_GOLD, result)
 
   def testTypeEq(self):
@@ -223,7 +245,7 @@ class CodeAnalysisTest(parameterized.TestCase):
 
     self.assertLen(set(args), 2)
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testTypedefRelatedTypes(self):
     body = """
@@ -262,7 +284,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertSameElements(names, ['data_s', 'data_p'])
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testTypedefDuplicateType(self):
     body = """
@@ -291,7 +313,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertSameElements(['data_s', 's'], names)
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testStructureRelatedTypes(self):
     body = """
@@ -342,7 +364,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(types, 1)
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testUnionRelatedTypes(self):
     body = """
@@ -382,7 +404,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertSameElements(names, ['union_1', 'uint'])
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testFunctionPointerRelatedTypes(self):
     body = """
@@ -415,7 +437,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertSameElements(names, ['funcp', 'uint', 'uchar'])
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testForwardDeclaration(self):
     body = """
@@ -440,24 +462,25 @@ class CodeAnalysisTest(parameterized.TestCase):
     names = [t._clang_type.spelling for t in types]
     self.assertLen(types, 4)
     self.assertSameElements(
-        names, ['struct_6p', 'struct_6', 'struct_6_def', 'function_p3'])
+        names, ['struct_6p', 'struct_6', 'struct_6_def', 'function_p3']
+    )
 
     self.assertLen(generator.translation_units, 1)
     self.assertLen(generator.translation_units[0].forward_decls, 1)
 
-    t = next(
-        x for x in types if x._clang_type.spelling == 'struct_6_def')
+    t = next(x for x in types if x._clang_type.spelling == 'struct_6_def')
     self.assertIn(t, generator.translation_units[0].forward_decls)
 
     names = [t._clang_type.spelling for t in generator._get_related_types()]
     self.assertEqual(
-        names, ['struct_6', 'struct_6p', 'function_p3', 'struct_6_def'])
+        names, ['struct_6', 'struct_6p', 'function_p3', 'struct_6_def']
+    )
 
     # Extra check for generation, in case rendering throws error for this test.
     forward_decls = generator._get_forward_decls(generator._get_related_types())
     self.assertLen(forward_decls, 1)
     self.assertEqual(forward_decls[0], 'struct struct_6_def;')
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testEnumRelatedTypes(self):
     body = """
@@ -486,7 +509,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(args[5].get_related_types(), 1)
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testArrayAsParam(self):
     body = """
@@ -568,8 +591,12 @@ class CodeAnalysisTest(parameterized.TestCase):
     typedef unsigned char uchar;"""
     file3_code = 'typedef unsigned long ulong;'
     file4_code = 'typedef char chr;'
-    files = [('f1.h', file1_code), ('/f2.h', file2_code), ('/f3.h', file3_code),
-             ('/f4.h', file4_code)]
+    files = [
+        ('f1.h', file1_code),
+        ('/f2.h', file2_code),
+        ('/f3.h', file3_code),
+        ('/f4.h', file4_code),
+    ]
     generator = code.Generator([analyze_strings('f1.h', files)])
     functions = generator._get_functions()
     self.assertLen(functions, 1)
@@ -577,7 +604,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     args = functions[0].arguments()
     getattr(self, func)(args[a1], args[a2])
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testFilterFunctionsFromInputFilesOnly(self):
     file1_code = """
@@ -643,7 +670,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertMultiLineEqual(expected, types[1].stringify())
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testCollectDefines(self):
     body = """
@@ -665,7 +692,7 @@ class CodeAnalysisTest(parameterized.TestCase):
 
     generator._get_related_types()
     tu = generator.translation_units[0]
-    tu._process()
+    tu.get_functions()
 
     self.assertLen(tu.required_defines, 4)
     defines = generator._get_defines()
@@ -676,7 +703,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertIn('#define SIZE4 10', defines)
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testYaraCase(self):
     body = """
@@ -697,7 +724,7 @@ class CodeAnalysisTest(parameterized.TestCase):
 
     generator._get_related_types()
     tu = generator.translation_units[0]
-    tu._process()
+    tu.get_functions()
 
     self.assertLen(tu.required_defines, 2)
     defines = generator._get_defines()
@@ -708,7 +735,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertTrue(defines[1].startswith(gold))
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testDoubleFunction(self):
     body = """
@@ -726,7 +753,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(tu.functions, 1)
 
     # Extra check for generation, in case rendering throws error for this test.
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
   def testDefineStructBody(self):
     body = """
@@ -744,7 +771,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(generator.translation_units, 1)
 
     # initialize all internal data
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
     tu = generator.translation_units[0]
 
     self.assertLen(tu.functions, 1)
@@ -762,7 +789,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(generator.translation_units, 1)
 
     # initialize all internal data
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
     tu = generator.translation_units[0]
     self.assertLen(tu.functions, 1)
@@ -784,7 +811,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(generator.translation_units, 1)
 
     # Initialize all internal data
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
     tu = generator.translation_units[0]
     self.assertLen(tu.functions, 2)
@@ -802,7 +829,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     self.assertLen(generator.translation_units, 1)
 
     # Initialize all internal data
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
     tu = generator.translation_units[0]
     self.assertLen(tu.functions, 1)
@@ -822,7 +849,7 @@ class CodeAnalysisTest(parameterized.TestCase):
     unsaved_files = [(path, content)]
     generator = code.Generator([analyze_strings(path, unsaved_files)])
     # Initialize all internal data
-    generator.generate('Test', [], 'sapi::Tests', None, None)
+    generator.generate('Test', 'sapi::Tests', None, None)
 
     # generator should filter out mangled function
     functions = generator._get_functions()
diff --git a/sandboxed_api/tools/generator2/code_test_util.py b/sandboxed_api/tools/python_generator/code_test_util.py
similarity index 100%
rename from sandboxed_api/tools/generator2/code_test_util.py
rename to sandboxed_api/tools/python_generator/code_test_util.py
diff --git a/sandboxed_api/tools/generator2/sapi_generator.py b/sandboxed_api/tools/python_generator/sapi_generator.py
similarity index 82%
rename from sandboxed_api/tools/generator2/sapi_generator.py
rename to sandboxed_api/tools/python_generator/sapi_generator.py
index 56a6dab..19dc68d 100644
--- a/sandboxed_api/tools/generator2/sapi_generator.py
+++ b/sandboxed_api/tools/python_generator/sapi_generator.py
@@ -16,15 +16,15 @@
 Parses headers to extract type information from functions and generate a SAPI
 interface wrapper.
 """
+import os  # pylint: disable=unused-import
 import sys
 
 from absl import app
 from absl import flags
 from absl import logging
-try:
-  from com_google_sandboxed_api.sandboxed_api.tools.generator2 import code
-except:
-  import code
+
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', '..'))
+from sandboxed_api.tools.python_generator import code
 
 FLAGS = flags.FLAGS
 
@@ -40,7 +40,6 @@ flags.DEFINE_bool(
     'sapi_limit_scan_depth', False,
     'scan only functions from top level file in compilation unit')
 
-
 def extract_includes(path, array):
   try:
     with open(path, 'r') as f:
@@ -57,12 +56,17 @@ def main(c_flags):
   c_flags.pop(0)
   logging.debug(FLAGS.sapi_functions)
   extract_includes(FLAGS.sapi_isystem, c_flags)
-  tus = code.Analyzer.process_files(FLAGS.sapi_in, c_flags,
-                                    FLAGS.sapi_limit_scan_depth)
+  tus = code.Analyzer.process_files(
+      FLAGS.sapi_in, c_flags, FLAGS.sapi_limit_scan_depth, FLAGS.sapi_functions
+  )
   generator = code.Generator(tus)
-  result = generator.generate(FLAGS.sapi_name, FLAGS.sapi_functions,
-                              FLAGS.sapi_ns, FLAGS.sapi_out,
-                              FLAGS.sapi_embed_dir, FLAGS.sapi_embed_name)
+  result = generator.generate(
+      FLAGS.sapi_name,
+      FLAGS.sapi_ns,
+      FLAGS.sapi_out,
+      FLAGS.sapi_embed_dir,
+      FLAGS.sapi_embed_name,
+  )
 
   if FLAGS.sapi_out:
     with open(FLAGS.sapi_out, 'w') as out_file:
diff --git a/sandboxed_api/tools/generator2/testdata/main.cc b/sandboxed_api/tools/python_generator/testdata/main.cc
similarity index 89%
rename from sandboxed_api/tools/generator2/testdata/main.cc
rename to sandboxed_api/tools/python_generator/testdata/main.cc
index 6b25f59..920b404 100644
--- a/sandboxed_api/tools/generator2/testdata/main.cc
+++ b/sandboxed_api/tools/python_generator/testdata/main.cc
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include "sandboxed_api/tools/generator2/tests_sapi_generator.sapi.h"
+#include "sandboxed_api/tools/python_generator/tests_sapi_generator.sapi.h"
 
 int main() {
   sapi::tests::struct_t a;
diff --git a/sandboxed_api/tools/generator2/testdata/tests.cc b/sandboxed_api/tools/python_generator/testdata/tests.cc
similarity index 98%
rename from sandboxed_api/tools/generator2/testdata/tests.cc
rename to sandboxed_api/tools/python_generator/testdata/tests.cc
index 5c01bb9..8c514fc 100644
--- a/sandboxed_api/tools/generator2/testdata/tests.cc
+++ b/sandboxed_api/tools/python_generator/testdata/tests.cc
@@ -18,7 +18,7 @@
 // be passed as arguments, returned by function or be part of structure
 // dependency chain
 
-#include "sandboxed_api/tools/generator2/testdata/tests.h"
+#include "sandboxed_api/tools/python_generator/testdata/tests.h"  // IWYU pragma: keep
 
 namespace a {
 namespace b {
diff --git a/sandboxed_api/tools/generator2/testdata/tests.h b/sandboxed_api/tools/python_generator/testdata/tests.h
similarity index 75%
rename from sandboxed_api/tools/generator2/testdata/tests.h
rename to sandboxed_api/tools/python_generator/testdata/tests.h
index da8bbd6..a1cf1d2 100644
--- a/sandboxed_api/tools/generator2/testdata/tests.h
+++ b/sandboxed_api/tools/python_generator/testdata/tests.h
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#ifndef SANDBOXED_API_TOOLS_GENERATOR2_TESTDATA_TESTS_H_
-#define SANDBOXED_API_TOOLS_GENERATOR2_TESTDATA_TESTS_H_
+#ifndef SANDBOXED_API_TOOLS_PYTHON_GENERATOR_TESTDATA_TESTS_H_
+#define SANDBOXED_API_TOOLS_PYTHON_GENERATOR_TESTDATA_TESTS_H_
 
-#endif  // SANDBOXED_API_TOOLS_GENERATOR2_TESTDATA_TESTS_H_
+#endif  // SANDBOXED_API_TOOLS_PYTHON_GENERATOR_TESTDATA_TESTS_H_
diff --git a/sandboxed_api/tools/generator2/testdata/tests2.cc b/sandboxed_api/tools/python_generator/testdata/tests2.cc
similarity index 89%
rename from sandboxed_api/tools/generator2/testdata/tests2.cc
rename to sandboxed_api/tools/python_generator/testdata/tests2.cc
index 21f9e36..72479ff 100644
--- a/sandboxed_api/tools/generator2/testdata/tests2.cc
+++ b/sandboxed_api/tools/python_generator/testdata/tests2.cc
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include "sandboxed_api/tools/generator2/testdata/tests.h"
+#include "sandboxed_api/tools/python_generator/testdata/tests.h"  // IWYU pragma: keep
 
 // This compilation unit should have this structure partially defined
 struct struct_2* function_returning_struct_ptr() {
diff --git a/sandboxed_api/transaction.cc b/sandboxed_api/transaction.cc
index 1073f2f..149b9f1 100644
--- a/sandboxed_api/transaction.cc
+++ b/sandboxed_api/transaction.cc
@@ -17,6 +17,7 @@
 #include <functional>
 #include <memory>
 
+#include "absl/cleanup/cleanup.h"
 #include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/time/time.h"
@@ -33,14 +34,10 @@ absl::Status TransactionBase::RunTransactionFunctionInSandbox(
 
   // Set the wall-time limit for this transaction run, and clean it up
   // afterwards, no matter what the result.
-  SAPI_RETURN_IF_ERROR(
-      sandbox_->SetWallTimeLimit(absl::Seconds(GetTimeLimit())));
-  struct TimeCleanup {
-    ~TimeCleanup() {
-      capture->sandbox_->SetWallTimeLimit(absl::ZeroDuration()).IgnoreError();
-    }
-    TransactionBase* capture;
-  } sandbox_cleanup = {this};
+  SAPI_RETURN_IF_ERROR(sandbox_->SetWallTimeLimit(time_limit_));
+  absl::Cleanup time_cleanup = [this] {
+    sandbox_->SetWallTimeLimit(absl::ZeroDuration()).IgnoreError();
+  };
 
   if (!initialized_) {
     SAPI_RETURN_IF_ERROR(Init());
diff --git a/sandboxed_api/transaction.h b/sandboxed_api/transaction.h
index 2270ff5..83d8fa6 100644
--- a/sandboxed_api/transaction.h
+++ b/sandboxed_api/transaction.h
@@ -65,11 +65,13 @@ class TransactionBase {
   }
 
   // Getter/Setter for time_limit_.
-  time_t GetTimeLimit() const { return time_limit_; }
-  void SetTimeLimit(time_t time_limit) { time_limit_ = time_limit; }
-  void SetTimeLimit(absl::Duration time_limit) {
-    time_limit_ = absl::ToTimeT(absl::UnixEpoch() + time_limit);
+  time_t GetTimeLimit() const {
+    return absl::ToTimeT(absl::UnixEpoch() + time_limit_);
   }
+  void SetTimeLimit(time_t time_limit) {
+    time_limit_ = absl::Seconds(time_limit);
+  }
+  void SetTimeLimit(absl::Duration time_limit) { time_limit_ = time_limit; }
 
   bool IsInitialized() const { return initialized_; }
 
@@ -90,8 +92,7 @@ class TransactionBase {
 
  protected:
   explicit TransactionBase(std::unique_ptr<Sandbox> sandbox)
-      : time_limit_(absl::ToTimeT(absl::UnixEpoch() + kDefaultTimeLimit)),
-        sandbox_(std::move(sandbox)) {}
+      : time_limit_(kDefaultTimeLimit), sandbox_(std::move(sandbox)) {}
 
   // Runs the main (retrying) transaction loop.
   absl::Status RunTransactionLoop(const std::function<absl::Status()>& f);
@@ -121,7 +122,7 @@ class TransactionBase {
 
   // Time (wall-time) limit for a single Run() call (in seconds). 0 means: no
   // wall-time limit.
-  time_t time_limit_;
+  absl::Duration time_limit_;
 
   // Has Init() finished with success?
   bool initialized_ = false;
diff --git a/sandboxed_api/util/BUILD.bazel b/sandboxed_api/util/BUILD
similarity index 83%
rename from sandboxed_api/util/BUILD.bazel
rename to sandboxed_api/util/BUILD
index 9dac419..e37b8b1 100644
--- a/sandboxed_api/util/BUILD.bazel
+++ b/sandboxed_api/util/BUILD
@@ -12,15 +12,12 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
-load("//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:build_defs.bzl", "sapi_platform_copts")
+load("@com_google_sandboxed_api//sandboxed_api/bazel:proto.bzl", "sapi_proto_library")
 
-package(
-    default_visibility = [
-        "//sandboxed_api:__subpackages__",
-        "//security/bedebox:__subpackages__",
-    ],
-)
+package(default_visibility = [
+    "@com_google_sandboxed_api//sandboxed_api:__subpackages__",
+])
 
 licenses(["notice"])
 
@@ -90,9 +87,29 @@ cc_test(
         ":file_helpers",
         ":fileops",
         ":status_matchers",
-        "//sandboxed_api:testing",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+    ],
+)
+
+sapi_proto_library(
+    name = "proto_arg",
+    srcs = ["proto_arg.proto"],
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "proto_helper",
+    srcs = ["proto_helper.cc"],
+    hdrs = ["proto_helper.h"],
+    copts = sapi_platform_copts(),
+    deps = [
+        ":proto_arg_cc_proto",
+        ":status",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_protobuf//:protobuf_lite",
     ],
 )
 
@@ -121,10 +138,10 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":file_base",
-        ":raw_logging",
         "@bazel_tools//tools/cpp/runfiles",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
+        "@com_google_sandboxed_api//sandboxed_api/util:raw_logging",
     ],
 )
 
@@ -177,6 +194,7 @@ cc_test(
     copts = sapi_platform_copts(),
     deps = [
         ":status",
+        ":status_cc_proto",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_googletest//:gtest_main",
@@ -217,6 +235,7 @@ cc_test(
     copts = sapi_platform_copts(),
     deps = [
         ":strerror",
+        ":thread",
         "@com_google_absl//absl/strings",
         "@com_google_googletest//:gtest_main",
     ],
@@ -244,9 +263,19 @@ cc_test(
         ":fileops",
         ":status_matchers",
         ":temp_file",
-        "//sandboxed_api:testing",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_googletest//:gtest_main",
+        "@com_google_sandboxed_api//sandboxed_api:testing",
+    ],
+)
+
+cc_library(
+    name = "thread",
+    hdrs = ["thread.h"],
+    copts = sapi_platform_copts(),
+    deps = [
+        "@com_google_absl//absl/functional:any_invocable",
+        "@com_google_absl//absl/strings:string_view",
     ],
 )
diff --git a/sandboxed_api/util/CMakeLists.txt b/sandboxed_api/util/CMakeLists.txt
index ae91c16..b91fa1d 100644
--- a/sandboxed_api/util/CMakeLists.txt
+++ b/sandboxed_api/util/CMakeLists.txt
@@ -47,6 +47,36 @@ target_link_libraries(sapi_util_fileops PRIVATE
   sapi::base
 )
 
+# sandboxed_api/util:proto_arg
+sapi_protobuf_generate_cpp(_sapi_proto_arg_pb_cc _sapi_proto_arg_pb_h
+  proto_arg.proto
+)
+add_library(sapi_util_proto_arg_proto ${SAPI_LIB_TYPE}
+  ${_sapi_proto_arg_pb_cc}
+  ${_sapi_proto_arg_pb_h}
+)
+add_library(sapi::proto_arg_proto ALIAS sapi_util_proto_arg_proto)
+target_link_libraries(sapi_util_proto_arg_proto PRIVATE
+  protobuf::libprotobuf
+  sapi::base
+)
+
+# sandboxed_api/util:proto_helper
+add_library(sapi_util_proto_helper ${SAPI_LIB_TYPE}
+  proto_helper.cc
+  proto_helper.h
+)
+add_library(sapi::proto_helper ALIAS sapi_util_proto_helper)
+target_link_libraries(sapi_util_proto_helper
+  PRIVATE sapi::base
+  PUBLIC absl::core_headers
+         absl::status
+         absl::statusor
+         sapi::proto_arg_proto
+         sapi::status
+)
+
+
 # sandboxed_api/util:raw_logging
 add_library(sapi_util_raw_logging ${SAPI_LIB_TYPE}
   raw_logging.cc
@@ -134,6 +164,17 @@ target_link_libraries(sapi_util_temp_file
          absl::statusor
 )
 
+# sandboxed_api/util:thread
+add_library(sapi_util_thread ${SAPI_LIB_TYPE}
+  thread.h
+)
+add_library(sapi::thread ALIAS sapi_util_thread)
+target_link_libraries(sapi_util_thread
+  PUBLIC absl::any_invocable
+         absl::strings
+         sapi::base
+)
+
 if(BUILD_TESTING AND SAPI_BUILD_TESTING)
   # sandboxed_api/util:file_base_test
   add_executable(sapi_file_base_test
@@ -239,6 +280,7 @@ if(BUILD_TESTING AND SAPI_BUILD_TESTING)
     absl::strings
     sapi::strerror
     sapi::test_main
+    sapi::thread
   )
   gtest_discover_tests_xcompile(sapi_strerror_test)
 
diff --git a/sandboxed_api/util/file_helpers.cc b/sandboxed_api/util/file_helpers.cc
index df1af4d..955ad79 100644
--- a/sandboxed_api/util/file_helpers.cc
+++ b/sandboxed_api/util/file_helpers.cc
@@ -15,6 +15,7 @@
 #include "sandboxed_api/util/file_helpers.h"
 
 #include <fstream>
+#include <ios>
 #include <sstream>
 #include <string>
 
diff --git a/sandboxed_api/util/fileops.cc b/sandboxed_api/util/fileops.cc
index cc5f525..2373d8d 100644
--- a/sandboxed_api/util/fileops.cc
+++ b/sandboxed_api/util/fileops.cc
@@ -22,6 +22,7 @@
 #include <cerrno>
 #include <cstdlib>
 #include <fstream>
+#include <ios>
 #include <memory>
 #include <string>
 #include <utility>
@@ -69,19 +70,17 @@ std::string GetCWD() {
 
 // Makes a path absolute with respect to base. Returns true on success. Result
 // may be an alias of base or filename.
-bool MakeAbsolute(const std::string& filename, const std::string& base,
+bool MakeAbsolute(absl::string_view filename, absl::string_view base,
                   std::string* result) {
   if (filename.empty()) {
     return false;
   }
   if (filename[0] == '/') {
-    if (result != &filename) {
-      *result = filename;
-    }
+    *result = std::string(filename);
     return true;
   }
 
-  std::string actual_base = base;
+  std::string actual_base = std::string(base);
   if (actual_base.empty() && !GetCWD(&actual_base)) {
     return false;
   }
@@ -95,12 +94,12 @@ bool MakeAbsolute(const std::string& filename, const std::string& base,
       *result = actual_base;
     }
   } else {
-    *result = actual_base + "/" + filename;
+    *result = absl::StrCat(actual_base, "/", filename);
   }
   return true;
 }
 
-std::string MakeAbsolute(const std::string& filename, const std::string& base) {
+std::string MakeAbsolute(absl::string_view filename, absl::string_view base) {
   std::string result;
   return !MakeAbsolute(filename, base, &result) ? "" : result;
 }
diff --git a/sandboxed_api/util/fileops.h b/sandboxed_api/util/fileops.h
index f1c0a88..6be248d 100644
--- a/sandboxed_api/util/fileops.h
+++ b/sandboxed_api/util/fileops.h
@@ -104,7 +104,7 @@ bool CopyFile(const std::string& old_path, const std::string& new_path,
 
 // Makes filename absolute with respect to base. Returns an empty string on
 // failure.
-std::string MakeAbsolute(const std::string& filename, const std::string& base);
+std::string MakeAbsolute(absl::string_view filename, absl::string_view base);
 
 // Writes data to a file descriptor. The file descriptor should be blocking.
 // Returns true on success.
diff --git a/sandboxed_api/util/fileops_test.cc b/sandboxed_api/util/fileops_test.cc
index 6d9cc94..24f1a69 100644
--- a/sandboxed_api/util/fileops_test.cc
+++ b/sandboxed_api/util/fileops_test.cc
@@ -19,7 +19,6 @@
 
 #include <algorithm>
 #include <cerrno>
-#include <climits>
 #include <string>
 #include <vector>
 
diff --git a/sandboxed_api/util/path.h b/sandboxed_api/util/path.h
index 8ff3240..3b33bdf 100644
--- a/sandboxed_api/util/path.h
+++ b/sandboxed_api/util/path.h
@@ -48,10 +48,15 @@ std::pair<absl::string_view, absl::string_view> SplitPath(
 // Collapses duplicate "/"s, resolve ".." and "." path elements, removes
 // trailing "/".
 //
-// NOTE: This respects relative vs. absolute paths, but does not
-// invoke any system calls in order to resolve relative paths to the actual
-// working directory. That is, this is purely a string manipulation, completely
-// independent of process state.
+// This is purely a string manipulation and does not invoke any system calls in
+// order to resolve relative paths to the actual working directory.
+//
+// For absolute paths, this is equivalent to the following:
+//   /path/to/./foo/../bar/../baz/ -> /path/to/bar/baz
+//
+// For relative paths, this is equivalent to the following:
+//   ./path/to/./foo/../bar/../baz/ -> path/to/bar/baz
+//   ../path/to/./foo/../bar/../baz/ -> ../path/to/bar/baz
 std::string CleanPath(absl::string_view path);
 
 }  // namespace sapi::file
diff --git a/sandboxed_api/util/path_test.cc b/sandboxed_api/util/path_test.cc
index b33dce0..0d19979 100644
--- a/sandboxed_api/util/path_test.cc
+++ b/sandboxed_api/util/path_test.cc
@@ -96,6 +96,12 @@ TEST(PathTest, CleanPath) {
   EXPECT_THAT(file::CleanPath("../../a/b/../c"), StrEq("../../a/c"));
   EXPECT_THAT(file::CleanPath("../../a/b/../c/../.."), StrEq("../.."));
   EXPECT_THAT(file::CleanPath("foo/../../../bar"), StrEq("../../bar"));
+  EXPECT_THAT(file::CleanPath("/path/to/./foo/../bar/../baz/"),
+              StrEq("/path/to/baz"));
+  EXPECT_THAT(file::CleanPath("./path/to/./foo/../bar/../baz/"),
+              StrEq("path/to/baz"));
+  EXPECT_THAT(file::CleanPath("../path/to/./foo/../bar/../baz/"),
+              StrEq("../path/to/baz"));
 }
 
 }  // namespace
diff --git a/sandboxed_api/proto_arg.proto b/sandboxed_api/util/proto_arg.proto
similarity index 100%
rename from sandboxed_api/proto_arg.proto
rename to sandboxed_api/util/proto_arg.proto
diff --git a/sandboxed_api/proto_helper.cc b/sandboxed_api/util/proto_helper.cc
similarity index 84%
rename from sandboxed_api/proto_helper.cc
rename to sandboxed_api/util/proto_helper.cc
index 868033d..ce8ef5d 100644
--- a/sandboxed_api/proto_helper.cc
+++ b/sandboxed_api/util/proto_helper.cc
@@ -12,15 +12,18 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include "sandboxed_api/proto_helper.h"
+#include "sandboxed_api/util/proto_helper.h"
 
 #include <cstddef>
 #include <cstdint>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "google/protobuf/message_lite.h"
+#include "sandboxed_api/util/proto_arg.pb.h"
 
 namespace sapi {
 
@@ -47,7 +50,11 @@ absl::StatusOr<std::vector<uint8_t>> SerializeProto(
   // Wrap protobuf in a envelope so that we know the name of the protobuf
   // structure when deserializing in the sandboxee.
   ProtoArg proto_arg;
-  proto_arg.set_protobuf_data(proto.SerializeAsString());
+  std::string proto_data;
+  if (!proto.SerializeToString(&proto_data)) {
+    return absl::InternalError("Unable to serialize proto data");
+  }
+  proto_arg.set_protobuf_data(std::move(proto_data));
   proto_arg.set_full_name(proto.GetTypeName());
   std::vector<uint8_t> serialized_proto(proto_arg.ByteSizeLong());
   if (!proto_arg.SerializeToArray(serialized_proto.data(),
diff --git a/sandboxed_api/proto_helper.h b/sandboxed_api/util/proto_helper.h
similarity index 87%
rename from sandboxed_api/proto_helper.h
rename to sandboxed_api/util/proto_helper.h
index 267bbba..ba95916 100644
--- a/sandboxed_api/proto_helper.h
+++ b/sandboxed_api/util/proto_helper.h
@@ -14,8 +14,8 @@
 
 // Utility functions for protobuf handling.
 
-#ifndef SANDBOXED_API_PROTO_HELPER_H_
-#define SANDBOXED_API_PROTO_HELPER_H_
+#ifndef SANDBOXED_API_UTIL_PROTO_HELPER_H_
+#define SANDBOXED_API_UTIL_PROTO_HELPER_H_
 
 #include <cstddef>
 #include <cstdint>
@@ -24,7 +24,8 @@
 
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
-#include "sandboxed_api/proto_arg.pb.h"
+#include "google/protobuf/message_lite.h"
+#include "sandboxed_api/util/proto_arg.pb.h"
 #include "sandboxed_api/util/status_macros.h"
 
 namespace sapi {
@@ -51,4 +52,4 @@ absl::StatusOr<T> DeserializeProto(const char* data, size_t len) {
 
 }  // namespace sapi
 
-#endif  // SANDBOXED_API_PROTO_HELPER_H_
+#endif  // SANDBOXED_API_UTIL_PROTO_HELPER_H_
diff --git a/sandboxed_api/util/raw_logging.cc b/sandboxed_api/util/raw_logging.cc
index ce0ab77..366bc38 100644
--- a/sandboxed_api/util/raw_logging.cc
+++ b/sandboxed_api/util/raw_logging.cc
@@ -14,23 +14,24 @@
 
 #include "sandboxed_api/util/raw_logging.h"
 
-#include <syscall.h>
 #include <unistd.h>
 
+#include <cstdlib>
+#include <limits>
+
+#include "absl/strings/numbers.h"
+
+#ifndef SAPI_USE_ABSL_RAW_LOG
+#include <syscall.h>
+
 #include <cstdarg>
 #include <cstdio>
-#include <cstdlib>
 #include <cstring>
-#include <limits>
 
 #include "absl/base/attributes.h"
 #include "absl/base/log_severity.h"
-#include "absl/strings/numbers.h"
-
-#ifdef __ANDROID__
-#include "android/log.h"
-#endif
 
+namespace {
 static const char kTruncated[] = " ... (message truncated)\n";
 
 // sprintf the format to the buffer, adjusting *buf and *size to reflect the
@@ -56,8 +57,6 @@ inline static bool VADoRawLog(char** buf, int* size, const char* format,
   return result;
 }
 
-namespace {
-
 // CAVEAT: vsnprintf called from *DoRawLog below has some (exotic) code paths
 // that invoke malloc() and getenv() that might acquire some locks.
 
@@ -77,22 +76,14 @@ bool DoRawLog(char** buf, int* size, const char* format, ...) {
   return true;
 }
 
-#ifdef __ANDROID__
-android_LogPriority ConvertSeverity(absl::LogSeverity severity) {
-  switch (severity) {
-    case absl::LogSeverity::kInfo:
-      return ANDROID_LOG_INFO;
-    case absl::LogSeverity::kWarning:
-      return ANDROID_LOG_WARN;
-    case absl::LogSeverity::kError:
-      return ANDROID_LOG_ERROR;
-    case absl::LogSeverity::kFatal:
-      return ANDROID_LOG_FATAL;
-    default:
-      return ANDROID_LOG_INFO;
-  }
+// Writes the provided buffer directly to stderr, in a safe, low-level manner.
+//
+// In POSIX this means calling write(), which is async-signal safe and does
+// not malloc.  If the platform supports the SYS_write syscall, we invoke that
+// directly to side-step any libc interception.
+void SafeWriteToStderr(const char* s, size_t len) {
+  syscall(SYS_write, STDERR_FILENO, s, len);
 }
-#endif
 
 void RawLogVA(absl::LogSeverity severity, const char* file, int line,
               const char* format, va_list ap) ABSL_PRINTF_ATTRIBUTE(4, 0);
@@ -110,13 +101,8 @@ void RawLogVA(absl::LogSeverity severity, const char* file, int line,
   } else {
     DoRawLog(&buf, &size, "%s", kTruncated);
   }
-#ifndef __ANDROID__
-  sapi::raw_logging_internal::SafeWriteToStderr(buffer, strlen(buffer));
-#else
-  // Logs to Android's logcat with the TAG SAPI and the log line containing
-  // the code location and the log output.
-  __android_log_print(ConvertSeverity(severity), "SAPI", "%s", buffer);
-#endif
+
+  SafeWriteToStderr(buffer, strlen(buffer));
 
   // Abort the process after logging a FATAL message, even if the output itself
   // was suppressed.
@@ -126,9 +112,11 @@ void RawLogVA(absl::LogSeverity severity, const char* file, int line,
 }
 
 }  // namespace
+#endif
 
 namespace sapi::raw_logging_internal {
 
+#ifndef SAPI_USE_ABSL_RAW_LOG
 void RawLog(absl::LogSeverity severity, const char* file, int line,
             const char* format, ...) ABSL_PRINTF_ATTRIBUTE(4, 5);
 void RawLog(absl::LogSeverity severity, const char* file, int line,
@@ -138,10 +126,7 @@ void RawLog(absl::LogSeverity severity, const char* file, int line,
   RawLogVA(severity, file, line, format, ap);
   va_end(ap);
 }
-
-void SafeWriteToStderr(const char* s, size_t len) {
-  syscall(SYS_write, STDERR_FILENO, s, len);
-}
+#endif
 
 bool VLogIsOn(int verbose_level) {
   static int external_verbose_level = [] {
diff --git a/sandboxed_api/util/raw_logging.h b/sandboxed_api/util/raw_logging.h
index 27d864e..eaaa50e 100644
--- a/sandboxed_api/util/raw_logging.h
+++ b/sandboxed_api/util/raw_logging.h
@@ -32,12 +32,14 @@
 #include "absl/strings/str_format.h"
 #include "sandboxed_api/util/strerror.h"
 
-// Exclude ABSL_RAW_LOG when running on Android because it will not be visible
-// in logcat since Android sends anything written to stdout and stderr to
-// /dev/null.
-#if defined(ABSL_RAW_LOG) && !(__ANDROID__)
+#if defined(ABSL_RAW_LOG)
 #define SAPI_RAW_LOG ABSL_RAW_LOG
+#define SAPI_USE_ABSL_RAW_LOG 1
 #else
+#define SAPI_RAW_LOGGING_INTERNAL_INFO ::absl::LogSeverity::kInfo
+#define SAPI_RAW_LOGGING_INTERNAL_WARNING ::absl::LogSeverity::kWarning
+#define SAPI_RAW_LOGGING_INTERNAL_ERROR ::absl::LogSeverity::kError
+#define SAPI_RAW_LOGGING_INTERNAL_FATAL ::absl::LogSeverity::kFatal
 // This is similar to LOG(severity) << format..., but
 // * it is to be used ONLY by low-level modules that can't use normal LOG()
 // * it is designed to be a low-level logger that does not allocate any
@@ -80,32 +82,11 @@
   } while (0)
 #endif
 
-#define SAPI_RAW_LOGGING_INTERNAL_INFO ::absl::LogSeverity::kInfo
-#define SAPI_RAW_LOGGING_INTERNAL_WARNING ::absl::LogSeverity::kWarning
-#define SAPI_RAW_LOGGING_INTERNAL_ERROR ::absl::LogSeverity::kError
-#define SAPI_RAW_LOGGING_INTERNAL_FATAL ::absl::LogSeverity::kFatal
-
-// Returns whether SAPI verbose logging is enabled, as determined by the
+// Returns whether SAPI raw verbose logging is enabled, as determined by the
 // SAPI_VLOG_LEVEL environment variable.
-#define SAPI_VLOG_IS_ON(verbose_level) \
+#define SAPI_RAW_VLOG_IS_ON(verbose_level) \
   ::sapi::raw_logging_internal::VLogIsOn(verbose_level)
 
-#define SAPI_RAW_VLOG_IS_ON(verbose_level) SAPI_VLOG_IS_ON(verbose_level)
-
-#ifndef VLOG
-// `VLOG` uses numeric levels to provide verbose logging that can configured at
-// runtime, globally. `VLOG` statements are logged at `INFO` severity if they
-// are logged at all; the numeric levels are on a different scale than the
-// proper severity levels. Positive levels are disabled by default. Negative
-// levels should not be used.
-#define VLOG(verbose_level)                                                \
-  for (int sapi_logging_internal_verbose_level = (verbose_level),          \
-           sapi_logging_internal_log_loop = 1;                             \
-       sapi_logging_internal_log_loop; sapi_logging_internal_log_loop = 0) \
-  LOG_IF(INFO, SAPI_VLOG_IS_ON(sapi_logging_internal_verbose_level))       \
-      .WithVerbosity(sapi_logging_internal_verbose_level)
-#endif
-
 // Like SAPI_RAW_LOG(), but also logs the current value of errno and its
 // corresponding error message.
 #define SAPI_RAW_PLOG(severity, format, ...)                              \
@@ -148,6 +129,7 @@ namespace sapi::raw_logging_internal {
 
 constexpr int kLogBufSize = 3000;
 
+#ifndef SAPI_USE_ABSL_RAW_LOG
 // Helper function to implement ABSL_RAW_LOG
 // Logs format... at "severity" level, reporting it
 // as called from file:line.
@@ -155,13 +137,6 @@ constexpr int kLogBufSize = 3000;
 void RawLog(absl::LogSeverity severity, const char* file, int line,
             const char* format, ...) ABSL_PRINTF_ATTRIBUTE(4, 5);
 
-// Writes the provided buffer directly to stderr, in a safe, low-level manner.
-//
-// In POSIX this means calling write(), which is async-signal safe and does
-// not malloc.  If the platform supports the SYS_write syscall, we invoke that
-// directly to side-step any libc interception.
-void SafeWriteToStderr(const char* s, size_t len);
-
 // compile-time function to get the "base" filename, that is, the part of
 // a filename after the last "/" or "\" path separator.  The search starts at
 // the end of the string; the second parameter is the length of the string.
@@ -170,6 +145,7 @@ constexpr const char* Basename(const char* fname, int offset) {
              ? fname + offset
              : Basename(fname, offset - 1);
 }
+#endif
 
 bool VLogIsOn(int verbose_level);
 
diff --git a/sandboxed_api/util/status.cc b/sandboxed_api/util/status.cc
index c9459f6..6bfbe2b 100644
--- a/sandboxed_api/util/status.cc
+++ b/sandboxed_api/util/status.cc
@@ -20,6 +20,7 @@
 #include "absl/status/status.h"
 #include "absl/strings/cord.h"
 #include "absl/strings/string_view.h"
+#include "sandboxed_api/util/status.pb.h"
 
 namespace sapi {
 
diff --git a/sandboxed_api/util/status_macros_test.cc b/sandboxed_api/util/status_macros_test.cc
index 2a56492..497fecf 100644
--- a/sandboxed_api/util/status_macros_test.cc
+++ b/sandboxed_api/util/status_macros_test.cc
@@ -15,7 +15,6 @@
 #include "sandboxed_api/util/status_macros.h"
 
 #include <memory>
-#include <string>
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
diff --git a/sandboxed_api/util/status_test.cc b/sandboxed_api/util/status_test.cc
index 830c680..81f9f93 100644
--- a/sandboxed_api/util/status_test.cc
+++ b/sandboxed_api/util/status_test.cc
@@ -14,13 +14,13 @@
 
 #include "sandboxed_api/util/status.h"
 
-#include <cstdint>
 #include <string>
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
+#include "sandboxed_api/util/status.pb.h"
 
 using ::testing::Eq;
 using ::testing::StrEq;
diff --git a/sandboxed_api/util/strerror_test.cc b/sandboxed_api/util/strerror_test.cc
index 36b16a3..f623a2b 100644
--- a/sandboxed_api/util/strerror_test.cc
+++ b/sandboxed_api/util/strerror_test.cc
@@ -17,13 +17,14 @@
 #include <atomic>
 #include <cerrno>
 #include <cstring>
+#include <memory>
 #include <string>
-#include <thread>  // NOLINT(build/c++11)
 #include <vector>
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "absl/strings/match.h"
+#include "sandboxed_api/util/thread.h"
 
 namespace sapi {
 namespace {
@@ -67,12 +68,12 @@ TEST(StrErrorTest, MultipleThreads) {
   };
 
   constexpr int kNumThreads = 100;
-  std::vector<std::thread> threads;
+  std::vector<std::unique_ptr<Thread>> threads;
   for (int i = 0; i < kNumThreads; ++i) {
-    threads.push_back(std::thread(thread_fun));
+    threads.push_back(std::make_unique<Thread>(thread_fun));
   }
   for (auto& thread : threads) {
-    thread.join();
+    thread->Join();
   }
 
   EXPECT_THAT(counter, Eq(kNumThreads * kNumCodes));
diff --git a/sandboxed_api/util/thread.h b/sandboxed_api/util/thread.h
new file mode 100644
index 0000000..e7cd81a
--- /dev/null
+++ b/sandboxed_api/util/thread.h
@@ -0,0 +1,71 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SANDBOXED_API_UTIL_THREAD_H_
+#define SANDBOXED_API_UTIL_THREAD_H_
+
+#include <memory>
+#include <utility>
+#include <thread>
+
+#include "absl/functional/any_invocable.h"
+#include "absl/strings/string_view.h"
+
+namespace sapi {
+
+class Thread {
+ public:
+  static void StartDetachedThread(absl::AnyInvocable<void() &&> functor,
+                                  absl::string_view name_prefix = "") {
+    std::thread(std::move(functor)).detach();
+  }
+
+  Thread() = default;
+
+  Thread(const Thread&) = delete;
+  Thread& operator=(const Thread&) = delete;
+
+  Thread(Thread&&) = default;
+  Thread& operator=(Thread&&) = default;
+
+  Thread(absl::AnyInvocable<void() &&> functor,
+         absl::string_view name_prefix = "") {
+    thread_ = std::thread(std::move(functor));
+  }
+
+  template <class CL>
+  Thread(CL* ptr, void (CL::*ptr_to_member)(),
+         absl::string_view name_prefix = "") {
+    thread_ = std::thread(ptr_to_member, ptr);
+  }
+
+  pthread_t handle() {
+    return thread_.native_handle();
+  }
+
+  void Join() {
+    thread_.join();
+  }
+
+  bool IsJoinable() {
+    return thread_.joinable();
+  }
+
+ private:
+  std::thread thread_;
+};
+
+}  // namespace sapi
+
+#endif  // SANDBOXED_API_UTIL_THREAD_H_
diff --git a/sandboxed_api/var_abstract.cc b/sandboxed_api/var_abstract.cc
index 2027d66..bec6d61 100644
--- a/sandboxed_api/var_abstract.cc
+++ b/sandboxed_api/var_abstract.cc
@@ -16,22 +16,36 @@
 
 #include "sandboxed_api/var_abstract.h"
 
-#include <sys/types.h>
-#include <sys/uio.h>
-
+#include <cstddef>
+#include <cstdint>
 #include <memory>
-#include <string>
+#include <utility>
 
 #include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
+#include "absl/types/span.h"
 #include "sandboxed_api/rpcchannel.h"
-#include "sandboxed_api/util/raw_logging.h"
+#include "sandboxed_api/sandbox2/util.h"
 #include "sandboxed_api/util/status_macros.h"
 #include "sandboxed_api/var_ptr.h"
 
 namespace sapi::v {
 
+Var& Var::operator=(Var&& other) {
+  if (this != &other) {
+    using std::swap;
+    swap(local_, other.local_);
+    swap(remote_, other.remote_);
+    swap(free_rpc_channel_, other.free_rpc_channel_);
+    swap(ptr_none_, other.ptr_none_);
+    swap(ptr_both_, other.ptr_both_);
+    swap(ptr_before_, other.ptr_before_);
+    swap(ptr_after_, other.ptr_after_);
+  }
+  return *this;
+}
+
 Var::~Var() {
   if (free_rpc_channel_ && GetRemote()) {
     this->Free(free_rpc_channel_).IgnoreError();
@@ -98,27 +112,18 @@ absl::Status Var::TransferToSandboxee(RPCChannel* rpc_channel, pid_t pid) {
           << ", size: " << GetSize();
 
   if (remote_ == nullptr) {
-    LOG(WARNING) << "Object: " << GetType() << " has no remote object set";
+    LOG(WARNING) << "Object: " << GetTypeString()
+                 << " has no remote object set";
     return absl::FailedPreconditionError(
-        absl::StrCat("Object: ", GetType(), " has no remote object set"));
+        absl::StrCat("Object: ", GetTypeString(), " has no remote object set"));
   }
 
-  struct iovec local = {
-      .iov_base = GetLocal(),
-      .iov_len = GetSize(),
-  };
-  struct iovec remote = {
-      .iov_base = GetRemote(),
-      .iov_len = GetSize(),
-  };
-
-  ssize_t ret = process_vm_writev(pid, &local, 1, &remote, 1, 0);
-  if (ret == -1) {
-    PLOG(WARNING) << "process_vm_writev(pid: " << pid
-                  << " laddr: " << GetLocal() << " raddr: " << GetRemote()
-                  << " size: " << GetSize() << ")";
-    return absl::UnavailableError("process_vm_writev failed");
-  }
+  SAPI_ASSIGN_OR_RETURN(
+      size_t ret,
+      sandbox2::util::WriteBytesToPidFrom(
+          pid, reinterpret_cast<uintptr_t>(GetRemote()),
+          absl::MakeSpan(reinterpret_cast<char*>(GetLocal()), GetSize())));
+
   if (ret != GetSize()) {
     LOG(WARNING) << "process_vm_writev(pid: " << pid << " laddr: " << GetLocal()
                  << " raddr: " << GetRemote() << " size: " << GetSize() << ")"
@@ -136,24 +141,14 @@ absl::Status Var::TransferFromSandboxee(RPCChannel* rpc_channel, pid_t pid) {
 
   if (local_ == nullptr) {
     return absl::FailedPreconditionError(
-        absl::StrCat("Object: ", GetType(), " has no local storage set"));
+        absl::StrCat("Object: ", GetTypeString(), " has no local storage set"));
   }
 
-  struct iovec local = {
-      .iov_base = GetLocal(),
-      .iov_len = GetSize(),
-  };
-  struct iovec remote = {
-      .iov_base = GetRemote(),
-      .iov_len = GetSize(),
-  };
-
-  ssize_t ret = process_vm_readv(pid, &local, 1, &remote, 1, 0);
-  if (ret == -1) {
-    PLOG(WARNING) << "process_vm_readv(pid: " << pid << " laddr: " << GetLocal()
-                  << " raddr: " << GetRemote() << " size: " << GetSize() << ")";
-    return absl::UnavailableError("process_vm_readv failed");
-  }
+  SAPI_ASSIGN_OR_RETURN(
+      size_t ret,
+      sandbox2::util::ReadBytesFromPidInto(
+          pid, reinterpret_cast<uintptr_t>(GetRemote()),
+          absl::MakeSpan(reinterpret_cast<char*>(GetLocal()), GetSize())));
   if (ret != GetSize()) {
     LOG(WARNING) << "process_vm_readv(pid: " << pid << " laddr: " << GetLocal()
                  << " raddr: " << GetRemote() << " size: " << GetSize() << ")"
diff --git a/sandboxed_api/var_abstract.h b/sandboxed_api/var_abstract.h
index 599ee7c..18b5256 100644
--- a/sandboxed_api/var_abstract.h
+++ b/sandboxed_api/var_abstract.h
@@ -19,6 +19,7 @@
 #include <memory>
 #include <string>
 #include <type_traits>
+#include <utility>
 
 #include "absl/base/attributes.h"
 #include "absl/base/macros.h"
@@ -97,6 +98,9 @@ class Var : public Pointable {
  protected:
   Var() = default;
 
+  Var(Var&& other) { *this = std::move(other); }
+  Var& operator=(Var&& other);
+
   // Set pointer to local storage class.
   void SetLocal(void* local) { local_ = local; }
 
diff --git a/sandboxed_api/var_array.h b/sandboxed_api/var_array.h
index f84f01a..cacc76b 100644
--- a/sandboxed_api/var_array.h
+++ b/sandboxed_api/var_array.h
@@ -18,11 +18,9 @@
 #include <algorithm>
 #include <cstdlib>
 #include <cstring>
-#include <memory>
 #include <string>
 #include <type_traits>
 
-#include "absl/base/macros.h"
 #include "absl/log/check.h"
 #include "absl/log/log.h"
 #include "absl/status/status.h"
@@ -31,7 +29,7 @@
 #include "sandboxed_api/rpcchannel.h"
 #include "sandboxed_api/util/status_macros.h"
 #include "sandboxed_api/var_abstract.h"
-#include "sandboxed_api/var_ptr.h"
+#include "sandboxed_api/var_type.h"
 
 namespace sapi::v {
 
@@ -57,6 +55,20 @@ class Array : public Var {
     arr_ = static_cast<T*>(storage);
   }
 
+  Array(Array&& other) { *this = std::move(other); }
+  Array& operator=(Array&& other) {
+    if (this != &other) {
+      Var::operator=(std::move(other));
+      using std::swap;
+      swap(arr_, other.arr_);
+      swap(nelem_, other.nelem_);
+      swap(total_size_, other.total_size_);
+      swap(buffer_owned_, other.buffer_owned_);
+      other.buffer_owned_ = false;  // If it was owned before, we own it now.
+    }
+    return *this;
+  }
+
   virtual ~Array() {
     if (buffer_owned_) {
       free(const_cast<std::remove_const_t<T>*>(arr_));
@@ -132,10 +144,10 @@ class Array : public Var {
   }
 
   // Pointer to the data, owned by the object if buffer_owned_ is 'true'.
-  T* arr_;
-  size_t nelem_;       // Number of elements
-  size_t total_size_;  // Total size in bytes
-  bool buffer_owned_;  // Whether we own the buffer
+  T* arr_ = nullptr;
+  size_t nelem_ = 0;           // Number of elements
+  size_t total_size_ = 0;      // Total size in bytes
+  bool buffer_owned_ = false;  // Whether we own the buffer
 };
 
 // Specialized Array class for representing NUL-terminated C-style strings. The
diff --git a/sandboxed_api/var_lenval.h b/sandboxed_api/var_lenval.h
index 53d1a8f..0572077 100644
--- a/sandboxed_api/var_lenval.h
+++ b/sandboxed_api/var_lenval.h
@@ -18,6 +18,7 @@
 #include <sys/types.h>
 #include <sys/uio.h>
 
+#include <cstdint>
 #include <cstring>
 #include <memory>
 #include <string>
@@ -54,16 +55,22 @@ class LenVal : public Var {
 
   explicit LenVal(size_t size) : array_(size), struct_(size, nullptr) {}
 
+  LenVal(LenVal&& other) = default;
+  LenVal& operator=(LenVal&& other) = default;
+
   Type GetType() const final { return Type::kLenVal; }
   std::string GetTypeString() const final { return "LengthValue"; }
   std::string ToString() const final { return "LenVal"; }
 
   absl::Status ResizeData(RPCChannel* rpc_channel, size_t size);
-  size_t GetDataSize() const { return struct_.data().size; }
+  size_t GetDataSize() const { return array_.GetSize(); }
   uint8_t* GetData() const { return array_.GetData(); }
   void* GetRemote() const final { return struct_.GetRemote(); }
 
  protected:
+  template <class T>
+  friend class Proto;
+
   size_t GetSize() const final { return 0; }
 
   absl::Status Allocate(RPCChannel* rpc_channel, bool automatic_free) override;
@@ -74,9 +81,6 @@ class LenVal : public Var {
 
   Array<uint8_t> array_;
   Struct<LenValStruct> struct_;
-
-  template <class T>
-  friend class Proto;
 };
 
 }  // namespace sapi::v
diff --git a/sandboxed_api/var_proto.h b/sandboxed_api/var_proto.h
index 2f1d8aa..a5246f2 100644
--- a/sandboxed_api/var_proto.h
+++ b/sandboxed_api/var_proto.h
@@ -17,7 +17,6 @@
 #ifndef SANDBOXED_API_VAR_PROTO_H_
 #define SANDBOXED_API_VAR_PROTO_H_
 
-#include <cinttypes>
 #include <cstdint>
 #include <ctime>
 #include <memory>
@@ -27,31 +26,49 @@
 #include <vector>
 
 #include "absl/base/attributes.h"
-#include "absl/base/macros.h"
+#include "absl/log/check.h"
 #include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/utility/utility.h"
-#include "sandboxed_api/proto_helper.h"
+#include "google/protobuf/message_lite.h"
+#include "sandboxed_api/rpcchannel.h"
+#include "sandboxed_api/util/proto_helper.h"
 #include "sandboxed_api/util/status_macros.h"
+#include "sandboxed_api/var_abstract.h"
 #include "sandboxed_api/var_lenval.h"
-#include "sandboxed_api/var_ptr.h"
+#include "sandboxed_api/var_type.h"
 
 namespace sapi::v {
 
 template <typename T>
 class Proto : public Var {
  public:
+  class PrivateToken {
+   private:
+    explicit PrivateToken() = default;
+    friend class Proto;
+  };
+
   static_assert(std::is_base_of<google::protobuf::MessageLite, T>::value,
                 "Template argument must be a proto message");
 
+  Proto() : wrapped_var_(SerializeProto(T{}).value()) {}
+
+  Proto(PrivateToken, std::vector<uint8_t> data)
+      : wrapped_var_(std::move(data)) {}
+
   ABSL_DEPRECATED("Use Proto<>::FromMessage() instead")
   explicit Proto(const T& proto)
       : wrapped_var_(SerializeProto(proto).value()) {}
 
+  Proto(Proto&& other) = default;
+  Proto& operator=(Proto&& other) = default;
+
   static absl::StatusOr<Proto<T>> FromMessage(const T& proto) {
     SAPI_ASSIGN_OR_RETURN(std::vector<uint8_t> len_val, SerializeProto(proto));
-    return absl::StatusOr<Proto<T>>(absl::in_place, proto);
+    return absl::StatusOr<Proto<T>>(absl::in_place, PrivateToken{},
+                                    std::move(len_val));
   }
 
   size_t GetSize() const final { return wrapped_var_.GetSize(); }
@@ -105,10 +122,6 @@ class Proto : public Var {
   }
 
  private:
-  friend class absl::StatusOr<Proto<T>>;
-
-  explicit Proto(std::vector<uint8_t> data) : wrapped_var_(std::move(data)) {}
-
   // The management of reading/writing the data to the sandboxee is handled by
   // the LenVal class.
   LenVal wrapped_var_;
diff --git a/sandboxed_api/var_ptr.h b/sandboxed_api/var_ptr.h
index 2c9894f..774e48e 100644
--- a/sandboxed_api/var_ptr.h
+++ b/sandboxed_api/var_ptr.h
@@ -22,6 +22,7 @@
 
 #include "absl/base/attributes.h"
 #include "absl/base/macros.h"
+#include "absl/log/log.h"
 #include "absl/strings/str_format.h"
 #include "sandboxed_api/var_abstract.h"
 #include "sandboxed_api/var_reg.h"
@@ -98,6 +99,10 @@ class RemotePtr : public Ptr {
     pointed_obj_.SetRemote(remote_addr);
   }
 
+  void SetRemote(void* /* remote */) override {
+    LOG(FATAL) << "SetRemote not supported on RemotePtr";
+  }
+
  private:
   Reg<void*> pointed_obj_;
 };
diff --git a/sandboxed_api/var_reg.h b/sandboxed_api/var_reg.h
index eff6ee8..1907563 100644
--- a/sandboxed_api/var_reg.h
+++ b/sandboxed_api/var_reg.h
@@ -17,16 +17,16 @@
 
 #include <algorithm>
 #include <cstring>
-#include <iostream>
 #include <string>
 #include <type_traits>
 
 #include "absl/strings/str_format.h"
 #include "sandboxed_api/var_abstract.h"
+#include "sandboxed_api/var_type.h"
 
 namespace sapi::v {
 
-// The super-class for Reg. Specified as a class, so it can be used as a
+// The superclass for Reg. Specified as a class, so it can be used as a
 // type specifier in methods.
 class Callable : public Var {
  public:
@@ -46,7 +46,7 @@ class Callable : public Var {
   Callable() = default;
 };
 
-// class Reg represents register-sized variables.
+// Class Reg represents register-sized variables.
 template <typename T>
 class Reg : public Callable {
  public:
@@ -126,7 +126,7 @@ std::string Reg<T>::ToString() const {
   if constexpr (std::is_pointer<T>::value) {
     return absl::StrFormat("%p", value_);
   }
-  // Not reached.
+  // Not reached
 }
 
 }  // namespace sapi::v
diff --git a/sandboxed_api/var_struct.h b/sandboxed_api/var_struct.h
index ec55006..b735e18 100644
--- a/sandboxed_api/var_struct.h
+++ b/sandboxed_api/var_struct.h
@@ -16,13 +16,12 @@
 #define SANDBOXED_API_VAR_STRUCT_H_
 
 #include <cstddef>
-#include <memory>
 #include <string>
 #include <utility>
 
-#include "absl/base/macros.h"
 #include "absl/strings/str_cat.h"
-#include "sandboxed_api/var_ptr.h"
+#include "sandboxed_api/var_abstract.h"
+#include "sandboxed_api/var_type.h"
 
 namespace sapi::v {
 
@@ -30,12 +29,15 @@ namespace sapi::v {
 template <class T>
 class Struct : public Var {
  public:
-  // Forwarding constructor to initalize the struct_ field.
+  // Forwarding constructor to initialize the struct_ field.
   template <typename... Args>
   explicit Struct(Args&&... args) : struct_(std::forward<Args>(args)...) {
     SetLocal(&struct_);
   }
 
+  Struct(Struct&& other) = default;
+  Struct& operator=(Struct&& other) = default;
+
   size_t GetSize() const final { return sizeof(T); }
   Type GetType() const final { return Type::kStruct; }
   std::string GetTypeString() const final { return "Structure"; }
```

