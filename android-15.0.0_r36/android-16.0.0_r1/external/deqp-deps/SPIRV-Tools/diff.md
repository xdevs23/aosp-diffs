```diff
diff --git a/.bazelrc b/.bazelrc
index ff6db819..79ad5948 100644
--- a/.bazelrc
+++ b/.bazelrc
@@ -1,3 +1,6 @@
+# Enable Bzlmod for every Bazel command
+common --enable_bzlmod
+
 build --enable_platform_specific_config
 build:linux --cxxopt=-std=c++17
 build:macos --cxxopt=-std=c++17
diff --git a/.bazelversion b/.bazelversion
index 0062ac97..a8907c02 100644
--- a/.bazelversion
+++ b/.bazelversion
@@ -1 +1 @@
-5.0.0
+7.0.2
diff --git a/.github/workflows/autoroll.yml b/.github/workflows/autoroll.yml
index 8e8c3a42..eb0b0fea 100644
--- a/.github/workflows/autoroll.yml
+++ b/.github/workflows/autoroll.yml
@@ -16,7 +16,7 @@ jobs:
     runs-on: ubuntu-latest
 
     steps:
-      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
 
       # Checkout the depot tools they are needed by roll_deps.sh
       - name: Checkout depot tools
diff --git a/.github/workflows/bazel.yml b/.github/workflows/bazel.yml
index bd90e82e..38dd1b34 100644
--- a/.github/workflows/bazel.yml
+++ b/.github/workflows/bazel.yml
@@ -13,18 +13,41 @@ jobs:
     timeout-minutes: 120
     strategy:
       matrix:
-        os: [ubuntu-latest, macos-latest, windows-2019]
+        os: [ubuntu-latest, windows-2019]
 
     runs-on: ${{matrix.os}}
 
     steps:
-      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
         with:
           fetch-depth: '0'
       - name: Download dependencies
         run: python3 utils/git-sync-deps
       - name: Mount Bazel cache
-        uses: actions/cache@13aacd865c20de90d75de3b17ebe84f7a17d57d2 # v4.0.0
+        uses: actions/cache@6849a6489940f00c2f30c0fb92c6274307ccb58a # v4.1.2
+        with:
+          path: ~/.bazel/cache
+          key: bazel-cache-${{ runner.os }}
+      - name: Build All
+        run: bazel --output_user_root=~/.bazel/cache build //...
+      - name: Test All
+        run: bazel --output_user_root=~/.bazel/cache test //...
+
+  # iOS is 10x expensive to run on GitHub machines, so only run if we know something else passed
+  # The steps are unfortunately duplicated because github actions requires 2 jobs for a dependency
+  build-macos:
+    needs: build
+    timeout-minutes: 120
+    runs-on: macos-latest
+
+    steps:
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
+        with:
+          fetch-depth: '0'
+      - name: Download dependencies
+        run: python3 utils/git-sync-deps
+      - name: Mount Bazel cache
+        uses: actions/cache@6849a6489940f00c2f30c0fb92c6274307ccb58a # v4.1.2
         with:
           path: ~/.bazel/cache
           key: bazel-cache-${{ runner.os }}
diff --git a/.github/workflows/ios.yml b/.github/workflows/ios.yml
index 70a0729e..b856e722 100644
--- a/.github/workflows/ios.yml
+++ b/.github/workflows/ios.yml
@@ -2,17 +2,20 @@ name: iOS
 permissions:
   contents: read
 
-on: [push, pull_request, workflow_dispatch]
+on:
+  workflow_run:
+    # iOS is 10x expensive to run on GitHub machines, so only run if we know something else passed
+    workflows: ["Wasm Build"]
+    types:
+      - completed
 
 jobs:
   build:
-    runs-on: ${{ matrix.os }}
-    strategy:
-        matrix:
-          os: [ macos-12, macos-13 ]
+    runs-on: macos-latest
+    if: ${{ github.event.workflow_run.conclusion == 'success' }}
     steps:
-        - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
-        - uses: lukka/get-cmake@139aae96315b496d9af1b5e9abe53b15ca7eece8 # v3.28.3
+        - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
+        - uses: lukka/get-cmake@71b7adfe2603f48bb9ed50d2b01a72499ae94885 # v3.31.0
         - name: Download dependencies
           run: python3 utils/git-sync-deps
         # NOTE: The MacOS SDK ships universal binaries. CI should reflect this.
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index f3b3de91..1e0d865a 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -13,7 +13,7 @@ jobs:
   prepare-release-job:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       - name: Prepare CHANGELOG for version
         run: |
           python utils/generate_changelog.py CHANGES "${{ github.ref_name }}" VERSION_CHANGELOG
diff --git a/.github/workflows/scorecard.yml b/.github/workflows/scorecard.yml
index f952197a..8a2c9ecb 100644
--- a/.github/workflows/scorecard.yml
+++ b/.github/workflows/scorecard.yml
@@ -23,12 +23,12 @@ jobs:
 
     steps:
       - name: "Checkout code"
-        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
         with:
           persist-credentials: false
 
       - name: "Run analysis"
-        uses: ossf/scorecard-action@0864cf19026789058feabb7e87baa5f140aac736 # v2.3.1
+        uses: ossf/scorecard-action@62b2cac7ed8198b15735ed49ab1e5cf35480ba46 # v2.4.0
         with:
           results_file: results.sarif
           results_format: sarif
@@ -40,7 +40,7 @@ jobs:
       # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF
       # format to the repository Actions tab.
       - name: "Upload artifact"
-        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
+        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.4.3
         with:
           name: SARIF file
           path: results.sarif
@@ -48,6 +48,6 @@ jobs:
 
       # Upload the results to GitHub's code scanning dashboard.
       - name: "Upload to code-scanning"
-        uses: github/codeql-action/upload-sarif@e8893c57a1f3a2b659b6b55564fdfdbbd2982911 # v3.24.0
+        uses: github/codeql-action/upload-sarif@f09c1c0a94de965c15400f5634aa42fac8fb8f88 # v3.27.5
         with:
           sarif_file: results.sarif
diff --git a/.github/workflows/wasm.yml b/.github/workflows/wasm.yml
index 552e56a9..cbe21435 100644
--- a/.github/workflows/wasm.yml
+++ b/.github/workflows/wasm.yml
@@ -9,10 +9,10 @@ jobs:
     runs-on: ubuntu-latest
 
     steps:
-      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
         with:
           fetch-depth: '0'
       - name: Build web
-        run: docker-compose -f source/wasm/docker-compose.yml --project-directory . up
+        run: docker compose -f source/wasm/docker-compose.yml --project-directory . up
       - name: Run tests
         run: node test/wasm/test.js
diff --git a/.gitignore b/.gitignore
index d9c6a1a4..e85cea95 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,6 +23,7 @@ bazel-out
 bazel-spirv-tools
 bazel-SPIRV-Tools
 bazel-testlogs
+MODULE.bazel.lock
 
 # Vim
 [._]*.s[a-w][a-z]
diff --git a/Android.bp b/Android.bp
index b9c2a8bb..f87f43c1 100644
--- a/Android.bp
+++ b/Android.bp
@@ -39,6 +39,7 @@ genrule {
         "extension_enum.inc",
         "glsl.std.450.insts.inc",
         "nonsemantic.clspvreflection.insts.inc",
+        "nonsemantic.vkspreflection.insts.inc",
         "nonsemantic.shader.debuginfo.100.insts.inc",
         "opencl.debuginfo.100.insts.inc",
         "opencl.std.insts.inc",
@@ -52,6 +53,7 @@ genrule {
         ":deqp_spirv_headers_unified1_extinst.debuginfo.grammar.json",
         ":deqp_spirv_headers_unified1_extinst.glsl.std.450.grammar.json",
         ":deqp_spirv_headers_unified1_extinst.nonsemantic.clspvreflection.grammar.json",
+        ":deqp_spirv_headers_unified1_extinst.nonsemantic.vkspreflection.grammar.json",
         ":deqp_spirv_headers_unified1_extinst.nonsemantic.shader.debuginfo.100.grammar.json",
         ":deqp_spirv_headers_unified1_extinst.opencl.debuginfo.100.grammar.json",
         ":deqp_spirv_headers_unified1_extinst.opencl.std.100.grammar.json",
@@ -67,6 +69,7 @@ genrule {
         "$(location) --output-language=c++ --extinst-opencl-grammar=$(location :deqp_spirv_headers_unified1_extinst.opencl.std.100.grammar.json) --opencl-insts-output=$(location opencl.std.insts.inc); "+
         "$(location) --output-language=c++ --extinst-vendor-grammar=$(location :deqp_spirv_headers_unified1_extinst.debuginfo.grammar.json) --vendor-insts-output=$(location debuginfo.insts.inc) --vendor-operand-kind-prefix=; "+
         "$(location) --output-language=c++ --extinst-vendor-grammar=$(location :deqp_spirv_headers_unified1_extinst.nonsemantic.clspvreflection.grammar.json) --vendor-insts-output=$(location nonsemantic.clspvreflection.insts.inc) --vendor-operand-kind-prefix=; "+
+        "$(location) --output-language=c++ --extinst-vendor-grammar=$(location :deqp_spirv_headers_unified1_extinst.nonsemantic.vkspreflection.grammar.json) --vendor-insts-output=$(location nonsemantic.vkspreflection.insts.inc) --vendor-operand-kind-prefix=; "+
         "$(location) --output-language=c++ --extinst-vendor-grammar=$(location :deqp_spirv_headers_unified1_extinst.nonsemantic.shader.debuginfo.100.grammar.json) --vendor-insts-output=$(location nonsemantic.shader.debuginfo.100.insts.inc) --vendor-operand-kind-prefix=SHDEBUG100_; "+
         "$(location) --output-language=c++ --extinst-vendor-grammar=$(location :deqp_spirv_headers_unified1_extinst.opencl.debuginfo.100.grammar.json) --vendor-insts-output=$(location opencl.debuginfo.100.insts.inc) --vendor-operand-kind-prefix=CLDEBUG100_; "+
         "$(location) --output-language=c++ --extinst-vendor-grammar=$(location :deqp_spirv_headers_unified1_extinst.spv-amd-gcn-shader.grammar.json) --vendor-insts-output=$(location spv-amd-gcn-shader.insts.inc) --vendor-operand-kind-prefix=; "+
diff --git a/BUILD.bazel b/BUILD.bazel
index b83fd5ae..526d08e3 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -58,6 +58,8 @@ generate_vendor_tables(extension = "debuginfo")
 
 generate_vendor_tables(extension = "nonsemantic.clspvreflection")
 
+generate_vendor_tables(extension = "nonsemantic.vkspreflection")
+
 generate_vendor_tables(
     extension = "opencl.debuginfo.100",
     operand_kind_prefix = "CLDEBUG100_",
@@ -108,7 +110,6 @@ genrule(
     outs = ["build-version.inc"],
     cmd = "SOURCE_DATE_EPOCH=0 $(location :update_build_version) $(location CHANGES) $(location build-version.inc)",
     cmd_bat = "set SOURCE_DATE_EPOCH=0  && $(location :update_build_version) $(location CHANGES) $(location build-version.inc)",
-    local = True,
     tools = [":update_build_version"],
 )
 
@@ -146,6 +147,7 @@ cc_library(
         ":gen_opencl_tables_unified1",
         ":gen_vendor_tables_debuginfo",
         ":gen_vendor_tables_nonsemantic_clspvreflection",
+        ":gen_vendor_tables_nonsemantic_vkspreflection",
         ":gen_vendor_tables_nonsemantic_shader_debuginfo_100",
         ":gen_vendor_tables_opencl_debuginfo_100",
         ":gen_vendor_tables_spv_amd_gcn_shader",
@@ -176,7 +178,6 @@ cc_library(
 cc_library(
     name = "spirv_tools_opt",
     hdrs = [
-        "include/spirv-tools/instrument.hpp",
         "include/spirv-tools/optimizer.hpp",
     ],
     copts = COMMON_COPTS,
@@ -194,7 +195,6 @@ cc_library(
         ":gen_vendor_tables_spv_amd_shader_ballot",
     ],
     hdrs = glob(["source/opt/*.h"]) + [
-        "include/spirv-tools/instrument.hpp",
         "include/spirv-tools/optimizer.hpp",
     ],
     copts = COMMON_COPTS,
@@ -269,6 +269,7 @@ cc_library(
 cc_library(
     name = "tools_io",
     hdrs = ["tools/io.h"],
+    srcs = ["tools/io.cpp"],
     copts = COMMON_COPTS,
 )
 
@@ -426,7 +427,7 @@ cc_library(
     copts = TEST_COPTS,
     deps = [
         ":spirv_tools_internal",
-        "@com_google_googletest//:gtest",
+        "@googletest//:gtest",
     ],
 )
 
@@ -446,8 +447,9 @@ cc_library(
         "tools_util",
         ":spirv_tools_internal",
         ":test_lib",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        ":tools_io",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(
     [
@@ -467,8 +469,8 @@ cc_test(
     linkstatic = 1,
     deps = [
         ":spirv_tools_opt_internal",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
         "@spirv_headers//:spirv_cpp11_headers",
     ],
 )
@@ -481,8 +483,8 @@ cc_test(
     linkstatic = 1,
     deps = [
         ":spirv_tools_internal",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 )
 
@@ -495,8 +497,8 @@ cc_library(
         ":spirv_tools_internal",
         ":spirv_tools_link",
         ":test_lib",
-        "@com_google_effcee//:effcee",
-        "@com_googlesource_code_re2//:re2",
+        "@effcee//:effcee",
+        "@re2//:re2",
     ],
 )
 
@@ -508,8 +510,8 @@ cc_library(
     linkstatic = 1,
     deps = [
         ":link_test_lib",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(
     ["test/link/*_test.cpp"],
@@ -525,8 +527,8 @@ cc_library(
         ":spirv_tools",
         ":spirv_tools_lint_internal",
         ":spirv_tools_opt_internal",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(
     ["test/lint/*_test.cpp"],
@@ -549,8 +551,8 @@ cc_library(
     deps = [
         ":spirv_tools_internal",
         ":spirv_tools_opt_internal",
-        "@com_google_effcee//:effcee",
-        "@com_google_googletest//:gtest",
+        "@effcee//:effcee",
+        "@googletest//:gtest",
     ],
 )
 
@@ -565,9 +567,9 @@ cc_library(
         ":spirv_tools_internal",
         ":spirv_tools_opt_internal",
         ":test_lib",
-        "@com_google_effcee//:effcee",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@effcee//:effcee",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(["test/opt/*_test.cpp"])]
 
@@ -580,8 +582,8 @@ cc_library(
     deps = [
         ":opt_test_lib",
         ":spirv_tools_opt_internal",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(
     ["test/opt/dominator_tree/*.cpp"],
@@ -598,9 +600,9 @@ cc_library(
         ":opt_test_lib",
         ":spirv_tools",
         ":spirv_tools_opt_internal",
-        "@com_google_effcee//:effcee",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@effcee//:effcee",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(
     ["test/opt/loop_optimizations/*.cpp"],
@@ -621,7 +623,7 @@ cc_library(
         ":spirv_tools_reduce",
         ":test_lib",
         ":tools_io",
-        "@com_google_googletest//:gtest",
+        "@googletest//:gtest",
     ],
 )
 
@@ -636,7 +638,7 @@ cc_library(
         ":spirv_tools_internal",
         ":spirv_tools_opt_internal",
         ":spirv_tools_reduce",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(["test/reduce/*_test.cpp"])]
 
@@ -648,8 +650,8 @@ cc_library(
     linkstatic = 1,
     deps = [
         ":spirv_tools_internal",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(["test/util/*_test.cpp"])]
 
@@ -680,8 +682,8 @@ cc_library(
         ":spirv_tools_internal",
         ":test_lib",
         ":val_test_lib",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 ) for f in glob(
     ["test/val/val_*_test.cpp"],
@@ -702,8 +704,8 @@ cc_test(
         ":spirv_tools_internal",
         ":test_lib",
         ":val_test_lib",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 )
 
@@ -719,7 +721,7 @@ cc_test(
     deps = [
         ":test_lib",
         ":val_test_lib",
-        "@com_google_googletest//:gtest",
-        "@com_google_googletest//:gtest_main",
+        "@googletest//:gtest",
+        "@googletest//:gtest_main",
     ],
 )
diff --git a/BUILD.gn b/BUILD.gn
index 7c42a99a..7c361f03 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -327,6 +327,10 @@ spvtools_vendor_tables = [
     "nonsemantic.clspvreflection",
     "...nil...",
   ],
+  [
+    "nonsemantic.vkspreflection",
+    "...nil...",
+  ],
   [
     "nonsemantic.shader.debuginfo.100",
     "SHDEBUG100_",
@@ -384,7 +388,6 @@ config("spvtools_internal_config") {
 
 source_set("spvtools_headers") {
   sources = [
-    "include/spirv-tools/instrument.hpp",
     "include/spirv-tools/libspirv.h",
     "include/spirv-tools/libspirv.hpp",
     "include/spirv-tools/linker.hpp",
@@ -471,6 +474,8 @@ static_library("spvtools") {
     "source/text.h",
     "source/text_handler.cpp",
     "source/text_handler.h",
+    "source/to_string.cpp",
+    "source/to_string.h",
     "source/util/bit_vector.cpp",
     "source/util/bit_vector.h",
     "source/util/bitutils.h",
@@ -552,6 +557,7 @@ static_library("spvtools_val") {
     "source/val/validate_scopes.cpp",
     "source/val/validate_scopes.h",
     "source/val/validate_small_type_uses.cpp",
+    "source/val/validate_tensor_layout.cpp",
     "source/val/validate_type.cpp",
     "source/val/validation_state.cpp",
     "source/val/validation_state.h",
@@ -677,18 +683,10 @@ static_library("spvtools_opt") {
     "source/opt/inline_opaque_pass.h",
     "source/opt/inline_pass.cpp",
     "source/opt/inline_pass.h",
-    "source/opt/inst_bindless_check_pass.cpp",
-    "source/opt/inst_bindless_check_pass.h",
-    "source/opt/inst_buff_addr_check_pass.cpp",
-    "source/opt/inst_buff_addr_check_pass.h",
-    "source/opt/inst_debug_printf_pass.cpp",
-    "source/opt/inst_debug_printf_pass.h",
     "source/opt/instruction.cpp",
     "source/opt/instruction.h",
     "source/opt/instruction_list.cpp",
     "source/opt/instruction_list.h",
-    "source/opt/instrument_pass.cpp",
-    "source/opt/instrument_pass.h",
     "source/opt/interface_var_sroa.cpp",
     "source/opt/interface_var_sroa.h",
     "source/opt/interp_fixup_pass.cpp",
@@ -742,6 +740,8 @@ static_library("spvtools_opt") {
     "source/opt/module.cpp",
     "source/opt/module.h",
     "source/opt/null_pass.h",
+    "source/opt/opextinst_forward_ref_fixup_pass.cpp",
+    "source/opt/opextinst_forward_ref_fixup_pass.h",
     "source/opt/optimizer.cpp",
     "source/opt/pass.cpp",
     "source/opt/pass.h",
@@ -791,6 +791,8 @@ static_library("spvtools_opt") {
     "source/opt/strip_debug_info_pass.h",
     "source/opt/strip_nonsemantic_info_pass.cpp",
     "source/opt/strip_nonsemantic_info_pass.h",
+    "source/opt/struct_packing_pass.cpp",
+    "source/opt/struct_packing_pass.h",
     "source/opt/struct_cfg_analysis.cpp",
     "source/opt/struct_cfg_analysis.h",
     "source/opt/switch_descriptorset_pass.cpp",
@@ -1375,6 +1377,7 @@ if (build_with_chromium && spvtools_build_executables) {
       "test/fix_word_test.cpp",
       "test/generator_magic_number_test.cpp",
       "test/hex_float_test.cpp",
+      "test/hex_to_text_test.cpp",
       "test/immediate_int_test.cpp",
       "test/libspirv_macros_test.cpp",
       "test/name_mapper_test.cpp",
@@ -1412,6 +1415,7 @@ if (build_with_chromium && spvtools_build_executables) {
       "test/text_to_binary.type_declaration_test.cpp",
       "test/text_to_binary_test.cpp",
       "test/text_word_get_test.cpp",
+      "test/to_string_test.cpp",
       "test/unit_spirv.cpp",
       "test/unit_spirv.h",
     ]
@@ -1421,6 +1425,7 @@ if (build_with_chromium && spvtools_build_executables) {
       ":spvtools_language_header_cldebuginfo100",
       ":spvtools_language_header_debuginfo",
       ":spvtools_language_header_vkdebuginfo100",
+      ":spvtools_tools_io",
       ":spvtools_val",
       "//testing/gmock",
       "//testing/gtest",
@@ -1463,6 +1468,15 @@ source_set("spvtools_tools_util") {
   configs += [ ":spvtools_internal_config" ]
 }
 
+source_set("spvtools_tools_io") {
+  sources = [
+    "tools/io.cpp",
+    "tools/io.h",
+  ]
+  deps = [ ":spvtools_headers" ]
+  configs += [ ":spvtools_internal_config" ]
+}
+
 if (spvtools_build_executables) {
   executable("spirv-as") {
     sources = [ "tools/as/as.cpp" ]
@@ -1470,6 +1484,7 @@ if (spvtools_build_executables) {
       ":spvtools",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
     ]
     configs += [ ":spvtools_internal_config" ]
   }
@@ -1480,6 +1495,7 @@ if (spvtools_build_executables) {
       ":spvtools",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
     ]
     configs += [ ":spvtools_internal_config" ]
   }
@@ -1490,6 +1506,7 @@ if (spvtools_build_executables) {
       ":spvtools",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
       ":spvtools_val",
     ]
     configs += [ ":spvtools_internal_config" ]
@@ -1505,6 +1522,7 @@ if (spvtools_build_executables) {
       ":spvtools",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
     ]
     configs += [ ":spvtools_internal_config" ]
   }
@@ -1516,6 +1534,7 @@ if (spvtools_build_executables) {
       ":spvtools_opt",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
       ":spvtools_val",
     ]
     configs += [ ":spvtools_internal_config" ]
@@ -1529,6 +1548,7 @@ if (spvtools_build_executables) {
       ":spvtools_opt",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
       ":spvtools_val",
     ]
     configs += [ ":spvtools_internal_config" ]
@@ -1549,6 +1569,7 @@ if (!is_ios && !spirv_is_winuwp && build_with_chromium && spvtools_build_executa
       ":spvtools_reduce",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
       ":spvtools_val",
       "//third_party/protobuf:protobuf_full",
     ]
@@ -1568,6 +1589,7 @@ if (!is_ios && !spirv_is_winuwp && spvtools_build_executables) {
       ":spvtools_reduce",
       ":spvtools_software_version",
       ":spvtools_tools_util",
+      ":spvtools_tools_io",
       ":spvtools_val",
     ]
     configs += [ ":spvtools_internal_config" ]
diff --git a/CHANGES b/CHANGES
index 48aa8766..c671ceb0 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,5 +1,80 @@
 Revision history for SPIRV-Tools
 
+v2024.4 2024-09-19
+  - General
+    - Add FPEncoding operand type. (#5726)
+    - Support SPV_KHR_untyped_pointers (#5736)
+    - add support for SPV_INTEL_global_variable_host_access (#5786)
+  - Optimizer
+    - Add knowledge of cooperative matrices (#5720)
+    - Add struct-packing pass and unit test. (#5778)
+  - Validator
+    - Validate presence of Stride operand to OpCooperativeMatrix{Load,Store}KHR (#5777)
+    - Update sampled image validation (#5789)
+  - Linker
+    - allow linking functions with different pointer arguments (#5534)
+
+v2024.3 2024-06-20
+  - General
+  - Optimizer
+    - Do not fold mul and adds to generate fmas (#5682)
+    - add OpExtInst forward ref fixup pass (#5708)
+  - Validator
+    - Separate Location check for tess patch (#5654)
+    - Validate MemoryAccessMask of OpCooperativeMatrixStoreKHR (#5668)
+    - OpSampledImage extra validation (#5695)
+    - add support for OpExtInstWithForwardRefs (#5698)A
+  - Disassembler
+    - add decorations to comments (#5675)
+    - Add --nested-indent and --reorder-blocks (#5671)
+
+v2024.2 2024-04-22
+  - General
+    - Add SPIRV_TOOLS_EXPORT to public C++ API (#5591)
+    - Use bazel 7 and bzlmod (#5601)
+  - Optimizer
+    - opt: add GroupNonUniformPartitionedNV capability to trim pass (#5648)
+    - Fix rebuilding types with circular references. (#5637)
+    - Add AliasedPointer decoration (#5635)
+    - add support for vulkan-shader-profiler external passes (#5512)
+  - Validator
+    - A fix to support of SPV_QCOM_image_processing2 (#5646)
+    - spirv-val: Add Vulkan check for Rect Dim in OpTypeImage (#5644)
+    - Validate duplicate decorations and execution modes (#5641)
+    - Validator: Support SPV_NV_raw_access_chains (#5568)
+
+v2024.1 2024-03-06
+  - General
+    - Add tooling support for SPV_KHR_maximal_reconvergence (#5542)
+    - Add support for SPV_KHR_float_controls2 (#5543)
+    - SPV_KHR_quad_control (#5547)
+    - Fold 64-bit int operations (#5561)
+    - update image enum tests to remove Kernel capability (#5562)
+    - Support operand kind for SPV_INTEL_maximum_registers (#5580)
+    - SPV_NV_shader_atomic_fp16_vector (#5581)
+    - Support for SPV_QCOM_image_processing2 (#5582)
+    - Fix access chain struct checks (#5592)
+  - Optimizer
+    - opt: add Int16 and Float16 to capability trim pass (#5519)
+    - Add preserver-interface option to spirv-opt (#5524)
+    - spirv-opt: Fix OpCompositeExtract relaxation with struct operands (#5536)
+    - opt: Add VulkanMemoryModelDeviceScope to trim (#5544)
+    - opt: Add TrimCapabilities pass to spirv-opt tool (#5545)
+    - Add modify-maximal-reconvergence to spirv-opt help (#5546)
+    - opt: add SPV_EXT_mesh_shader to opt allowlist (#5551)
+    - opt: Add OpEntryPoint to DescriptorScalarReplacement pass (#5553)
+    - opt: prevent meld to merge block with MaximalReconvergence (#5557)
+    - [OPT] Use new instruction folder for for all opcodes in spec consti folding (#5569)
+    - [OPT] Identify arrays with unknown length in copy prop arrays (#5570)
+    - [OPT] Add removed unused interface var pass to legalization passes (#5579)
+  - Validator
+    - spirv-val: Re-enable OpControlBarrier VU (#5527)
+    - spirv-val: Add Mesh Primitive Built-In validaiton (#5529)
+    - spirv-val: Validate PhysicalStorageBuffer Stage Interface (#5539)
+    - spirv-val: Multiple interface var with same SC (#5528)
+    - spirv-val: Revert Validate PhysicalStorageBuffer Stage Interface (#5575)
+    - spirv-val: Make Constant evaluation consistent (#5587)
+
 v2023.6 2023-12-18
   - General
     - update_build_version.py produce deterministic header. (#5426)
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 07be2dfc..e50fb56c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -49,37 +49,13 @@ option(ENABLE_RTTI "Enables RTTI" OFF)
 option(SPIRV_ALLOW_TIMERS "Allow timers via clock_gettime on supported platforms" ON)
 
 if("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux")
-  add_definitions(-DSPIRV_LINUX)
   set(SPIRV_TIMER_ENABLED ${SPIRV_ALLOW_TIMERS})
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "Emscripten")
-    add_definitions(-DSPIRV_EMSCRIPTEN)
 elseif("${CMAKE_SYSTEM_NAME}" MATCHES "Windows")
   add_definitions(-DSPIRV_WINDOWS)
 elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "CYGWIN")
   add_definitions(-DSPIRV_WINDOWS)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "Darwin")
-  add_definitions(-DSPIRV_MAC)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "iOS")
-  add_definitions(-DSPIRV_IOS)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "tvOS")
-  add_definitions(-DSPIRV_TVOS)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "visionOS")
-  add_definitions(-DSPIRV_VISIONOS)
 elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "Android")
-  add_definitions(-DSPIRV_ANDROID)
   set(SPIRV_TIMER_ENABLED ${SPIRV_ALLOW_TIMERS})
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "FreeBSD")
-  add_definitions(-DSPIRV_FREEBSD)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "OpenBSD")
-  add_definitions(-DSPIRV_OPENBSD)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "Fuchsia")
-  add_definitions(-DSPIRV_FUCHSIA)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "GNU")
-  add_definitions(-DSPIRV_GNU)
-elseif("${CMAKE_SYSTEM_NAME}" STREQUAL "QNX")
-  add_definitions(-DSPIRV_QNX)
-else()
-  message(FATAL_ERROR "Your platform '${CMAKE_SYSTEM_NAME}' is not supported!")
 endif()
 
 if (${SPIRV_TIMER_ENABLED})
@@ -371,7 +347,6 @@ if(ENABLE_SPIRV_TOOLS_INSTALL)
       ${CMAKE_CURRENT_SOURCE_DIR}/include/spirv-tools/libspirv.hpp
       ${CMAKE_CURRENT_SOURCE_DIR}/include/spirv-tools/optimizer.hpp
       ${CMAKE_CURRENT_SOURCE_DIR}/include/spirv-tools/linker.hpp
-      ${CMAKE_CURRENT_SOURCE_DIR}/include/spirv-tools/instrument.hpp
     DESTINATION
       ${CMAKE_INSTALL_INCLUDEDIR}/spirv-tools/)
 endif(ENABLE_SPIRV_TOOLS_INSTALL)
@@ -387,7 +362,8 @@ set(SPIRV_SHARED_LIBRARIES "-lSPIRV-Tools-shared")
 
 # Build pkg-config file
 # Use a first-class target so it's regenerated when relevant files are updated.
-add_custom_target(spirv-tools-pkg-config ALL
+add_custom_command(
+        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/SPIRV-Tools.pc
         COMMAND ${CMAKE_COMMAND}
                       -DCHANGES_FILE=${CMAKE_CURRENT_SOURCE_DIR}/CHANGES
                       -DTEMPLATE_FILE=${CMAKE_CURRENT_SOURCE_DIR}/cmake/SPIRV-Tools.pc.in
@@ -397,8 +373,9 @@ add_custom_target(spirv-tools-pkg-config ALL
                       -DCMAKE_INSTALL_INCLUDEDIR=${CMAKE_INSTALL_INCLUDEDIR}
                       -DSPIRV_LIBRARIES=${SPIRV_LIBRARIES}
                       -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/write_pkg_config.cmake
-        DEPENDS "CHANGES" "cmake/SPIRV-Tools.pc.in" "cmake/write_pkg_config.cmake")
-add_custom_target(spirv-tools-shared-pkg-config ALL
+        DEPENDS "CHANGES" "${CMAKE_CURRENT_SOURCE_DIR}/cmake/SPIRV-Tools.pc.in" "${CMAKE_CURRENT_SOURCE_DIR}/cmake/write_pkg_config.cmake")
+add_custom_command(
+        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/SPIRV-Tools-shared.pc
         COMMAND ${CMAKE_COMMAND}
                       -DCHANGES_FILE=${CMAKE_CURRENT_SOURCE_DIR}/CHANGES
                       -DTEMPLATE_FILE=${CMAKE_CURRENT_SOURCE_DIR}/cmake/SPIRV-Tools-shared.pc.in
@@ -408,7 +385,10 @@ add_custom_target(spirv-tools-shared-pkg-config ALL
                       -DCMAKE_INSTALL_INCLUDEDIR=${CMAKE_INSTALL_INCLUDEDIR}
                       -DSPIRV_SHARED_LIBRARIES=${SPIRV_SHARED_LIBRARIES}
                       -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/write_pkg_config.cmake
-        DEPENDS "CHANGES" "cmake/SPIRV-Tools-shared.pc.in" "cmake/write_pkg_config.cmake")
+        DEPENDS "CHANGES" "${CMAKE_CURRENT_SOURCE_DIR}/cmake/SPIRV-Tools-shared.pc.in" "${CMAKE_CURRENT_SOURCE_DIR}/cmake/write_pkg_config.cmake")
+add_custom_target(spirv-tools-pkg-config 
+        ALL 
+        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/SPIRV-Tools-shared.pc ${CMAKE_CURRENT_BINARY_DIR}/SPIRV-Tools.pc)
 
 # Install pkg-config file
 if (ENABLE_SPIRV_TOOLS_INSTALL)
diff --git a/DEPS b/DEPS
index 50fd6c19..ea86b4cf 100644
--- a/DEPS
+++ b/DEPS
@@ -3,17 +3,18 @@ use_relative_paths = True
 vars = {
   'github': 'https://github.com',
 
-  'abseil_revision': '79ca5d7aad63973c83a4962a66ab07cd623131ea',
+  'abseil_revision': 'c7cf999bda8390d2dd294ef903716a80135e6f4c',
 
-  'effcee_revision': '19b4aa87af25cb4ee779a071409732f34bfc305c',
+  'effcee_revision': '2c97e5689ed8d7ab6ae5820f884f03a601ae124b',
 
-  'googletest_revision': 'b75ecf1bed2fcd416b66c86cb6fe79122abf132e',
+  'googletest_revision': '35d0c365609296fa4730d62057c487e3cfa030ff',
 
   # Use protobufs before they gained the dependency on abseil
   'protobuf_revision': 'v21.12',
 
-  're2_revision': 'ab7c5918b418428ed17dbe564e0d8402bd7d743d',
-  'spirv_headers_revision': 'd3c2a6fa95ad463ca8044d7fc45557db381a6a64',
+  're2_revision': '6dcd83d60f7944926bfd308cc13979fc53dd69ca',
+
+  'spirv_headers_revision': '36d5e2ddaa54c70d2f29081510c66f4fc98e5e53',
 }
 
 deps = {
diff --git a/MODULE.bazel b/MODULE.bazel
new file mode 100644
index 00000000..2e28e9ef
--- /dev/null
+++ b/MODULE.bazel
@@ -0,0 +1,33 @@
+bazel_dep(name = "bazel_skylib", version = "1.5.0")
+
+bazel_dep(name = "googletest", dev_dependency = True)
+local_path_override(
+    module_name = "googletest",
+    path = "external/googletest",
+)
+
+bazel_dep(name = "re2", dev_dependency = True)
+local_path_override(
+    module_name = "re2",
+    path = "external/re2",
+)
+
+bazel_dep(name = "effcee", dev_dependency = True)
+local_path_override(
+    module_name = "effcee",
+    path = "external/effcee",
+)
+
+bazel_dep(name = "rules_python",
+          version = "0.34.0")
+
+# https://rules-python.readthedocs.io/en/stable/toolchains.html#library-modules-with-dev-only-python-usage
+python = use_extension(
+    "@rules_python//python/extensions:python.bzl",
+    "python",
+    dev_dependency = True
+)
+
+python.toolchain(python_version = "3.12",
+                 is_default = True,
+                 ignore_root_user_error = True)
diff --git a/OWNERS b/OWNERS
index ca2b8249..a973c04d 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1 +1,2 @@
 include platform/external/deqp:/OWNERS
+include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/README.md b/README.md
index 042b83da..d1ce2fbe 100644
--- a/README.md
+++ b/README.md
@@ -24,6 +24,13 @@ headers, and XML registry.
 
 ## Downloads
 
+The official releases for SPIRV-Tools can be found on LunarG's
+[SDK download page](https://vulkan.lunarg.com/sdk/home).
+
+For convenience, here are also links to the latest builds (HEAD).
+Those are untested automated builds. Those are not official releases, nor
+are guaranteed to work. Official releases builds are in the Vulkan SDK.
+
 <img alt="Linux" src="kokoro/img/linux.png" width="20px" height="20px" hspace="2px"/>[![Linux Build Status](https://storage.googleapis.com/spirv-tools/badges/build_status_linux_clang_release.svg)](https://storage.googleapis.com/spirv-tools/badges/build_link_linux_clang_release.html)
 <img alt="MacOS" src="kokoro/img/macos.png" width="20px" height="20px" hspace="2px"/>[![MacOS Build Status](https://storage.googleapis.com/spirv-tools/badges/build_status_macos_clang_release.svg)](https://storage.googleapis.com/spirv-tools/badges/build_link_macos_clang_release.html)
 <img alt="Windows" src="kokoro/img/windows.png" width="20px" height="20px" hspace="2px"/>[![Windows Build Status](https://storage.googleapis.com/spirv-tools/badges/build_status_windows_release.svg)](https://storage.googleapis.com/spirv-tools/badges/build_link_windows_vs2019_release.html)
@@ -49,17 +56,14 @@ version.  An API call reports the software version as a C-style string.
 
 ## Releases
 
-Some versions of SPIRV-Tools are tagged as stable releases (see
-[tags](https://github.com/KhronosGroup/SPIRV-Tools/tags) on github).
-These versions undergo extra testing.
-Releases are not directly related to releases (or versions) of
-[SPIRV-Headers][spirv-headers].
-Releases of SPIRV-Tools are tested against the version of SPIRV-Headers listed
-in the [DEPS](DEPS) file.
-The release generally uses the most recent compatible version of SPIRV-Headers
-available at the time of release.
-No version of SPIRV-Headers other than the one listed in the DEPS file is
-guaranteed to work with the SPIRV-Tools release.
+The official releases for SPIRV-Tools can be found on LunarG's
+[SDK download page](https://vulkan.lunarg.com/sdk/home).
+
+You can find either the prebuilt, and QA tested binaries, or download the
+SDK Config, which lists the commits to use to build the release from scratch.
+
+GitHub releases are deprecated, and we will not publish new releases until
+further notice.
 
 ## Supported features
 
@@ -76,6 +80,8 @@ guaranteed to work with the SPIRV-Tools release.
 * Assembler only does basic syntax checking.  No cross validation of
   IDs or types is performed, except to check literal arguments to
   `OpConstant`, `OpSpecConstant`, and `OpSwitch`.
+* Where tools expect binary input, a hex stream may be provided instead.  See
+  `spirv-dis --help`.
 
 See [`docs/syntax.md`](docs/syntax.md) for the assembly language syntax.
 
@@ -426,7 +432,7 @@ targets, you need to install CMake Version 2.8.12 or later.
 - [Python 3](http://www.python.org/): for utility scripts and running the test
 suite.
 - [Bazel](https://bazel.build/) (optional): if building the source with Bazel,
-you need to install Bazel Version 5.0.0 on your machine. Other versions may
+you need to install Bazel Version 7.0.2 on your machine. Other versions may
 also work, but are not verified.
 - [Emscripten SDK](https://emscripten.org) (optional): if building the
   WebAssembly module.
diff --git a/WORKSPACE b/WORKSPACE
index 589dc122..054960aa 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -1,32 +1,9 @@
-load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
-
-http_archive(
-    name = "bazel_skylib",
-    strip_prefix = "bazel-skylib-main",
-    urls = ["https://github.com/bazelbuild/bazel-skylib/archive/main.zip"],
-)
-
 local_repository(
     name = "spirv_headers",
     path = "external/spirv-headers",
 )
 
 local_repository(
-    name = "com_google_googletest",
-    path = "external/googletest",
-)
-
-local_repository(
-    name = "com_googlesource_code_re2",
-    path = "external/re2",
-)
-
-local_repository(
-    name = "com_google_effcee",
-    path = "external/effcee",
-)
-
-local_repository(
-    name = "com_google_absl",
+    name = "abseil-cpp",
     path = "external/abseil_cpp",
 )
diff --git a/docs/downloads.md b/docs/downloads.md
index f56b6fe9..0454b9ea 100644
--- a/docs/downloads.md
+++ b/docs/downloads.md
@@ -1,6 +1,22 @@
 # Downloads
 
-## Latest builds
+## Vulkan SDK
+
+The official releases for SPIRV-Tools can be found on LunarG's
+[SDK download page](https://vulkan.lunarg.com/sdk/home).
+The Vulkan SDK is updated approximately every six weeks.
+
+## Android NDK
+
+SPIRV-Tools host executables, and library sources are published as
+part of the [Android NDK](https://developer.android.com/ndk/downloads).
+
+## Automated builds
+
+For convenience, here are also links to the latest builds (HEAD).
+Those are untested automated builds. Those are not official releases, nor
+are guaranteed to work. Official releases builds are in the Android NDK or
+Vulkan SDK.
 
 Download the latest builds of the [main](https://github.com/KhronosGroup/SPIRV-Tools/tree/main) branch.
 
@@ -15,14 +31,3 @@ Download the latest builds of the [main](https://github.com/KhronosGroup/SPIRV-T
 | --- | --- | --- |
 | [MSVC 2017](https://storage.googleapis.com/spirv-tools/badges/build_link_windows_vs2017_debug.html) | [clang](https://storage.googleapis.com/spirv-tools/badges/build_link_linux_clang_debug.html) | [clang](https://storage.googleapis.com/spirv-tools/badges/build_link_macos_clang_debug.html) |
 | | [gcc](https://storage.googleapis.com/spirv-tools/badges/build_link_linux_gcc_debug.html) | |
-
-
-## Vulkan SDK
-
-SPIRV-Tools is published as part of the [LunarG Vulkan SDK](https://www.lunarg.com/vulkan-sdk/).
-The Vulkan SDK is updated approximately every six weeks.
-
-## Android NDK
-
-SPIRV-Tools host executables, and library sources are published as
-part of the [Android NDK](https://developer.android.com/ndk/downloads).
diff --git a/external/CMakeLists.txt b/external/CMakeLists.txt
index 5d8a3dab..1ccab196 100644
--- a/external/CMakeLists.txt
+++ b/external/CMakeLists.txt
@@ -45,7 +45,7 @@ if (IS_DIRECTORY ${SPIRV_HEADER_DIR})
   endif()
 else()
   message(FATAL_ERROR
-    "SPIRV-Headers was not found - please checkout a copy under external/.")
+    "SPIRV-Headers was not found - please checkout a copy at external/spirv-headers.")
 endif()
 
 if (NOT ${SPIRV_SKIP_TESTS})
diff --git a/include/spirv-tools/instrument.hpp b/include/spirv-tools/instrument.hpp
deleted file mode 100644
index 0a6e6306..00000000
--- a/include/spirv-tools/instrument.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-// Copyright (c) 2018 The Khronos Group Inc.
-// Copyright (c) 2018 Valve Corporation
-// Copyright (c) 2018 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef INCLUDE_SPIRV_TOOLS_INSTRUMENT_HPP_
-#define INCLUDE_SPIRV_TOOLS_INSTRUMENT_HPP_
-
-// Shader Instrumentation Interface
-//
-// This file provides an external interface for applications that wish to
-// communicate with shaders instrumented by passes created by:
-//
-//   CreateInstBindlessCheckPass
-//   CreateInstBuffAddrCheckPass
-//   CreateInstDebugPrintfPass
-//
-// More detailed documentation of these routines can be found in optimizer.hpp
-
-namespace spvtools {
-
-// Stream Output Buffer Offsets
-//
-// The following values provide offsets into the output buffer struct
-// generated by InstrumentPass::GenDebugStreamWrite. This method is utilized
-// by InstBindlessCheckPass, InstBuffAddrCheckPass, and InstDebugPrintfPass.
-//
-// The 1st member of the debug output buffer contains a set of flags
-// controlling the behavior of instrumentation code.
-static const int kDebugOutputFlagsOffset = 0;
-
-// Values stored at kDebugOutputFlagsOffset
-enum kInstFlags : unsigned int {
-  kInstBufferOOBEnable = 0x1,
-};
-
-// The 2nd member of the debug output buffer contains the next available word
-// in the data stream to be written. Shaders will atomically read and update
-// this value so as not to overwrite each others records. This value must be
-// initialized to zero
-static const int kDebugOutputSizeOffset = 1;
-
-// The 3rd member of the output buffer is the start of the stream of records
-// written by the instrumented shaders. Each record represents a validation
-// error. The format of the records is documented below.
-static const int kDebugOutputDataOffset = 2;
-
-// Common Stream Record Offsets
-//
-// The following are offsets to fields which are common to all records written
-// to the output stream.
-//
-// Each record first contains the size of the record in 32-bit words, including
-// the size word.
-static const int kInstCommonOutSize = 0;
-
-// This is the shader id passed by the layer when the instrumentation pass is
-// created.
-static const int kInstCommonOutShaderId = 1;
-
-// This is the ordinal position of the instruction within the SPIR-V shader
-// which generated the validation error.
-static const int kInstCommonOutInstructionIdx = 2;
-
-// Debug Buffer Bindings
-//
-// These are the bindings for the different buffers which are
-// read or written by the instrumentation passes.
-//
-// This is the output buffer written by InstDebugPrintfPass.
-static const int kDebugOutputPrintfStream = 3;
-
-}  // namespace spvtools
-
-#endif  // INCLUDE_SPIRV_TOOLS_INSTRUMENT_HPP_
diff --git a/include/spirv-tools/libspirv.h b/include/spirv-tools/libspirv.h
index abdfc15d..100e61e1 100644
--- a/include/spirv-tools/libspirv.h
+++ b/include/spirv-tools/libspirv.h
@@ -33,15 +33,19 @@ extern "C" {
 #else
 #define SPIRV_TOOLS_EXPORT __declspec(dllimport)
 #endif
+#define SPIRV_TOOLS_LOCAL
 #else
 #if defined(SPIRV_TOOLS_IMPLEMENTATION)
 #define SPIRV_TOOLS_EXPORT __attribute__((visibility("default")))
+#define SPIRV_TOOLS_LOCAL __attribute__((visibility("hidden")))
 #else
 #define SPIRV_TOOLS_EXPORT
+#define SPIRV_TOOLS_LOCAL
 #endif
 #endif
 #else
 #define SPIRV_TOOLS_EXPORT
+#define SPIRV_TOOLS_LOCAL
 #endif
 
 // Helpers
@@ -171,6 +175,7 @@ typedef enum spv_operand_type_t {
   SPV_OPERAND_TYPE_KERNEL_ENQ_FLAGS,              // SPIR-V Sec 3.29
   SPV_OPERAND_TYPE_KERNEL_PROFILING_INFO,         // SPIR-V Sec 3.30
   SPV_OPERAND_TYPE_CAPABILITY,                    // SPIR-V Sec 3.31
+  SPV_OPERAND_TYPE_FPENCODING,                    // SPIR-V Sec 3.51
 
   // NOTE: New concrete enum values should be added at the end.
 
@@ -232,6 +237,8 @@ typedef enum spv_operand_type_t {
   // assemble regardless of where they occur -- literals, IDs, immediate
   // integers, etc.
   SPV_OPERAND_TYPE_OPTIONAL_CIV,
+  // An optional floating point encoding enum
+  SPV_OPERAND_TYPE_OPTIONAL_FPENCODING,
 
   // A variable operand represents zero or more logical operands.
   // In an instruction definition, this may only appear at the end of the
@@ -301,6 +308,18 @@ typedef enum spv_operand_type_t {
   SPV_OPERAND_TYPE_LOAD_CACHE_CONTROL,
   // Enum type from SPV_INTEL_cache_controls
   SPV_OPERAND_TYPE_STORE_CACHE_CONTROL,
+  // Enum type from SPV_INTEL_maximum_registers
+  SPV_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS,
+  // Enum type from SPV_NV_raw_access_chains
+  SPV_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS,
+  // Optional enum type from SPV_NV_raw_access_chains
+  SPV_OPERAND_TYPE_OPTIONAL_RAW_ACCESS_CHAIN_OPERANDS,
+  // Enum type from SPV_NV_tensor_addressing
+  SPV_OPERAND_TYPE_TENSOR_CLAMP_MODE,
+  // Enum type from SPV_NV_cooperative_matrix2
+  SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE,
+  // Enum type from SPV_NV_cooperative_matrix2
+  SPV_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS,
 
   // This is a sentinel value, and does not represent an operand type.
   // It should come last.
@@ -327,6 +346,7 @@ typedef enum spv_ext_inst_type_t {
   SPV_EXT_INST_TYPE_OPENCL_DEBUGINFO_100,
   SPV_EXT_INST_TYPE_NONSEMANTIC_CLSPVREFLECTION,
   SPV_EXT_INST_TYPE_NONSEMANTIC_SHADER_DEBUGINFO_100,
+  SPV_EXT_INST_TYPE_NONSEMANTIC_VKSPREFLECTION,
 
   // Multiple distinct extended instruction set types could return this
   // value, if they are prefixed with NonSemantic. and are otherwise
@@ -371,6 +391,11 @@ typedef enum spv_binary_to_text_options_t {
   SPV_BINARY_TO_TEXT_OPTION_FRIENDLY_NAMES = SPV_BIT(6),
   // Add some comments to the generated assembly
   SPV_BINARY_TO_TEXT_OPTION_COMMENT = SPV_BIT(7),
+  // Use nested indentation for more readable SPIR-V
+  SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT = SPV_BIT(8),
+  // Reorder blocks to match the structured control flow of SPIR-V to increase
+  // readability.
+  SPV_BINARY_TO_TEXT_OPTION_REORDER_BLOCKS = SPV_BIT(9),
   SPV_FORCE_32_BIT_ENUM(spv_binary_to_text_options_t)
 } spv_binary_to_text_options_t;
 
@@ -515,6 +540,7 @@ SPIRV_TOOLS_EXPORT const char* spvSoftwareVersionDetailsString(void);
 //    SPV_ENV_VULKAN_1_1_SPIRV_1_4 ->  SPIR-V 1.4
 //    SPV_ENV_VULKAN_1_2           ->  SPIR-V 1.5
 //    SPV_ENV_VULKAN_1_3           ->  SPIR-V 1.6
+//    SPV_ENV_VULKAN_1_4           ->  SPIR-V 1.6
 // Consult the description of API entry points for specific rules.
 typedef enum {
   SPV_ENV_UNIVERSAL_1_0,  // SPIR-V 1.0 latest revision, no other restrictions.
@@ -552,6 +578,7 @@ typedef enum {
 
   SPV_ENV_UNIVERSAL_1_6,  // SPIR-V 1.6 latest revision, no other restrictions.
   SPV_ENV_VULKAN_1_3,     // Vulkan 1.3 latest revision.
+  SPV_ENV_VULKAN_1_4,     // Vulkan 1.4 latest revision.
 
   SPV_ENV_MAX  // Keep this as the last enum value.
 } spv_target_env;
diff --git a/include/spirv-tools/libspirv.hpp b/include/spirv-tools/libspirv.hpp
index ee6c8469..6a64e936 100644
--- a/include/spirv-tools/libspirv.hpp
+++ b/include/spirv-tools/libspirv.hpp
@@ -20,7 +20,7 @@
 #include <string>
 #include <vector>
 
-#include "spirv-tools/libspirv.h"
+#include "libspirv.h"
 
 namespace spvtools {
 
@@ -37,7 +37,7 @@ using InstructionParser =
     std::function<spv_result_t(const spv_parsed_instruction_t& instruction)>;
 
 // C++ RAII wrapper around the C context object spv_context.
-class Context {
+class SPIRV_TOOLS_EXPORT Context {
  public:
   // Constructs a context targeting the given environment |env|.
   //
@@ -73,7 +73,7 @@ class Context {
 };
 
 // A RAII wrapper around a validator options object.
-class ValidatorOptions {
+class SPIRV_TOOLS_EXPORT ValidatorOptions {
  public:
   ValidatorOptions() : options_(spvValidatorOptionsCreate()) {}
   ~ValidatorOptions() { spvValidatorOptionsDestroy(options_); }
@@ -163,7 +163,7 @@ class ValidatorOptions {
 };
 
 // A C++ wrapper around an optimization options object.
-class OptimizerOptions {
+class SPIRV_TOOLS_EXPORT OptimizerOptions {
  public:
   OptimizerOptions() : options_(spvOptimizerOptionsCreate()) {}
   ~OptimizerOptions() { spvOptimizerOptionsDestroy(options_); }
@@ -205,7 +205,7 @@ class OptimizerOptions {
 };
 
 // A C++ wrapper around a reducer options object.
-class ReducerOptions {
+class SPIRV_TOOLS_EXPORT ReducerOptions {
  public:
   ReducerOptions() : options_(spvReducerOptionsCreate()) {}
   ~ReducerOptions() { spvReducerOptionsDestroy(options_); }
@@ -236,7 +236,7 @@ class ReducerOptions {
 };
 
 // A C++ wrapper around a fuzzer options object.
-class FuzzerOptions {
+class SPIRV_TOOLS_EXPORT FuzzerOptions {
  public:
   FuzzerOptions() : options_(spvFuzzerOptionsCreate()) {}
   ~FuzzerOptions() { spvFuzzerOptionsDestroy(options_); }
@@ -283,7 +283,7 @@ class FuzzerOptions {
 // provides methods for assembling, disassembling, and validating.
 //
 // Instances of this class provide basic thread-safety guarantee.
-class SpirvTools {
+class SPIRV_TOOLS_EXPORT SpirvTools {
  public:
   enum {
     // Default assembling option used by assemble():
@@ -388,7 +388,8 @@ class SpirvTools {
   bool IsValid() const;
 
  private:
-  struct Impl;  // Opaque struct for holding the data fields used by this class.
+  struct SPIRV_TOOLS_LOCAL
+      Impl;  // Opaque struct for holding the data fields used by this class.
   std::unique_ptr<Impl> impl_;  // Unique pointer to implementation data.
 };
 
diff --git a/include/spirv-tools/linker.hpp b/include/spirv-tools/linker.hpp
index 5b60cb9f..9037b948 100644
--- a/include/spirv-tools/linker.hpp
+++ b/include/spirv-tools/linker.hpp
@@ -16,7 +16,6 @@
 #define INCLUDE_SPIRV_TOOLS_LINKER_HPP_
 
 #include <cstdint>
-
 #include <memory>
 #include <vector>
 
@@ -24,7 +23,7 @@
 
 namespace spvtools {
 
-class LinkerOptions {
+class SPIRV_TOOLS_EXPORT LinkerOptions {
  public:
   // Returns whether a library or an executable should be produced by the
   // linking phase.
@@ -63,11 +62,17 @@ class LinkerOptions {
     use_highest_version_ = use_highest_vers;
   }
 
+  bool GetAllowPtrTypeMismatch() const { return allow_ptr_type_mismatch_; }
+  void SetAllowPtrTypeMismatch(bool allow_ptr_type_mismatch) {
+    allow_ptr_type_mismatch_ = allow_ptr_type_mismatch;
+  }
+
  private:
   bool create_library_{false};
   bool verify_ids_{false};
   bool allow_partial_linkage_{false};
   bool use_highest_version_{false};
+  bool allow_ptr_type_mismatch_{false};
 };
 
 // Links one or more SPIR-V modules into a new SPIR-V module. That is, combine
@@ -84,14 +89,15 @@ class LinkerOptions {
 // * Some entry points were defined multiple times;
 // * Some imported symbols did not have an exported counterpart;
 // * Possibly other reasons.
-spv_result_t Link(const Context& context,
-                  const std::vector<std::vector<uint32_t>>& binaries,
-                  std::vector<uint32_t>* linked_binary,
-                  const LinkerOptions& options = LinkerOptions());
-spv_result_t Link(const Context& context, const uint32_t* const* binaries,
-                  const size_t* binary_sizes, size_t num_binaries,
-                  std::vector<uint32_t>* linked_binary,
-                  const LinkerOptions& options = LinkerOptions());
+SPIRV_TOOLS_EXPORT spv_result_t
+Link(const Context& context, const std::vector<std::vector<uint32_t>>& binaries,
+     std::vector<uint32_t>* linked_binary,
+     const LinkerOptions& options = LinkerOptions());
+SPIRV_TOOLS_EXPORT spv_result_t
+Link(const Context& context, const uint32_t* const* binaries,
+     const size_t* binary_sizes, size_t num_binaries,
+     std::vector<uint32_t>* linked_binary,
+     const LinkerOptions& options = LinkerOptions());
 
 }  // namespace spvtools
 
diff --git a/include/spirv-tools/linter.hpp b/include/spirv-tools/linter.hpp
index 52ed5a46..ccbcf0c1 100644
--- a/include/spirv-tools/linter.hpp
+++ b/include/spirv-tools/linter.hpp
@@ -24,7 +24,7 @@ namespace spvtools {
 // provides a method for linting.
 //
 // Instances of this class provides basic thread-safety guarantee.
-class Linter {
+class SPIRV_TOOLS_EXPORT Linter {
  public:
   explicit Linter(spv_target_env env);
 
@@ -40,7 +40,7 @@ class Linter {
   bool Run(const uint32_t* binary, size_t binary_size);
 
  private:
-  struct Impl;
+  struct SPIRV_TOOLS_LOCAL Impl;
   std::unique_ptr<Impl> impl_;
 };
 }  // namespace spvtools
diff --git a/include/spirv-tools/optimizer.hpp b/include/spirv-tools/optimizer.hpp
index 926e438f..9427b01e 100644
--- a/include/spirv-tools/optimizer.hpp
+++ b/include/spirv-tools/optimizer.hpp
@@ -37,14 +37,14 @@ struct DescriptorSetAndBinding;
 // provides methods for registering optimization passes and optimizing.
 //
 // Instances of this class provides basic thread-safety guarantee.
-class Optimizer {
+class SPIRV_TOOLS_EXPORT Optimizer {
  public:
   // The token for an optimization pass. It is returned via one of the
   // Create*Pass() standalone functions at the end of this header file and
   // consumed by the RegisterPass() method. Tokens are one-time objects that
   // only support move; copying is not allowed.
   struct PassToken {
-    struct Impl;  // Opaque struct for holding internal data.
+    struct SPIRV_TOOLS_LOCAL Impl;  // Opaque struct for holding internal data.
 
     PassToken(std::unique_ptr<Impl>);
 
@@ -239,7 +239,7 @@ class Optimizer {
   Optimizer& SetValidateAfterAll(bool validate);
 
  private:
-  struct Impl;                  // Opaque struct for holding internal data.
+  struct SPIRV_TOOLS_LOCAL Impl;  // Opaque struct for holding internal data.
   std::unique_ptr<Impl> impl_;  // Unique pointer to internal data.
 };
 
@@ -747,65 +747,6 @@ Optimizer::PassToken CreateReduceLoadSizePass(
 // them into a single instruction where possible.
 Optimizer::PassToken CreateCombineAccessChainsPass();
 
-// Create a pass to instrument bindless descriptor checking
-// This pass instruments all bindless references to check that descriptor
-// array indices are inbounds, and if the descriptor indexing extension is
-// enabled, that the descriptor has been initialized. If the reference is
-// invalid, a record is written to the debug output buffer (if space allows)
-// and a null value is returned. This pass is designed to support bindless
-// validation in the Vulkan validation layers.
-//
-// TODO(greg-lunarg): Add support for buffer references. Currently only does
-// checking for image references.
-//
-// Dead code elimination should be run after this pass as the original,
-// potentially invalid code is not removed and could cause undefined behavior,
-// including crashes. It may also be beneficial to run Simplification
-// (ie Constant Propagation), DeadBranchElim and BlockMerge after this pass to
-// optimize instrument code involving the testing of compile-time constants.
-// It is also generally recommended that this pass (and all
-// instrumentation passes) be run after any legalization and optimization
-// passes. This will give better analysis for the instrumentation and avoid
-// potentially de-optimizing the instrument code, for example, inlining
-// the debug record output function throughout the module.
-//
-// The instrumentation will write |shader_id| in each output record
-// to identify the shader module which generated the record.
-Optimizer::PassToken CreateInstBindlessCheckPass(uint32_t shader_id);
-
-// Create a pass to instrument physical buffer address checking
-// This pass instruments all physical buffer address references to check that
-// all referenced bytes fall in a valid buffer. If the reference is
-// invalid, a record is written to the debug output buffer (if space allows)
-// and a null value is returned. This pass is designed to support buffer
-// address validation in the Vulkan validation layers.
-//
-// Dead code elimination should be run after this pass as the original,
-// potentially invalid code is not removed and could cause undefined behavior,
-// including crashes. Instruction simplification would likely also be
-// beneficial. It is also generally recommended that this pass (and all
-// instrumentation passes) be run after any legalization and optimization
-// passes. This will give better analysis for the instrumentation and avoid
-// potentially de-optimizing the instrument code, for example, inlining
-// the debug record output function throughout the module.
-//
-// The instrumentation will read and write buffers in debug
-// descriptor set |desc_set|. It will write |shader_id| in each output record
-// to identify the shader module which generated the record.
-Optimizer::PassToken CreateInstBuffAddrCheckPass(uint32_t shader_id);
-
-// Create a pass to instrument OpDebugPrintf instructions.
-// This pass replaces all OpDebugPrintf instructions with instructions to write
-// a record containing the string id and the all specified values into a special
-// printf output buffer (if space allows). This pass is designed to support
-// the printf validation in the Vulkan validation layers.
-//
-// The instrumentation will write buffers in debug descriptor set |desc_set|.
-// It will write |shader_id| in each output record to identify the shader
-// module which generated the record.
-Optimizer::PassToken CreateInstDebugPrintfPass(uint32_t desc_set,
-                                               uint32_t shader_id);
-
 // Create a pass to upgrade to the VulkanKHR memory model.
 // This pass upgrades the Logical GLSL450 memory model to Logical VulkanKHR.
 // Additionally, it modifies memory, image, atomic and barrier operations to
@@ -874,14 +815,19 @@ Optimizer::PassToken CreateReplaceDescArrayAccessUsingVarIndexPass();
 
 // Create descriptor scalar replacement pass.
 // This pass replaces every array variable |desc| that has a DescriptorSet and
-// Binding decorations with a new variable for each element of the array.
-// Suppose |desc| was bound at binding |b|.  Then the variable corresponding to
-// |desc[i]| will have binding |b+i|.  The descriptor set will be the same.  It
-// is assumed that no other variable already has a binding that will used by one
-// of the new variables.  If not, the pass will generate invalid Spir-V.  All
-// accesses to |desc| must be OpAccessChain instructions with a literal index
-// for the first index.
+// Binding decorations with a new variable for each element of the
+// array/composite. Suppose |desc| was bound at binding |b|.  Then the variable
+// corresponding to |desc[i]| will have binding |b+i|.  The descriptor set will
+// be the same.  It is assumed that no other variable already has a binding that
+// will used by one of the new variables.  If not, the pass will generate
+// invalid Spir-V.  All accesses to |desc| must be OpAccessChain instructions
+// with a literal index for the first index. This variant flattens both
+// composites and arrays.
 Optimizer::PassToken CreateDescriptorScalarReplacementPass();
+// This variant flattens only composites.
+Optimizer::PassToken CreateDescriptorCompositeScalarReplacementPass();
+// This variant flattens only arrays.
+Optimizer::PassToken CreateDescriptorArrayScalarReplacementPass();
 
 // Create a pass to replace each OpKill instruction with a function call to a
 // function that has a single OpKill.  Also replace each OpTerminateInvocation
@@ -903,6 +849,12 @@ Optimizer::PassToken CreateAmdExtToKhrPass();
 // propagated into their final positions.
 Optimizer::PassToken CreateInterpolateFixupPass();
 
+// Replace OpExtInst instructions with OpExtInstWithForwardRefsKHR when
+// the instruction contains a forward reference to another debug instuction.
+// Replace OpExtInstWithForwardRefsKHR with OpExtInst when there are no forward
+// reference to another debug instruction.
+Optimizer::PassToken CreateOpExtInstWithForwardReferenceFixupPass();
+
 // Removes unused components from composite input variables. Current
 // implementation just removes trailing unused components from input arrays
 // and structs. The pass performs best after maximizing dead code removal.
@@ -992,6 +944,15 @@ Optimizer::PassToken CreateFixFuncCallArgumentsPass();
 // the unknown capability interacts with one of the trimmed capabilities.
 Optimizer::PassToken CreateTrimCapabilitiesPass();
 
+// Creates a struct-packing pass.
+// This pass re-assigns all offset layout decorators to tightly pack
+// the struct with OpName matching `structToPack` according to the given packing
+// rule. Accepted packing rules are: std140, std140EnhancedLayout, std430,
+// std430EnhancedLayout, hlslCbuffer, hlslCbufferPackOffset, scalar,
+// scalarEnhancedLayout.
+Optimizer::PassToken CreateStructPackingPass(const char* structToPack,
+                                             const char* packingRule);
+
 // Creates a switch-descriptorset pass.
 // This pass changes any DescriptorSet decorations with the value |ds_from| to
 // use the new value |ds_to|.
diff --git a/kokoro/macos-clang-release-bazel/build.sh b/kokoro/macos-clang-release-bazel/build.sh
index 74f9e236..4bb889ad 100644
--- a/kokoro/macos-clang-release-bazel/build.sh
+++ b/kokoro/macos-clang-release-bazel/build.sh
@@ -32,14 +32,14 @@ git config --global --add safe.directory $SRC
 cd $SRC
 /usr/bin/python3 utils/git-sync-deps --treeless
 
-# Get bazel 5.0.0
-gsutil cp gs://bazel/5.0.0/release/bazel-5.0.0-darwin-x86_64 .
-chmod +x bazel-5.0.0-darwin-x86_64
+# Get bazel 7.0.2
+gsutil cp gs://bazel/7.0.2/release/bazel-7.0.2-darwin-x86_64 .
+chmod +x bazel-7.0.2-darwin-x86_64
 
 echo $(date): Build everything...
-./bazel-5.0.0-darwin-x86_64 build --cxxopt=-std=c++17 :all
+./bazel-7.0.2-darwin-x86_64 build --cxxopt=-std=c++17 :all
 echo $(date): Build completed.
 
 echo $(date): Starting bazel test...
-./bazel-5.0.0-darwin-x86_64 test --cxxopt=-std=c++17 :all
+./bazel-7.0.2-darwin-x86_64 test --cxxopt=-std=c++17 :all
 echo $(date): Bazel test completed.
diff --git a/kokoro/scripts/linux/build-docker.sh b/kokoro/scripts/linux/build-docker.sh
index a0dc96ab..b2c034d6 100755
--- a/kokoro/scripts/linux/build-docker.sh
+++ b/kokoro/scripts/linux/build-docker.sh
@@ -27,6 +27,8 @@ git config --global --add safe.directory $ROOT_DIR
 
 . /bin/using.sh # Declare the bash `using` function for configuring toolchains.
 
+using python-3.12
+
 if [ $COMPILER = "clang" ]; then
   using clang-10.0.0
 elif [ $COMPILER = "gcc" ]; then
@@ -191,7 +193,7 @@ elif [ $TOOL = "android-ndk-build" ]; then
 
   echo $(date): ndk-build completed.
 elif [ $TOOL = "bazel" ]; then
-  using bazel-5.0.0
+  using bazel-7.0.2
 
   echo $(date): Build everything...
   bazel build --cxxopt=-std=c++17 :all
diff --git a/source/CMakeLists.txt b/source/CMakeLists.txt
index f4ee3c84..b20357bb 100644
--- a/source/CMakeLists.txt
+++ b/source/CMakeLists.txt
@@ -156,6 +156,7 @@ spvtools_vendor_tables("debuginfo" "debuginfo" "")
 spvtools_vendor_tables("opencl.debuginfo.100" "cldi100" "CLDEBUG100_")
 spvtools_vendor_tables("nonsemantic.shader.debuginfo.100" "shdi100" "SHDEBUG100_")
 spvtools_vendor_tables("nonsemantic.clspvreflection" "clspvreflection" "")
+spvtools_vendor_tables("nonsemantic.vkspreflection" "vkspreflection" "")
 spvtools_extinst_lang_headers("DebugInfo" ${DEBUGINFO_GRAMMAR_JSON_FILE})
 spvtools_extinst_lang_headers("OpenCLDebugInfo100" ${CLDEBUGINFO100_GRAMMAR_JSON_FILE})
 spvtools_extinst_lang_headers("NonSemanticShaderDebugInfo100" ${VKDEBUGINFO100_GRAMMAR_JSON_FILE})
@@ -265,6 +266,7 @@ set(SPIRV_SOURCES
   ${CMAKE_CURRENT_SOURCE_DIR}/table.h
   ${CMAKE_CURRENT_SOURCE_DIR}/text.h
   ${CMAKE_CURRENT_SOURCE_DIR}/text_handler.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/to_string.h
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate.h
 
   ${CMAKE_CURRENT_SOURCE_DIR}/util/bit_vector.cpp
@@ -293,6 +295,7 @@ set(SPIRV_SOURCES
   ${CMAKE_CURRENT_SOURCE_DIR}/table.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/text.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/text_handler.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/to_string.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_adjacency.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_annotation.cpp
@@ -331,6 +334,7 @@ set(SPIRV_SOURCES
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_ray_tracing_reorder.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_scopes.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_small_type_uses.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_tensor_layout.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/validate_type.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/val/decoration.h
   ${CMAKE_CURRENT_SOURCE_DIR}/val/basic_block.cpp
diff --git a/source/binary.cpp b/source/binary.cpp
index 3cfdee04..ed574985 100644
--- a/source/binary.cpp
+++ b/source/binary.cpp
@@ -473,7 +473,7 @@ spv_result_t Parser::parseOperand(size_t inst_offset,
       if (!word) return diagnostic(SPV_ERROR_INVALID_ID) << "Id is 0";
       parsed_operand.type = SPV_OPERAND_TYPE_ID;
 
-      if (opcode == spv::Op::OpExtInst && parsed_operand.offset == 3) {
+      if (spvIsExtendedInstruction(opcode) && parsed_operand.offset == 3) {
         // The current word is the extended instruction set Id.
         // Set the extended instruction set type for the current instruction.
         auto ext_inst_type_iter = _.import_id_to_ext_inst_type.find(word);
@@ -494,7 +494,7 @@ spv_result_t Parser::parseOperand(size_t inst_offset,
       break;
 
     case SPV_OPERAND_TYPE_EXTENSION_INSTRUCTION_NUMBER: {
-      assert(spv::Op::OpExtInst == opcode);
+      assert(spvIsExtendedInstruction(opcode));
       assert(inst->ext_inst_type != SPV_EXT_INST_TYPE_NONE);
       spv_ext_inst_desc ext_inst;
       if (grammar_.lookupExtInst(inst->ext_inst_type, word, &ext_inst) ==
@@ -670,7 +670,13 @@ spv_result_t Parser::parseOperand(size_t inst_offset,
     case SPV_OPERAND_TYPE_QUANTIZATION_MODES:
     case SPV_OPERAND_TYPE_OVERFLOW_MODES:
     case SPV_OPERAND_TYPE_PACKED_VECTOR_FORMAT:
-    case SPV_OPERAND_TYPE_OPTIONAL_PACKED_VECTOR_FORMAT: {
+    case SPV_OPERAND_TYPE_OPTIONAL_PACKED_VECTOR_FORMAT:
+    case SPV_OPERAND_TYPE_FPENCODING:
+    case SPV_OPERAND_TYPE_OPTIONAL_FPENCODING:
+    case SPV_OPERAND_TYPE_HOST_ACCESS_QUALIFIER:
+    case SPV_OPERAND_TYPE_LOAD_CACHE_CONTROL:
+    case SPV_OPERAND_TYPE_STORE_CACHE_CONTROL:
+    case SPV_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS: {
       // A single word that is a plain enum value.
 
       // Map an optional operand type to its corresponding concrete type.
@@ -678,6 +684,8 @@ spv_result_t Parser::parseOperand(size_t inst_offset,
         parsed_operand.type = SPV_OPERAND_TYPE_ACCESS_QUALIFIER;
       if (type == SPV_OPERAND_TYPE_OPTIONAL_PACKED_VECTOR_FORMAT)
         parsed_operand.type = SPV_OPERAND_TYPE_PACKED_VECTOR_FORMAT;
+      if (type == SPV_OPERAND_TYPE_OPTIONAL_FPENCODING)
+        parsed_operand.type = SPV_OPERAND_TYPE_FPENCODING;
 
       spv_operand_desc entry;
       if (grammar_.lookupOperand(type, word, &entry)) {
@@ -698,7 +706,7 @@ spv_result_t Parser::parseOperand(size_t inst_offset,
                << ", if you are creating a new source language please use "
                   "value 0 "
                   "(Unknown) and when ready, add your source language to "
-                  "SPRIV-Headers";
+                  "SPIRV-Headers";
       }
       // Prepare to accept operands to this operand, if needed.
       spvPushOperandTypes(entry->operandTypes, expected_operands);
@@ -709,21 +717,27 @@ spv_result_t Parser::parseOperand(size_t inst_offset,
     case SPV_OPERAND_TYPE_LOOP_CONTROL:
     case SPV_OPERAND_TYPE_IMAGE:
     case SPV_OPERAND_TYPE_OPTIONAL_IMAGE:
+    case SPV_OPERAND_TYPE_MEMORY_ACCESS:
     case SPV_OPERAND_TYPE_OPTIONAL_MEMORY_ACCESS:
+    case SPV_OPERAND_TYPE_OPTIONAL_RAW_ACCESS_CHAIN_OPERANDS:
     case SPV_OPERAND_TYPE_SELECTION_CONTROL:
     case SPV_OPERAND_TYPE_CLDEBUG100_DEBUG_INFO_FLAGS:
     case SPV_OPERAND_TYPE_DEBUG_INFO_FLAGS:
     case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_OPERANDS:
-    case SPV_OPERAND_TYPE_OPTIONAL_COOPERATIVE_MATRIX_OPERANDS: {
+    case SPV_OPERAND_TYPE_OPTIONAL_COOPERATIVE_MATRIX_OPERANDS:
+    case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE:
+    case SPV_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS: {
       // This operand is a mask.
 
       // Map an optional operand type to its corresponding concrete type.
       if (type == SPV_OPERAND_TYPE_OPTIONAL_IMAGE)
         parsed_operand.type = SPV_OPERAND_TYPE_IMAGE;
-      else if (type == SPV_OPERAND_TYPE_OPTIONAL_MEMORY_ACCESS)
+      if (type == SPV_OPERAND_TYPE_OPTIONAL_MEMORY_ACCESS)
         parsed_operand.type = SPV_OPERAND_TYPE_MEMORY_ACCESS;
       if (type == SPV_OPERAND_TYPE_OPTIONAL_COOPERATIVE_MATRIX_OPERANDS)
         parsed_operand.type = SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_OPERANDS;
+      if (type == SPV_OPERAND_TYPE_OPTIONAL_RAW_ACCESS_CHAIN_OPERANDS)
+        parsed_operand.type = SPV_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS;
 
       // Check validity of set mask bits. Also prepare for operands for those
       // masks if they have any.  To get operand order correct, scan from
diff --git a/source/disassemble.cpp b/source/disassemble.cpp
index 5173fbf6..93791a0c 100644
--- a/source/disassemble.cpp
+++ b/source/disassemble.cpp
@@ -23,7 +23,11 @@
 #include <cassert>
 #include <cstring>
 #include <iomanip>
+#include <ios>
 #include <memory>
+#include <set>
+#include <sstream>
+#include <stack>
 #include <unordered_map>
 #include <utility>
 
@@ -43,6 +47,70 @@
 namespace spvtools {
 namespace {
 
+// Indices to ControlFlowGraph's list of blocks from one block to its successors
+struct BlockSuccessors {
+  // Merge block in OpLoopMerge and OpSelectionMerge
+  uint32_t merge_block_id = 0;
+  // The continue block in OpLoopMerge
+  uint32_t continue_block_id = 0;
+  // The true and false blocks in OpBranchConditional
+  uint32_t true_block_id = 0;
+  uint32_t false_block_id = 0;
+  // The body block of a loop, as specified by OpBranch after a merge
+  // instruction
+  uint32_t body_block_id = 0;
+  // The same-nesting-level block that follows this one, indicated by an
+  // OpBranch with no merge instruction.
+  uint32_t next_block_id = 0;
+  // The cases (including default) of an OpSwitch
+  std::vector<uint32_t> case_block_ids;
+};
+
+class ParsedInstruction {
+ public:
+  ParsedInstruction(const spv_parsed_instruction_t* instruction) {
+    // Make a copy of the parsed instruction, including stable memory for its
+    // operands.
+    instruction_ = *instruction;
+    operands_ =
+        std::make_unique<spv_parsed_operand_t[]>(instruction->num_operands);
+    memcpy(operands_.get(), instruction->operands,
+           instruction->num_operands * sizeof(*instruction->operands));
+    instruction_.operands = operands_.get();
+  }
+
+  const spv_parsed_instruction_t* get() const { return &instruction_; }
+
+ private:
+  spv_parsed_instruction_t instruction_;
+  std::unique_ptr<spv_parsed_operand_t[]> operands_;
+};
+
+// One block in the CFG
+struct SingleBlock {
+  // The byte offset in the SPIR-V where the block starts.  Used for printing in
+  // a comment.
+  size_t byte_offset;
+
+  // Block instructions
+  std::vector<ParsedInstruction> instructions;
+
+  // Successors of this block
+  BlockSuccessors successors;
+
+  // The nesting level for this block.
+  uint32_t nest_level = 0;
+  bool nest_level_assigned = false;
+
+  // Whether the block was reachable
+  bool reachable = false;
+};
+
+// CFG for one function
+struct ControlFlowGraph {
+  std::vector<SingleBlock> blocks;
+};
+
 // A Disassembler instance converts a SPIR-V binary to its assembly
 // representation.
 class Disassembler {
@@ -50,6 +118,10 @@ class Disassembler {
   Disassembler(const AssemblyGrammar& grammar, uint32_t options,
                NameMapper name_mapper)
       : print_(spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_PRINT, options)),
+        nested_indent_(
+            spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT, options)),
+        reorder_blocks_(
+            spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_REORDER_BLOCKS, options)),
         text_(),
         out_(print_ ? out_stream() : out_stream(text_)),
         instruction_disassembler_(grammar, out_.get(), options, name_mapper),
@@ -70,7 +142,13 @@ class Disassembler {
   spv_result_t SaveTextResult(spv_text* text_result) const;
 
  private:
+  void EmitCFG();
+
   const bool print_;  // Should we also print to the standard output stream?
+  const bool nested_indent_;  // Should the blocks be indented according to the
+                              // control flow structure?
+  const bool
+      reorder_blocks_;       // Should the blocks be reordered for readability?
   spv_endianness_t endian_;  // The detected endianness of the binary.
   std::stringstream text_;   // Captures the text, if not printing.
   out_stream out_;  // The Output stream.  Either to text_ or standard output.
@@ -80,6 +158,9 @@ class Disassembler {
   bool inserted_decoration_space_ = false;
   bool inserted_debug_space_ = false;
   bool inserted_type_space_ = false;
+
+  // The CFG for the current function
+  ControlFlowGraph current_function_cfg_;
 };
 
 spv_result_t Disassembler::HandleHeader(spv_endianness_t endian,
@@ -106,13 +187,336 @@ spv_result_t Disassembler::HandleInstruction(
                                                inserted_debug_space_,
                                                inserted_type_space_);
 
-  instruction_disassembler_.EmitInstruction(inst, byte_offset_);
+  // When nesting needs to be calculated or when the blocks are reordered, we
+  // have to have the full picture of the CFG first.  Defer processing of the
+  // instructions until the entire function is visited.  This is not done
+  // without those options (even if simpler) to improve debuggability; for
+  // example to be able to see whatever is parsed so far even if there is a
+  // parse error.
+  if (nested_indent_ || reorder_blocks_) {
+    switch (static_cast<spv::Op>(inst.opcode)) {
+      case spv::Op::OpLabel: {
+        // Add a new block to the CFG
+        SingleBlock new_block;
+        new_block.byte_offset = byte_offset_;
+        new_block.instructions.emplace_back(&inst);
+        current_function_cfg_.blocks.push_back(std::move(new_block));
+        break;
+      }
+      case spv::Op::OpFunctionEnd:
+        // Process the CFG and output the instructions
+        EmitCFG();
+        // Output OpFunctionEnd itself too
+        [[fallthrough]];
+      default:
+        if (!current_function_cfg_.blocks.empty()) {
+          // If in a function, stash the instruction for later.
+          current_function_cfg_.blocks.back().instructions.emplace_back(&inst);
+        } else {
+          // Otherwise emit the instruction right away.
+          instruction_disassembler_.EmitInstruction(inst, byte_offset_);
+        }
+        break;
+    }
+  } else {
+    instruction_disassembler_.EmitInstruction(inst, byte_offset_);
+  }
 
   byte_offset_ += inst.num_words * sizeof(uint32_t);
 
   return SPV_SUCCESS;
 }
 
+// Helper to get the operand of an instruction as an id.
+uint32_t GetOperand(const spv_parsed_instruction_t* instruction,
+                    uint32_t operand) {
+  return instruction->words[instruction->operands[operand].offset];
+}
+
+std::unordered_map<uint32_t, uint32_t> BuildControlFlowGraph(
+    ControlFlowGraph& cfg) {
+  std::unordered_map<uint32_t, uint32_t> id_to_index;
+
+  for (size_t index = 0; index < cfg.blocks.size(); ++index) {
+    SingleBlock& block = cfg.blocks[index];
+
+    // For future use, build the ID->index map
+    assert(static_cast<spv::Op>(block.instructions[0].get()->opcode) ==
+           spv::Op::OpLabel);
+    const uint32_t id = block.instructions[0].get()->result_id;
+
+    id_to_index[id] = static_cast<uint32_t>(index);
+
+    // Look for a merge instruction first.  The function of OpBranch depends on
+    // that.
+    if (block.instructions.size() >= 3) {
+      const spv_parsed_instruction_t* maybe_merge =
+          block.instructions[block.instructions.size() - 2].get();
+
+      switch (static_cast<spv::Op>(maybe_merge->opcode)) {
+        case spv::Op::OpLoopMerge:
+          block.successors.merge_block_id = GetOperand(maybe_merge, 0);
+          block.successors.continue_block_id = GetOperand(maybe_merge, 1);
+          break;
+
+        case spv::Op::OpSelectionMerge:
+          block.successors.merge_block_id = GetOperand(maybe_merge, 0);
+          break;
+
+        default:
+          break;
+      }
+    }
+
+    // Then look at the last instruction; it must be a branch
+    assert(block.instructions.size() >= 2);
+
+    const spv_parsed_instruction_t* branch = block.instructions.back().get();
+    switch (static_cast<spv::Op>(branch->opcode)) {
+      case spv::Op::OpBranch:
+        if (block.successors.merge_block_id != 0) {
+          block.successors.body_block_id = GetOperand(branch, 0);
+        } else {
+          block.successors.next_block_id = GetOperand(branch, 0);
+        }
+        break;
+
+      case spv::Op::OpBranchConditional:
+        block.successors.true_block_id = GetOperand(branch, 1);
+        block.successors.false_block_id = GetOperand(branch, 2);
+        break;
+
+      case spv::Op::OpSwitch:
+        for (uint32_t case_index = 1; case_index < branch->num_operands;
+             case_index += 2) {
+          block.successors.case_block_ids.push_back(
+              GetOperand(branch, case_index));
+        }
+        break;
+
+      default:
+        break;
+    }
+  }
+
+  return id_to_index;
+}
+
+// Helper to deal with nesting and non-existing ids / previously-assigned
+// levels.  It assigns a given nesting level `level` to the block identified by
+// `id` (unless that block already has a nesting level assigned).
+void Nest(ControlFlowGraph& cfg,
+          const std::unordered_map<uint32_t, uint32_t>& id_to_index,
+          uint32_t id, uint32_t level) {
+  if (id == 0) {
+    return;
+  }
+
+  const uint32_t block_index = id_to_index.at(id);
+  SingleBlock& block = cfg.blocks[block_index];
+
+  if (!block.nest_level_assigned) {
+    block.nest_level = level;
+    block.nest_level_assigned = true;
+  }
+}
+
+// For a given block, assign nesting level to its successors.
+void NestSuccessors(ControlFlowGraph& cfg, const SingleBlock& block,
+                    const std::unordered_map<uint32_t, uint32_t>& id_to_index) {
+  assert(block.nest_level_assigned);
+
+  // Nest loops as such:
+  //
+  //     %loop = OpLabel
+  //               OpLoopMerge %merge %cont ...
+  //               OpBranch %body
+  //     %body =     OpLabel
+  //                   Op...
+  //     %cont =   OpLabel
+  //                 Op...
+  //    %merge = OpLabel
+  //               Op...
+  //
+  // Nest conditional branches as such:
+  //
+  //   %header = OpLabel
+  //               OpSelectionMerge %merge ...
+  //               OpBranchConditional ... %true %false
+  //     %true =     OpLabel
+  //                   Op...
+  //    %false =     OpLabel
+  //                   Op...
+  //    %merge = OpLabel
+  //               Op...
+  //
+  // Nest switch/case as such:
+  //
+  //   %header = OpLabel
+  //               OpSelectionMerge %merge ...
+  //               OpSwitch ... %default ... %case0 ... %case1 ...
+  //  %default =     OpLabel
+  //                   Op...
+  //    %case0 =     OpLabel
+  //                   Op...
+  //    %case1 =     OpLabel
+  //                   Op...
+  //             ...
+  //    %merge = OpLabel
+  //               Op...
+  //
+  // The following can be observed:
+  //
+  // - In all cases, the merge block has the same nesting as this block
+  // - The continue block of loops is nested 1 level deeper
+  // - The body/branches/cases are nested 2 levels deeper
+  //
+  // Back branches to the header block, branches to the merge block, etc
+  // are correctly handled by processing the header block first (that is
+  // _this_ block, already processed), then following the above rules
+  // (in the same order) for any block that is not already processed.
+  Nest(cfg, id_to_index, block.successors.merge_block_id, block.nest_level);
+  Nest(cfg, id_to_index, block.successors.continue_block_id,
+       block.nest_level + 1);
+  Nest(cfg, id_to_index, block.successors.true_block_id, block.nest_level + 2);
+  Nest(cfg, id_to_index, block.successors.false_block_id, block.nest_level + 2);
+  Nest(cfg, id_to_index, block.successors.body_block_id, block.nest_level + 2);
+  Nest(cfg, id_to_index, block.successors.next_block_id, block.nest_level);
+  for (uint32_t case_block_id : block.successors.case_block_ids) {
+    Nest(cfg, id_to_index, case_block_id, block.nest_level + 2);
+  }
+}
+
+struct StackEntry {
+  // The index of the block (in ControlFlowGraph::blocks) to process.
+  uint32_t block_index;
+  // Whether this is the pre or post visit of the block.  Because a post-visit
+  // traversal is needed, the same block is pushed back on the stack on
+  // pre-visit so it can be visited again on post-visit.
+  bool post_visit = false;
+};
+
+// Helper to deal with DFS traversal and non-existing ids
+void VisitSuccesor(std::stack<StackEntry>* dfs_stack,
+                   const std::unordered_map<uint32_t, uint32_t>& id_to_index,
+                   uint32_t id) {
+  if (id != 0) {
+    dfs_stack->push({id_to_index.at(id), false});
+  }
+}
+
+// Given the control flow graph, calculates and returns the reverse post-order
+// ordering of the blocks.  The blocks are then disassembled in that order for
+// readability.
+std::vector<uint32_t> OrderBlocks(
+    ControlFlowGraph& cfg,
+    const std::unordered_map<uint32_t, uint32_t>& id_to_index) {
+  std::vector<uint32_t> post_order;
+
+  // Nest level of a function's first block is 0.
+  cfg.blocks[0].nest_level = 0;
+  cfg.blocks[0].nest_level_assigned = true;
+
+  // Stack of block indices as they are visited.
+  std::stack<StackEntry> dfs_stack;
+  dfs_stack.push({0, false});
+
+  std::set<uint32_t> visited;
+
+  while (!dfs_stack.empty()) {
+    const uint32_t block_index = dfs_stack.top().block_index;
+    const bool post_visit = dfs_stack.top().post_visit;
+    dfs_stack.pop();
+
+    // If this is the second time the block is visited, that's the post-order
+    // visit.
+    if (post_visit) {
+      post_order.push_back(block_index);
+      continue;
+    }
+
+    // If already visited, another path got to it first (like a case
+    // fallthrough), avoid reprocessing it.
+    if (visited.count(block_index) > 0) {
+      continue;
+    }
+    visited.insert(block_index);
+
+    // Push it back in the stack for post-order visit
+    dfs_stack.push({block_index, true});
+
+    SingleBlock& block = cfg.blocks[block_index];
+
+    // Assign nest levels of successors right away.  The successors are either
+    // nested under this block, or are back or forward edges to blocks outside
+    // this nesting level (no farther than the merge block), whose nesting
+    // levels are already assigned before this block is visited.
+    NestSuccessors(cfg, block, id_to_index);
+    block.reachable = true;
+
+    // The post-order visit yields the order in which the blocks are naturally
+    // ordered _backwards_. So blocks to be ordered last should be visited
+    // first.  In other words, they should be pushed to the DFS stack last.
+    VisitSuccesor(&dfs_stack, id_to_index, block.successors.true_block_id);
+    VisitSuccesor(&dfs_stack, id_to_index, block.successors.false_block_id);
+    VisitSuccesor(&dfs_stack, id_to_index, block.successors.body_block_id);
+    VisitSuccesor(&dfs_stack, id_to_index, block.successors.next_block_id);
+    for (uint32_t case_block_id : block.successors.case_block_ids) {
+      VisitSuccesor(&dfs_stack, id_to_index, case_block_id);
+    }
+    VisitSuccesor(&dfs_stack, id_to_index, block.successors.continue_block_id);
+    VisitSuccesor(&dfs_stack, id_to_index, block.successors.merge_block_id);
+  }
+
+  std::vector<uint32_t> order(post_order.rbegin(), post_order.rend());
+
+  // Finally, dump all unreachable blocks at the end
+  for (size_t index = 0; index < cfg.blocks.size(); ++index) {
+    SingleBlock& block = cfg.blocks[index];
+
+    if (!block.reachable) {
+      order.push_back(static_cast<uint32_t>(index));
+      block.nest_level = 0;
+      block.nest_level_assigned = true;
+    }
+  }
+
+  return order;
+}
+
+void Disassembler::EmitCFG() {
+  // Build the CFG edges.  At the same time, build an ID->block index map to
+  // simplify building the CFG edges.
+  const std::unordered_map<uint32_t, uint32_t> id_to_index =
+      BuildControlFlowGraph(current_function_cfg_);
+
+  // Walk the CFG in reverse post-order to find the best ordering of blocks for
+  // presentation
+  std::vector<uint32_t> block_order =
+      OrderBlocks(current_function_cfg_, id_to_index);
+  assert(block_order.size() == current_function_cfg_.blocks.size());
+
+  // Walk the CFG either in block order or input order based on whether the
+  // reorder_blocks_ option is given.
+  for (uint32_t index = 0; index < current_function_cfg_.blocks.size();
+       ++index) {
+    const uint32_t block_index = reorder_blocks_ ? block_order[index] : index;
+    const SingleBlock& block = current_function_cfg_.blocks[block_index];
+
+    // Emit instructions for this block
+    size_t byte_offset = block.byte_offset;
+    assert(block.nest_level_assigned);
+
+    for (const ParsedInstruction& inst : block.instructions) {
+      instruction_disassembler_.EmitInstructionInBlock(*inst.get(), byte_offset,
+                                                       block.nest_level);
+      byte_offset += inst.get()->num_words * sizeof(uint32_t);
+    }
+  }
+
+  current_function_cfg_.blocks.clear();
+}
+
 spv_result_t Disassembler::SaveTextResult(spv_text* text_result) const {
   if (!print_) {
     size_t length = text_.str().size();
@@ -194,7 +598,29 @@ spv_result_t DisassembleTargetInstruction(
   return SPV_SUCCESS;
 }
 
+uint32_t GetLineLengthWithoutColor(const std::string line) {
+  // Currently, every added color is in the form \x1b...m, so instead of doing a
+  // lot of string comparisons with spvtools::clr::* strings, we just ignore
+  // those ranges.
+  uint32_t length = 0;
+  for (size_t i = 0; i < line.size(); ++i) {
+    if (line[i] == '\x1b') {
+      do {
+        ++i;
+      } while (i < line.size() && line[i] != 'm');
+      continue;
+    }
+
+    ++length;
+  }
+
+  return length;
+}
+
 constexpr int kStandardIndent = 15;
+constexpr int kBlockNestIndent = 2;
+constexpr int kBlockBodyIndentOffset = 2;
+constexpr uint32_t kCommentColumn = 50;
 }  // namespace
 
 namespace disassemble {
@@ -209,10 +635,13 @@ InstructionDisassembler::InstructionDisassembler(const AssemblyGrammar& grammar,
       indent_(spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_INDENT, options)
                   ? kStandardIndent
                   : 0),
+      nested_indent_(
+          spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT, options)),
       comment_(spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_COMMENT, options)),
       show_byte_offset_(
           spvIsInBitfield(SPV_BINARY_TO_TEXT_OPTION_SHOW_BYTE_OFFSET, options)),
-      name_mapper_(std::move(name_mapper)) {}
+      name_mapper_(std::move(name_mapper)),
+      last_instruction_comment_alignment_(0) {}
 
 void InstructionDisassembler::EmitHeaderSpirv() { stream_ << "; SPIR-V\n"; }
 
@@ -244,55 +673,160 @@ void InstructionDisassembler::EmitHeaderSchema(uint32_t schema) {
 
 void InstructionDisassembler::EmitInstruction(
     const spv_parsed_instruction_t& inst, size_t inst_byte_offset) {
+  EmitInstructionImpl(inst, inst_byte_offset, 0, false);
+}
+
+void InstructionDisassembler::EmitInstructionInBlock(
+    const spv_parsed_instruction_t& inst, size_t inst_byte_offset,
+    uint32_t block_indent) {
+  EmitInstructionImpl(inst, inst_byte_offset, block_indent, true);
+}
+
+void InstructionDisassembler::EmitInstructionImpl(
+    const spv_parsed_instruction_t& inst, size_t inst_byte_offset,
+    uint32_t block_indent, bool is_in_block) {
   auto opcode = static_cast<spv::Op>(inst.opcode);
 
+  // To better align the comments (if any), write the instruction to a line
+  // first so its length can be readily available.
+  std::ostringstream line;
+
+  if (nested_indent_ && opcode == spv::Op::OpLabel) {
+    // Separate the blocks by an empty line to make them easier to separate
+    stream_ << std::endl;
+  }
+
   if (inst.result_id) {
     SetBlue();
     const std::string id_name = name_mapper_(inst.result_id);
     if (indent_)
-      stream_ << std::setw(std::max(0, indent_ - 3 - int(id_name.size())));
-    stream_ << "%" << id_name;
+      line << std::setw(std::max(0, indent_ - 3 - int(id_name.size())));
+    line << "%" << id_name;
     ResetColor();
-    stream_ << " = ";
+    line << " = ";
   } else {
-    stream_ << std::string(indent_, ' ');
+    line << std::string(indent_, ' ');
+  }
+
+  if (nested_indent_ && is_in_block) {
+    // Output OpLabel at the specified nest level, and instructions inside
+    // blocks nested a little more.
+    uint32_t indent = block_indent;
+    bool body_indent = opcode != spv::Op::OpLabel;
+
+    line << std::string(
+        indent * kBlockNestIndent + (body_indent ? kBlockBodyIndentOffset : 0),
+        ' ');
   }
 
-  stream_ << "Op" << spvOpcodeString(opcode);
+  line << "Op" << spvOpcodeString(opcode);
 
   for (uint16_t i = 0; i < inst.num_operands; i++) {
     const spv_operand_type_t type = inst.operands[i].type;
     assert(type != SPV_OPERAND_TYPE_NONE);
     if (type == SPV_OPERAND_TYPE_RESULT_ID) continue;
-    stream_ << " ";
-    EmitOperand(inst, i);
+    line << " ";
+    EmitOperand(line, inst, i);
+  }
+
+  // For the sake of comment generation, store information from some
+  // instructions for the future.
+  if (comment_) {
+    GenerateCommentForDecoratedId(inst);
+  }
+
+  std::ostringstream comments;
+  const char* comment_separator = "";
+
+  if (show_byte_offset_) {
+    SetGrey(comments);
+    auto saved_flags = comments.flags();
+    auto saved_fill = comments.fill();
+    comments << comment_separator << "0x" << std::setw(8) << std::hex
+             << std::setfill('0') << inst_byte_offset;
+    comments.flags(saved_flags);
+    comments.fill(saved_fill);
+    ResetColor(comments);
+    comment_separator = ", ";
   }
 
   if (comment_ && opcode == spv::Op::OpName) {
     const spv_parsed_operand_t& operand = inst.operands[0];
     const uint32_t word = inst.words[operand.offset];
-    stream_ << "  ; id %" << word;
+    comments << comment_separator << "id %" << word;
+    comment_separator = ", ";
   }
 
-  if (show_byte_offset_) {
-    SetGrey();
-    auto saved_flags = stream_.flags();
-    auto saved_fill = stream_.fill();
-    stream_ << " ; 0x" << std::setw(8) << std::hex << std::setfill('0')
-            << inst_byte_offset;
-    stream_.flags(saved_flags);
-    stream_.fill(saved_fill);
-    ResetColor();
+  if (comment_ && inst.result_id && id_comments_.count(inst.result_id) > 0) {
+    comments << comment_separator << id_comments_[inst.result_id].str();
+    comment_separator = ", ";
+  }
+
+  stream_ << line.str();
+
+  if (!comments.str().empty()) {
+    // Align the comments
+    const uint32_t line_length = GetLineLengthWithoutColor(line.str());
+    uint32_t align = std::max(
+        {line_length + 2, last_instruction_comment_alignment_, kCommentColumn});
+    // Round up the alignment to a multiple of 4 for more niceness.
+    align = (align + 3) & ~0x3u;
+    last_instruction_comment_alignment_ = align;
+
+    stream_ << std::string(align - line_length, ' ') << "; " << comments.str();
+  } else {
+    last_instruction_comment_alignment_ = 0;
   }
+
   stream_ << "\n";
 }
 
+void InstructionDisassembler::GenerateCommentForDecoratedId(
+    const spv_parsed_instruction_t& inst) {
+  assert(comment_);
+  auto opcode = static_cast<spv::Op>(inst.opcode);
+
+  std::ostringstream partial;
+  uint32_t id = 0;
+  const char* separator = "";
+
+  switch (opcode) {
+    case spv::Op::OpDecorate:
+      // Take everything after `OpDecorate %id` and associate it with id.
+      id = inst.words[inst.operands[0].offset];
+      for (uint16_t i = 1; i < inst.num_operands; i++) {
+        partial << separator;
+        separator = " ";
+        EmitOperand(partial, inst, i);
+      }
+      break;
+    default:
+      break;
+  }
+
+  if (id == 0) {
+    return;
+  }
+
+  // Add the new comment to the comments of this id
+  std::ostringstream& id_comment = id_comments_[id];
+  if (!id_comment.str().empty()) {
+    id_comment << ", ";
+  }
+  id_comment << partial.str();
+}
+
 void InstructionDisassembler::EmitSectionComment(
     const spv_parsed_instruction_t& inst, bool& inserted_decoration_space,
     bool& inserted_debug_space, bool& inserted_type_space) {
   auto opcode = static_cast<spv::Op>(inst.opcode);
   if (comment_ && opcode == spv::Op::OpFunction) {
     stream_ << std::endl;
+    if (nested_indent_) {
+      // Double the empty lines between Function sections since nested_indent_
+      // also separates blocks by a blank.
+      stream_ << std::endl;
+    }
     stream_ << std::string(indent_, ' ');
     stream_ << "; Function " << name_mapper_(inst.result_id) << std::endl;
   }
@@ -316,36 +850,37 @@ void InstructionDisassembler::EmitSectionComment(
   }
 }
 
-void InstructionDisassembler::EmitOperand(const spv_parsed_instruction_t& inst,
-                                          const uint16_t operand_index) {
+void InstructionDisassembler::EmitOperand(std::ostream& stream,
+                                          const spv_parsed_instruction_t& inst,
+                                          const uint16_t operand_index) const {
   assert(operand_index < inst.num_operands);
   const spv_parsed_operand_t& operand = inst.operands[operand_index];
   const uint32_t word = inst.words[operand.offset];
   switch (operand.type) {
     case SPV_OPERAND_TYPE_RESULT_ID:
       assert(false && "<result-id> is not supposed to be handled here");
-      SetBlue();
-      stream_ << "%" << name_mapper_(word);
+      SetBlue(stream);
+      stream << "%" << name_mapper_(word);
       break;
     case SPV_OPERAND_TYPE_ID:
     case SPV_OPERAND_TYPE_TYPE_ID:
     case SPV_OPERAND_TYPE_SCOPE_ID:
     case SPV_OPERAND_TYPE_MEMORY_SEMANTICS_ID:
-      SetYellow();
-      stream_ << "%" << name_mapper_(word);
+      SetYellow(stream);
+      stream << "%" << name_mapper_(word);
       break;
     case SPV_OPERAND_TYPE_EXTENSION_INSTRUCTION_NUMBER: {
       spv_ext_inst_desc ext_inst;
-      SetRed();
+      SetRed(stream);
       if (grammar_.lookupExtInst(inst.ext_inst_type, word, &ext_inst) ==
           SPV_SUCCESS) {
-        stream_ << ext_inst->name;
+        stream << ext_inst->name;
       } else {
         if (!spvExtInstIsNonSemantic(inst.ext_inst_type)) {
           assert(false && "should have caught this earlier");
         } else {
           // for non-semantic instruction sets we can just print the number
-          stream_ << word;
+          stream << word;
         }
       }
     } break;
@@ -353,27 +888,27 @@ void InstructionDisassembler::EmitOperand(const spv_parsed_instruction_t& inst,
       spv_opcode_desc opcode_desc;
       if (grammar_.lookupOpcode(spv::Op(word), &opcode_desc))
         assert(false && "should have caught this earlier");
-      SetRed();
-      stream_ << opcode_desc->name;
+      SetRed(stream);
+      stream << opcode_desc->name;
     } break;
     case SPV_OPERAND_TYPE_LITERAL_INTEGER:
     case SPV_OPERAND_TYPE_TYPED_LITERAL_NUMBER:
     case SPV_OPERAND_TYPE_LITERAL_FLOAT: {
-      SetRed();
-      EmitNumericLiteral(&stream_, inst, operand);
-      ResetColor();
+      SetRed(stream);
+      EmitNumericLiteral(&stream, inst, operand);
+      ResetColor(stream);
     } break;
     case SPV_OPERAND_TYPE_LITERAL_STRING: {
-      stream_ << "\"";
-      SetGreen();
+      stream << "\"";
+      SetGreen(stream);
 
       std::string str = spvDecodeLiteralStringOperand(inst, operand_index);
       for (char const& c : str) {
-        if (c == '"' || c == '\\') stream_ << '\\';
-        stream_ << c;
+        if (c == '"' || c == '\\') stream << '\\';
+        stream << c;
       }
-      ResetColor();
-      stream_ << '"';
+      ResetColor(stream);
+      stream << '"';
     } break;
     case SPV_OPERAND_TYPE_CAPABILITY:
     case SPV_OPERAND_TYPE_SOURCE_LANGUAGE:
@@ -411,11 +946,12 @@ void InstructionDisassembler::EmitOperand(const spv_parsed_instruction_t& inst,
     case SPV_OPERAND_TYPE_FPDENORM_MODE:
     case SPV_OPERAND_TYPE_FPOPERATION_MODE:
     case SPV_OPERAND_TYPE_QUANTIZATION_MODES:
+    case SPV_OPERAND_TYPE_FPENCODING:
     case SPV_OPERAND_TYPE_OVERFLOW_MODES: {
       spv_operand_desc entry;
       if (grammar_.lookupOperand(operand.type, word, &entry))
         assert(false && "should have caught this earlier");
-      stream_ << entry->name;
+      stream << entry->name;
     } break;
     case SPV_OPERAND_TYPE_FP_FAST_MATH_MODE:
     case SPV_OPERAND_TYPE_FUNCTION_CONTROL:
@@ -425,26 +961,28 @@ void InstructionDisassembler::EmitOperand(const spv_parsed_instruction_t& inst,
     case SPV_OPERAND_TYPE_SELECTION_CONTROL:
     case SPV_OPERAND_TYPE_DEBUG_INFO_FLAGS:
     case SPV_OPERAND_TYPE_CLDEBUG100_DEBUG_INFO_FLAGS:
-      EmitMaskOperand(operand.type, word);
+    case SPV_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS:
+      EmitMaskOperand(stream, operand.type, word);
       break;
     default:
       if (spvOperandIsConcreteMask(operand.type)) {
-        EmitMaskOperand(operand.type, word);
+        EmitMaskOperand(stream, operand.type, word);
       } else if (spvOperandIsConcrete(operand.type)) {
         spv_operand_desc entry;
         if (grammar_.lookupOperand(operand.type, word, &entry))
           assert(false && "should have caught this earlier");
-        stream_ << entry->name;
+        stream << entry->name;
       } else {
         assert(false && "unhandled or invalid case");
       }
       break;
   }
-  ResetColor();
+  ResetColor(stream);
 }
 
-void InstructionDisassembler::EmitMaskOperand(const spv_operand_type_t type,
-                                              const uint32_t word) {
+void InstructionDisassembler::EmitMaskOperand(std::ostream& stream,
+                                              const spv_operand_type_t type,
+                                              const uint32_t word) const {
   // Scan the mask from least significant bit to most significant bit.  For each
   // set bit, emit the name of that bit. Separate multiple names with '|'.
   uint32_t remaining_word = word;
@@ -456,8 +994,8 @@ void InstructionDisassembler::EmitMaskOperand(const spv_operand_type_t type,
       spv_operand_desc entry;
       if (grammar_.lookupOperand(type, mask, &entry))
         assert(false && "should have caught this earlier");
-      if (num_emitted) stream_ << "|";
-      stream_ << entry->name;
+      if (num_emitted) stream << "|";
+      stream << entry->name;
       num_emitted++;
     }
   }
@@ -466,28 +1004,35 @@ void InstructionDisassembler::EmitMaskOperand(const spv_operand_type_t type,
     // of the 0 value. In many cases, that's "None".
     spv_operand_desc entry;
     if (SPV_SUCCESS == grammar_.lookupOperand(type, 0, &entry))
-      stream_ << entry->name;
+      stream << entry->name;
   }
 }
 
-void InstructionDisassembler::ResetColor() {
-  if (color_) stream_ << spvtools::clr::reset{print_};
+void InstructionDisassembler::ResetColor(std::ostream& stream) const {
+  if (color_) stream << spvtools::clr::reset{print_};
 }
-void InstructionDisassembler::SetGrey() {
-  if (color_) stream_ << spvtools::clr::grey{print_};
+void InstructionDisassembler::SetGrey(std::ostream& stream) const {
+  if (color_) stream << spvtools::clr::grey{print_};
 }
-void InstructionDisassembler::SetBlue() {
-  if (color_) stream_ << spvtools::clr::blue{print_};
+void InstructionDisassembler::SetBlue(std::ostream& stream) const {
+  if (color_) stream << spvtools::clr::blue{print_};
 }
-void InstructionDisassembler::SetYellow() {
-  if (color_) stream_ << spvtools::clr::yellow{print_};
+void InstructionDisassembler::SetYellow(std::ostream& stream) const {
+  if (color_) stream << spvtools::clr::yellow{print_};
 }
-void InstructionDisassembler::SetRed() {
-  if (color_) stream_ << spvtools::clr::red{print_};
+void InstructionDisassembler::SetRed(std::ostream& stream) const {
+  if (color_) stream << spvtools::clr::red{print_};
 }
-void InstructionDisassembler::SetGreen() {
-  if (color_) stream_ << spvtools::clr::green{print_};
+void InstructionDisassembler::SetGreen(std::ostream& stream) const {
+  if (color_) stream << spvtools::clr::green{print_};
 }
+
+void InstructionDisassembler::ResetColor() { ResetColor(stream_); }
+void InstructionDisassembler::SetGrey() { SetGrey(stream_); }
+void InstructionDisassembler::SetBlue() { SetBlue(stream_); }
+void InstructionDisassembler::SetYellow() { SetYellow(stream_); }
+void InstructionDisassembler::SetRed() { SetRed(stream_); }
+void InstructionDisassembler::SetGreen() { SetGreen(stream_); }
 }  // namespace disassemble
 
 std::string spvInstructionBinaryToText(const spv_target_env env,
diff --git a/source/disassemble.h b/source/disassemble.h
index b520a1ea..b6d13c64 100644
--- a/source/disassemble.h
+++ b/source/disassemble.h
@@ -15,7 +15,8 @@
 #ifndef SOURCE_DISASSEMBLE_H_
 #define SOURCE_DISASSEMBLE_H_
 
-#include <iosfwd>
+#include <ios>
+#include <sstream>
 #include <string>
 
 #include "source/name_mapper.h"
@@ -57,6 +58,11 @@ class InstructionDisassembler {
   // Emits the assembly text for the given instruction.
   void EmitInstruction(const spv_parsed_instruction_t& inst,
                        size_t inst_byte_offset);
+  // Same as EmitInstruction, but only for block instructions (including
+  // OpLabel) and useful for nested indentation.  If nested indentation is not
+  // desired, EmitInstruction can still be used for block instructions.
+  void EmitInstructionInBlock(const spv_parsed_instruction_t& inst,
+                              size_t inst_byte_offset, uint32_t block_indent);
 
   // Emits a comment between different sections of the module.
   void EmitSectionComment(const spv_parsed_instruction_t& inst,
@@ -74,22 +80,46 @@ class InstructionDisassembler {
   void SetGreen();
 
  private:
+  void ResetColor(std::ostream& stream) const;
+  void SetGrey(std::ostream& stream) const;
+  void SetBlue(std::ostream& stream) const;
+  void SetYellow(std::ostream& stream) const;
+  void SetRed(std::ostream& stream) const;
+  void SetGreen(std::ostream& stream) const;
+
+  void EmitInstructionImpl(const spv_parsed_instruction_t& inst,
+                           size_t inst_byte_offset, uint32_t block_indent,
+                           bool is_in_block);
+
   // Emits an operand for the given instruction, where the instruction
   // is at offset words from the start of the binary.
-  void EmitOperand(const spv_parsed_instruction_t& inst,
-                   const uint16_t operand_index);
+  void EmitOperand(std::ostream& stream, const spv_parsed_instruction_t& inst,
+                   uint16_t operand_index) const;
 
   // Emits a mask expression for the given mask word of the specified type.
-  void EmitMaskOperand(const spv_operand_type_t type, const uint32_t word);
+  void EmitMaskOperand(std::ostream& stream, spv_operand_type_t type,
+                       uint32_t word) const;
+
+  // Generate part of the instruction as a comment to be added to
+  // |id_comments_|.
+  void GenerateCommentForDecoratedId(const spv_parsed_instruction_t& inst);
 
   const spvtools::AssemblyGrammar& grammar_;
   std::ostream& stream_;
-  const bool print_;   // Should we also print to the standard output stream?
-  const bool color_;   // Should we print in colour?
-  const int indent_;   // How much to indent. 0 means don't indent
-  const int comment_;  // Should we comment the source
+  const bool print_;  // Should we also print to the standard output stream?
+  const bool color_;  // Should we print in colour?
+  const int indent_;  // How much to indent. 0 means don't indent
+  const bool nested_indent_;     // Whether indentation should indicate nesting
+  const int comment_;            // Should we comment the source
   const bool show_byte_offset_;  // Should we print byte offset, in hex?
   spvtools::NameMapper name_mapper_;
+
+  // Some comments are generated as instructions (such as OpDecorate) are
+  // visited so that when the instruction with that result id is visited, the
+  // comment can be output.
+  std::unordered_map<uint32_t, std::ostringstream> id_comments_;
+  // Align the comments in consecutive lines for more readability.
+  uint32_t last_instruction_comment_alignment_;
 };
 
 }  // namespace disassemble
diff --git a/source/ext_inst.cpp b/source/ext_inst.cpp
index 4e279545..f2ff63fc 100644
--- a/source/ext_inst.cpp
+++ b/source/ext_inst.cpp
@@ -30,6 +30,7 @@
 #include "glsl.std.450.insts.inc"
 #include "nonsemantic.clspvreflection.insts.inc"
 #include "nonsemantic.shader.debuginfo.100.insts.inc"
+#include "nonsemantic.vkspreflection.insts.inc"
 #include "opencl.debuginfo.100.insts.inc"
 #include "opencl.std.insts.inc"
 
@@ -62,6 +63,9 @@ static const spv_ext_inst_group_t kGroups_1_0[] = {
     {SPV_EXT_INST_TYPE_NONSEMANTIC_CLSPVREFLECTION,
      ARRAY_SIZE(nonsemantic_clspvreflection_entries),
      nonsemantic_clspvreflection_entries},
+    {SPV_EXT_INST_TYPE_NONSEMANTIC_VKSPREFLECTION,
+     ARRAY_SIZE(nonsemantic_vkspreflection_entries),
+     nonsemantic_vkspreflection_entries},
 };
 
 static const spv_ext_inst_table_t kTable_1_0 = {ARRAY_SIZE(kGroups_1_0),
@@ -98,6 +102,7 @@ spv_result_t spvExtInstTableGet(spv_ext_inst_table* pExtInstTable,
     case SPV_ENV_VULKAN_1_2:
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       *pExtInstTable = &kTable_1_0;
       return SPV_SUCCESS;
     default:
@@ -138,6 +143,9 @@ spv_ext_inst_type_t spvExtInstImportTypeGet(const char* name) {
   if (!strncmp("NonSemantic.ClspvReflection.", name, 28)) {
     return SPV_EXT_INST_TYPE_NONSEMANTIC_CLSPVREFLECTION;
   }
+  if (!strncmp("NonSemantic.VkspReflection.", name, 27)) {
+    return SPV_EXT_INST_TYPE_NONSEMANTIC_VKSPREFLECTION;
+  }
   // ensure to add any known non-semantic extended instruction sets
   // above this point, and update spvExtInstIsNonSemantic()
   if (!strncmp("NonSemantic.", name, 12)) {
@@ -149,7 +157,8 @@ spv_ext_inst_type_t spvExtInstImportTypeGet(const char* name) {
 bool spvExtInstIsNonSemantic(const spv_ext_inst_type_t type) {
   if (type == SPV_EXT_INST_TYPE_NONSEMANTIC_UNKNOWN ||
       type == SPV_EXT_INST_TYPE_NONSEMANTIC_SHADER_DEBUGINFO_100 ||
-      type == SPV_EXT_INST_TYPE_NONSEMANTIC_CLSPVREFLECTION) {
+      type == SPV_EXT_INST_TYPE_NONSEMANTIC_CLSPVREFLECTION ||
+      type == SPV_EXT_INST_TYPE_NONSEMANTIC_VKSPREFLECTION) {
     return true;
   }
   return false;
diff --git a/source/fuzz/transformation_add_no_contraction_decoration.cpp b/source/fuzz/transformation_add_no_contraction_decoration.cpp
index 07a31e5c..87393e95 100644
--- a/source/fuzz/transformation_add_no_contraction_decoration.cpp
+++ b/source/fuzz/transformation_add_no_contraction_decoration.cpp
@@ -36,6 +36,11 @@ bool TransformationAddNoContractionDecoration::IsApplicable(
   if (!instr) {
     return false;
   }
+  // |instr| must not be decorated with NoContraction.
+  if (ir_context->get_decoration_mgr()->HasDecoration(
+          message_.result_id(), spv::Decoration::NoContraction)) {
+    return false;
+  }
   // The instruction must be arithmetic.
   return IsArithmetic(instr->opcode());
 }
diff --git a/source/fuzz/transformation_add_relaxed_decoration.cpp b/source/fuzz/transformation_add_relaxed_decoration.cpp
index 6cd4ecbb..601546c9 100644
--- a/source/fuzz/transformation_add_relaxed_decoration.cpp
+++ b/source/fuzz/transformation_add_relaxed_decoration.cpp
@@ -36,6 +36,11 @@ bool TransformationAddRelaxedDecoration::IsApplicable(
   if (!instr) {
     return false;
   }
+  // |instr| must not be decorated with RelaxedPrecision.
+  if (ir_context->get_decoration_mgr()->HasDecoration(
+          message_.result_id(), spv::Decoration::RelaxedPrecision)) {
+    return false;
+  }
   opt::BasicBlock* cur_block = ir_context->get_instr_block(instr);
   // The instruction must have a block.
   if (cur_block == nullptr) {
@@ -46,6 +51,7 @@ bool TransformationAddRelaxedDecoration::IsApplicable(
           cur_block->id()))) {
     return false;
   }
+
   // The instruction must be numeric.
   return IsNumeric(instr->opcode());
 }
diff --git a/source/link/linker.cpp b/source/link/linker.cpp
index 58930e45..e6aa72e3 100644
--- a/source/link/linker.cpp
+++ b/source/link/linker.cpp
@@ -31,6 +31,7 @@
 #include "source/opt/build_module.h"
 #include "source/opt/compact_ids_pass.h"
 #include "source/opt/decoration_manager.h"
+#include "source/opt/ir_builder.h"
 #include "source/opt/ir_loader.h"
 #include "source/opt/pass_manager.h"
 #include "source/opt/remove_duplicates_pass.h"
@@ -46,12 +47,14 @@ namespace spvtools {
 namespace {
 
 using opt::Instruction;
+using opt::InstructionBuilder;
 using opt::IRContext;
 using opt::Module;
 using opt::PassManager;
 using opt::RemoveDuplicatesPass;
 using opt::analysis::DecorationManager;
 using opt::analysis::DefUseManager;
+using opt::analysis::Function;
 using opt::analysis::Type;
 using opt::analysis::TypeManager;
 
@@ -126,6 +129,7 @@ spv_result_t GetImportExportPairs(const MessageConsumer& consumer,
 // checked.
 spv_result_t CheckImportExportCompatibility(const MessageConsumer& consumer,
                                             const LinkageTable& linkings_to_do,
+                                            bool allow_ptr_type_mismatch,
                                             opt::IRContext* context);
 
 // Remove linkage specific instructions, such as prototypes of imported
@@ -502,6 +506,7 @@ spv_result_t GetImportExportPairs(const MessageConsumer& consumer,
 
 spv_result_t CheckImportExportCompatibility(const MessageConsumer& consumer,
                                             const LinkageTable& linkings_to_do,
+                                            bool allow_ptr_type_mismatch,
                                             opt::IRContext* context) {
   spv_position_t position = {};
 
@@ -513,7 +518,34 @@ spv_result_t CheckImportExportCompatibility(const MessageConsumer& consumer,
         type_manager.GetType(linking_entry.imported_symbol.type_id);
     Type* exported_symbol_type =
         type_manager.GetType(linking_entry.exported_symbol.type_id);
-    if (!(*imported_symbol_type == *exported_symbol_type))
+    if (!(*imported_symbol_type == *exported_symbol_type)) {
+      Function* imported_symbol_type_func = imported_symbol_type->AsFunction();
+      Function* exported_symbol_type_func = exported_symbol_type->AsFunction();
+
+      if (imported_symbol_type_func && exported_symbol_type_func) {
+        const auto& imported_params = imported_symbol_type_func->param_types();
+        const auto& exported_params = exported_symbol_type_func->param_types();
+        // allow_ptr_type_mismatch allows linking functions where the pointer
+        // type of arguments doesn't match. Everything else still needs to be
+        // equal. This is to workaround LLVM-17+ not having typed pointers and
+        // generated SPIR-Vs not knowing the actual pointer types in some cases.
+        if (allow_ptr_type_mismatch &&
+            imported_params.size() == exported_params.size()) {
+          bool correct = true;
+          for (size_t i = 0; i < imported_params.size(); i++) {
+            const auto& imported_param = imported_params[i];
+            const auto& exported_param = exported_params[i];
+
+            if (!imported_param->IsSame(exported_param) &&
+                (imported_param->kind() != Type::kPointer ||
+                 exported_param->kind() != Type::kPointer)) {
+              correct = false;
+              break;
+            }
+          }
+          if (correct) continue;
+        }
+      }
       return DiagnosticStream(position, consumer, "", SPV_ERROR_INVALID_BINARY)
              << "Type mismatch on symbol \""
              << linking_entry.imported_symbol.name
@@ -521,6 +553,7 @@ spv_result_t CheckImportExportCompatibility(const MessageConsumer& consumer,
              << linking_entry.imported_symbol.id
              << " and exported variable/function %"
              << linking_entry.exported_symbol.id << ".";
+    }
   }
 
   // Ensure the import and export decorations are similar
@@ -696,6 +729,57 @@ spv_result_t VerifyLimits(const MessageConsumer& consumer,
   return SPV_SUCCESS;
 }
 
+spv_result_t FixFunctionCallTypes(opt::IRContext& context,
+                                  const LinkageTable& linkings) {
+  auto mod = context.module();
+  const auto type_manager = context.get_type_mgr();
+  const auto def_use_mgr = context.get_def_use_mgr();
+
+  for (auto& func : *mod) {
+    func.ForEachInst([&](Instruction* inst) {
+      if (inst->opcode() != spv::Op::OpFunctionCall) return;
+      opt::Operand& target = inst->GetInOperand(0);
+
+      // only fix calls to imported functions
+      auto linking = std::find_if(
+          linkings.begin(), linkings.end(), [&](const auto& entry) {
+            return entry.exported_symbol.id == target.AsId();
+          });
+      if (linking == linkings.end()) return;
+
+      auto builder = InstructionBuilder(&context, inst);
+      for (uint32_t i = 1; i < inst->NumInOperands(); ++i) {
+        auto exported_func_param =
+            def_use_mgr->GetDef(linking->exported_symbol.parameter_ids[i - 1]);
+        const Type* target_type =
+            type_manager->GetType(exported_func_param->type_id());
+        if (target_type->kind() != Type::kPointer) continue;
+
+        opt::Operand& arg = inst->GetInOperand(i);
+        const Type* param_type =
+            type_manager->GetType(def_use_mgr->GetDef(arg.AsId())->type_id());
+
+        // No need to cast if it already matches
+        if (*param_type == *target_type) continue;
+
+        auto new_id = context.TakeNextId();
+
+        // cast to the expected pointer type
+        builder.AddInstruction(MakeUnique<opt::Instruction>(
+            &context, spv::Op::OpBitcast, exported_func_param->type_id(),
+            new_id,
+            opt::Instruction::OperandList(
+                {{SPV_OPERAND_TYPE_ID, {arg.AsId()}}})));
+
+        inst->SetInOperand(i, {new_id});
+      }
+    });
+  }
+  context.InvalidateAnalyses(opt::IRContext::kAnalysisDefUse |
+                             opt::IRContext::kAnalysisInstrToBlockMapping);
+  return SPV_SUCCESS;
+}
+
 }  // namespace
 
 spv_result_t Link(const Context& context,
@@ -773,7 +857,14 @@ spv_result_t Link(const Context& context, const uint32_t* const* binaries,
     if (res != SPV_SUCCESS) return res;
   }
 
-  // Phase 4: Find the import/export pairs
+  // Phase 4: Remove duplicates
+  PassManager manager;
+  manager.SetMessageConsumer(consumer);
+  manager.AddPass<RemoveDuplicatesPass>();
+  opt::Pass::Status pass_res = manager.Run(&linked_context);
+  if (pass_res == opt::Pass::Status::Failure) return SPV_ERROR_INVALID_DATA;
+
+  // Phase 5: Find the import/export pairs
   LinkageTable linkings_to_do;
   res = GetImportExportPairs(consumer, linked_context,
                              *linked_context.get_def_use_mgr(),
@@ -781,18 +872,12 @@ spv_result_t Link(const Context& context, const uint32_t* const* binaries,
                              options.GetAllowPartialLinkage(), &linkings_to_do);
   if (res != SPV_SUCCESS) return res;
 
-  // Phase 5: Ensure the import and export have the same types and decorations.
-  res =
-      CheckImportExportCompatibility(consumer, linkings_to_do, &linked_context);
+  // Phase 6: Ensure the import and export have the same types and decorations.
+  res = CheckImportExportCompatibility(consumer, linkings_to_do,
+                                       options.GetAllowPtrTypeMismatch(),
+                                       &linked_context);
   if (res != SPV_SUCCESS) return res;
 
-  // Phase 6: Remove duplicates
-  PassManager manager;
-  manager.SetMessageConsumer(consumer);
-  manager.AddPass<RemoveDuplicatesPass>();
-  opt::Pass::Status pass_res = manager.Run(&linked_context);
-  if (pass_res == opt::Pass::Status::Failure) return SPV_ERROR_INVALID_DATA;
-
   // Phase 7: Remove all names and decorations of import variables/functions
   for (const auto& linking_entry : linkings_to_do) {
     linked_context.KillNamesAndDecorates(linking_entry.imported_symbol.id);
@@ -815,21 +900,27 @@ spv_result_t Link(const Context& context, const uint32_t* const* binaries,
                                           &linked_context);
   if (res != SPV_SUCCESS) return res;
 
-  // Phase 10: Compact the IDs used in the module
+  // Phase 10: Optionally fix function call types
+  if (options.GetAllowPtrTypeMismatch()) {
+    res = FixFunctionCallTypes(linked_context, linkings_to_do);
+    if (res != SPV_SUCCESS) return res;
+  }
+
+  // Phase 11: Compact the IDs used in the module
   manager.AddPass<opt::CompactIdsPass>();
   pass_res = manager.Run(&linked_context);
   if (pass_res == opt::Pass::Status::Failure) return SPV_ERROR_INVALID_DATA;
 
-  // Phase 11: Recompute EntryPoint variables
+  // Phase 12: Recompute EntryPoint variables
   manager.AddPass<opt::RemoveUnusedInterfaceVariablesPass>();
   pass_res = manager.Run(&linked_context);
   if (pass_res == opt::Pass::Status::Failure) return SPV_ERROR_INVALID_DATA;
 
-  // Phase 12: Warn if SPIR-V limits were exceeded
+  // Phase 13: Warn if SPIR-V limits were exceeded
   res = VerifyLimits(consumer, linked_context);
   if (res != SPV_SUCCESS) return res;
 
-  // Phase 13: Output the module
+  // Phase 14: Output the module
   linked_context.module()->ToBinary(linked_binary, true);
 
   return SPV_SUCCESS;
diff --git a/source/name_mapper.cpp b/source/name_mapper.cpp
index b2d0f445..7e5f0917 100644
--- a/source/name_mapper.cpp
+++ b/source/name_mapper.cpp
@@ -25,24 +25,15 @@
 #include "source/binary.h"
 #include "source/latest_version_spirv_header.h"
 #include "source/parsed_operand.h"
+#include "source/to_string.h"
 #include "spirv-tools/libspirv.h"
 
 namespace spvtools {
-namespace {
 
-// Converts a uint32_t to its string decimal representation.
-std::string to_string(uint32_t id) {
-  // Use stringstream, since some versions of Android compilers lack
-  // std::to_string.
-  std::stringstream os;
-  os << id;
-  return os.str();
+NameMapper GetTrivialNameMapper() {
+  return [](uint32_t i) { return spvtools::to_string(i); };
 }
 
-}  // anonymous namespace
-
-NameMapper GetTrivialNameMapper() { return to_string; }
-
 FriendlyNameMapper::FriendlyNameMapper(const spv_const_context context,
                                        const uint32_t* code,
                                        const size_t wordCount)
@@ -218,6 +209,7 @@ spv_result_t FriendlyNameMapper::ParseInstruction(
     } break;
     case spv::Op::OpTypeFloat: {
       const auto bit_width = inst.words[2];
+      // TODO: Handle optional fpencoding enum once actually used.
       switch (bit_width) {
         case 16:
           SaveName(result_id, "half");
@@ -255,6 +247,11 @@ spv_result_t FriendlyNameMapper::ParseInstruction(
                                                  inst.words[2]) +
                               "_" + NameForId(inst.words[3]));
       break;
+    case spv::Op::OpTypeUntypedPointerKHR:
+      SaveName(result_id, std::string("_ptr_") +
+                              NameForEnumOperand(SPV_OPERAND_TYPE_STORAGE_CLASS,
+                                                 inst.words[2]));
+      break;
     case spv::Op::OpTypePipe:
       SaveName(result_id,
                std::string("Pipe") +
diff --git a/source/opcode.cpp b/source/opcode.cpp
index 38d1a1be..2b25fc3d 100644
--- a/source/opcode.cpp
+++ b/source/opcode.cpp
@@ -102,7 +102,7 @@ spv_result_t spvOpcodeTableNameLookup(spv_target_env env,
   const auto version = spvVersionForTargetEnv(env);
   for (uint64_t opcodeIndex = 0; opcodeIndex < table->count; ++opcodeIndex) {
     const spv_opcode_desc_t& entry = table->entries[opcodeIndex];
-    // We considers the current opcode as available as long as
+    // We consider the current opcode as available as long as
     // 1. The target environment satisfies the minimal requirement of the
     //    opcode; or
     // 2. There is at least one extension enabling this opcode.
@@ -110,13 +110,34 @@ spv_result_t spvOpcodeTableNameLookup(spv_target_env env,
     // Note that the second rule assumes the extension enabling this instruction
     // is indeed requested in the SPIR-V code; checking that should be
     // validator's work.
-    if (((version >= entry.minVersion && version <= entry.lastVersion) ||
-         entry.numExtensions > 0u || entry.numCapabilities > 0u) &&
-        nameLength == strlen(entry.name) &&
-        !strncmp(name, entry.name, nameLength)) {
-      // NOTE: Found out Opcode!
-      *pEntry = &entry;
-      return SPV_SUCCESS;
+    if ((version >= entry.minVersion && version <= entry.lastVersion) ||
+        entry.numExtensions > 0u || entry.numCapabilities > 0u) {
+      // Exact match case.
+      if (nameLength == strlen(entry.name) &&
+          !strncmp(name, entry.name, nameLength)) {
+        *pEntry = &entry;
+        return SPV_SUCCESS;
+      }
+      // Lack of binary search really hurts here. There isn't an easy filter to
+      // apply before checking aliases since we need to handle promotion from
+      // vendor to KHR/EXT and KHR/EXT to core. It would require a sure-fire way
+      // of dropping suffices. Fortunately, most lookup are based on token
+      // value.
+      //
+      // If this was a binary search we could iterate between the lower and
+      // upper bounds.
+      if (entry.numAliases > 0) {
+        for (uint32_t aliasIndex = 0; aliasIndex < entry.numAliases;
+             aliasIndex++) {
+          // Skip Op prefix. Should this be encoded in the table instead?
+          const auto alias = entry.aliases[aliasIndex] + 2;
+          const size_t aliasLength = strlen(alias);
+          if (nameLength == aliasLength && !strncmp(name, alias, nameLength)) {
+            *pEntry = &entry;
+            return SPV_SUCCESS;
+          }
+        }
+      }
     }
   }
 
@@ -133,8 +154,8 @@ spv_result_t spvOpcodeTableValueLookup(spv_target_env env,
   const auto beg = table->entries;
   const auto end = table->entries + table->count;
 
-  spv_opcode_desc_t needle = {"",    opcode, 0, nullptr, 0,   {},
-                              false, false,  0, nullptr, ~0u, ~0u};
+  spv_opcode_desc_t needle = {"", opcode, 0,     nullptr, 0,       {},  0,
+                              {}, false,  false, 0,       nullptr, ~0u, ~0u};
 
   auto comp = [](const spv_opcode_desc_t& lhs, const spv_opcode_desc_t& rhs) {
     return lhs.opcode < rhs.opcode;
@@ -189,6 +210,7 @@ const char* spvOpcodeString(const uint32_t opcode) {
   spv_opcode_desc_t needle = {"",    static_cast<spv::Op>(opcode),
                               0,     nullptr,
                               0,     {},
+                              0,     {},
                               false, false,
                               0,     nullptr,
                               ~0u,   ~0u};
@@ -225,6 +247,7 @@ int32_t spvOpcodeIsSpecConstant(const spv::Op opcode) {
     case spv::Op::OpSpecConstantFalse:
     case spv::Op::OpSpecConstant:
     case spv::Op::OpSpecConstantComposite:
+    case spv::Op::OpSpecConstantCompositeReplicateEXT:
     case spv::Op::OpSpecConstantOp:
       return true;
     default:
@@ -238,6 +261,7 @@ int32_t spvOpcodeIsConstant(const spv::Op opcode) {
     case spv::Op::OpConstantFalse:
     case spv::Op::OpConstant:
     case spv::Op::OpConstantComposite:
+    case spv::Op::OpConstantCompositeReplicateEXT:
     case spv::Op::OpConstantSampler:
     case spv::Op::OpConstantNull:
     case spv::Op::OpConstantFunctionPointerINTEL:
@@ -245,6 +269,7 @@ int32_t spvOpcodeIsConstant(const spv::Op opcode) {
     case spv::Op::OpSpecConstantFalse:
     case spv::Op::OpSpecConstant:
     case spv::Op::OpSpecConstantComposite:
+    case spv::Op::OpSpecConstantCompositeReplicateEXT:
     case spv::Op::OpSpecConstantOp:
       return true;
     default:
@@ -273,6 +298,7 @@ int32_t spvOpcodeIsComposite(const spv::Op opcode) {
     case spv::Op::OpTypeMatrix:
     case spv::Op::OpTypeArray:
     case spv::Op::OpTypeStruct:
+    case spv::Op::OpTypeRuntimeArray:
     case spv::Op::OpTypeCooperativeMatrixNV:
     case spv::Op::OpTypeCooperativeMatrixKHR:
       return true;
@@ -284,8 +310,11 @@ int32_t spvOpcodeIsComposite(const spv::Op opcode) {
 bool spvOpcodeReturnsLogicalVariablePointer(const spv::Op opcode) {
   switch (opcode) {
     case spv::Op::OpVariable:
+    case spv::Op::OpUntypedVariableKHR:
     case spv::Op::OpAccessChain:
     case spv::Op::OpInBoundsAccessChain:
+    case spv::Op::OpUntypedAccessChainKHR:
+    case spv::Op::OpUntypedInBoundsAccessChainKHR:
     case spv::Op::OpFunctionParameter:
     case spv::Op::OpImageTexelPointer:
     case spv::Op::OpCopyObject:
@@ -293,8 +322,10 @@ bool spvOpcodeReturnsLogicalVariablePointer(const spv::Op opcode) {
     case spv::Op::OpPhi:
     case spv::Op::OpFunctionCall:
     case spv::Op::OpPtrAccessChain:
+    case spv::Op::OpUntypedPtrAccessChainKHR:
     case spv::Op::OpLoad:
     case spv::Op::OpConstantNull:
+    case spv::Op::OpRawAccessChainNV:
       return true;
     default:
       return false;
@@ -304,11 +335,15 @@ bool spvOpcodeReturnsLogicalVariablePointer(const spv::Op opcode) {
 int32_t spvOpcodeReturnsLogicalPointer(const spv::Op opcode) {
   switch (opcode) {
     case spv::Op::OpVariable:
+    case spv::Op::OpUntypedVariableKHR:
     case spv::Op::OpAccessChain:
     case spv::Op::OpInBoundsAccessChain:
+    case spv::Op::OpUntypedAccessChainKHR:
+    case spv::Op::OpUntypedInBoundsAccessChainKHR:
     case spv::Op::OpFunctionParameter:
     case spv::Op::OpImageTexelPointer:
     case spv::Op::OpCopyObject:
+    case spv::Op::OpRawAccessChainNV:
       return true;
     default:
       return false;
@@ -346,6 +381,9 @@ int32_t spvOpcodeGeneratesType(spv::Op op) {
     // spv::Op::OpTypeAccelerationStructureNV
     case spv::Op::OpTypeRayQueryKHR:
     case spv::Op::OpTypeHitObjectNV:
+    case spv::Op::OpTypeUntypedPointerKHR:
+    case spv::Op::OpTypeTensorLayoutNV:
+    case spv::Op::OpTypeTensorViewNV:
       return true;
     default:
       // In particular, OpTypeForwardPointer does not generate a type,
@@ -715,6 +753,16 @@ bool spvOpcodeIsImageSample(const spv::Op opcode) {
   }
 }
 
+bool spvIsExtendedInstruction(const spv::Op opcode) {
+  switch (opcode) {
+    case spv::Op::OpExtInst:
+    case spv::Op::OpExtInstWithForwardRefsKHR:
+      return true;
+    default:
+      return false;
+  }
+}
+
 std::vector<uint32_t> spvOpcodeMemorySemanticsOperandIndices(spv::Op opcode) {
   switch (opcode) {
     case spv::Op::OpMemoryBarrier:
@@ -754,6 +802,7 @@ bool spvOpcodeIsAccessChain(spv::Op opcode) {
     case spv::Op::OpInBoundsAccessChain:
     case spv::Op::OpPtrAccessChain:
     case spv::Op::OpInBoundsPtrAccessChain:
+    case spv::Op::OpRawAccessChainNV:
       return true;
     default:
       return false;
@@ -776,3 +825,16 @@ bool spvOpcodeIsBit(spv::Op opcode) {
       return false;
   }
 }
+
+bool spvOpcodeGeneratesUntypedPointer(spv::Op opcode) {
+  switch (opcode) {
+    case spv::Op::OpUntypedVariableKHR:
+    case spv::Op::OpUntypedAccessChainKHR:
+    case spv::Op::OpUntypedInBoundsAccessChainKHR:
+    case spv::Op::OpUntypedPtrAccessChainKHR:
+    case spv::Op::OpUntypedInBoundsPtrAccessChainKHR:
+      return true;
+    default:
+      return false;
+  }
+}
diff --git a/source/opcode.h b/source/opcode.h
index 217aeb2b..08fc56d8 100644
--- a/source/opcode.h
+++ b/source/opcode.h
@@ -146,6 +146,9 @@ bool spvOpcodeIsLinearAlgebra(spv::Op opcode);
 // Returns true for opcodes that represent image sample instructions.
 bool spvOpcodeIsImageSample(spv::Op opcode);
 
+// Returns true if the opcode is either OpExtInst or OpExtInstWithForwardRefsKHR
+bool spvIsExtendedInstruction(spv::Op opcode);
+
 // Returns a vector containing the indices of the memory semantics <id>
 // operands for |opcode|.
 std::vector<uint32_t> spvOpcodeMemorySemanticsOperandIndices(spv::Op opcode);
@@ -159,4 +162,7 @@ bool spvOpcodeIsBit(spv::Op opcode);
 // Gets the name of an instruction, without the "Op" prefix.
 const char* spvOpcodeString(const spv::Op opcode);
 
+// Returns true for opcodes that generate an untyped pointer result.
+bool spvOpcodeGeneratesUntypedPointer(spv::Op opcode);
+
 #endif  // SOURCE_OPCODE_H_
diff --git a/source/operand.cpp b/source/operand.cpp
index 6577f8f7..54856466 100644
--- a/source/operand.cpp
+++ b/source/operand.cpp
@@ -64,11 +64,29 @@ spv_result_t spvOperandTableNameLookup(spv_target_env,
       // We consider the current operand as available as long as
       // it is in the grammar.  It might not be *valid* to use,
       // but that should be checked by the validator, not by parsing.
+      //
+      // Exact match case
       if (nameLength == strlen(entry.name) &&
           !strncmp(entry.name, name, nameLength)) {
         *pEntry = &entry;
         return SPV_SUCCESS;
       }
+
+      // Check the aliases. Ideally we would have a version of the table sorted
+      // by name and then we could iterate between the lower and upper bounds to
+      // restrict the amount comparisons. Fortunately, name-based lookups are
+      // mostly restricted to the assembler.
+      if (entry.numAliases > 0) {
+        for (uint32_t aliasIndex = 0; aliasIndex < entry.numAliases;
+             aliasIndex++) {
+          const auto alias = entry.aliases[aliasIndex];
+          const size_t aliasLength = strlen(alias);
+          if (nameLength == aliasLength && !strncmp(name, alias, nameLength)) {
+            *pEntry = &entry;
+            return SPV_SUCCESS;
+          }
+        }
+      }
     }
   }
 
@@ -83,7 +101,8 @@ spv_result_t spvOperandTableValueLookup(spv_target_env,
   if (!table) return SPV_ERROR_INVALID_TABLE;
   if (!pEntry) return SPV_ERROR_INVALID_POINTER;
 
-  spv_operand_desc_t needle = {"", value, 0, nullptr, 0, nullptr, {}, ~0u, ~0u};
+  spv_operand_desc_t needle = {"", value,   0,  nullptr, 0,  nullptr,
+                               0,  nullptr, {}, ~0u,     ~0u};
 
   auto comp = [](const spv_operand_desc_t& lhs, const spv_operand_desc_t& rhs) {
     return lhs.value < rhs.value;
@@ -212,6 +231,12 @@ const char* spvOperandTypeStr(spv_operand_type_t type) {
       return "cooperative matrix layout";
     case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_USE:
       return "cooperative matrix use";
+    case SPV_OPERAND_TYPE_TENSOR_CLAMP_MODE:
+      return "tensor clamp mode";
+    case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE:
+      return "cooperative matrix reduce";
+    case SPV_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS:
+      return "tensor addressing operands";
     case SPV_OPERAND_TYPE_INITIALIZATION_MODE_QUALIFIER:
       return "initialization mode qualifier";
     case SPV_OPERAND_TYPE_HOST_ACCESS_QUALIFIER:
@@ -220,6 +245,11 @@ const char* spvOperandTypeStr(spv_operand_type_t type) {
       return "load cache control";
     case SPV_OPERAND_TYPE_STORE_CACHE_CONTROL:
       return "store cache control";
+    case SPV_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS:
+      return "named maximum number of registers";
+    case SPV_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS:
+    case SPV_OPERAND_TYPE_OPTIONAL_RAW_ACCESS_CHAIN_OPERANDS:
+      return "raw access chain operands";
     case SPV_OPERAND_TYPE_IMAGE:
     case SPV_OPERAND_TYPE_OPTIONAL_IMAGE:
       return "image";
@@ -247,6 +277,9 @@ const char* spvOperandTypeStr(spv_operand_type_t type) {
       return "OpenCL.DebugInfo.100 debug operation";
     case SPV_OPERAND_TYPE_CLDEBUG100_DEBUG_IMPORTED_ENTITY:
       return "OpenCL.DebugInfo.100 debug imported entity";
+    case SPV_OPERAND_TYPE_FPENCODING:
+    case SPV_OPERAND_TYPE_OPTIONAL_FPENCODING:
+      return "FP encoding";
 
     // The next values are for values returned from an instruction, not actually
     // an operand.  So the specific strings don't matter.  But let's add them
@@ -360,6 +393,9 @@ bool spvOperandIsConcrete(spv_operand_type_t type) {
     case SPV_OPERAND_TYPE_HOST_ACCESS_QUALIFIER:
     case SPV_OPERAND_TYPE_LOAD_CACHE_CONTROL:
     case SPV_OPERAND_TYPE_STORE_CACHE_CONTROL:
+    case SPV_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS:
+    case SPV_OPERAND_TYPE_FPENCODING:
+    case SPV_OPERAND_TYPE_TENSOR_CLAMP_MODE:
       return true;
     default:
       break;
@@ -379,6 +415,9 @@ bool spvOperandIsConcreteMask(spv_operand_type_t type) {
     case SPV_OPERAND_TYPE_DEBUG_INFO_FLAGS:
     case SPV_OPERAND_TYPE_CLDEBUG100_DEBUG_INFO_FLAGS:
     case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_OPERANDS:
+    case SPV_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS:
+    case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE:
+    case SPV_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS:
       return true;
     default:
       break;
@@ -399,6 +438,8 @@ bool spvOperandIsOptional(spv_operand_type_t type) {
     case SPV_OPERAND_TYPE_OPTIONAL_PACKED_VECTOR_FORMAT:
     case SPV_OPERAND_TYPE_OPTIONAL_COOPERATIVE_MATRIX_OPERANDS:
     case SPV_OPERAND_TYPE_OPTIONAL_CIV:
+    case SPV_OPERAND_TYPE_OPTIONAL_RAW_ACCESS_CHAIN_OPERANDS:
+    case SPV_OPERAND_TYPE_OPTIONAL_FPENCODING:
       return true;
     default:
       break;
@@ -566,6 +607,16 @@ std::function<bool(unsigned)> spvOperandCanBeForwardDeclaredFunction(
     case spv::Op::OpTypeArray:
       out = [](unsigned index) { return index == 1; };
       break;
+    case spv::Op::OpCooperativeMatrixPerElementOpNV:
+      out = [](unsigned index) { return index == 3; };
+      break;
+    case spv::Op::OpCooperativeMatrixReduceNV:
+      out = [](unsigned index) { return index == 4; };
+      break;
+    case spv::Op::OpCooperativeMatrixLoadTensorNV:
+      // approximate, due to variable operands
+      out = [](unsigned index) { return index > 6; };
+      break;
     default:
       out = [](unsigned) { return false; };
       break;
@@ -574,11 +625,13 @@ std::function<bool(unsigned)> spvOperandCanBeForwardDeclaredFunction(
 }
 
 std::function<bool(unsigned)> spvDbgInfoExtOperandCanBeForwardDeclaredFunction(
-    spv_ext_inst_type_t ext_type, uint32_t key) {
+    spv::Op opcode, spv_ext_inst_type_t ext_type, uint32_t key) {
   // The Vulkan debug info extended instruction set is non-semantic so allows no
-  // forward references ever
+  // forward references except if used through OpExtInstWithForwardRefsKHR.
   if (ext_type == SPV_EXT_INST_TYPE_NONSEMANTIC_SHADER_DEBUGINFO_100) {
-    return [](unsigned) { return false; };
+    return [opcode](unsigned) {
+      return opcode == spv::Op::OpExtInstWithForwardRefsKHR;
+    };
   }
 
   // TODO(https://gitlab.khronos.org/spirv/SPIR-V/issues/532): Forward
diff --git a/source/operand.h b/source/operand.h
index a3010d93..3d42a059 100644
--- a/source/operand.h
+++ b/source/operand.h
@@ -57,12 +57,6 @@ spv_result_t spvOperandTableValueLookup(spv_target_env,
 // Gets the name string of the non-variable operand type.
 const char* spvOperandTypeStr(spv_operand_type_t type);
 
-// Returns true if the given type is concrete.
-bool spvOperandIsConcrete(spv_operand_type_t type);
-
-// Returns true if the given type is concrete and also a mask.
-bool spvOperandIsConcreteMask(spv_operand_type_t type);
-
 // Returns true if an operand of the given type is optional.
 bool spvOperandIsOptional(spv_operand_type_t type);
 
@@ -146,6 +140,6 @@ std::function<bool(unsigned)> spvOperandCanBeForwardDeclaredFunction(
 // of the operand can be forward declared. This function will
 // used in the SSA validation stage of the pipeline
 std::function<bool(unsigned)> spvDbgInfoExtOperandCanBeForwardDeclaredFunction(
-    spv_ext_inst_type_t ext_type, uint32_t key);
+    spv::Op opcode, spv_ext_inst_type_t ext_type, uint32_t key);
 
 #endif  // SOURCE_OPERAND_H_
diff --git a/source/opt/CMakeLists.txt b/source/opt/CMakeLists.txt
index 4e7d92d5..4a12e6ef 100644
--- a/source/opt/CMakeLists.txt
+++ b/source/opt/CMakeLists.txt
@@ -64,15 +64,12 @@ set(SPIRV_TOOLS_OPT_SOURCES
   inline_exhaustive_pass.h
   inline_opaque_pass.h
   inline_pass.h
-  inst_bindless_check_pass.h
-  inst_buff_addr_check_pass.h
-  inst_debug_printf_pass.h
   instruction.h
   instruction_list.h
-  instrument_pass.h
   interface_var_sroa.h
   invocation_interlock_placement_pass.h
   interp_fixup_pass.h
+  opextinst_forward_ref_fixup_pass.h
   ir_builder.h
   ir_context.h
   ir_loader.h
@@ -186,15 +183,12 @@ set(SPIRV_TOOLS_OPT_SOURCES
   inline_exhaustive_pass.cpp
   inline_opaque_pass.cpp
   inline_pass.cpp
-  inst_bindless_check_pass.cpp
-  inst_buff_addr_check_pass.cpp
-  inst_debug_printf_pass.cpp
   instruction.cpp
   instruction_list.cpp
-  instrument_pass.cpp
   interface_var_sroa.cpp
   invocation_interlock_placement_pass.cpp
   interp_fixup_pass.cpp
+  opextinst_forward_ref_fixup_pass.cpp
   ir_context.cpp
   ir_loader.cpp
   licm_pass.cpp
@@ -242,6 +236,7 @@ set(SPIRV_TOOLS_OPT_SOURCES
   strip_debug_info_pass.cpp
   strip_nonsemantic_info_pass.cpp
   struct_cfg_analysis.cpp
+  struct_packing_pass.cpp
   switch_descriptorset_pass.cpp
   trim_capabilities_pass.cpp
   type_manager.cpp
diff --git a/source/opt/aggressive_dead_code_elim_pass.cpp b/source/opt/aggressive_dead_code_elim_pass.cpp
index 4737da5f..d78d63ca 100644
--- a/source/opt/aggressive_dead_code_elim_pass.cpp
+++ b/source/opt/aggressive_dead_code_elim_pass.cpp
@@ -40,6 +40,10 @@ constexpr uint32_t kCopyMemorySourceAddrInIdx = 1;
 constexpr uint32_t kLoadSourceAddrInIdx = 0;
 constexpr uint32_t kDebugDeclareOperandVariableIndex = 5;
 constexpr uint32_t kGlobalVariableVariableIndex = 12;
+constexpr uint32_t kExtInstSetInIdx = 0;
+constexpr uint32_t kExtInstOpInIdx = 1;
+constexpr uint32_t kInterpolantInIdx = 2;
+constexpr uint32_t kCooperativeMatrixLoadSourceAddrInIdx = 0;
 
 // Sorting functor to present annotation instructions in an easy-to-process
 // order. The functor orders by opcode first and falls back on unique id
@@ -134,7 +138,12 @@ void AggressiveDCEPass::AddStores(Function* func, uint32_t ptrId) {
         }
         break;
       // If default, assume it stores e.g. frexp, modf, function call
-      case spv::Op::OpStore:
+      case spv::Op::OpStore: {
+        const uint32_t kStoreTargetAddrInIdx = 0;
+        if (user->GetSingleWordInOperand(kStoreTargetAddrInIdx) == ptrId)
+          AddToWorklist(user);
+        break;
+      }
       default:
         AddToWorklist(user);
         break;
@@ -262,6 +271,7 @@ void AggressiveDCEPass::AddBreaksAndContinuesToWorklist(
 }
 
 bool AggressiveDCEPass::AggressiveDCE(Function* func) {
+  if (func->IsDeclaration()) return false;
   std::list<BasicBlock*> structured_order;
   cfg()->ComputeStructuredOrder(func, &*func->begin(), &structured_order);
   live_local_vars_.clear();
@@ -416,6 +426,24 @@ uint32_t AggressiveDCEPass::GetLoadedVariableFromNonFunctionCalls(
     case spv::Op::OpCopyMemorySized:
       return GetVariableId(
           inst->GetSingleWordInOperand(kCopyMemorySourceAddrInIdx));
+    case spv::Op::OpExtInst: {
+      if (inst->GetSingleWordInOperand(kExtInstSetInIdx) ==
+          context()->get_feature_mgr()->GetExtInstImportId_GLSLstd450()) {
+        auto ext_inst = inst->GetSingleWordInOperand(kExtInstOpInIdx);
+        switch (ext_inst) {
+          case GLSLstd450InterpolateAtCentroid:
+          case GLSLstd450InterpolateAtOffset:
+          case GLSLstd450InterpolateAtSample:
+            return inst->GetSingleWordInOperand(kInterpolantInIdx);
+        }
+      }
+      break;
+    }
+    case spv::Op::OpCooperativeMatrixLoadNV:
+    case spv::Op::OpCooperativeMatrixLoadKHR:
+    case spv::Op::OpCooperativeMatrixLoadTensorNV:
+      return GetVariableId(
+          inst->GetSingleWordInOperand(kCooperativeMatrixLoadSourceAddrInIdx));
     default:
       break;
   }
@@ -1004,7 +1032,11 @@ void AggressiveDCEPass::InitExtensions() {
       "SPV_NV_bindless_texture",
       "SPV_EXT_shader_atomic_float_add",
       "SPV_EXT_fragment_shader_interlock",
-      "SPV_NV_compute_shader_derivatives"
+      "SPV_KHR_compute_shader_derivatives",
+      "SPV_NV_cooperative_matrix",
+      "SPV_KHR_cooperative_matrix",
+      "SPV_KHR_ray_tracing_position_fetch",
+      "SPV_KHR_fragment_shading_rate"
   });
   // clang-format on
 }
diff --git a/source/opt/build_module.h b/source/opt/build_module.h
index 29eaf661..0f906c88 100644
--- a/source/opt/build_module.h
+++ b/source/opt/build_module.h
@@ -24,7 +24,7 @@
 
 namespace spvtools {
 
-// Builds an Module returns the owning IRContext from the given SPIR-V
+// Builds a Module and returns the owning IRContext from the given SPIR-V
 // |binary|. |size| specifies number of words in |binary|. The |binary| will be
 // decoded according to the given target |env|. Returns nullptr if errors occur
 // and sends the errors to |consumer|.  When |extra_line_tracking| is true,
@@ -41,7 +41,7 @@ std::unique_ptr<opt::IRContext> BuildModule(spv_target_env env,
                                             const uint32_t* binary,
                                             size_t size);
 
-// Builds an Module and returns the owning IRContext from the given
+// Builds a Module and returns the owning IRContext from the given
 // SPIR-V assembly |text|.  The |text| will be encoded according to the given
 // target |env|. Returns nullptr if errors occur and sends the errors to
 // |consumer|.
diff --git a/source/opt/const_folding_rules.cpp b/source/opt/const_folding_rules.cpp
index 17900af2..a5d4cbe7 100644
--- a/source/opt/const_folding_rules.cpp
+++ b/source/opt/const_folding_rules.cpp
@@ -21,59 +21,6 @@ namespace opt {
 namespace {
 constexpr uint32_t kExtractCompositeIdInIdx = 0;
 
-// Returns the value obtained by extracting the |number_of_bits| least
-// significant bits from |value|, and sign-extending it to 64-bits.
-uint64_t SignExtendValue(uint64_t value, uint32_t number_of_bits) {
-  if (number_of_bits == 64) return value;
-
-  uint64_t mask_for_sign_bit = 1ull << (number_of_bits - 1);
-  uint64_t mask_for_significant_bits = (mask_for_sign_bit << 1) - 1ull;
-  if (value & mask_for_sign_bit) {
-    // Set upper bits to 1
-    value |= ~mask_for_significant_bits;
-  } else {
-    // Clear the upper bits
-    value &= mask_for_significant_bits;
-  }
-  return value;
-}
-
-// Returns the value obtained by extracting the |number_of_bits| least
-// significant bits from |value|, and zero-extending it to 64-bits.
-uint64_t ZeroExtendValue(uint64_t value, uint32_t number_of_bits) {
-  if (number_of_bits == 64) return value;
-
-  uint64_t mask_for_first_bit_to_clear = 1ull << (number_of_bits);
-  uint64_t mask_for_bits_to_keep = mask_for_first_bit_to_clear - 1;
-  value &= mask_for_bits_to_keep;
-  return value;
-}
-
-// Returns a constant whose value is `value` and type is `type`. This constant
-// will be generated by `const_mgr`. The type must be a scalar integer type.
-const analysis::Constant* GenerateIntegerConstant(
-    const analysis::Integer* integer_type, uint64_t result,
-    analysis::ConstantManager* const_mgr) {
-  assert(integer_type != nullptr);
-
-  std::vector<uint32_t> words;
-  if (integer_type->width() == 64) {
-    // In the 64-bit case, two words are needed to represent the value.
-    words = {static_cast<uint32_t>(result),
-             static_cast<uint32_t>(result >> 32)};
-  } else {
-    // In all other cases, only a single word is needed.
-    assert(integer_type->width() <= 32);
-    if (integer_type->IsSigned()) {
-      result = SignExtendValue(result, integer_type->width());
-    } else {
-      result = ZeroExtendValue(result, integer_type->width());
-    }
-    words = {static_cast<uint32_t>(result)};
-  }
-  return const_mgr->GetConstant(integer_type, words);
-}
-
 // Returns a constants with the value NaN of the given type.  Only works for
 // 32-bit and 64-bit float point types.  Returns |nullptr| if an error occurs.
 const analysis::Constant* GetNan(const analysis::Type* type,
@@ -1730,7 +1677,7 @@ BinaryScalarFoldingRule FoldBinaryIntegerOperation(uint64_t (*op)(uint64_t,
         uint64_t result = op(ia, ib);
 
         const analysis::Constant* result_constant =
-            GenerateIntegerConstant(integer_type, result, const_mgr);
+            const_mgr->GenerateIntegerConstant(integer_type, result);
         return result_constant;
       };
 }
@@ -1745,7 +1692,7 @@ const analysis::Constant* FoldScalarSConvert(
   const analysis::Integer* integer_type = result_type->AsInteger();
   assert(integer_type && "The result type of an SConvert");
   int64_t value = a->GetSignExtendedValue();
-  return GenerateIntegerConstant(integer_type, value, const_mgr);
+  return const_mgr->GenerateIntegerConstant(integer_type, value);
 }
 
 // A scalar folding rule that folds OpUConvert.
@@ -1762,8 +1709,8 @@ const analysis::Constant* FoldScalarUConvert(
   // If the operand was an unsigned value with less than 32-bit, it would have
   // been sign extended earlier, and we need to clear those bits.
   auto* operand_type = a->type()->AsInteger();
-  value = ZeroExtendValue(value, operand_type->width());
-  return GenerateIntegerConstant(integer_type, value, const_mgr);
+  value = utils::ClearHighBits(value, 64 - operand_type->width());
+  return const_mgr->GenerateIntegerConstant(integer_type, value);
 }
 }  // namespace
 
diff --git a/source/opt/constants.cpp b/source/opt/constants.cpp
index a487a45b..7dc02dea 100644
--- a/source/opt/constants.cpp
+++ b/source/opt/constants.cpp
@@ -498,7 +498,7 @@ const Constant* ConstantManager::GetIntConst(uint64_t val, int32_t bitWidth,
     int32_t num_of_bit_to_ignore = 64 - bitWidth;
     val = static_cast<int64_t>(val << num_of_bit_to_ignore) >>
           num_of_bit_to_ignore;
-  } else {
+  } else if (bitWidth < 64) {
     // Clear the upper bit that are not used.
     uint64_t mask = ((1ull << bitWidth) - 1);
     val &= mask;
@@ -511,7 +511,7 @@ const Constant* ConstantManager::GetIntConst(uint64_t val, int32_t bitWidth,
   // If the value is more than 32-bit, we need to split the operands into two
   // 32-bit integers.
   return GetConstant(
-      int_type, {static_cast<uint32_t>(val >> 32), static_cast<uint32_t>(val)});
+      int_type, {static_cast<uint32_t>(val), static_cast<uint32_t>(val >> 32)});
 }
 
 uint32_t ConstantManager::GetUIntConstId(uint32_t val) {
@@ -525,6 +525,28 @@ uint32_t ConstantManager::GetNullConstId(const Type* type) {
   return GetDefiningInstruction(c)->result_id();
 }
 
+const Constant* ConstantManager::GenerateIntegerConstant(
+    const analysis::Integer* integer_type, uint64_t result) {
+  assert(integer_type != nullptr);
+
+  std::vector<uint32_t> words;
+  if (integer_type->width() == 64) {
+    // In the 64-bit case, two words are needed to represent the value.
+    words = {static_cast<uint32_t>(result),
+             static_cast<uint32_t>(result >> 32)};
+  } else {
+    // In all other cases, only a single word is needed.
+    assert(integer_type->width() <= 32);
+    if (integer_type->IsSigned()) {
+      result = utils::SignExtendValue(result, integer_type->width());
+    } else {
+      result = utils::ZeroExtendValue(result, integer_type->width());
+    }
+    words = {static_cast<uint32_t>(result)};
+  }
+  return GetConstant(integer_type, words);
+}
+
 std::vector<const analysis::Constant*> Constant::GetVectorComponents(
     analysis::ConstantManager* const_mgr) const {
   std::vector<const analysis::Constant*> components;
diff --git a/source/opt/constants.h b/source/opt/constants.h
index ae8dc625..534afa6f 100644
--- a/source/opt/constants.h
+++ b/source/opt/constants.h
@@ -671,6 +671,11 @@ class ConstantManager {
   // Returns the id of a OpConstantNull with type of |type|.
   uint32_t GetNullConstId(const Type* type);
 
+  // Returns a constant whose value is `value` and type is `type`. This constant
+  // will be generated by `const_mgr`. The type must be a scalar integer type.
+  const Constant* GenerateIntegerConstant(const analysis::Integer* integer_type,
+                                          uint64_t result);
+
  private:
   // Creates a Constant instance with the given type and a vector of constant
   // defining words. Returns a unique pointer to the created Constant instance
diff --git a/source/opt/convert_to_sampled_image_pass.cpp b/source/opt/convert_to_sampled_image_pass.cpp
index c82db41c..d2da4d1e 100644
--- a/source/opt/convert_to_sampled_image_pass.cpp
+++ b/source/opt/convert_to_sampled_image_pass.cpp
@@ -329,12 +329,10 @@ bool ConvertToSampledImagePass::ConvertImageVariableToSampledImage(
   if (sampled_image_type == nullptr) return false;
   auto storage_class = GetStorageClass(*image_variable);
   if (storage_class == spv::StorageClass::Max) return false;
-  analysis::Pointer sampled_image_pointer(sampled_image_type, storage_class);
-
   // Make sure |image_variable| is behind its type i.e., avoid the forward
   // reference.
-  uint32_t type_id =
-      context()->get_type_mgr()->GetTypeInstruction(&sampled_image_pointer);
+  uint32_t type_id = context()->get_type_mgr()->FindPointerToType(
+      sampled_image_type_id, storage_class);
   MoveInstructionNextToType(image_variable, type_id);
   return true;
 }
diff --git a/source/opt/copy_prop_arrays.cpp b/source/opt/copy_prop_arrays.cpp
index c2bea8ad..0a420744 100644
--- a/source/opt/copy_prop_arrays.cpp
+++ b/source/opt/copy_prop_arrays.cpp
@@ -28,6 +28,9 @@ constexpr uint32_t kStoreObjectInOperand = 1;
 constexpr uint32_t kCompositeExtractObjectInOperand = 0;
 constexpr uint32_t kTypePointerStorageClassInIdx = 0;
 constexpr uint32_t kTypePointerPointeeInIdx = 1;
+constexpr uint32_t kExtInstSetInIdx = 0;
+constexpr uint32_t kExtInstOpInIdx = 1;
+constexpr uint32_t kInterpolantInIdx = 2;
 
 bool IsDebugDeclareOrValue(Instruction* di) {
   auto dbg_opcode = di->GetCommonDebugOpcode();
@@ -74,28 +77,38 @@ Pass::Status CopyPropagateArrays::Process() {
 
     for (auto var_inst = entry_bb->begin();
          var_inst->opcode() == spv::Op::OpVariable; ++var_inst) {
-      if (!IsPointerToArrayType(var_inst->type_id())) {
-        continue;
-      }
+      worklist_.push(&*var_inst);
+    }
+  }
+
+  while (!worklist_.empty()) {
+    Instruction* var_inst = worklist_.front();
+    worklist_.pop();
 
-      // Find the only store to the entire memory location, if it exists.
-      Instruction* store_inst = FindStoreInstruction(&*var_inst);
+    // Find the only store to the entire memory location, if it exists.
+    Instruction* store_inst = FindStoreInstruction(&*var_inst);
 
-      if (!store_inst) {
+    if (!store_inst) {
+      continue;
+    }
+
+    std::unique_ptr<MemoryObject> source_object =
+        FindSourceObjectIfPossible(&*var_inst, store_inst);
+
+    if (source_object != nullptr) {
+      if (!IsPointerToArrayType(var_inst->type_id()) &&
+          source_object->GetStorageClass() != spv::StorageClass::Input) {
         continue;
       }
 
-      std::unique_ptr<MemoryObject> source_object =
-          FindSourceObjectIfPossible(&*var_inst, store_inst);
+      if (CanUpdateUses(&*var_inst, source_object->GetPointerTypeId(this))) {
+        modified = true;
 
-      if (source_object != nullptr) {
-        if (CanUpdateUses(&*var_inst, source_object->GetPointerTypeId(this))) {
-          modified = true;
-          PropagateObject(&*var_inst, source_object.get(), store_inst);
-        }
+        PropagateObject(&*var_inst, source_object.get(), store_inst);
       }
     }
   }
+
   return (modified ? Status::SuccessWithChange : Status::SuccessWithoutChange);
 }
 
@@ -204,6 +217,8 @@ bool CopyPropagateArrays::HasNoStores(Instruction* ptr_inst) {
       return true;
     } else if (use->opcode() == spv::Op::OpEntryPoint) {
       return true;
+    } else if (IsInterpolationInstruction(use)) {
+      return true;
     }
     // Some other instruction.  Be conservative.
     return false;
@@ -225,6 +240,13 @@ bool CopyPropagateArrays::HasValidReferencesOnly(Instruction* ptr_inst,
           // time to do the multiple traverses can add up.  Consider collecting
           // those loads and doing a single traversal.
           return dominator_analysis->Dominates(store_inst, use);
+        } else if (IsInterpolationInstruction(use)) {
+          // GLSL InterpolateAt* instructions work similarly to loads
+          uint32_t interpolant = use->GetSingleWordInOperand(kInterpolantInIdx);
+          if (interpolant !=
+              store_inst->GetSingleWordInOperand(kStorePointerInOperand))
+            return false;
+          return dominator_analysis->Dominates(store_inst, use);
         } else if (use->opcode() == spv::Op::OpAccessChain) {
           return HasValidReferencesOnly(use, store_inst);
         } else if (use->IsDecoration() || use->opcode() == spv::Op::OpName) {
@@ -489,6 +511,21 @@ bool CopyPropagateArrays::IsPointerToArrayType(uint32_t type_id) {
   return false;
 }
 
+bool CopyPropagateArrays::IsInterpolationInstruction(Instruction* inst) {
+  if (inst->opcode() == spv::Op::OpExtInst &&
+      inst->GetSingleWordInOperand(kExtInstSetInIdx) ==
+          context()->get_feature_mgr()->GetExtInstImportId_GLSLstd450()) {
+    uint32_t ext_inst = inst->GetSingleWordInOperand(kExtInstOpInIdx);
+    switch (ext_inst) {
+      case GLSLstd450InterpolateAtCentroid:
+      case GLSLstd450InterpolateAtOffset:
+      case GLSLstd450InterpolateAtSample:
+        return true;
+    }
+  }
+  return false;
+}
+
 bool CopyPropagateArrays::CanUpdateUses(Instruction* original_ptr_inst,
                                         uint32_t type_id) {
   analysis::TypeManager* type_mgr = context()->get_type_mgr();
@@ -522,6 +559,11 @@ bool CopyPropagateArrays::CanUpdateUses(Instruction* original_ptr_inst,
         }
         return true;
       }
+      case spv::Op::OpExtInst:
+        if (IsInterpolationInstruction(use)) {
+          return true;
+        }
+        return false;
       case spv::Op::OpAccessChain: {
         analysis::Pointer* pointer_type = type->AsPointer();
         const analysis::Type* pointee_type = pointer_type->pointee_type();
@@ -670,6 +712,18 @@ void CopyPropagateArrays::UpdateUses(Instruction* original_ptr_inst,
         } else {
           context()->AnalyzeUses(use);
         }
+
+        AddUsesToWorklist(use);
+      } break;
+      case spv::Op::OpExtInst: {
+        if (IsInterpolationInstruction(use)) {
+          // Replace the actual use.
+          context()->ForgetUses(use);
+          use->SetOperand(index, {new_ptr_inst->result_id()});
+          context()->AnalyzeUses(use);
+        } else {
+          assert(false && "Don't know how to rewrite instruction");
+        }
       } break;
       case spv::Op::OpAccessChain: {
         // Update the actual use.
@@ -751,6 +805,8 @@ void CopyPropagateArrays::UpdateUses(Instruction* original_ptr_inst,
           uint32_t pointee_type_id =
               pointer_type->GetSingleWordInOperand(kTypePointerPointeeInIdx);
           uint32_t copy = GenerateCopy(original_ptr_inst, pointee_type_id, use);
+          assert(copy != 0 &&
+                 "Should not be updating uses unless we know it can be done.");
 
           context()->ForgetUses(use);
           use->SetInOperand(index, {copy});
@@ -797,6 +853,22 @@ uint32_t CopyPropagateArrays::GetMemberTypeId(
   return id;
 }
 
+void CopyPropagateArrays::AddUsesToWorklist(Instruction* inst) {
+  analysis::DefUseManager* def_use_mgr = context()->get_def_use_mgr();
+
+  def_use_mgr->ForEachUse(inst, [this](Instruction* use, uint32_t) {
+    if (use->opcode() == spv::Op::OpStore) {
+      uint32_t var_id;
+      Instruction* target_pointer = GetPtr(use, &var_id);
+      if (target_pointer->opcode() != spv::Op::OpVariable) {
+        return;
+      }
+
+      worklist_.push(target_pointer);
+    }
+  });
+}
+
 void CopyPropagateArrays::MemoryObject::PushIndirection(
     const std::vector<AccessChainEntry>& access_chain) {
   access_chain_.insert(access_chain_.end(), access_chain.begin(),
diff --git a/source/opt/copy_prop_arrays.h b/source/opt/copy_prop_arrays.h
index c6ca7d25..bf4bfb5c 100644
--- a/source/opt/copy_prop_arrays.h
+++ b/source/opt/copy_prop_arrays.h
@@ -222,6 +222,10 @@ class CopyPropagateArrays : public MemPass {
   // Return true if |type_id| is a pointer type whose pointee type is an array.
   bool IsPointerToArrayType(uint32_t type_id);
 
+  // Return true if |inst| is one of the InterpolateAt* GLSL.std.450 extended
+  // instructions.
+  bool IsInterpolationInstruction(Instruction* inst);
+
   // Returns true if there are not stores using |ptr_inst| or something derived
   // from it.
   bool HasNoStores(Instruction* ptr_inst);
@@ -254,6 +258,14 @@ class CopyPropagateArrays : public MemPass {
   // same way the indexes are used in an |OpCompositeExtract| instruction.
   uint32_t GetMemberTypeId(uint32_t id,
                            const std::vector<uint32_t>& access_chain) const;
+
+  // If the result of inst is stored to a variable, add that variable to the
+  // worklist.
+  void AddUsesToWorklist(Instruction* inst);
+
+  // OpVariable worklist. An instruction is added to this list if we would like
+  // to run copy propagation on it.
+  std::queue<Instruction*> worklist_;
 };
 
 }  // namespace opt
diff --git a/source/opt/debug_info_manager.cpp b/source/opt/debug_info_manager.cpp
index 1e614c6f..24094b36 100644
--- a/source/opt/debug_info_manager.cpp
+++ b/source/opt/debug_info_manager.cpp
@@ -768,15 +768,29 @@ void DebugInfoManager::ConvertDebugGlobalToLocalVariable(
          local_var->opcode() == spv::Op::OpFunctionParameter);
 
   // Convert |dbg_global_var| to DebugLocalVariable
+  // All of the operands up to the scope operand are the same for the type
+  // instructions. The flag operand needs to move from operand
+  // kDebugGlobalVariableOperandFlagsIndex to
+  // kDebugLocalVariableOperandFlagsIndex. No other operands are needed to
+  // define the DebugLocalVariable.
+
+  // Modify the opcode.
   dbg_global_var->SetInOperand(kExtInstInstructionInIdx,
                                {CommonDebugInfoDebugLocalVariable});
+
+  // Move the flags operand.
   auto flags = dbg_global_var->GetSingleWordOperand(
       kDebugGlobalVariableOperandFlagsIndex);
-  for (uint32_t i = dbg_global_var->NumInOperands() - 1;
-       i >= kDebugLocalVariableOperandFlagsIndex; --i) {
+  dbg_global_var->SetOperand(kDebugLocalVariableOperandFlagsIndex, {flags});
+
+  // Remove the  extra operands. Starting at the end to avoid copying too much
+  // data.
+  for (uint32_t i = dbg_global_var->NumOperands() - 1;
+       i > kDebugLocalVariableOperandFlagsIndex; --i) {
     dbg_global_var->RemoveOperand(i);
   }
-  dbg_global_var->SetOperand(kDebugLocalVariableOperandFlagsIndex, {flags});
+
+  // Update the def-use manager.
   context()->ForgetUses(dbg_global_var);
   context()->AnalyzeUses(dbg_global_var);
 
diff --git a/source/opt/desc_sroa.cpp b/source/opt/desc_sroa.cpp
index 2c0f4829..124a3d3a 100644
--- a/source/opt/desc_sroa.cpp
+++ b/source/opt/desc_sroa.cpp
@@ -31,11 +31,14 @@ bool IsDecorationBinding(Instruction* inst) {
 
 Pass::Status DescriptorScalarReplacement::Process() {
   bool modified = false;
-
   std::vector<Instruction*> vars_to_kill;
 
   for (Instruction& var : context()->types_values()) {
-    if (descsroautil::IsDescriptorArray(context(), &var)) {
+    bool is_candidate =
+        flatten_arrays_ && descsroautil::IsDescriptorArray(context(), &var);
+    is_candidate |= flatten_composites_ &&
+                    descsroautil::IsDescriptorStruct(context(), &var);
+    if (is_candidate) {
       modified = true;
       if (!ReplaceCandidate(&var)) {
         return Status::Failure;
diff --git a/source/opt/desc_sroa.h b/source/opt/desc_sroa.h
index 901be3e9..d6af4df5 100644
--- a/source/opt/desc_sroa.h
+++ b/source/opt/desc_sroa.h
@@ -32,9 +32,16 @@ namespace opt {
 // Documented in optimizer.hpp
 class DescriptorScalarReplacement : public Pass {
  public:
-  DescriptorScalarReplacement() {}
-
-  const char* name() const override { return "descriptor-scalar-replacement"; }
+  DescriptorScalarReplacement(bool flatten_composites, bool flatten_arrays)
+      : flatten_composites_(flatten_composites),
+        flatten_arrays_(flatten_arrays) {}
+
+  const char* name() const override {
+    if (flatten_composites_ && flatten_arrays_)
+      return "descriptor-scalar-replacement";
+    if (flatten_composites_) return "descriptor-compososite-scalar-replacement";
+    return "descriptor-array-scalar-replacement";
+  }
 
   Status Process() override;
 
@@ -141,6 +148,9 @@ class DescriptorScalarReplacement : public Pass {
   // array |var|. If the entry is |0|, then the variable has not been
   // created yet.
   std::map<Instruction*, std::vector<uint32_t>> replacement_variables_;
+
+  bool flatten_composites_;
+  bool flatten_arrays_;
 };
 
 }  // namespace opt
diff --git a/source/opt/desc_sroa_util.cpp b/source/opt/desc_sroa_util.cpp
index dba3de9c..62d94764 100644
--- a/source/opt/desc_sroa_util.cpp
+++ b/source/opt/desc_sroa_util.cpp
@@ -29,41 +29,58 @@ uint32_t GetLengthOfArrayType(IRContext* context, Instruction* type) {
   return length_const->GetU32();
 }
 
-}  // namespace
-
-namespace descsroautil {
+bool HasDescriptorDecorations(IRContext* context, Instruction* var) {
+  const auto& decoration_mgr = context->get_decoration_mgr();
+  return decoration_mgr->HasDecoration(
+             var->result_id(), uint32_t(spv::Decoration::DescriptorSet)) &&
+         decoration_mgr->HasDecoration(var->result_id(),
+                                       uint32_t(spv::Decoration::Binding));
+}
 
-bool IsDescriptorArray(IRContext* context, Instruction* var) {
+Instruction* GetVariableType(IRContext* context, Instruction* var) {
   if (var->opcode() != spv::Op::OpVariable) {
-    return false;
+    return nullptr;
   }
 
   uint32_t ptr_type_id = var->type_id();
   Instruction* ptr_type_inst = context->get_def_use_mgr()->GetDef(ptr_type_id);
   if (ptr_type_inst->opcode() != spv::Op::OpTypePointer) {
-    return false;
+    return nullptr;
   }
 
   uint32_t var_type_id = ptr_type_inst->GetSingleWordInOperand(1);
-  Instruction* var_type_inst = context->get_def_use_mgr()->GetDef(var_type_id);
-  if (var_type_inst->opcode() != spv::Op::OpTypeArray &&
-      var_type_inst->opcode() != spv::Op::OpTypeStruct) {
-    return false;
+  return context->get_def_use_mgr()->GetDef(var_type_id);
+}
+
+}  // namespace
+
+namespace descsroautil {
+
+bool IsDescriptorArray(IRContext* context, Instruction* var) {
+  Instruction* var_type_inst = GetVariableType(context, var);
+  if (var_type_inst == nullptr) return false;
+  return var_type_inst->opcode() == spv::Op::OpTypeArray &&
+         HasDescriptorDecorations(context, var);
+}
+
+bool IsDescriptorStruct(IRContext* context, Instruction* var) {
+  Instruction* var_type_inst = GetVariableType(context, var);
+  if (var_type_inst == nullptr) return false;
+
+  while (var_type_inst->opcode() == spv::Op::OpTypeArray) {
+    var_type_inst = context->get_def_use_mgr()->GetDef(
+        var_type_inst->GetInOperand(0).AsId());
   }
 
+  if (var_type_inst->opcode() != spv::Op::OpTypeStruct) return false;
+
   // All structures with descriptor assignments must be replaced by variables,
   // one for each of their members - with the exceptions of buffers.
   if (IsTypeOfStructuredBuffer(context, var_type_inst)) {
     return false;
   }
 
-  if (!context->get_decoration_mgr()->HasDecoration(
-          var->result_id(), uint32_t(spv::Decoration::DescriptorSet))) {
-    return false;
-  }
-
-  return context->get_decoration_mgr()->HasDecoration(
-      var->result_id(), uint32_t(spv::Decoration::Binding));
+  return HasDescriptorDecorations(context, var);
 }
 
 bool IsTypeOfStructuredBuffer(IRContext* context, const Instruction* type) {
diff --git a/source/opt/desc_sroa_util.h b/source/opt/desc_sroa_util.h
index 2f45c0c2..04233565 100644
--- a/source/opt/desc_sroa_util.h
+++ b/source/opt/desc_sroa_util.h
@@ -27,6 +27,10 @@ namespace descsroautil {
 // descriptor array.
 bool IsDescriptorArray(IRContext* context, Instruction* var);
 
+// Returns true if |var| is an OpVariable instruction that represents a
+// struct containing descriptors.
+bool IsDescriptorStruct(IRContext* context, Instruction* var);
+
 // Returns true if |type| is a type that could be used for a structured buffer
 // as opposed to a type that would be used for a structure of resource
 // descriptors.
diff --git a/source/opt/eliminate_dead_members_pass.cpp b/source/opt/eliminate_dead_members_pass.cpp
index 1c98502e..e440296f 100644
--- a/source/opt/eliminate_dead_members_pass.cpp
+++ b/source/opt/eliminate_dead_members_pass.cpp
@@ -70,6 +70,11 @@ void EliminateDeadMembersPass::FindLiveMembers() {
             MarkPointeeTypeAsFullUsed(inst.type_id());
           break;
       }
+    } else if (inst.opcode() == spv::Op::OpTypePointer) {
+      uint32_t storage_class = inst.GetSingleWordInOperand(0);
+      if (storage_class == uint32_t(spv::StorageClass::PhysicalStorageBuffer)) {
+        MarkTypeAsFullyUsed(inst.GetSingleWordInOperand(1));
+      }
     }
   }
 
@@ -200,6 +205,8 @@ void EliminateDeadMembersPass::MarkMembersAsLiveForExtract(
       case spv::Op::OpTypeRuntimeArray:
       case spv::Op::OpTypeVector:
       case spv::Op::OpTypeMatrix:
+      case spv::Op::OpTypeCooperativeMatrixNV:
+      case spv::Op::OpTypeCooperativeMatrixKHR:
         type_id = type_inst->GetSingleWordInOperand(0);
         break;
       default:
@@ -246,6 +253,8 @@ void EliminateDeadMembersPass::MarkMembersAsLiveForAccessChain(
       case spv::Op::OpTypeRuntimeArray:
       case spv::Op::OpTypeVector:
       case spv::Op::OpTypeMatrix:
+      case spv::Op::OpTypeCooperativeMatrixNV:
+      case spv::Op::OpTypeCooperativeMatrixKHR:
         type_id = type_inst->GetSingleWordInOperand(0);
         break;
       default:
@@ -505,6 +514,8 @@ bool EliminateDeadMembersPass::UpdateAccessChain(Instruction* inst) {
       case spv::Op::OpTypeRuntimeArray:
       case spv::Op::OpTypeVector:
       case spv::Op::OpTypeMatrix:
+      case spv::Op::OpTypeCooperativeMatrixNV:
+      case spv::Op::OpTypeCooperativeMatrixKHR:
         new_operands.emplace_back(inst->GetInOperand(i));
         type_id = type_inst->GetSingleWordInOperand(0);
         break;
@@ -578,6 +589,8 @@ bool EliminateDeadMembersPass::UpdateCompsiteExtract(Instruction* inst) {
       case spv::Op::OpTypeRuntimeArray:
       case spv::Op::OpTypeVector:
       case spv::Op::OpTypeMatrix:
+      case spv::Op::OpTypeCooperativeMatrixNV:
+      case spv::Op::OpTypeCooperativeMatrixKHR:
         type_id = type_inst->GetSingleWordInOperand(0);
         break;
       default:
@@ -639,6 +652,8 @@ bool EliminateDeadMembersPass::UpdateCompositeInsert(Instruction* inst) {
       case spv::Op::OpTypeRuntimeArray:
       case spv::Op::OpTypeVector:
       case spv::Op::OpTypeMatrix:
+      case spv::Op::OpTypeCooperativeMatrixNV:
+      case spv::Op::OpTypeCooperativeMatrixKHR:
         type_id = type_inst->GetSingleWordInOperand(0);
         break;
       default:
diff --git a/source/opt/eliminate_dead_output_stores_pass.cpp b/source/opt/eliminate_dead_output_stores_pass.cpp
index 99711a16..e71032d4 100644
--- a/source/opt/eliminate_dead_output_stores_pass.cpp
+++ b/source/opt/eliminate_dead_output_stores_pass.cpp
@@ -92,16 +92,19 @@ void EliminateDeadOutputStoresPass::KillAllDeadStoresOfLocRef(
       });
   // Compute offset and final type of reference. If no location found
   // or any stored locations are live, return without removing stores.
-  auto ptr_type = type_mgr->GetType(var->type_id())->AsPointer();
+
+  Instruction* ptr_type = get_def_use_mgr()->GetDef(var->type_id());
   assert(ptr_type && "unexpected var type");
-  auto var_type = ptr_type->pointee_type();
+  const uint32_t kPointerTypePointeeIdx = 1;
+  uint32_t var_type_id =
+      ptr_type->GetSingleWordInOperand(kPointerTypePointeeIdx);
   uint32_t ref_loc = start_loc;
-  auto curr_type = var_type;
   if (ref->opcode() == spv::Op::OpAccessChain ||
       ref->opcode() == spv::Op::OpInBoundsAccessChain) {
-    live_mgr->AnalyzeAccessChainLoc(ref, &curr_type, &ref_loc, &no_loc,
-                                    is_patch, /* input */ false);
+    var_type_id = live_mgr->AnalyzeAccessChainLoc(
+        ref, var_type_id, &ref_loc, &no_loc, is_patch, /* input */ false);
   }
+  const analysis::Type* curr_type = type_mgr->GetType(var_type_id);
   if (no_loc || AnyLocsAreLive(ref_loc, live_mgr->GetLocSize(curr_type)))
     return;
   // Kill all stores based on this reference
diff --git a/source/opt/fix_storage_class.cpp b/source/opt/fix_storage_class.cpp
index 564cd1b8..b64026e6 100644
--- a/source/opt/fix_storage_class.cpp
+++ b/source/opt/fix_storage_class.cpp
@@ -141,22 +141,26 @@ bool FixStorageClass::IsPointerResultType(Instruction* inst) {
   if (inst->type_id() == 0) {
     return false;
   }
-  const analysis::Type* ret_type =
-      context()->get_type_mgr()->GetType(inst->type_id());
-  return ret_type->AsPointer() != nullptr;
+
+  Instruction* type_def = get_def_use_mgr()->GetDef(inst->type_id());
+  return type_def->opcode() == spv::Op::OpTypePointer;
 }
 
 bool FixStorageClass::IsPointerToStorageClass(Instruction* inst,
                                               spv::StorageClass storage_class) {
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  analysis::Type* pType = type_mgr->GetType(inst->type_id());
-  const analysis::Pointer* result_type = pType->AsPointer();
+  if (inst->type_id() == 0) {
+    return false;
+  }
 
-  if (result_type == nullptr) {
+  Instruction* type_def = get_def_use_mgr()->GetDef(inst->type_id());
+  if (type_def->opcode() != spv::Op::OpTypePointer) {
     return false;
   }
 
-  return (result_type->storage_class() == storage_class);
+  const uint32_t kPointerTypeStorageClassIndex = 0;
+  spv::StorageClass pointer_storage_class = static_cast<spv::StorageClass>(
+      type_def->GetSingleWordInOperand(kPointerTypeStorageClassIndex));
+  return pointer_storage_class == storage_class;
 }
 
 bool FixStorageClass::ChangeResultType(Instruction* inst,
@@ -233,6 +237,9 @@ bool FixStorageClass::PropagateType(Instruction* inst, uint32_t type_id,
         }
 
         uint32_t copy_id = GenerateCopy(obj_inst, pointee_type_id, inst);
+        if (copy_id == 0) {
+          return false;
+        }
         inst->SetInOperand(1, {copy_id});
         context()->UpdateDefUse(inst);
       }
@@ -301,9 +308,11 @@ uint32_t FixStorageClass::WalkAccessChainType(Instruction* inst, uint32_t id) {
       break;
   }
 
-  Instruction* orig_type_inst = get_def_use_mgr()->GetDef(id);
-  assert(orig_type_inst->opcode() == spv::Op::OpTypePointer);
-  id = orig_type_inst->GetSingleWordInOperand(1);
+  Instruction* id_type_inst = get_def_use_mgr()->GetDef(id);
+  assert(id_type_inst->opcode() == spv::Op::OpTypePointer);
+  id = id_type_inst->GetSingleWordInOperand(1);
+  spv::StorageClass input_storage_class =
+      static_cast<spv::StorageClass>(id_type_inst->GetSingleWordInOperand(0));
 
   for (uint32_t i = start_idx; i < inst->NumInOperands(); ++i) {
     Instruction* type_inst = get_def_use_mgr()->GetDef(id);
@@ -312,6 +321,7 @@ uint32_t FixStorageClass::WalkAccessChainType(Instruction* inst, uint32_t id) {
       case spv::Op::OpTypeRuntimeArray:
       case spv::Op::OpTypeMatrix:
       case spv::Op::OpTypeVector:
+      case spv::Op::OpTypeCooperativeMatrixKHR:
         id = type_inst->GetSingleWordInOperand(0);
         break;
       case spv::Op::OpTypeStruct: {
@@ -335,9 +345,19 @@ uint32_t FixStorageClass::WalkAccessChainType(Instruction* inst, uint32_t id) {
            "Tried to extract from an object where it cannot be done.");
   }
 
-  return context()->get_type_mgr()->FindPointerToType(
-      id, static_cast<spv::StorageClass>(
-              orig_type_inst->GetSingleWordInOperand(0)));
+  Instruction* orig_type_inst = get_def_use_mgr()->GetDef(inst->type_id());
+  spv::StorageClass orig_storage_class =
+      static_cast<spv::StorageClass>(orig_type_inst->GetSingleWordInOperand(0));
+  assert(orig_type_inst->opcode() == spv::Op::OpTypePointer);
+  if (orig_type_inst->GetSingleWordInOperand(1) == id &&
+      input_storage_class == orig_storage_class) {
+    // The existing type is correct. Avoid the search for the type. Note that if
+    // there is a duplicate type, the search below could return a different type
+    // forcing more changes to the code than necessary.
+    return inst->type_id();
+  }
+
+  return context()->get_type_mgr()->FindPointerToType(id, input_storage_class);
 }
 
 // namespace opt
diff --git a/source/opt/fold_spec_constant_op_and_composite_pass.cpp b/source/opt/fold_spec_constant_op_and_composite_pass.cpp
index c568027d..ddfe59f7 100644
--- a/source/opt/fold_spec_constant_op_and_composite_pass.cpp
+++ b/source/opt/fold_spec_constant_op_and_composite_pass.cpp
@@ -247,18 +247,7 @@ utils::SmallVector<uint32_t, 2> EncodeIntegerAsWords(const analysis::Type& type,
 
   // Truncate first_word if the |type| has width less than uint32.
   if (bit_width < bits_per_word) {
-    const uint32_t num_high_bits_to_mask = bits_per_word - bit_width;
-    const bool is_negative_after_truncation =
-        result_type_signed &&
-        utils::IsBitAtPositionSet(first_word, bit_width - 1);
-
-    if (is_negative_after_truncation) {
-      // Truncate and sign-extend |first_word|. No padding words will be
-      // added and |pad_value| can be left as-is.
-      first_word = utils::SetHighBits(first_word, num_high_bits_to_mask);
-    } else {
-      first_word = utils::ClearHighBits(first_word, num_high_bits_to_mask);
-    }
+    first_word = utils::SignExtendValue(first_word, bit_width);
   }
 
   utils::SmallVector<uint32_t, 2> words = {first_word};
diff --git a/source/opt/folding_rules.cpp b/source/opt/folding_rules.cpp
index 5c68e291..5748f971 100644
--- a/source/opt/folding_rules.cpp
+++ b/source/opt/folding_rules.cpp
@@ -112,6 +112,12 @@ bool IsValidResult(T val) {
   }
 }
 
+// Returns true if `type` is a cooperative matrix.
+bool IsCooperativeMatrix(const analysis::Type* type) {
+  return type->kind() == analysis::Type::kCooperativeMatrixKHR ||
+         type->kind() == analysis::Type::kCooperativeMatrixNV;
+}
+
 const analysis::Constant* ConstInput(
     const std::vector<const analysis::Constant*>& constants) {
   return constants[0] ? constants[0] : constants[1];
@@ -180,8 +186,14 @@ std::vector<uint32_t> GetWordsFromNumericScalarOrVectorConstant(
 const analysis::Constant* ConvertWordsToNumericScalarOrVectorConstant(
     analysis::ConstantManager* const_mgr, const std::vector<uint32_t>& words,
     const analysis::Type* type) {
-  if (type->AsInteger() || type->AsFloat())
-    return const_mgr->GetConstant(type, words);
+  const spvtools::opt::analysis::Integer* int_type = type->AsInteger();
+
+  if (int_type && int_type->width() <= 32) {
+    assert(words.size() == 1);
+    return const_mgr->GenerateIntegerConstant(int_type, words[0]);
+  }
+
+  if (int_type || type->AsFloat()) return const_mgr->GetConstant(type, words);
   if (const auto* vec_type = type->AsVector())
     return const_mgr->GetNumericVectorConstantWithWords(vec_type, words);
   return nullptr;
@@ -307,6 +319,11 @@ FoldingRule ReciprocalFDiv() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (!inst->IsFloatingPointFoldingAllowed()) return false;
 
     uint32_t width = ElementWidth(type);
@@ -388,6 +405,11 @@ FoldingRule MergeNegateMulDivArithmetic() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (HasFloatingPoint(type) && !inst->IsFloatingPointFoldingAllowed())
       return false;
 
@@ -400,36 +422,37 @@ FoldingRule MergeNegateMulDivArithmetic() {
     if (width != 32 && width != 64) return false;
 
     spv::Op opcode = op_inst->opcode();
-    if (opcode == spv::Op::OpFMul || opcode == spv::Op::OpFDiv ||
-        opcode == spv::Op::OpIMul || opcode == spv::Op::OpSDiv ||
-        opcode == spv::Op::OpUDiv) {
-      std::vector<const analysis::Constant*> op_constants =
-          const_mgr->GetOperandConstants(op_inst);
-      // Merge negate into mul or div if one operand is constant.
-      if (op_constants[0] || op_constants[1]) {
-        bool zero_is_variable = op_constants[0] == nullptr;
-        const analysis::Constant* c = ConstInput(op_constants);
-        uint32_t neg_id = NegateConstant(const_mgr, c);
-        uint32_t non_const_id = zero_is_variable
-                                    ? op_inst->GetSingleWordInOperand(0u)
-                                    : op_inst->GetSingleWordInOperand(1u);
-        // Change this instruction to a mul/div.
-        inst->SetOpcode(op_inst->opcode());
-        if (opcode == spv::Op::OpFDiv || opcode == spv::Op::OpUDiv ||
-            opcode == spv::Op::OpSDiv) {
-          uint32_t op0 = zero_is_variable ? non_const_id : neg_id;
-          uint32_t op1 = zero_is_variable ? neg_id : non_const_id;
-          inst->SetInOperands(
-              {{SPV_OPERAND_TYPE_ID, {op0}}, {SPV_OPERAND_TYPE_ID, {op1}}});
-        } else {
-          inst->SetInOperands({{SPV_OPERAND_TYPE_ID, {non_const_id}},
-                               {SPV_OPERAND_TYPE_ID, {neg_id}}});
-        }
-        return true;
-      }
+    if (opcode != spv::Op::OpFMul && opcode != spv::Op::OpFDiv &&
+        opcode != spv::Op::OpIMul && opcode != spv::Op::OpSDiv) {
+      return false;
     }
 
-    return false;
+    std::vector<const analysis::Constant*> op_constants =
+        const_mgr->GetOperandConstants(op_inst);
+    // Merge negate into mul or div if one operand is constant.
+    if (op_constants[0] == nullptr && op_constants[1] == nullptr) {
+      return false;
+    }
+
+    bool zero_is_variable = op_constants[0] == nullptr;
+    const analysis::Constant* c = ConstInput(op_constants);
+    uint32_t neg_id = NegateConstant(const_mgr, c);
+    uint32_t non_const_id = zero_is_variable
+                                ? op_inst->GetSingleWordInOperand(0u)
+                                : op_inst->GetSingleWordInOperand(1u);
+    // Change this instruction to a mul/div.
+    inst->SetOpcode(op_inst->opcode());
+    if (opcode == spv::Op::OpFDiv || opcode == spv::Op::OpUDiv ||
+        opcode == spv::Op::OpSDiv) {
+      uint32_t op0 = zero_is_variable ? non_const_id : neg_id;
+      uint32_t op1 = zero_is_variable ? neg_id : non_const_id;
+      inst->SetInOperands(
+          {{SPV_OPERAND_TYPE_ID, {op0}}, {SPV_OPERAND_TYPE_ID, {op1}}});
+    } else {
+      inst->SetInOperands({{SPV_OPERAND_TYPE_ID, {non_const_id}},
+                           {SPV_OPERAND_TYPE_ID, {neg_id}}});
+    }
+    return true;
   };
 }
 
@@ -449,6 +472,11 @@ FoldingRule MergeNegateAddSubArithmetic() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (HasFloatingPoint(type) && !inst->IsFloatingPointFoldingAllowed())
       return false;
 
@@ -680,6 +708,11 @@ FoldingRule MergeMulMulArithmetic() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (HasFloatingPoint(type) && !inst->IsFloatingPointFoldingAllowed())
       return false;
 
@@ -734,6 +767,11 @@ FoldingRule MergeMulDivArithmetic() {
 
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (!inst->IsFloatingPointFoldingAllowed()) return false;
 
     uint32_t width = ElementWidth(type);
@@ -807,6 +845,11 @@ FoldingRule MergeMulNegateArithmetic() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
 
@@ -847,6 +890,11 @@ FoldingRule MergeDivDivArithmetic() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (!inst->IsFloatingPointFoldingAllowed()) return false;
 
     uint32_t width = ElementWidth(type);
@@ -920,6 +968,11 @@ FoldingRule MergeDivMulArithmetic() {
 
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     if (!inst->IsFloatingPointFoldingAllowed()) return false;
 
     uint32_t width = ElementWidth(type);
@@ -1062,6 +1115,11 @@ FoldingRule MergeSubNegateArithmetic() {
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
 
@@ -1110,6 +1168,11 @@ FoldingRule MergeAddAddArithmetic() {
            inst->opcode() == spv::Op::OpIAdd);
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
@@ -1158,6 +1221,11 @@ FoldingRule MergeAddSubArithmetic() {
            inst->opcode() == spv::Op::OpIAdd);
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
@@ -1218,6 +1286,11 @@ FoldingRule MergeSubAddArithmetic() {
            inst->opcode() == spv::Op::OpISub);
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
@@ -1284,6 +1357,11 @@ FoldingRule MergeSubSubArithmetic() {
            inst->opcode() == spv::Op::OpISub);
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     analysis::ConstantManager* const_mgr = context->get_constant_mgr();
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
@@ -1377,6 +1455,11 @@ FoldingRule MergeGenericAddSubArithmetic() {
            inst->opcode() == spv::Op::OpIAdd);
     const analysis::Type* type =
         context->get_type_mgr()->GetType(inst->type_id());
+
+    if (IsCooperativeMatrix(type)) {
+      return false;
+    }
+
     bool uses_float = HasFloatingPoint(type);
     if (uses_float && !inst->IsFloatingPointFoldingAllowed()) return false;
 
@@ -1459,132 +1542,6 @@ FoldingRule FactorAddMuls() {
   };
 }
 
-// Replaces |inst| inplace with an FMA instruction |(x*y)+a|.
-void ReplaceWithFma(Instruction* inst, uint32_t x, uint32_t y, uint32_t a) {
-  uint32_t ext =
-      inst->context()->get_feature_mgr()->GetExtInstImportId_GLSLstd450();
-
-  if (ext == 0) {
-    inst->context()->AddExtInstImport("GLSL.std.450");
-    ext = inst->context()->get_feature_mgr()->GetExtInstImportId_GLSLstd450();
-    assert(ext != 0 &&
-           "Could not add the GLSL.std.450 extended instruction set");
-  }
-
-  std::vector<Operand> operands;
-  operands.push_back({SPV_OPERAND_TYPE_ID, {ext}});
-  operands.push_back({SPV_OPERAND_TYPE_LITERAL_INTEGER, {GLSLstd450Fma}});
-  operands.push_back({SPV_OPERAND_TYPE_ID, {x}});
-  operands.push_back({SPV_OPERAND_TYPE_ID, {y}});
-  operands.push_back({SPV_OPERAND_TYPE_ID, {a}});
-
-  inst->SetOpcode(spv::Op::OpExtInst);
-  inst->SetInOperands(std::move(operands));
-}
-
-// Folds a multiple and add into an Fma.
-//
-// Cases:
-// (x * y) + a = Fma x y a
-// a + (x * y) = Fma x y a
-bool MergeMulAddArithmetic(IRContext* context, Instruction* inst,
-                           const std::vector<const analysis::Constant*>&) {
-  assert(inst->opcode() == spv::Op::OpFAdd);
-
-  if (!inst->IsFloatingPointFoldingAllowed()) {
-    return false;
-  }
-
-  analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();
-  for (int i = 0; i < 2; i++) {
-    uint32_t op_id = inst->GetSingleWordInOperand(i);
-    Instruction* op_inst = def_use_mgr->GetDef(op_id);
-
-    if (op_inst->opcode() != spv::Op::OpFMul) {
-      continue;
-    }
-
-    if (!op_inst->IsFloatingPointFoldingAllowed()) {
-      continue;
-    }
-
-    uint32_t x = op_inst->GetSingleWordInOperand(0);
-    uint32_t y = op_inst->GetSingleWordInOperand(1);
-    uint32_t a = inst->GetSingleWordInOperand((i + 1) % 2);
-    ReplaceWithFma(inst, x, y, a);
-    return true;
-  }
-  return false;
-}
-
-// Replaces |sub| inplace with an FMA instruction |(x*y)+a| where |a| first gets
-// negated if |negate_addition| is true, otherwise |x| gets negated.
-void ReplaceWithFmaAndNegate(Instruction* sub, uint32_t x, uint32_t y,
-                             uint32_t a, bool negate_addition) {
-  uint32_t ext =
-      sub->context()->get_feature_mgr()->GetExtInstImportId_GLSLstd450();
-
-  if (ext == 0) {
-    sub->context()->AddExtInstImport("GLSL.std.450");
-    ext = sub->context()->get_feature_mgr()->GetExtInstImportId_GLSLstd450();
-    assert(ext != 0 &&
-           "Could not add the GLSL.std.450 extended instruction set");
-  }
-
-  InstructionBuilder ir_builder(
-      sub->context(), sub,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-
-  Instruction* neg = ir_builder.AddUnaryOp(sub->type_id(), spv::Op::OpFNegate,
-                                           negate_addition ? a : x);
-  uint32_t neg_op = neg->result_id();  // -a : -x
-
-  std::vector<Operand> operands;
-  operands.push_back({SPV_OPERAND_TYPE_ID, {ext}});
-  operands.push_back({SPV_OPERAND_TYPE_LITERAL_INTEGER, {GLSLstd450Fma}});
-  operands.push_back({SPV_OPERAND_TYPE_ID, {negate_addition ? x : neg_op}});
-  operands.push_back({SPV_OPERAND_TYPE_ID, {y}});
-  operands.push_back({SPV_OPERAND_TYPE_ID, {negate_addition ? neg_op : a}});
-
-  sub->SetOpcode(spv::Op::OpExtInst);
-  sub->SetInOperands(std::move(operands));
-}
-
-// Folds a multiply and subtract into an Fma and negation.
-//
-// Cases:
-// (x * y) - a = Fma x y -a
-// a - (x * y) = Fma -x y a
-bool MergeMulSubArithmetic(IRContext* context, Instruction* sub,
-                           const std::vector<const analysis::Constant*>&) {
-  assert(sub->opcode() == spv::Op::OpFSub);
-
-  if (!sub->IsFloatingPointFoldingAllowed()) {
-    return false;
-  }
-
-  analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();
-  for (int i = 0; i < 2; i++) {
-    uint32_t op_id = sub->GetSingleWordInOperand(i);
-    Instruction* mul = def_use_mgr->GetDef(op_id);
-
-    if (mul->opcode() != spv::Op::OpFMul) {
-      continue;
-    }
-
-    if (!mul->IsFloatingPointFoldingAllowed()) {
-      continue;
-    }
-
-    uint32_t x = mul->GetSingleWordInOperand(0);
-    uint32_t y = mul->GetSingleWordInOperand(1);
-    uint32_t a = sub->GetSingleWordInOperand((i + 1) % 2);
-    ReplaceWithFmaAndNegate(sub, x, y, a, i == 0);
-    return true;
-  }
-  return false;
-}
-
 FoldingRule IntMultipleBy1() {
   return [](IRContext*, Instruction* inst,
             const std::vector<const analysis::Constant*>& constants) {
@@ -1733,27 +1690,26 @@ bool CompositeConstructFeedingExtract(
 }
 
 // Walks the indexes chain from |start| to |end| of an OpCompositeInsert or
-// OpCompositeExtract instruction, and returns the type of the final element
-// being accessed.
-const analysis::Type* GetElementType(uint32_t type_id,
-                                     Instruction::iterator start,
-                                     Instruction::iterator end,
-                                     const analysis::TypeManager* type_mgr) {
-  const analysis::Type* type = type_mgr->GetType(type_id);
+// OpCompositeExtract instruction, and returns the type id of the final element
+// being accessed. Returns 0 if a valid type could not be found.
+uint32_t GetElementType(uint32_t type_id, Instruction::iterator start,
+                        Instruction::iterator end,
+                        const analysis::DefUseManager* def_use_manager) {
   for (auto index : make_range(std::move(start), std::move(end))) {
+    const Instruction* type_inst = def_use_manager->GetDef(type_id);
     assert(index.type == SPV_OPERAND_TYPE_LITERAL_INTEGER &&
            index.words.size() == 1);
-    if (auto* array_type = type->AsArray()) {
-      type = array_type->element_type();
-    } else if (auto* matrix_type = type->AsMatrix()) {
-      type = matrix_type->element_type();
-    } else if (auto* struct_type = type->AsStruct()) {
-      type = struct_type->element_types()[index.words[0]];
+    if (type_inst->opcode() == spv::Op::OpTypeArray) {
+      type_id = type_inst->GetSingleWordInOperand(0);
+    } else if (type_inst->opcode() == spv::Op::OpTypeMatrix) {
+      type_id = type_inst->GetSingleWordInOperand(0);
+    } else if (type_inst->opcode() == spv::Op::OpTypeStruct) {
+      type_id = type_inst->GetSingleWordInOperand(index.words[0]);
     } else {
-      type = nullptr;
+      return 0;
     }
   }
-  return type;
+  return type_id;
 }
 
 // Returns true of |inst_1| and |inst_2| have the same indexes that will be used
@@ -1834,20 +1790,16 @@ bool CompositeExtractFeedingConstruct(
       return false;
     }
   }
+  assert(first_element_inst != nullptr);
 
   // The last check it to see that the object being extracted from is the
   // correct type.
   Instruction* original_inst = def_use_mgr->GetDef(original_id);
-  analysis::TypeManager* type_mgr = context->get_type_mgr();
-  const analysis::Type* original_type =
+  uint32_t original_type_id =
       GetElementType(original_inst->type_id(), first_element_inst->begin() + 3,
-                     first_element_inst->end() - 1, type_mgr);
-
-  if (original_type == nullptr) {
-    return false;
-  }
+                     first_element_inst->end() - 1, def_use_mgr);
 
-  if (inst->type_id() != type_mgr->GetId(original_type)) {
+  if (inst->type_id() != original_type_id) {
     return false;
   }
 
@@ -2137,13 +2089,15 @@ bool DoInsertedValuesCoverEntireObject(
   return true;
 }
 
-// Returns the type of the element that immediately contains the element being
-// inserted by the OpCompositeInsert instruction |inst|.
-const analysis::Type* GetContainerType(Instruction* inst) {
+// Returns id of the type of the element that immediately contains the element
+// being inserted by the OpCompositeInsert instruction |inst|. Returns 0 if it
+// could not be found.
+uint32_t GetContainerTypeId(Instruction* inst) {
   assert(inst->opcode() == spv::Op::OpCompositeInsert);
-  analysis::TypeManager* type_mgr = inst->context()->get_type_mgr();
-  return GetElementType(inst->type_id(), inst->begin() + 4, inst->end() - 1,
-                        type_mgr);
+  analysis::DefUseManager* def_use_manager = inst->context()->get_def_use_mgr();
+  uint32_t container_type_id = GetElementType(
+      inst->type_id(), inst->begin() + 4, inst->end() - 1, def_use_manager);
+  return container_type_id;
 }
 
 // Returns an OpCompositeConstruct instruction that build an object with
@@ -2190,18 +2144,20 @@ bool CompositeInsertToCompositeConstruct(
   if (inst->NumInOperands() < 3) return false;
 
   std::map<uint32_t, uint32_t> values_inserted = GetInsertedValues(inst);
-  const analysis::Type* container_type = GetContainerType(inst);
-  if (container_type == nullptr) {
+  uint32_t container_type_id = GetContainerTypeId(inst);
+  if (container_type_id == 0) {
     return false;
   }
 
+  analysis::TypeManager* type_mgr = context->get_type_mgr();
+  const analysis::Type* container_type = type_mgr->GetType(container_type_id);
+  assert(container_type && "GetContainerTypeId returned a bad id.");
   if (!DoInsertedValuesCoverEntireObject(container_type, values_inserted)) {
     return false;
   }
 
-  analysis::TypeManager* type_mgr = context->get_type_mgr();
-  Instruction* construct = BuildCompositeConstruct(
-      type_mgr->GetId(container_type), values_inserted, inst);
+  Instruction* construct =
+      BuildCompositeConstruct(container_type_id, values_inserted, inst);
   InsertConstructedObject(inst, construct);
   return true;
 }
@@ -2941,7 +2897,6 @@ void FoldingRules::AddFoldingRules() {
   rules_[spv::Op::OpFAdd].push_back(MergeAddSubArithmetic());
   rules_[spv::Op::OpFAdd].push_back(MergeGenericAddSubArithmetic());
   rules_[spv::Op::OpFAdd].push_back(FactorAddMuls());
-  rules_[spv::Op::OpFAdd].push_back(MergeMulAddArithmetic);
 
   rules_[spv::Op::OpFDiv].push_back(RedundantFDiv());
   rules_[spv::Op::OpFDiv].push_back(ReciprocalFDiv());
@@ -2962,7 +2917,6 @@ void FoldingRules::AddFoldingRules() {
   rules_[spv::Op::OpFSub].push_back(MergeSubNegateArithmetic());
   rules_[spv::Op::OpFSub].push_back(MergeSubAddArithmetic());
   rules_[spv::Op::OpFSub].push_back(MergeSubSubArithmetic());
-  rules_[spv::Op::OpFSub].push_back(MergeMulSubArithmetic);
 
   rules_[spv::Op::OpIAdd].push_back(RedundantIAdd());
   rules_[spv::Op::OpIAdd].push_back(MergeAddNegateArithmetic());
diff --git a/source/opt/inline_pass.cpp b/source/opt/inline_pass.cpp
index 3f160b24..31864334 100644
--- a/source/opt/inline_pass.cpp
+++ b/source/opt/inline_pass.cpp
@@ -213,6 +213,19 @@ uint32_t InlinePass::CreateReturnVar(
         {(uint32_t)spv::StorageClass::Function}}}));
   new_vars->push_back(std::move(var_inst));
   get_decoration_mgr()->CloneDecorations(calleeFn->result_id(), returnVarId);
+
+  // Decorate the return var with AliasedPointer if the storage class of the
+  // pointee type is PhysicalStorageBuffer.
+  auto const pointee_type =
+      type_mgr->GetType(returnVarTypeId)->AsPointer()->pointee_type();
+  if (pointee_type->AsPointer() != nullptr) {
+    if (pointee_type->AsPointer()->storage_class() ==
+        spv::StorageClass::PhysicalStorageBuffer) {
+      get_decoration_mgr()->AddDecoration(
+          returnVarId, uint32_t(spv::Decoration::AliasedPointer));
+    }
+  }
+
   return returnVarId;
 }
 
diff --git a/source/opt/inst_bindless_check_pass.cpp b/source/opt/inst_bindless_check_pass.cpp
deleted file mode 100644
index 8e7d4f83..00000000
--- a/source/opt/inst_bindless_check_pass.cpp
+++ /dev/null
@@ -1,761 +0,0 @@
-// Copyright (c) 2018 The Khronos Group Inc.
-// Copyright (c) 2018 Valve Corporation
-// Copyright (c) 2018 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "inst_bindless_check_pass.h"
-
-#include "source/spirv_constant.h"
-
-namespace spvtools {
-namespace opt {
-namespace {
-// Input Operand Indices
-constexpr int kSpvImageSampleImageIdInIdx = 0;
-constexpr int kSpvSampledImageImageIdInIdx = 0;
-constexpr int kSpvSampledImageSamplerIdInIdx = 1;
-constexpr int kSpvImageSampledImageIdInIdx = 0;
-constexpr int kSpvCopyObjectOperandIdInIdx = 0;
-constexpr int kSpvLoadPtrIdInIdx = 0;
-constexpr int kSpvAccessChainBaseIdInIdx = 0;
-constexpr int kSpvAccessChainIndex0IdInIdx = 1;
-constexpr int kSpvTypeArrayTypeIdInIdx = 0;
-constexpr int kSpvVariableStorageClassInIdx = 0;
-constexpr int kSpvTypePtrTypeIdInIdx = 1;
-constexpr int kSpvTypeImageDim = 1;
-constexpr int kSpvTypeImageDepth = 2;
-constexpr int kSpvTypeImageArrayed = 3;
-constexpr int kSpvTypeImageMS = 4;
-}  // namespace
-
-// This is a stub function for use with Import linkage
-// clang-format off
-// GLSL:
-//bool inst_bindless_check_desc(const uint shader_id, const uint inst_num, const uvec4 stage_info, const uint desc_set,
-//                              const uint binding, const uint desc_index, const uint byte_offset) {
-//}
-// clang-format on
-uint32_t InstBindlessCheckPass::GenDescCheckFunctionId() {
-  enum {
-    kShaderId = 0,
-    kInstructionIndex = 1,
-    kStageInfo = 2,
-    kDescSet = 3,
-    kDescBinding = 4,
-    kDescIndex = 5,
-    kByteOffset = 6,
-    kNumArgs
-  };
-  if (check_desc_func_id_ != 0) {
-    return check_desc_func_id_;
-  }
-
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  const analysis::Integer* uint_type = GetInteger(32, false);
-  const analysis::Vector v4uint(uint_type, 4);
-  const analysis::Type* v4uint_type = type_mgr->GetRegisteredType(&v4uint);
-  std::vector<const analysis::Type*> param_types(kNumArgs, uint_type);
-  param_types[2] = v4uint_type;
-
-  const uint32_t func_id = TakeNextId();
-  std::unique_ptr<Function> func =
-      StartFunction(func_id, type_mgr->GetBoolType(), param_types);
-
-  func->SetFunctionEnd(EndFunction());
-
-  static const std::string func_name{"inst_bindless_check_desc"};
-  context()->AddFunctionDeclaration(std::move(func));
-  context()->AddDebug2Inst(NewName(func_id, func_name));
-  std::vector<Operand> operands{
-      {spv_operand_type_t::SPV_OPERAND_TYPE_ID, {func_id}},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LITERAL_INTEGER,
-       {uint32_t(spv::Decoration::LinkageAttributes)}},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LITERAL_STRING,
-       utils::MakeVector(func_name.c_str())},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LINKAGE_TYPE,
-       {uint32_t(spv::LinkageType::Import)}},
-  };
-  get_decoration_mgr()->AddDecoration(spv::Op::OpDecorate, operands);
-
-  check_desc_func_id_ = func_id;
-  // Make sure function doesn't get processed by
-  // InstrumentPass::InstProcessCallTreeFromRoots()
-  param2output_func_id_[3] = func_id;
-  return check_desc_func_id_;
-}
-
-// clang-format off
-// GLSL:
-// result = inst_bindless_check_desc(shader_id, inst_idx, stage_info, desc_set, binding, desc_idx, offset);
-//
-// clang-format on
-uint32_t InstBindlessCheckPass::GenDescCheckCall(
-    uint32_t inst_idx, uint32_t stage_idx, uint32_t var_id,
-    uint32_t desc_idx_id, uint32_t offset_id, InstructionBuilder* builder) {
-  const uint32_t func_id = GenDescCheckFunctionId();
-  const std::vector<uint32_t> args = {
-      builder->GetUintConstantId(shader_id_),
-      builder->GetUintConstantId(inst_idx),
-      GenStageInfo(stage_idx, builder),
-      builder->GetUintConstantId(var2desc_set_[var_id]),
-      builder->GetUintConstantId(var2binding_[var_id]),
-      GenUintCastCode(desc_idx_id, builder),
-      offset_id};
-  return GenReadFunctionCall(GetBoolId(), func_id, args, builder);
-}
-
-uint32_t InstBindlessCheckPass::CloneOriginalImage(
-    uint32_t old_image_id, InstructionBuilder* builder) {
-  Instruction* new_image_inst;
-  Instruction* old_image_inst = get_def_use_mgr()->GetDef(old_image_id);
-  if (old_image_inst->opcode() == spv::Op::OpLoad) {
-    new_image_inst = builder->AddLoad(
-        old_image_inst->type_id(),
-        old_image_inst->GetSingleWordInOperand(kSpvLoadPtrIdInIdx));
-  } else if (old_image_inst->opcode() == spv::Op::OpSampledImage) {
-    uint32_t clone_id = CloneOriginalImage(
-        old_image_inst->GetSingleWordInOperand(kSpvSampledImageImageIdInIdx),
-        builder);
-    new_image_inst = builder->AddBinaryOp(
-        old_image_inst->type_id(), spv::Op::OpSampledImage, clone_id,
-        old_image_inst->GetSingleWordInOperand(kSpvSampledImageSamplerIdInIdx));
-  } else if (old_image_inst->opcode() == spv::Op::OpImage) {
-    uint32_t clone_id = CloneOriginalImage(
-        old_image_inst->GetSingleWordInOperand(kSpvImageSampledImageIdInIdx),
-        builder);
-    new_image_inst = builder->AddUnaryOp(old_image_inst->type_id(),
-                                         spv::Op::OpImage, clone_id);
-  } else {
-    assert(old_image_inst->opcode() == spv::Op::OpCopyObject &&
-           "expecting OpCopyObject");
-    uint32_t clone_id = CloneOriginalImage(
-        old_image_inst->GetSingleWordInOperand(kSpvCopyObjectOperandIdInIdx),
-        builder);
-    // Since we are cloning, no need to create new copy
-    new_image_inst = get_def_use_mgr()->GetDef(clone_id);
-  }
-  uid2offset_[new_image_inst->unique_id()] =
-      uid2offset_[old_image_inst->unique_id()];
-  uint32_t new_image_id = new_image_inst->result_id();
-  get_decoration_mgr()->CloneDecorations(old_image_id, new_image_id);
-  return new_image_id;
-}
-
-uint32_t InstBindlessCheckPass::CloneOriginalReference(
-    RefAnalysis* ref, InstructionBuilder* builder) {
-  // If original is image based, start by cloning descriptor load
-  uint32_t new_image_id = 0;
-  if (ref->desc_load_id != 0) {
-    uint32_t old_image_id =
-        ref->ref_inst->GetSingleWordInOperand(kSpvImageSampleImageIdInIdx);
-    new_image_id = CloneOriginalImage(old_image_id, builder);
-  }
-  // Clone original reference
-  std::unique_ptr<Instruction> new_ref_inst(ref->ref_inst->Clone(context()));
-  uint32_t ref_result_id = ref->ref_inst->result_id();
-  uint32_t new_ref_id = 0;
-  if (ref_result_id != 0) {
-    new_ref_id = TakeNextId();
-    new_ref_inst->SetResultId(new_ref_id);
-  }
-  // Update new ref with new image if created
-  if (new_image_id != 0)
-    new_ref_inst->SetInOperand(kSpvImageSampleImageIdInIdx, {new_image_id});
-  // Register new reference and add to new block
-  Instruction* added_inst = builder->AddInstruction(std::move(new_ref_inst));
-  uid2offset_[added_inst->unique_id()] =
-      uid2offset_[ref->ref_inst->unique_id()];
-  if (new_ref_id != 0)
-    get_decoration_mgr()->CloneDecorations(ref_result_id, new_ref_id);
-  return new_ref_id;
-}
-
-uint32_t InstBindlessCheckPass::GetImageId(Instruction* inst) {
-  switch (inst->opcode()) {
-    case spv::Op::OpImageSampleImplicitLod:
-    case spv::Op::OpImageSampleExplicitLod:
-    case spv::Op::OpImageSampleDrefImplicitLod:
-    case spv::Op::OpImageSampleDrefExplicitLod:
-    case spv::Op::OpImageSampleProjImplicitLod:
-    case spv::Op::OpImageSampleProjExplicitLod:
-    case spv::Op::OpImageSampleProjDrefImplicitLod:
-    case spv::Op::OpImageSampleProjDrefExplicitLod:
-    case spv::Op::OpImageGather:
-    case spv::Op::OpImageDrefGather:
-    case spv::Op::OpImageQueryLod:
-    case spv::Op::OpImageSparseSampleImplicitLod:
-    case spv::Op::OpImageSparseSampleExplicitLod:
-    case spv::Op::OpImageSparseSampleDrefImplicitLod:
-    case spv::Op::OpImageSparseSampleDrefExplicitLod:
-    case spv::Op::OpImageSparseSampleProjImplicitLod:
-    case spv::Op::OpImageSparseSampleProjExplicitLod:
-    case spv::Op::OpImageSparseSampleProjDrefImplicitLod:
-    case spv::Op::OpImageSparseSampleProjDrefExplicitLod:
-    case spv::Op::OpImageSparseGather:
-    case spv::Op::OpImageSparseDrefGather:
-    case spv::Op::OpImageFetch:
-    case spv::Op::OpImageRead:
-    case spv::Op::OpImageQueryFormat:
-    case spv::Op::OpImageQueryOrder:
-    case spv::Op::OpImageQuerySizeLod:
-    case spv::Op::OpImageQuerySize:
-    case spv::Op::OpImageQueryLevels:
-    case spv::Op::OpImageQuerySamples:
-    case spv::Op::OpImageSparseFetch:
-    case spv::Op::OpImageSparseRead:
-    case spv::Op::OpImageWrite:
-      return inst->GetSingleWordInOperand(kSpvImageSampleImageIdInIdx);
-    default:
-      break;
-  }
-  return 0;
-}
-
-Instruction* InstBindlessCheckPass::GetPointeeTypeInst(Instruction* ptr_inst) {
-  uint32_t pte_ty_id = GetPointeeTypeId(ptr_inst);
-  return get_def_use_mgr()->GetDef(pte_ty_id);
-}
-
-bool InstBindlessCheckPass::AnalyzeDescriptorReference(Instruction* ref_inst,
-                                                       RefAnalysis* ref) {
-  ref->ref_inst = ref_inst;
-  if (ref_inst->opcode() == spv::Op::OpLoad ||
-      ref_inst->opcode() == spv::Op::OpStore) {
-    ref->desc_load_id = 0;
-    ref->ptr_id = ref_inst->GetSingleWordInOperand(kSpvLoadPtrIdInIdx);
-    Instruction* ptr_inst = get_def_use_mgr()->GetDef(ref->ptr_id);
-    if (ptr_inst->opcode() != spv::Op::OpAccessChain) return false;
-    ref->var_id = ptr_inst->GetSingleWordInOperand(kSpvAccessChainBaseIdInIdx);
-    Instruction* var_inst = get_def_use_mgr()->GetDef(ref->var_id);
-    if (var_inst->opcode() != spv::Op::OpVariable) return false;
-    spv::StorageClass storage_class = spv::StorageClass(
-        var_inst->GetSingleWordInOperand(kSpvVariableStorageClassInIdx));
-    switch (storage_class) {
-      case spv::StorageClass::Uniform:
-      case spv::StorageClass::StorageBuffer:
-        break;
-      default:
-        return false;
-        break;
-    }
-    // Check for deprecated storage block form
-    if (storage_class == spv::StorageClass::Uniform) {
-      uint32_t var_ty_id = var_inst->type_id();
-      Instruction* var_ty_inst = get_def_use_mgr()->GetDef(var_ty_id);
-      uint32_t ptr_ty_id =
-          var_ty_inst->GetSingleWordInOperand(kSpvTypePtrTypeIdInIdx);
-      Instruction* ptr_ty_inst = get_def_use_mgr()->GetDef(ptr_ty_id);
-      spv::Op ptr_ty_op = ptr_ty_inst->opcode();
-      uint32_t block_ty_id =
-          (ptr_ty_op == spv::Op::OpTypeArray ||
-           ptr_ty_op == spv::Op::OpTypeRuntimeArray)
-              ? ptr_ty_inst->GetSingleWordInOperand(kSpvTypeArrayTypeIdInIdx)
-              : ptr_ty_id;
-      assert(get_def_use_mgr()->GetDef(block_ty_id)->opcode() ==
-                 spv::Op::OpTypeStruct &&
-             "unexpected block type");
-      bool block_found = get_decoration_mgr()->FindDecoration(
-          block_ty_id, uint32_t(spv::Decoration::Block),
-          [](const Instruction&) { return true; });
-      if (!block_found) {
-        // If block decoration not found, verify deprecated form of SSBO
-        bool buffer_block_found = get_decoration_mgr()->FindDecoration(
-            block_ty_id, uint32_t(spv::Decoration::BufferBlock),
-            [](const Instruction&) { return true; });
-        USE_ASSERT(buffer_block_found && "block decoration not found");
-        storage_class = spv::StorageClass::StorageBuffer;
-      }
-    }
-    ref->strg_class = uint32_t(storage_class);
-    Instruction* desc_type_inst = GetPointeeTypeInst(var_inst);
-    switch (desc_type_inst->opcode()) {
-      case spv::Op::OpTypeArray:
-      case spv::Op::OpTypeRuntimeArray:
-        // A load through a descriptor array will have at least 3 operands. We
-        // do not want to instrument loads of descriptors here which are part of
-        // an image-based reference.
-        if (ptr_inst->NumInOperands() < 3) return false;
-        ref->desc_idx_id =
-            ptr_inst->GetSingleWordInOperand(kSpvAccessChainIndex0IdInIdx);
-        break;
-      default:
-        break;
-    }
-    auto decos =
-        context()->get_decoration_mgr()->GetDecorationsFor(ref->var_id, false);
-    for (const auto& deco : decos) {
-      spv::Decoration d = spv::Decoration(deco->GetSingleWordInOperand(1u));
-      if (d == spv::Decoration::DescriptorSet) {
-        ref->set = deco->GetSingleWordInOperand(2u);
-      } else if (d == spv::Decoration::Binding) {
-        ref->binding = deco->GetSingleWordInOperand(2u);
-      }
-    }
-    return true;
-  }
-  // Reference is not load or store. If not an image-based reference, return.
-  ref->image_id = GetImageId(ref_inst);
-  if (ref->image_id == 0) return false;
-  // Search for descriptor load
-  uint32_t desc_load_id = ref->image_id;
-  Instruction* desc_load_inst;
-  for (;;) {
-    desc_load_inst = get_def_use_mgr()->GetDef(desc_load_id);
-    if (desc_load_inst->opcode() == spv::Op::OpSampledImage)
-      desc_load_id =
-          desc_load_inst->GetSingleWordInOperand(kSpvSampledImageImageIdInIdx);
-    else if (desc_load_inst->opcode() == spv::Op::OpImage)
-      desc_load_id =
-          desc_load_inst->GetSingleWordInOperand(kSpvImageSampledImageIdInIdx);
-    else if (desc_load_inst->opcode() == spv::Op::OpCopyObject)
-      desc_load_id =
-          desc_load_inst->GetSingleWordInOperand(kSpvCopyObjectOperandIdInIdx);
-    else
-      break;
-  }
-  if (desc_load_inst->opcode() != spv::Op::OpLoad) {
-    // TODO(greg-lunarg): Handle additional possibilities?
-    return false;
-  }
-  ref->desc_load_id = desc_load_id;
-  ref->ptr_id = desc_load_inst->GetSingleWordInOperand(kSpvLoadPtrIdInIdx);
-  Instruction* ptr_inst = get_def_use_mgr()->GetDef(ref->ptr_id);
-  if (ptr_inst->opcode() == spv::Op::OpVariable) {
-    ref->desc_idx_id = 0;
-    ref->var_id = ref->ptr_id;
-  } else if (ptr_inst->opcode() == spv::Op::OpAccessChain) {
-    if (ptr_inst->NumInOperands() != 2) {
-      assert(false && "unexpected bindless index number");
-      return false;
-    }
-    ref->desc_idx_id =
-        ptr_inst->GetSingleWordInOperand(kSpvAccessChainIndex0IdInIdx);
-    ref->var_id = ptr_inst->GetSingleWordInOperand(kSpvAccessChainBaseIdInIdx);
-    Instruction* var_inst = get_def_use_mgr()->GetDef(ref->var_id);
-    if (var_inst->opcode() != spv::Op::OpVariable) {
-      assert(false && "unexpected bindless base");
-      return false;
-    }
-  } else {
-    // TODO(greg-lunarg): Handle additional possibilities?
-    return false;
-  }
-  auto decos =
-      context()->get_decoration_mgr()->GetDecorationsFor(ref->var_id, false);
-  for (const auto& deco : decos) {
-    spv::Decoration d = spv::Decoration(deco->GetSingleWordInOperand(1u));
-    if (d == spv::Decoration::DescriptorSet) {
-      ref->set = deco->GetSingleWordInOperand(2u);
-    } else if (d == spv::Decoration::Binding) {
-      ref->binding = deco->GetSingleWordInOperand(2u);
-    }
-  }
-  return true;
-}
-
-uint32_t InstBindlessCheckPass::FindStride(uint32_t ty_id,
-                                           uint32_t stride_deco) {
-  uint32_t stride = 0xdeadbeef;
-  bool found = get_decoration_mgr()->FindDecoration(
-      ty_id, stride_deco, [&stride](const Instruction& deco_inst) {
-        stride = deco_inst.GetSingleWordInOperand(2u);
-        return true;
-      });
-  USE_ASSERT(found && "stride not found");
-  return stride;
-}
-
-uint32_t InstBindlessCheckPass::ByteSize(uint32_t ty_id, uint32_t matrix_stride,
-                                         bool col_major, bool in_matrix) {
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  const analysis::Type* sz_ty = type_mgr->GetType(ty_id);
-  if (sz_ty->kind() == analysis::Type::kPointer) {
-    // Assuming PhysicalStorageBuffer pointer
-    return 8;
-  }
-  if (sz_ty->kind() == analysis::Type::kMatrix) {
-    assert(matrix_stride != 0 && "missing matrix stride");
-    const analysis::Matrix* m_ty = sz_ty->AsMatrix();
-    if (col_major) {
-      return m_ty->element_count() * matrix_stride;
-    } else {
-      const analysis::Vector* v_ty = m_ty->element_type()->AsVector();
-      return v_ty->element_count() * matrix_stride;
-    }
-  }
-  uint32_t size = 1;
-  if (sz_ty->kind() == analysis::Type::kVector) {
-    const analysis::Vector* v_ty = sz_ty->AsVector();
-    size = v_ty->element_count();
-    const analysis::Type* comp_ty = v_ty->element_type();
-    // if vector in row major matrix, the vector is strided so return the
-    // number of bytes spanned by the vector
-    if (in_matrix && !col_major && matrix_stride > 0) {
-      uint32_t comp_ty_id = type_mgr->GetId(comp_ty);
-      return (size - 1) * matrix_stride + ByteSize(comp_ty_id, 0, false, false);
-    }
-    sz_ty = comp_ty;
-  }
-  switch (sz_ty->kind()) {
-    case analysis::Type::kFloat: {
-      const analysis::Float* f_ty = sz_ty->AsFloat();
-      size *= f_ty->width();
-    } break;
-    case analysis::Type::kInteger: {
-      const analysis::Integer* i_ty = sz_ty->AsInteger();
-      size *= i_ty->width();
-    } break;
-    default: { assert(false && "unexpected type"); } break;
-  }
-  size /= 8;
-  return size;
-}
-
-uint32_t InstBindlessCheckPass::GenLastByteIdx(RefAnalysis* ref,
-                                               InstructionBuilder* builder) {
-  // Find outermost buffer type and its access chain index
-  Instruction* var_inst = get_def_use_mgr()->GetDef(ref->var_id);
-  Instruction* desc_ty_inst = GetPointeeTypeInst(var_inst);
-  uint32_t buff_ty_id;
-  uint32_t ac_in_idx = 1;
-  switch (desc_ty_inst->opcode()) {
-    case spv::Op::OpTypeArray:
-    case spv::Op::OpTypeRuntimeArray:
-      buff_ty_id = desc_ty_inst->GetSingleWordInOperand(0);
-      ++ac_in_idx;
-      break;
-    default:
-      assert(desc_ty_inst->opcode() == spv::Op::OpTypeStruct &&
-             "unexpected descriptor type");
-      buff_ty_id = desc_ty_inst->result_id();
-      break;
-  }
-  // Process remaining access chain indices
-  Instruction* ac_inst = get_def_use_mgr()->GetDef(ref->ptr_id);
-  uint32_t curr_ty_id = buff_ty_id;
-  uint32_t sum_id = 0u;
-  uint32_t matrix_stride = 0u;
-  bool col_major = false;
-  uint32_t matrix_stride_id = 0u;
-  bool in_matrix = false;
-  while (ac_in_idx < ac_inst->NumInOperands()) {
-    uint32_t curr_idx_id = ac_inst->GetSingleWordInOperand(ac_in_idx);
-    Instruction* curr_ty_inst = get_def_use_mgr()->GetDef(curr_ty_id);
-    uint32_t curr_offset_id = 0;
-    switch (curr_ty_inst->opcode()) {
-      case spv::Op::OpTypeArray:
-      case spv::Op::OpTypeRuntimeArray: {
-        // Get array stride and multiply by current index
-        uint32_t arr_stride =
-            FindStride(curr_ty_id, uint32_t(spv::Decoration::ArrayStride));
-        uint32_t arr_stride_id = builder->GetUintConstantId(arr_stride);
-        uint32_t curr_idx_32b_id = Gen32BitCvtCode(curr_idx_id, builder);
-        Instruction* curr_offset_inst = builder->AddBinaryOp(
-            GetUintId(), spv::Op::OpIMul, arr_stride_id, curr_idx_32b_id);
-        curr_offset_id = curr_offset_inst->result_id();
-        // Get element type for next step
-        curr_ty_id = curr_ty_inst->GetSingleWordInOperand(0);
-      } break;
-      case spv::Op::OpTypeMatrix: {
-        assert(matrix_stride != 0 && "missing matrix stride");
-        matrix_stride_id = builder->GetUintConstantId(matrix_stride);
-        uint32_t vec_ty_id = curr_ty_inst->GetSingleWordInOperand(0);
-        // If column major, multiply column index by matrix stride, otherwise
-        // by vector component size and save matrix stride for vector (row)
-        // index
-        uint32_t col_stride_id;
-        if (col_major) {
-          col_stride_id = matrix_stride_id;
-        } else {
-          Instruction* vec_ty_inst = get_def_use_mgr()->GetDef(vec_ty_id);
-          uint32_t comp_ty_id = vec_ty_inst->GetSingleWordInOperand(0u);
-          uint32_t col_stride = ByteSize(comp_ty_id, 0u, false, false);
-          col_stride_id = builder->GetUintConstantId(col_stride);
-        }
-        uint32_t curr_idx_32b_id = Gen32BitCvtCode(curr_idx_id, builder);
-        Instruction* curr_offset_inst = builder->AddBinaryOp(
-            GetUintId(), spv::Op::OpIMul, col_stride_id, curr_idx_32b_id);
-        curr_offset_id = curr_offset_inst->result_id();
-        // Get element type for next step
-        curr_ty_id = vec_ty_id;
-        in_matrix = true;
-      } break;
-      case spv::Op::OpTypeVector: {
-        // If inside a row major matrix type, multiply index by matrix stride,
-        // else multiply by component size
-        uint32_t comp_ty_id = curr_ty_inst->GetSingleWordInOperand(0u);
-        uint32_t curr_idx_32b_id = Gen32BitCvtCode(curr_idx_id, builder);
-        if (in_matrix && !col_major) {
-          Instruction* curr_offset_inst = builder->AddBinaryOp(
-              GetUintId(), spv::Op::OpIMul, matrix_stride_id, curr_idx_32b_id);
-          curr_offset_id = curr_offset_inst->result_id();
-        } else {
-          uint32_t comp_ty_sz = ByteSize(comp_ty_id, 0u, false, false);
-          uint32_t comp_ty_sz_id = builder->GetUintConstantId(comp_ty_sz);
-          Instruction* curr_offset_inst = builder->AddBinaryOp(
-              GetUintId(), spv::Op::OpIMul, comp_ty_sz_id, curr_idx_32b_id);
-          curr_offset_id = curr_offset_inst->result_id();
-        }
-        // Get element type for next step
-        curr_ty_id = comp_ty_id;
-      } break;
-      case spv::Op::OpTypeStruct: {
-        // Get buffer byte offset for the referenced member
-        Instruction* curr_idx_inst = get_def_use_mgr()->GetDef(curr_idx_id);
-        assert(curr_idx_inst->opcode() == spv::Op::OpConstant &&
-               "unexpected struct index");
-        uint32_t member_idx = curr_idx_inst->GetSingleWordInOperand(0);
-        uint32_t member_offset = 0xdeadbeef;
-        bool found = get_decoration_mgr()->FindDecoration(
-            curr_ty_id, uint32_t(spv::Decoration::Offset),
-            [&member_idx, &member_offset](const Instruction& deco_inst) {
-              if (deco_inst.GetSingleWordInOperand(1u) != member_idx)
-                return false;
-              member_offset = deco_inst.GetSingleWordInOperand(3u);
-              return true;
-            });
-        USE_ASSERT(found && "member offset not found");
-        curr_offset_id = builder->GetUintConstantId(member_offset);
-        // Look for matrix stride for this member if there is one. The matrix
-        // stride is not on the matrix type, but in a OpMemberDecorate on the
-        // enclosing struct type at the member index. If none found, reset
-        // stride to 0.
-        found = get_decoration_mgr()->FindDecoration(
-            curr_ty_id, uint32_t(spv::Decoration::MatrixStride),
-            [&member_idx, &matrix_stride](const Instruction& deco_inst) {
-              if (deco_inst.GetSingleWordInOperand(1u) != member_idx)
-                return false;
-              matrix_stride = deco_inst.GetSingleWordInOperand(3u);
-              return true;
-            });
-        if (!found) matrix_stride = 0;
-        // Look for column major decoration
-        found = get_decoration_mgr()->FindDecoration(
-            curr_ty_id, uint32_t(spv::Decoration::ColMajor),
-            [&member_idx, &col_major](const Instruction& deco_inst) {
-              if (deco_inst.GetSingleWordInOperand(1u) != member_idx)
-                return false;
-              col_major = true;
-              return true;
-            });
-        if (!found) col_major = false;
-        // Get element type for next step
-        curr_ty_id = curr_ty_inst->GetSingleWordInOperand(member_idx);
-      } break;
-      default: { assert(false && "unexpected non-composite type"); } break;
-    }
-    if (sum_id == 0)
-      sum_id = curr_offset_id;
-    else {
-      Instruction* sum_inst =
-          builder->AddIAdd(GetUintId(), sum_id, curr_offset_id);
-      sum_id = sum_inst->result_id();
-    }
-    ++ac_in_idx;
-  }
-  // Add in offset of last byte of referenced object
-  uint32_t bsize = ByteSize(curr_ty_id, matrix_stride, col_major, in_matrix);
-  uint32_t last = bsize - 1;
-  uint32_t last_id = builder->GetUintConstantId(last);
-  Instruction* sum_inst = builder->AddIAdd(GetUintId(), sum_id, last_id);
-  return sum_inst->result_id();
-}
-
-void InstBindlessCheckPass::GenCheckCode(
-    uint32_t check_id, RefAnalysis* ref,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  BasicBlock* back_blk_ptr = &*new_blocks->back();
-  InstructionBuilder builder(
-      context(), back_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  // Gen conditional branch on check_id. Valid branch generates original
-  // reference. Invalid generates debug output and zero result (if needed).
-  uint32_t merge_blk_id = TakeNextId();
-  uint32_t valid_blk_id = TakeNextId();
-  uint32_t invalid_blk_id = TakeNextId();
-  std::unique_ptr<Instruction> merge_label(NewLabel(merge_blk_id));
-  std::unique_ptr<Instruction> valid_label(NewLabel(valid_blk_id));
-  std::unique_ptr<Instruction> invalid_label(NewLabel(invalid_blk_id));
-  (void)builder.AddConditionalBranch(
-      check_id, valid_blk_id, invalid_blk_id, merge_blk_id,
-      uint32_t(spv::SelectionControlMask::MaskNone));
-  // Gen valid bounds branch
-  std::unique_ptr<BasicBlock> new_blk_ptr(
-      new BasicBlock(std::move(valid_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-  uint32_t new_ref_id = CloneOriginalReference(ref, &builder);
-  uint32_t null_id = 0;
-  uint32_t ref_type_id = ref->ref_inst->type_id();
-  (void)builder.AddBranch(merge_blk_id);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Gen invalid block
-  new_blk_ptr.reset(new BasicBlock(std::move(invalid_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-
-  // Generate a ConstantNull, converting to uint64 if the type cannot be a null.
-  if (new_ref_id != 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Type* ref_type = type_mgr->GetType(ref_type_id);
-    if (ref_type->AsPointer() != nullptr) {
-      context()->AddCapability(spv::Capability::Int64);
-      uint32_t null_u64_id = GetNullId(GetUint64Id());
-      Instruction* null_ptr_inst = builder.AddUnaryOp(
-          ref_type_id, spv::Op::OpConvertUToPtr, null_u64_id);
-      null_id = null_ptr_inst->result_id();
-    } else {
-      null_id = GetNullId(ref_type_id);
-    }
-  }
-  // Remember last invalid block id
-  uint32_t last_invalid_blk_id = new_blk_ptr->GetLabelInst()->result_id();
-  // Gen zero for invalid  reference
-  (void)builder.AddBranch(merge_blk_id);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Gen merge block
-  new_blk_ptr.reset(new BasicBlock(std::move(merge_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-  // Gen phi of new reference and zero, if necessary, and replace the
-  // result id of the original reference with that of the Phi. Kill original
-  // reference.
-  if (new_ref_id != 0) {
-    Instruction* phi_inst = builder.AddPhi(
-        ref_type_id, {new_ref_id, valid_blk_id, null_id, last_invalid_blk_id});
-    context()->ReplaceAllUsesWith(ref->ref_inst->result_id(),
-                                  phi_inst->result_id());
-  }
-  new_blocks->push_back(std::move(new_blk_ptr));
-  context()->KillInst(ref->ref_inst);
-}
-
-void InstBindlessCheckPass::GenDescCheckCode(
-    BasicBlock::iterator ref_inst_itr,
-    UptrVectorIterator<BasicBlock> ref_block_itr, uint32_t stage_idx,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  // Look for reference through descriptor. If not, return.
-  RefAnalysis ref;
-  if (!AnalyzeDescriptorReference(&*ref_inst_itr, &ref)) return;
-  std::unique_ptr<BasicBlock> new_blk_ptr;
-  // Move original block's preceding instructions into first new block
-  MovePreludeCode(ref_inst_itr, ref_block_itr, &new_blk_ptr);
-  InstructionBuilder builder(
-      context(), &*new_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Determine if we can only do initialization check
-  uint32_t ref_id = builder.GetUintConstantId(0u);
-  spv::Op op = ref.ref_inst->opcode();
-  if (ref.desc_load_id != 0) {
-    uint32_t num_in_oprnds = ref.ref_inst->NumInOperands();
-    if ((op == spv::Op::OpImageRead && num_in_oprnds == 2) ||
-        (op == spv::Op::OpImageFetch && num_in_oprnds == 2) ||
-        (op == spv::Op::OpImageWrite && num_in_oprnds == 3)) {
-      Instruction* image_inst = get_def_use_mgr()->GetDef(ref.image_id);
-      uint32_t image_ty_id = image_inst->type_id();
-      Instruction* image_ty_inst = get_def_use_mgr()->GetDef(image_ty_id);
-      if (spv::Dim(image_ty_inst->GetSingleWordInOperand(kSpvTypeImageDim)) ==
-          spv::Dim::Buffer) {
-        if ((image_ty_inst->GetSingleWordInOperand(kSpvTypeImageDepth) == 0) &&
-            (image_ty_inst->GetSingleWordInOperand(kSpvTypeImageArrayed) ==
-             0) &&
-            (image_ty_inst->GetSingleWordInOperand(kSpvTypeImageMS) == 0)) {
-          ref_id = GenUintCastCode(ref.ref_inst->GetSingleWordInOperand(1),
-                                   &builder);
-        }
-      }
-    }
-  } else {
-    // For now, only do bounds check for non-aggregate types. Otherwise
-    // just do descriptor initialization check.
-    // TODO(greg-lunarg): Do bounds check for aggregate loads and stores
-    Instruction* ref_ptr_inst = get_def_use_mgr()->GetDef(ref.ptr_id);
-    Instruction* pte_type_inst = GetPointeeTypeInst(ref_ptr_inst);
-    spv::Op pte_type_op = pte_type_inst->opcode();
-    if (pte_type_op != spv::Op::OpTypeArray &&
-        pte_type_op != spv::Op::OpTypeRuntimeArray &&
-        pte_type_op != spv::Op::OpTypeStruct) {
-      ref_id = GenLastByteIdx(&ref, &builder);
-    }
-  }
-  // Read initialization/bounds from debug input buffer. If index id not yet
-  // set, binding is single descriptor, so set index to constant 0.
-  if (ref.desc_idx_id == 0) ref.desc_idx_id = builder.GetUintConstantId(0u);
-  uint32_t check_id =
-      GenDescCheckCall(ref.ref_inst->unique_id(), stage_idx, ref.var_id,
-                       ref.desc_idx_id, ref_id, &builder);
-
-  // Generate runtime initialization/bounds test code with true branch
-  // being full reference and false branch being zero
-  // for the referenced value.
-  GenCheckCode(check_id, &ref, new_blocks);
-
-  // Move original block's remaining code into remainder/merge block and add
-  // to new blocks
-  BasicBlock* back_blk_ptr = &*new_blocks->back();
-  MovePostludeCode(ref_block_itr, back_blk_ptr);
-}
-
-void InstBindlessCheckPass::InitializeInstBindlessCheck() {
-  // Initialize base class
-  InitializeInstrument();
-  for (auto& anno : get_module()->annotations()) {
-    if (anno.opcode() == spv::Op::OpDecorate) {
-      if (spv::Decoration(anno.GetSingleWordInOperand(1u)) ==
-          spv::Decoration::DescriptorSet) {
-        var2desc_set_[anno.GetSingleWordInOperand(0u)] =
-            anno.GetSingleWordInOperand(2u);
-      } else if (spv::Decoration(anno.GetSingleWordInOperand(1u)) ==
-                 spv::Decoration::Binding) {
-        var2binding_[anno.GetSingleWordInOperand(0u)] =
-            anno.GetSingleWordInOperand(2u);
-      }
-    }
-  }
-}
-
-Pass::Status InstBindlessCheckPass::ProcessImpl() {
-  // The memory model and linkage must always be updated for spirv-link to work
-  // correctly.
-  AddStorageBufferExt();
-  if (!get_feature_mgr()->HasExtension(kSPV_KHR_physical_storage_buffer)) {
-    context()->AddExtension("SPV_KHR_physical_storage_buffer");
-  }
-
-  context()->AddCapability(spv::Capability::PhysicalStorageBufferAddresses);
-  Instruction* memory_model = get_module()->GetMemoryModel();
-  memory_model->SetInOperand(
-      0u, {uint32_t(spv::AddressingModel::PhysicalStorageBuffer64)});
-
-  context()->AddCapability(spv::Capability::Linkage);
-
-  InstProcessFunction pfn =
-      [this](BasicBlock::iterator ref_inst_itr,
-             UptrVectorIterator<BasicBlock> ref_block_itr, uint32_t stage_idx,
-             std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-        return GenDescCheckCode(ref_inst_itr, ref_block_itr, stage_idx,
-                                new_blocks);
-      };
-
-  InstProcessEntryPointCallTree(pfn);
-  // This pass always changes the memory model, so that linking will work
-  // properly.
-  return Status::SuccessWithChange;
-}
-
-Pass::Status InstBindlessCheckPass::Process() {
-  InitializeInstBindlessCheck();
-  return ProcessImpl();
-}
-
-}  // namespace opt
-}  // namespace spvtools
diff --git a/source/opt/inst_bindless_check_pass.h b/source/opt/inst_bindless_check_pass.h
deleted file mode 100644
index 243cba76..00000000
--- a/source/opt/inst_bindless_check_pass.h
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright (c) 2018 The Khronos Group Inc.
-// Copyright (c) 2018 Valve Corporation
-// Copyright (c) 2018 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef LIBSPIRV_OPT_INST_BINDLESS_CHECK_PASS_H_
-#define LIBSPIRV_OPT_INST_BINDLESS_CHECK_PASS_H_
-
-#include "instrument_pass.h"
-
-namespace spvtools {
-namespace opt {
-
-// This class/pass is designed to support the bindless (descriptor indexing)
-// GPU-assisted validation layer of
-// https://github.com/KhronosGroup/Vulkan-ValidationLayers. Its internal and
-// external design may change as the layer evolves.
-class InstBindlessCheckPass : public InstrumentPass {
- public:
-  InstBindlessCheckPass(uint32_t shader_id)
-      : InstrumentPass(0, shader_id, true, true) {}
-
-  ~InstBindlessCheckPass() override = default;
-
-  // See optimizer.hpp for pass user documentation.
-  Status Process() override;
-
-  const char* name() const override { return "inst-bindless-check-pass"; }
-
- private:
-  void GenDescCheckCode(BasicBlock::iterator ref_inst_itr,
-                        UptrVectorIterator<BasicBlock> ref_block_itr,
-                        uint32_t stage_idx,
-                        std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  uint32_t GenDescCheckFunctionId();
-
-  uint32_t GenDescCheckCall(uint32_t inst_idx, uint32_t stage_idx,
-                            uint32_t var_id, uint32_t index_id,
-                            uint32_t byte_offset, InstructionBuilder* builder);
-
-  // Analysis data for descriptor reference components, generated by
-  // AnalyzeDescriptorReference. It is necessary and sufficient for further
-  // analysis and regeneration of the reference.
-  typedef struct RefAnalysis {
-    uint32_t desc_load_id{0};
-    uint32_t image_id{0};
-    uint32_t load_id{0};
-    uint32_t ptr_id{0};
-    uint32_t var_id{0};
-    uint32_t set{0};
-    uint32_t binding{0};
-    uint32_t desc_idx_id{0};
-    uint32_t strg_class{0};
-    Instruction* ref_inst{nullptr};
-  } RefAnalysis;
-
-  // Return size of type |ty_id| in bytes. Use |matrix_stride| and |col_major|
-  // for matrix type, or for vector type if vector is |in_matrix|.
-  uint32_t ByteSize(uint32_t ty_id, uint32_t matrix_stride, bool col_major,
-                    bool in_matrix);
-
-  // Return stride of type |ty_id| with decoration |stride_deco|. Return 0
-  // if not found
-  uint32_t FindStride(uint32_t ty_id, uint32_t stride_deco);
-
-  // Generate index of last byte referenced by buffer reference |ref|
-  uint32_t GenLastByteIdx(RefAnalysis* ref, InstructionBuilder* builder);
-
-  // Clone original image computation starting at |image_id| into |builder|.
-  // This may generate more than one instruction if necessary.
-  uint32_t CloneOriginalImage(uint32_t image_id, InstructionBuilder* builder);
-
-  // Clone original original reference encapsulated by |ref| into |builder|.
-  // This may generate more than one instruction if necessary.
-  uint32_t CloneOriginalReference(RefAnalysis* ref,
-                                  InstructionBuilder* builder);
-
-  // If |inst| references through an image, return the id of the image it
-  // references through. Else return 0.
-  uint32_t GetImageId(Instruction* inst);
-
-  // Get pointee type inst of pointer value |ptr_inst|.
-  Instruction* GetPointeeTypeInst(Instruction* ptr_inst);
-
-  // Analyze descriptor reference |ref_inst| and save components into |ref|.
-  // Return true if |ref_inst| is a descriptor reference, false otherwise.
-  bool AnalyzeDescriptorReference(Instruction* ref_inst, RefAnalysis* ref);
-
-  // Generate instrumentation code for generic test result |check_id|, starting
-  // with |builder| of block |new_blk_ptr|, adding new blocks to |new_blocks|.
-  // Generate conditional branch to a valid or invalid branch. Generate valid
-  // block which does original reference |ref|. Generate invalid block which
-  // writes debug error output utilizing |ref|, |error_id|, |length_id| and
-  // |stage_idx|. Generate merge block for valid and invalid branches. Kill
-  // original reference.
-  void GenCheckCode(uint32_t check_id, RefAnalysis* ref,
-                    std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  // Initialize state for instrumenting bindless checking
-  void InitializeInstBindlessCheck();
-
-  // Apply GenDescIdxCheckCode to every instruction in module. Then apply
-  // GenDescInitCheckCode to every instruction in module.
-  Pass::Status ProcessImpl();
-
-  // Mapping from variable to descriptor set
-  std::unordered_map<uint32_t, uint32_t> var2desc_set_;
-
-  // Mapping from variable to binding
-  std::unordered_map<uint32_t, uint32_t> var2binding_;
-
-  uint32_t check_desc_func_id_{0};
-};
-
-}  // namespace opt
-}  // namespace spvtools
-
-#endif  // LIBSPIRV_OPT_INST_BINDLESS_CHECK_PASS_H_
diff --git a/source/opt/inst_buff_addr_check_pass.cpp b/source/opt/inst_buff_addr_check_pass.cpp
deleted file mode 100644
index e6c55087..00000000
--- a/source/opt/inst_buff_addr_check_pass.cpp
+++ /dev/null
@@ -1,331 +0,0 @@
-// Copyright (c) 2019 The Khronos Group Inc.
-// Copyright (c) 2019 Valve Corporation
-// Copyright (c) 2019 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "inst_buff_addr_check_pass.h"
-
-namespace spvtools {
-namespace opt {
-
-uint32_t InstBuffAddrCheckPass::CloneOriginalReference(
-    Instruction* ref_inst, InstructionBuilder* builder) {
-  // Clone original ref with new result id (if load)
-  assert((ref_inst->opcode() == spv::Op::OpLoad ||
-          ref_inst->opcode() == spv::Op::OpStore) &&
-         "unexpected ref");
-  std::unique_ptr<Instruction> new_ref_inst(ref_inst->Clone(context()));
-  uint32_t ref_result_id = ref_inst->result_id();
-  uint32_t new_ref_id = 0;
-  if (ref_result_id != 0) {
-    new_ref_id = TakeNextId();
-    new_ref_inst->SetResultId(new_ref_id);
-  }
-  // Register new reference and add to new block
-  Instruction* added_inst = builder->AddInstruction(std::move(new_ref_inst));
-  uid2offset_[added_inst->unique_id()] = uid2offset_[ref_inst->unique_id()];
-  if (new_ref_id != 0)
-    get_decoration_mgr()->CloneDecorations(ref_result_id, new_ref_id);
-  return new_ref_id;
-}
-
-bool InstBuffAddrCheckPass::IsPhysicalBuffAddrReference(Instruction* ref_inst) {
-  if (ref_inst->opcode() != spv::Op::OpLoad &&
-      ref_inst->opcode() != spv::Op::OpStore)
-    return false;
-  uint32_t ptr_id = ref_inst->GetSingleWordInOperand(0);
-  analysis::DefUseManager* du_mgr = get_def_use_mgr();
-  Instruction* ptr_inst = du_mgr->GetDef(ptr_id);
-  if (ptr_inst->opcode() != spv::Op::OpAccessChain) return false;
-  uint32_t ptr_ty_id = ptr_inst->type_id();
-  Instruction* ptr_ty_inst = du_mgr->GetDef(ptr_ty_id);
-  if (spv::StorageClass(ptr_ty_inst->GetSingleWordInOperand(0)) !=
-      spv::StorageClass::PhysicalStorageBufferEXT)
-    return false;
-  return true;
-}
-
-// TODO(greg-lunarg): Refactor with InstBindlessCheckPass::GenCheckCode() ??
-void InstBuffAddrCheckPass::GenCheckCode(
-    uint32_t check_id, Instruction* ref_inst,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  BasicBlock* back_blk_ptr = &*new_blocks->back();
-  InstructionBuilder builder(
-      context(), back_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  // Gen conditional branch on check_id. Valid branch generates original
-  // reference. Invalid generates debug output and zero result (if needed).
-  uint32_t merge_blk_id = TakeNextId();
-  uint32_t valid_blk_id = TakeNextId();
-  uint32_t invalid_blk_id = TakeNextId();
-  std::unique_ptr<Instruction> merge_label(NewLabel(merge_blk_id));
-  std::unique_ptr<Instruction> valid_label(NewLabel(valid_blk_id));
-  std::unique_ptr<Instruction> invalid_label(NewLabel(invalid_blk_id));
-  (void)builder.AddConditionalBranch(
-      check_id, valid_blk_id, invalid_blk_id, merge_blk_id,
-      uint32_t(spv::SelectionControlMask::MaskNone));
-  // Gen valid branch
-  std::unique_ptr<BasicBlock> new_blk_ptr(
-      new BasicBlock(std::move(valid_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-  uint32_t new_ref_id = CloneOriginalReference(ref_inst, &builder);
-  (void)builder.AddBranch(merge_blk_id);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Gen invalid block
-  new_blk_ptr.reset(new BasicBlock(std::move(invalid_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-  // Gen zero for invalid load. If pointer type, need to convert uint64
-  // zero to pointer; cannot create ConstantNull of pointer type.
-  uint32_t null_id = 0;
-  if (new_ref_id != 0) {
-    uint32_t ref_type_id = ref_inst->type_id();
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Type* ref_type = type_mgr->GetType(ref_type_id);
-    if (ref_type->AsPointer() != nullptr) {
-      uint32_t null_u64_id = GetNullId(GetUint64Id());
-      Instruction* null_ptr_inst = builder.AddUnaryOp(
-          ref_type_id, spv::Op::OpConvertUToPtr, null_u64_id);
-      null_id = null_ptr_inst->result_id();
-    } else {
-      null_id = GetNullId(ref_type_id);
-    }
-  }
-  (void)builder.AddBranch(merge_blk_id);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Gen merge block
-  new_blk_ptr.reset(new BasicBlock(std::move(merge_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-  // Gen phi of new reference and zero, if necessary, and replace the
-  // result id of the original reference with that of the Phi. Kill original
-  // reference.
-  if (new_ref_id != 0) {
-    Instruction* phi_inst =
-        builder.AddPhi(ref_inst->type_id(),
-                       {new_ref_id, valid_blk_id, null_id, invalid_blk_id});
-    context()->ReplaceAllUsesWith(ref_inst->result_id(), phi_inst->result_id());
-  }
-  new_blocks->push_back(std::move(new_blk_ptr));
-  context()->KillInst(ref_inst);
-}
-
-uint32_t InstBuffAddrCheckPass::GetTypeLength(uint32_t type_id) {
-  Instruction* type_inst = get_def_use_mgr()->GetDef(type_id);
-  switch (type_inst->opcode()) {
-    case spv::Op::OpTypeFloat:
-    case spv::Op::OpTypeInt:
-      return type_inst->GetSingleWordInOperand(0) / 8u;
-    case spv::Op::OpTypeVector:
-    case spv::Op::OpTypeMatrix:
-      return type_inst->GetSingleWordInOperand(1) *
-             GetTypeLength(type_inst->GetSingleWordInOperand(0));
-    case spv::Op::OpTypePointer:
-      assert(spv::StorageClass(type_inst->GetSingleWordInOperand(0)) ==
-                 spv::StorageClass::PhysicalStorageBufferEXT &&
-             "unexpected pointer type");
-      return 8u;
-    case spv::Op::OpTypeArray: {
-      uint32_t const_id = type_inst->GetSingleWordInOperand(1);
-      Instruction* const_inst = get_def_use_mgr()->GetDef(const_id);
-      uint32_t cnt = const_inst->GetSingleWordInOperand(0);
-      return cnt * GetTypeLength(type_inst->GetSingleWordInOperand(0));
-    }
-    case spv::Op::OpTypeStruct: {
-      // Figure out the location of the last byte of the last member of the
-      // structure.
-      uint32_t last_offset = 0, last_len = 0;
-
-      get_decoration_mgr()->ForEachDecoration(
-          type_id, uint32_t(spv::Decoration::Offset),
-          [&last_offset](const Instruction& deco_inst) {
-            last_offset = deco_inst.GetSingleWordInOperand(3);
-          });
-      type_inst->ForEachInId([&last_len, this](const uint32_t* iid) {
-        last_len = GetTypeLength(*iid);
-      });
-      return last_offset + last_len;
-    }
-    case spv::Op::OpTypeRuntimeArray:
-    default:
-      assert(false && "unexpected type");
-      return 0;
-  }
-}
-
-void InstBuffAddrCheckPass::AddParam(uint32_t type_id,
-                                     std::vector<uint32_t>* param_vec,
-                                     std::unique_ptr<Function>* input_func) {
-  uint32_t pid = TakeNextId();
-  param_vec->push_back(pid);
-  std::unique_ptr<Instruction> param_inst(new Instruction(
-      get_module()->context(), spv::Op::OpFunctionParameter, type_id, pid, {}));
-  get_def_use_mgr()->AnalyzeInstDefUse(&*param_inst);
-  (*input_func)->AddParameter(std::move(param_inst));
-}
-
-// This is a stub function for use with Import linkage
-// clang-format off
-// GLSL:
-//bool inst_bindless_search_and_test(const uint shader_id, const uint inst_num, const uvec4 stage_info,
-//				     const uint64 ref_ptr, const uint length) {
-//}
-// clang-format on
-uint32_t InstBuffAddrCheckPass::GetSearchAndTestFuncId() {
-  enum {
-    kShaderId = 0,
-    kInstructionIndex = 1,
-    kStageInfo = 2,
-    kRefPtr = 3,
-    kLength = 4,
-    kNumArgs
-  };
-  if (search_test_func_id_ != 0) {
-    return search_test_func_id_;
-  }
-  // Generate function "bool search_and_test(uint64_t ref_ptr, uint32_t len)"
-  // which searches input buffer for buffer which most likely contains the
-  // pointer value |ref_ptr| and verifies that the entire reference of
-  // length |len| bytes is contained in the buffer.
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  const analysis::Integer* uint_type = GetInteger(32, false);
-  const analysis::Vector v4uint(uint_type, 4);
-  const analysis::Type* v4uint_type = type_mgr->GetRegisteredType(&v4uint);
-
-  std::vector<const analysis::Type*> param_types = {
-      uint_type, uint_type, v4uint_type, type_mgr->GetType(GetUint64Id()),
-      uint_type};
-
-  const std::string func_name{"inst_buff_addr_search_and_test"};
-  const uint32_t func_id = TakeNextId();
-  std::unique_ptr<Function> func =
-      StartFunction(func_id, type_mgr->GetBoolType(), param_types);
-  func->SetFunctionEnd(EndFunction());
-  context()->AddFunctionDeclaration(std::move(func));
-  context()->AddDebug2Inst(NewName(func_id, func_name));
-
-  std::vector<Operand> operands{
-      {spv_operand_type_t::SPV_OPERAND_TYPE_ID, {func_id}},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LITERAL_INTEGER,
-       {uint32_t(spv::Decoration::LinkageAttributes)}},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LITERAL_STRING,
-       utils::MakeVector(func_name.c_str())},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LINKAGE_TYPE,
-       {uint32_t(spv::LinkageType::Import)}},
-  };
-  get_decoration_mgr()->AddDecoration(spv::Op::OpDecorate, operands);
-
-  search_test_func_id_ = func_id;
-  return search_test_func_id_;
-}
-
-uint32_t InstBuffAddrCheckPass::GenSearchAndTest(Instruction* ref_inst,
-                                                 InstructionBuilder* builder,
-                                                 uint32_t* ref_uptr_id,
-                                                 uint32_t stage_idx) {
-  // Enable Int64 if necessary
-  // Convert reference pointer to uint64
-  const uint32_t ref_ptr_id = ref_inst->GetSingleWordInOperand(0);
-  Instruction* ref_uptr_inst =
-      builder->AddUnaryOp(GetUint64Id(), spv::Op::OpConvertPtrToU, ref_ptr_id);
-  *ref_uptr_id = ref_uptr_inst->result_id();
-  // Compute reference length in bytes
-  analysis::DefUseManager* du_mgr = get_def_use_mgr();
-  Instruction* ref_ptr_inst = du_mgr->GetDef(ref_ptr_id);
-  const uint32_t ref_ptr_ty_id = ref_ptr_inst->type_id();
-  Instruction* ref_ptr_ty_inst = du_mgr->GetDef(ref_ptr_ty_id);
-  const uint32_t ref_len =
-      GetTypeLength(ref_ptr_ty_inst->GetSingleWordInOperand(1));
-  // Gen call to search and test function
-  const uint32_t func_id = GetSearchAndTestFuncId();
-  const std::vector<uint32_t> args = {
-      builder->GetUintConstantId(shader_id_),
-      builder->GetUintConstantId(ref_inst->unique_id()),
-      GenStageInfo(stage_idx, builder), *ref_uptr_id,
-      builder->GetUintConstantId(ref_len)};
-  return GenReadFunctionCall(GetBoolId(), func_id, args, builder);
-}
-
-void InstBuffAddrCheckPass::GenBuffAddrCheckCode(
-    BasicBlock::iterator ref_inst_itr,
-    UptrVectorIterator<BasicBlock> ref_block_itr, uint32_t stage_idx,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  // Look for reference through indexed descriptor. If found, analyze and
-  // save components. If not, return.
-  Instruction* ref_inst = &*ref_inst_itr;
-  if (!IsPhysicalBuffAddrReference(ref_inst)) return;
-  // Move original block's preceding instructions into first new block
-  std::unique_ptr<BasicBlock> new_blk_ptr;
-  MovePreludeCode(ref_inst_itr, ref_block_itr, &new_blk_ptr);
-  InstructionBuilder builder(
-      context(), &*new_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Generate code to do search and test if all bytes of reference
-  // are within a listed buffer. Return reference pointer converted to uint64.
-  uint32_t ref_uptr_id;
-  uint32_t valid_id =
-      GenSearchAndTest(ref_inst, &builder, &ref_uptr_id, stage_idx);
-  // Generate test of search results with true branch
-  // being full reference and false branch being debug output and zero
-  // for the referenced value.
-  GenCheckCode(valid_id, ref_inst, new_blocks);
-
-  // Move original block's remaining code into remainder/merge block and add
-  // to new blocks
-  BasicBlock* back_blk_ptr = &*new_blocks->back();
-  MovePostludeCode(ref_block_itr, back_blk_ptr);
-}
-
-void InstBuffAddrCheckPass::InitInstBuffAddrCheck() {
-  // Initialize base class
-  InitializeInstrument();
-  // Initialize class
-  search_test_func_id_ = 0;
-}
-
-Pass::Status InstBuffAddrCheckPass::ProcessImpl() {
-  // The memory model and linkage must always be updated for spirv-link to work
-  // correctly.
-  AddStorageBufferExt();
-  if (!get_feature_mgr()->HasExtension(kSPV_KHR_physical_storage_buffer)) {
-    context()->AddExtension("SPV_KHR_physical_storage_buffer");
-  }
-
-  context()->AddCapability(spv::Capability::PhysicalStorageBufferAddresses);
-  Instruction* memory_model = get_module()->GetMemoryModel();
-  memory_model->SetInOperand(
-      0u, {uint32_t(spv::AddressingModel::PhysicalStorageBuffer64)});
-
-  context()->AddCapability(spv::Capability::Int64);
-  context()->AddCapability(spv::Capability::Linkage);
-  // Perform bindless bounds check on each entry point function in module
-  InstProcessFunction pfn =
-      [this](BasicBlock::iterator ref_inst_itr,
-             UptrVectorIterator<BasicBlock> ref_block_itr, uint32_t stage_idx,
-             std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-        return GenBuffAddrCheckCode(ref_inst_itr, ref_block_itr, stage_idx,
-                                    new_blocks);
-      };
-  InstProcessEntryPointCallTree(pfn);
-  // This pass always changes the memory model, so that linking will work
-  // properly.
-  return Status::SuccessWithChange;
-}
-
-Pass::Status InstBuffAddrCheckPass::Process() {
-  InitInstBuffAddrCheck();
-  return ProcessImpl();
-}
-
-}  // namespace opt
-}  // namespace spvtools
diff --git a/source/opt/inst_buff_addr_check_pass.h b/source/opt/inst_buff_addr_check_pass.h
deleted file mode 100644
index f07f98a0..00000000
--- a/source/opt/inst_buff_addr_check_pass.h
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright (c) 2019 The Khronos Group Inc.
-// Copyright (c) 2019 Valve Corporation
-// Copyright (c) 2019 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef LIBSPIRV_OPT_INST_BUFFER_ADDRESS_PASS_H_
-#define LIBSPIRV_OPT_INST_BUFFER_ADDRESS_PASS_H_
-
-#include "instrument_pass.h"
-
-namespace spvtools {
-namespace opt {
-
-// This class/pass is designed to support the GPU-assisted validation layer of
-// the Buffer Device Address (BDA) extension in
-// https://github.com/KhronosGroup/Vulkan-ValidationLayers. The internal and
-// external design of this class may change as the layer evolves.
-class InstBuffAddrCheckPass : public InstrumentPass {
- public:
-  // For test harness only
-  InstBuffAddrCheckPass() : InstrumentPass(0, 23, false, true) {}
-  // For all other interfaces
-  InstBuffAddrCheckPass(uint32_t shader_id)
-      : InstrumentPass(0, shader_id, false, true) {}
-
-  ~InstBuffAddrCheckPass() override = default;
-
-  // See optimizer.hpp for pass user documentation.
-  Status Process() override;
-
-  const char* name() const override { return "inst-buff-addr-check-pass"; }
-
- private:
-  // Return byte length of type |type_id|. Must be int, float, vector, matrix,
-  // struct, array or physical pointer. Uses std430 alignment and sizes.
-  uint32_t GetTypeLength(uint32_t type_id);
-
-  // Add |type_id| param to |input_func| and add id to |param_vec|.
-  void AddParam(uint32_t type_id, std::vector<uint32_t>* param_vec,
-                std::unique_ptr<Function>* input_func);
-
-  // Return id for search and test function. Generate it if not already gen'd.
-  uint32_t GetSearchAndTestFuncId();
-
-  // Generate code into |builder| to do search of the BDA debug input buffer
-  // for the buffer used by |ref_inst| and test that all bytes of reference
-  // are within the buffer. Returns id of boolean value which is true if
-  // search and test is successful, false otherwise.
-  uint32_t GenSearchAndTest(Instruction* ref_inst, InstructionBuilder* builder,
-                            uint32_t* ref_uptr_id, uint32_t stage_idx);
-
-  // This function does checking instrumentation on a single
-  // instruction which references through a physical storage buffer address.
-  // GenBuffAddrCheckCode generates code that checks that all bytes that
-  // are referenced fall within a buffer that was queried via
-  // the Vulkan API call vkGetBufferDeviceAddressEXT().
-  //
-  // The function is designed to be passed to
-  // InstrumentPass::InstProcessEntryPointCallTree(), which applies the
-  // function to each instruction in a module and replaces the instruction
-  // with instrumented code if warranted.
-  //
-  // If |ref_inst_itr| is a physical storage buffer reference, return in
-  // |new_blocks| the result of instrumenting it with validation code within
-  // its block at |ref_block_itr|.  The validation code first executes a check
-  // for the specific condition called for. If the check passes, it executes
-  // the remainder of the reference, otherwise writes a record to the debug
-  // output buffer stream including |function_idx, instruction_idx, stage_idx|
-  // and replaces the reference with the null value of the original type. The
-  // block at |ref_block_itr| can just be replaced with the blocks in
-  // |new_blocks|, which will contain at least two blocks. The last block will
-  // comprise all instructions following |ref_inst_itr|,
-  // preceded by a phi instruction if needed.
-  //
-  // This instrumentation function utilizes GenDebugStreamWrite() to write its
-  // error records. The validation-specific part of the error record will
-  // have the format:
-  //
-  //    Validation Error Code (=kInstErrorBuffAddr)
-  //    Buffer Address (lowest 32 bits)
-  //    Buffer Address (highest 32 bits)
-  //
-  void GenBuffAddrCheckCode(
-      BasicBlock::iterator ref_inst_itr,
-      UptrVectorIterator<BasicBlock> ref_block_itr, uint32_t stage_idx,
-      std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  // Return true if |ref_inst| is a physical buffer address reference, false
-  // otherwise.
-  bool IsPhysicalBuffAddrReference(Instruction* ref_inst);
-
-  // Clone original reference |ref_inst| into |builder| and return id of result
-  uint32_t CloneOriginalReference(Instruction* ref_inst,
-                                  InstructionBuilder* builder);
-
-  // Generate instrumentation code for boolean test result |check_id|,
-  // adding new blocks to |new_blocks|. Generate conditional branch to valid
-  // or invalid reference blocks. Generate valid reference block which does
-  // original reference |ref_inst|. Then generate invalid reference block which
-  // writes debug error output utilizing |ref_inst|, |error_id| and
-  // |stage_idx|. Generate merge block for valid and invalid reference blocks.
-  // Kill original reference.
-  void GenCheckCode(uint32_t check_id, Instruction* ref_inst,
-                    std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  // Initialize state for instrumenting physical buffer address checking
-  void InitInstBuffAddrCheck();
-
-  // Apply GenBuffAddrCheckCode to every instruction in module.
-  Pass::Status ProcessImpl();
-
-  // Id of search and test function, if already gen'd, else zero.
-  uint32_t search_test_func_id_;
-};
-
-}  // namespace opt
-}  // namespace spvtools
-
-#endif  // LIBSPIRV_OPT_INST_BUFFER_ADDRESS_PASS_H_
diff --git a/source/opt/inst_debug_printf_pass.cpp b/source/opt/inst_debug_printf_pass.cpp
deleted file mode 100644
index abd25e93..00000000
--- a/source/opt/inst_debug_printf_pass.cpp
+++ /dev/null
@@ -1,483 +0,0 @@
-// Copyright (c) 2020 The Khronos Group Inc.
-// Copyright (c) 2020 Valve Corporation
-// Copyright (c) 2020 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "inst_debug_printf_pass.h"
-
-#include "source/spirv_constant.h"
-#include "source/util/string_utils.h"
-#include "spirv/unified1/NonSemanticDebugPrintf.h"
-
-namespace spvtools {
-namespace opt {
-
-void InstDebugPrintfPass::GenOutputValues(Instruction* val_inst,
-                                          std::vector<uint32_t>* val_ids,
-                                          InstructionBuilder* builder) {
-  uint32_t val_ty_id = val_inst->type_id();
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  analysis::Type* val_ty = type_mgr->GetType(val_ty_id);
-  switch (val_ty->kind()) {
-    case analysis::Type::kVector: {
-      analysis::Vector* v_ty = val_ty->AsVector();
-      const analysis::Type* c_ty = v_ty->element_type();
-      uint32_t c_ty_id = type_mgr->GetId(c_ty);
-      for (uint32_t c = 0; c < v_ty->element_count(); ++c) {
-        Instruction* c_inst =
-            builder->AddCompositeExtract(c_ty_id, val_inst->result_id(), {c});
-        GenOutputValues(c_inst, val_ids, builder);
-      }
-      return;
-    }
-    case analysis::Type::kBool: {
-      // Select between uint32 zero or one
-      uint32_t zero_id = builder->GetUintConstantId(0);
-      uint32_t one_id = builder->GetUintConstantId(1);
-      Instruction* sel_inst = builder->AddSelect(
-          GetUintId(), val_inst->result_id(), one_id, zero_id);
-      val_ids->push_back(sel_inst->result_id());
-      return;
-    }
-    case analysis::Type::kFloat: {
-      analysis::Float* f_ty = val_ty->AsFloat();
-      switch (f_ty->width()) {
-        case 16: {
-          // Convert float16 to float32 and recurse
-          Instruction* f32_inst = builder->AddUnaryOp(
-              GetFloatId(), spv::Op::OpFConvert, val_inst->result_id());
-          GenOutputValues(f32_inst, val_ids, builder);
-          return;
-        }
-        case 64: {
-          // Bitcast float64 to uint64 and recurse
-          Instruction* ui64_inst = builder->AddUnaryOp(
-              GetUint64Id(), spv::Op::OpBitcast, val_inst->result_id());
-          GenOutputValues(ui64_inst, val_ids, builder);
-          return;
-        }
-        case 32: {
-          // Bitcase float32 to uint32
-          Instruction* bc_inst = builder->AddUnaryOp(
-              GetUintId(), spv::Op::OpBitcast, val_inst->result_id());
-          val_ids->push_back(bc_inst->result_id());
-          return;
-        }
-        default:
-          assert(false && "unsupported float width");
-          return;
-      }
-    }
-    case analysis::Type::kInteger: {
-      analysis::Integer* i_ty = val_ty->AsInteger();
-      switch (i_ty->width()) {
-        case 64: {
-          Instruction* ui64_inst = val_inst;
-          if (i_ty->IsSigned()) {
-            // Bitcast sint64 to uint64
-            ui64_inst = builder->AddUnaryOp(GetUint64Id(), spv::Op::OpBitcast,
-                                            val_inst->result_id());
-          }
-          // Break uint64 into 2x uint32
-          Instruction* lo_ui64_inst = builder->AddUnaryOp(
-              GetUintId(), spv::Op::OpUConvert, ui64_inst->result_id());
-          Instruction* rshift_ui64_inst = builder->AddBinaryOp(
-              GetUint64Id(), spv::Op::OpShiftRightLogical,
-              ui64_inst->result_id(), builder->GetUintConstantId(32));
-          Instruction* hi_ui64_inst = builder->AddUnaryOp(
-              GetUintId(), spv::Op::OpUConvert, rshift_ui64_inst->result_id());
-          val_ids->push_back(lo_ui64_inst->result_id());
-          val_ids->push_back(hi_ui64_inst->result_id());
-          return;
-        }
-        case 8: {
-          Instruction* ui8_inst = val_inst;
-          if (i_ty->IsSigned()) {
-            // Bitcast sint8 to uint8
-            ui8_inst = builder->AddUnaryOp(GetUint8Id(), spv::Op::OpBitcast,
-                                           val_inst->result_id());
-          }
-          // Convert uint8 to uint32
-          Instruction* ui32_inst = builder->AddUnaryOp(
-              GetUintId(), spv::Op::OpUConvert, ui8_inst->result_id());
-          val_ids->push_back(ui32_inst->result_id());
-          return;
-        }
-        case 32: {
-          Instruction* ui32_inst = val_inst;
-          if (i_ty->IsSigned()) {
-            // Bitcast sint32 to uint32
-            ui32_inst = builder->AddUnaryOp(GetUintId(), spv::Op::OpBitcast,
-                                            val_inst->result_id());
-          }
-          // uint32 needs no further processing
-          val_ids->push_back(ui32_inst->result_id());
-          return;
-        }
-        default:
-          // TODO(greg-lunarg): Support non-32-bit int
-          assert(false && "unsupported int width");
-          return;
-      }
-    }
-    default:
-      assert(false && "unsupported type");
-      return;
-  }
-}
-
-void InstDebugPrintfPass::GenOutputCode(
-    Instruction* printf_inst,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  BasicBlock* back_blk_ptr = &*new_blocks->back();
-  InstructionBuilder builder(
-      context(), back_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  // Gen debug printf record validation-specific values. The format string
-  // will have its id written. Vectors will need to be broken down into
-  // component values. float16 will need to be converted to float32. Pointer
-  // and uint64 will need to be converted to two uint32 values. float32 will
-  // need to be bitcast to uint32. int32 will need to be bitcast to uint32.
-  std::vector<uint32_t> val_ids;
-  bool is_first_operand = false;
-  printf_inst->ForEachInId(
-      [&is_first_operand, &val_ids, &builder, this](const uint32_t* iid) {
-        // skip set operand
-        if (!is_first_operand) {
-          is_first_operand = true;
-          return;
-        }
-        Instruction* opnd_inst = get_def_use_mgr()->GetDef(*iid);
-        if (opnd_inst->opcode() == spv::Op::OpString) {
-          uint32_t string_id_id = builder.GetUintConstantId(*iid);
-          val_ids.push_back(string_id_id);
-        } else {
-          GenOutputValues(opnd_inst, &val_ids, &builder);
-        }
-      });
-  GenDebugStreamWrite(
-      builder.GetUintConstantId(shader_id_),
-      builder.GetUintConstantId(uid2offset_[printf_inst->unique_id()]), val_ids,
-      &builder);
-  context()->KillInst(printf_inst);
-}
-
-void InstDebugPrintfPass::GenDebugPrintfCode(
-    BasicBlock::iterator ref_inst_itr,
-    UptrVectorIterator<BasicBlock> ref_block_itr,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  // If not DebugPrintf OpExtInst, return.
-  Instruction* printf_inst = &*ref_inst_itr;
-  if (printf_inst->opcode() != spv::Op::OpExtInst) return;
-  if (printf_inst->GetSingleWordInOperand(0) != ext_inst_printf_id_) return;
-  if (printf_inst->GetSingleWordInOperand(1) !=
-      NonSemanticDebugPrintfDebugPrintf)
-    return;
-  // Initialize DefUse manager before dismantling module
-  (void)get_def_use_mgr();
-  // Move original block's preceding instructions into first new block
-  std::unique_ptr<BasicBlock> new_blk_ptr;
-  MovePreludeCode(ref_inst_itr, ref_block_itr, &new_blk_ptr);
-  new_blocks->push_back(std::move(new_blk_ptr));
-  // Generate instructions to output printf args to printf buffer
-  GenOutputCode(printf_inst, new_blocks);
-  // Caller expects at least two blocks with last block containing remaining
-  // code, so end block after instrumentation, create remainder block, and
-  // branch to it
-  uint32_t rem_blk_id = TakeNextId();
-  std::unique_ptr<Instruction> rem_label(NewLabel(rem_blk_id));
-  BasicBlock* back_blk_ptr = &*new_blocks->back();
-  InstructionBuilder builder(
-      context(), back_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  (void)builder.AddBranch(rem_blk_id);
-  // Gen remainder block
-  new_blk_ptr.reset(new BasicBlock(std::move(rem_label)));
-  builder.SetInsertPoint(&*new_blk_ptr);
-  // Move original block's remaining code into remainder block and add
-  // to new blocks
-  MovePostludeCode(ref_block_itr, &*new_blk_ptr);
-  new_blocks->push_back(std::move(new_blk_ptr));
-}
-
-// Return id for output buffer
-uint32_t InstDebugPrintfPass::GetOutputBufferId() {
-  if (output_buffer_id_ == 0) {
-    // If not created yet, create one
-    analysis::DecorationManager* deco_mgr = get_decoration_mgr();
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::RuntimeArray* reg_uint_rarr_ty = GetUintRuntimeArrayType(32);
-    analysis::Integer* reg_uint_ty = GetInteger(32, false);
-    analysis::Type* reg_buf_ty =
-        GetStruct({reg_uint_ty, reg_uint_ty, reg_uint_rarr_ty});
-    uint32_t obufTyId = type_mgr->GetTypeInstruction(reg_buf_ty);
-    // By the Vulkan spec, a pre-existing struct containing a RuntimeArray
-    // must be a block, and will therefore be decorated with Block. Therefore
-    // the undecorated type returned here will not be pre-existing and can
-    // safely be decorated. Since this type is now decorated, it is out of
-    // sync with the TypeManager and therefore the TypeManager must be
-    // invalidated after this pass.
-    assert(context()->get_def_use_mgr()->NumUses(obufTyId) == 0 &&
-           "used struct type returned");
-    deco_mgr->AddDecoration(obufTyId, uint32_t(spv::Decoration::Block));
-    deco_mgr->AddMemberDecoration(obufTyId, kDebugOutputFlagsOffset,
-                                  uint32_t(spv::Decoration::Offset), 0);
-    deco_mgr->AddMemberDecoration(obufTyId, kDebugOutputSizeOffset,
-                                  uint32_t(spv::Decoration::Offset), 4);
-    deco_mgr->AddMemberDecoration(obufTyId, kDebugOutputDataOffset,
-                                  uint32_t(spv::Decoration::Offset), 8);
-    uint32_t obufTyPtrId_ =
-        type_mgr->FindPointerToType(obufTyId, spv::StorageClass::StorageBuffer);
-    output_buffer_id_ = TakeNextId();
-    std::unique_ptr<Instruction> newVarOp(new Instruction(
-        context(), spv::Op::OpVariable, obufTyPtrId_, output_buffer_id_,
-        {{spv_operand_type_t::SPV_OPERAND_TYPE_LITERAL_INTEGER,
-          {uint32_t(spv::StorageClass::StorageBuffer)}}}));
-    context()->AddGlobalValue(std::move(newVarOp));
-    context()->AddDebug2Inst(NewGlobalName(obufTyId, "OutputBuffer"));
-    context()->AddDebug2Inst(NewMemberName(obufTyId, 0, "flags"));
-    context()->AddDebug2Inst(NewMemberName(obufTyId, 1, "written_count"));
-    context()->AddDebug2Inst(NewMemberName(obufTyId, 2, "data"));
-    context()->AddDebug2Inst(NewGlobalName(output_buffer_id_, "output_buffer"));
-    deco_mgr->AddDecorationVal(
-        output_buffer_id_, uint32_t(spv::Decoration::DescriptorSet), desc_set_);
-    deco_mgr->AddDecorationVal(output_buffer_id_,
-                               uint32_t(spv::Decoration::Binding),
-                               GetOutputBufferBinding());
-    AddStorageBufferExt();
-    if (get_module()->version() >= SPV_SPIRV_VERSION_WORD(1, 4)) {
-      // Add the new buffer to all entry points.
-      for (auto& entry : get_module()->entry_points()) {
-        entry.AddOperand({SPV_OPERAND_TYPE_ID, {output_buffer_id_}});
-        context()->AnalyzeUses(&entry);
-      }
-    }
-  }
-  return output_buffer_id_;
-}
-
-uint32_t InstDebugPrintfPass::GetOutputBufferPtrId() {
-  if (output_buffer_ptr_id_ == 0) {
-    output_buffer_ptr_id_ = context()->get_type_mgr()->FindPointerToType(
-        GetUintId(), spv::StorageClass::StorageBuffer);
-  }
-  return output_buffer_ptr_id_;
-}
-
-uint32_t InstDebugPrintfPass::GetOutputBufferBinding() {
-  return kDebugOutputPrintfStream;
-}
-
-void InstDebugPrintfPass::GenDebugOutputFieldCode(uint32_t base_offset_id,
-                                                  uint32_t field_offset,
-                                                  uint32_t field_value_id,
-                                                  InstructionBuilder* builder) {
-  // Cast value to 32-bit unsigned if necessary
-  uint32_t val_id = GenUintCastCode(field_value_id, builder);
-  // Store value
-  Instruction* data_idx_inst = builder->AddIAdd(
-      GetUintId(), base_offset_id, builder->GetUintConstantId(field_offset));
-  uint32_t buf_id = GetOutputBufferId();
-  uint32_t buf_uint_ptr_id = GetOutputBufferPtrId();
-  Instruction* achain_inst = builder->AddAccessChain(
-      buf_uint_ptr_id, buf_id,
-      {builder->GetUintConstantId(kDebugOutputDataOffset),
-       data_idx_inst->result_id()});
-  (void)builder->AddStore(achain_inst->result_id(), val_id);
-}
-
-uint32_t InstDebugPrintfPass::GetStreamWriteFunctionId(uint32_t param_cnt) {
-  enum {
-    kShaderId = 0,
-    kInstructionIndex = 1,
-    kFirstParam = 2,
-  };
-  // Total param count is common params plus validation-specific
-  // params
-  if (param2output_func_id_[param_cnt] == 0) {
-    // Create function
-    param2output_func_id_[param_cnt] = TakeNextId();
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-
-    const analysis::Type* uint_type = GetInteger(32, false);
-
-    std::vector<const analysis::Type*> param_types(kFirstParam + param_cnt,
-                                                   uint_type);
-    std::unique_ptr<Function> output_func = StartFunction(
-        param2output_func_id_[param_cnt], type_mgr->GetVoidType(), param_types);
-
-    std::vector<uint32_t> param_ids = AddParameters(*output_func, param_types);
-
-    // Create first block
-    auto new_blk_ptr = MakeUnique<BasicBlock>(NewLabel(TakeNextId()));
-
-    InstructionBuilder builder(
-        context(), &*new_blk_ptr,
-        IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-    // Gen test if debug output buffer size will not be exceeded.
-    const uint32_t first_param_offset = kInstCommonOutInstructionIdx + 1;
-    const uint32_t obuf_record_sz = first_param_offset + param_cnt;
-    const uint32_t buf_id = GetOutputBufferId();
-    const uint32_t buf_uint_ptr_id = GetOutputBufferPtrId();
-    Instruction* obuf_curr_sz_ac_inst = builder.AddAccessChain(
-        buf_uint_ptr_id, buf_id,
-        {builder.GetUintConstantId(kDebugOutputSizeOffset)});
-    // Fetch the current debug buffer written size atomically, adding the
-    // size of the record to be written.
-    uint32_t obuf_record_sz_id = builder.GetUintConstantId(obuf_record_sz);
-    uint32_t mask_none_id =
-        builder.GetUintConstantId(uint32_t(spv::MemoryAccessMask::MaskNone));
-    uint32_t scope_invok_id =
-        builder.GetUintConstantId(uint32_t(spv::Scope::Invocation));
-    Instruction* obuf_curr_sz_inst = builder.AddQuadOp(
-        GetUintId(), spv::Op::OpAtomicIAdd, obuf_curr_sz_ac_inst->result_id(),
-        scope_invok_id, mask_none_id, obuf_record_sz_id);
-    uint32_t obuf_curr_sz_id = obuf_curr_sz_inst->result_id();
-    // Compute new written size
-    Instruction* obuf_new_sz_inst =
-        builder.AddIAdd(GetUintId(), obuf_curr_sz_id,
-                        builder.GetUintConstantId(obuf_record_sz));
-    // Fetch the data bound
-    Instruction* obuf_bnd_inst =
-        builder.AddIdLiteralOp(GetUintId(), spv::Op::OpArrayLength,
-                               GetOutputBufferId(), kDebugOutputDataOffset);
-    // Test that new written size is less than or equal to debug output
-    // data bound
-    Instruction* obuf_safe_inst = builder.AddBinaryOp(
-        GetBoolId(), spv::Op::OpULessThanEqual, obuf_new_sz_inst->result_id(),
-        obuf_bnd_inst->result_id());
-    uint32_t merge_blk_id = TakeNextId();
-    uint32_t write_blk_id = TakeNextId();
-    std::unique_ptr<Instruction> merge_label(NewLabel(merge_blk_id));
-    std::unique_ptr<Instruction> write_label(NewLabel(write_blk_id));
-    (void)builder.AddConditionalBranch(
-        obuf_safe_inst->result_id(), write_blk_id, merge_blk_id, merge_blk_id,
-        uint32_t(spv::SelectionControlMask::MaskNone));
-    // Close safety test block and gen write block
-    output_func->AddBasicBlock(std::move(new_blk_ptr));
-    new_blk_ptr = MakeUnique<BasicBlock>(std::move(write_label));
-    builder.SetInsertPoint(&*new_blk_ptr);
-    // Generate common and stage-specific debug record members
-    GenDebugOutputFieldCode(obuf_curr_sz_id, kInstCommonOutSize,
-                            builder.GetUintConstantId(obuf_record_sz),
-                            &builder);
-    // Store Shader Id
-    GenDebugOutputFieldCode(obuf_curr_sz_id, kInstCommonOutShaderId,
-                            param_ids[kShaderId], &builder);
-    // Store Instruction Idx
-    GenDebugOutputFieldCode(obuf_curr_sz_id, kInstCommonOutInstructionIdx,
-                            param_ids[kInstructionIndex], &builder);
-    // Gen writes of validation specific data
-    for (uint32_t i = 0; i < param_cnt; ++i) {
-      GenDebugOutputFieldCode(obuf_curr_sz_id, first_param_offset + i,
-                              param_ids[kFirstParam + i], &builder);
-    }
-    // Close write block and gen merge block
-    (void)builder.AddBranch(merge_blk_id);
-    output_func->AddBasicBlock(std::move(new_blk_ptr));
-    new_blk_ptr = MakeUnique<BasicBlock>(std::move(merge_label));
-    builder.SetInsertPoint(&*new_blk_ptr);
-    // Close merge block and function and add function to module
-    (void)builder.AddNullaryOp(0, spv::Op::OpReturn);
-
-    output_func->AddBasicBlock(std::move(new_blk_ptr));
-    output_func->SetFunctionEnd(EndFunction());
-    context()->AddFunction(std::move(output_func));
-
-    std::string name("stream_write_");
-    name += std::to_string(param_cnt);
-
-    context()->AddDebug2Inst(
-        NewGlobalName(param2output_func_id_[param_cnt], name));
-  }
-  return param2output_func_id_[param_cnt];
-}
-
-void InstDebugPrintfPass::GenDebugStreamWrite(
-    uint32_t shader_id, uint32_t instruction_idx_id,
-    const std::vector<uint32_t>& validation_ids, InstructionBuilder* builder) {
-  // Call debug output function. Pass func_idx, instruction_idx and
-  // validation ids as args.
-  uint32_t val_id_cnt = static_cast<uint32_t>(validation_ids.size());
-  std::vector<uint32_t> args = {shader_id, instruction_idx_id};
-  (void)args.insert(args.end(), validation_ids.begin(), validation_ids.end());
-  (void)builder->AddFunctionCall(GetVoidId(),
-                                 GetStreamWriteFunctionId(val_id_cnt), args);
-}
-
-std::unique_ptr<Instruction> InstDebugPrintfPass::NewGlobalName(
-    uint32_t id, const std::string& name_str) {
-  std::string prefixed_name{"inst_printf_"};
-  prefixed_name += name_str;
-  return NewName(id, prefixed_name);
-}
-
-std::unique_ptr<Instruction> InstDebugPrintfPass::NewMemberName(
-    uint32_t id, uint32_t member_index, const std::string& name_str) {
-  return MakeUnique<Instruction>(
-      context(), spv::Op::OpMemberName, 0, 0,
-      std::initializer_list<Operand>{
-          {SPV_OPERAND_TYPE_ID, {id}},
-          {SPV_OPERAND_TYPE_LITERAL_INTEGER, {member_index}},
-          {SPV_OPERAND_TYPE_LITERAL_STRING, utils::MakeVector(name_str)}});
-}
-
-void InstDebugPrintfPass::InitializeInstDebugPrintf() {
-  // Initialize base class
-  InitializeInstrument();
-  output_buffer_id_ = 0;
-  output_buffer_ptr_id_ = 0;
-}
-
-Pass::Status InstDebugPrintfPass::ProcessImpl() {
-  // Perform printf instrumentation on each entry point function in module
-  InstProcessFunction pfn =
-      [this](BasicBlock::iterator ref_inst_itr,
-             UptrVectorIterator<BasicBlock> ref_block_itr,
-             [[maybe_unused]] uint32_t stage_idx,
-             std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-        return GenDebugPrintfCode(ref_inst_itr, ref_block_itr, new_blocks);
-      };
-  (void)InstProcessEntryPointCallTree(pfn);
-  // Remove DebugPrintf OpExtInstImport instruction
-  Instruction* ext_inst_import_inst =
-      get_def_use_mgr()->GetDef(ext_inst_printf_id_);
-  context()->KillInst(ext_inst_import_inst);
-  // If no remaining non-semantic instruction sets, remove non-semantic debug
-  // info extension from module and feature manager
-  bool non_sem_set_seen = false;
-  for (auto c_itr = context()->module()->ext_inst_import_begin();
-       c_itr != context()->module()->ext_inst_import_end(); ++c_itr) {
-    const std::string set_name = c_itr->GetInOperand(0).AsString();
-    if (spvtools::utils::starts_with(set_name, "NonSemantic.")) {
-      non_sem_set_seen = true;
-      break;
-    }
-  }
-  if (!non_sem_set_seen) {
-    context()->RemoveExtension(kSPV_KHR_non_semantic_info);
-  }
-  return Status::SuccessWithChange;
-}
-
-Pass::Status InstDebugPrintfPass::Process() {
-  ext_inst_printf_id_ =
-      get_module()->GetExtInstImportId("NonSemantic.DebugPrintf");
-  if (ext_inst_printf_id_ == 0) return Status::SuccessWithoutChange;
-  InitializeInstDebugPrintf();
-  return ProcessImpl();
-}
-
-}  // namespace opt
-}  // namespace spvtools
diff --git a/source/opt/inst_debug_printf_pass.h b/source/opt/inst_debug_printf_pass.h
deleted file mode 100644
index 5688d384..00000000
--- a/source/opt/inst_debug_printf_pass.h
+++ /dev/null
@@ -1,198 +0,0 @@
-// Copyright (c) 2020 The Khronos Group Inc.
-// Copyright (c) 2020 Valve Corporation
-// Copyright (c) 2020 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef LIBSPIRV_OPT_INST_DEBUG_PRINTF_PASS_H_
-#define LIBSPIRV_OPT_INST_DEBUG_PRINTF_PASS_H_
-
-#include "instrument_pass.h"
-
-namespace spvtools {
-namespace opt {
-
-// This class/pass is designed to support the debug printf GPU-assisted layer
-// of https://github.com/KhronosGroup/Vulkan-ValidationLayers. Its internal and
-// external design may change as the layer evolves.
-class InstDebugPrintfPass : public InstrumentPass {
- public:
-  // For test harness only
-  InstDebugPrintfPass() : InstrumentPass(7, 23, false, false) {}
-  // For all other interfaces
-  InstDebugPrintfPass(uint32_t desc_set, uint32_t shader_id)
-      : InstrumentPass(desc_set, shader_id, false, false) {}
-
-  ~InstDebugPrintfPass() override = default;
-
-  // See optimizer.hpp for pass user documentation.
-  Status Process() override;
-
-  const char* name() const override { return "inst-printf-pass"; }
-
- private:
-  // Gen code into |builder| to write |field_value_id| into debug output
-  // buffer at |base_offset_id| + |field_offset|.
-  void GenDebugOutputFieldCode(uint32_t base_offset_id, uint32_t field_offset,
-                               uint32_t field_value_id,
-                               InstructionBuilder* builder);
-
-  // Generate instructions in |builder| which will atomically fetch and
-  // increment the size of the debug output buffer stream of the current
-  // validation and write a record to the end of the stream, if enough space
-  // in the buffer remains. The record will contain the index of the function
-  // and instruction within that function |func_idx, instruction_idx| which
-  // generated the record. Finally, the record will contain validation-specific
-  // data contained in |validation_ids| which will identify the validation
-  // error as well as the values involved in the error.
-  //
-  // The output buffer binding written to by the code generated by the function
-  // is determined by the validation id specified when each specific
-  // instrumentation pass is created.
-  //
-  // The output buffer is a sequence of 32-bit values with the following
-  // format (where all elements are unsigned 32-bit unless otherwise noted):
-  //
-  //     Size
-  //     Record0
-  //     Record1
-  //     Record2
-  //     ...
-  //
-  // Size is the number of 32-bit values that have been written or
-  // attempted to be written to the output buffer, excluding the Size. It is
-  // initialized to 0. If the size of attempts to write the buffer exceeds
-  // the actual size of the buffer, it is possible that this field can exceed
-  // the actual size of the buffer.
-  //
-  // Each Record* is a variable-length sequence of 32-bit values with the
-  // following format defined using static const offsets in the .cpp file:
-  //
-  //     Record Size
-  //     Shader ID
-  //     Instruction Index
-  //     ...
-  //     Validation Error Code
-  //     Validation-specific Word 0
-  //     Validation-specific Word 1
-  //     Validation-specific Word 2
-  //     ...
-  //
-  // Each record consists of two subsections: members common across all
-  // validation and members specific to a
-  // validation.
-  //
-  // The Record Size is the number of 32-bit words in the record, including
-  // the Record Size word.
-  //
-  // Shader ID is a value that identifies which shader has generated the
-  // validation error. It is passed when the instrumentation pass is created.
-  //
-  // The Instruction Index is the position of the instruction within the
-  // SPIR-V file which is in error.
-  //
-  // The Validation Error Code specifies the exact error which has occurred.
-  // These are enumerated with the kInstError* static consts. This allows
-  // multiple validation layers to use the same, single output buffer.
-  //
-  // The Validation-specific Words are a validation-specific number of 32-bit
-  // words which give further information on the validation error that
-  // occurred. These are documented further in each file containing the
-  // validation-specific class which derives from this base class.
-  //
-  // Because the code that is generated checks against the size of the buffer
-  // before writing, the size of the debug out buffer can be used by the
-  // validation layer to control the number of error records that are written.
-  void GenDebugStreamWrite(uint32_t shader_id, uint32_t instruction_idx_id,
-                           const std::vector<uint32_t>& validation_ids,
-                           InstructionBuilder* builder);
-
-  // Return id for output function. Define if it doesn't exist with
-  // |val_spec_param_cnt| validation-specific uint32 parameters.
-  uint32_t GetStreamWriteFunctionId(uint32_t val_spec_param_cnt);
-
-  // Generate instructions for OpDebugPrintf.
-  //
-  // If |ref_inst_itr| is an OpDebugPrintf, return in |new_blocks| the result
-  // of replacing it with buffer write instructions within its block at
-  // |ref_block_itr|.  The instructions write a record to the printf
-  // output buffer stream including |function_idx, instruction_idx|
-  // and removes the OpDebugPrintf. The block at |ref_block_itr| can just be
-  // replaced with the block in |new_blocks|. Besides the buffer writes, this
-  // block will comprise all instructions preceding and following
-  // |ref_inst_itr|.
-  //
-  // This function is designed to be passed to
-  // InstrumentPass::InstProcessEntryPointCallTree(), which applies the
-  // function to each instruction in a module and replaces the instruction
-  // if warranted.
-  //
-  // This instrumentation function utilizes GenDebugStreamWrite() to write its
-  // error records. The validation-specific part of the error record will
-  // consist of a uint32 which is the id of the format string plus a sequence
-  // of uint32s representing the values of the remaining operands of the
-  // DebugPrintf.
-  void GenDebugPrintfCode(BasicBlock::iterator ref_inst_itr,
-                          UptrVectorIterator<BasicBlock> ref_block_itr,
-                          std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  // Generate a sequence of uint32 instructions in |builder| (if necessary)
-  // representing the value of |val_inst|, which must be a buffer pointer, a
-  // uint64, or a scalar or vector of type uint32, float32 or float16. Append
-  // the ids of all values to the end of |val_ids|.
-  void GenOutputValues(Instruction* val_inst, std::vector<uint32_t>* val_ids,
-                       InstructionBuilder* builder);
-
-  // Generate instructions to write a record containing the operands of
-  // |printf_inst| arguments to printf buffer, adding new code to the end of
-  // the last block in |new_blocks|. Kill OpDebugPrintf instruction.
-  void GenOutputCode(Instruction* printf_inst,
-                     std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  // Set the name for a function or global variable, names will be
-  // prefixed to identify which instrumentation pass generated them.
-  std::unique_ptr<Instruction> NewGlobalName(uint32_t id,
-                                             const std::string& name_str);
-
-  // Set the name for a structure member
-  std::unique_ptr<Instruction> NewMemberName(uint32_t id, uint32_t member_index,
-                                             const std::string& name_str);
-
-  // Return id for debug output buffer
-  uint32_t GetOutputBufferId();
-
-  // Return id for buffer uint type
-  uint32_t GetOutputBufferPtrId();
-
-  // Return binding for output buffer for current validation.
-  uint32_t GetOutputBufferBinding();
-
-  // Initialize state for instrumenting bindless checking
-  void InitializeInstDebugPrintf();
-
-  // Apply GenDebugPrintfCode to every instruction in module.
-  Pass::Status ProcessImpl();
-
-  uint32_t ext_inst_printf_id_{0};
-
-  // id for output buffer variable
-  uint32_t output_buffer_id_{0};
-
-  // ptr type id for output buffer element
-  uint32_t output_buffer_ptr_id_{0};
-};
-
-}  // namespace opt
-}  // namespace spvtools
-
-#endif  // LIBSPIRV_OPT_INST_DEBUG_PRINTF_PASS_H_
diff --git a/source/opt/instrument_pass.cpp b/source/opt/instrument_pass.cpp
deleted file mode 100644
index b6845a59..00000000
--- a/source/opt/instrument_pass.cpp
+++ /dev/null
@@ -1,803 +0,0 @@
-// Copyright (c) 2018 The Khronos Group Inc.
-// Copyright (c) 2018 Valve Corporation
-// Copyright (c) 2018 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "instrument_pass.h"
-
-#include "source/cfa.h"
-#include "source/spirv_constant.h"
-
-namespace spvtools {
-namespace opt {
-namespace {
-// Indices of operands in SPIR-V instructions
-constexpr int kEntryPointFunctionIdInIdx = 1;
-}  // namespace
-
-void InstrumentPass::MovePreludeCode(
-    BasicBlock::iterator ref_inst_itr,
-    UptrVectorIterator<BasicBlock> ref_block_itr,
-    std::unique_ptr<BasicBlock>* new_blk_ptr) {
-  same_block_pre_.clear();
-  same_block_post_.clear();
-  // Initialize new block. Reuse label from original block.
-  new_blk_ptr->reset(new BasicBlock(std::move(ref_block_itr->GetLabel())));
-  // Move contents of original ref block up to ref instruction.
-  for (auto cii = ref_block_itr->begin(); cii != ref_inst_itr;
-       cii = ref_block_itr->begin()) {
-    Instruction* inst = &*cii;
-    inst->RemoveFromList();
-    std::unique_ptr<Instruction> mv_ptr(inst);
-    // Remember same-block ops for possible regeneration.
-    if (IsSameBlockOp(&*mv_ptr)) {
-      auto* sb_inst_ptr = mv_ptr.get();
-      same_block_pre_[mv_ptr->result_id()] = sb_inst_ptr;
-    }
-    (*new_blk_ptr)->AddInstruction(std::move(mv_ptr));
-  }
-}
-
-void InstrumentPass::MovePostludeCode(
-    UptrVectorIterator<BasicBlock> ref_block_itr, BasicBlock* new_blk_ptr) {
-  // Move contents of original ref block.
-  for (auto cii = ref_block_itr->begin(); cii != ref_block_itr->end();
-       cii = ref_block_itr->begin()) {
-    Instruction* inst = &*cii;
-    inst->RemoveFromList();
-    std::unique_ptr<Instruction> mv_inst(inst);
-    // Regenerate any same-block instruction that has not been seen in the
-    // current block.
-    if (same_block_pre_.size() > 0) {
-      CloneSameBlockOps(&mv_inst, &same_block_post_, &same_block_pre_,
-                        new_blk_ptr);
-      // Remember same-block ops in this block.
-      if (IsSameBlockOp(&*mv_inst)) {
-        const uint32_t rid = mv_inst->result_id();
-        same_block_post_[rid] = rid;
-      }
-    }
-    new_blk_ptr->AddInstruction(std::move(mv_inst));
-  }
-}
-
-std::unique_ptr<Instruction> InstrumentPass::NewLabel(uint32_t label_id) {
-  auto new_label =
-      MakeUnique<Instruction>(context(), spv::Op::OpLabel, 0, label_id,
-                              std::initializer_list<Operand>{});
-  get_def_use_mgr()->AnalyzeInstDefUse(&*new_label);
-  return new_label;
-}
-
-std::unique_ptr<Function> InstrumentPass::StartFunction(
-    uint32_t func_id, const analysis::Type* return_type,
-    const std::vector<const analysis::Type*>& param_types) {
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  analysis::Function* func_type = GetFunction(return_type, param_types);
-
-  const std::vector<Operand> operands{
-      {spv_operand_type_t::SPV_OPERAND_TYPE_LITERAL_INTEGER,
-       {uint32_t(spv::FunctionControlMask::MaskNone)}},
-      {spv_operand_type_t::SPV_OPERAND_TYPE_ID, {type_mgr->GetId(func_type)}},
-  };
-  auto func_inst =
-      MakeUnique<Instruction>(context(), spv::Op::OpFunction,
-                              type_mgr->GetId(return_type), func_id, operands);
-  get_def_use_mgr()->AnalyzeInstDefUse(&*func_inst);
-  return MakeUnique<Function>(std::move(func_inst));
-}
-
-std::unique_ptr<Instruction> InstrumentPass::EndFunction() {
-  auto end = MakeUnique<Instruction>(context(), spv::Op::OpFunctionEnd, 0, 0,
-                                     std::initializer_list<Operand>{});
-  get_def_use_mgr()->AnalyzeInstDefUse(end.get());
-  return end;
-}
-
-std::vector<uint32_t> InstrumentPass::AddParameters(
-    Function& func, const std::vector<const analysis::Type*>& param_types) {
-  std::vector<uint32_t> param_ids;
-  param_ids.reserve(param_types.size());
-  for (const analysis::Type* param : param_types) {
-    uint32_t pid = TakeNextId();
-    param_ids.push_back(pid);
-    auto param_inst =
-        MakeUnique<Instruction>(context(), spv::Op::OpFunctionParameter,
-                                context()->get_type_mgr()->GetId(param), pid,
-                                std::initializer_list<Operand>{});
-    get_def_use_mgr()->AnalyzeInstDefUse(param_inst.get());
-    func.AddParameter(std::move(param_inst));
-  }
-  return param_ids;
-}
-
-std::unique_ptr<Instruction> InstrumentPass::NewName(
-    uint32_t id, const std::string& name_str) {
-  return MakeUnique<Instruction>(
-      context(), spv::Op::OpName, 0, 0,
-      std::initializer_list<Operand>{
-          {SPV_OPERAND_TYPE_ID, {id}},
-          {SPV_OPERAND_TYPE_LITERAL_STRING, utils::MakeVector(name_str)}});
-}
-
-uint32_t InstrumentPass::Gen32BitCvtCode(uint32_t val_id,
-                                         InstructionBuilder* builder) {
-  // Convert integer value to 32-bit if necessary
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  uint32_t val_ty_id = get_def_use_mgr()->GetDef(val_id)->type_id();
-  analysis::Integer* val_ty = type_mgr->GetType(val_ty_id)->AsInteger();
-  if (val_ty->width() == 32) return val_id;
-  bool is_signed = val_ty->IsSigned();
-  analysis::Integer val_32b_ty(32, is_signed);
-  analysis::Type* val_32b_reg_ty = type_mgr->GetRegisteredType(&val_32b_ty);
-  uint32_t val_32b_reg_ty_id = type_mgr->GetId(val_32b_reg_ty);
-  if (is_signed)
-    return builder->AddUnaryOp(val_32b_reg_ty_id, spv::Op::OpSConvert, val_id)
-        ->result_id();
-  else
-    return builder->AddUnaryOp(val_32b_reg_ty_id, spv::Op::OpUConvert, val_id)
-        ->result_id();
-}
-
-uint32_t InstrumentPass::GenUintCastCode(uint32_t val_id,
-                                         InstructionBuilder* builder) {
-  // Convert value to 32-bit if necessary
-  uint32_t val_32b_id = Gen32BitCvtCode(val_id, builder);
-  // Cast value to unsigned if necessary
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  uint32_t val_ty_id = get_def_use_mgr()->GetDef(val_32b_id)->type_id();
-  analysis::Integer* val_ty = type_mgr->GetType(val_ty_id)->AsInteger();
-  if (!val_ty->IsSigned()) return val_32b_id;
-  return builder->AddUnaryOp(GetUintId(), spv::Op::OpBitcast, val_32b_id)
-      ->result_id();
-}
-
-uint32_t InstrumentPass::GenVarLoad(uint32_t var_id,
-                                    InstructionBuilder* builder) {
-  Instruction* var_inst = get_def_use_mgr()->GetDef(var_id);
-  uint32_t type_id = GetPointeeTypeId(var_inst);
-  Instruction* load_inst = builder->AddLoad(type_id, var_id);
-  return load_inst->result_id();
-}
-
-uint32_t InstrumentPass::GenStageInfo(uint32_t stage_idx,
-                                      InstructionBuilder* builder) {
-  std::vector<uint32_t> ids(4, builder->GetUintConstantId(0));
-  ids[0] = builder->GetUintConstantId(stage_idx);
-  // %289 = OpCompositeConstruct %v4uint %uint_0 %285 %288 %uint_0
-  // TODO(greg-lunarg): Add support for all stages
-  switch (spv::ExecutionModel(stage_idx)) {
-    case spv::ExecutionModel::Vertex: {
-      // Load and store VertexId and InstanceId
-      uint32_t load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::VertexIndex)),
-          builder);
-      ids[1] = GenUintCastCode(load_id, builder);
-
-      load_id = GenVarLoad(context()->GetBuiltinInputVarId(
-                               uint32_t(spv::BuiltIn::InstanceIndex)),
-                           builder);
-      ids[2] = GenUintCastCode(load_id, builder);
-    } break;
-    case spv::ExecutionModel::GLCompute:
-    case spv::ExecutionModel::TaskNV:
-    case spv::ExecutionModel::MeshNV:
-    case spv::ExecutionModel::TaskEXT:
-    case spv::ExecutionModel::MeshEXT: {
-      // Load and store GlobalInvocationId.
-      uint32_t load_id = GenVarLoad(context()->GetBuiltinInputVarId(uint32_t(
-                                        spv::BuiltIn::GlobalInvocationId)),
-                                    builder);
-      for (uint32_t u = 0; u < 3u; ++u) {
-        ids[u + 1] = builder->AddCompositeExtract(GetUintId(), load_id, {u})
-                         ->result_id();
-      }
-    } break;
-    case spv::ExecutionModel::Geometry: {
-      // Load and store PrimitiveId and InvocationId.
-      uint32_t load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::PrimitiveId)),
-          builder);
-      ids[1] = load_id;
-      load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::InvocationId)),
-          builder);
-      ids[2] = GenUintCastCode(load_id, builder);
-    } break;
-    case spv::ExecutionModel::TessellationControl: {
-      // Load and store InvocationId and PrimitiveId
-      uint32_t load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::InvocationId)),
-          builder);
-      ids[1] = GenUintCastCode(load_id, builder);
-      load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::PrimitiveId)),
-          builder);
-      ids[2] = load_id;
-    } break;
-    case spv::ExecutionModel::TessellationEvaluation: {
-      // Load and store PrimitiveId and TessCoord.uv
-      uint32_t load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::PrimitiveId)),
-          builder);
-      ids[1] = load_id;
-      load_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::TessCoord)),
-          builder);
-      Instruction* uvec3_cast_inst =
-          builder->AddUnaryOp(GetVec3UintId(), spv::Op::OpBitcast, load_id);
-      uint32_t uvec3_cast_id = uvec3_cast_inst->result_id();
-      for (uint32_t u = 0; u < 2u; ++u) {
-        ids[u + 2] =
-            builder->AddCompositeExtract(GetUintId(), uvec3_cast_id, {u})
-                ->result_id();
-      }
-    } break;
-    case spv::ExecutionModel::Fragment: {
-      // Load FragCoord and convert to Uint
-      Instruction* frag_coord_inst = builder->AddLoad(
-          GetVec4FloatId(),
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::FragCoord)));
-      Instruction* uint_frag_coord_inst = builder->AddUnaryOp(
-          GetVec4UintId(), spv::Op::OpBitcast, frag_coord_inst->result_id());
-      for (uint32_t u = 0; u < 2u; ++u) {
-        ids[u + 1] =
-            builder
-                ->AddCompositeExtract(GetUintId(),
-                                      uint_frag_coord_inst->result_id(), {u})
-                ->result_id();
-      }
-    } break;
-    case spv::ExecutionModel::RayGenerationNV:
-    case spv::ExecutionModel::IntersectionNV:
-    case spv::ExecutionModel::AnyHitNV:
-    case spv::ExecutionModel::ClosestHitNV:
-    case spv::ExecutionModel::MissNV:
-    case spv::ExecutionModel::CallableNV: {
-      // Load and store LaunchIdNV.
-      uint32_t launch_id = GenVarLoad(
-          context()->GetBuiltinInputVarId(uint32_t(spv::BuiltIn::LaunchIdNV)),
-          builder);
-      for (uint32_t u = 0; u < 3u; ++u) {
-        ids[u + 1] = builder->AddCompositeExtract(GetUintId(), launch_id, {u})
-                         ->result_id();
-      }
-    } break;
-    default: { assert(false && "unsupported stage"); } break;
-  }
-  return builder->AddCompositeConstruct(GetVec4UintId(), ids)->result_id();
-}
-
-bool InstrumentPass::AllConstant(const std::vector<uint32_t>& ids) {
-  for (auto& id : ids) {
-    Instruction* id_inst = context()->get_def_use_mgr()->GetDef(id);
-    if (!spvOpcodeIsConstant(id_inst->opcode())) return false;
-  }
-  return true;
-}
-
-uint32_t InstrumentPass::GenReadFunctionCall(
-    uint32_t return_id, uint32_t func_id,
-    const std::vector<uint32_t>& func_call_args,
-    InstructionBuilder* ref_builder) {
-  // If optimizing direct reads and the call has already been generated,
-  // use its result
-  if (opt_direct_reads_) {
-    uint32_t res_id = call2id_[func_call_args];
-    if (res_id != 0) return res_id;
-  }
-  // If the function arguments are all constants, the call can be moved to the
-  // first block of the function where its result can be reused. One example
-  // where this is profitable is for uniform buffer references, of which there
-  // are often many.
-  InstructionBuilder builder(ref_builder->GetContext(),
-                             &*ref_builder->GetInsertPoint(),
-                             ref_builder->GetPreservedAnalysis());
-  bool insert_in_first_block = opt_direct_reads_ && AllConstant(func_call_args);
-  if (insert_in_first_block) {
-    Instruction* insert_before = &*curr_func_->begin()->tail();
-    builder.SetInsertPoint(insert_before);
-  }
-  uint32_t res_id =
-      builder.AddFunctionCall(return_id, func_id, func_call_args)->result_id();
-  if (insert_in_first_block) call2id_[func_call_args] = res_id;
-  return res_id;
-}
-
-bool InstrumentPass::IsSameBlockOp(const Instruction* inst) const {
-  return inst->opcode() == spv::Op::OpSampledImage ||
-         inst->opcode() == spv::Op::OpImage;
-}
-
-void InstrumentPass::CloneSameBlockOps(
-    std::unique_ptr<Instruction>* inst,
-    std::unordered_map<uint32_t, uint32_t>* same_blk_post,
-    std::unordered_map<uint32_t, Instruction*>* same_blk_pre,
-    BasicBlock* block_ptr) {
-  bool changed = false;
-  (*inst)->ForEachInId([&same_blk_post, &same_blk_pre, &block_ptr, &changed,
-                        this](uint32_t* iid) {
-    const auto map_itr = (*same_blk_post).find(*iid);
-    if (map_itr == (*same_blk_post).end()) {
-      const auto map_itr2 = (*same_blk_pre).find(*iid);
-      if (map_itr2 != (*same_blk_pre).end()) {
-        // Clone pre-call same-block ops, map result id.
-        const Instruction* in_inst = map_itr2->second;
-        std::unique_ptr<Instruction> sb_inst(in_inst->Clone(context()));
-        const uint32_t rid = sb_inst->result_id();
-        const uint32_t nid = this->TakeNextId();
-        get_decoration_mgr()->CloneDecorations(rid, nid);
-        sb_inst->SetResultId(nid);
-        get_def_use_mgr()->AnalyzeInstDefUse(&*sb_inst);
-        (*same_blk_post)[rid] = nid;
-        *iid = nid;
-        changed = true;
-        CloneSameBlockOps(&sb_inst, same_blk_post, same_blk_pre, block_ptr);
-        block_ptr->AddInstruction(std::move(sb_inst));
-      }
-    } else {
-      // Reset same-block op operand if necessary
-      if (*iid != map_itr->second) {
-        *iid = map_itr->second;
-        changed = true;
-      }
-    }
-  });
-  if (changed) get_def_use_mgr()->AnalyzeInstUse(&**inst);
-}
-
-void InstrumentPass::UpdateSucceedingPhis(
-    std::vector<std::unique_ptr<BasicBlock>>& new_blocks) {
-  const auto first_blk = new_blocks.begin();
-  const auto last_blk = new_blocks.end() - 1;
-  const uint32_t first_id = (*first_blk)->id();
-  const uint32_t last_id = (*last_blk)->id();
-  const BasicBlock& const_last_block = *last_blk->get();
-  const_last_block.ForEachSuccessorLabel(
-      [&first_id, &last_id, this](const uint32_t succ) {
-        BasicBlock* sbp = this->id2block_[succ];
-        sbp->ForEachPhiInst([&first_id, &last_id, this](Instruction* phi) {
-          bool changed = false;
-          phi->ForEachInId([&first_id, &last_id, &changed](uint32_t* id) {
-            if (*id == first_id) {
-              *id = last_id;
-              changed = true;
-            }
-          });
-          if (changed) get_def_use_mgr()->AnalyzeInstUse(phi);
-        });
-      });
-}
-
-analysis::Integer* InstrumentPass::GetInteger(uint32_t width, bool is_signed) {
-  analysis::Integer i(width, is_signed);
-  analysis::Type* type = context()->get_type_mgr()->GetRegisteredType(&i);
-  assert(type && type->AsInteger());
-  return type->AsInteger();
-}
-
-analysis::Struct* InstrumentPass::GetStruct(
-    const std::vector<const analysis::Type*>& fields) {
-  analysis::Struct s(fields);
-  analysis::Type* type = context()->get_type_mgr()->GetRegisteredType(&s);
-  assert(type && type->AsStruct());
-  return type->AsStruct();
-}
-
-analysis::RuntimeArray* InstrumentPass::GetRuntimeArray(
-    const analysis::Type* element) {
-  analysis::RuntimeArray r(element);
-  analysis::Type* type = context()->get_type_mgr()->GetRegisteredType(&r);
-  assert(type && type->AsRuntimeArray());
-  return type->AsRuntimeArray();
-}
-
-analysis::Array* InstrumentPass::GetArray(const analysis::Type* element,
-                                          uint32_t length) {
-  uint32_t length_id = context()->get_constant_mgr()->GetUIntConstId(length);
-  analysis::Array::LengthInfo length_info{
-      length_id, {analysis::Array::LengthInfo::Case::kConstant, length}};
-
-  analysis::Array r(element, length_info);
-
-  analysis::Type* type = context()->get_type_mgr()->GetRegisteredType(&r);
-  assert(type && type->AsArray());
-  return type->AsArray();
-}
-
-analysis::Function* InstrumentPass::GetFunction(
-    const analysis::Type* return_val,
-    const std::vector<const analysis::Type*>& args) {
-  analysis::Function func(return_val, args);
-  analysis::Type* type = context()->get_type_mgr()->GetRegisteredType(&func);
-  assert(type && type->AsFunction());
-  return type->AsFunction();
-}
-
-analysis::RuntimeArray* InstrumentPass::GetUintXRuntimeArrayType(
-    uint32_t width, analysis::RuntimeArray** rarr_ty) {
-  if (*rarr_ty == nullptr) {
-    *rarr_ty = GetRuntimeArray(GetInteger(width, false));
-    uint32_t uint_arr_ty_id =
-        context()->get_type_mgr()->GetTypeInstruction(*rarr_ty);
-    // By the Vulkan spec, a pre-existing RuntimeArray of uint must be part of
-    // a block, and will therefore be decorated with an ArrayStride. Therefore
-    // the undecorated type returned here will not be pre-existing and can
-    // safely be decorated. Since this type is now decorated, it is out of
-    // sync with the TypeManager and therefore the TypeManager must be
-    // invalidated after this pass.
-    assert(get_def_use_mgr()->NumUses(uint_arr_ty_id) == 0 &&
-           "used RuntimeArray type returned");
-    get_decoration_mgr()->AddDecorationVal(
-        uint_arr_ty_id, uint32_t(spv::Decoration::ArrayStride), width / 8u);
-  }
-  return *rarr_ty;
-}
-
-analysis::RuntimeArray* InstrumentPass::GetUintRuntimeArrayType(
-    uint32_t width) {
-  analysis::RuntimeArray** rarr_ty =
-      (width == 64) ? &uint64_rarr_ty_ : &uint32_rarr_ty_;
-  return GetUintXRuntimeArrayType(width, rarr_ty);
-}
-
-void InstrumentPass::AddStorageBufferExt() {
-  if (storage_buffer_ext_defined_) return;
-  if (!get_feature_mgr()->HasExtension(kSPV_KHR_storage_buffer_storage_class)) {
-    context()->AddExtension("SPV_KHR_storage_buffer_storage_class");
-  }
-  storage_buffer_ext_defined_ = true;
-}
-
-uint32_t InstrumentPass::GetFloatId() {
-  if (float_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Float float_ty(32);
-    analysis::Type* reg_float_ty = type_mgr->GetRegisteredType(&float_ty);
-    float_id_ = type_mgr->GetTypeInstruction(reg_float_ty);
-  }
-  return float_id_;
-}
-
-uint32_t InstrumentPass::GetVec4FloatId() {
-  if (v4float_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Float float_ty(32);
-    analysis::Type* reg_float_ty = type_mgr->GetRegisteredType(&float_ty);
-    analysis::Vector v4float_ty(reg_float_ty, 4);
-    analysis::Type* reg_v4float_ty = type_mgr->GetRegisteredType(&v4float_ty);
-    v4float_id_ = type_mgr->GetTypeInstruction(reg_v4float_ty);
-  }
-  return v4float_id_;
-}
-
-uint32_t InstrumentPass::GetUintId() {
-  if (uint_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Integer uint_ty(32, false);
-    analysis::Type* reg_uint_ty = type_mgr->GetRegisteredType(&uint_ty);
-    uint_id_ = type_mgr->GetTypeInstruction(reg_uint_ty);
-  }
-  return uint_id_;
-}
-
-uint32_t InstrumentPass::GetUint64Id() {
-  if (uint64_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Integer uint64_ty(64, false);
-    analysis::Type* reg_uint64_ty = type_mgr->GetRegisteredType(&uint64_ty);
-    uint64_id_ = type_mgr->GetTypeInstruction(reg_uint64_ty);
-  }
-  return uint64_id_;
-}
-
-uint32_t InstrumentPass::GetUint8Id() {
-  if (uint8_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Integer uint8_ty(8, false);
-    analysis::Type* reg_uint8_ty = type_mgr->GetRegisteredType(&uint8_ty);
-    uint8_id_ = type_mgr->GetTypeInstruction(reg_uint8_ty);
-  }
-  return uint8_id_;
-}
-
-uint32_t InstrumentPass::GetVecUintId(uint32_t len) {
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
-  analysis::Integer uint_ty(32, false);
-  analysis::Type* reg_uint_ty = type_mgr->GetRegisteredType(&uint_ty);
-  analysis::Vector v_uint_ty(reg_uint_ty, len);
-  analysis::Type* reg_v_uint_ty = type_mgr->GetRegisteredType(&v_uint_ty);
-  uint32_t v_uint_id = type_mgr->GetTypeInstruction(reg_v_uint_ty);
-  return v_uint_id;
-}
-
-uint32_t InstrumentPass::GetVec4UintId() {
-  if (v4uint_id_ == 0) v4uint_id_ = GetVecUintId(4u);
-  return v4uint_id_;
-}
-
-uint32_t InstrumentPass::GetVec3UintId() {
-  if (v3uint_id_ == 0) v3uint_id_ = GetVecUintId(3u);
-  return v3uint_id_;
-}
-
-uint32_t InstrumentPass::GetBoolId() {
-  if (bool_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Bool bool_ty;
-    analysis::Type* reg_bool_ty = type_mgr->GetRegisteredType(&bool_ty);
-    bool_id_ = type_mgr->GetTypeInstruction(reg_bool_ty);
-  }
-  return bool_id_;
-}
-
-uint32_t InstrumentPass::GetVoidId() {
-  if (void_id_ == 0) {
-    analysis::TypeManager* type_mgr = context()->get_type_mgr();
-    analysis::Void void_ty;
-    analysis::Type* reg_void_ty = type_mgr->GetRegisteredType(&void_ty);
-    void_id_ = type_mgr->GetTypeInstruction(reg_void_ty);
-  }
-  return void_id_;
-}
-
-void InstrumentPass::SplitBlock(
-    BasicBlock::iterator inst_itr, UptrVectorIterator<BasicBlock> block_itr,
-    std::vector<std::unique_ptr<BasicBlock>>* new_blocks) {
-  // Make sure def/use analysis is done before we start moving instructions
-  // out of function
-  (void)get_def_use_mgr();
-  // Move original block's preceding instructions into first new block
-  std::unique_ptr<BasicBlock> first_blk_ptr;
-  MovePreludeCode(inst_itr, block_itr, &first_blk_ptr);
-  InstructionBuilder builder(
-      context(), &*first_blk_ptr,
-      IRContext::kAnalysisDefUse | IRContext::kAnalysisInstrToBlockMapping);
-  uint32_t split_blk_id = TakeNextId();
-  std::unique_ptr<Instruction> split_label(NewLabel(split_blk_id));
-  (void)builder.AddBranch(split_blk_id);
-  new_blocks->push_back(std::move(first_blk_ptr));
-  // Move remaining instructions into split block and add to new blocks
-  std::unique_ptr<BasicBlock> split_blk_ptr(
-      new BasicBlock(std::move(split_label)));
-  MovePostludeCode(block_itr, &*split_blk_ptr);
-  new_blocks->push_back(std::move(split_blk_ptr));
-}
-
-bool InstrumentPass::InstrumentFunction(Function* func, uint32_t stage_idx,
-                                        InstProcessFunction& pfn) {
-  curr_func_ = func;
-  call2id_.clear();
-  bool first_block_split = false;
-  bool modified = false;
-  // Apply instrumentation function to each instruction.
-  // Using block iterators here because of block erasures and insertions.
-  std::vector<std::unique_ptr<BasicBlock>> new_blks;
-  for (auto bi = func->begin(); bi != func->end(); ++bi) {
-    for (auto ii = bi->begin(); ii != bi->end();) {
-      // Split all executable instructions out of first block into a following
-      // block. This will allow function calls to be inserted into the first
-      // block without interfering with the instrumentation algorithm.
-      if (opt_direct_reads_ && !first_block_split) {
-        if (ii->opcode() != spv::Op::OpVariable) {
-          SplitBlock(ii, bi, &new_blks);
-          first_block_split = true;
-        }
-      } else {
-        pfn(ii, bi, stage_idx, &new_blks);
-      }
-      // If no new code, continue
-      if (new_blks.size() == 0) {
-        ++ii;
-        continue;
-      }
-      // Add new blocks to label id map
-      for (auto& blk : new_blks) id2block_[blk->id()] = &*blk;
-      // If there are new blocks we know there will always be two or
-      // more, so update succeeding phis with label of new last block.
-      size_t newBlocksSize = new_blks.size();
-      assert(newBlocksSize > 1);
-      UpdateSucceedingPhis(new_blks);
-      // Replace original block with new block(s)
-      bi = bi.Erase();
-      for (auto& bb : new_blks) {
-        bb->SetParent(func);
-      }
-      bi = bi.InsertBefore(&new_blks);
-      // Reset block iterator to last new block
-      for (size_t i = 0; i < newBlocksSize - 1; i++) ++bi;
-      modified = true;
-      // Restart instrumenting at beginning of last new block,
-      // but skip over any new phi or copy instruction.
-      ii = bi->begin();
-      if (ii->opcode() == spv::Op::OpPhi ||
-          ii->opcode() == spv::Op::OpCopyObject)
-        ++ii;
-      new_blks.clear();
-    }
-  }
-  return modified;
-}
-
-bool InstrumentPass::InstProcessCallTreeFromRoots(InstProcessFunction& pfn,
-                                                  std::queue<uint32_t>* roots,
-                                                  uint32_t stage_idx) {
-  bool modified = false;
-  std::unordered_set<uint32_t> done;
-  // Don't process input and output functions
-  for (auto& ifn : param2input_func_id_) done.insert(ifn.second);
-  for (auto& ofn : param2output_func_id_) done.insert(ofn.second);
-  // Process all functions from roots
-  while (!roots->empty()) {
-    const uint32_t fi = roots->front();
-    roots->pop();
-    if (done.insert(fi).second) {
-      Function* fn = id2function_.at(fi);
-      // Add calls first so we don't add new output function
-      context()->AddCalls(fn, roots);
-      modified = InstrumentFunction(fn, stage_idx, pfn) || modified;
-    }
-  }
-  return modified;
-}
-
-bool InstrumentPass::InstProcessEntryPointCallTree(InstProcessFunction& pfn) {
-  uint32_t stage_id;
-  if (use_stage_info_) {
-    // Make sure all entry points have the same execution model. Do not
-    // instrument if they do not.
-    // TODO(greg-lunarg): Handle mixed stages. Technically, a shader module
-    // can contain entry points with different execution models, although
-    // such modules will likely be rare as GLSL and HLSL are geared toward
-    // one model per module. In such cases we will need
-    // to clone any functions which are in the call trees of entrypoints
-    // with differing execution models.
-    spv::ExecutionModel stage = context()->GetStage();
-    // Check for supported stages
-    if (stage != spv::ExecutionModel::Vertex &&
-        stage != spv::ExecutionModel::Fragment &&
-        stage != spv::ExecutionModel::Geometry &&
-        stage != spv::ExecutionModel::GLCompute &&
-        stage != spv::ExecutionModel::TessellationControl &&
-        stage != spv::ExecutionModel::TessellationEvaluation &&
-        stage != spv::ExecutionModel::TaskNV &&
-        stage != spv::ExecutionModel::MeshNV &&
-        stage != spv::ExecutionModel::RayGenerationNV &&
-        stage != spv::ExecutionModel::IntersectionNV &&
-        stage != spv::ExecutionModel::AnyHitNV &&
-        stage != spv::ExecutionModel::ClosestHitNV &&
-        stage != spv::ExecutionModel::MissNV &&
-        stage != spv::ExecutionModel::CallableNV &&
-        stage != spv::ExecutionModel::TaskEXT &&
-        stage != spv::ExecutionModel::MeshEXT) {
-      if (consumer()) {
-        std::string message = "Stage not supported by instrumentation";
-        consumer()(SPV_MSG_ERROR, 0, {0, 0, 0}, message.c_str());
-      }
-      return false;
-    }
-    stage_id = static_cast<uint32_t>(stage);
-  } else {
-    stage_id = 0;
-  }
-  // Add together the roots of all entry points
-  std::queue<uint32_t> roots;
-  for (auto& e : get_module()->entry_points()) {
-    roots.push(e.GetSingleWordInOperand(kEntryPointFunctionIdInIdx));
-  }
-  bool modified = InstProcessCallTreeFromRoots(pfn, &roots, stage_id);
-  return modified;
-}
-
-void InstrumentPass::InitializeInstrument() {
-  float_id_ = 0;
-  v4float_id_ = 0;
-  uint_id_ = 0;
-  uint64_id_ = 0;
-  uint8_id_ = 0;
-  v4uint_id_ = 0;
-  v3uint_id_ = 0;
-  bool_id_ = 0;
-  void_id_ = 0;
-  storage_buffer_ext_defined_ = false;
-  uint32_rarr_ty_ = nullptr;
-  uint64_rarr_ty_ = nullptr;
-
-  // clear collections
-  id2function_.clear();
-  id2block_.clear();
-
-  // clear maps
-  param2input_func_id_.clear();
-  param2output_func_id_.clear();
-
-  // Initialize function and block maps.
-  for (auto& fn : *get_module()) {
-    id2function_[fn.result_id()] = &fn;
-    for (auto& blk : fn) {
-      id2block_[blk.id()] = &blk;
-    }
-  }
-
-  // Remember original instruction offsets
-  uint32_t module_offset = 0;
-  Module* module = get_module();
-  for (auto& i : context()->capabilities()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->extensions()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->ext_inst_imports()) {
-    (void)i;
-    ++module_offset;
-  }
-  ++module_offset;  // memory_model
-  for (auto& i : module->entry_points()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->execution_modes()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->debugs1()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->debugs2()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->debugs3()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->ext_inst_debuginfo()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->annotations()) {
-    (void)i;
-    ++module_offset;
-  }
-  for (auto& i : module->types_values()) {
-    module_offset += 1;
-    module_offset += static_cast<uint32_t>(i.dbg_line_insts().size());
-  }
-
-  auto curr_fn = get_module()->begin();
-  for (; curr_fn != get_module()->end(); ++curr_fn) {
-    // Count function instruction
-    module_offset += 1;
-    curr_fn->ForEachParam(
-        [&module_offset](const Instruction*) { module_offset += 1; }, true);
-    for (auto& blk : *curr_fn) {
-      // Count label
-      module_offset += 1;
-      for (auto& inst : blk) {
-        module_offset += static_cast<uint32_t>(inst.dbg_line_insts().size());
-        uid2offset_[inst.unique_id()] = module_offset;
-        module_offset += 1;
-      }
-    }
-    // Count function end instruction
-    module_offset += 1;
-  }
-}
-
-}  // namespace opt
-}  // namespace spvtools
diff --git a/source/opt/instrument_pass.h b/source/opt/instrument_pass.h
deleted file mode 100644
index e4408c93..00000000
--- a/source/opt/instrument_pass.h
+++ /dev/null
@@ -1,326 +0,0 @@
-// Copyright (c) 2018 The Khronos Group Inc.
-// Copyright (c) 2018 Valve Corporation
-// Copyright (c) 2018 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef LIBSPIRV_OPT_INSTRUMENT_PASS_H_
-#define LIBSPIRV_OPT_INSTRUMENT_PASS_H_
-
-#include <list>
-#include <memory>
-#include <vector>
-
-#include "source/opt/ir_builder.h"
-#include "source/opt/pass.h"
-#include "spirv-tools/instrument.hpp"
-
-// This is a base class to assist in the creation of passes which instrument
-// shader modules. More specifically, passes which replace instructions with a
-// larger and more capable set of instructions. Commonly, these new
-// instructions will add testing of operands and execute different
-// instructions depending on the outcome, including outputting of debug
-// information into a buffer created especially for that purpose.
-//
-// This class contains helper functions to create an InstProcessFunction,
-// which is the heart of any derived class implementing a specific
-// instrumentation pass. It takes an instruction as an argument, decides
-// if it should be instrumented, and generates code to replace it. This class
-// also supplies function InstProcessEntryPointCallTree which applies the
-// InstProcessFunction to every reachable instruction in a module and replaces
-// the instruction with new instructions if generated.
-//
-// Chief among the helper functions are output code generation functions,
-// used to generate code in the shader which writes data to output buffers
-// associated with that validation. Currently one such function,
-// GenDebugStreamWrite, exists. Other such functions may be added in the
-// future. Each is accompanied by documentation describing the format of
-// its output buffer.
-//
-// A validation pass may read or write multiple buffers. All such buffers
-// are located in a single debug descriptor set whose index is passed at the
-// creation of the instrumentation pass. The bindings of the buffers used by
-// a validation pass are permanently assigned and fixed and documented by
-// the kDebugOutput* static consts.
-
-namespace spvtools {
-namespace opt {
-
-class InstrumentPass : public Pass {
-  using cbb_ptr = const BasicBlock*;
-
- public:
-  using InstProcessFunction =
-      std::function<void(BasicBlock::iterator, UptrVectorIterator<BasicBlock>,
-                         uint32_t, std::vector<std::unique_ptr<BasicBlock>>*)>;
-
-  ~InstrumentPass() override = default;
-
-  IRContext::Analysis GetPreservedAnalyses() override {
-    return IRContext::kAnalysisDefUse | IRContext::kAnalysisDecorations |
-           IRContext::kAnalysisCombinators | IRContext::kAnalysisNameMap |
-           IRContext::kAnalysisBuiltinVarId | IRContext::kAnalysisConstants;
-  }
-
- protected:
-  // Create instrumentation pass for |validation_id| which utilizes descriptor
-  // set |desc_set| for debug input and output buffers and writes |shader_id|
-  // into debug output records. |opt_direct_reads| indicates that the pass
-  // will see direct input buffer reads and should prepare to optimize them.
-  InstrumentPass(uint32_t desc_set, uint32_t shader_id, bool opt_direct_reads,
-                 bool use_stage_info)
-      : Pass(),
-        desc_set_(desc_set),
-        shader_id_(shader_id),
-        opt_direct_reads_(opt_direct_reads),
-        use_stage_info_(use_stage_info) {}
-
-  // Initialize state for instrumentation of module.
-  void InitializeInstrument();
-
-  // Call |pfn| on all instructions in all functions in the call tree of the
-  // entry points in |module|. If code is generated for an instruction, replace
-  // the instruction's block with the new blocks that are generated. Continue
-  // processing at the top of the last new block.
-  bool InstProcessEntryPointCallTree(InstProcessFunction& pfn);
-
-  // Move all code in |ref_block_itr| preceding the instruction |ref_inst_itr|
-  // to be instrumented into block |new_blk_ptr|.
-  void MovePreludeCode(BasicBlock::iterator ref_inst_itr,
-                       UptrVectorIterator<BasicBlock> ref_block_itr,
-                       std::unique_ptr<BasicBlock>* new_blk_ptr);
-
-  // Move all code in |ref_block_itr| succeeding the instruction |ref_inst_itr|
-  // to be instrumented into block |new_blk_ptr|.
-  void MovePostludeCode(UptrVectorIterator<BasicBlock> ref_block_itr,
-                        BasicBlock* new_blk_ptr);
-
-  // Return true if all instructions in |ids| are constants or spec constants.
-  bool AllConstant(const std::vector<uint32_t>& ids);
-
-  uint32_t GenReadFunctionCall(uint32_t return_id, uint32_t func_id,
-                               const std::vector<uint32_t>& args,
-                               InstructionBuilder* builder);
-
-  // Generate code to convert integer |value_id| to 32bit, if needed. Return
-  // an id to the 32bit equivalent.
-  uint32_t Gen32BitCvtCode(uint32_t value_id, InstructionBuilder* builder);
-
-  // Generate code to cast integer |value_id| to 32bit unsigned, if needed.
-  // Return an id to the Uint equivalent.
-  uint32_t GenUintCastCode(uint32_t value_id, InstructionBuilder* builder);
-
-  std::unique_ptr<Function> StartFunction(
-      uint32_t func_id, const analysis::Type* return_type,
-      const std::vector<const analysis::Type*>& param_types);
-
-  std::vector<uint32_t> AddParameters(
-      Function& func, const std::vector<const analysis::Type*>& param_types);
-
-  std::unique_ptr<Instruction> EndFunction();
-
-  // Return new label.
-  std::unique_ptr<Instruction> NewLabel(uint32_t label_id);
-
-  // Set the name function parameter or local variable
-  std::unique_ptr<Instruction> NewName(uint32_t id,
-                                       const std::string& name_str);
-
-  // Return id for 32-bit unsigned type
-  uint32_t GetUintId();
-
-  // Return id for 64-bit unsigned type
-  uint32_t GetUint64Id();
-
-  // Return id for 8-bit unsigned type
-  uint32_t GetUint8Id();
-
-  // Return id for 32-bit unsigned type
-  uint32_t GetBoolId();
-
-  // Return id for void type
-  uint32_t GetVoidId();
-
-  // Get registered type structures
-  analysis::Integer* GetInteger(uint32_t width, bool is_signed);
-  analysis::Struct* GetStruct(const std::vector<const analysis::Type*>& fields);
-  analysis::RuntimeArray* GetRuntimeArray(const analysis::Type* element);
-  analysis::Array* GetArray(const analysis::Type* element, uint32_t size);
-  analysis::Function* GetFunction(
-      const analysis::Type* return_val,
-      const std::vector<const analysis::Type*>& args);
-
-  // Return pointer to type for runtime array of uint
-  analysis::RuntimeArray* GetUintXRuntimeArrayType(
-      uint32_t width, analysis::RuntimeArray** rarr_ty);
-
-  // Return pointer to type for runtime array of uint
-  analysis::RuntimeArray* GetUintRuntimeArrayType(uint32_t width);
-
-  // Add storage buffer extension if needed
-  void AddStorageBufferExt();
-
-  // Return id for 32-bit float type
-  uint32_t GetFloatId();
-
-  // Return id for v4float type
-  uint32_t GetVec4FloatId();
-
-  // Return id for uint vector type of |length|
-  uint32_t GetVecUintId(uint32_t length);
-
-  // Return id for v4uint type
-  uint32_t GetVec4UintId();
-
-  // Return id for v3uint type
-  uint32_t GetVec3UintId();
-
-  // Split block |block_itr| into two new blocks where the second block
-  // contains |inst_itr| and place in |new_blocks|.
-  void SplitBlock(BasicBlock::iterator inst_itr,
-                  UptrVectorIterator<BasicBlock> block_itr,
-                  std::vector<std::unique_ptr<BasicBlock>>* new_blocks);
-
-  // Apply instrumentation function |pfn| to every instruction in |func|.
-  // If code is generated for an instruction, replace the instruction's
-  // block with the new blocks that are generated. Continue processing at the
-  // top of the last new block.
-  virtual bool InstrumentFunction(Function* func, uint32_t stage_idx,
-                                  InstProcessFunction& pfn);
-
-  // Call |pfn| on all functions in the call tree of the function
-  // ids in |roots|.
-  bool InstProcessCallTreeFromRoots(InstProcessFunction& pfn,
-                                    std::queue<uint32_t>* roots,
-                                    uint32_t stage_idx);
-
-  // Generate instructions into |builder| which will load |var_id| and return
-  // its result id.
-  uint32_t GenVarLoad(uint32_t var_id, InstructionBuilder* builder);
-
-  uint32_t GenStageInfo(uint32_t stage_idx, InstructionBuilder* builder);
-
-  // Return true if instruction must be in the same block that its result
-  // is used.
-  bool IsSameBlockOp(const Instruction* inst) const;
-
-  // Clone operands which must be in same block as consumer instructions.
-  // Look in same_blk_pre for instructions that need cloning. Look in
-  // same_blk_post for instructions already cloned. Add cloned instruction
-  // to same_blk_post.
-  void CloneSameBlockOps(
-      std::unique_ptr<Instruction>* inst,
-      std::unordered_map<uint32_t, uint32_t>* same_blk_post,
-      std::unordered_map<uint32_t, Instruction*>* same_blk_pre,
-      BasicBlock* block_ptr);
-
-  // Update phis in succeeding blocks to point to new last block
-  void UpdateSucceedingPhis(
-      std::vector<std::unique_ptr<BasicBlock>>& new_blocks);
-
-  // Debug descriptor set index
-  uint32_t desc_set_;
-
-  // Shader module ID written into output record
-  uint32_t shader_id_;
-
-  // Map from function id to function pointer.
-  std::unordered_map<uint32_t, Function*> id2function_;
-
-  // Map from block's label id to block. TODO(dnovillo): This is superfluous wrt
-  // CFG. It has functionality not present in CFG. Consolidate.
-  std::unordered_map<uint32_t, BasicBlock*> id2block_;
-
-  // Map from instruction's unique id to offset in original file.
-  std::unordered_map<uint32_t, uint32_t> uid2offset_;
-
-  // id for debug output function
-  std::unordered_map<uint32_t, uint32_t> param2output_func_id_;
-
-  // ids for debug input functions
-  std::unordered_map<uint32_t, uint32_t> param2input_func_id_;
-
-  // id for 32-bit float type
-  uint32_t float_id_{0};
-
-  // id for v4float type
-  uint32_t v4float_id_{0};
-
-  // id for v4uint type
-  uint32_t v4uint_id_{0};
-
-  // id for v3uint type
-  uint32_t v3uint_id_{0};
-
-  // id for 32-bit unsigned type
-  uint32_t uint_id_{0};
-
-  // id for 64-bit unsigned type
-  uint32_t uint64_id_{0};
-
-  // id for 8-bit unsigned type
-  uint32_t uint8_id_{0};
-
-  // id for bool type
-  uint32_t bool_id_{0};
-
-  // id for void type
-  uint32_t void_id_{0};
-
-  // boolean to remember storage buffer extension
-  bool storage_buffer_ext_defined_{false};
-
-  // runtime array of uint type
-  analysis::RuntimeArray* uint64_rarr_ty_{nullptr};
-
-  // runtime array of uint type
-  analysis::RuntimeArray* uint32_rarr_ty_{nullptr};
-
-  // Pre-instrumentation same-block insts
-  std::unordered_map<uint32_t, Instruction*> same_block_pre_;
-
-  // Post-instrumentation same-block op ids
-  std::unordered_map<uint32_t, uint32_t> same_block_post_;
-
-  // Map function calls to result id. Clear for every function.
-  // This is for debug input reads with constant arguments that
-  // have been generated into the first block of the function.
-  // This mechanism is used to avoid multiple identical debug
-  // input buffer reads.
-  struct vector_hash_ {
-    std::size_t operator()(const std::vector<uint32_t>& v) const {
-      std::size_t hash = v.size();
-      for (auto& u : v) {
-        hash ^= u + 0x9e3779b9 + (hash << 11) + (hash >> 21);
-      }
-      return hash;
-    }
-  };
-  std::unordered_map<std::vector<uint32_t>, uint32_t, vector_hash_> call2id_;
-
-  // Function currently being instrumented
-  Function* curr_func_{nullptr};
-
-  // Optimize direct debug input buffer reads. Specifically, move all such
-  // reads with constant args to first block and reuse them.
-  const bool opt_direct_reads_;
-
-  // Set true if the instrumentation needs to know the current stage.
-  // Note that this does not work with multi-stage modules.
-  const bool use_stage_info_;
-};
-
-}  // namespace opt
-}  // namespace spvtools
-
-#endif  // LIBSPIRV_OPT_INSTRUMENT_PASS_H_
diff --git a/source/opt/ir_context.cpp b/source/opt/ir_context.cpp
index 239d316c..1cf0d74b 100644
--- a/source/opt/ir_context.cpp
+++ b/source/opt/ir_context.cpp
@@ -88,6 +88,9 @@ void IRContext::BuildInvalidAnalyses(IRContext::Analysis set) {
   if (set & kAnalysisDebugInfo) {
     BuildDebugInfoManager();
   }
+  if (set & kAnalysisLiveness) {
+    BuildLivenessManager();
+  }
 }
 
 void IRContext::InvalidateAnalysesExceptFor(
@@ -923,9 +926,35 @@ uint32_t IRContext::GetBuiltinInputVarId(uint32_t builtin) {
 
 void IRContext::AddCalls(const Function* func, std::queue<uint32_t>* todo) {
   for (auto bi = func->begin(); bi != func->end(); ++bi)
-    for (auto ii = bi->begin(); ii != bi->end(); ++ii)
+    for (auto ii = bi->begin(); ii != bi->end(); ++ii) {
       if (ii->opcode() == spv::Op::OpFunctionCall)
         todo->push(ii->GetSingleWordInOperand(0));
+      if (ii->opcode() == spv::Op::OpCooperativeMatrixPerElementOpNV)
+        todo->push(ii->GetSingleWordInOperand(1));
+      if (ii->opcode() == spv::Op::OpCooperativeMatrixReduceNV)
+        todo->push(ii->GetSingleWordInOperand(2));
+      if (ii->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) {
+        const auto memory_operands_index = 3;
+        auto mask = ii->GetSingleWordInOperand(memory_operands_index);
+
+        uint32_t count = 1;
+        if (mask & uint32_t(spv::MemoryAccessMask::Aligned)) ++count;
+        if (mask & uint32_t(spv::MemoryAccessMask::MakePointerAvailableKHR))
+          ++count;
+        if (mask & uint32_t(spv::MemoryAccessMask::MakePointerVisibleKHR))
+          ++count;
+
+        const auto tensor_operands_index = memory_operands_index + count;
+        mask = ii->GetSingleWordInOperand(tensor_operands_index);
+        count = 1;
+        if (mask & uint32_t(spv::TensorAddressingOperandsMask::TensorView))
+          ++count;
+
+        if (mask & uint32_t(spv::TensorAddressingOperandsMask::DecodeFunc)) {
+          todo->push(ii->GetSingleWordInOperand(tensor_operands_index + count));
+        }
+      }
+    }
 }
 
 bool IRContext::ProcessEntryPointCallTree(ProcessFunction& pfn) {
diff --git a/source/opt/ir_context.h b/source/opt/ir_context.h
index 5685db80..38576966 100644
--- a/source/opt/ir_context.h
+++ b/source/opt/ir_context.h
@@ -84,7 +84,7 @@ class IRContext {
     kAnalysisTypes = 1 << 15,
     kAnalysisDebugInfo = 1 << 16,
     kAnalysisLiveness = 1 << 17,
-    kAnalysisEnd = 1 << 17
+    kAnalysisEnd = 1 << 18
   };
 
   using ProcessFunction = std::function<bool(Function*)>;
@@ -202,8 +202,9 @@ class IRContext {
   inline IteratorRange<Module::const_inst_iterator> debugs3() const;
 
   // Iterators for debug info instructions (excluding OpLine & OpNoLine)
-  // contained in this module.  These are OpExtInst for DebugInfo extension
-  // placed between section 9 and 10.
+  // contained in this module.  These are OpExtInst &
+  // OpExtInstWithForwardRefsKHR for DebugInfo extension placed between section
+  // 9 and 10.
   inline Module::inst_iterator ext_inst_debuginfo_begin();
   inline Module::inst_iterator ext_inst_debuginfo_end();
   inline IteratorRange<Module::inst_iterator> ext_inst_debuginfo();
diff --git a/source/opt/ir_loader.cpp b/source/opt/ir_loader.cpp
index e9b7bbfc..a7850488 100644
--- a/source/opt/ir_loader.cpp
+++ b/source/opt/ir_loader.cpp
@@ -42,7 +42,7 @@ IrLoader::IrLoader(const MessageConsumer& consumer, Module* m)
 bool IsLineInst(const spv_parsed_instruction_t* inst) {
   const auto opcode = static_cast<spv::Op>(inst->opcode);
   if (IsOpLineInst(opcode)) return true;
-  if (opcode != spv::Op::OpExtInst) return false;
+  if (!spvIsExtendedInstruction(opcode)) return false;
   if (inst->ext_inst_type != SPV_EXT_INST_TYPE_NONSEMANTIC_SHADER_DEBUGINFO_100)
     return false;
   const uint32_t ext_inst_index = inst->words[kExtInstSetIndex];
@@ -65,7 +65,7 @@ bool IrLoader::AddInstruction(const spv_parsed_instruction_t* inst) {
   // create a new instruction, but simply keep the information in
   // struct DebugScope.
   const auto opcode = static_cast<spv::Op>(inst->opcode);
-  if (opcode == spv::Op::OpExtInst &&
+  if (spvIsExtendedInstruction(opcode) &&
       spvExtInstIsDebugInfo(inst->ext_inst_type)) {
     const uint32_t ext_inst_index = inst->words[kExtInstSetIndex];
     if (inst->ext_inst_type == SPV_EXT_INST_TYPE_OPENCL_DEBUGINFO_100 ||
@@ -209,10 +209,10 @@ bool IrLoader::AddInstruction(const spv_parsed_instruction_t* inst) {
       } else if (IsConstantInst(opcode) || opcode == spv::Op::OpVariable ||
                  opcode == spv::Op::OpUndef) {
         module_->AddGlobalValue(std::move(spv_inst));
-      } else if (opcode == spv::Op::OpExtInst &&
+      } else if (spvIsExtendedInstruction(opcode) &&
                  spvExtInstIsDebugInfo(inst->ext_inst_type)) {
         module_->AddExtInstDebugInfo(std::move(spv_inst));
-      } else if (opcode == spv::Op::OpExtInst &&
+      } else if (spvIsExtendedInstruction(opcode) &&
                  spvExtInstIsNonSemantic(inst->ext_inst_type)) {
         // If there are no functions, add the non-semantic instructions to the
         // global values. Otherwise append it to the list of the last function.
@@ -235,7 +235,7 @@ bool IrLoader::AddInstruction(const spv_parsed_instruction_t* inst) {
         last_dbg_scope_ = DebugScope(kNoDebugScope, kNoInlinedAt);
       if (last_dbg_scope_.GetLexicalScope() != kNoDebugScope)
         spv_inst->SetDebugScope(last_dbg_scope_);
-      if (opcode == spv::Op::OpExtInst &&
+      if (spvIsExtendedInstruction(opcode) &&
           spvExtInstIsDebugInfo(inst->ext_inst_type)) {
         const uint32_t ext_inst_index = inst->words[kExtInstSetIndex];
         if (inst->ext_inst_type == SPV_EXT_INST_TYPE_OPENCL_DEBUGINFO_100) {
diff --git a/source/opt/liveness.cpp b/source/opt/liveness.cpp
index 336f3ae5..dae705dc 100644
--- a/source/opt/liveness.cpp
+++ b/source/opt/liveness.cpp
@@ -123,21 +123,29 @@ uint32_t LivenessManager::GetLocSize(const analysis::Type* type) const {
   return 1;
 }
 
-const analysis::Type* LivenessManager::GetComponentType(
-    uint32_t index, const analysis::Type* agg_type) const {
-  auto arr_type = agg_type->AsArray();
-  if (arr_type) return arr_type->element_type();
-  auto struct_type = agg_type->AsStruct();
-  if (struct_type) return struct_type->element_types()[index];
-  auto mat_type = agg_type->AsMatrix();
-  if (mat_type) return mat_type->element_type();
-  auto vec_type = agg_type->AsVector();
-  assert(vec_type && "unexpected non-aggregate type");
-  return vec_type->element_type();
+uint32_t LivenessManager::GetComponentType(uint32_t index,
+                                           uint32_t agg_type_id) const {
+  analysis::DefUseManager* def_use_mgr = context()->get_def_use_mgr();
+  Instruction* agg_type_inst = def_use_mgr->GetDef(agg_type_id);
+
+  const uint32_t kArrayElementInIdx = 0;
+  switch (agg_type_inst->opcode()) {
+    case spv::Op::OpTypeArray:
+    case spv::Op::OpTypeMatrix:
+    case spv::Op::OpTypeVector:
+      return agg_type_inst->GetSingleWordInOperand(kArrayElementInIdx);
+    case spv::Op::OpTypeStruct:
+      return agg_type_inst->GetSingleWordInOperand(index);
+    default:
+      assert(false && "unexpected aggregate type");
+      return 0;
+  }
 }
 
 uint32_t LivenessManager::GetLocOffset(uint32_t index,
-                                       const analysis::Type* agg_type) const {
+                                       uint32_t agg_type_id) const {
+  analysis::TypeManager* type_mgr = context()->get_type_mgr();
+  const analysis::Type* agg_type = type_mgr->GetType(agg_type_id);
   auto arr_type = agg_type->AsArray();
   if (arr_type) return index * GetLocSize(arr_type->element_type());
   auto struct_type = agg_type->AsStruct();
@@ -161,12 +169,11 @@ uint32_t LivenessManager::GetLocOffset(uint32_t index,
   return 0;
 }
 
-void LivenessManager::AnalyzeAccessChainLoc(const Instruction* ac,
-                                            const analysis::Type** curr_type,
-                                            uint32_t* offset, bool* no_loc,
-                                            bool is_patch, bool input) {
+uint32_t LivenessManager::AnalyzeAccessChainLoc(const Instruction* ac,
+                                                uint32_t curr_type_id,
+                                                uint32_t* offset, bool* no_loc,
+                                                bool is_patch, bool input) {
   analysis::DefUseManager* def_use_mgr = context()->get_def_use_mgr();
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
   analysis::DecorationManager* deco_mgr = context()->get_decoration_mgr();
   // For tesc, tese and geom input variables, and tesc output variables,
   // first array index does not contribute to offset.
@@ -178,15 +185,18 @@ void LivenessManager::AnalyzeAccessChainLoc(const Instruction* ac,
       (!input && stage == spv::ExecutionModel::TessellationControl))
     skip_first_index = !is_patch;
   uint32_t ocnt = 0;
-  ac->WhileEachInOperand([this, &ocnt, def_use_mgr, type_mgr, deco_mgr,
-                          curr_type, offset, no_loc,
+  ac->WhileEachInOperand([this, &ocnt, def_use_mgr, deco_mgr, &curr_type_id,
+                          offset, no_loc,
                           skip_first_index](const uint32_t* opnd) {
     if (ocnt >= 1) {
       // Skip first index's contribution to offset if indicated
+      Instruction* curr_type_inst = def_use_mgr->GetDef(curr_type_id);
       if (ocnt == 1 && skip_first_index) {
-        auto arr_type = (*curr_type)->AsArray();
-        assert(arr_type && "unexpected wrapper type");
-        *curr_type = arr_type->element_type();
+        assert(curr_type_inst->opcode() == spv::Op::OpTypeArray &&
+               "unexpected wrapper type");
+        const uint32_t kArrayElementTypeInIdx = 0;
+        curr_type_id =
+            curr_type_inst->GetSingleWordInOperand(kArrayElementTypeInIdx);
         ocnt++;
         return true;
       }
@@ -196,12 +206,10 @@ void LivenessManager::AnalyzeAccessChainLoc(const Instruction* ac,
       // If current type is struct, look for location decoration on member and
       // reset offset if found.
       auto index = idx_inst->GetSingleWordInOperand(0);
-      auto str_type = (*curr_type)->AsStruct();
-      if (str_type) {
+      if (curr_type_inst->opcode() == spv::Op::OpTypeStruct) {
         uint32_t loc = 0;
-        auto str_type_id = type_mgr->GetId(str_type);
         bool no_mem_loc = deco_mgr->WhileEachDecoration(
-            str_type_id, uint32_t(spv::Decoration::Location),
+            curr_type_id, uint32_t(spv::Decoration::Location),
             [&loc, index, no_loc](const Instruction& deco) {
               assert(deco.opcode() == spv::Op::OpMemberDecorate &&
                      "unexpected decoration");
@@ -216,19 +224,20 @@ void LivenessManager::AnalyzeAccessChainLoc(const Instruction* ac,
             });
         if (!no_mem_loc) {
           *offset = loc;
-          *curr_type = GetComponentType(index, *curr_type);
+          curr_type_id = curr_type_inst->GetSingleWordInOperand(index);
           ocnt++;
           return true;
         }
       }
 
       // Update offset and current type based on constant index.
-      *offset += GetLocOffset(index, *curr_type);
-      *curr_type = GetComponentType(index, *curr_type);
+      *offset += GetLocOffset(index, curr_type_id);
+      curr_type_id = GetComponentType(index, curr_type_id);
     }
     ocnt++;
     return true;
   });
+  return curr_type_id;
 }
 
 void LivenessManager::MarkRefLive(const Instruction* ref, Instruction* var) {
@@ -268,8 +277,15 @@ void LivenessManager::MarkRefLive(const Instruction* ref, Instruction* var) {
   // through constant indices and mark those locs live. Assert if no location
   // found.
   uint32_t offset = loc;
-  auto curr_type = var_type;
-  AnalyzeAccessChainLoc(ref, &curr_type, &offset, &no_loc, is_patch);
+  Instruction* ptr_type_inst =
+      context()->get_def_use_mgr()->GetDef(var->type_id());
+  assert(ptr_type && "unexpected var type");
+  const uint32_t kPointerTypePointeeIdx = 1;
+  uint32_t var_type_id =
+      ptr_type_inst->GetSingleWordInOperand(kPointerTypePointeeIdx);
+  uint32_t curr_type_id =
+      AnalyzeAccessChainLoc(ref, var_type_id, &offset, &no_loc, is_patch);
+  auto curr_type = type_mgr->GetType(curr_type_id);
   assert(!no_loc && "missing input variable location");
   MarkLocsLive(offset, GetLocSize(curr_type));
 }
@@ -277,15 +293,18 @@ void LivenessManager::MarkRefLive(const Instruction* ref, Instruction* var) {
 void LivenessManager::ComputeLiveness() {
   InitializeAnalysis();
   analysis::DefUseManager* def_use_mgr = context()->get_def_use_mgr();
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
   // Process all input variables
   for (auto& var : context()->types_values()) {
     if (var.opcode() != spv::Op::OpVariable) {
       continue;
     }
-    analysis::Type* var_type = type_mgr->GetType(var.type_id());
-    analysis::Pointer* ptr_type = var_type->AsPointer();
-    if (ptr_type->storage_class() != spv::StorageClass::Input) {
+    Instruction* var_type_inst = def_use_mgr->GetDef(var.type_id());
+    assert(var_type_inst->opcode() == spv::Op::OpTypePointer &&
+           "Expected a pointer type");
+    const uint32_t kPointerTypeStorageClassInIdx = 0;
+    spv::StorageClass sc = static_cast<spv::StorageClass>(
+        var_type_inst->GetSingleWordInOperand(kPointerTypeStorageClassInIdx));
+    if (sc != spv::StorageClass::Input) {
       continue;
     }
     // If var is builtin, mark live if analyzed and continue to next variable
@@ -295,14 +314,15 @@ void LivenessManager::ComputeLiveness() {
     // continue to next variable. Input interface blocks will only appear
     // in tesc, tese and geom shaders. Will need to strip off one level of
     // arrayness to get to block type.
-    auto pte_type = ptr_type->pointee_type();
-    auto arr_type = pte_type->AsArray();
-    if (arr_type) {
-      auto elt_type = arr_type->element_type();
-      auto str_type = elt_type->AsStruct();
-      if (str_type) {
-        auto str_type_id = type_mgr->GetId(str_type);
-        if (AnalyzeBuiltIn(str_type_id)) continue;
+    const uint32_t kPointerTypePointeeTypeInIdx = 1;
+    uint32_t pte_type_id =
+        var_type_inst->GetSingleWordInOperand(kPointerTypePointeeTypeInIdx);
+    Instruction* pte_type_inst = def_use_mgr->GetDef(pte_type_id);
+    if (pte_type_inst->opcode() == spv::Op::OpTypeArray) {
+      uint32_t array_elt_type_id = pte_type_inst->GetSingleWordInOperand(0);
+      Instruction* arr_elt_type = def_use_mgr->GetDef(array_elt_type_id);
+      if (arr_elt_type->opcode() == spv::Op::OpTypeStruct) {
+        if (AnalyzeBuiltIn(array_elt_type_id)) continue;
       }
     }
     // Mark all used locations of var live
diff --git a/source/opt/liveness.h b/source/opt/liveness.h
index 7d8a9fb4..70500059 100644
--- a/source/opt/liveness.h
+++ b/source/opt/liveness.h
@@ -41,13 +41,13 @@ class LivenessManager {
   // Return true if builtin |bi| is being analyzed.
   bool IsAnalyzedBuiltin(uint32_t bi);
 
-  // Determine starting loc |offset| and the type |cur_type| of
-  // access chain |ac|. Set |no_loc| to true if no loc found.
-  // |is_patch| indicates if patch variable. |input| is true
-  // if input variable, otherwise output variable.
-  void AnalyzeAccessChainLoc(const Instruction* ac,
-                             const analysis::Type** curr_type, uint32_t* offset,
-                             bool* no_loc, bool is_patch, bool input = true);
+  // Return the result type of |ac| when applied to |cur_type_id|. Set
+  // |no_loc| to true if no loc found. Set |is_patch| indicates if the variable
+  // is a patch variable. Set |input| if the variable is an input variable.
+  // Otherwise it is assumed that the variable is an output variable.
+  uint32_t AnalyzeAccessChainLoc(const Instruction* ac, uint32_t curr_type_id,
+                                 uint32_t* offset, bool* no_loc, bool is_patch,
+                                 bool input = true);
 
   // Return size of |type_id| in units of locations
   uint32_t GetLocSize(const analysis::Type* type) const;
@@ -68,13 +68,12 @@ class LivenessManager {
   // Mark |count| locations starting at location |start|.
   void MarkLocsLive(uint32_t start, uint32_t count);
 
-  // Return type of component of aggregate type |agg_type| at |index|
-  const analysis::Type* GetComponentType(uint32_t index,
-                                         const analysis::Type* agg_type) const;
+  // Return type of the member |index| in the aggregate type |agg_type_id|.
+  uint32_t GetComponentType(uint32_t index, uint32_t agg_type_id) const;
 
-  // Return offset of |index| into aggregate type |agg_type| in units of
-  // input locations
-  uint32_t GetLocOffset(uint32_t index, const analysis::Type* agg_type) const;
+  // Return offset of member |index| in the aggregate type |agg_type_id| in
+  // units of input locations.
+  uint32_t GetLocOffset(uint32_t index, uint32_t agg_type_id) const;
 
   // Populate live_locs_ and live_builtins_
   void ComputeLiveness();
diff --git a/source/opt/local_access_chain_convert_pass.cpp b/source/opt/local_access_chain_convert_pass.cpp
index 7ba75cb7..91ea7c69 100644
--- a/source/opt/local_access_chain_convert_pass.cpp
+++ b/source/opt/local_access_chain_convert_pass.cpp
@@ -429,7 +429,9 @@ void LocalAccessChainConvertPass::InitExtensions() {
        "SPV_KHR_fragment_shader_barycentric", "SPV_KHR_vulkan_memory_model",
        "SPV_NV_bindless_texture", "SPV_EXT_shader_atomic_float_add",
        "SPV_EXT_fragment_shader_interlock",
-       "SPV_NV_compute_shader_derivatives"});
+       "SPV_KHR_compute_shader_derivatives", "SPV_NV_cooperative_matrix",
+       "SPV_KHR_cooperative_matrix", "SPV_KHR_ray_tracing_position_fetch",
+       "SPV_KHR_fragment_shading_rate"});
 }
 
 bool LocalAccessChainConvertPass::AnyIndexIsOutOfBounds(
diff --git a/source/opt/local_single_block_elim_pass.cpp b/source/opt/local_single_block_elim_pass.cpp
index d7a9295e..f9c5a797 100644
--- a/source/opt/local_single_block_elim_pass.cpp
+++ b/source/opt/local_single_block_elim_pass.cpp
@@ -291,7 +291,11 @@ void LocalSingleBlockLoadStoreElimPass::InitExtensions() {
                                 "SPV_NV_bindless_texture",
                                 "SPV_EXT_shader_atomic_float_add",
                                 "SPV_EXT_fragment_shader_interlock",
-                                "SPV_NV_compute_shader_derivatives"});
+                                "SPV_KHR_compute_shader_derivatives",
+                                "SPV_NV_cooperative_matrix",
+                                "SPV_KHR_cooperative_matrix",
+                                "SPV_KHR_ray_tracing_position_fetch",
+                                "SPV_KHR_fragment_shading_rate"});
 }
 
 }  // namespace opt
diff --git a/source/opt/local_single_store_elim_pass.cpp b/source/opt/local_single_store_elim_pass.cpp
index 7cd6b0eb..38fa14ef 100644
--- a/source/opt/local_single_store_elim_pass.cpp
+++ b/source/opt/local_single_store_elim_pass.cpp
@@ -141,7 +141,11 @@ void LocalSingleStoreElimPass::InitExtensionAllowList() {
                                 "SPV_NV_bindless_texture",
                                 "SPV_EXT_shader_atomic_float_add",
                                 "SPV_EXT_fragment_shader_interlock",
-                                "SPV_NV_compute_shader_derivatives"});
+                                "SPV_KHR_compute_shader_derivatives",
+                                "SPV_NV_cooperative_matrix",
+                                "SPV_KHR_cooperative_matrix",
+                                "SPV_KHR_ray_tracing_position_fetch",
+                                "SPV_KHR_fragment_shading_rate"});
 }
 bool LocalSingleStoreElimPass::ProcessVariable(Instruction* var_inst) {
   std::vector<Instruction*> users;
diff --git a/source/opt/loop_fission.cpp b/source/opt/loop_fission.cpp
index 2ae05c3c..1bbe4baa 100644
--- a/source/opt/loop_fission.cpp
+++ b/source/opt/loop_fission.cpp
@@ -499,6 +499,7 @@ Pass::Status LoopFissionPass::Process() {
       // next iteration.
       if (split_multiple_times_) {
         inner_most_loops = std::move(new_loops_to_split);
+        new_loops_to_split = {};
       } else {
         break;
       }
diff --git a/source/opt/mem_pass.cpp b/source/opt/mem_pass.cpp
index 9972c4f7..65f45ec3 100644
--- a/source/opt/mem_pass.cpp
+++ b/source/opt/mem_pass.cpp
@@ -43,6 +43,8 @@ bool MemPass::IsBaseTargetType(const Instruction* typeInst) const {
     case spv::Op::OpTypeSampler:
     case spv::Op::OpTypeSampledImage:
     case spv::Op::OpTypePointer:
+    case spv::Op::OpTypeCooperativeMatrixNV:
+    case spv::Op::OpTypeCooperativeMatrixKHR:
       return true;
     default:
       break;
@@ -413,6 +415,7 @@ void MemPass::RemoveBlock(Function::iterator* bi) {
 }
 
 bool MemPass::RemoveUnreachableBlocks(Function* func) {
+  if (func->IsDeclaration()) return false;
   bool modified = false;
 
   // Mark reachable all blocks reachable from the function's entry block.
diff --git a/source/opt/opextinst_forward_ref_fixup_pass.cpp b/source/opt/opextinst_forward_ref_fixup_pass.cpp
new file mode 100644
index 00000000..8684feb4
--- /dev/null
+++ b/source/opt/opextinst_forward_ref_fixup_pass.cpp
@@ -0,0 +1,112 @@
+// Copyright (c) 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "source/opt/opextinst_forward_ref_fixup_pass.h"
+
+#include <string>
+#include <unordered_set>
+
+#include "source/extensions.h"
+#include "source/opt/ir_context.h"
+#include "source/opt/module.h"
+#include "type_manager.h"
+
+namespace spvtools {
+namespace opt {
+namespace {
+
+// Returns true if the instruction |inst| has a forward reference to another
+// debug instruction.
+// |debug_ids| contains the list of IDs belonging to debug instructions.
+// |seen_ids| contains the list of IDs already seen.
+bool HasForwardReference(const Instruction& inst,
+                         const std::unordered_set<uint32_t>& debug_ids,
+                         const std::unordered_set<uint32_t>& seen_ids) {
+  const uint32_t num_in_operands = inst.NumInOperands();
+  for (uint32_t i = 0; i < num_in_operands; ++i) {
+    const Operand& op = inst.GetInOperand(i);
+    if (!spvIsIdType(op.type)) continue;
+
+    if (debug_ids.count(op.AsId()) == 0) continue;
+
+    if (seen_ids.count(op.AsId()) == 0) return true;
+  }
+
+  return false;
+}
+
+// Replace |inst| opcode with OpExtInstWithForwardRefsKHR or OpExtInst
+// if required to comply with forward references.
+bool ReplaceOpcodeIfRequired(Instruction& inst, bool hasForwardReferences) {
+  if (hasForwardReferences &&
+      inst.opcode() != spv::Op::OpExtInstWithForwardRefsKHR)
+    inst.SetOpcode(spv::Op::OpExtInstWithForwardRefsKHR);
+  else if (!hasForwardReferences && inst.opcode() != spv::Op::OpExtInst)
+    inst.SetOpcode(spv::Op::OpExtInst);
+  else
+    return false;
+  return true;
+}
+
+// Returns all the result IDs of the instructions in |range|.
+std::unordered_set<uint32_t> gatherResultIds(
+    const IteratorRange<Module::inst_iterator>& range) {
+  std::unordered_set<uint32_t> output;
+  for (const auto& it : range) output.insert(it.result_id());
+  return output;
+}
+
+}  // namespace
+
+Pass::Status OpExtInstWithForwardReferenceFixupPass::Process() {
+  std::unordered_set<uint32_t> seen_ids =
+      gatherResultIds(get_module()->ext_inst_imports());
+  std::unordered_set<uint32_t> debug_ids =
+      gatherResultIds(get_module()->ext_inst_debuginfo());
+  for (uint32_t id : seen_ids) debug_ids.insert(id);
+
+  bool moduleChanged = false;
+  bool hasAtLeastOneForwardReference = false;
+  IRContext* ctx = context();
+  for (Instruction& inst : get_module()->ext_inst_debuginfo()) {
+    if (inst.opcode() != spv::Op::OpExtInst &&
+        inst.opcode() != spv::Op::OpExtInstWithForwardRefsKHR)
+      continue;
+
+    seen_ids.insert(inst.result_id());
+    bool hasForwardReferences = HasForwardReference(inst, debug_ids, seen_ids);
+    hasAtLeastOneForwardReference |= hasForwardReferences;
+
+    if (ReplaceOpcodeIfRequired(inst, hasForwardReferences)) {
+      moduleChanged = true;
+      ctx->AnalyzeUses(&inst);
+    }
+  }
+
+  if (hasAtLeastOneForwardReference !=
+      ctx->get_feature_mgr()->HasExtension(
+          kSPV_KHR_relaxed_extended_instruction)) {
+    if (hasAtLeastOneForwardReference)
+      ctx->AddExtension("SPV_KHR_relaxed_extended_instruction");
+    else
+      ctx->RemoveExtension(Extension::kSPV_KHR_relaxed_extended_instruction);
+    moduleChanged = true;
+  }
+
+  return moduleChanged ? Status::SuccessWithChange
+                       : Status::SuccessWithoutChange;
+}
+
+}  // namespace opt
+}  // namespace spvtools
diff --git a/source/opt/opextinst_forward_ref_fixup_pass.h b/source/opt/opextinst_forward_ref_fixup_pass.h
new file mode 100644
index 00000000..26e5b81c
--- /dev/null
+++ b/source/opt/opextinst_forward_ref_fixup_pass.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SOURCE_OPT_OPEXTINST_FORWARD_REF_FIXUP_H
+#define SOURCE_OPT_OPEXTINST_FORWARD_REF_FIXUP_H
+
+#include "source/opt/ir_context.h"
+#include "source/opt/module.h"
+#include "source/opt/pass.h"
+
+namespace spvtools {
+namespace opt {
+
+class OpExtInstWithForwardReferenceFixupPass : public Pass {
+ public:
+  const char* name() const override { return "fix-opextinst-opcodes"; }
+  Status Process() override;
+
+  IRContext::Analysis GetPreservedAnalyses() override {
+    return IRContext::kAnalysisInstrToBlockMapping |
+           IRContext::kAnalysisDecorations | IRContext::kAnalysisCombinators |
+           IRContext::kAnalysisCFG | IRContext::kAnalysisDominatorAnalysis |
+           IRContext::kAnalysisLoopAnalysis | IRContext::kAnalysisNameMap |
+           IRContext::kAnalysisScalarEvolution |
+           IRContext::kAnalysisRegisterPressure |
+           IRContext::kAnalysisValueNumberTable |
+           IRContext::kAnalysisStructuredCFG |
+           IRContext::kAnalysisBuiltinVarId |
+           IRContext::kAnalysisIdToFuncMapping | IRContext::kAnalysisTypes |
+           IRContext::kAnalysisDefUse | IRContext::kAnalysisConstants;
+  }
+};
+
+}  // namespace opt
+}  // namespace spvtools
+
+#endif  // SOURCE_OPT_OPEXTINST_FORWARD_REF_FIXUP_H
diff --git a/source/opt/optimizer.cpp b/source/opt/optimizer.cpp
index 429a6cba..94b15c6a 100644
--- a/source/opt/optimizer.cpp
+++ b/source/opt/optimizer.cpp
@@ -167,8 +167,10 @@ Optimizer& Optimizer::RegisterLegalizationPasses(bool preserve_interface) {
           .RegisterPass(CreateDeadInsertElimPass())
           .RegisterPass(CreateReduceLoadSizePass())
           .RegisterPass(CreateAggressiveDCEPass(preserve_interface))
+          .RegisterPass(CreateRemoveUnusedInterfaceVariablesPass())
           .RegisterPass(CreateInterpolateFixupPass())
-          .RegisterPass(CreateInvocationInterlockPlacementPass());
+          .RegisterPass(CreateInvocationInterlockPlacementPass())
+          .RegisterPass(CreateOpExtInstWithForwardReferenceFixupPass());
 }
 
 Optimizer& Optimizer::RegisterLegalizationPasses() {
@@ -322,6 +324,8 @@ bool Optimizer::RegisterPassFromFlag(const std::string& flag,
     RegisterPass(CreateStripReflectInfoPass());
   } else if (pass_name == "strip-nonsemantic") {
     RegisterPass(CreateStripNonSemanticInfoPass());
+  } else if (pass_name == "fix-opextinst-opcodes") {
+    RegisterPass(CreateOpExtInstWithForwardReferenceFixupPass());
   } else if (pass_name == "set-spec-const-default-value") {
     if (pass_args.size() > 0) {
       auto spec_ids_vals =
@@ -360,6 +364,10 @@ bool Optimizer::RegisterPassFromFlag(const std::string& flag,
     RegisterPass(CreateSpreadVolatileSemanticsPass());
   } else if (pass_name == "descriptor-scalar-replacement") {
     RegisterPass(CreateDescriptorScalarReplacementPass());
+  } else if (pass_name == "descriptor-composite-scalar-replacement") {
+    RegisterPass(CreateDescriptorCompositeScalarReplacementPass());
+  } else if (pass_name == "descriptor-array-scalar-replacement") {
+    RegisterPass(CreateDescriptorArrayScalarReplacementPass());
   } else if (pass_name == "eliminate-dead-code-aggressive") {
     RegisterPass(CreateAggressiveDCEPass(preserve_interface));
   } else if (pass_name == "eliminate-insert-extract") {
@@ -450,27 +458,10 @@ bool Optimizer::RegisterPassFromFlag(const std::string& flag,
     RegisterPass(CreateWorkaround1209Pass());
   } else if (pass_name == "replace-invalid-opcode") {
     RegisterPass(CreateReplaceInvalidOpcodePass());
-  } else if (pass_name == "inst-bindless-check" ||
-             pass_name == "inst-desc-idx-check" ||
-             pass_name == "inst-buff-oob-check") {
-    // preserve legacy names
-    RegisterPass(CreateInstBindlessCheckPass(23));
-    RegisterPass(CreateSimplificationPass());
-    RegisterPass(CreateDeadBranchElimPass());
-    RegisterPass(CreateBlockMergePass());
-  } else if (pass_name == "inst-buff-addr-check") {
-    RegisterPass(CreateInstBuffAddrCheckPass(23));
   } else if (pass_name == "convert-relaxed-to-half") {
     RegisterPass(CreateConvertRelaxedToHalfPass());
   } else if (pass_name == "relax-float-ops") {
     RegisterPass(CreateRelaxFloatOpsPass());
-  } else if (pass_name == "inst-debug-printf") {
-    // This private option is not for user consumption.
-    // It is here to assist in debugging and fixing the debug printf
-    // instrumentation pass.
-    // For users who wish to utilize debug printf, see the white paper at
-    // https://www.lunarg.com/wp-content/uploads/2021/08/Using-Debug-Printf-02August2021.pdf
-    RegisterPass(CreateInstDebugPrintfPass(7, 23));
   } else if (pass_name == "simplify-instructions") {
     RegisterPass(CreateSimplificationPass());
   } else if (pass_name == "ssa-rewrite") {
@@ -573,6 +564,26 @@ bool Optimizer::RegisterPassFromFlag(const std::string& flag,
              pass_args.c_str());
       return false;
     }
+  } else if (pass_name == "struct-packing") {
+    if (pass_args.size() == 0) {
+      Error(consumer(), nullptr, {},
+            "--struct-packing requires a name:rule argument.");
+      return false;
+    }
+
+    auto separator_pos = pass_args.find(':');
+    if (separator_pos == std::string::npos || separator_pos == 0 ||
+        separator_pos + 1 == pass_args.size()) {
+      Errorf(consumer(), nullptr, {},
+             "Invalid argument for --struct-packing: %s", pass_args.c_str());
+      return false;
+    }
+
+    const std::string struct_name = pass_args.substr(0, separator_pos);
+    const std::string rule_name = pass_args.substr(separator_pos + 1);
+
+    RegisterPass(
+        CreateStructPackingPass(struct_name.c_str(), rule_name.c_str()));
   } else if (pass_name == "switch-descriptorset") {
     if (pass_args.size() == 0) {
       Error(consumer(), nullptr, {},
@@ -1022,22 +1033,6 @@ Optimizer::PassToken CreateUpgradeMemoryModelPass() {
       MakeUnique<opt::UpgradeMemoryModel>());
 }
 
-Optimizer::PassToken CreateInstBindlessCheckPass(uint32_t shader_id) {
-  return MakeUnique<Optimizer::PassToken::Impl>(
-      MakeUnique<opt::InstBindlessCheckPass>(shader_id));
-}
-
-Optimizer::PassToken CreateInstDebugPrintfPass(uint32_t desc_set,
-                                               uint32_t shader_id) {
-  return MakeUnique<Optimizer::PassToken::Impl>(
-      MakeUnique<opt::InstDebugPrintfPass>(desc_set, shader_id));
-}
-
-Optimizer::PassToken CreateInstBuffAddrCheckPass(uint32_t shader_id) {
-  return MakeUnique<Optimizer::PassToken::Impl>(
-      MakeUnique<opt::InstBuffAddrCheckPass>(shader_id));
-}
-
 Optimizer::PassToken CreateConvertRelaxedToHalfPass() {
   return MakeUnique<Optimizer::PassToken::Impl>(
       MakeUnique<opt::ConvertToHalfPass>());
@@ -1075,7 +1070,20 @@ Optimizer::PassToken CreateSpreadVolatileSemanticsPass() {
 
 Optimizer::PassToken CreateDescriptorScalarReplacementPass() {
   return MakeUnique<Optimizer::PassToken::Impl>(
-      MakeUnique<opt::DescriptorScalarReplacement>());
+      MakeUnique<opt::DescriptorScalarReplacement>(
+          /* flatten_composites= */ true, /* flatten_arrays= */ true));
+}
+
+Optimizer::PassToken CreateDescriptorCompositeScalarReplacementPass() {
+  return MakeUnique<Optimizer::PassToken::Impl>(
+      MakeUnique<opt::DescriptorScalarReplacement>(
+          /* flatten_composites= */ true, /* flatten_arrays= */ false));
+}
+
+Optimizer::PassToken CreateDescriptorArrayScalarReplacementPass() {
+  return MakeUnique<Optimizer::PassToken::Impl>(
+      MakeUnique<opt::DescriptorScalarReplacement>(
+          /* flatten_composites= */ false, /* flatten_arrays= */ true));
 }
 
 Optimizer::PassToken CreateWrapOpKillPass() {
@@ -1151,6 +1159,14 @@ Optimizer::PassToken CreateTrimCapabilitiesPass() {
       MakeUnique<opt::TrimCapabilitiesPass>());
 }
 
+Optimizer::PassToken CreateStructPackingPass(const char* structToPack,
+                                             const char* packingRule) {
+  return MakeUnique<Optimizer::PassToken::Impl>(
+      MakeUnique<opt::StructPackingPass>(
+          structToPack,
+          opt::StructPackingPass::ParsePackingRuleFromString(packingRule)));
+}
+
 Optimizer::PassToken CreateSwitchDescriptorSetPass(uint32_t from, uint32_t to) {
   return MakeUnique<Optimizer::PassToken::Impl>(
       MakeUnique<opt::SwitchDescriptorSetPass>(from, to));
@@ -1165,6 +1181,12 @@ Optimizer::PassToken CreateModifyMaximalReconvergencePass(bool add) {
   return MakeUnique<Optimizer::PassToken::Impl>(
       MakeUnique<opt::ModifyMaximalReconvergence>(add));
 }
+
+Optimizer::PassToken CreateOpExtInstWithForwardReferenceFixupPass() {
+  return MakeUnique<Optimizer::PassToken::Impl>(
+      MakeUnique<opt::OpExtInstWithForwardReferenceFixupPass>());
+}
+
 }  // namespace spvtools
 
 extern "C" {
diff --git a/source/opt/pass.cpp b/source/opt/pass.cpp
index 75c37407..0f260e2e 100644
--- a/source/opt/pass.cpp
+++ b/source/opt/pass.cpp
@@ -83,7 +83,6 @@ uint32_t Pass::GetNullId(uint32_t type_id) {
 
 uint32_t Pass::GenerateCopy(Instruction* object_to_copy, uint32_t new_type_id,
                             Instruction* insertion_position) {
-  analysis::TypeManager* type_mgr = context()->get_type_mgr();
   analysis::ConstantManager* const_mgr = context()->get_constant_mgr();
 
   uint32_t original_type_id = object_to_copy->type_id();
@@ -95,57 +94,63 @@ uint32_t Pass::GenerateCopy(Instruction* object_to_copy, uint32_t new_type_id,
       context(), insertion_position,
       IRContext::kAnalysisInstrToBlockMapping | IRContext::kAnalysisDefUse);
 
-  analysis::Type* original_type = type_mgr->GetType(original_type_id);
-  analysis::Type* new_type = type_mgr->GetType(new_type_id);
-
-  if (const analysis::Array* original_array_type = original_type->AsArray()) {
-    uint32_t original_element_type_id =
-        type_mgr->GetId(original_array_type->element_type());
-
-    analysis::Array* new_array_type = new_type->AsArray();
-    assert(new_array_type != nullptr && "Can't copy an array to a non-array.");
-    uint32_t new_element_type_id =
-        type_mgr->GetId(new_array_type->element_type());
-
-    std::vector<uint32_t> element_ids;
-    const analysis::Constant* length_const =
-        const_mgr->FindDeclaredConstant(original_array_type->LengthId());
-    assert(length_const->AsIntConstant());
-    uint32_t array_length = length_const->AsIntConstant()->GetU32();
-    for (uint32_t i = 0; i < array_length; i++) {
-      Instruction* extract = ir_builder.AddCompositeExtract(
-          original_element_type_id, object_to_copy->result_id(), {i});
-      element_ids.push_back(
-          GenerateCopy(extract, new_element_type_id, insertion_position));
-    }
+  Instruction* original_type = get_def_use_mgr()->GetDef(original_type_id);
+  Instruction* new_type = get_def_use_mgr()->GetDef(new_type_id);
 
-    return ir_builder.AddCompositeConstruct(new_type_id, element_ids)
-        ->result_id();
-  } else if (const analysis::Struct* original_struct_type =
-                 original_type->AsStruct()) {
-    analysis::Struct* new_struct_type = new_type->AsStruct();
-
-    const std::vector<const analysis::Type*>& original_types =
-        original_struct_type->element_types();
-    const std::vector<const analysis::Type*>& new_types =
-        new_struct_type->element_types();
-    std::vector<uint32_t> element_ids;
-    for (uint32_t i = 0; i < original_types.size(); i++) {
-      Instruction* extract = ir_builder.AddCompositeExtract(
-          type_mgr->GetId(original_types[i]), object_to_copy->result_id(), {i});
-      element_ids.push_back(GenerateCopy(extract, type_mgr->GetId(new_types[i]),
-                                         insertion_position));
+  if (new_type->opcode() != original_type->opcode()) {
+    return 0;
+  }
+
+  switch (original_type->opcode()) {
+    case spv::Op::OpTypeArray: {
+      uint32_t original_element_type_id =
+          original_type->GetSingleWordInOperand(0);
+      uint32_t new_element_type_id = new_type->GetSingleWordInOperand(0);
+
+      std::vector<uint32_t> element_ids;
+      uint32_t length_id = original_type->GetSingleWordInOperand(1);
+      const analysis::Constant* length_const =
+          const_mgr->FindDeclaredConstant(length_id);
+      assert(length_const->AsIntConstant());
+      uint32_t array_length = length_const->AsIntConstant()->GetU32();
+      for (uint32_t i = 0; i < array_length; i++) {
+        Instruction* extract = ir_builder.AddCompositeExtract(
+            original_element_type_id, object_to_copy->result_id(), {i});
+        uint32_t new_id =
+            GenerateCopy(extract, new_element_type_id, insertion_position);
+        if (new_id == 0) {
+          return 0;
+        }
+        element_ids.push_back(new_id);
+      }
+
+      return ir_builder.AddCompositeConstruct(new_type_id, element_ids)
+          ->result_id();
+    }
+    case spv::Op::OpTypeStruct: {
+      std::vector<uint32_t> element_ids;
+      for (uint32_t i = 0; i < original_type->NumInOperands(); i++) {
+        uint32_t orig_member_type_id = original_type->GetSingleWordInOperand(i);
+        uint32_t new_member_type_id = new_type->GetSingleWordInOperand(i);
+        Instruction* extract = ir_builder.AddCompositeExtract(
+            orig_member_type_id, object_to_copy->result_id(), {i});
+        uint32_t new_id =
+            GenerateCopy(extract, new_member_type_id, insertion_position);
+        if (new_id == 0) {
+          return 0;
+        }
+        element_ids.push_back(new_id);
+      }
+      return ir_builder.AddCompositeConstruct(new_type_id, element_ids)
+          ->result_id();
     }
-    return ir_builder.AddCompositeConstruct(new_type_id, element_ids)
-        ->result_id();
-  } else {
-    // If we do not have an aggregate type, then we have a problem.  Either we
-    // found multiple instances of the same type, or we are copying to an
-    // incompatible type.  Either way the code is illegal.
-    assert(false &&
-           "Don't know how to copy this type.  Code is likely illegal.");
+    default:
+      // If we do not have an aggregate type, then we have a problem.  Either we
+      // found multiple instances of the same type, or we are copying to an
+      // incompatible type.  Either way the code is illegal. Leave the code as
+      // is and let the caller deal with it.
+      return 0;
   }
-  return 0;
 }
 
 }  // namespace opt
diff --git a/source/opt/pass.h b/source/opt/pass.h
index b2303e23..3e6c4d07 100644
--- a/source/opt/pass.h
+++ b/source/opt/pass.h
@@ -145,7 +145,8 @@ class Pass {
 
   // Returns the id whose value is the same as |object_to_copy| except its type
   // is |new_type_id|.  Any instructions needed to generate this value will be
-  // inserted before |insertion_position|.
+  // inserted before |insertion_position|. Returns 0 if a copy could not be
+  // done.
   uint32_t GenerateCopy(Instruction* object_to_copy, uint32_t new_type_id,
                         Instruction* insertion_position);
 
diff --git a/source/opt/passes.h b/source/opt/passes.h
index 9d027fbf..3311529a 100644
--- a/source/opt/passes.h
+++ b/source/opt/passes.h
@@ -48,9 +48,6 @@
 #include "source/opt/if_conversion.h"
 #include "source/opt/inline_exhaustive_pass.h"
 #include "source/opt/inline_opaque_pass.h"
-#include "source/opt/inst_bindless_check_pass.h"
-#include "source/opt/inst_buff_addr_check_pass.h"
-#include "source/opt/inst_debug_printf_pass.h"
 #include "source/opt/interface_var_sroa.h"
 #include "source/opt/interp_fixup_pass.h"
 #include "source/opt/invocation_interlock_placement_pass.h"
@@ -67,6 +64,7 @@
 #include "source/opt/merge_return_pass.h"
 #include "source/opt/modify_maximal_reconvergence.h"
 #include "source/opt/null_pass.h"
+#include "source/opt/opextinst_forward_ref_fixup_pass.h"
 #include "source/opt/private_to_local_pass.h"
 #include "source/opt/reduce_load_size.h"
 #include "source/opt/redundancy_elimination.h"
@@ -84,6 +82,7 @@
 #include "source/opt/strength_reduction_pass.h"
 #include "source/opt/strip_debug_info_pass.h"
 #include "source/opt/strip_nonsemantic_info_pass.h"
+#include "source/opt/struct_packing_pass.h"
 #include "source/opt/switch_descriptorset_pass.h"
 #include "source/opt/trim_capabilities_pass.h"
 #include "source/opt/unify_const_pass.h"
diff --git a/source/opt/remove_unused_interface_variables_pass.cpp b/source/opt/remove_unused_interface_variables_pass.cpp
index d4df1b2e..c3a4b775 100644
--- a/source/opt/remove_unused_interface_variables_pass.cpp
+++ b/source/opt/remove_unused_interface_variables_pass.cpp
@@ -21,6 +21,8 @@ class RemoveUnusedInterfaceVariablesContext {
   RemoveUnusedInterfaceVariablesPass& parent_;
   Instruction& entry_;
   std::unordered_set<uint32_t> used_variables_;
+  std::vector<uint32_t> operands_to_add_;
+
   IRContext::ProcessFunction pfn_ =
       std::bind(&RemoveUnusedInterfaceVariablesContext::processFunction, this,
                 std::placeholders::_1);
@@ -38,8 +40,10 @@ class RemoveUnusedInterfaceVariablesContext {
               (parent_.get_module()->version() >=
                    SPV_SPIRV_VERSION_WORD(1, 4) ||
                storage_class == spv::StorageClass::Input ||
-               storage_class == spv::StorageClass::Output))
+               storage_class == spv::StorageClass::Output)) {
             used_variables_.insert(*id);
+            operands_to_add_.push_back(*id);
+          }
         });
     return false;
   }
@@ -71,7 +75,7 @@ class RemoveUnusedInterfaceVariablesContext {
   void Modify() {
     for (int i = entry_.NumInOperands() - 1; i >= 3; --i)
       entry_.RemoveInOperand(i);
-    for (auto id : used_variables_) {
+    for (auto id : operands_to_add_) {
       entry_.AddOperand(Operand(SPV_OPERAND_TYPE_ID, {id}));
     }
   }
diff --git a/source/opt/strip_debug_info_pass.cpp b/source/opt/strip_debug_info_pass.cpp
index f81bced5..118d8465 100644
--- a/source/opt/strip_debug_info_pass.cpp
+++ b/source/opt/strip_debug_info_pass.cpp
@@ -43,7 +43,7 @@ Pass::Status StripDebugInfoPass::Process() {
           // see if this string is used anywhere by a non-semantic instruction
           bool no_nonsemantic_use =
               def_use->WhileEachUser(&inst, [def_use](Instruction* use) {
-                if (use->opcode() == spv::Op::OpExtInst) {
+                if (spvIsExtendedInstruction(use->opcode())) {
                   auto ext_inst_set =
                       def_use->GetDef(use->GetSingleWordInOperand(0u));
                   const std::string extension_name =
diff --git a/source/opt/strip_nonsemantic_info_pass.cpp b/source/opt/strip_nonsemantic_info_pass.cpp
index 3886835a..659849ef 100644
--- a/source/opt/strip_nonsemantic_info_pass.cpp
+++ b/source/opt/strip_nonsemantic_info_pass.cpp
@@ -96,7 +96,7 @@ Pass::Status StripNonSemanticInfoPass::Process() {
   if (!non_semantic_sets.empty()) {
     context()->module()->ForEachInst(
         [&non_semantic_sets, &to_remove](Instruction* inst) {
-          if (inst->opcode() == spv::Op::OpExtInst) {
+          if (spvIsExtendedInstruction(inst->opcode())) {
             if (non_semantic_sets.find(inst->GetSingleWordInOperand(0)) !=
                 non_semantic_sets.end()) {
               to_remove.push_back(inst);
diff --git a/source/opt/struct_packing_pass.cpp b/source/opt/struct_packing_pass.cpp
new file mode 100644
index 00000000..3bf2b2ab
--- /dev/null
+++ b/source/opt/struct_packing_pass.cpp
@@ -0,0 +1,482 @@
+// Copyright (c) 2024 Epic Games, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "struct_packing_pass.h"
+
+#include <algorithm>
+
+#include "source/opt/instruction.h"
+#include "source/opt/ir_context.h"
+
+namespace spvtools {
+namespace opt {
+
+/*
+Std140 packing rules from the original GLSL 140 specification (see
+https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt)
+
+When using the "std140" storage layout, structures will be laid out in
+buffer storage with its members stored in monotonically increasing order
+based on their location in the declaration. A structure and each
+structure member have a base offset and a base alignment, from which an
+aligned offset is computed by rounding the base offset up to a multiple of
+the base alignment. The base offset of the first member of a structure is
+taken from the aligned offset of the structure itself. The base offset of
+all other structure members is derived by taking the offset of the last
+basic machine unit consumed by the previous member and adding one. Each
+structure member is stored in memory at its aligned offset. The members
+of a top-level uniform block are laid out in buffer storage by treating
+the uniform block as a structure with a base offset of zero.
+
+(1) If the member is a scalar consuming <N> basic machine units, the
+    base alignment is <N>.
+
+(2) If the member is a two- or four-component vector with components
+    consuming <N> basic machine units, the base alignment is 2<N> or
+    4<N>, respectively.
+
+(3) If the member is a three-component vector with components consuming
+    <N> basic machine units, the base alignment is 4<N>.
+
+(4) If the member is an array of scalars or vectors, the base alignment
+    and array stride are set to match the base alignment of a single
+    array element, according to rules (1), (2), and (3), and rounded up
+    to the base alignment of a vec4. The array may have padding at the
+    end; the base offset of the member following the array is rounded up
+    to the next multiple of the base alignment.
+
+(5) If the member is a column-major matrix with <C> columns and <R>
+    rows, the matrix is stored identically to an array of <C> column
+    vectors with <R> components each, according to rule (4).
+
+(6) If the member is an array of <S> column-major matrices with <C>
+    columns and <R> rows, the matrix is stored identically to a row of
+    <S>*<C> column vectors with <R> components each, according to rule
+    (4).
+
+(7) If the member is a row-major matrix with <C> columns and <R> rows,
+    the matrix is stored identically to an array of <R> row vectors
+    with <C> components each, according to rule (4).
+
+(8) If the member is an array of <S> row-major matrices with <C> columns
+    and <R> rows, the matrix is stored identically to a row of <S>*<R>
+    row vectors with <C> components each, according to rule (4).
+
+(9) If the member is a structure, the base alignment of the structure is
+    <N>, where <N> is the largest base alignment value of any of its
+    members, and rounded up to the base alignment of a vec4. The
+    individual members of this sub-structure are then assigned offsets
+    by applying this set of rules recursively, where the base offset of
+    the first member of the sub-structure is equal to the aligned offset
+    of the structure. The structure may have padding at the end; the
+    base offset of the member following the sub-structure is rounded up
+    to the next multiple of the base alignment of the structure.
+
+(10) If the member is an array of <S> structures, the <S> elements of
+    the array are laid out in order, according to rule (9).
+*/
+
+static bool isPackingVec4Padded(StructPackingPass::PackingRules rules) {
+  switch (rules) {
+    case StructPackingPass::PackingRules::Std140:
+    case StructPackingPass::PackingRules::Std140EnhancedLayout:
+    case StructPackingPass::PackingRules::HlslCbuffer:
+    case StructPackingPass::PackingRules::HlslCbufferPackOffset:
+      return true;
+    default:
+      return false;
+  }
+}
+
+static bool isPackingScalar(StructPackingPass::PackingRules rules) {
+  switch (rules) {
+    case StructPackingPass::PackingRules::Scalar:
+    case StructPackingPass::PackingRules::ScalarEnhancedLayout:
+      return true;
+    default:
+      return false;
+  }
+}
+
+static bool isPackingHlsl(StructPackingPass::PackingRules rules) {
+  switch (rules) {
+    case StructPackingPass::PackingRules::HlslCbuffer:
+    case StructPackingPass::PackingRules::HlslCbufferPackOffset:
+      return true;
+    default:
+      return false;
+  }
+}
+
+static uint32_t getPackedBaseSize(const analysis::Type& type) {
+  switch (type.kind()) {
+    case analysis::Type::kBool:
+      return 1;
+    case analysis::Type::kInteger:
+      return type.AsInteger()->width() / 8;
+    case analysis::Type::kFloat:
+      return type.AsFloat()->width() / 8;
+    case analysis::Type::kVector:
+      return getPackedBaseSize(*type.AsVector()->element_type());
+    case analysis::Type::kMatrix:
+      return getPackedBaseSize(*type.AsMatrix()->element_type());
+    default:
+      break;  // we only expect bool, int, float, vec, and mat here
+  }
+  assert(0 && "Unrecognized type to get base size");
+  return 0;
+}
+
+static uint32_t getScalarElementCount(const analysis::Type& type) {
+  switch (type.kind()) {
+    case analysis::Type::kVector:
+      return type.AsVector()->element_count();
+    case analysis::Type::kMatrix:
+      return getScalarElementCount(*type.AsMatrix()->element_type());
+    case analysis::Type::kStruct:
+      assert(0 && "getScalarElementCount() does not recognized struct types");
+      return 0;
+    default:
+      return 1;
+  }
+}
+
+// Aligns the specified value to a multiple of alignment, whereas the
+// alignment must be a power-of-two.
+static uint32_t alignPow2(uint32_t value, uint32_t alignment) {
+  return (value + alignment - 1) & ~(alignment - 1);
+}
+
+void StructPackingPass::buildConstantsMap() {
+  constantsMap_.clear();
+  for (Instruction* instr : context()->module()->GetConstants()) {
+    constantsMap_[instr->result_id()] = instr;
+  }
+}
+
+uint32_t StructPackingPass::getPackedAlignment(
+    const analysis::Type& type) const {
+  switch (type.kind()) {
+    case analysis::Type::kArray: {
+      // Get alignment of base type and round up to minimum alignment
+      const uint32_t minAlignment = isPackingVec4Padded(packingRules_) ? 16 : 1;
+      return std::max<uint32_t>(
+          minAlignment, getPackedAlignment(*type.AsArray()->element_type()));
+    }
+    case analysis::Type::kStruct: {
+      // Rule 9. Struct alignment is maximum alignmnet of its members
+      uint32_t alignment = 1;
+
+      for (const analysis::Type* elementType :
+           type.AsStruct()->element_types()) {
+        alignment =
+            std::max<uint32_t>(alignment, getPackedAlignment(*elementType));
+      }
+
+      if (isPackingVec4Padded(packingRules_))
+        alignment = std::max<uint32_t>(alignment, 16u);
+
+      return alignment;
+    }
+    default: {
+      const uint32_t baseAlignment = getPackedBaseSize(type);
+
+      // Scalar block layout always uses alignment for the most basic component
+      if (isPackingScalar(packingRules_)) return baseAlignment;
+
+      if (const analysis::Matrix* matrixType = type.AsMatrix()) {
+        // Rule 5/7
+        if (isPackingVec4Padded(packingRules_) ||
+            matrixType->element_count() == 3)
+          return baseAlignment * 4;
+        else
+          return baseAlignment * matrixType->element_count();
+      } else if (const analysis::Vector* vectorType = type.AsVector()) {
+        // Rule 1
+        if (vectorType->element_count() == 1) return baseAlignment;
+
+        // Rule 2
+        if (vectorType->element_count() == 2 ||
+            vectorType->element_count() == 4)
+          return baseAlignment * vectorType->element_count();
+
+        // Rule 3
+        if (vectorType->element_count() == 3) return baseAlignment * 4;
+      } else {
+        // Rule 1
+        return baseAlignment;
+      }
+    }
+  }
+  assert(0 && "Unrecognized type to get packed alignment");
+  return 0;
+}
+
+static uint32_t getPadAlignment(const analysis::Type& type,
+                                uint32_t packedAlignment) {
+  // The next member following a struct member is aligned to the base alignment
+  // of a previous struct member.
+  return type.kind() == analysis::Type::kStruct ? packedAlignment : 1;
+}
+
+uint32_t StructPackingPass::getPackedSize(const analysis::Type& type) const {
+  switch (type.kind()) {
+    case analysis::Type::kArray: {
+      if (const analysis::Array* arrayType = type.AsArray()) {
+        uint32_t size =
+            getPackedArrayStride(*arrayType) * getArrayLength(*arrayType);
+
+        // For arrays of vector and matrices in HLSL, the last element has a
+        // size depending on its vector/matrix size to allow packing other
+        // vectors in the last element.
+        const analysis::Type* arraySubType = arrayType->element_type();
+        if (isPackingHlsl(packingRules_) &&
+            arraySubType->kind() != analysis::Type::kStruct) {
+          size -= (4 - getScalarElementCount(*arraySubType)) *
+                  getPackedBaseSize(*arraySubType);
+        }
+        return size;
+      }
+      break;
+    }
+    case analysis::Type::kStruct: {
+      uint32_t size = 0;
+      uint32_t padAlignment = 1;
+      for (const analysis::Type* memberType :
+           type.AsStruct()->element_types()) {
+        const uint32_t packedAlignment = getPackedAlignment(*memberType);
+        const uint32_t alignment =
+            std::max<uint32_t>(packedAlignment, padAlignment);
+        padAlignment = getPadAlignment(*memberType, packedAlignment);
+        size = alignPow2(size, alignment);
+        size += getPackedSize(*memberType);
+      }
+      return size;
+    }
+    default: {
+      const uint32_t baseAlignment = getPackedBaseSize(type);
+      if (isPackingScalar(packingRules_)) {
+        return getScalarElementCount(type) * baseAlignment;
+      } else {
+        uint32_t size = 0;
+        if (const analysis::Matrix* matrixType = type.AsMatrix()) {
+          const analysis::Vector* matrixSubType =
+              matrixType->element_type()->AsVector();
+          assert(matrixSubType != nullptr &&
+                 "Matrix sub-type is expected to be a vector type");
+          if (isPackingVec4Padded(packingRules_) ||
+              matrixType->element_count() == 3)
+            size = matrixSubType->element_count() * baseAlignment * 4;
+          else
+            size = matrixSubType->element_count() * baseAlignment *
+                   matrixType->element_count();
+
+          // For matrices in HLSL, the last element has a size depending on its
+          // vector size to allow packing other vectors in the last element.
+          if (isPackingHlsl(packingRules_)) {
+            size -= (4 - matrixSubType->element_count()) *
+                    getPackedBaseSize(*matrixSubType);
+          }
+        } else if (const analysis::Vector* vectorType = type.AsVector()) {
+          size = vectorType->element_count() * baseAlignment;
+        } else {
+          size = baseAlignment;
+        }
+        return size;
+      }
+    }
+  }
+  assert(0 && "Unrecognized type to get packed size");
+  return 0;
+}
+
+uint32_t StructPackingPass::getPackedArrayStride(
+    const analysis::Array& arrayType) const {
+  // Array stride is equal to aligned size of element type
+  const uint32_t elementSize = getPackedSize(*arrayType.element_type());
+  const uint32_t alignment = getPackedAlignment(arrayType);
+  return alignPow2(elementSize, alignment);
+}
+
+uint32_t StructPackingPass::getArrayLength(
+    const analysis::Array& arrayType) const {
+  return getConstantInt(arrayType.LengthId());
+}
+
+uint32_t StructPackingPass::getConstantInt(spv::Id id) const {
+  auto it = constantsMap_.find(id);
+  assert(it != constantsMap_.end() &&
+         "Failed to map SPIR-V instruction ID to constant value");
+  [[maybe_unused]] const analysis::Type* constType =
+      context()->get_type_mgr()->GetType(it->second->type_id());
+  assert(constType != nullptr &&
+         "Failed to map SPIR-V instruction result type to definition");
+  assert(constType->kind() == analysis::Type::kInteger &&
+         "Failed to map SPIR-V instruction result type to integer type");
+  return it->second->GetOperand(2).words[0];
+}
+
+StructPackingPass::PackingRules StructPackingPass::ParsePackingRuleFromString(
+    const std::string& s) {
+  if (s == "std140") return PackingRules::Std140;
+  if (s == "std140EnhancedLayout") return PackingRules::Std140EnhancedLayout;
+  if (s == "std430") return PackingRules::Std430;
+  if (s == "std430EnhancedLayout") return PackingRules::Std430EnhancedLayout;
+  if (s == "hlslCbuffer") return PackingRules::HlslCbuffer;
+  if (s == "hlslCbufferPackOffset") return PackingRules::HlslCbufferPackOffset;
+  if (s == "scalar") return PackingRules::Scalar;
+  if (s == "scalarEnhancedLayout") return PackingRules::ScalarEnhancedLayout;
+  return PackingRules::Undefined;
+}
+
+StructPackingPass::StructPackingPass(const char* structToPack,
+                                     PackingRules rules)
+    : structToPack_{structToPack != nullptr ? structToPack : ""},
+      packingRules_{rules} {}
+
+Pass::Status StructPackingPass::Process() {
+  if (packingRules_ == PackingRules::Undefined) {
+    if (consumer()) {
+      consumer()(SPV_MSG_ERROR, "", {0, 0, 0},
+                 "Cannot pack struct with undefined rule");
+    }
+    return Status::Failure;
+  }
+
+  // Build Id-to-instruction map for easier access
+  buildConstantsMap();
+
+  // Find structure of interest
+  const uint32_t structIdToPack = findStructIdByName(structToPack_.c_str());
+
+  const Instruction* structDef =
+      context()->get_def_use_mgr()->GetDef(structIdToPack);
+  if (structDef == nullptr || structDef->opcode() != spv::Op::OpTypeStruct) {
+    if (consumer()) {
+      const std::string message =
+          "Failed to find struct with name " + structToPack_;
+      consumer()(SPV_MSG_ERROR, "", {0, 0, 0}, message.c_str());
+    }
+    return Status::Failure;
+  }
+
+  // Find all struct member types
+  std::vector<const analysis::Type*> structMemberTypes =
+      findStructMemberTypes(*structDef);
+
+  return assignStructMemberOffsets(structIdToPack, structMemberTypes);
+}
+
+uint32_t StructPackingPass::findStructIdByName(const char* structName) const {
+  for (Instruction& instr : context()->module()->debugs2()) {
+    if (instr.opcode() == spv::Op::OpName &&
+        instr.GetOperand(1).AsString() == structName) {
+      return instr.GetOperand(0).AsId();
+    }
+  }
+  return 0;
+}
+
+std::vector<const analysis::Type*> StructPackingPass::findStructMemberTypes(
+    const Instruction& structDef) const {
+  // Found struct type to pack, now collect all types of its members
+  assert(structDef.NumOperands() > 0 &&
+         "Number of operands in OpTypeStruct instruction must not be zero");
+  const uint32_t numMembers = structDef.NumOperands() - 1;
+  std::vector<const analysis::Type*> structMemberTypes;
+  structMemberTypes.resize(numMembers);
+  for (uint32_t i = 0; i < numMembers; ++i) {
+    const spv::Id memberTypeId = structDef.GetOperand(1 + i).AsId();
+    if (const analysis::Type* memberType =
+            context()->get_type_mgr()->GetType(memberTypeId)) {
+      structMemberTypes[i] = memberType;
+    }
+  }
+  return structMemberTypes;
+}
+
+Pass::Status StructPackingPass::assignStructMemberOffsets(
+    uint32_t structIdToPack,
+    const std::vector<const analysis::Type*>& structMemberTypes) {
+  // Returns true if the specified instruction is a OpMemberDecorate for the
+  // struct we're looking for with an offset decoration
+  auto isMemberOffsetDecoration =
+      [structIdToPack](const Instruction& instr) -> bool {
+    return instr.opcode() == spv::Op::OpMemberDecorate &&
+           instr.GetOperand(0).AsId() == structIdToPack &&
+           static_cast<spv::Decoration>(instr.GetOperand(2).words[0]) ==
+               spv::Decoration::Offset;
+  };
+
+  bool modified = false;
+
+  // Find and re-assign all member offset decorations
+  for (auto it = context()->module()->annotation_begin(),
+            itEnd = context()->module()->annotation_end();
+       it != itEnd; ++it) {
+    if (isMemberOffsetDecoration(*it)) {
+      // Found first member decoration with offset, we expect all other
+      // offsets right after the first one
+      uint32_t prevMemberIndex = 0;
+      uint32_t currentOffset = 0;
+      uint32_t padAlignment = 1;
+      do {
+        const uint32_t memberIndex = it->GetOperand(1).words[0];
+        if (memberIndex < prevMemberIndex) {
+          // Failure: we expect all members to appear in consecutive order
+          return Status::Failure;
+        }
+
+        // Apply alignment rules to current offset
+        const analysis::Type& memberType = *structMemberTypes[memberIndex];
+        uint32_t packedAlignment = getPackedAlignment(memberType);
+        uint32_t packedSize = getPackedSize(memberType);
+
+        if (isPackingHlsl(packingRules_)) {
+          // If a member crosses vec4 boundaries, alignment is size of vec4
+          if (currentOffset / 16 != (currentOffset + packedSize - 1) / 16)
+            packedAlignment = std::max<uint32_t>(packedAlignment, 16u);
+        }
+
+        const uint32_t alignment =
+            std::max<uint32_t>(packedAlignment, padAlignment);
+        currentOffset = alignPow2(currentOffset, alignment);
+        padAlignment = getPadAlignment(memberType, packedAlignment);
+
+        // Override packed offset in instruction
+        if (it->GetOperand(3).words[0] < currentOffset) {
+          // Failure: packing resulted in higher offset for member than
+          // previously generated
+          return Status::Failure;
+        }
+
+        it->GetOperand(3).words[0] = currentOffset;
+        modified = true;
+
+        // Move to next member
+        ++it;
+        prevMemberIndex = memberIndex;
+        currentOffset += packedSize;
+      } while (it != itEnd && isMemberOffsetDecoration(*it));
+
+      // We're done with all decorations for the struct of interest
+      break;
+    }
+  }
+
+  return modified ? Status::SuccessWithChange : Status::SuccessWithoutChange;
+}
+
+}  // namespace opt
+}  // namespace spvtools
diff --git a/source/opt/struct_packing_pass.h b/source/opt/struct_packing_pass.h
new file mode 100644
index 00000000..3f30f98a
--- /dev/null
+++ b/source/opt/struct_packing_pass.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2024 Epic Games, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SOURCE_OPT_STRUCT_PACKING_PASS_
+#define SOURCE_OPT_STRUCT_PACKING_PASS_
+
+#include <unordered_map>
+
+#include "source/opt/ir_context.h"
+#include "source/opt/module.h"
+#include "source/opt/pass.h"
+
+namespace spvtools {
+namespace opt {
+
+// This pass re-assigns all field offsets under the specified packing rules.
+class StructPackingPass final : public Pass {
+ public:
+  enum class PackingRules {
+    Undefined,
+    Std140,
+    Std140EnhancedLayout,
+    Std430,
+    Std430EnhancedLayout,
+    HlslCbuffer,
+    HlslCbufferPackOffset,
+    Scalar,
+    ScalarEnhancedLayout,
+  };
+
+  static PackingRules ParsePackingRuleFromString(const std::string& s);
+
+  StructPackingPass(const char* structToPack, PackingRules rules);
+  const char* name() const override { return "struct-packing"; }
+  Status Process() override;
+
+  IRContext::Analysis GetPreservedAnalyses() override {
+    return IRContext::kAnalysisCombinators | IRContext::kAnalysisCFG |
+           IRContext::kAnalysisDominatorAnalysis |
+           IRContext::kAnalysisLoopAnalysis | IRContext::kAnalysisNameMap |
+           IRContext::kAnalysisScalarEvolution |
+           IRContext::kAnalysisStructuredCFG | IRContext::kAnalysisConstants |
+           IRContext::kAnalysisDebugInfo | IRContext::kAnalysisLiveness;
+  }
+
+ private:
+  void buildConstantsMap();
+  uint32_t findStructIdByName(const char* structName) const;
+  std::vector<const analysis::Type*> findStructMemberTypes(
+      const Instruction& structDef) const;
+  Status assignStructMemberOffsets(
+      uint32_t structIdToPack,
+      const std::vector<const analysis::Type*>& structMemberTypes);
+
+  uint32_t getPackedAlignment(const analysis::Type& type) const;
+  uint32_t getPackedSize(const analysis::Type& type) const;
+  uint32_t getPackedArrayStride(const analysis::Array& arrayType) const;
+  uint32_t getArrayLength(const analysis::Array& arrayType) const;
+  uint32_t getConstantInt(spv::Id id) const;
+
+ private:
+  std::string structToPack_;
+  PackingRules packingRules_ = PackingRules::Undefined;
+  std::unordered_map<spv::Id, Instruction*> constantsMap_;
+};
+
+}  // namespace opt
+}  // namespace spvtools
+
+#endif  // SOURCE_OPT_STRUCT_PACKING_PASS_
diff --git a/source/opt/trim_capabilities_pass.cpp b/source/opt/trim_capabilities_pass.cpp
index 24f9e467..34fbc449 100644
--- a/source/opt/trim_capabilities_pass.cpp
+++ b/source/opt/trim_capabilities_pass.cpp
@@ -27,6 +27,7 @@
 
 #include "source/enum_set.h"
 #include "source/enum_string_mapping.h"
+#include "source/ext_inst.h"
 #include "source/opt/ir_context.h"
 #include "source/opt/reflect.h"
 #include "source/spirv_target_env.h"
@@ -48,7 +49,11 @@ constexpr uint32_t kOpTypeImageMSIndex = kOpTypeImageArrayedIndex + 1;
 constexpr uint32_t kOpTypeImageSampledIndex = kOpTypeImageMSIndex + 1;
 constexpr uint32_t kOpTypeImageFormatIndex = kOpTypeImageSampledIndex + 1;
 constexpr uint32_t kOpImageReadImageIndex = 0;
+constexpr uint32_t kOpImageWriteImageIndex = 0;
 constexpr uint32_t kOpImageSparseReadImageIndex = 0;
+constexpr uint32_t kOpExtInstSetInIndex = 0;
+constexpr uint32_t kOpExtInstInstructionInIndex = 1;
+constexpr uint32_t kOpExtInstImportNameInIndex = 0;
 
 // DFS visit of the type defined by `instruction`.
 // If `condition` is true, children of the current node are visited.
@@ -334,6 +339,8 @@ Handler_OpImageRead_StorageImageReadWithoutFormat(
   const uint32_t dim = type->GetSingleWordInOperand(kOpTypeImageDimIndex);
   const uint32_t format = type->GetSingleWordInOperand(kOpTypeImageFormatIndex);
 
+  // If the Image Format is Unknown and Dim is SubpassData,
+  // StorageImageReadWithoutFormat is required.
   const bool is_unknown = spv::ImageFormat(format) == spv::ImageFormat::Unknown;
   const bool requires_capability_for_unknown =
       spv::Dim(dim) != spv::Dim::SubpassData;
@@ -342,6 +349,26 @@ Handler_OpImageRead_StorageImageReadWithoutFormat(
              : std::nullopt;
 }
 
+static std::optional<spv::Capability>
+Handler_OpImageWrite_StorageImageWriteWithoutFormat(
+    const Instruction* instruction) {
+  assert(instruction->opcode() == spv::Op::OpImageWrite &&
+         "This handler only support OpImageWrite opcodes.");
+  const auto* def_use_mgr = instruction->context()->get_def_use_mgr();
+
+  const uint32_t image_index =
+      instruction->GetSingleWordInOperand(kOpImageWriteImageIndex);
+  const uint32_t type_index = def_use_mgr->GetDef(image_index)->type_id();
+
+  // If the Image Format is Unknown, StorageImageWriteWithoutFormat is required.
+  const Instruction* type = def_use_mgr->GetDef(type_index);
+  const uint32_t format = type->GetSingleWordInOperand(kOpTypeImageFormatIndex);
+  const bool is_unknown = spv::ImageFormat(format) == spv::ImageFormat::Unknown;
+  return is_unknown
+             ? std::optional(spv::Capability::StorageImageWriteWithoutFormat)
+             : std::nullopt;
+}
+
 static std::optional<spv::Capability>
 Handler_OpImageSparseRead_StorageImageReadWithoutFormat(
     const Instruction* instruction) {
@@ -361,9 +388,10 @@ Handler_OpImageSparseRead_StorageImageReadWithoutFormat(
 }
 
 // Opcode of interest to determine capabilities requirements.
-constexpr std::array<std::pair<spv::Op, OpcodeHandler>, 12> kOpcodeHandlers{{
+constexpr std::array<std::pair<spv::Op, OpcodeHandler>, 13> kOpcodeHandlers{{
     // clang-format off
     {spv::Op::OpImageRead,         Handler_OpImageRead_StorageImageReadWithoutFormat},
+    {spv::Op::OpImageWrite,        Handler_OpImageWrite_StorageImageWriteWithoutFormat},
     {spv::Op::OpImageSparseRead,   Handler_OpImageSparseRead_StorageImageReadWithoutFormat},
     {spv::Op::OpTypeFloat,         Handler_OpTypeFloat_Float16 },
     {spv::Op::OpTypeFloat,         Handler_OpTypeFloat_Float64 },
@@ -399,6 +427,33 @@ ExtensionSet getExtensionsRelatedTo(const CapabilitySet& capabilities,
 
   return output;
 }
+
+bool hasOpcodeConflictingCapabilities(spv::Op opcode) {
+  switch (opcode) {
+    case spv::Op::OpBeginInvocationInterlockEXT:
+    case spv::Op::OpEndInvocationInterlockEXT:
+    case spv::Op::OpGroupNonUniformIAdd:
+    case spv::Op::OpGroupNonUniformFAdd:
+    case spv::Op::OpGroupNonUniformIMul:
+    case spv::Op::OpGroupNonUniformFMul:
+    case spv::Op::OpGroupNonUniformSMin:
+    case spv::Op::OpGroupNonUniformUMin:
+    case spv::Op::OpGroupNonUniformFMin:
+    case spv::Op::OpGroupNonUniformSMax:
+    case spv::Op::OpGroupNonUniformUMax:
+    case spv::Op::OpGroupNonUniformFMax:
+    case spv::Op::OpGroupNonUniformBitwiseAnd:
+    case spv::Op::OpGroupNonUniformBitwiseOr:
+    case spv::Op::OpGroupNonUniformBitwiseXor:
+    case spv::Op::OpGroupNonUniformLogicalAnd:
+    case spv::Op::OpGroupNonUniformLogicalOr:
+    case spv::Op::OpGroupNonUniformLogicalXor:
+      return true;
+    default:
+      return false;
+  }
+}
+
 }  // namespace
 
 TrimCapabilitiesPass::TrimCapabilitiesPass()
@@ -416,10 +471,7 @@ TrimCapabilitiesPass::TrimCapabilitiesPass()
 void TrimCapabilitiesPass::addInstructionRequirementsForOpcode(
     spv::Op opcode, CapabilitySet* capabilities,
     ExtensionSet* extensions) const {
-  // Ignoring OpBeginInvocationInterlockEXT and OpEndInvocationInterlockEXT
-  // because they have three possible capabilities, only one of which is needed
-  if (opcode == spv::Op::OpBeginInvocationInterlockEXT ||
-      opcode == spv::Op::OpEndInvocationInterlockEXT) {
+  if (hasOpcodeConflictingCapabilities(opcode)) {
     return;
   }
 
@@ -490,6 +542,35 @@ void TrimCapabilitiesPass::addInstructionRequirementsForOperand(
   }
 }
 
+void TrimCapabilitiesPass::addInstructionRequirementsForExtInst(
+    Instruction* instruction, CapabilitySet* capabilities) const {
+  assert(instruction->opcode() == spv::Op::OpExtInst &&
+         "addInstructionRequirementsForExtInst must be passed an OpExtInst "
+         "instruction");
+
+  const auto* def_use_mgr = context()->get_def_use_mgr();
+
+  const Instruction* extInstImport = def_use_mgr->GetDef(
+      instruction->GetSingleWordInOperand(kOpExtInstSetInIndex));
+  uint32_t extInstruction =
+      instruction->GetSingleWordInOperand(kOpExtInstInstructionInIndex);
+
+  const Operand& extInstSet =
+      extInstImport->GetInOperand(kOpExtInstImportNameInIndex);
+
+  spv_ext_inst_type_t instructionSet =
+      spvExtInstImportTypeGet(extInstSet.AsString().c_str());
+
+  spv_ext_inst_desc desc = {};
+  auto result =
+      context()->grammar().lookupExtInst(instructionSet, extInstruction, &desc);
+  if (result != SPV_SUCCESS) {
+    return;
+  }
+
+  addSupportedCapabilitiesToSet(desc, capabilities);
+}
+
 void TrimCapabilitiesPass::addInstructionRequirements(
     Instruction* instruction, CapabilitySet* capabilities,
     ExtensionSet* extensions) const {
@@ -499,8 +580,12 @@ void TrimCapabilitiesPass::addInstructionRequirements(
     return;
   }
 
-  addInstructionRequirementsForOpcode(instruction->opcode(), capabilities,
-                                      extensions);
+  if (instruction->opcode() == spv::Op::OpExtInst) {
+    addInstructionRequirementsForExtInst(instruction, capabilities);
+  } else {
+    addInstructionRequirementsForOpcode(instruction->opcode(), capabilities,
+                                        extensions);
+  }
 
   // Second case: one of the opcode operand is gated by a capability.
   const uint32_t operandCount = instruction->NumOperands();
diff --git a/source/opt/trim_capabilities_pass.h b/source/opt/trim_capabilities_pass.h
index 3a8460f3..1d1183ab 100644
--- a/source/opt/trim_capabilities_pass.h
+++ b/source/opt/trim_capabilities_pass.h
@@ -74,17 +74,23 @@ class TrimCapabilitiesPass : public Pass {
   // contains unsupported instruction, the pass could yield bad results.
   static constexpr std::array kSupportedCapabilities{
       // clang-format off
-      spv::Capability::ComputeDerivativeGroupLinearNV,
-      spv::Capability::ComputeDerivativeGroupQuadsNV,
+      spv::Capability::ComputeDerivativeGroupLinearKHR,
+      spv::Capability::ComputeDerivativeGroupQuadsKHR,
       spv::Capability::Float16,
       spv::Capability::Float64,
       spv::Capability::FragmentShaderPixelInterlockEXT,
       spv::Capability::FragmentShaderSampleInterlockEXT,
       spv::Capability::FragmentShaderShadingRateInterlockEXT,
+      spv::Capability::GroupNonUniform,
+      spv::Capability::GroupNonUniformArithmetic,
+      spv::Capability::GroupNonUniformClustered,
+      spv::Capability::GroupNonUniformPartitionedNV,
+      spv::Capability::GroupNonUniformVote,
       spv::Capability::Groups,
       spv::Capability::ImageMSArray,
       spv::Capability::Int16,
       spv::Capability::Int64,
+      spv::Capability::InterpolationFunction,
       spv::Capability::Linkage,
       spv::Capability::MinLod,
       spv::Capability::PhysicalStorageBufferAddresses,
@@ -94,11 +100,12 @@ class TrimCapabilitiesPass : public Pass {
       spv::Capability::Shader,
       spv::Capability::ShaderClockKHR,
       spv::Capability::StorageImageReadWithoutFormat,
+      spv::Capability::StorageImageWriteWithoutFormat,
       spv::Capability::StorageInputOutput16,
       spv::Capability::StoragePushConstant16,
       spv::Capability::StorageUniform16,
       spv::Capability::StorageUniformBufferBlock16,
-      spv::Capability::VulkanMemoryModelDeviceScope
+      spv::Capability::VulkanMemoryModelDeviceScope,
       // clang-format on
   };
 
@@ -155,6 +162,9 @@ class TrimCapabilitiesPass : public Pass {
                                             CapabilitySet* capabilities,
                                             ExtensionSet* extensions) const;
 
+  void addInstructionRequirementsForExtInst(Instruction* instruction,
+                                            CapabilitySet* capabilities) const;
+
   // Given an `instruction`, determines the capabilities it requires, and output
   // them in `capabilities`. The returned capabilities form a subset of
   // kSupportedCapabilities.
diff --git a/source/opt/type_manager.cpp b/source/opt/type_manager.cpp
index ae320772..88106b60 100644
--- a/source/opt/type_manager.cpp
+++ b/source/opt/type_manager.cpp
@@ -245,6 +245,7 @@ uint32_t TypeManager::GetTypeInstruction(const Type* type) {
                {(type->AsInteger()->IsSigned() ? 1u : 0u)}}});
       break;
     case Type::kFloat:
+      // TODO: Handle FP encoding enums once actually used.
       typeInst = MakeUnique<Instruction>(
           context(), spv::Op::OpTypeFloat, 0, id,
           std::initializer_list<Operand>{
@@ -440,6 +441,28 @@ uint32_t TypeManager::GetTypeInstruction(const Type* type) {
               {SPV_OPERAND_TYPE_ID, {coop_mat->use_id()}}});
       break;
     }
+    case Type::kTensorLayoutNV: {
+      auto tensor_layout = type->AsTensorLayoutNV();
+      typeInst = MakeUnique<Instruction>(
+          context(), spv::Op::OpTypeTensorLayoutNV, 0, id,
+          std::initializer_list<Operand>{
+              {SPV_OPERAND_TYPE_ID, {tensor_layout->dim_id()}},
+              {SPV_OPERAND_TYPE_ID, {tensor_layout->clamp_mode_id()}}});
+      break;
+    }
+    case Type::kTensorViewNV: {
+      auto tensor_view = type->AsTensorViewNV();
+      std::vector<Operand> operands;
+      operands.push_back(Operand{SPV_OPERAND_TYPE_ID, {tensor_view->dim_id()}});
+      operands.push_back(
+          Operand{SPV_OPERAND_TYPE_ID, {tensor_view->has_dimensions_id()}});
+      for (auto p : tensor_view->perm()) {
+        operands.push_back(Operand{SPV_OPERAND_TYPE_ID, {p}});
+      }
+      typeInst = MakeUnique<Instruction>(context(), spv::Op::OpTypeTensorViewNV,
+                                         0, id, operands);
+      break;
+    }
     default:
       assert(false && "Unexpected type");
       break;
@@ -454,12 +477,7 @@ uint32_t TypeManager::FindPointerToType(uint32_t type_id,
                                         spv::StorageClass storage_class) {
   Type* pointeeTy = GetType(type_id);
   Pointer pointerTy(pointeeTy, storage_class);
-  if (pointeeTy->IsUniqueType()) {
-    // Non-ambiguous type. Get the pointer type through the type manager.
-    return GetTypeInstruction(&pointerTy);
-  }
 
-  // Ambiguous type, do a linear search.
   Module::inst_iterator type_itr = context()->module()->types_values_begin();
   for (; type_itr != context()->module()->types_values_end(); ++type_itr) {
     const Instruction* type_inst = &*type_itr;
@@ -472,8 +490,10 @@ uint32_t TypeManager::FindPointerToType(uint32_t type_id,
   }
 
   // Must create the pointer type.
-  // TODO(1841): Handle id overflow.
   uint32_t resultId = context()->TakeNextId();
+  if (resultId == 0) {
+    return 0;
+  }
   std::unique_ptr<Instruction> type_inst(
       new Instruction(context(), spv::Op::OpTypePointer, 0, resultId,
                       {{spv_operand_type_t::SPV_OPERAND_TYPE_STORAGE_CLASS,
@@ -517,13 +537,24 @@ void TypeManager::CreateDecoration(uint32_t target,
   context()->get_def_use_mgr()->AnalyzeInstUse(inst);
 }
 
-Type* TypeManager::RebuildType(const Type& type) {
+Type* TypeManager::RebuildType(uint32_t type_id, const Type& type) {
+  assert(type_id != 0);
+
   // The comparison and hash on the type pool will avoid inserting the rebuilt
   // type if an equivalent type already exists. The rebuilt type will be deleted
   // when it goes out of scope at the end of the function in that case. Repeated
   // insertions of the same Type will, at most, keep one corresponding object in
   // the type pool.
   std::unique_ptr<Type> rebuilt_ty;
+
+  // If |type_id| is already present in the type pool, return the existing type.
+  // This saves extra work in the type builder and prevents running into
+  // circular issues (https://github.com/KhronosGroup/SPIRV-Tools/issues/5623).
+  Type* pool_ty = GetType(type_id);
+  if (pool_ty != nullptr) {
+    return pool_ty;
+  }
+
   switch (type.kind()) {
 #define DefineNoSubtypeCase(kind)             \
   case Type::k##kind:                         \
@@ -550,43 +581,46 @@ Type* TypeManager::RebuildType(const Type& type) {
     case Type::kVector: {
       const Vector* vec_ty = type.AsVector();
       const Type* ele_ty = vec_ty->element_type();
-      rebuilt_ty =
-          MakeUnique<Vector>(RebuildType(*ele_ty), vec_ty->element_count());
+      rebuilt_ty = MakeUnique<Vector>(RebuildType(GetId(ele_ty), *ele_ty),
+                                      vec_ty->element_count());
       break;
     }
     case Type::kMatrix: {
       const Matrix* mat_ty = type.AsMatrix();
       const Type* ele_ty = mat_ty->element_type();
-      rebuilt_ty =
-          MakeUnique<Matrix>(RebuildType(*ele_ty), mat_ty->element_count());
+      rebuilt_ty = MakeUnique<Matrix>(RebuildType(GetId(ele_ty), *ele_ty),
+                                      mat_ty->element_count());
       break;
     }
     case Type::kImage: {
       const Image* image_ty = type.AsImage();
       const Type* ele_ty = image_ty->sampled_type();
-      rebuilt_ty =
-          MakeUnique<Image>(RebuildType(*ele_ty), image_ty->dim(),
-                            image_ty->depth(), image_ty->is_arrayed(),
-                            image_ty->is_multisampled(), image_ty->sampled(),
-                            image_ty->format(), image_ty->access_qualifier());
+      rebuilt_ty = MakeUnique<Image>(
+          RebuildType(GetId(ele_ty), *ele_ty), image_ty->dim(),
+          image_ty->depth(), image_ty->is_arrayed(),
+          image_ty->is_multisampled(), image_ty->sampled(), image_ty->format(),
+          image_ty->access_qualifier());
       break;
     }
     case Type::kSampledImage: {
       const SampledImage* image_ty = type.AsSampledImage();
       const Type* ele_ty = image_ty->image_type();
-      rebuilt_ty = MakeUnique<SampledImage>(RebuildType(*ele_ty));
+      rebuilt_ty =
+          MakeUnique<SampledImage>(RebuildType(GetId(ele_ty), *ele_ty));
       break;
     }
     case Type::kArray: {
       const Array* array_ty = type.AsArray();
-      rebuilt_ty =
-          MakeUnique<Array>(array_ty->element_type(), array_ty->length_info());
+      const Type* ele_ty = array_ty->element_type();
+      rebuilt_ty = MakeUnique<Array>(RebuildType(GetId(ele_ty), *ele_ty),
+                                     array_ty->length_info());
       break;
     }
     case Type::kRuntimeArray: {
       const RuntimeArray* array_ty = type.AsRuntimeArray();
       const Type* ele_ty = array_ty->element_type();
-      rebuilt_ty = MakeUnique<RuntimeArray>(RebuildType(*ele_ty));
+      rebuilt_ty =
+          MakeUnique<RuntimeArray>(RebuildType(GetId(ele_ty), *ele_ty));
       break;
     }
     case Type::kStruct: {
@@ -594,7 +628,7 @@ Type* TypeManager::RebuildType(const Type& type) {
       std::vector<const Type*> subtypes;
       subtypes.reserve(struct_ty->element_types().size());
       for (const auto* ele_ty : struct_ty->element_types()) {
-        subtypes.push_back(RebuildType(*ele_ty));
+        subtypes.push_back(RebuildType(GetId(ele_ty), *ele_ty));
       }
       rebuilt_ty = MakeUnique<Struct>(subtypes);
       Struct* rebuilt_struct = rebuilt_ty->AsStruct();
@@ -611,7 +645,7 @@ Type* TypeManager::RebuildType(const Type& type) {
     case Type::kPointer: {
       const Pointer* pointer_ty = type.AsPointer();
       const Type* ele_ty = pointer_ty->pointee_type();
-      rebuilt_ty = MakeUnique<Pointer>(RebuildType(*ele_ty),
+      rebuilt_ty = MakeUnique<Pointer>(RebuildType(GetId(ele_ty), *ele_ty),
                                        pointer_ty->storage_class());
       break;
     }
@@ -621,9 +655,10 @@ Type* TypeManager::RebuildType(const Type& type) {
       std::vector<const Type*> param_types;
       param_types.reserve(function_ty->param_types().size());
       for (const auto* param_ty : function_ty->param_types()) {
-        param_types.push_back(RebuildType(*param_ty));
+        param_types.push_back(RebuildType(GetId(param_ty), *param_ty));
       }
-      rebuilt_ty = MakeUnique<Function>(RebuildType(*ret_ty), param_types);
+      rebuilt_ty = MakeUnique<Function>(RebuildType(GetId(ret_ty), *ret_ty),
+                                        param_types);
       break;
     }
     case Type::kForwardPointer: {
@@ -633,7 +668,7 @@ Type* TypeManager::RebuildType(const Type& type) {
       const Pointer* target_ptr = forward_ptr_ty->target_pointer();
       if (target_ptr) {
         rebuilt_ty->AsForwardPointer()->SetTargetPointer(
-            RebuildType(*target_ptr)->AsPointer());
+            RebuildType(GetId(target_ptr), *target_ptr)->AsPointer());
       }
       break;
     }
@@ -641,16 +676,29 @@ Type* TypeManager::RebuildType(const Type& type) {
       const CooperativeMatrixNV* cm_type = type.AsCooperativeMatrixNV();
       const Type* component_type = cm_type->component_type();
       rebuilt_ty = MakeUnique<CooperativeMatrixNV>(
-          RebuildType(*component_type), cm_type->scope_id(), cm_type->rows_id(),
-          cm_type->columns_id());
+          RebuildType(GetId(component_type), *component_type),
+          cm_type->scope_id(), cm_type->rows_id(), cm_type->columns_id());
       break;
     }
     case Type::kCooperativeMatrixKHR: {
       const CooperativeMatrixKHR* cm_type = type.AsCooperativeMatrixKHR();
       const Type* component_type = cm_type->component_type();
       rebuilt_ty = MakeUnique<CooperativeMatrixKHR>(
-          RebuildType(*component_type), cm_type->scope_id(), cm_type->rows_id(),
-          cm_type->columns_id(), cm_type->use_id());
+          RebuildType(GetId(component_type), *component_type),
+          cm_type->scope_id(), cm_type->rows_id(), cm_type->columns_id(),
+          cm_type->use_id());
+      break;
+    }
+    case Type::kTensorLayoutNV: {
+      const TensorLayoutNV* tl_type = type.AsTensorLayoutNV();
+      rebuilt_ty = MakeUnique<TensorLayoutNV>(tl_type->dim_id(),
+                                              tl_type->clamp_mode_id());
+      break;
+    }
+    case Type::kTensorViewNV: {
+      const TensorViewNV* tv_type = type.AsTensorViewNV();
+      rebuilt_ty = MakeUnique<TensorViewNV>(
+          tv_type->dim_id(), tv_type->has_dimensions_id(), tv_type->perm());
       break;
     }
     default:
@@ -669,7 +717,7 @@ Type* TypeManager::RebuildType(const Type& type) {
 void TypeManager::RegisterType(uint32_t id, const Type& type) {
   // Rebuild |type| so it and all its constituent types are owned by the type
   // pool.
-  Type* rebuilt = RebuildType(type);
+  Type* rebuilt = RebuildType(id, type);
   assert(rebuilt->IsSame(&type));
   id_to_type_[id] = rebuilt;
   if (GetId(rebuilt) == 0) {
@@ -900,6 +948,20 @@ Type* TypeManager::RecordIfTypeDefinition(const Instruction& inst) {
     case spv::Op::OpTypeHitObjectNV:
       type = new HitObjectNV();
       break;
+    case spv::Op::OpTypeTensorLayoutNV:
+      type = new TensorLayoutNV(inst.GetSingleWordInOperand(0),
+                                inst.GetSingleWordInOperand(1));
+      break;
+    case spv::Op::OpTypeTensorViewNV: {
+      const auto count = inst.NumOperands();
+      std::vector<uint32_t> perm;
+      for (uint32_t i = 2; i < count; ++i) {
+        perm.push_back(inst.GetSingleWordOperand(i));
+      }
+      type = new TensorViewNV(inst.GetSingleWordInOperand(0),
+                              inst.GetSingleWordInOperand(1), perm);
+      break;
+    }
     default:
       assert(false && "Type not handled by the type manager.");
       break;
diff --git a/source/opt/type_manager.h b/source/opt/type_manager.h
index a70c371d..948b691b 100644
--- a/source/opt/type_manager.h
+++ b/source/opt/type_manager.h
@@ -260,7 +260,9 @@ class TypeManager {
   // Returns an equivalent pointer to |type| built in terms of pointers owned by
   // |type_pool_|. For example, if |type| is a vec3 of bool, it will be rebuilt
   // replacing the bool subtype with one owned by |type_pool_|.
-  Type* RebuildType(const Type& type);
+  //
+  // The re-built type will have ID |type_id|.
+  Type* RebuildType(uint32_t type_id, const Type& type);
 
   // Completes the incomplete type |type|, by replaces all references to
   // ForwardPointer by the defining Pointer.
diff --git a/source/opt/types.cpp b/source/opt/types.cpp
index b18b8cb1..8ccf6c9a 100644
--- a/source/opt/types.cpp
+++ b/source/opt/types.cpp
@@ -179,6 +179,8 @@ bool Type::operator==(const Type& other) const {
     DeclareKindCase(CooperativeMatrixKHR);
     DeclareKindCase(RayQueryKHR);
     DeclareKindCase(HitObjectNV);
+    DeclareKindCase(TensorLayoutNV);
+    DeclareKindCase(TensorViewNV);
 #undef DeclareKindCase
     default:
       assert(false && "Unhandled type");
@@ -235,6 +237,8 @@ size_t Type::ComputeHashValue(size_t hash, SeenTypes* seen) const {
     DeclareKindCase(CooperativeMatrixKHR);
     DeclareKindCase(RayQueryKHR);
     DeclareKindCase(HitObjectNV);
+    DeclareKindCase(TensorLayoutNV);
+    DeclareKindCase(TensorViewNV);
 #undef DeclareKindCase
     default:
       assert(false && "Unhandled type");
@@ -747,7 +751,55 @@ bool CooperativeMatrixKHR::IsSameImpl(const Type* that,
   if (!mt) return false;
   return component_type_->IsSameImpl(mt->component_type_, seen) &&
          scope_id_ == mt->scope_id_ && rows_id_ == mt->rows_id_ &&
-         columns_id_ == mt->columns_id_ && HasSameDecorations(that);
+         columns_id_ == mt->columns_id_ && use_id_ == mt->use_id_ &&
+         HasSameDecorations(that);
+}
+
+TensorLayoutNV::TensorLayoutNV(const uint32_t dim, const uint32_t clamp_mode)
+    : Type(kTensorLayoutNV), dim_id_(dim), clamp_mode_id_(clamp_mode) {}
+
+std::string TensorLayoutNV::str() const {
+  std::ostringstream oss;
+  oss << "<" << dim_id_ << ", " << clamp_mode_id_ << ">";
+  return oss.str();
+}
+
+size_t TensorLayoutNV::ComputeExtraStateHash(size_t hash, SeenTypes*) const {
+  return hash_combine(hash, dim_id_, clamp_mode_id_);
+}
+
+bool TensorLayoutNV::IsSameImpl(const Type* that, IsSameCache*) const {
+  const TensorLayoutNV* tl = that->AsTensorLayoutNV();
+  if (!tl) return false;
+  return dim_id_ == tl->dim_id_ && clamp_mode_id_ == tl->clamp_mode_id_;
+}
+
+TensorViewNV::TensorViewNV(const uint32_t dim, const uint32_t clamp_mode,
+                           const std::vector<uint32_t>& perm)
+    : Type(kTensorViewNV),
+      dim_id_(dim),
+      has_dimensions_id_(clamp_mode),
+      perm_(perm) {}
+
+std::string TensorViewNV::str() const {
+  std::ostringstream oss;
+  oss << "<" << dim_id_ << ", " << has_dimensions_id_;
+  for (auto p : perm_) {
+    oss << ", " << p;
+  }
+  oss << ">";
+  return oss.str();
+}
+
+size_t TensorViewNV::ComputeExtraStateHash(size_t hash, SeenTypes*) const {
+  return hash_combine(hash, dim_id_, has_dimensions_id_, perm_);
+}
+
+bool TensorViewNV::IsSameImpl(const Type* that, IsSameCache*) const {
+  const TensorViewNV* tv = that->AsTensorViewNV();
+  if (!tv) return false;
+  return dim_id_ == tv->dim_id_ &&
+         has_dimensions_id_ == tv->has_dimensions_id_ && perm_ == tv->perm_;
 }
 
 }  // namespace analysis
diff --git a/source/opt/types.h b/source/opt/types.h
index 16a948ce..6092c3c9 100644
--- a/source/opt/types.h
+++ b/source/opt/types.h
@@ -63,6 +63,8 @@ class CooperativeMatrixNV;
 class CooperativeMatrixKHR;
 class RayQueryKHR;
 class HitObjectNV;
+class TensorLayoutNV;
+class TensorViewNV;
 
 // Abstract class for a SPIR-V type. It has a bunch of As<sublcass>() methods,
 // which is used as a way to probe the actual <subclass>.
@@ -104,6 +106,8 @@ class Type {
     kCooperativeMatrixKHR,
     kRayQueryKHR,
     kHitObjectNV,
+    kTensorLayoutNV,
+    kTensorViewNV,
     kLast
   };
 
@@ -206,6 +210,8 @@ class Type {
   DeclareCastMethod(CooperativeMatrixKHR)
   DeclareCastMethod(RayQueryKHR)
   DeclareCastMethod(HitObjectNV)
+  DeclareCastMethod(TensorLayoutNV)
+  DeclareCastMethod(TensorViewNV)
 #undef DeclareCastMethod
 
 protected:
@@ -659,6 +665,53 @@ class CooperativeMatrixKHR : public Type {
   const uint32_t use_id_;
 };
 
+class TensorLayoutNV : public Type {
+ public:
+  TensorLayoutNV(const uint32_t dim, const uint32_t clamp_mode);
+  TensorLayoutNV(const TensorLayoutNV&) = default;
+
+  std::string str() const override;
+
+  TensorLayoutNV* AsTensorLayoutNV() override { return this; }
+  const TensorLayoutNV* AsTensorLayoutNV() const override { return this; }
+
+  size_t ComputeExtraStateHash(size_t hash, SeenTypes* seen) const override;
+
+  uint32_t dim_id() const { return dim_id_; }
+  uint32_t clamp_mode_id() const { return clamp_mode_id_; }
+
+ private:
+  bool IsSameImpl(const Type* that, IsSameCache*) const override;
+
+  const uint32_t dim_id_;
+  const uint32_t clamp_mode_id_;
+};
+
+class TensorViewNV : public Type {
+ public:
+  TensorViewNV(const uint32_t dim, const uint32_t clamp_mode,
+               const std::vector<uint32_t>& perm);
+  TensorViewNV(const TensorViewNV&) = default;
+
+  std::string str() const override;
+
+  TensorViewNV* AsTensorViewNV() override { return this; }
+  const TensorViewNV* AsTensorViewNV() const override { return this; }
+
+  size_t ComputeExtraStateHash(size_t hash, SeenTypes* seen) const override;
+
+  uint32_t dim_id() const { return dim_id_; }
+  uint32_t has_dimensions_id() const { return has_dimensions_id_; }
+  const std::vector<uint32_t>& perm() const { return perm_; }
+
+ private:
+  bool IsSameImpl(const Type* that, IsSameCache*) const override;
+
+  const uint32_t dim_id_;
+  const uint32_t has_dimensions_id_;
+  std::vector<uint32_t> perm_;
+};
+
 #define DefineParameterlessType(type, name)                                \
   class type : public Type {                                               \
    public:                                                                 \
diff --git a/source/print.cpp b/source/print.cpp
index f36812ef..3143db17 100644
--- a/source/print.cpp
+++ b/source/print.cpp
@@ -14,26 +14,7 @@
 
 #include "source/print.h"
 
-#if defined(SPIRV_ANDROID) || defined(SPIRV_LINUX) || defined(SPIRV_MAC) || \
-    defined(SPIRV_IOS) || defined(SPIRV_TVOS) || defined(SPIRV_FREEBSD) ||  \
-    defined(SPIRV_OPENBSD) || defined(SPIRV_EMSCRIPTEN) ||                  \
-    defined(SPIRV_FUCHSIA) || defined(SPIRV_GNU) || defined(SPIRV_QNX)
-namespace spvtools {
-
-clr::reset::operator const char*() { return "\x1b[0m"; }
-
-clr::grey::operator const char*() { return "\x1b[1;30m"; }
-
-clr::red::operator const char*() { return "\x1b[31m"; }
-
-clr::green::operator const char*() { return "\x1b[32m"; }
-
-clr::yellow::operator const char*() { return "\x1b[33m"; }
-
-clr::blue::operator const char*() { return "\x1b[34m"; }
-
-}  // namespace spvtools
-#elif defined(SPIRV_WINDOWS)
+#if defined(SPIRV_WINDOWS)
 #include <windows.h>
 
 namespace spvtools {
@@ -111,17 +92,17 @@ clr::blue::operator const char*() {
 #else
 namespace spvtools {
 
-clr::reset::operator const char*() { return ""; }
+clr::reset::operator const char*() { return "\x1b[0m"; }
 
-clr::grey::operator const char*() { return ""; }
+clr::grey::operator const char*() { return "\x1b[1;30m"; }
 
-clr::red::operator const char*() { return ""; }
+clr::red::operator const char*() { return "\x1b[31m"; }
 
-clr::green::operator const char*() { return ""; }
+clr::green::operator const char*() { return "\x1b[32m"; }
 
-clr::yellow::operator const char*() { return ""; }
+clr::yellow::operator const char*() { return "\x1b[33m"; }
 
-clr::blue::operator const char*() { return ""; }
+clr::blue::operator const char*() { return "\x1b[34m"; }
 
 }  // namespace spvtools
 #endif
diff --git a/source/spirv_target_env.cpp b/source/spirv_target_env.cpp
index 585f8b65..8e1b2dd7 100644
--- a/source/spirv_target_env.cpp
+++ b/source/spirv_target_env.cpp
@@ -14,11 +14,13 @@
 
 #include "source/spirv_target_env.h"
 
+#include <array>
 #include <cassert>
+#include <cctype>
 #include <cstring>
 #include <string>
-#include <utility>
 
+#include "source/latest_version_spirv_header.h"
 #include "source/spirv_constant.h"
 #include "spirv-tools/libspirv.h"
 
@@ -77,6 +79,8 @@ const char* spvTargetEnvDescription(spv_target_env env) {
       return "SPIR-V 1.6";
     case SPV_ENV_VULKAN_1_3:
       return "SPIR-V 1.6 (under Vulkan 1.3 semantics)";
+    case SPV_ENV_VULKAN_1_4:
+      return "SPIR-V 1.6 (under Vulkan 1.4 semantics)";
     case SPV_ENV_MAX:
       assert(false && "Invalid target environment value.");
       break;
@@ -120,6 +124,7 @@ uint32_t spvVersionForTargetEnv(spv_target_env env) {
       return SPV_SPIRV_VERSION_WORD(1, 5);
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       return SPV_SPIRV_VERSION_WORD(1, 6);
     case SPV_ENV_MAX:
       assert(false && "Invalid target environment value.");
@@ -128,32 +133,44 @@ uint32_t spvVersionForTargetEnv(spv_target_env env) {
   return SPV_SPIRV_VERSION_WORD(0, 0);
 }
 
-static const std::pair<const char*, spv_target_env> spvTargetEnvNameMap[] = {
-    {"vulkan1.1spv1.4", SPV_ENV_VULKAN_1_1_SPIRV_1_4},
-    {"vulkan1.0", SPV_ENV_VULKAN_1_0},
-    {"vulkan1.1", SPV_ENV_VULKAN_1_1},
-    {"vulkan1.2", SPV_ENV_VULKAN_1_2},
-    {"vulkan1.3", SPV_ENV_VULKAN_1_3},
-    {"spv1.0", SPV_ENV_UNIVERSAL_1_0},
-    {"spv1.1", SPV_ENV_UNIVERSAL_1_1},
-    {"spv1.2", SPV_ENV_UNIVERSAL_1_2},
-    {"spv1.3", SPV_ENV_UNIVERSAL_1_3},
-    {"spv1.4", SPV_ENV_UNIVERSAL_1_4},
-    {"spv1.5", SPV_ENV_UNIVERSAL_1_5},
-    {"spv1.6", SPV_ENV_UNIVERSAL_1_6},
-    {"opencl1.2embedded", SPV_ENV_OPENCL_EMBEDDED_1_2},
-    {"opencl1.2", SPV_ENV_OPENCL_1_2},
-    {"opencl2.0embedded", SPV_ENV_OPENCL_EMBEDDED_2_0},
-    {"opencl2.0", SPV_ENV_OPENCL_2_0},
-    {"opencl2.1embedded", SPV_ENV_OPENCL_EMBEDDED_2_1},
-    {"opencl2.1", SPV_ENV_OPENCL_2_1},
-    {"opencl2.2embedded", SPV_ENV_OPENCL_EMBEDDED_2_2},
-    {"opencl2.2", SPV_ENV_OPENCL_2_2},
-    {"opengl4.0", SPV_ENV_OPENGL_4_0},
-    {"opengl4.1", SPV_ENV_OPENGL_4_1},
-    {"opengl4.2", SPV_ENV_OPENGL_4_2},
-    {"opengl4.3", SPV_ENV_OPENGL_4_3},
-    {"opengl4.5", SPV_ENV_OPENGL_4_5},
+// When a new SPIR-V version is released, update this table.
+static_assert(spv::Version == 0x10600);
+constexpr auto ordered_universal_envs = std::array<spv_target_env, 7>{
+    SPV_ENV_UNIVERSAL_1_0, SPV_ENV_UNIVERSAL_1_1, SPV_ENV_UNIVERSAL_1_2,
+    SPV_ENV_UNIVERSAL_1_3, SPV_ENV_UNIVERSAL_1_4, SPV_ENV_UNIVERSAL_1_5,
+    SPV_ENV_UNIVERSAL_1_6,
+};
+
+// When a new SPIR-V version is released, update this table.
+static_assert(spv::Version == 0x10600);
+inline constexpr std::pair<const char*, spv_target_env> spvTargetEnvNameMap[] =
+    {
+        {"vulkan1.1spv1.4", SPV_ENV_VULKAN_1_1_SPIRV_1_4},
+        {"vulkan1.0", SPV_ENV_VULKAN_1_0},
+        {"vulkan1.1", SPV_ENV_VULKAN_1_1},
+        {"vulkan1.2", SPV_ENV_VULKAN_1_2},
+        {"vulkan1.3", SPV_ENV_VULKAN_1_3},
+        {"vulkan1.4", SPV_ENV_VULKAN_1_4},
+        {"spv1.0", SPV_ENV_UNIVERSAL_1_0},
+        {"spv1.1", SPV_ENV_UNIVERSAL_1_1},
+        {"spv1.2", SPV_ENV_UNIVERSAL_1_2},
+        {"spv1.3", SPV_ENV_UNIVERSAL_1_3},
+        {"spv1.4", SPV_ENV_UNIVERSAL_1_4},
+        {"spv1.5", SPV_ENV_UNIVERSAL_1_5},
+        {"spv1.6", SPV_ENV_UNIVERSAL_1_6},
+        {"opencl1.2embedded", SPV_ENV_OPENCL_EMBEDDED_1_2},
+        {"opencl1.2", SPV_ENV_OPENCL_1_2},
+        {"opencl2.0embedded", SPV_ENV_OPENCL_EMBEDDED_2_0},
+        {"opencl2.0", SPV_ENV_OPENCL_2_0},
+        {"opencl2.1embedded", SPV_ENV_OPENCL_EMBEDDED_2_1},
+        {"opencl2.1", SPV_ENV_OPENCL_2_1},
+        {"opencl2.2embedded", SPV_ENV_OPENCL_EMBEDDED_2_2},
+        {"opencl2.2", SPV_ENV_OPENCL_2_2},
+        {"opengl4.0", SPV_ENV_OPENGL_4_0},
+        {"opengl4.1", SPV_ENV_OPENGL_4_1},
+        {"opengl4.2", SPV_ENV_OPENGL_4_2},
+        {"opengl4.3", SPV_ENV_OPENGL_4_3},
+        {"opengl4.5", SPV_ENV_OPENGL_4_5},
 };
 
 bool spvParseTargetEnv(const char* s, spv_target_env* env) {
@@ -172,6 +189,59 @@ bool spvParseTargetEnv(const char* s, spv_target_env* env) {
   return false;
 }
 
+bool spvReadEnvironmentFromText(const std::vector<char>& text,
+                                spv_target_env* env) {
+  // Version is expected to match "; Version: 1.X"
+  // Version string must occur in header, that is, initial lines of comments
+  // Once a non-comment line occurs, the header has ended
+  for (std::size_t i = 0; i < text.size(); ++i) {
+    char c = text[i];
+
+    if (c == ';') {
+      // Try to match against the expected version string
+      constexpr const char* kVersionPrefix = "; Version: 1.";
+      constexpr const auto kPrefixLength = 13;
+      // 'minor_digit_pos' is the expected position of the version digit.
+      const auto minor_digit_pos = i + kPrefixLength;
+      if (minor_digit_pos >= text.size()) return false;
+
+      // Match the prefix.
+      auto j = 1;
+      for (; j < kPrefixLength; ++j) {
+        if (kVersionPrefix[j] != text[i + j]) break;
+      }
+      // j will match the prefix length if all characters before matched
+      if (j == kPrefixLength) {
+        // This expects only one digit in the minor number.
+        static_assert(((spv::Version >> 8) & 0xff) < 10);
+        char minor = text[minor_digit_pos];
+        char next_char =
+            minor_digit_pos + 1 < text.size() ? text[minor_digit_pos + 1] : 0;
+        if (std::isdigit(minor) && !std::isdigit(next_char)) {
+          const auto index = minor - '0';
+          assert(index >= 0);
+          if (static_cast<size_t>(index) < ordered_universal_envs.size()) {
+            *env = ordered_universal_envs[index];
+            return true;
+          }
+        }
+      }
+
+      // If no match, determine whether the header has ended (in which case,
+      // assumption has failed.)
+      // Skip until the next line.
+      i = j;
+      for (; i < text.size(); ++i) {
+        if (text[i] == '\n') break;
+      }
+    } else if (!std::isspace(c)) {
+      // Allow blanks, but end the search if we find something else.
+      break;
+    }
+  }
+  return false;
+}
+
 #define VULKAN_VER(MAJOR, MINOR) ((MAJOR << 22) | (MINOR << 12))
 #define SPIRV_VER(MAJOR, MINOR) ((MAJOR << 16) | (MINOR << 8))
 
@@ -188,7 +258,8 @@ static const VulkanEnv ordered_vulkan_envs[] = {
     {SPV_ENV_VULKAN_1_1, VULKAN_VER(1, 1), SPIRV_VER(1, 3)},
     {SPV_ENV_VULKAN_1_1_SPIRV_1_4, VULKAN_VER(1, 1), SPIRV_VER(1, 4)},
     {SPV_ENV_VULKAN_1_2, VULKAN_VER(1, 2), SPIRV_VER(1, 5)},
-    {SPV_ENV_VULKAN_1_3, VULKAN_VER(1, 3), SPIRV_VER(1, 6)}};
+    {SPV_ENV_VULKAN_1_3, VULKAN_VER(1, 3), SPIRV_VER(1, 6)},
+    {SPV_ENV_VULKAN_1_4, VULKAN_VER(1, 4), SPIRV_VER(1, 6)}};
 
 bool spvParseVulkanEnv(uint32_t vulkan_ver, uint32_t spirv_ver,
                        spv_target_env* env) {
@@ -229,6 +300,7 @@ bool spvIsVulkanEnv(spv_target_env env) {
     case SPV_ENV_VULKAN_1_1_SPIRV_1_4:
     case SPV_ENV_VULKAN_1_2:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       return true;
     case SPV_ENV_WEBGPU_0:
       assert(false && "Deprecated target environment value.");
@@ -259,6 +331,7 @@ bool spvIsOpenCLEnv(spv_target_env env) {
     case SPV_ENV_VULKAN_1_2:
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       return false;
     case SPV_ENV_OPENCL_1_2:
     case SPV_ENV_OPENCL_EMBEDDED_1_2:
@@ -301,6 +374,7 @@ bool spvIsOpenGLEnv(spv_target_env env) {
     case SPV_ENV_VULKAN_1_2:
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       return false;
     case SPV_ENV_OPENGL_4_0:
     case SPV_ENV_OPENGL_4_1:
@@ -340,6 +414,7 @@ bool spvIsValidEnv(spv_target_env env) {
     case SPV_ENV_VULKAN_1_2:
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
     case SPV_ENV_OPENGL_4_0:
     case SPV_ENV_OPENGL_4_1:
     case SPV_ENV_OPENGL_4_2:
@@ -376,7 +451,8 @@ std::string spvLogStringForEnv(spv_target_env env) {
     case SPV_ENV_VULKAN_1_1:
     case SPV_ENV_VULKAN_1_1_SPIRV_1_4:
     case SPV_ENV_VULKAN_1_2:
-    case SPV_ENV_VULKAN_1_3: {
+    case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4: {
       return "Vulkan";
     }
     case SPV_ENV_UNIVERSAL_1_0:
diff --git a/source/spirv_target_env.h b/source/spirv_target_env.h
index f3b0c2f6..4378f06f 100644
--- a/source/spirv_target_env.h
+++ b/source/spirv_target_env.h
@@ -16,6 +16,8 @@
 #define SOURCE_SPIRV_TARGET_ENV_H_
 
 #include <string>
+#include <utility>
+#include <vector>
 
 #include "spirv-tools/libspirv.h"
 
@@ -46,4 +48,9 @@ std::string spvLogStringForEnv(spv_target_env env);
 //        occur to satisfy this limit.
 std::string spvTargetEnvList(const int pad, const int wrap);
 
+// Reads the target environment from the header comments of disassembly. Returns
+// true if valid name found, false otherwise.
+bool spvReadEnvironmentFromText(const std::vector<char>& text,
+                                spv_target_env* env);
+
 #endif  // SOURCE_SPIRV_TARGET_ENV_H_
diff --git a/source/table.cpp b/source/table.cpp
index 822cefeb..01df1bc0 100644
--- a/source/table.cpp
+++ b/source/table.cpp
@@ -43,6 +43,7 @@ spv_context spvContextCreate(spv_target_env env) {
     case SPV_ENV_VULKAN_1_2:
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       break;
     default:
       return nullptr;
diff --git a/source/table.h b/source/table.h
index 8097f13f..47625c5f 100644
--- a/source/table.h
+++ b/source/table.h
@@ -22,6 +22,8 @@
 typedef struct spv_opcode_desc_t {
   const char* name;
   const spv::Op opcode;
+  const uint32_t numAliases;
+  const char** aliases;
   const uint32_t numCapabilities;
   const spv::Capability* capabilities;
   // operandTypes[0..numTypes-1] describe logical operands for the instruction.
@@ -47,6 +49,8 @@ typedef struct spv_opcode_desc_t {
 typedef struct spv_operand_desc_t {
   const char* name;
   const uint32_t value;
+  const uint32_t numAliases;
+  const char** aliases;
   const uint32_t numCapabilities;
   const spv::Capability* capabilities;
   // A set of extensions that enable this feature. If empty then this operand
@@ -74,7 +78,7 @@ typedef struct spv_ext_inst_desc_t {
   const uint32_t ext_inst;
   const uint32_t numCapabilities;
   const spv::Capability* capabilities;
-  const spv_operand_type_t operandTypes[16];  // TODO: Smaller/larger?
+  const spv_operand_type_t operandTypes[40];  // vksp needs at least 40
 } spv_ext_inst_desc_t;
 
 typedef struct spv_ext_inst_group_t {
diff --git a/source/text.cpp b/source/text.cpp
index 737c223b..2154e855 100644
--- a/source/text.cpp
+++ b/source/text.cpp
@@ -201,7 +201,7 @@ spv_result_t spvTextEncodeOperand(const spvtools::AssemblyGrammar& grammar,
   }
 
   // Optional literal operands can fail to parse. In that case use
-  // SPV_FAILED_MATCH to avoid emitting a diagostic.  Use the following
+  // SPV_FAILED_MATCH to avoid emitting a diagnostic.  Use the following
   // for those situations.
   spv_result_t error_code_for_literals =
       spvOperandIsOptional(type) ? SPV_FAILED_MATCH : SPV_ERROR_INVALID_TEXT;
@@ -227,8 +227,7 @@ spv_result_t spvTextEncodeOperand(const spvtools::AssemblyGrammar& grammar,
 
       // Set the extended instruction type.
       // The import set id is the 3rd operand of OpExtInst.
-      if (spv::Op(pInst->opcode) == spv::Op::OpExtInst &&
-          pInst->words.size() == 4) {
+      if (spvIsExtendedInstruction(pInst->opcode) && pInst->words.size() == 4) {
         auto ext_inst_type = context->getExtInstTypeForId(pInst->words[3]);
         if (ext_inst_type == SPV_EXT_INST_TYPE_NONE) {
           return context->diagnostic()
@@ -411,10 +410,13 @@ spv_result_t spvTextEncodeOperand(const spvtools::AssemblyGrammar& grammar,
     case SPV_OPERAND_TYPE_IMAGE:
     case SPV_OPERAND_TYPE_OPTIONAL_IMAGE:
     case SPV_OPERAND_TYPE_OPTIONAL_MEMORY_ACCESS:
+    case SPV_OPERAND_TYPE_OPTIONAL_RAW_ACCESS_CHAIN_OPERANDS:
     case SPV_OPERAND_TYPE_SELECTION_CONTROL:
     case SPV_OPERAND_TYPE_DEBUG_INFO_FLAGS:
     case SPV_OPERAND_TYPE_CLDEBUG100_DEBUG_INFO_FLAGS:
-    case SPV_OPERAND_TYPE_OPTIONAL_COOPERATIVE_MATRIX_OPERANDS: {
+    case SPV_OPERAND_TYPE_OPTIONAL_COOPERATIVE_MATRIX_OPERANDS:
+    case SPV_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS:
+    case SPV_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE: {
       uint32_t value;
       if (auto error = grammar.parseMaskOperand(type, textValue, &value)) {
         return context->diagnostic(error)
diff --git a/source/text_handler.cpp b/source/text_handler.cpp
index 35c4b83c..a778c2c1 100644
--- a/source/text_handler.cpp
+++ b/source/text_handler.cpp
@@ -329,8 +329,9 @@ spv_result_t AssemblyContext::recordTypeDefinition(
     types_[value] = {pInst->words[2], pInst->words[3] != 0,
                      IdTypeClass::kScalarIntegerType};
   } else if (pInst->opcode == spv::Op::OpTypeFloat) {
-    if (pInst->words.size() != 3)
+    if ((pInst->words.size() != 3) && (pInst->words.size() != 4))
       return diagnostic() << "Invalid OpTypeFloat instruction";
+    // TODO(kpet) Do we need to record the FP Encoding here?
     types_[value] = {pInst->words[2], false, IdTypeClass::kScalarFloatType};
   } else {
     types_[value] = {0, false, IdTypeClass::kOtherType};
diff --git a/source/to_string.cpp b/source/to_string.cpp
new file mode 100644
index 00000000..b707070b
--- /dev/null
+++ b/source/to_string.cpp
@@ -0,0 +1,44 @@
+// Copyright (c) 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "source/to_string.h"
+
+#include <cassert>
+
+namespace spvtools {
+
+std::string to_string(uint32_t n) {
+  // This implementation avoids using standard library features that access
+  // the locale.  Using the locale requires taking a mutex which causes
+  // annoying serialization.
+
+  constexpr int max_digits = 10;  // max uint has 10 digits
+  // Contains the resulting digits, with least significant digit in the last
+  // entry.
+  char buf[max_digits];
+  int write_index = max_digits - 1;
+  if (n == 0) {
+    buf[write_index] = '0';
+  } else {
+    while (n > 0) {
+      int units = n % 10;
+      buf[write_index--] = "0123456789"[units];
+      n = (n - units) / 10;
+    }
+    write_index++;
+  }
+  assert(write_index >= 0);
+  return std::string(buf + write_index, max_digits - write_index);
+}
+}  // namespace spvtools
diff --git a/source/to_string.h b/source/to_string.h
new file mode 100644
index 00000000..83702f92
--- /dev/null
+++ b/source/to_string.h
@@ -0,0 +1,29 @@
+// Copyright (c) 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef SOURCE_TO_STRING_H_
+#define SOURCE_TO_STRING_H_
+
+#include <cstdint>
+#include <string>
+
+namespace spvtools {
+
+// Returns the decimal representation of a number as a string,
+// without using the locale.
+std::string to_string(uint32_t n);
+
+}  // namespace spvtools
+
+#endif  // SOURCE_TO_STRING_H_
diff --git a/source/util/bitutils.h b/source/util/bitutils.h
index 9ced2f96..2763bc27 100644
--- a/source/util/bitutils.h
+++ b/source/util/bitutils.h
@@ -97,7 +97,7 @@ template <typename T>
 size_t CountSetBits(T word) {
   static_assert(std::is_integral<T>::value,
                 "CountSetBits requires integer type");
-  size_t count = 0;
+  uint32_t count = 0;
   while (word) {
     word &= word - 1;
     ++count;
@@ -181,6 +181,31 @@ T ClearHighBits(T word, size_t num_bits_to_set) {
                     false);
 }
 
+// Returns the value obtained by extracting the |number_of_bits| least
+// significant bits from |value|, and sign-extending it to 64-bits.
+template <typename T>
+T SignExtendValue(T value, uint32_t number_of_bits) {
+  const uint32_t bit_width = sizeof(value) * 8;
+  if (number_of_bits == bit_width) return value;
+
+  bool is_negative = utils::IsBitAtPositionSet(value, number_of_bits - 1);
+  if (is_negative) {
+    value = utils::SetHighBits(value, bit_width - number_of_bits);
+  } else {
+    value = utils::ClearHighBits(value, bit_width - number_of_bits);
+  }
+  return value;
+}
+
+// Returns the value obtained by extracting the |number_of_bits| least
+// significant bits from |value|, and zero-extending it to 64-bits.
+template <typename T>
+T ZeroExtendValue(T value, uint32_t number_of_bits) {
+  const uint32_t bit_width = sizeof(value) * 8;
+  if (number_of_bits == bit_width) return value;
+  return utils::ClearHighBits(value, bit_width - number_of_bits);
+}
+
 }  // namespace utils
 }  // namespace spvtools
 
diff --git a/source/val/decoration.h b/source/val/decoration.h
index 384cc575..77e0f615 100644
--- a/source/val/decoration.h
+++ b/source/val/decoration.h
@@ -15,6 +15,7 @@
 #ifndef SOURCE_VAL_DECORATION_H_
 #define SOURCE_VAL_DECORATION_H_
 
+#include <cassert>
 #include <cstdint>
 #include <unordered_map>
 #include <vector>
@@ -55,6 +56,12 @@ namespace val {
 //              params_ = vector { 2 }
 // struct_member_index_ = 2
 //
+// Example 4: Decoration for a Builtin:
+// OpDecorate %var BuiltIn FragDepth
+//            dec_type_ = spv::Decoration::BuiltIn
+//              params_ = vector { FragDepth }
+// struct_member_index_ = kInvalidMember
+//
 class Decoration {
  public:
   enum { kInvalidMember = -1 };
@@ -68,6 +75,10 @@ class Decoration {
   spv::Decoration dec_type() const { return dec_type_; }
   std::vector<uint32_t>& params() { return params_; }
   const std::vector<uint32_t>& params() const { return params_; }
+  spv::BuiltIn builtin() const {
+    assert(dec_type_ == spv::Decoration::BuiltIn);
+    return spv::BuiltIn(params_[0]);
+  }
 
   inline bool operator<(const Decoration& rhs) const {
     // Note: Sort by struct_member_index_ first, then type, so look up can be
diff --git a/source/val/function.h b/source/val/function.h
index 48117944..c4cd5a46 100644
--- a/source/val/function.h
+++ b/source/val/function.h
@@ -278,7 +278,7 @@ class Function {
   Construct& FindConstructForEntryBlock(const BasicBlock* entry_block,
                                         ConstructType t);
 
-  /// The result id of the OpLabel that defined this block
+  /// The result id of OpFunction
   uint32_t id_;
 
   /// The type of the function
diff --git a/source/val/instruction.h b/source/val/instruction.h
index c524bd37..59e8af13 100644
--- a/source/val/instruction.h
+++ b/source/val/instruction.h
@@ -22,6 +22,7 @@
 #include <vector>
 
 #include "source/ext_inst.h"
+#include "source/opcode.h"
 #include "source/table.h"
 #include "spirv-tools/libspirv.h"
 
@@ -87,13 +88,13 @@ class Instruction {
   }
 
   bool IsNonSemantic() const {
-    return opcode() == spv::Op::OpExtInst &&
+    return spvIsExtendedInstruction(opcode()) &&
            spvExtInstIsNonSemantic(inst_.ext_inst_type);
   }
 
   /// True if this is an OpExtInst for debug info extension.
   bool IsDebugInfo() const {
-    return opcode() == spv::Op::OpExtInst &&
+    return spvIsExtendedInstruction(opcode()) &&
            spvExtInstIsDebugInfo(inst_.ext_inst_type);
   }
 
diff --git a/source/val/validate.cpp b/source/val/validate.cpp
index ccf26fbf..2d10347d 100644
--- a/source/val/validate.cpp
+++ b/source/val/validate.cpp
@@ -144,6 +144,9 @@ spv_result_t ValidateEntryPoints(ValidationState_t& _) {
   if (auto error = ValidateFloatControls2(_)) {
     return error;
   }
+  if (auto error = ValidateDuplicateExecutionModes(_)) {
+    return error;
+  }
 
   return SPV_SUCCESS;
 }
@@ -363,6 +366,7 @@ spv_result_t ValidateBinaryUsingContextAndValidationState(
     if (auto error = RayTracingPass(*vstate, &instruction)) return error;
     if (auto error = RayReorderNVPass(*vstate, &instruction)) return error;
     if (auto error = MeshShadingPass(*vstate, &instruction)) return error;
+    if (auto error = TensorLayoutPass(*vstate, &instruction)) return error;
   }
 
   // Validate the preconditions involving adjacent instructions. e.g.
diff --git a/source/val/validate.h b/source/val/validate.h
index 52267c8a..5514ff73 100644
--- a/source/val/validate.h
+++ b/source/val/validate.h
@@ -94,6 +94,13 @@ spv_result_t ValidateInterfaces(ValidationState_t& _);
 /// @return SPV_SUCCESS if no errors are found.
 spv_result_t ValidateFloatControls2(ValidationState_t& _);
 
+/// @brief Validates duplicated execution modes for each entry point.
+///
+/// @param[in] _ the validation state of the module
+///
+/// @return SPV_SUCCESS if no errors are found.
+spv_result_t ValidateDuplicateExecutionModes(ValidationState_t& _);
+
 /// @brief Validates memory instructions
 ///
 /// @param[in] _ the validation state of the module
@@ -219,6 +226,9 @@ spv_result_t MeshShadingPass(ValidationState_t& _, const Instruction* inst);
 /// Calculates the reachability of basic blocks.
 void ReachabilityPass(ValidationState_t& _);
 
+/// Validates tensor layout and view instructions.
+spv_result_t TensorLayoutPass(ValidationState_t& _, const Instruction* inst);
+
 /// Validates execution limitations.
 ///
 /// Verifies execution models are allowed for all functionality they contain.
diff --git a/source/val/validate_adjacency.cpp b/source/val/validate_adjacency.cpp
index 7e371c2f..52519bfa 100644
--- a/source/val/validate_adjacency.cpp
+++ b/source/val/validate_adjacency.cpp
@@ -52,6 +52,7 @@ spv_result_t ValidateAdjacency(ValidationState_t& _) {
             adjacency_status == IN_NEW_FUNCTION ? IN_ENTRY_BLOCK : PHI_VALID;
         break;
       case spv::Op::OpExtInst:
+      case spv::Op::OpExtInstWithForwardRefsKHR:
         // If it is a debug info instruction, we do not change the status to
         // allow debug info instructions before OpVariable in a function.
         // TODO(https://gitlab.khronos.org/spirv/SPIR-V/issues/533): We need
@@ -116,6 +117,15 @@ spv_result_t ValidateAdjacency(ValidationState_t& _) {
                     "first instructions in the first block.";
         }
         break;
+      case spv::Op::OpUntypedVariableKHR:
+        if (inst.GetOperandAs<spv::StorageClass>(2) ==
+                spv::StorageClass::Function &&
+            adjacency_status != IN_ENTRY_BLOCK) {
+          return _.diag(SPV_ERROR_INVALID_DATA, &inst)
+                 << "All OpUntypedVariableKHR instructions in a function must "
+                    "be the first instructions in the first block.";
+        }
+        break;
       default:
         adjacency_status = PHI_AND_VAR_INVALID;
         break;
diff --git a/source/val/validate_annotation.cpp b/source/val/validate_annotation.cpp
index 106004d0..cf6f96b8 100644
--- a/source/val/validate_annotation.cpp
+++ b/source/val/validate_annotation.cpp
@@ -123,12 +123,14 @@ spv_result_t ValidateDecorationTarget(ValidationState_t& _, spv::Decoration dec,
     case spv::Decoration::ArrayStride:
       if (target->opcode() != spv::Op::OpTypeArray &&
           target->opcode() != spv::Op::OpTypeRuntimeArray &&
-          target->opcode() != spv::Op::OpTypePointer) {
+          target->opcode() != spv::Op::OpTypePointer &&
+          target->opcode() != spv::Op::OpTypeUntypedPointerKHR) {
         return fail(0) << "must be an array or pointer type";
       }
       break;
     case spv::Decoration::BuiltIn:
       if (target->opcode() != spv::Op::OpVariable &&
+          target->opcode() != spv::Op::OpUntypedVariableKHR &&
           !spvOpcodeIsConstant(target->opcode())) {
         return _.diag(SPV_ERROR_INVALID_DATA, inst)
                << "BuiltIns can only target variables, structure members or "
@@ -139,7 +141,8 @@ spv_result_t ValidateDecorationTarget(ValidationState_t& _, spv::Decoration dec,
         if (!spvOpcodeIsConstant(target->opcode())) {
           return fail(0) << "must be a constant for WorkgroupSize";
         }
-      } else if (target->opcode() != spv::Op::OpVariable) {
+      } else if (target->opcode() != spv::Op::OpVariable &&
+                 target->opcode() != spv::Op::OpUntypedVariableKHR) {
         return fail(0) << "must be a variable";
       }
       break;
@@ -161,10 +164,12 @@ spv_result_t ValidateDecorationTarget(ValidationState_t& _, spv::Decoration dec,
     case spv::Decoration::RestrictPointer:
     case spv::Decoration::AliasedPointer:
       if (target->opcode() != spv::Op::OpVariable &&
-          target->opcode() != spv::Op::OpFunctionParameter) {
+          target->opcode() != spv::Op::OpUntypedVariableKHR &&
+          target->opcode() != spv::Op::OpFunctionParameter &&
+          target->opcode() != spv::Op::OpRawAccessChainNV) {
         return fail(0) << "must be a memory object declaration";
       }
-      if (_.GetIdOpcode(target->type_id()) != spv::Op::OpTypePointer) {
+      if (!_.IsPointerType(target->type_id())) {
         return fail(0) << "must be a pointer type";
       }
       break;
@@ -175,7 +180,8 @@ spv_result_t ValidateDecorationTarget(ValidationState_t& _, spv::Decoration dec,
     case spv::Decoration::Binding:
     case spv::Decoration::DescriptorSet:
     case spv::Decoration::InputAttachmentIndex:
-      if (target->opcode() != spv::Op::OpVariable) {
+      if (target->opcode() != spv::Op::OpVariable &&
+          target->opcode() != spv::Op::OpUntypedVariableKHR) {
         return fail(0) << "must be a variable";
       }
       break;
diff --git a/source/val/validate_arithmetics.cpp b/source/val/validate_arithmetics.cpp
index b608a859..8b0049c5 100644
--- a/source/val/validate_arithmetics.cpp
+++ b/source/val/validate_arithmetics.cpp
@@ -62,7 +62,7 @@ spv_result_t ArithmeticsPass(ValidationState_t& _, const Instruction* inst) {
                    << operand_index;
           }
           spv_result_t ret =
-              _.CooperativeMatrixShapesMatch(inst, type_id, result_type);
+              _.CooperativeMatrixShapesMatch(inst, result_type, type_id, false);
           if (ret != SPV_SUCCESS) return ret;
         } else if (_.GetOperandTypeId(inst, operand_index) != result_type)
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
@@ -96,7 +96,7 @@ spv_result_t ArithmeticsPass(ValidationState_t& _, const Instruction* inst) {
                    << operand_index;
           }
           spv_result_t ret =
-              _.CooperativeMatrixShapesMatch(inst, type_id, result_type);
+              _.CooperativeMatrixShapesMatch(inst, result_type, type_id, false);
           if (ret != SPV_SUCCESS) return ret;
         } else if (_.GetOperandTypeId(inst, operand_index) != result_type)
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
@@ -142,7 +142,7 @@ spv_result_t ArithmeticsPass(ValidationState_t& _, const Instruction* inst) {
                    << operand_index;
           }
           spv_result_t ret =
-              _.CooperativeMatrixShapesMatch(inst, type_id, result_type);
+              _.CooperativeMatrixShapesMatch(inst, result_type, type_id, false);
           if (ret != SPV_SUCCESS) return ret;
         }
 
@@ -672,6 +672,128 @@ spv_result_t ArithmeticsPass(ValidationState_t& _, const Instruction* inst) {
       break;
     }
 
+    case spv::Op::OpCooperativeMatrixReduceNV: {
+      if (!_.IsCooperativeMatrixKHRType(result_type)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Result Type must be a cooperative matrix type: "
+               << spvOpcodeString(opcode);
+      }
+
+      const auto result_comp_type_id =
+          _.FindDef(result_type)->GetOperandAs<uint32_t>(1);
+
+      const auto matrix_id = inst->GetOperandAs<uint32_t>(2);
+      const auto matrix = _.FindDef(matrix_id);
+      const auto matrix_type_id = matrix->type_id();
+      if (!_.IsCooperativeMatrixKHRType(matrix_type_id)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Matrix must have a cooperative matrix type: "
+               << spvOpcodeString(opcode);
+      }
+      const auto matrix_type = _.FindDef(matrix_type_id);
+      const auto matrix_comp_type_id = matrix_type->GetOperandAs<uint32_t>(1);
+      if (matrix_comp_type_id != result_comp_type_id) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Result Type and Matrix type must have the same component "
+                  "type: "
+               << spvOpcodeString(opcode);
+      }
+      if (_.FindDef(result_type)->GetOperandAs<uint32_t>(2) !=
+          matrix_type->GetOperandAs<uint32_t>(2)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Result Type and Matrix type must have the same scope: "
+               << spvOpcodeString(opcode);
+      }
+
+      if (!_.IsCooperativeMatrixAccType(result_type)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Result Type must have UseAccumulator: "
+               << spvOpcodeString(opcode);
+      }
+      if (!_.IsCooperativeMatrixAccType(matrix_type_id)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Matrix type must have UseAccumulator: "
+               << spvOpcodeString(opcode);
+      }
+
+      const auto reduce_value = inst->GetOperandAs<uint32_t>(3);
+
+      if ((reduce_value &
+           uint32_t(
+               spv::CooperativeMatrixReduceMask::CooperativeMatrixReduce2x2)) &&
+          (reduce_value & uint32_t(spv::CooperativeMatrixReduceMask::Row |
+                                   spv::CooperativeMatrixReduceMask::Column))) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Reduce 2x2 must not be used with Row/Column: "
+               << spvOpcodeString(opcode);
+      }
+
+      std::tuple<bool, bool, uint32_t> result_rows, result_cols, matrix_rows,
+          matrix_cols;
+      result_rows =
+          _.EvalInt32IfConst(_.FindDef(result_type)->GetOperandAs<uint32_t>(3));
+      result_cols =
+          _.EvalInt32IfConst(_.FindDef(result_type)->GetOperandAs<uint32_t>(4));
+      matrix_rows = _.EvalInt32IfConst(matrix_type->GetOperandAs<uint32_t>(3));
+      matrix_cols = _.EvalInt32IfConst(matrix_type->GetOperandAs<uint32_t>(4));
+
+      if (reduce_value &
+          uint32_t(
+              spv::CooperativeMatrixReduceMask::CooperativeMatrixReduce2x2)) {
+        if (std::get<1>(result_rows) && std::get<1>(result_cols) &&
+            std::get<1>(matrix_rows) && std::get<1>(matrix_cols) &&
+            (std::get<2>(result_rows) != std::get<2>(matrix_rows) / 2 ||
+             std::get<2>(result_cols) != std::get<2>(matrix_cols) / 2)) {
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "For Reduce2x2, result rows/cols must be half of matrix "
+                    "rows/cols: "
+                 << spvOpcodeString(opcode);
+        }
+      }
+      if (reduce_value == uint32_t(spv::CooperativeMatrixReduceMask::Row)) {
+        if (std::get<1>(result_rows) && std::get<1>(matrix_rows) &&
+            std::get<2>(result_rows) != std::get<2>(matrix_rows)) {
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "For ReduceRow, result rows must match matrix rows: "
+                 << spvOpcodeString(opcode);
+        }
+      }
+      if (reduce_value == uint32_t(spv::CooperativeMatrixReduceMask::Column)) {
+        if (std::get<1>(result_cols) && std::get<1>(matrix_cols) &&
+            std::get<2>(result_cols) != std::get<2>(matrix_cols)) {
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "For ReduceColumn, result cols must match matrix cols: "
+                 << spvOpcodeString(opcode);
+        }
+      }
+
+      const auto combine_func_id = inst->GetOperandAs<uint32_t>(4);
+      const auto combine_func = _.FindDef(combine_func_id);
+      if (!combine_func || combine_func->opcode() != spv::Op::OpFunction) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "CombineFunc must be a function: " << spvOpcodeString(opcode);
+      }
+      const auto function_type_id = combine_func->GetOperandAs<uint32_t>(3);
+      const auto function_type = _.FindDef(function_type_id);
+      if (function_type->operands().size() != 4) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "CombineFunc must have two parameters: "
+               << spvOpcodeString(opcode);
+      }
+      for (uint32_t i = 0; i < 3; ++i) {
+        // checks return type and two params
+        const auto param_type_id = function_type->GetOperandAs<uint32_t>(i + 1);
+        if (param_type_id != matrix_comp_type_id) {
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "CombineFunc return type and parameters must match matrix "
+                    "component type: "
+                 << spvOpcodeString(opcode);
+        }
+      }
+
+      break;
+    }
+
     default:
       break;
   }
diff --git a/source/val/validate_atomics.cpp b/source/val/validate_atomics.cpp
index b745a9ec..990ed315 100644
--- a/source/val/validate_atomics.cpp
+++ b/source/val/validate_atomics.cpp
@@ -144,12 +144,13 @@ spv_result_t AtomicsPass(ValidationState_t& _, const Instruction* inst) {
     case spv::Op::OpAtomicFlagClear: {
       const uint32_t result_type = inst->type_id();
 
-      // All current atomics only are scalar result
       // Validate return type first so can just check if pointer type is same
       // (if applicable)
       if (HasReturnType(opcode)) {
         if (HasOnlyFloatReturnType(opcode) &&
-            !_.IsFloatScalarType(result_type)) {
+            (!(_.HasCapability(spv::Capability::AtomicFloat16VectorNV) &&
+               _.IsFloat16Vector2Or4Type(result_type)) &&
+             !_.IsFloatScalarType(result_type))) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << spvOpcodeString(opcode)
                  << ": expected Result Type to be float scalar type";
@@ -160,6 +161,9 @@ spv_result_t AtomicsPass(ValidationState_t& _, const Instruction* inst) {
                  << ": expected Result Type to be integer scalar type";
         } else if (HasIntOrFloatReturnType(opcode) &&
                    !_.IsFloatScalarType(result_type) &&
+                   !(opcode == spv::Op::OpAtomicExchange &&
+                     _.HasCapability(spv::Capability::AtomicFloat16VectorNV) &&
+                     _.IsFloat16Vector2Or4Type(result_type)) &&
                    !_.IsIntScalarType(result_type)) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << spvOpcodeString(opcode)
@@ -179,7 +183,44 @@ spv_result_t AtomicsPass(ValidationState_t& _, const Instruction* inst) {
       if (!_.GetPointerTypeInfo(pointer_type, &data_type, &storage_class)) {
         return _.diag(SPV_ERROR_INVALID_DATA, inst)
                << spvOpcodeString(opcode)
-               << ": expected Pointer to be of type OpTypePointer";
+               << ": expected Pointer to be a pointer type";
+      }
+
+      // If the pointer is an untyped pointer, get the data type elsewhere.
+      if (data_type == 0) {
+        switch (opcode) {
+          case spv::Op::OpAtomicLoad:
+          case spv::Op::OpAtomicExchange:
+          case spv::Op::OpAtomicFAddEXT:
+          case spv::Op::OpAtomicCompareExchange:
+          case spv::Op::OpAtomicCompareExchangeWeak:
+          case spv::Op::OpAtomicIIncrement:
+          case spv::Op::OpAtomicIDecrement:
+          case spv::Op::OpAtomicIAdd:
+          case spv::Op::OpAtomicISub:
+          case spv::Op::OpAtomicSMin:
+          case spv::Op::OpAtomicUMin:
+          case spv::Op::OpAtomicFMinEXT:
+          case spv::Op::OpAtomicSMax:
+          case spv::Op::OpAtomicUMax:
+          case spv::Op::OpAtomicFMaxEXT:
+          case spv::Op::OpAtomicAnd:
+          case spv::Op::OpAtomicOr:
+          case spv::Op::OpAtomicXor:
+            data_type = inst->type_id();
+            break;
+          case spv::Op::OpAtomicFlagTestAndSet:
+          case spv::Op::OpAtomicFlagClear:
+            return _.diag(SPV_ERROR_INVALID_ID, inst)
+                   << "Untyped pointers are not supported by atomic flag "
+                      "instructions";
+            break;
+          case spv::Op::OpAtomicStore:
+            data_type = _.FindDef(inst->GetOperandAs<uint32_t>(3))->type_id();
+            break;
+          default:
+            break;
+        }
       }
 
       // Can't use result_type because OpAtomicStore doesn't have a result
@@ -222,12 +263,21 @@ spv_result_t AtomicsPass(ValidationState_t& _, const Instruction* inst) {
 
         if (opcode == spv::Op::OpAtomicFAddEXT) {
           // result type being float checked already
-          if ((_.GetBitWidth(result_type) == 16) &&
-              (!_.HasCapability(spv::Capability::AtomicFloat16AddEXT))) {
-            return _.diag(SPV_ERROR_INVALID_DATA, inst)
-                   << spvOpcodeString(opcode)
-                   << ": float add atomics require the AtomicFloat32AddEXT "
-                      "capability";
+          if (_.GetBitWidth(result_type) == 16) {
+            if (_.IsFloat16Vector2Or4Type(result_type)) {
+              if (!_.HasCapability(spv::Capability::AtomicFloat16VectorNV))
+                return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                       << spvOpcodeString(opcode)
+                       << ": float vector atomics require the "
+                          "AtomicFloat16VectorNV capability";
+            } else {
+              if (!_.HasCapability(spv::Capability::AtomicFloat16AddEXT)) {
+                return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                       << spvOpcodeString(opcode)
+                       << ": float add atomics require the AtomicFloat32AddEXT "
+                          "capability";
+              }
+            }
           }
           if ((_.GetBitWidth(result_type) == 32) &&
               (!_.HasCapability(spv::Capability::AtomicFloat32AddEXT))) {
@@ -245,12 +295,21 @@ spv_result_t AtomicsPass(ValidationState_t& _, const Instruction* inst) {
           }
         } else if (opcode == spv::Op::OpAtomicFMinEXT ||
                    opcode == spv::Op::OpAtomicFMaxEXT) {
-          if ((_.GetBitWidth(result_type) == 16) &&
-              (!_.HasCapability(spv::Capability::AtomicFloat16MinMaxEXT))) {
-            return _.diag(SPV_ERROR_INVALID_DATA, inst)
-                   << spvOpcodeString(opcode)
-                   << ": float min/max atomics require the "
-                      "AtomicFloat16MinMaxEXT capability";
+          if (_.GetBitWidth(result_type) == 16) {
+            if (_.IsFloat16Vector2Or4Type(result_type)) {
+              if (!_.HasCapability(spv::Capability::AtomicFloat16VectorNV))
+                return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                       << spvOpcodeString(opcode)
+                       << ": float vector atomics require the "
+                          "AtomicFloat16VectorNV capability";
+            } else {
+              if (!_.HasCapability(spv::Capability::AtomicFloat16MinMaxEXT)) {
+                return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                       << spvOpcodeString(opcode)
+                       << ": float min/max atomics require the "
+                          "AtomicFloat16MinMaxEXT capability";
+              }
+            }
           }
           if ((_.GetBitWidth(result_type) == 32) &&
               (!_.HasCapability(spv::Capability::AtomicFloat32MinMaxEXT))) {
diff --git a/source/val/validate_builtins.cpp b/source/val/validate_builtins.cpp
index 42fbc52a..1305dc1f 100644
--- a/source/val/validate_builtins.cpp
+++ b/source/val/validate_builtins.cpp
@@ -97,12 +97,16 @@ spv_result_t GetUnderlyingType(ValidationState_t& _,
 spv::StorageClass GetStorageClass(const Instruction& inst) {
   switch (inst.opcode()) {
     case spv::Op::OpTypePointer:
+    case spv::Op::OpTypeUntypedPointerKHR:
     case spv::Op::OpTypeForwardPointer: {
       return spv::StorageClass(inst.word(2));
     }
     case spv::Op::OpVariable: {
       return spv::StorageClass(inst.word(3));
     }
+    case spv::Op::OpUntypedVariableKHR: {
+      return spv::StorageClass(inst.word(4));
+    }
     case spv::Op::OpGenericCastToPtrExplicit: {
       return spv::StorageClass(inst.word(4));
     }
@@ -741,7 +745,7 @@ std::string BuiltInsValidator::GetReferenceDesc(
 
   ss << " which is decorated with BuiltIn ";
   ss << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                      decoration.params()[0]);
+                                      (uint32_t)decoration.builtin());
   if (function_id_) {
     ss << " in function <" << function_id_ << ">";
     if (execution_model != spv::ExecutionModel::Max) {
@@ -1120,7 +1124,7 @@ spv_result_t BuiltInsValidator::ValidateF32ArrHelper(
 
   if (num_components != 0) {
     uint64_t actual_num_components = 0;
-    if (!_.GetConstantValUint64(type_inst->word(3), &actual_num_components)) {
+    if (!_.EvalConstantValUint64(type_inst->word(3), &actual_num_components)) {
       assert(0 && "Array type definition is corrupt");
     }
     if (actual_num_components != num_components) {
@@ -1170,7 +1174,7 @@ spv_result_t BuiltInsValidator::ValidateNotCalledWithExecutionModel(
       const char* execution_model_str = _.grammar().lookupOperandName(
           SPV_OPERAND_TYPE_EXECUTION_MODEL, uint32_t(execution_model));
       const char* built_in_str = _.grammar().lookupOperandName(
-          SPV_OPERAND_TYPE_BUILT_IN, decoration.params()[0]);
+          SPV_OPERAND_TYPE_BUILT_IN, (uint32_t)decoration.builtin());
       return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
              << (vuid < 0 ? std::string("") : _.VkErrorID(vuid)) << comment
              << " " << GetIdDesc(referenced_inst) << " depends on "
@@ -1201,13 +1205,14 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input &&
         storage_class != spv::StorageClass::Output) {
-      uint32_t vuid = (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance) ? 4190 : 4199;
+      uint32_t vuid =
+          (decoration.builtin() == spv::BuiltIn::ClipDistance) ? 4190 : 4199;
       return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
              << _.VkErrorID(vuid) << "Vulkan spec allows BuiltIn "
              << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
@@ -1221,7 +1226,8 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
 
     if (storage_class == spv::StorageClass::Input) {
       assert(function_id_ == 0);
-      uint32_t vuid = (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance) ? 4188 : 4197;
+      uint32_t vuid =
+          (decoration.builtin() == spv::BuiltIn::ClipDistance) ? 4188 : 4197;
       id_to_at_reference_checks_[referenced_from_inst.id()].push_back(std::bind(
           &BuiltInsValidator::ValidateNotCalledWithExecutionModel, this, vuid,
           "Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be "
@@ -1247,7 +1253,8 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
 
     if (storage_class == spv::StorageClass::Output) {
       assert(function_id_ == 0);
-      uint32_t vuid = (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance) ? 4189 : 4198;
+      uint32_t vuid =
+          (decoration.builtin() == spv::BuiltIn::ClipDistance) ? 4189 : 4198;
       id_to_at_reference_checks_[referenced_from_inst.id()].push_back(std::bind(
           &BuiltInsValidator::ValidateNotCalledWithExecutionModel, this, vuid,
           "Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be "
@@ -1266,7 +1273,7 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
                   [this, &decoration, &referenced_from_inst](
                       const std::string& message) -> spv_result_t {
                     uint32_t vuid =
-                        (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance)
+                        (decoration.builtin() == spv::BuiltIn::ClipDistance)
                             ? 4191
                             : 4200;
                     return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
@@ -1274,7 +1281,7 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
                            << "According to the Vulkan spec BuiltIn "
                            << _.grammar().lookupOperandName(
                                   SPV_OPERAND_TYPE_BUILT_IN,
-                                  decoration.params()[0])
+                                  (uint32_t)decoration.builtin())
                            << " variable needs to be a 32-bit float array. "
                            << message;
                   })) {
@@ -1294,7 +1301,7 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
                     [this, &decoration, &referenced_from_inst](
                         const std::string& message) -> spv_result_t {
                       uint32_t vuid =
-                          (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance)
+                          (decoration.builtin() == spv::BuiltIn::ClipDistance)
                               ? 4191
                               : 4200;
                       return _.diag(SPV_ERROR_INVALID_DATA,
@@ -1303,7 +1310,7 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
                              << "According to the Vulkan spec BuiltIn "
                              << _.grammar().lookupOperandName(
                                     SPV_OPERAND_TYPE_BUILT_IN,
-                                    decoration.params()[0])
+                                    (uint32_t)decoration.builtin())
                              << " variable needs to be a 32-bit float array. "
                              << message;
                     })) {
@@ -1315,7 +1322,7 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
                     [this, &decoration, &referenced_from_inst](
                         const std::string& message) -> spv_result_t {
                       uint32_t vuid =
-                          (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance)
+                          (decoration.builtin() == spv::BuiltIn::ClipDistance)
                               ? 4191
                               : 4200;
                       return _.diag(SPV_ERROR_INVALID_DATA,
@@ -1324,7 +1331,7 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
                              << "According to the Vulkan spec BuiltIn "
                              << _.grammar().lookupOperandName(
                                     SPV_OPERAND_TYPE_BUILT_IN,
-                                    decoration.params()[0])
+                                    (uint32_t)decoration.builtin())
                              << " variable needs to be a 32-bit float array. "
                              << message;
                     })) {
@@ -1335,8 +1342,9 @@ spv_result_t BuiltInsValidator::ValidateClipOrCullDistanceAtReference(
         }
 
         default: {
-          uint32_t vuid =
-              (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::ClipDistance) ? 4187 : 4196;
+          uint32_t vuid = (decoration.builtin() == spv::BuiltIn::ClipDistance)
+                              ? 4187
+                              : 4196;
           return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
                  << _.VkErrorID(vuid) << "Vulkan spec allows BuiltIn "
                  << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
@@ -2542,7 +2550,7 @@ spv_result_t BuiltInsValidator::ValidateTessLevelAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -2561,7 +2569,8 @@ spv_result_t BuiltInsValidator::ValidateTessLevelAtReference(
 
     if (storage_class == spv::StorageClass::Input) {
       assert(function_id_ == 0);
-      uint32_t vuid = (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::TessLevelOuter) ? 4391 : 4395;
+      uint32_t vuid =
+          (decoration.builtin() == spv::BuiltIn::TessLevelOuter) ? 4391 : 4395;
       id_to_at_reference_checks_[referenced_from_inst.id()].push_back(std::bind(
           &BuiltInsValidator::ValidateNotCalledWithExecutionModel, this, vuid,
           "Vulkan spec doesn't allow TessLevelOuter/TessLevelInner to be "
@@ -2574,7 +2583,8 @@ spv_result_t BuiltInsValidator::ValidateTessLevelAtReference(
 
     if (storage_class == spv::StorageClass::Output) {
       assert(function_id_ == 0);
-      uint32_t vuid = (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::TessLevelOuter) ? 4392 : 4396;
+      uint32_t vuid =
+          (decoration.builtin() == spv::BuiltIn::TessLevelOuter) ? 4392 : 4396;
       id_to_at_reference_checks_[referenced_from_inst.id()].push_back(std::bind(
           &BuiltInsValidator::ValidateNotCalledWithExecutionModel, this, vuid,
           "Vulkan spec doesn't allow TessLevelOuter/TessLevelInner to be "
@@ -2724,12 +2734,13 @@ spv_result_t BuiltInsValidator::ValidateLayerOrViewportIndexAtDefinition(
               [this, &decoration,
                &inst](const std::string& message) -> spv_result_t {
                 uint32_t vuid =
-                    (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::Layer) ? 4276 : 4408;
+                    (decoration.builtin() == spv::BuiltIn::Layer) ? 4276 : 4408;
                 return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                        << _.VkErrorID(vuid)
                        << "According to the Vulkan spec BuiltIn "
                        << _.grammar().lookupOperandName(
-                              SPV_OPERAND_TYPE_BUILT_IN, decoration.params()[0])
+                              SPV_OPERAND_TYPE_BUILT_IN,
+                              (uint32_t)decoration.builtin())
                        << "variable needs to be a 32-bit int scalar. "
                        << message;
               })) {
@@ -2741,12 +2752,13 @@ spv_result_t BuiltInsValidator::ValidateLayerOrViewportIndexAtDefinition(
               [this, &decoration,
                &inst](const std::string& message) -> spv_result_t {
                 uint32_t vuid =
-                    (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::Layer) ? 4276 : 4408;
+                    (decoration.builtin() == spv::BuiltIn::Layer) ? 4276 : 4408;
                 return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                        << _.VkErrorID(vuid)
                        << "According to the Vulkan spec BuiltIn "
                        << _.grammar().lookupOperandName(
-                              SPV_OPERAND_TYPE_BUILT_IN, decoration.params()[0])
+                              SPV_OPERAND_TYPE_BUILT_IN,
+                              (uint32_t)decoration.builtin())
                        << "variable needs to be a 32-bit int scalar. "
                        << message;
               })) {
@@ -2763,7 +2775,7 @@ spv_result_t BuiltInsValidator::ValidateLayerOrViewportIndexAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -2877,7 +2889,7 @@ spv_result_t BuiltInsValidator::ValidateLayerOrViewportIndexAtReference(
 spv_result_t BuiltInsValidator::ValidateFragmentShaderF32Vec3InputAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (spv_result_t error = ValidateF32Vec(
             decoration, inst, 3,
             [this, &inst, builtin](const std::string& message) -> spv_result_t {
@@ -2907,7 +2919,7 @@ spv_result_t BuiltInsValidator::ValidateFragmentShaderF32Vec3InputAtReference(
     const Instruction& referenced_from_inst) {
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -2951,7 +2963,7 @@ spv_result_t BuiltInsValidator::ValidateFragmentShaderF32Vec3InputAtReference(
 spv_result_t BuiltInsValidator::ValidateComputeShaderI32Vec3InputAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (spv_result_t error = ValidateI32Vec(
             decoration, inst, 3,
             [this, &inst, builtin](const std::string& message) -> spv_result_t {
@@ -2980,7 +2992,7 @@ spv_result_t BuiltInsValidator::ValidateComputeShaderI32Vec3InputAtReference(
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -3031,7 +3043,7 @@ spv_result_t BuiltInsValidator::ValidateComputeShaderI32Vec3InputAtReference(
 spv_result_t BuiltInsValidator::ValidateComputeI32InputAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (decoration.struct_member_index() != Decoration::kInvalidMember) {
       return _.diag(SPV_ERROR_INVALID_DATA, &inst)
              << "BuiltIn "
@@ -3065,7 +3077,7 @@ spv_result_t BuiltInsValidator::ValidateComputeI32InputAtReference(
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -3116,7 +3128,7 @@ spv_result_t BuiltInsValidator::ValidateComputeI32InputAtReference(
 spv_result_t BuiltInsValidator::ValidateI32InputAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (decoration.struct_member_index() != Decoration::kInvalidMember) {
       return _.diag(SPV_ERROR_INVALID_DATA, &inst)
              << "BuiltIn "
@@ -3159,7 +3171,7 @@ spv_result_t BuiltInsValidator::ValidateI32InputAtDefinition(
 spv_result_t BuiltInsValidator::ValidateI32Vec4InputAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (decoration.struct_member_index() != Decoration::kInvalidMember) {
       return _.diag(SPV_ERROR_INVALID_DATA, &inst)
              << "BuiltIn "
@@ -3247,7 +3259,7 @@ spv_result_t BuiltInsValidator::ValidateWorkgroupSizeAtReference(
                << spvLogStringForEnv(_.context()->target_env)
                << " spec allows BuiltIn "
                << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                decoration.params()[0])
+                                                (uint32_t)decoration.builtin())
                << " to be used only with GLCompute, MeshNV, TaskNV, MeshEXT or "
                << "TaskEXT execution model. "
                << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
@@ -3273,14 +3285,15 @@ spv_result_t BuiltInsValidator::ValidateBaseInstanceOrVertexAtDefinition(
             decoration, inst,
             [this, &inst,
              &decoration](const std::string& message) -> spv_result_t {
-              uint32_t vuid = (spv::BuiltIn(decoration.params()[0]) == spv::BuiltIn::BaseInstance)
-                                  ? 4183
-                                  : 4186;
+              uint32_t vuid =
+                  (decoration.builtin() == spv::BuiltIn::BaseInstance) ? 4183
+                                                                       : 4186;
               return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                      << _.VkErrorID(vuid)
                      << "According to the Vulkan spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3295,7 +3308,7 @@ spv_result_t BuiltInsValidator::ValidateBaseInstanceOrVertexAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -3346,8 +3359,9 @@ spv_result_t BuiltInsValidator::ValidateDrawIndexAtDefinition(
               return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                      << _.VkErrorID(4209)
                      << "According to the Vulkan spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3362,7 +3376,7 @@ spv_result_t BuiltInsValidator::ValidateDrawIndexAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -3416,8 +3430,9 @@ spv_result_t BuiltInsValidator::ValidateViewIndexAtDefinition(
               return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                      << _.VkErrorID(4403)
                      << "According to the Vulkan spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3432,7 +3447,7 @@ spv_result_t BuiltInsValidator::ValidateViewIndexAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -3480,8 +3495,9 @@ spv_result_t BuiltInsValidator::ValidateDeviceIndexAtDefinition(
               return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                      << _.VkErrorID(4206)
                      << "According to the Vulkan spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3496,7 +3512,7 @@ spv_result_t BuiltInsValidator::ValidateDeviceIndexAtReference(
     const Decoration& decoration, const Instruction& built_in_inst,
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
-  uint32_t operand = decoration.params()[0];
+  uint32_t operand = (uint32_t)decoration.builtin();
   if (spvIsVulkanEnv(_.context()->target_env)) {
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -3526,7 +3542,7 @@ spv_result_t BuiltInsValidator::ValidateFragInvocationCountAtDefinition(const De
                                             const Instruction& inst) {
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (spv_result_t error = ValidateI32(
             decoration, inst,
             [this, &inst, &builtin](const std::string& message) -> spv_result_t {
@@ -3553,7 +3569,7 @@ spv_result_t BuiltInsValidator::ValidateFragInvocationCountAtReference(
     const Instruction& referenced_from_inst) {
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -3596,7 +3612,7 @@ spv_result_t BuiltInsValidator::ValidateFragInvocationCountAtReference(
 spv_result_t BuiltInsValidator::ValidateFragSizeAtDefinition(const Decoration& decoration,
                                             const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (spv_result_t error = ValidateI32Vec(
             decoration, inst, 2,
             [this, &inst, &builtin](const std::string& message) -> spv_result_t {
@@ -3623,7 +3639,7 @@ spv_result_t BuiltInsValidator::ValidateFragSizeAtReference(
     const Instruction& referenced_from_inst) {
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -3666,7 +3682,7 @@ spv_result_t BuiltInsValidator::ValidateFragSizeAtReference(
 spv_result_t BuiltInsValidator::ValidateFragStencilRefAtDefinition(const Decoration& decoration,
                                             const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (spv_result_t error = ValidateI(
             decoration, inst,
             [this, &inst, &builtin](const std::string& message) -> spv_result_t {
@@ -3693,7 +3709,7 @@ spv_result_t BuiltInsValidator::ValidateFragStencilRefAtReference(
     const Instruction& referenced_from_inst) {
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Output) {
@@ -3736,7 +3752,7 @@ spv_result_t BuiltInsValidator::ValidateFragStencilRefAtReference(
 spv_result_t BuiltInsValidator::ValidateFullyCoveredAtDefinition(const Decoration& decoration,
                                                const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     if (spv_result_t error = ValidateBool(
             decoration, inst,
             [this, &inst, &builtin](const std::string& message) -> spv_result_t {
@@ -3763,7 +3779,7 @@ spv_result_t BuiltInsValidator::ValidateFullyCoveredAtReference(
     const Instruction& referenced_from_inst) {
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -3814,8 +3830,9 @@ spv_result_t BuiltInsValidator::ValidateNVSMOrARMCoreBuiltinsAtDefinition(
                      << "According to the "
                      << spvLogStringForEnv(_.context()->target_env)
                      << " spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3839,7 +3856,7 @@ spv_result_t BuiltInsValidator::ValidateNVSMOrARMCoreBuiltinsAtReference(
              << spvLogStringForEnv(_.context()->target_env)
              << " spec allows BuiltIn "
              << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                              decoration.params()[0])
+                                              (uint32_t)decoration.builtin())
              << " to be only used for "
                 "variables with Input storage class. "
              << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
@@ -3868,8 +3885,9 @@ spv_result_t BuiltInsValidator::ValidatePrimitiveShadingRateAtDefinition(
               return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                      << _.VkErrorID(4486)
                      << "According to the Vulkan spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3892,7 +3910,7 @@ spv_result_t BuiltInsValidator::ValidatePrimitiveShadingRateAtReference(
       return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
              << _.VkErrorID(4485) << "Vulkan spec allows BuiltIn "
              << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                              decoration.params()[0])
+                                              (uint32_t)decoration.builtin())
              << " to be only used for variables with Output storage class. "
              << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
                                  referenced_from_inst)
@@ -3909,8 +3927,9 @@ spv_result_t BuiltInsValidator::ValidatePrimitiveShadingRateAtReference(
         default: {
           return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
                  << _.VkErrorID(4484) << "Vulkan spec allows BuiltIn "
-                 << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                  decoration.params()[0])
+                 << _.grammar().lookupOperandName(
+                        SPV_OPERAND_TYPE_BUILT_IN,
+                        (uint32_t)decoration.builtin())
                  << " to be used only with Vertex, Geometry, or MeshNV "
                     "execution models. "
                  << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
@@ -3941,8 +3960,9 @@ spv_result_t BuiltInsValidator::ValidateShadingRateAtDefinition(
               return _.diag(SPV_ERROR_INVALID_DATA, &inst)
                      << _.VkErrorID(4492)
                      << "According to the Vulkan spec BuiltIn "
-                     << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                      decoration.params()[0])
+                     << _.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN,
+                            (uint32_t)decoration.builtin())
                      << " variable needs to be a 32-bit int scalar. "
                      << message;
             })) {
@@ -3965,7 +3985,7 @@ spv_result_t BuiltInsValidator::ValidateShadingRateAtReference(
       return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
              << _.VkErrorID(4491) << "Vulkan spec allows BuiltIn "
              << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                              decoration.params()[0])
+                                              (uint32_t)decoration.builtin())
              << " to be only used for variables with Input storage class. "
              << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
                                  referenced_from_inst)
@@ -3977,7 +3997,7 @@ spv_result_t BuiltInsValidator::ValidateShadingRateAtReference(
         return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
                << _.VkErrorID(4490) << "Vulkan spec allows BuiltIn "
                << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                decoration.params()[0])
+                                                (uint32_t)decoration.builtin())
                << " to be used only with the Fragment execution model. "
                << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
                                    referenced_from_inst, execution_model);
@@ -3998,7 +4018,7 @@ spv_result_t BuiltInsValidator::ValidateShadingRateAtReference(
 spv_result_t BuiltInsValidator::ValidateRayTracingBuiltinsAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     switch (builtin) {
       case spv::BuiltIn::HitTNV:
       case spv::BuiltIn::RayTminKHR:
@@ -4121,7 +4141,7 @@ spv_result_t BuiltInsValidator::ValidateRayTracingBuiltinsAtReference(
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class = GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
         storage_class != spv::StorageClass::Input) {
@@ -4129,7 +4149,7 @@ spv_result_t BuiltInsValidator::ValidateRayTracingBuiltinsAtReference(
       return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
              << _.VkErrorID(vuid) << "Vulkan spec allows BuiltIn "
              << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                              decoration.params()[0])
+                                              (uint32_t)decoration.builtin())
              << " to be only used for variables with Input storage class. "
              << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
                                  referenced_from_inst)
@@ -4142,10 +4162,11 @@ spv_result_t BuiltInsValidator::ValidateRayTracingBuiltinsAtReference(
         return _.diag(SPV_ERROR_INVALID_DATA, &referenced_from_inst)
                << _.VkErrorID(vuid) << "Vulkan spec does not allow BuiltIn "
                << _.grammar().lookupOperandName(SPV_OPERAND_TYPE_BUILT_IN,
-                                                decoration.params()[0])
+                                                (uint32_t)decoration.builtin())
                << " to be used with the execution model "
                << _.grammar().lookupOperandName(
-                      SPV_OPERAND_TYPE_EXECUTION_MODEL, uint32_t(execution_model))
+                      SPV_OPERAND_TYPE_EXECUTION_MODEL,
+                      uint32_t(execution_model))
                << ".\n"
                << GetReferenceDesc(decoration, built_in_inst, referenced_inst,
                                    referenced_from_inst, execution_model);
@@ -4167,7 +4188,7 @@ spv_result_t BuiltInsValidator::ValidateRayTracingBuiltinsAtReference(
 spv_result_t BuiltInsValidator::ValidateMeshShadingEXTBuiltinsAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     uint32_t vuid = GetVUIDForBuiltin(builtin, VUIDErrorType);
     if (builtin == spv::BuiltIn::PrimitivePointIndicesEXT) {
       if (spv_result_t error = ValidateI32Arr(
@@ -4179,7 +4200,8 @@ spv_result_t BuiltInsValidator::ValidateMeshShadingEXTBuiltinsAtDefinition(
                        << spvLogStringForEnv(_.context()->target_env)
                        << " spec BuiltIn "
                        << _.grammar().lookupOperandName(
-                              SPV_OPERAND_TYPE_BUILT_IN, decoration.params()[0])
+                              SPV_OPERAND_TYPE_BUILT_IN,
+                              (uint32_t)decoration.builtin())
                        << " variable needs to be a 32-bit int array."
                        << message;
               })) {
@@ -4196,7 +4218,8 @@ spv_result_t BuiltInsValidator::ValidateMeshShadingEXTBuiltinsAtDefinition(
                        << spvLogStringForEnv(_.context()->target_env)
                        << " spec BuiltIn "
                        << _.grammar().lookupOperandName(
-                              SPV_OPERAND_TYPE_BUILT_IN, decoration.params()[0])
+                              SPV_OPERAND_TYPE_BUILT_IN,
+                              (uint32_t)decoration.builtin())
                        << " variable needs to be a 2-component 32-bit int "
                           "array."
                        << message;
@@ -4214,7 +4237,8 @@ spv_result_t BuiltInsValidator::ValidateMeshShadingEXTBuiltinsAtDefinition(
                        << spvLogStringForEnv(_.context()->target_env)
                        << " spec BuiltIn "
                        << _.grammar().lookupOperandName(
-                              SPV_OPERAND_TYPE_BUILT_IN, decoration.params()[0])
+                              SPV_OPERAND_TYPE_BUILT_IN,
+                              (uint32_t)decoration.builtin())
                        << " variable needs to be a 3-component 32-bit int "
                           "array."
                        << message;
@@ -4233,7 +4257,7 @@ spv_result_t BuiltInsValidator::ValidateMeshShadingEXTBuiltinsAtReference(
     const Instruction& referenced_inst,
     const Instruction& referenced_from_inst) {
   if (spvIsVulkanEnv(_.context()->target_env)) {
-    const spv::BuiltIn builtin = spv::BuiltIn(decoration.params()[0]);
+    const spv::BuiltIn builtin = decoration.builtin();
     const spv::StorageClass storage_class =
         GetStorageClass(referenced_from_inst);
     if (storage_class != spv::StorageClass::Max &&
@@ -4279,7 +4303,7 @@ spv_result_t BuiltInsValidator::ValidateMeshShadingEXTBuiltinsAtReference(
 
 spv_result_t BuiltInsValidator::ValidateSingleBuiltInAtDefinition(
     const Decoration& decoration, const Instruction& inst) {
-  const spv::BuiltIn label = spv::BuiltIn(decoration.params()[0]);
+  const spv::BuiltIn label = decoration.builtin();
 
   if (!spvIsVulkanEnv(_.context()->target_env)) {
     // Early return. All currently implemented rules are based on Vulkan spec.
diff --git a/source/val/validate_cfg.cpp b/source/val/validate_cfg.cpp
index 9b7161fc..b7e570de 100644
--- a/source/val/validate_cfg.cpp
+++ b/source/val/validate_cfg.cpp
@@ -250,7 +250,8 @@ spv_result_t ValidateReturnValue(ValidationState_t& _,
   }
 
   if (_.addressing_model() == spv::AddressingModel::Logical &&
-      spv::Op::OpTypePointer == value_type->opcode() &&
+      (spv::Op::OpTypePointer == value_type->opcode() ||
+       spv::Op::OpTypeUntypedPointerKHR == value_type->opcode()) &&
       !_.features().variable_pointers && !_.options()->relax_logical_pointer) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "OpReturnValue value's type <id> "
@@ -467,13 +468,13 @@ std::string ConstructErrorString(const Construct& construct,
 // headed by |target_block| branches to multiple case constructs.
 spv_result_t FindCaseFallThrough(
     ValidationState_t& _, BasicBlock* target_block, uint32_t* case_fall_through,
-    const BasicBlock* merge, const std::unordered_set<uint32_t>& case_targets,
-    Function* function) {
+    const Construct& switch_construct,
+    const std::unordered_set<uint32_t>& case_targets) {
+  const auto* merge = switch_construct.exit_block();
   std::vector<BasicBlock*> stack;
   stack.push_back(target_block);
   std::unordered_set<const BasicBlock*> visited;
   bool target_reachable = target_block->structurally_reachable();
-  int target_depth = function->GetBlockDepth(target_block);
   while (!stack.empty()) {
     auto block = stack.back();
     stack.pop_back();
@@ -491,9 +492,14 @@ spv_result_t FindCaseFallThrough(
     } else {
       // Exiting the case construct to non-merge block.
       if (!case_targets.count(block->id())) {
-        int depth = function->GetBlockDepth(block);
-        if ((depth < target_depth) ||
-            (depth == target_depth && block->is_type(kBlockTypeContinue))) {
+        // We have already filtered out the following:
+        //  * The switch's merge
+        //  * Other case targets
+        //  * Blocks in the same case construct
+        //
+        // So the only remaining valid branches are the structured exits from
+        // the overall selection construct of the switch.
+        if (switch_construct.IsStructuredExit(_, block)) {
           continue;
         }
 
@@ -525,9 +531,10 @@ spv_result_t FindCaseFallThrough(
 }
 
 spv_result_t StructuredSwitchChecks(ValidationState_t& _, Function* function,
-                                    const Instruction* switch_inst,
-                                    const BasicBlock* header,
-                                    const BasicBlock* merge) {
+                                    const Construct& switch_construct) {
+  const auto* header = switch_construct.entry_block();
+  const auto* merge = switch_construct.exit_block();
+  const auto* switch_inst = header->terminator();
   std::unordered_set<uint32_t> case_targets;
   for (uint32_t i = 1; i < switch_inst->operands().size(); i += 2) {
     uint32_t target = switch_inst->GetOperandAs<uint32_t>(i);
@@ -545,6 +552,7 @@ spv_result_t StructuredSwitchChecks(ValidationState_t& _, Function* function,
       break;
     }
   }
+
   std::unordered_map<uint32_t, uint32_t> seen_to_fall_through;
   for (uint32_t i = 1; i < switch_inst->operands().size(); i += 2) {
     uint32_t target = switch_inst->GetOperandAs<uint32_t>(i);
@@ -565,7 +573,7 @@ spv_result_t StructuredSwitchChecks(ValidationState_t& _, Function* function,
       }
 
       if (auto error = FindCaseFallThrough(_, target_block, &case_fall_through,
-                                           merge, case_targets, function)) {
+                                           switch_construct, case_targets)) {
         return error;
       }
 
@@ -838,6 +846,9 @@ spv_result_t StructuredControlFlowChecks(
       const auto* continue_target = next_inst.block();
       if (header->id() != continue_id) {
         for (auto pred : *continue_target->predecessors()) {
+          if (!pred->structurally_reachable()) {
+            continue;
+          }
           // Ignore back-edges from within the continue construct.
           bool is_back_edge = false;
           for (auto back_edge : back_edges) {
@@ -862,9 +873,7 @@ spv_result_t StructuredControlFlowChecks(
     // Checks rules for case constructs.
     if (construct.type() == ConstructType::kSelection &&
         header->terminator()->opcode() == spv::Op::OpSwitch) {
-      const auto terminator = header->terminator();
-      if (auto error =
-              StructuredSwitchChecks(_, function, terminator, header, merge)) {
+      if (auto error = StructuredSwitchChecks(_, function, construct)) {
         return error;
       }
     }
diff --git a/source/val/validate_composites.cpp b/source/val/validate_composites.cpp
index ed043b68..26486dac 100644
--- a/source/val/validate_composites.cpp
+++ b/source/val/validate_composites.cpp
@@ -94,7 +94,7 @@ spv_result_t GetExtractInsertValueType(ValidationState_t& _,
           break;
         }
 
-        if (!_.GetConstantValUint64(type_inst->word(3), &array_size)) {
+        if (!_.EvalConstantValUint64(type_inst->word(3), &array_size)) {
           assert(0 && "Array type definition is corrupt");
         }
         if (component_index >= array_size) {
@@ -289,7 +289,7 @@ spv_result_t ValidateCompositeConstruct(ValidationState_t& _,
       }
 
       uint64_t array_size = 0;
-      if (!_.GetConstantValUint64(array_inst->word(3), &array_size)) {
+      if (!_.EvalConstantValUint64(array_inst->word(3), &array_size)) {
         assert(0 && "Array type definition is corrupt");
       }
 
diff --git a/source/val/validate_constants.cpp b/source/val/validate_constants.cpp
index 4deaa496..1d40eedf 100644
--- a/source/val/validate_constants.cpp
+++ b/source/val/validate_constants.cpp
@@ -324,6 +324,7 @@ bool IsTypeNullable(const std::vector<uint32_t>& instruction,
       }
       return true;
     }
+    case spv::Op::OpTypeUntypedPointerKHR:
     case spv::Op::OpTypePointer:
       if (spv::StorageClass(instruction[2]) ==
           spv::StorageClass::PhysicalStorageBuffer) {
diff --git a/source/val/validate_conversion.cpp b/source/val/validate_conversion.cpp
index b2892a86..770b8e2e 100644
--- a/source/val/validate_conversion.cpp
+++ b/source/val/validate_conversion.cpp
@@ -49,7 +49,7 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       if (_.IsCooperativeMatrixType(result_type) ||
           _.IsCooperativeMatrixType(input_type)) {
         spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+            _.CooperativeMatrixShapesMatch(inst, result_type, input_type, true);
         if (ret != SPV_SUCCESS) return ret;
       } else {
         if (_.GetDimension(result_type) != _.GetDimension(input_type))
@@ -79,7 +79,7 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       if (_.IsCooperativeMatrixType(result_type) ||
           _.IsCooperativeMatrixType(input_type)) {
         spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+            _.CooperativeMatrixShapesMatch(inst, result_type, input_type, true);
         if (ret != SPV_SUCCESS) return ret;
       } else {
         if (_.GetDimension(result_type) != _.GetDimension(input_type))
@@ -111,7 +111,7 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       if (_.IsCooperativeMatrixType(result_type) ||
           _.IsCooperativeMatrixType(input_type)) {
         spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+            _.CooperativeMatrixShapesMatch(inst, result_type, input_type, true);
         if (ret != SPV_SUCCESS) return ret;
       } else {
         if (_.GetDimension(result_type) != _.GetDimension(input_type))
@@ -142,7 +142,7 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       if (_.IsCooperativeMatrixType(result_type) ||
           _.IsCooperativeMatrixType(input_type)) {
         spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+            _.CooperativeMatrixShapesMatch(inst, result_type, input_type, true);
         if (ret != SPV_SUCCESS) return ret;
       } else {
         if (_.GetDimension(result_type) != _.GetDimension(input_type))
@@ -177,7 +177,7 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       if (_.IsCooperativeMatrixType(result_type) ||
           _.IsCooperativeMatrixType(input_type)) {
         spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+            _.CooperativeMatrixShapesMatch(inst, result_type, input_type, true);
         if (ret != SPV_SUCCESS) return ret;
       } else {
         if (_.GetDimension(result_type) != _.GetDimension(input_type))
@@ -213,7 +213,7 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       if (_.IsCooperativeMatrixType(result_type) ||
           _.IsCooperativeMatrixType(input_type)) {
         spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+            _.CooperativeMatrixShapesMatch(inst, result_type, input_type, true);
         if (ret != SPV_SUCCESS) return ret;
       } else {
         if (_.GetDimension(result_type) != _.GetDimension(input_type))
@@ -497,8 +497,8 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
                << "matrix: " << spvOpcodeString(opcode);
 
       if (result_is_coopmat) {
-        spv_result_t ret =
-            _.CooperativeMatrixShapesMatch(inst, result_type, input_type);
+        spv_result_t ret = _.CooperativeMatrixShapesMatch(inst, result_type,
+                                                          input_type, false);
         if (ret != SPV_SUCCESS) return ret;
       }
 
@@ -568,6 +568,43 @@ spv_result_t ConversionPass(ValidationState_t& _, const Instruction* inst) {
       break;
     }
 
+    case spv::Op::OpCooperativeMatrixConvertNV:
+    case spv::Op::OpCooperativeMatrixTransposeNV: {
+      if (!_.IsCooperativeMatrixType(result_type)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Expected cooperative matrix Result Type: "
+               << spvOpcodeString(opcode);
+      }
+      const uint32_t input_type = _.GetOperandTypeId(inst, 2);
+      if (!_.IsCooperativeMatrixType(input_type)) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Expected cooperative matrix type for Matrix input: "
+               << spvOpcodeString(opcode);
+      }
+
+      bool swap_row_col = (opcode == spv::Op::OpCooperativeMatrixTransposeNV);
+      if (auto error = _.CooperativeMatrixShapesMatch(
+              inst, result_type, input_type, true, swap_row_col))
+        return error;
+
+      if (opcode == spv::Op::OpCooperativeMatrixConvertNV) {
+        if (_.FindDef(result_type)->GetOperandAs<uint32_t>(1) !=
+            _.FindDef(input_type)->GetOperandAs<uint32_t>(1)) {
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "Result Type and Matrix component types mismatch: "
+                 << spvOpcodeString(opcode);
+        }
+      }
+
+      if (opcode == spv::Op::OpCooperativeMatrixTransposeNV) {
+        if (!_.IsCooperativeMatrixBType(result_type)) {
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "Result Type must have UseB: " << spvOpcodeString(opcode);
+        }
+      }
+      break;
+    }
+
     default:
       break;
   }
diff --git a/source/val/validate_decorations.cpp b/source/val/validate_decorations.cpp
index caa4a6f1..e680bd6e 100644
--- a/source/val/validate_decorations.cpp
+++ b/source/val/validate_decorations.cpp
@@ -71,26 +71,6 @@ uint32_t GetArrayStride(uint32_t array_id, ValidationState_t& vstate) {
   return 0;
 }
 
-// Returns true if the given variable has a BuiltIn decoration.
-bool isBuiltInVar(uint32_t var_id, ValidationState_t& vstate) {
-  const auto& decorations = vstate.id_decorations(var_id);
-  return std::any_of(decorations.begin(), decorations.end(),
-                     [](const Decoration& d) {
-                       return spv::Decoration::BuiltIn == d.dec_type();
-                     });
-}
-
-// Returns true if the given structure type has any members with BuiltIn
-// decoration.
-bool isBuiltInStruct(uint32_t struct_id, ValidationState_t& vstate) {
-  const auto& decorations = vstate.id_decorations(struct_id);
-  return std::any_of(
-      decorations.begin(), decorations.end(), [](const Decoration& d) {
-        return spv::Decoration::BuiltIn == d.dec_type() &&
-               Decoration::kInvalidMember != d.struct_member_index();
-      });
-}
-
 // Returns true if the given structure type has a Block decoration.
 bool isBlock(uint32_t struct_id, ValidationState_t& vstate) {
   const auto& decorations = vstate.id_decorations(struct_id);
@@ -189,7 +169,7 @@ uint32_t getBaseAlignment(uint32_t member_id, bool roundUp,
     case spv::Op::OpTypeSampler:
     case spv::Op::OpTypeImage:
       if (vstate.HasCapability(spv::Capability::BindlessTextureNV))
-        return baseAlignment = vstate.samplerimage_variable_address_mode() / 8;
+        return vstate.samplerimage_variable_address_mode() / 8;
       assert(0);
       return 0;
     case spv::Op::OpTypeInt:
@@ -244,6 +224,7 @@ uint32_t getBaseAlignment(uint32_t member_id, bool roundUp,
       break;
     }
     case spv::Op::OpTypePointer:
+    case spv::Op::OpTypeUntypedPointerKHR:
       baseAlignment = vstate.pointer_size_and_alignment();
       break;
     default:
@@ -290,6 +271,7 @@ uint32_t getScalarAlignment(uint32_t type_id, ValidationState_t& vstate) {
       return max_member_alignment;
     } break;
     case spv::Op::OpTypePointer:
+    case spv::Op::OpTypeUntypedPointerKHR:
       return vstate.pointer_size_and_alignment();
     default:
       assert(0);
@@ -379,6 +361,7 @@ uint32_t getSize(uint32_t member_id, const LayoutConstraints& inherited,
       return offset + getSize(lastMember, constraint, constraints, vstate);
     }
     case spv::Op::OpTypePointer:
+    case spv::Op::OpTypeUntypedPointerKHR:
       return vstate.pointer_size_and_alignment();
     default:
       assert(0);
@@ -452,9 +435,9 @@ spv_result_t checkLayout(uint32_t struct_id, const char* storage_class_str,
     return ds;
   };
 
-  // If we are checking physical storage buffer pointers, we may not actually
-  // have a struct here. Instead, pretend we have a struct with a single member
-  // at offset 0.
+  // If we are checking the layout of untyped pointers or physical storage
+  // buffer pointers, we may not actually have a struct here. Instead, pretend
+  // we have a struct with a single member at offset 0.
   const auto& struct_type = vstate.FindDef(struct_id);
   std::vector<uint32_t> members;
   if (struct_type->opcode() == spv::Op::OpTypeStruct) {
@@ -471,8 +454,8 @@ spv_result_t checkLayout(uint32_t struct_id, const char* storage_class_str,
   };
   std::vector<MemberOffsetPair> member_offsets;
 
-  // With physical storage buffers, we might be checking layouts that do not
-  // originate from a structure.
+  // With untyped pointers or physical storage buffers, we might be checking
+  // layouts that do not originate from a structure.
   if (struct_type->opcode() == spv::Op::OpTypeStruct) {
     member_offsets.reserve(members.size());
     for (uint32_t memberIdx = 0, numMembers = uint32_t(members.size());
@@ -623,6 +606,14 @@ spv_result_t checkLayout(uint32_t struct_id, const char* storage_class_str,
 
           seen[next_offset % 16] = true;
         }
+      } else if (spv::Op::OpTypeMatrix == element_inst->opcode()) {
+        // Matrix stride would be on the array element in the struct.
+        const auto stride = constraint.matrix_stride;
+        if (!IsAlignedTo(stride, alignment)) {
+          return fail(memberIdx)
+                 << "is a matrix with stride " << stride
+                 << " not satisfying alignment to " << alignment;
+        }
       }
 
       // Proceed to the element in case it is an array.
@@ -675,7 +666,16 @@ bool checkForRequiredDecoration(uint32_t struct_id,
                                 spv::Op type, ValidationState_t& vstate) {
   const auto& members = getStructMembers(struct_id, vstate);
   for (size_t memberIdx = 0; memberIdx < members.size(); memberIdx++) {
-    const auto id = members[memberIdx];
+    auto id = members[memberIdx];
+    if (type == spv::Op::OpTypeMatrix) {
+      // Matrix decorations also apply to arrays of matrices.
+      auto memberInst = vstate.FindDef(id);
+      while (memberInst->opcode() == spv::Op::OpTypeArray ||
+             memberInst->opcode() == spv::Op::OpTypeRuntimeArray) {
+        memberInst = vstate.FindDef(memberInst->GetOperandAs<uint32_t>(1u));
+      }
+      id = memberInst->id();
+    }
     if (type != vstate.FindDef(id)->opcode()) continue;
     bool found = false;
     for (auto& dec : vstate.id_decorations(id)) {
@@ -769,16 +769,23 @@ spv_result_t CheckDecorationsOfEntryPoints(ValidationState_t& vstate) {
     int num_workgroup_variables_with_aliased = 0;
     for (const auto& desc : descs) {
       std::unordered_set<Instruction*> seen_vars;
+      std::unordered_set<spv::BuiltIn> input_var_builtin;
+      std::unordered_set<spv::BuiltIn> output_var_builtin;
       for (auto interface : desc.interfaces) {
         Instruction* var_instr = vstate.FindDef(interface);
-        if (!var_instr || spv::Op::OpVariable != var_instr->opcode()) {
+        if (!var_instr ||
+            (spv::Op::OpVariable != var_instr->opcode() &&
+             spv::Op::OpUntypedVariableKHR != var_instr->opcode())) {
           return vstate.diag(SPV_ERROR_INVALID_ID, var_instr)
-                 << "Interfaces passed to OpEntryPoint must be of type "
-                    "OpTypeVariable. Found Op"
+                 << "Interfaces passed to OpEntryPoint must be variables. "
+                    "Found Op"
                  << spvOpcodeString(var_instr->opcode()) << ".";
         }
+        const bool untyped_pointers =
+            var_instr->opcode() == spv::Op::OpUntypedVariableKHR;
+        const auto sc_index = 2u;
         const spv::StorageClass storage_class =
-            var_instr->GetOperandAs<spv::StorageClass>(2);
+            var_instr->GetOperandAs<spv::StorageClass>(sc_index);
         if (vstate.version() >= SPV_SPIRV_VERSION_WORD(1, 4)) {
           // Starting in 1.4, OpEntryPoint must list all global variables
           // it statically uses and those interfaces must be unique.
@@ -805,45 +812,96 @@ spv_result_t CheckDecorationsOfEntryPoints(ValidationState_t& vstate) {
           }
         }
 
-        const uint32_t ptr_id = var_instr->word(1);
-        Instruction* ptr_instr = vstate.FindDef(ptr_id);
         // It is guaranteed (by validator ID checks) that ptr_instr is
         // OpTypePointer. Word 3 of this instruction is the type being pointed
-        // to.
-        const uint32_t type_id = ptr_instr->word(3);
+        // to. For untyped variables, the pointee type comes from the data type
+        // operand.
+        const uint32_t type_id =
+            untyped_pointers ? var_instr->word(4)
+                             : vstate.FindDef(var_instr->word(1))->word(3);
         Instruction* type_instr = vstate.FindDef(type_id);
-        if (type_instr && spv::Op::OpTypeStruct == type_instr->opcode() &&
-            isBuiltInStruct(type_id, vstate)) {
-          if (!isBlock(type_id, vstate)) {
-            return vstate.diag(SPV_ERROR_INVALID_DATA, vstate.FindDef(type_id))
-                   << vstate.VkErrorID(4919)
-                   << "Interface struct has no Block decoration but has "
-                      "BuiltIn members. "
-                      "Location decorations must be used on each member of "
-                      "OpVariable with a structure type that is a block not "
-                      "decorated with Location.";
+        const bool is_struct =
+            type_instr && spv::Op::OpTypeStruct == type_instr->opcode();
+
+        // Search all Built-in (on the variable or the struct)
+        bool has_built_in = false;
+        for (auto& dec :
+             vstate.id_decorations(is_struct ? type_id : interface)) {
+          if (dec.dec_type() != spv::Decoration::BuiltIn) continue;
+          has_built_in = true;
+
+          if (!spvIsVulkanEnv(vstate.context()->target_env)) continue;
+
+          const spv::BuiltIn builtin = dec.builtin();
+          if (storage_class == spv::StorageClass::Input) {
+            if (!input_var_builtin.insert(builtin).second) {
+              return vstate.diag(SPV_ERROR_INVALID_ID, var_instr)
+                     << vstate.VkErrorID(9658)
+                     << "OpEntryPoint contains duplicate input variables "
+                        "with "
+                     << vstate.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN, (uint32_t)builtin)
+                     << " builtin";
+            }
           }
-          if (storage_class == spv::StorageClass::Input)
-            ++num_builtin_block_inputs;
-          if (storage_class == spv::StorageClass::Output)
-            ++num_builtin_block_outputs;
-          if (num_builtin_block_inputs > 1 || num_builtin_block_outputs > 1)
-            break;
-          if (auto error = CheckBuiltInVariable(interface, vstate))
-            return error;
-        } else if (isBuiltInVar(interface, vstate)) {
+          if (storage_class == spv::StorageClass::Output) {
+            if (!output_var_builtin.insert(builtin).second) {
+              return vstate.diag(SPV_ERROR_INVALID_ID, var_instr)
+                     << vstate.VkErrorID(9659)
+                     << "OpEntryPoint contains duplicate output variables "
+                        "with "
+                     << vstate.grammar().lookupOperandName(
+                            SPV_OPERAND_TYPE_BUILT_IN, (uint32_t)builtin)
+                     << " builtin";
+            }
+          }
+        }
+
+        if (has_built_in) {
           if (auto error = CheckBuiltInVariable(interface, vstate))
             return error;
+
+          if (is_struct) {
+            if (!isBlock(type_id, vstate)) {
+              return vstate.diag(SPV_ERROR_INVALID_DATA,
+                                 vstate.FindDef(type_id))
+                     << vstate.VkErrorID(4919)
+                     << "Interface struct has no Block decoration but has "
+                        "BuiltIn members. "
+                        "Location decorations must be used on each member of "
+                        "OpVariable with a structure type that is a block not "
+                        "decorated with Location.";
+            }
+            if (storage_class == spv::StorageClass::Input)
+              ++num_builtin_block_inputs;
+            if (storage_class == spv::StorageClass::Output)
+              ++num_builtin_block_outputs;
+            if (num_builtin_block_inputs > 1 || num_builtin_block_outputs > 1)
+              break;
+          }
         }
 
         if (storage_class == spv::StorageClass::Workgroup) {
           ++num_workgroup_variables;
-          if (type_instr && spv::Op::OpTypeStruct == type_instr->opcode()) {
-            if (hasDecoration(type_id, spv::Decoration::Block, vstate))
-              ++num_workgroup_variables_with_block;
-            if (hasDecoration(var_instr->id(), spv::Decoration::Aliased,
-                              vstate))
-              ++num_workgroup_variables_with_aliased;
+          if (type_instr) {
+            if (spv::Op::OpTypeStruct == type_instr->opcode()) {
+              if (hasDecoration(type_id, spv::Decoration::Block, vstate)) {
+                ++num_workgroup_variables_with_block;
+              } else if (untyped_pointers &&
+                         vstate.HasCapability(spv::Capability::Shader)) {
+                return vstate.diag(SPV_ERROR_INVALID_ID, var_instr)
+                       << "Untyped workgroup variables in shaders must be "
+                          "block decorated";
+              }
+              if (hasDecoration(var_instr->id(), spv::Decoration::Aliased,
+                                vstate))
+                ++num_workgroup_variables_with_aliased;
+            } else if (untyped_pointers &&
+                       vstate.HasCapability(spv::Capability::Shader)) {
+              return vstate.diag(SPV_ERROR_INVALID_ID, var_instr)
+                     << "Untyped workgroup variables in shaders must be block "
+                        "decorated structs";
+            }
           }
         }
 
@@ -924,25 +982,33 @@ spv_result_t CheckDecorationsOfEntryPoints(ValidationState_t& vstate) {
 
       const bool workgroup_blocks_allowed = vstate.HasCapability(
           spv::Capability::WorkgroupMemoryExplicitLayoutKHR);
-      if (workgroup_blocks_allowed && num_workgroup_variables > 0 &&
+      if (workgroup_blocks_allowed &&
+          !vstate.HasCapability(spv::Capability::UntypedPointersKHR) &&
+          num_workgroup_variables > 0 &&
           num_workgroup_variables_with_block > 0) {
         if (num_workgroup_variables != num_workgroup_variables_with_block) {
-          return vstate.diag(SPV_ERROR_INVALID_BINARY, vstate.FindDef(entry_point))
+          return vstate.diag(SPV_ERROR_INVALID_BINARY,
+                             vstate.FindDef(entry_point))
                  << "When declaring WorkgroupMemoryExplicitLayoutKHR, "
-                    "either all or none of the Workgroup Storage Class variables "
+                    "either all or none of the Workgroup Storage Class "
+                    "variables "
                     "in the entry point interface must point to struct types "
-                    "decorated with Block.  Entry point id "
+                    "decorated with Block (unless the "
+                    "UntypedPointersKHR capability is declared).  "
+                    "Entry point id "
                  << entry_point << " does not meet this requirement.";
         }
         if (num_workgroup_variables_with_block > 1 &&
             num_workgroup_variables_with_block !=
             num_workgroup_variables_with_aliased) {
-          return vstate.diag(SPV_ERROR_INVALID_BINARY, vstate.FindDef(entry_point))
+          return vstate.diag(SPV_ERROR_INVALID_BINARY,
+                             vstate.FindDef(entry_point))
                  << "When declaring WorkgroupMemoryExplicitLayoutKHR, "
                     "if more than one Workgroup Storage Class variable in "
                     "the entry point interface point to a type decorated "
-                    "with Block, all of them must be decorated with Aliased. "
-                    "Entry point id "
+                    "with Block, all of them must be decorated with Aliased "
+                    "(unless the UntypedPointerWorkgroupKHR capability is "
+                    "declared). Entry point id "
                  << entry_point << " does not meet this requirement.";
         }
       } else if (!workgroup_blocks_allowed &&
@@ -1048,11 +1114,17 @@ spv_result_t CheckDecorationsOfBuffers(ValidationState_t& vstate) {
     const auto& words = inst.words();
     auto type_id = inst.type_id();
     const Instruction* type_inst = vstate.FindDef(type_id);
-    if (spv::Op::OpVariable == inst.opcode()) {
+    bool scalar_block_layout = false;
+    MemberConstraints constraints;
+    if (spv::Op::OpVariable == inst.opcode() ||
+        spv::Op::OpUntypedVariableKHR == inst.opcode()) {
+      const bool untyped_pointer =
+          inst.opcode() == spv::Op::OpUntypedVariableKHR;
       const auto var_id = inst.id();
       // For storage class / decoration combinations, see Vulkan 14.5.4 "Offset
       // and Stride Assignment".
-      const auto storageClass = inst.GetOperandAs<spv::StorageClass>(2);
+      const auto storageClassVal = words[3];
+      const auto storageClass = spv::StorageClass(storageClassVal);
       const bool uniform = storageClass == spv::StorageClass::Uniform;
       const bool uniform_constant =
           storageClass == spv::StorageClass::UniformConstant;
@@ -1131,20 +1203,24 @@ spv_result_t CheckDecorationsOfBuffers(ValidationState_t& vstate) {
       if (uniform || push_constant || storage_buffer || phys_storage_buffer ||
           workgroup) {
         const auto ptrInst = vstate.FindDef(words[1]);
-        assert(spv::Op::OpTypePointer == ptrInst->opcode());
-        auto id = ptrInst->words()[3];
-        auto id_inst = vstate.FindDef(id);
-        // Jump through one level of arraying.
-        if (!workgroup && (id_inst->opcode() == spv::Op::OpTypeArray ||
-                           id_inst->opcode() == spv::Op::OpTypeRuntimeArray)) {
-          id = id_inst->GetOperandAs<uint32_t>(1u);
-          id_inst = vstate.FindDef(id);
+        assert(spv::Op::OpTypePointer == ptrInst->opcode() ||
+               spv::Op::OpTypeUntypedPointerKHR == ptrInst->opcode());
+        auto id = untyped_pointer ? (words.size() > 4 ? words[4] : 0)
+                                  : ptrInst->words()[3];
+        if (id != 0) {
+          auto id_inst = vstate.FindDef(id);
+          // Jump through one level of arraying.
+          if (!workgroup &&
+              (id_inst->opcode() == spv::Op::OpTypeArray ||
+               id_inst->opcode() == spv::Op::OpTypeRuntimeArray)) {
+            id = id_inst->GetOperandAs<uint32_t>(1u);
+            id_inst = vstate.FindDef(id);
+          }
+          // Struct requirement is checked on variables so just move on here.
+          if (spv::Op::OpTypeStruct != id_inst->opcode()) continue;
+          ComputeMemberConstraintsForStruct(&constraints, id,
+                                            LayoutConstraints(), vstate);
         }
-        // Struct requirement is checked on variables so just move on here.
-        if (spv::Op::OpTypeStruct != id_inst->opcode()) continue;
-        MemberConstraints constraints;
-        ComputeMemberConstraintsForStruct(&constraints, id, LayoutConstraints(),
-                                          vstate);
         // Prepare for messages
         const char* sc_str =
             uniform ? "Uniform"
@@ -1214,88 +1290,91 @@ spv_result_t CheckDecorationsOfBuffers(ValidationState_t& vstate) {
           }
         }
 
-        for (const auto& dec : vstate.id_decorations(id)) {
-          const bool blockDeco = spv::Decoration::Block == dec.dec_type();
-          const bool bufferDeco =
-              spv::Decoration::BufferBlock == dec.dec_type();
-          const bool blockRules = uniform && blockDeco;
-          const bool bufferRules =
-              (uniform && bufferDeco) ||
-              ((push_constant || storage_buffer ||
-                phys_storage_buffer || workgroup) && blockDeco);
-          if (uniform && blockDeco) {
-            vstate.RegisterPointerToUniformBlock(ptrInst->id());
-            vstate.RegisterStructForUniformBlock(id);
-          }
-          if ((uniform && bufferDeco) ||
-              ((storage_buffer || phys_storage_buffer) && blockDeco)) {
-            vstate.RegisterPointerToStorageBuffer(ptrInst->id());
-            vstate.RegisterStructForStorageBuffer(id);
-          }
-
-          if (blockRules || bufferRules) {
-            const char* deco_str = blockDeco ? "Block" : "BufferBlock";
-            spv_result_t recursive_status = SPV_SUCCESS;
-            const bool scalar_block_layout = workgroup ?
-                vstate.options()->workgroup_scalar_block_layout :
-                vstate.options()->scalar_block_layout;
-
-            if (isMissingOffsetInStruct(id, vstate)) {
-              return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
-                     << "Structure id " << id << " decorated as " << deco_str
-                     << " must be explicitly laid out with Offset "
-                        "decorations.";
+        if (id != 0) {
+          for (const auto& dec : vstate.id_decorations(id)) {
+            const bool blockDeco = spv::Decoration::Block == dec.dec_type();
+            const bool bufferDeco =
+                spv::Decoration::BufferBlock == dec.dec_type();
+            const bool blockRules = uniform && blockDeco;
+            const bool bufferRules = (uniform && bufferDeco) ||
+                                     ((push_constant || storage_buffer ||
+                                       phys_storage_buffer || workgroup) &&
+                                      blockDeco);
+            if (uniform && blockDeco) {
+              vstate.RegisterPointerToUniformBlock(ptrInst->id());
+              vstate.RegisterStructForUniformBlock(id);
             }
-
-            if (!checkForRequiredDecoration(
-                    id,
-                    [](spv::Decoration d) {
-                      return d == spv::Decoration::ArrayStride;
-                    },
-                    spv::Op::OpTypeArray, vstate)) {
-              return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
-                     << "Structure id " << id << " decorated as " << deco_str
-                     << " must be explicitly laid out with ArrayStride "
-                        "decorations.";
+            if ((uniform && bufferDeco) ||
+                ((storage_buffer || phys_storage_buffer) && blockDeco)) {
+              vstate.RegisterPointerToStorageBuffer(ptrInst->id());
+              vstate.RegisterStructForStorageBuffer(id);
             }
 
-            if (!checkForRequiredDecoration(
-                    id,
-                    [](spv::Decoration d) {
-                      return d == spv::Decoration::MatrixStride;
-                    },
-                    spv::Op::OpTypeMatrix, vstate)) {
-              return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
-                     << "Structure id " << id << " decorated as " << deco_str
-                     << " must be explicitly laid out with MatrixStride "
-                        "decorations.";
-            }
+            if (blockRules || bufferRules) {
+              const char* deco_str = blockDeco ? "Block" : "BufferBlock";
+              spv_result_t recursive_status = SPV_SUCCESS;
+              scalar_block_layout =
+                  workgroup ? vstate.options()->workgroup_scalar_block_layout
+                            : vstate.options()->scalar_block_layout;
+
+              if (isMissingOffsetInStruct(id, vstate)) {
+                return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
+                       << "Structure id " << id << " decorated as " << deco_str
+                       << " must be explicitly laid out with Offset "
+                          "decorations.";
+              }
 
-            if (!checkForRequiredDecoration(
-                    id,
-                    [](spv::Decoration d) {
-                      return d == spv::Decoration::RowMajor ||
-                             d == spv::Decoration::ColMajor;
-                    },
-                    spv::Op::OpTypeMatrix, vstate)) {
-              return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
-                     << "Structure id " << id << " decorated as " << deco_str
-                     << " must be explicitly laid out with RowMajor or "
-                        "ColMajor decorations.";
-            }
+              if (!checkForRequiredDecoration(
+                      id,
+                      [](spv::Decoration d) {
+                        return d == spv::Decoration::ArrayStride;
+                      },
+                      spv::Op::OpTypeArray, vstate)) {
+                return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
+                       << "Structure id " << id << " decorated as " << deco_str
+                       << " must be explicitly laid out with ArrayStride "
+                          "decorations.";
+              }
 
-            if (spvIsVulkanEnv(vstate.context()->target_env)) {
-              if (blockRules && (SPV_SUCCESS != (recursive_status = checkLayout(
-                                                     id, sc_str, deco_str, true,
+              if (!checkForRequiredDecoration(
+                      id,
+                      [](spv::Decoration d) {
+                        return d == spv::Decoration::MatrixStride;
+                      },
+                      spv::Op::OpTypeMatrix, vstate)) {
+                return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
+                       << "Structure id " << id << " decorated as " << deco_str
+                       << " must be explicitly laid out with MatrixStride "
+                          "decorations.";
+              }
+
+              if (!checkForRequiredDecoration(
+                      id,
+                      [](spv::Decoration d) {
+                        return d == spv::Decoration::RowMajor ||
+                               d == spv::Decoration::ColMajor;
+                      },
+                      spv::Op::OpTypeMatrix, vstate)) {
+                return vstate.diag(SPV_ERROR_INVALID_ID, vstate.FindDef(id))
+                       << "Structure id " << id << " decorated as " << deco_str
+                       << " must be explicitly laid out with RowMajor or "
+                          "ColMajor decorations.";
+              }
+
+              if (spvIsVulkanEnv(vstate.context()->target_env)) {
+                if (blockRules &&
+                    (SPV_SUCCESS !=
+                     (recursive_status = checkLayout(id, sc_str, deco_str, true,
                                                      scalar_block_layout, 0,
                                                      constraints, vstate)))) {
-                return recursive_status;
-              } else if (bufferRules &&
-                         (SPV_SUCCESS !=
-                          (recursive_status = checkLayout(
-                               id, sc_str, deco_str, false, scalar_block_layout,
-                               0, constraints, vstate)))) {
-                return recursive_status;
+                  return recursive_status;
+                } else if (bufferRules &&
+                           (SPV_SUCCESS != (recursive_status = checkLayout(
+                                                id, sc_str, deco_str, false,
+                                                scalar_block_layout, 0,
+                                                constraints, vstate)))) {
+                  return recursive_status;
+                }
               }
             }
           }
@@ -1304,20 +1383,98 @@ spv_result_t CheckDecorationsOfBuffers(ValidationState_t& vstate) {
     } else if (type_inst && type_inst->opcode() == spv::Op::OpTypePointer &&
                type_inst->GetOperandAs<spv::StorageClass>(1u) ==
                    spv::StorageClass::PhysicalStorageBuffer) {
-      const bool scalar_block_layout = vstate.options()->scalar_block_layout;
-      MemberConstraints constraints;
       const bool buffer = true;
-      const auto data_type_id = type_inst->GetOperandAs<uint32_t>(2u);
-      const auto* data_type_inst = vstate.FindDef(data_type_id);
+      const auto pointee_type_id = type_inst->GetOperandAs<uint32_t>(2u);
+      const auto* data_type_inst = vstate.FindDef(pointee_type_id);
+      scalar_block_layout = vstate.options()->scalar_block_layout;
       if (data_type_inst->opcode() == spv::Op::OpTypeStruct) {
-        ComputeMemberConstraintsForStruct(&constraints, data_type_id,
+        ComputeMemberConstraintsForStruct(&constraints, pointee_type_id,
                                           LayoutConstraints(), vstate);
       }
-      if (auto res = checkLayout(data_type_id, "PhysicalStorageBuffer", "Block",
-                                 !buffer, scalar_block_layout, 0, constraints,
-                                 vstate)) {
+      if (auto res = checkLayout(pointee_type_id, "PhysicalStorageBuffer",
+                                 "Block", !buffer, scalar_block_layout, 0,
+                                 constraints, vstate)) {
         return res;
       }
+    } else if (vstate.HasCapability(spv::Capability::UntypedPointersKHR) &&
+               spvIsVulkanEnv(vstate.context()->target_env)) {
+      // Untyped variables are checked above. Here we check that instructions
+      // using an untyped pointer have a valid layout.
+      uint32_t ptr_ty_id = 0;
+      uint32_t data_type_id = 0;
+      switch (inst.opcode()) {
+        case spv::Op::OpUntypedAccessChainKHR:
+        case spv::Op::OpUntypedInBoundsAccessChainKHR:
+        case spv::Op::OpUntypedPtrAccessChainKHR:
+        case spv::Op::OpUntypedInBoundsPtrAccessChainKHR:
+          ptr_ty_id = inst.type_id();
+          data_type_id = inst.GetOperandAs<uint32_t>(2);
+          break;
+        case spv::Op::OpLoad:
+          if (vstate.GetIdOpcode(vstate.GetOperandTypeId(&inst, 2)) ==
+              spv::Op::OpTypeUntypedPointerKHR) {
+            const auto ptr_id = inst.GetOperandAs<uint32_t>(2);
+            ptr_ty_id = vstate.FindDef(ptr_id)->type_id();
+            data_type_id = inst.type_id();
+          }
+          break;
+        case spv::Op::OpStore:
+          if (vstate.GetIdOpcode(vstate.GetOperandTypeId(&inst, 0)) ==
+              spv::Op::OpTypeUntypedPointerKHR) {
+            const auto ptr_id = inst.GetOperandAs<uint32_t>(0);
+            ptr_ty_id = vstate.FindDef(ptr_id)->type_id();
+            data_type_id = vstate.GetOperandTypeId(&inst, 1);
+          }
+          break;
+        case spv::Op::OpUntypedArrayLengthKHR:
+          ptr_ty_id = vstate.FindDef(inst.GetOperandAs<uint32_t>(3))->type_id();
+          data_type_id = inst.GetOperandAs<uint32_t>(2);
+          break;
+        default:
+          break;
+      }
+
+      if (ptr_ty_id == 0 || data_type_id == 0) {
+        // Not an untyped pointer.
+        continue;
+      }
+
+      const auto sc =
+          vstate.FindDef(ptr_ty_id)->GetOperandAs<spv::StorageClass>(1);
+
+      const char* sc_str =
+          sc == spv::StorageClass::Uniform
+              ? "Uniform"
+              : (sc == spv::StorageClass::PushConstant
+                     ? "PushConstant"
+                     : (sc == spv::StorageClass::Workgroup ? "Workgroup"
+                                                           : "StorageBuffer"));
+
+      const auto data_type = vstate.FindDef(data_type_id);
+      scalar_block_layout =
+          sc == spv::StorageClass::Workgroup
+              ? vstate.options()->workgroup_scalar_block_layout
+              : vstate.options()->scalar_block_layout;
+      // Assume uniform storage class uses block rules unless we see a
+      // BufferBlock decorated struct in the data type.
+      bool bufferRules = sc == spv::StorageClass::Uniform ? false : true;
+      if (data_type->opcode() == spv::Op::OpTypeStruct) {
+        if (sc == spv::StorageClass::Uniform) {
+          bufferRules =
+              vstate.HasDecoration(data_type_id, spv::Decoration::BufferBlock);
+        }
+        ComputeMemberConstraintsForStruct(&constraints, data_type_id,
+                                          LayoutConstraints(), vstate);
+      }
+      const char* deco_str =
+          bufferRules
+              ? (sc == spv::StorageClass::Uniform ? "BufferBlock" : "Block")
+              : "Block";
+      if (auto result =
+              checkLayout(data_type_id, sc_str, deco_str, !bufferRules,
+                          scalar_block_layout, 0, constraints, vstate)) {
+        return result;
+      }
     }
   }
   return SPV_SUCCESS;
@@ -1325,21 +1482,14 @@ spv_result_t CheckDecorationsOfBuffers(ValidationState_t& vstate) {
 
 // Returns true if |decoration| cannot be applied to the same id more than once.
 bool AtMostOncePerId(spv::Decoration decoration) {
-  return decoration == spv::Decoration::ArrayStride;
+  return decoration != spv::Decoration::UserSemantic &&
+         decoration != spv::Decoration::FuncParamAttr;
 }
 
 // Returns true if |decoration| cannot be applied to the same member more than
 // once.
 bool AtMostOncePerMember(spv::Decoration decoration) {
-  switch (decoration) {
-    case spv::Decoration::Offset:
-    case spv::Decoration::MatrixStride:
-    case spv::Decoration::RowMajor:
-    case spv::Decoration::ColMajor:
-      return true;
-    default:
-      return false;
-  }
+  return decoration != spv::Decoration::UserSemantic;
 }
 
 spv_result_t CheckDecorationsCompatibility(ValidationState_t& vstate) {
@@ -1556,23 +1706,29 @@ spv_result_t CheckNonWritableDecoration(ValidationState_t& vstate,
     const auto opcode = inst.opcode();
     const auto type_id = inst.type_id();
     if (opcode != spv::Op::OpVariable &&
-        opcode != spv::Op::OpFunctionParameter) {
+        opcode != spv::Op::OpUntypedVariableKHR &&
+        opcode != spv::Op::OpFunctionParameter &&
+        opcode != spv::Op::OpRawAccessChainNV) {
       return vstate.diag(SPV_ERROR_INVALID_ID, &inst)
              << "Target of NonWritable decoration must be a memory object "
                 "declaration (a variable or a function parameter)";
     }
-    const auto var_storage_class = opcode == spv::Op::OpVariable
-                                       ? inst.GetOperandAs<spv::StorageClass>(2)
-                                       : spv::StorageClass::Max;
+    const auto var_storage_class =
+        opcode == spv::Op::OpVariable
+            ? inst.GetOperandAs<spv::StorageClass>(2)
+            : opcode == spv::Op::OpUntypedVariableKHR
+                  ? inst.GetOperandAs<spv::StorageClass>(3)
+                  : spv::StorageClass::Max;
     if ((var_storage_class == spv::StorageClass::Function ||
          var_storage_class == spv::StorageClass::Private) &&
         vstate.features().nonwritable_var_in_function_or_private) {
       // New permitted feature in SPIR-V 1.4.
     } else if (
-        // It may point to a UBO, SSBO, or storage image.
+        // It may point to a UBO, SSBO, storage image, or raw access chain.
         vstate.IsPointerToUniformBlock(type_id) ||
         vstate.IsPointerToStorageBuffer(type_id) ||
-        vstate.IsPointerToStorageImage(type_id)) {
+        vstate.IsPointerToStorageImage(type_id) ||
+        opcode == spv::Op::OpRawAccessChainNV) {
     } else {
       return vstate.diag(SPV_ERROR_INVALID_ID, &inst)
              << "Target of NonWritable decoration is invalid: must point to a "
@@ -1653,6 +1809,7 @@ spv_result_t CheckIntegerWrapDecoration(ValidationState_t& vstate,
     case spv::Op::OpSNegate:
       return SPV_SUCCESS;
     case spv::Op::OpExtInst:
+    case spv::Op::OpExtInstWithForwardRefsKHR:
       // TODO(dneto): Only certain extended instructions allow these
       // decorations.  For now allow anything.
       return SPV_SUCCESS;
@@ -1719,7 +1876,7 @@ spv_result_t CheckComponentDecoration(ValidationState_t& vstate,
 
   if (spvIsVulkanEnv(vstate.context()->target_env)) {
     // Strip the array, if present.
-    if (vstate.GetIdOpcode(type_id) == spv::Op::OpTypeArray) {
+    while (vstate.GetIdOpcode(type_id) == spv::Op::OpTypeArray) {
       type_id = vstate.FindDef(type_id)->word(2u);
     }
 
diff --git a/source/val/validate_derivatives.cpp b/source/val/validate_derivatives.cpp
index 90cf6645..1a473ba8 100644
--- a/source/val/validate_derivatives.cpp
+++ b/source/val/validate_derivatives.cpp
@@ -60,12 +60,14 @@ spv_result_t DerivativesPass(ValidationState_t& _, const Instruction* inst) {
           ->RegisterExecutionModelLimitation([opcode](spv::ExecutionModel model,
                                                       std::string* message) {
             if (model != spv::ExecutionModel::Fragment &&
-                model != spv::ExecutionModel::GLCompute) {
+                model != spv::ExecutionModel::GLCompute &&
+                model != spv::ExecutionModel::MeshEXT &&
+                model != spv::ExecutionModel::TaskEXT) {
               if (message) {
                 *message =
                     std::string(
-                        "Derivative instructions require Fragment or GLCompute "
-                        "execution model: ") +
+                        "Derivative instructions require Fragment, GLCompute, "
+                        "MeshEXT or TaskEXT execution model: ") +
                     spvOpcodeString(opcode);
               }
               return false;
@@ -79,19 +81,23 @@ spv_result_t DerivativesPass(ValidationState_t& _, const Instruction* inst) {
             const auto* models = state.GetExecutionModels(entry_point->id());
             const auto* modes = state.GetExecutionModes(entry_point->id());
             if (models &&
-                models->find(spv::ExecutionModel::GLCompute) != models->end() &&
+                (models->find(spv::ExecutionModel::GLCompute) !=
+                     models->end() ||
+                 models->find(spv::ExecutionModel::MeshEXT) != models->end() ||
+                 models->find(spv::ExecutionModel::TaskEXT) != models->end()) &&
                 (!modes ||
-                 (modes->find(spv::ExecutionMode::DerivativeGroupLinearNV) ==
+                 (modes->find(spv::ExecutionMode::DerivativeGroupLinearKHR) ==
                       modes->end() &&
-                  modes->find(spv::ExecutionMode::DerivativeGroupQuadsNV) ==
+                  modes->find(spv::ExecutionMode::DerivativeGroupQuadsKHR) ==
                       modes->end()))) {
               if (message) {
-                *message = std::string(
-                               "Derivative instructions require "
-                               "DerivativeGroupQuadsNV "
-                               "or DerivativeGroupLinearNV execution mode for "
-                               "GLCompute execution model: ") +
-                           spvOpcodeString(opcode);
+                *message =
+                    std::string(
+                        "Derivative instructions require "
+                        "DerivativeGroupQuadsKHR "
+                        "or DerivativeGroupLinearKHR execution mode for "
+                        "GLCompute, MeshEXT or TaskEXT execution model: ") +
+                    spvOpcodeString(opcode);
               }
               return false;
             }
diff --git a/source/val/validate_extensions.cpp b/source/val/validate_extensions.cpp
index 0334b606..cb4768dc 100644
--- a/source/val/validate_extensions.cpp
+++ b/source/val/validate_extensions.cpp
@@ -147,7 +147,7 @@ bool DoesDebugInfoOperandMatchExpectation(
     const Instruction* inst, uint32_t word_index) {
   if (inst->words().size() <= word_index) return false;
   auto* debug_inst = _.FindDef(inst->word(word_index));
-  if (debug_inst->opcode() != spv::Op::OpExtInst ||
+  if (!spvIsExtendedInstruction(debug_inst->opcode()) ||
       (debug_inst->ext_inst_type() != SPV_EXT_INST_TYPE_OPENCL_DEBUGINFO_100 &&
        debug_inst->ext_inst_type() !=
            SPV_EXT_INST_TYPE_NONSEMANTIC_SHADER_DEBUGINFO_100) ||
@@ -165,7 +165,7 @@ bool DoesDebugInfoOperandMatchExpectation(
     const Instruction* inst, uint32_t word_index) {
   if (inst->words().size() <= word_index) return false;
   auto* debug_inst = _.FindDef(inst->word(word_index));
-  if (debug_inst->opcode() != spv::Op::OpExtInst ||
+  if (!spvIsExtendedInstruction(debug_inst->opcode()) ||
       (debug_inst->ext_inst_type() !=
        SPV_EXT_INST_TYPE_NONSEMANTIC_SHADER_DEBUGINFO_100) ||
       !expectation(
@@ -409,7 +409,7 @@ spv_result_t ValidateClspvReflectionArgumentInfo(ValidationState_t& _,
 spv_result_t ValidateKernelDecl(ValidationState_t& _, const Instruction* inst) {
   const auto decl_id = inst->GetOperandAs<uint32_t>(4);
   const auto decl = _.FindDef(decl_id);
-  if (!decl || decl->opcode() != spv::Op::OpExtInst) {
+  if (!decl || !spvIsExtendedInstruction(decl->opcode())) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "Kernel must be a Kernel extended instruction";
   }
@@ -432,7 +432,7 @@ spv_result_t ValidateKernelDecl(ValidationState_t& _, const Instruction* inst) {
 spv_result_t ValidateArgInfo(ValidationState_t& _, const Instruction* inst,
                              uint32_t info_index) {
   auto info = _.FindDef(inst->GetOperandAs<uint32_t>(info_index));
-  if (!info || info->opcode() != spv::Op::OpExtInst) {
+  if (!info || !spvIsExtendedInstruction(info->opcode())) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "ArgInfo must be an ArgumentInfo extended instruction";
   }
@@ -1980,7 +1980,7 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
                     "CrossWorkgroup, Workgroup or Function";
         }
 
-        if (result_type != p_data_type) {
+        if (!_.ContainsUntypedPointer(p_type) && result_type != p_data_type) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected data type of the pointer to be equal to Result "
@@ -2042,15 +2042,17 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
                     "CrossWorkgroup, Workgroup or Function";
         }
 
-        if (!_.IsIntScalarOrVectorType(p_data_type) ||
-            _.GetBitWidth(p_data_type) != 32) {
+        if ((!_.IsIntScalarOrVectorType(p_data_type) ||
+             _.GetBitWidth(p_data_type) != 32) &&
+            !_.ContainsUntypedPointer(p_type)) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected data type of the pointer to be a 32-bit int "
                     "scalar or vector type";
         }
 
-        if (_.GetDimension(p_data_type) != num_components) {
+        if (!_.ContainsUntypedPointer(p_type) &&
+            _.GetDimension(p_data_type) != num_components) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected data type of the pointer to have the same number "
@@ -2701,8 +2703,9 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
                     "Generic, CrossWorkgroup, Workgroup or Function";
         }
 
-        if (!_.IsFloatScalarType(p_data_type) ||
-            _.GetBitWidth(p_data_type) != 16) {
+        if ((!_.IsFloatScalarType(p_data_type) ||
+             _.GetBitWidth(p_data_type) != 16) &&
+            !_.ContainsUntypedPointer(p_type)) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected operand P data type to be 16-bit float scalar";
@@ -2763,8 +2766,9 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
                     "Generic, CrossWorkgroup, Workgroup or Function";
         }
 
-        if (!_.IsFloatScalarType(p_data_type) ||
-            _.GetBitWidth(p_data_type) != 16) {
+        if ((!_.IsFloatScalarType(p_data_type) ||
+             _.GetBitWidth(p_data_type) != 16) &&
+            !_.ContainsUntypedPointer(p_type)) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected operand P data type to be 16-bit float scalar";
@@ -2855,8 +2859,9 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
                     "CrossWorkgroup, Workgroup or Function";
         }
 
-        if (!_.IsFloatScalarType(p_data_type) ||
-            _.GetBitWidth(p_data_type) != 16) {
+        if ((!_.IsFloatScalarType(p_data_type) ||
+             _.GetBitWidth(p_data_type) != 16) &&
+            !_.ContainsUntypedPointer(p_type)) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected operand P data type to be 16-bit float scalar";
@@ -2962,14 +2967,41 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
                  << "expected operand Format to be a pointer";
         }
 
-        if (format_storage_class != spv::StorageClass::UniformConstant) {
-          return _.diag(SPV_ERROR_INVALID_DATA, inst)
-                 << ext_inst_name() << ": "
-                 << "expected Format storage class to be UniformConstant";
+        if (_.HasExtension(
+                Extension::kSPV_EXT_relaxed_printf_string_address_space)) {
+          if (format_storage_class != spv::StorageClass::UniformConstant &&
+              // Extension SPV_EXT_relaxed_printf_string_address_space allows
+              // format strings in Global, Local, Private and Generic address
+              // spaces
+
+              // Global
+              format_storage_class != spv::StorageClass::CrossWorkgroup &&
+              // Local
+              format_storage_class != spv::StorageClass::Workgroup &&
+              // Private
+              format_storage_class != spv::StorageClass::Function &&
+              // Generic
+              format_storage_class != spv::StorageClass::Generic) {
+            return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                   << ext_inst_name() << ": "
+                   << "expected Format storage class to be UniformConstant, "
+                      "Crossworkgroup, Workgroup, Function, or Generic";
+          }
+        } else {
+          if (format_storage_class != spv::StorageClass::UniformConstant) {
+            return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                   << ext_inst_name() << ": "
+                   << "expected Format storage class to be UniformConstant";
+          }
         }
 
-        if (!_.IsIntScalarType(format_data_type) ||
-            _.GetBitWidth(format_data_type) != 8) {
+        // If pointer points to an array, get the type of an element
+        if (_.IsIntArrayType(format_data_type))
+          format_data_type = _.GetComponentType(format_data_type);
+
+        if ((!_.IsIntScalarType(format_data_type) ||
+             _.GetBitWidth(format_data_type) != 8) &&
+            !_.ContainsUntypedPointer(format_type)) {
           return _.diag(SPV_ERROR_INVALID_DATA, inst)
                  << ext_inst_name() << ": "
                  << "expected Format data type to be 8-bit int";
@@ -3058,7 +3090,6 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
         // validation.
         case NonSemanticShaderDebugInfo100DebugInfoNone:
         case NonSemanticShaderDebugInfo100DebugCompilationUnit:
-        case NonSemanticShaderDebugInfo100DebugTypeBasic:
         case NonSemanticShaderDebugInfo100DebugTypePointer:
         case NonSemanticShaderDebugInfo100DebugTypeQualifier:
         case NonSemanticShaderDebugInfo100DebugTypeArray:
@@ -3084,7 +3115,6 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
         case NonSemanticShaderDebugInfo100DebugInlinedAt:
         case NonSemanticShaderDebugInfo100DebugLocalVariable:
         case NonSemanticShaderDebugInfo100DebugInlinedVariable:
-        case NonSemanticShaderDebugInfo100DebugDeclare:
         case NonSemanticShaderDebugInfo100DebugValue:
         case NonSemanticShaderDebugInfo100DebugOperation:
         case NonSemanticShaderDebugInfo100DebugExpression:
@@ -3093,6 +3123,24 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
         case NonSemanticShaderDebugInfo100DebugImportedEntity:
         case NonSemanticShaderDebugInfo100DebugSource:
           break;
+
+        // These checks are for operands that are differnet in
+        // ShaderDebugInfo100
+        case NonSemanticShaderDebugInfo100DebugTypeBasic: {
+          CHECK_CONST_UINT_OPERAND("Flags", 8);
+          break;
+        }
+        case NonSemanticShaderDebugInfo100DebugDeclare: {
+          for (uint32_t word_index = 8; word_index < num_words; ++word_index) {
+            auto index_inst = _.FindDef(inst->word(word_index));
+            auto type_id = index_inst != nullptr ? index_inst->type_id() : 0;
+            if (type_id == 0 || !IsIntScalar(_, type_id, false, false))
+              return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                     << ext_inst_name() << ": "
+                     << "expected index must be scalar integer";
+          }
+          break;
+        }
         case NonSemanticShaderDebugInfo100DebugTypeMatrix: {
           CHECK_DEBUG_OPERAND("Vector Type", CommonDebugInfoDebugTypeVector, 5);
 
@@ -3100,7 +3148,7 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
 
           uint32_t vector_count = inst->word(6);
           uint64_t const_val;
-          if (!_.GetConstantValUint64(vector_count, &const_val)) {
+          if (!_.EvalConstantValUint64(vector_count, &const_val)) {
             return _.diag(SPV_ERROR_INVALID_DATA, inst)
                    << ext_inst_name()
                    << ": Vector Count must be 32-bit integer OpConstant";
@@ -3114,14 +3162,83 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
           }
           break;
         }
-        // TODO: Add validation rules for remaining cases as well.
-        case NonSemanticShaderDebugInfo100DebugFunctionDefinition:
-        case NonSemanticShaderDebugInfo100DebugSourceContinued:
-        case NonSemanticShaderDebugInfo100DebugLine:
+        case NonSemanticShaderDebugInfo100DebugFunctionDefinition: {
+          CHECK_DEBUG_OPERAND("Function", CommonDebugInfoDebugFunction, 5);
+          CHECK_OPERAND("Definition", spv::Op::OpFunction, 6);
+          const auto* current_function = inst->function();
+          if (current_function->first_block()->id() != inst->block()->id()) {
+            return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                   << ext_inst_name()
+                   << ": must be in the entry basic block of the function";
+          }
+
+          const uint32_t definition_id = inst->word(6);
+          if (definition_id != current_function->id()) {
+            return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                   << ext_inst_name()
+                   << ": operand Definition must point to the OpFunction it is "
+                      "inside";
+          }
+          break;
+        }
+        case NonSemanticShaderDebugInfo100DebugLine: {
+          CHECK_DEBUG_OPERAND("Source", CommonDebugInfoDebugSource, 5);
+          CHECK_CONST_UINT_OPERAND("Line Start", 6);
+          CHECK_CONST_UINT_OPERAND("Line End", 7);
+          CHECK_CONST_UINT_OPERAND("Column Start", 8);
+          CHECK_CONST_UINT_OPERAND("Column End", 9);
+
+          // above already validates if 32-bit and non-spec constant
+          // but want to use EvalInt32IfConst to be consistent with other Eval
+          // locations
+          bool is_int32 = false, is_const_int32 = false;
+          uint32_t line_start = 0;
+          uint32_t line_end = 0;
+          uint32_t column_start = 0;
+          uint32_t column_end = 0;
+          std::tie(is_int32, is_const_int32, line_start) =
+              _.EvalInt32IfConst(inst->word(6));
+          std::tie(is_int32, is_const_int32, line_end) =
+              _.EvalInt32IfConst(inst->word(7));
+          std::tie(is_int32, is_const_int32, column_start) =
+              _.EvalInt32IfConst(inst->word(8));
+          std::tie(is_int32, is_const_int32, column_end) =
+              _.EvalInt32IfConst(inst->word(9));
+          if (line_end < line_start) {
+            return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                   << ext_inst_name() << ": operand Line End (" << line_end
+                   << ") is less than Line Start (" << line_start << ")";
+          } else if (column_end < column_start) {
+            return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                   << ext_inst_name() << ": operand Column End (" << column_end
+                   << ") is less than Column Start (" << column_start << ")";
+          }
+          break;
+        }
+        case NonSemanticShaderDebugInfo100DebugSourceContinued: {
+          CHECK_OPERAND("Text", spv::Op::OpString, 5);
+          break;
+        }
+        case NonSemanticShaderDebugInfo100DebugBuildIdentifier: {
+          CHECK_OPERAND("Identifier", spv::Op::OpString, 5);
+          CHECK_CONST_UINT_OPERAND("Flags", 6);
+          break;
+        }
+        case NonSemanticShaderDebugInfo100DebugStoragePath: {
+          CHECK_OPERAND("Path", spv::Op::OpString, 5);
+          break;
+        }
+        case NonSemanticShaderDebugInfo100DebugEntryPoint: {
+          CHECK_DEBUG_OPERAND("Entry Point", CommonDebugInfoDebugFunction, 5);
+          CHECK_DEBUG_OPERAND("Compilation Unit",
+                              CommonDebugInfoDebugCompilationUnit, 6);
+          CHECK_OPERAND("Compiler Signature", spv::Op::OpString, 7);
+          CHECK_OPERAND("Command-line Arguments", spv::Op::OpString, 8);
+          break;
+        }
+
+          // Has no additional checks
         case NonSemanticShaderDebugInfo100DebugNoLine:
-        case NonSemanticShaderDebugInfo100DebugBuildIdentifier:
-        case NonSemanticShaderDebugInfo100DebugStoragePath:
-        case NonSemanticShaderDebugInfo100DebugEntryPoint:
           break;
         case NonSemanticShaderDebugInfo100InstructionsMax:
           assert(0);
@@ -3191,7 +3308,7 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
           uint32_t component_count = inst->word(6);
           if (vulkanDebugInfo) {
             uint64_t const_val;
-            if (!_.GetConstantValUint64(component_count, &const_val)) {
+            if (!_.EvalConstantValUint64(component_count, &const_val)) {
               return _.diag(SPV_ERROR_INVALID_DATA, inst)
                      << ext_inst_name()
                      << ": Component Count must be 32-bit integer OpConstant";
@@ -3423,9 +3540,7 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
         }
         case CommonDebugInfoDebugFunction: {
           CHECK_OPERAND("Name", spv::Op::OpString, 5);
-          auto validate_type = ValidateOperandDebugType(_, "Type", inst, 6,
-                                                        ext_inst_name, false);
-          if (validate_type != SPV_SUCCESS) return validate_type;
+          CHECK_DEBUG_OPERAND("Type", CommonDebugInfoDebugTypeFunction, 6);
           CHECK_DEBUG_OPERAND("Source", CommonDebugInfoDebugSource, 7);
           CHECK_CONST_UINT_OPERAND("Line", 8);
           CHECK_CONST_UINT_OPERAND("Column", 9);
@@ -3460,9 +3575,7 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
         }
         case CommonDebugInfoDebugFunctionDeclaration: {
           CHECK_OPERAND("Name", spv::Op::OpString, 5);
-          auto validate_type = ValidateOperandDebugType(_, "Type", inst, 6,
-                                                        ext_inst_name, false);
-          if (validate_type != SPV_SUCCESS) return validate_type;
+          CHECK_DEBUG_OPERAND("Type", CommonDebugInfoDebugTypeFunction, 6);
           CHECK_DEBUG_OPERAND("Source", CommonDebugInfoDebugSource, 7);
           CHECK_CONST_UINT_OPERAND("Line", 8);
           CHECK_CONST_UINT_OPERAND("Column", 9);
@@ -3524,18 +3637,6 @@ spv_result_t ValidateExtInst(ValidationState_t& _, const Instruction* inst) {
           }
 
           CHECK_DEBUG_OPERAND("Expression", CommonDebugInfoDebugExpression, 7);
-
-          if (vulkanDebugInfo) {
-            for (uint32_t word_index = 8; word_index < num_words;
-                 ++word_index) {
-              auto index_inst = _.FindDef(inst->word(word_index));
-              auto type_id = index_inst != nullptr ? index_inst->type_id() : 0;
-              if (type_id == 0 || !IsIntScalar(_, type_id, false, false))
-                return _.diag(SPV_ERROR_INVALID_DATA, inst)
-                       << ext_inst_name() << ": "
-                       << "expected index must be scalar integer";
-            }
-          }
           break;
         }
         case CommonDebugInfoDebugExpression: {
@@ -3706,7 +3807,7 @@ spv_result_t ExtensionPass(ValidationState_t& _, const Instruction* inst) {
   const spv::Op opcode = inst->opcode();
   if (opcode == spv::Op::OpExtension) return ValidateExtension(_, inst);
   if (opcode == spv::Op::OpExtInstImport) return ValidateExtInstImport(_, inst);
-  if (opcode == spv::Op::OpExtInst) return ValidateExtInst(_, inst);
+  if (spvIsExtendedInstruction(opcode)) return ValidateExtInst(_, inst);
 
   return SPV_SUCCESS;
 }
diff --git a/source/val/validate_function.cpp b/source/val/validate_function.cpp
index 639817fe..624b4e24 100644
--- a/source/val/validate_function.cpp
+++ b/source/val/validate_function.cpp
@@ -86,7 +86,10 @@ spv_result_t ValidateFunction(ValidationState_t& _, const Instruction* inst) {
       spv::Op::OpGetKernelPreferredWorkGroupSizeMultiple,
       spv::Op::OpGetKernelLocalSizeForSubgroupCount,
       spv::Op::OpGetKernelMaxNumSubgroups,
-      spv::Op::OpName};
+      spv::Op::OpName,
+      spv::Op::OpCooperativeMatrixPerElementOpNV,
+      spv::Op::OpCooperativeMatrixReduceNV,
+      spv::Op::OpCooperativeMatrixLoadTensorNV};
   for (auto& pair : inst->uses()) {
     const auto* use = pair.first;
     if (std::find(acceptable.begin(), acceptable.end(), use->opcode()) ==
@@ -156,7 +159,9 @@ spv_result_t ValidateFunctionParameter(ValidationState_t& _,
     param_nonarray_type_id =
         _.FindDef(param_nonarray_type_id)->GetOperandAs<uint32_t>(1u);
   }
-  if (_.GetIdOpcode(param_nonarray_type_id) == spv::Op::OpTypePointer) {
+  if (_.GetIdOpcode(param_nonarray_type_id) == spv::Op::OpTypePointer ||
+      _.GetIdOpcode(param_nonarray_type_id) ==
+          spv::Op::OpTypeUntypedPointerKHR) {
     auto param_nonarray_type = _.FindDef(param_nonarray_type_id);
     if (param_nonarray_type->GetOperandAs<spv::StorageClass>(1u) ==
         spv::StorageClass::PhysicalStorageBuffer) {
@@ -185,7 +190,7 @@ spv_result_t ValidateFunctionParameter(ValidationState_t& _,
                << ": can't specify both Aliased and Restrict for "
                   "PhysicalStorageBuffer pointer.";
       }
-    } else {
+    } else if (param_nonarray_type->opcode() == spv::Op::OpTypePointer) {
       const auto pointee_type_id =
           param_nonarray_type->GetOperandAs<uint32_t>(2);
       const auto pointee_type = _.FindDef(pointee_type_id);
@@ -278,7 +283,7 @@ spv_result_t ValidateFunctionCall(ValidationState_t& _,
         function_type->GetOperandAs<uint32_t>(param_index);
     const auto parameter_type = _.FindDef(parameter_type_id);
     if (!parameter_type || argument_type->id() != parameter_type->id()) {
-      if (!_.options()->before_hlsl_legalization ||
+      if (!parameter_type || !_.options()->before_hlsl_legalization ||
           !DoPointeesLogicallyMatch(argument_type, parameter_type, _)) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
                << "OpFunctionCall Argument <id> " << _.getIdName(argument_id)
@@ -288,7 +293,8 @@ spv_result_t ValidateFunctionCall(ValidationState_t& _,
     }
 
     if (_.addressing_model() == spv::AddressingModel::Logical) {
-      if (parameter_type->opcode() == spv::Op::OpTypePointer &&
+      if ((parameter_type->opcode() == spv::Op::OpTypePointer ||
+           parameter_type->opcode() == spv::Op::OpTypeUntypedPointerKHR) &&
           !_.options()->relax_logical_pointer) {
         spv::StorageClass sc =
             parameter_type->GetOperandAs<spv::StorageClass>(1u);
@@ -317,9 +323,11 @@ spv_result_t ValidateFunctionCall(ValidationState_t& _,
 
         // Validate memory object declaration requirements.
         if (argument->opcode() != spv::Op::OpVariable &&
+            argument->opcode() != spv::Op::OpUntypedVariableKHR &&
             argument->opcode() != spv::Op::OpFunctionParameter) {
-          const bool ssbo_vptr = _.features().variable_pointers &&
-                                 sc == spv::StorageClass::StorageBuffer;
+          const bool ssbo_vptr =
+              _.HasCapability(spv::Capability::VariablePointersStorageBuffer) &&
+              sc == spv::StorageClass::StorageBuffer;
           const bool wg_vptr =
               _.HasCapability(spv::Capability::VariablePointers) &&
               sc == spv::StorageClass::Workgroup;
@@ -336,6 +344,80 @@ spv_result_t ValidateFunctionCall(ValidationState_t& _,
   return SPV_SUCCESS;
 }
 
+spv_result_t ValidateCooperativeMatrixPerElementOp(ValidationState_t& _,
+                                                   const Instruction* inst) {
+  const auto function_id = inst->GetOperandAs<uint32_t>(3);
+  const auto function = _.FindDef(function_id);
+  if (!function || spv::Op::OpFunction != function->opcode()) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV Function <id> "
+           << _.getIdName(function_id) << " is not a function.";
+  }
+
+  const auto matrix_id = inst->GetOperandAs<uint32_t>(2);
+  const auto matrix = _.FindDef(matrix_id);
+  const auto matrix_type_id = matrix->type_id();
+  if (!_.IsCooperativeMatrixKHRType(matrix_type_id)) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV Matrix <id> "
+           << _.getIdName(matrix_id) << " is not a cooperative matrix.";
+  }
+
+  const auto result_type_id = inst->GetOperandAs<uint32_t>(0);
+  if (matrix_type_id != result_type_id) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV Result Type <id> "
+           << _.getIdName(result_type_id) << " must match matrix type <id> "
+           << _.getIdName(matrix_type_id) << ".";
+  }
+
+  const auto matrix_comp_type_id =
+      _.FindDef(matrix_type_id)->GetOperandAs<uint32_t>(1);
+  const auto function_type_id = function->GetOperandAs<uint32_t>(3);
+  const auto function_type = _.FindDef(function_type_id);
+  auto return_type_id = function_type->GetOperandAs<uint32_t>(1);
+  if (return_type_id != matrix_comp_type_id) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV function return type <id> "
+           << _.getIdName(return_type_id)
+           << " must match matrix component type <id> "
+           << _.getIdName(matrix_comp_type_id) << ".";
+  }
+
+  if (function_type->operands().size() < 5) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV function type <id> "
+           << _.getIdName(function_type_id)
+           << " must have a least three parameters.";
+  }
+
+  const auto param0_id = function_type->GetOperandAs<uint32_t>(2);
+  const auto param1_id = function_type->GetOperandAs<uint32_t>(3);
+  const auto param2_id = function_type->GetOperandAs<uint32_t>(4);
+  if (!_.IsIntScalarType(param0_id) || _.GetBitWidth(param0_id) != 32) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV function type first parameter "
+              "type <id> "
+           << _.getIdName(param0_id) << " must be a 32-bit integer.";
+  }
+
+  if (!_.IsIntScalarType(param1_id) || _.GetBitWidth(param1_id) != 32) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV function type second "
+              "parameter type <id> "
+           << _.getIdName(param1_id) << " must be a 32-bit integer.";
+  }
+
+  if (param2_id != matrix_comp_type_id) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "OpCooperativeMatrixPerElementOpNV function type third parameter "
+              "type <id> "
+           << _.getIdName(param2_id) << " must match matrix component type.";
+  }
+
+  return SPV_SUCCESS;
+}
+
 }  // namespace
 
 spv_result_t FunctionPass(ValidationState_t& _, const Instruction* inst) {
@@ -349,6 +431,10 @@ spv_result_t FunctionPass(ValidationState_t& _, const Instruction* inst) {
     case spv::Op::OpFunctionCall:
       if (auto error = ValidateFunctionCall(_, inst)) return error;
       break;
+    case spv::Op::OpCooperativeMatrixPerElementOpNV:
+      if (auto error = ValidateCooperativeMatrixPerElementOp(_, inst))
+        return error;
+      break;
     default:
       break;
   }
diff --git a/source/val/validate_id.cpp b/source/val/validate_id.cpp
index bcfeb591..00be150c 100644
--- a/source/val/validate_id.cpp
+++ b/source/val/validate_id.cpp
@@ -120,15 +120,16 @@ spv_result_t CheckIdDefinitionDominateUse(ValidationState_t& _) {
 // instruction operand's ID can be forward referenced.
 spv_result_t IdPass(ValidationState_t& _, Instruction* inst) {
   auto can_have_forward_declared_ids =
-      inst->opcode() == spv::Op::OpExtInst &&
+      spvIsExtendedInstruction(inst->opcode()) &&
               spvExtInstIsDebugInfo(inst->ext_inst_type())
           ? spvDbgInfoExtOperandCanBeForwardDeclaredFunction(
-                inst->ext_inst_type(), inst->word(4))
+                inst->opcode(), inst->ext_inst_type(), inst->word(4))
           : spvOperandCanBeForwardDeclaredFunction(inst->opcode());
 
   // Keep track of a result id defined by this instruction.  0 means it
   // does not define an id.
   uint32_t result_id = 0;
+  bool has_forward_declared_ids = false;
 
   for (unsigned i = 0; i < inst->operands().size(); i++) {
     const spv_parsed_operand_t& operand = inst->operand(i);
@@ -162,8 +163,11 @@ spv_result_t IdPass(ValidationState_t& _, Instruction* inst) {
               !spvOpcodeGeneratesType(opcode) && !spvOpcodeIsDebug(opcode) &&
               !inst->IsDebugInfo() && !inst->IsNonSemantic() &&
               !spvOpcodeIsDecoration(opcode) && opcode != spv::Op::OpFunction &&
+              opcode != spv::Op::OpSizeOf &&
               opcode != spv::Op::OpCooperativeMatrixLengthNV &&
               opcode != spv::Op::OpCooperativeMatrixLengthKHR &&
+              !spvOpcodeGeneratesUntypedPointer(opcode) &&
+              opcode != spv::Op::OpUntypedArrayLengthKHR &&
               !(opcode == spv::Op::OpSpecConstantOp &&
                 (spv::Op(inst->word(3)) ==
                      spv::Op::OpCooperativeMatrixLengthNV ||
@@ -177,12 +181,16 @@ spv_result_t IdPass(ValidationState_t& _, Instruction* inst) {
                      !inst->IsNonSemantic() && !spvOpcodeIsDecoration(opcode) &&
                      !spvOpcodeIsBranch(opcode) && opcode != spv::Op::OpPhi &&
                      opcode != spv::Op::OpExtInst &&
+                     opcode != spv::Op::OpExtInstWithForwardRefsKHR &&
                      opcode != spv::Op::OpExtInstImport &&
                      opcode != spv::Op::OpSelectionMerge &&
                      opcode != spv::Op::OpLoopMerge &&
                      opcode != spv::Op::OpFunction &&
+                     opcode != spv::Op::OpSizeOf &&
                      opcode != spv::Op::OpCooperativeMatrixLengthNV &&
                      opcode != spv::Op::OpCooperativeMatrixLengthKHR &&
+                     !spvOpcodeGeneratesUntypedPointer(opcode) &&
+                     opcode != spv::Op::OpUntypedArrayLengthKHR &&
                      !(opcode == spv::Op::OpSpecConstantOp &&
                        (spv::Op(inst->word(3)) ==
                             spv::Op::OpCooperativeMatrixLengthNV ||
@@ -200,6 +208,7 @@ spv_result_t IdPass(ValidationState_t& _, Instruction* inst) {
             ret = SPV_SUCCESS;
           }
         } else if (can_have_forward_declared_ids(i)) {
+          has_forward_declared_ids = true;
           if (spvOpcodeGeneratesType(inst->opcode()) &&
               !_.IsForwardPointer(operand_word)) {
             ret = _.diag(SPV_ERROR_INVALID_ID, inst)
@@ -229,12 +238,35 @@ spv_result_t IdPass(ValidationState_t& _, Instruction* inst) {
                 << " has not been defined";
         }
         break;
+      case SPV_OPERAND_TYPE_EXTENSION_INSTRUCTION_NUMBER:
+        // Ideally, this check would live in validate_extensions.cpp. But since
+        // forward references are only allowed on non-semantic instructions, and
+        // ID validation is done first, we would fail with a "ID had not been
+        // defined" error before we could give a more helpful message. For this
+        // reason, this test is done here, so we can be more helpful to the
+        // user.
+        if (inst->opcode() == spv::Op::OpExtInstWithForwardRefsKHR &&
+            !inst->IsNonSemantic())
+          return _.diag(SPV_ERROR_INVALID_DATA, inst)
+                 << "OpExtInstWithForwardRefsKHR is only allowed with "
+                    "non-semantic instructions.";
+        ret = SPV_SUCCESS;
+        break;
       default:
         ret = SPV_SUCCESS;
         break;
     }
     if (SPV_SUCCESS != ret) return ret;
   }
+  const bool must_have_forward_declared_ids =
+      inst->opcode() == spv::Op::OpExtInstWithForwardRefsKHR;
+  if (must_have_forward_declared_ids && !has_forward_declared_ids) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "Opcode OpExtInstWithForwardRefsKHR must have at least one "
+              "forward "
+              "declared ID.";
+  }
+
   if (result_id) _.RemoveIfForwardDeclared(result_id);
 
   return SPV_SUCCESS;
diff --git a/source/val/validate_image.cpp b/source/val/validate_image.cpp
index 39eeb4bd..04100dd7 100644
--- a/source/val/validate_image.cpp
+++ b/source/val/validate_image.cpp
@@ -495,7 +495,7 @@ spv_result_t ValidateImageOperands(ValidationState_t& _,
     }
 
     uint64_t array_size = 0;
-    if (!_.GetConstantValUint64(type_inst->word(3), &array_size)) {
+    if (!_.EvalConstantValUint64(type_inst->word(3), &array_size)) {
       assert(0 && "Array type definition is corrupt");
     }
 
@@ -914,7 +914,15 @@ spv_result_t ValidateTypeImage(ValidationState_t& _, const Instruction* inst) {
 
     if (info.dim == spv::Dim::SubpassData && info.arrayed != 0) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
-             << _.VkErrorID(6214) << "Dim SubpassData requires Arrayed to be 0";
+             << _.VkErrorID(6214)
+             << "Dim SubpassData requires Arrayed to be 0 in the Vulkan "
+                "environment";
+    }
+
+    if (info.dim == spv::Dim::Rect) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << _.VkErrorID(9638)
+             << "Dim must not be Rect in the Vulkan environment";
     }
   }
 
@@ -982,6 +990,10 @@ bool IsAllowedSampledImageOperand(spv::Op opcode, ValidationState_t& _) {
     case spv::Op::OpImageBoxFilterQCOM:
     case spv::Op::OpImageBlockMatchSSDQCOM:
     case spv::Op::OpImageBlockMatchSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSSDQCOM:
+    case spv::Op::OpImageBlockMatchGatherSADQCOM:
+    case spv::Op::OpImageBlockMatchGatherSSDQCOM:
       return true;
     case spv::Op::OpStore:
       if (_.HasCapability(spv::Capability::BindlessTextureNV)) return true;
@@ -993,7 +1005,8 @@ bool IsAllowedSampledImageOperand(spv::Op opcode, ValidationState_t& _) {
 
 spv_result_t ValidateSampledImage(ValidationState_t& _,
                                   const Instruction* inst) {
-  if (_.GetIdOpcode(inst->type_id()) != spv::Op::OpTypeSampledImage) {
+  auto type_inst = _.FindDef(inst->type_id());
+  if (type_inst->opcode() != spv::Op::OpTypeSampledImage) {
     return _.diag(SPV_ERROR_INVALID_DATA, inst)
            << "Expected Result Type to be OpTypeSampledImage.";
   }
@@ -1010,8 +1023,25 @@ spv_result_t ValidateSampledImage(ValidationState_t& _,
            << "Corrupt image type definition";
   }
 
-  // TODO(atgoo@github.com) Check compatibility of result type and received
-  // image.
+  // Image operands must match except for depth.
+  auto sampled_image_id = type_inst->GetOperandAs<uint32_t>(1);
+  if (sampled_image_id != image_type) {
+    ImageTypeInfo sampled_info;
+    if (!GetImageTypeInfo(_, sampled_image_id, &sampled_info)) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "Corrupt image type definition";
+    }
+    if (info.sampled_type != sampled_info.sampled_type ||
+        info.dim != sampled_info.dim || info.arrayed != sampled_info.arrayed ||
+        info.multisampled != sampled_info.multisampled ||
+        info.sampled != sampled_info.sampled ||
+        info.format != sampled_info.format ||
+        info.access_qualifier != sampled_info.access_qualifier) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "Image operands must match result image operands except for "
+                "depth";
+    }
+  }
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
     if (info.sampled != 1) {
@@ -1103,25 +1133,33 @@ spv_result_t ValidateSampledImage(ValidationState_t& _,
 spv_result_t ValidateImageTexelPointer(ValidationState_t& _,
                                        const Instruction* inst) {
   const auto result_type = _.FindDef(inst->type_id());
-  if (result_type->opcode() != spv::Op::OpTypePointer) {
+  if (result_type->opcode() != spv::Op::OpTypePointer &&
+      result_type->opcode() != spv::Op::OpTypeUntypedPointerKHR) {
     return _.diag(SPV_ERROR_INVALID_DATA, inst)
-           << "Expected Result Type to be OpTypePointer";
+           << "Expected Result Type to be a pointer";
   }
 
   const auto storage_class = result_type->GetOperandAs<spv::StorageClass>(1);
   if (storage_class != spv::StorageClass::Image) {
     return _.diag(SPV_ERROR_INVALID_DATA, inst)
-           << "Expected Result Type to be OpTypePointer whose Storage Class "
+           << "Expected Result Type to be a pointer whose Storage Class "
               "operand is Image";
   }
 
-  const auto ptr_type = result_type->GetOperandAs<uint32_t>(2);
-  const auto ptr_opcode = _.GetIdOpcode(ptr_type);
-  if (ptr_opcode != spv::Op::OpTypeInt && ptr_opcode != spv::Op::OpTypeFloat &&
-      ptr_opcode != spv::Op::OpTypeVoid) {
-    return _.diag(SPV_ERROR_INVALID_DATA, inst)
-           << "Expected Result Type to be OpTypePointer whose Type operand "
-              "must be a scalar numerical type or OpTypeVoid";
+  uint32_t ptr_type = 0;
+  if (result_type->opcode() == spv::Op::OpTypePointer) {
+    ptr_type = result_type->GetOperandAs<uint32_t>(2);
+    const auto ptr_opcode = _.GetIdOpcode(ptr_type);
+    if (ptr_opcode != spv::Op::OpTypeInt &&
+        ptr_opcode != spv::Op::OpTypeFloat &&
+        ptr_opcode != spv::Op::OpTypeVoid &&
+        !(ptr_opcode == spv::Op::OpTypeVector &&
+          _.HasCapability(spv::Capability::AtomicFloat16VectorNV) &&
+          _.IsFloat16Vector2Or4Type(ptr_type))) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "Expected Result Type to be a pointer whose Type operand "
+                "must be a scalar numerical type or OpTypeVoid";
+    }
   }
 
   const auto image_ptr = _.FindDef(_.GetOperandTypeId(inst, 2));
@@ -1142,7 +1180,15 @@ spv_result_t ValidateImageTexelPointer(ValidationState_t& _,
            << "Corrupt image type definition";
   }
 
-  if (info.sampled_type != ptr_type) {
+  if (result_type->opcode() == spv::Op::OpTypePointer &&
+      info.sampled_type != ptr_type &&
+      !(_.HasCapability(spv::Capability::AtomicFloat16VectorNV) &&
+        _.IsFloat16Vector2Or4Type(ptr_type) &&
+        _.GetIdOpcode(info.sampled_type) == spv::Op::OpTypeFloat &&
+        ((_.GetDimension(ptr_type) == 2 &&
+          info.format == spv::ImageFormat::Rg16f) ||
+         (_.GetDimension(ptr_type) == 4 &&
+          info.format == spv::ImageFormat::Rgba16f)))) {
     return _.diag(SPV_ERROR_INVALID_DATA, inst)
            << "Expected Image 'Sampled Type' to be the same as the Type "
               "pointed to by Result Type";
@@ -1200,7 +1246,7 @@ spv_result_t ValidateImageTexelPointer(ValidationState_t& _,
 
   if (info.multisampled == 0) {
     uint64_t ms = 0;
-    if (!_.GetConstantValUint64(inst->GetOperandAs<uint32_t>(4), &ms) ||
+    if (!_.EvalConstantValUint64(inst->GetOperandAs<uint32_t>(4), &ms) ||
         ms != 0) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
              << "Expected Sample for Image with MS 0 to be a valid <id> for "
@@ -1213,7 +1259,10 @@ spv_result_t ValidateImageTexelPointer(ValidationState_t& _,
         (info.format != spv::ImageFormat::R64ui) &&
         (info.format != spv::ImageFormat::R32f) &&
         (info.format != spv::ImageFormat::R32i) &&
-        (info.format != spv::ImageFormat::R32ui)) {
+        (info.format != spv::ImageFormat::R32ui) &&
+        !((info.format == spv::ImageFormat::Rg16f ||
+           info.format == spv::ImageFormat::Rgba16f) &&
+          _.HasCapability(spv::Capability::AtomicFloat16VectorNV))) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
              << _.VkErrorID(4658)
              << "Expected the Image Format in Image to be R64i, R64ui, R32f, "
@@ -1977,11 +2026,13 @@ spv_result_t ValidateImageQueryLod(ValidationState_t& _,
       ->RegisterExecutionModelLimitation(
           [&](spv::ExecutionModel model, std::string* message) {
             if (model != spv::ExecutionModel::Fragment &&
-                model != spv::ExecutionModel::GLCompute) {
+                model != spv::ExecutionModel::GLCompute &&
+                model != spv::ExecutionModel::MeshEXT &&
+                model != spv::ExecutionModel::TaskEXT) {
               if (message) {
                 *message = std::string(
-                    "OpImageQueryLod requires Fragment or GLCompute execution "
-                    "model");
+                    "OpImageQueryLod requires Fragment, GLCompute, MeshEXT or "
+                    "TaskEXT execution model");
               }
               return false;
             }
@@ -1993,16 +2044,20 @@ spv_result_t ValidateImageQueryLod(ValidationState_t& _,
                               std::string* message) {
         const auto* models = state.GetExecutionModels(entry_point->id());
         const auto* modes = state.GetExecutionModes(entry_point->id());
-        if (models->find(spv::ExecutionModel::GLCompute) != models->end() &&
-            modes->find(spv::ExecutionMode::DerivativeGroupLinearNV) ==
-                modes->end() &&
-            modes->find(spv::ExecutionMode::DerivativeGroupQuadsNV) ==
-                modes->end()) {
+        if (models &&
+            (models->find(spv::ExecutionModel::GLCompute) != models->end() ||
+             models->find(spv::ExecutionModel::MeshEXT) != models->end() ||
+             models->find(spv::ExecutionModel::TaskEXT) != models->end()) &&
+            (!modes ||
+             (modes->find(spv::ExecutionMode::DerivativeGroupLinearKHR) ==
+                  modes->end() &&
+              modes->find(spv::ExecutionMode::DerivativeGroupQuadsKHR) ==
+                  modes->end()))) {
           if (message) {
             *message = std::string(
-                "OpImageQueryLod requires DerivativeGroupQuadsNV "
-                "or DerivativeGroupLinearNV execution mode for GLCompute "
-                "execution model");
+                "OpImageQueryLod requires DerivativeGroupQuadsKHR "
+                "or DerivativeGroupLinearKHR execution mode for GLCompute, "
+                "MeshEXT or TaskEXT execution model");
           }
           return false;
         }
@@ -2144,7 +2199,8 @@ spv_result_t ValidateImageProcessingQCOMDecoration(ValidationState_t& _, int id,
                                                    spv::Decoration decor) {
   const Instruction* si_inst = nullptr;
   const Instruction* ld_inst = _.FindDef(id);
-  if (ld_inst->opcode() == spv::Op::OpSampledImage) {
+  bool is_intf_obj = (ld_inst->opcode() == spv::Op::OpSampledImage);
+  if (is_intf_obj == true) {
     si_inst = ld_inst;
     int t_idx = si_inst->GetOperandAs<int>(2);  // texture
     ld_inst = _.FindDef(t_idx);
@@ -2155,7 +2211,57 @@ spv_result_t ValidateImageProcessingQCOMDecoration(ValidationState_t& _, int id,
   int texture_id = ld_inst->GetOperandAs<int>(2);  // variable to load
   if (!_.HasDecoration(texture_id, decor)) {
     return _.diag(SPV_ERROR_INVALID_DATA, ld_inst)
-           << "Missing decoration WeightTextureQCOM/BlockMatchTextureQCOM";
+           << "Missing decoration " << _.SpvDecorationString(decor);
+  }
+
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateImageProcessing2QCOMWindowDecoration(ValidationState_t& _,
+                                                          int id) {
+  const Instruction* ld_inst = _.FindDef(id);
+  bool is_intf_obj = (ld_inst->opcode() != spv::Op::OpSampledImage);
+  if (is_intf_obj == true) {
+    if (ld_inst->opcode() != spv::Op::OpLoad) {
+      return _.diag(SPV_ERROR_INVALID_DATA, ld_inst) << "Expect to see OpLoad";
+    }
+    int texture_id = ld_inst->GetOperandAs<int>(2);  // variable to load
+    spv::Decoration decor = spv::Decoration::BlockMatchTextureQCOM;
+    if (!_.HasDecoration(texture_id, decor)) {
+      return _.diag(SPV_ERROR_INVALID_DATA, ld_inst)
+             << "Missing decoration " << _.SpvDecorationString(decor);
+    }
+    decor = spv::Decoration::BlockMatchSamplerQCOM;
+    if (!_.HasDecoration(texture_id, decor)) {
+      return _.diag(SPV_ERROR_INVALID_DATA, ld_inst)
+             << "Missing decoration " << _.SpvDecorationString(decor);
+    }
+  } else {
+    const Instruction* si_inst = ld_inst;
+    int t_idx = si_inst->GetOperandAs<int>(2);  // texture
+    const Instruction* t_ld_inst = _.FindDef(t_idx);
+    if (t_ld_inst->opcode() != spv::Op::OpLoad) {
+      return _.diag(SPV_ERROR_INVALID_DATA, t_ld_inst)
+             << "Expect to see OpLoad";
+    }
+    int texture_id = t_ld_inst->GetOperandAs<int>(2);  // variable to load
+    spv::Decoration decor = spv::Decoration::BlockMatchTextureQCOM;
+    if (!_.HasDecoration(texture_id, decor)) {
+      return _.diag(SPV_ERROR_INVALID_DATA, ld_inst)
+             << "Missing decoration " << _.SpvDecorationString(decor);
+    }
+    int s_idx = si_inst->GetOperandAs<int>(3);  // sampler
+    const Instruction* s_ld_inst = _.FindDef(s_idx);
+    if (s_ld_inst->opcode() != spv::Op::OpLoad) {
+      return _.diag(SPV_ERROR_INVALID_DATA, s_ld_inst)
+             << "Expect to see OpLoad";
+    }
+    int sampler_id = s_ld_inst->GetOperandAs<int>(2);  // variable to load
+    decor = spv::Decoration::BlockMatchSamplerQCOM;
+    if (!_.HasDecoration(sampler_id, decor)) {
+      return _.diag(SPV_ERROR_INVALID_DATA, ld_inst)
+             << "Missing decoration " << _.SpvDecorationString(decor);
+    }
   }
 
   return SPV_SUCCESS;
@@ -2183,6 +2289,26 @@ spv_result_t ValidateImageProcessingQCOM(ValidationState_t& _,
           _, ref_idx, spv::Decoration::BlockMatchTextureQCOM);
       break;
     }
+    case spv::Op::OpImageBlockMatchWindowSSDQCOM:
+    case spv::Op::OpImageBlockMatchWindowSADQCOM: {
+      int tgt_idx = inst->GetOperandAs<int>(2);  // target
+      res = ValidateImageProcessing2QCOMWindowDecoration(_, tgt_idx);
+      if (res != SPV_SUCCESS) break;
+      int ref_idx = inst->GetOperandAs<int>(4);  // reference
+      res = ValidateImageProcessing2QCOMWindowDecoration(_, ref_idx);
+      break;
+    }
+    case spv::Op::OpImageBlockMatchGatherSSDQCOM:
+    case spv::Op::OpImageBlockMatchGatherSADQCOM: {
+      int tgt_idx = inst->GetOperandAs<int>(2);  // target
+      res = ValidateImageProcessingQCOMDecoration(
+          _, tgt_idx, spv::Decoration::BlockMatchTextureQCOM);
+      if (res != SPV_SUCCESS) break;
+      int ref_idx = inst->GetOperandAs<int>(4);  // reference
+      res = ValidateImageProcessingQCOMDecoration(
+          _, ref_idx, spv::Decoration::BlockMatchTextureQCOM);
+      break;
+    }
     default:
       break;
   }
@@ -2200,12 +2326,14 @@ spv_result_t ImagePass(ValidationState_t& _, const Instruction* inst) {
         ->RegisterExecutionModelLimitation([opcode](spv::ExecutionModel model,
                                                     std::string* message) {
           if (model != spv::ExecutionModel::Fragment &&
-              model != spv::ExecutionModel::GLCompute) {
+              model != spv::ExecutionModel::GLCompute &&
+              model != spv::ExecutionModel::MeshEXT &&
+              model != spv::ExecutionModel::TaskEXT) {
             if (message) {
               *message =
                   std::string(
-                      "ImplicitLod instructions require Fragment or GLCompute "
-                      "execution model: ") +
+                      "ImplicitLod instructions require Fragment, GLCompute, "
+                      "MeshEXT or TaskEXT execution model: ") +
                   spvOpcodeString(opcode);
             }
             return false;
@@ -2219,19 +2347,22 @@ spv_result_t ImagePass(ValidationState_t& _, const Instruction* inst) {
           const auto* models = state.GetExecutionModels(entry_point->id());
           const auto* modes = state.GetExecutionModes(entry_point->id());
           if (models &&
-              models->find(spv::ExecutionModel::GLCompute) != models->end() &&
+              (models->find(spv::ExecutionModel::GLCompute) != models->end() ||
+               models->find(spv::ExecutionModel::MeshEXT) != models->end() ||
+               models->find(spv::ExecutionModel::TaskEXT) != models->end()) &&
               (!modes ||
-               (modes->find(spv::ExecutionMode::DerivativeGroupLinearNV) ==
+               (modes->find(spv::ExecutionMode::DerivativeGroupLinearKHR) ==
                     modes->end() &&
-                modes->find(spv::ExecutionMode::DerivativeGroupQuadsNV) ==
+                modes->find(spv::ExecutionMode::DerivativeGroupQuadsKHR) ==
                     modes->end()))) {
             if (message) {
-              *message =
-                  std::string(
-                      "ImplicitLod instructions require DerivativeGroupQuadsNV "
-                      "or DerivativeGroupLinearNV execution mode for GLCompute "
-                      "execution model: ") +
-                  spvOpcodeString(opcode);
+              *message = std::string(
+                             "ImplicitLod instructions require "
+                             "DerivativeGroupQuadsKHR "
+                             "or DerivativeGroupLinearKHR execution mode for "
+                             "GLCompute, "
+                             "MeshEXT or TaskEXT execution model: ") +
+                         spvOpcodeString(opcode);
             }
             return false;
           }
@@ -2313,6 +2444,10 @@ spv_result_t ImagePass(ValidationState_t& _, const Instruction* inst) {
     case spv::Op::OpImageBoxFilterQCOM:
     case spv::Op::OpImageBlockMatchSSDQCOM:
     case spv::Op::OpImageBlockMatchSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSSDQCOM:
+    case spv::Op::OpImageBlockMatchGatherSADQCOM:
+    case spv::Op::OpImageBlockMatchGatherSSDQCOM:
       return ValidateImageProcessingQCOM(_, inst);
 
     default:
@@ -2365,6 +2500,10 @@ bool IsImageInstruction(const spv::Op opcode) {
     case spv::Op::OpImageBoxFilterQCOM:
     case spv::Op::OpImageBlockMatchSSDQCOM:
     case spv::Op::OpImageBlockMatchSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSSDQCOM:
+    case spv::Op::OpImageBlockMatchGatherSADQCOM:
+    case spv::Op::OpImageBlockMatchGatherSSDQCOM:
       return true;
     default:
       break;
@@ -2383,6 +2522,11 @@ spv_result_t ValidateQCOMImageProcessingTextureUsages(ValidationState_t& _,
     case spv::Op::OpImageBlockMatchSSDQCOM:
     case spv::Op::OpImageBlockMatchSADQCOM:
       break;
+    case spv::Op::OpImageBlockMatchWindowSADQCOM:
+    case spv::Op::OpImageBlockMatchWindowSSDQCOM:
+    case spv::Op::OpImageBlockMatchGatherSADQCOM:
+    case spv::Op::OpImageBlockMatchGatherSSDQCOM:
+      break;
     default:
       for (size_t i = 0; i < inst->operands().size(); ++i) {
         int id = inst->GetOperandAs<int>(i);
diff --git a/source/val/validate_instruction.cpp b/source/val/validate_instruction.cpp
index 5bc4d2ce..39b1c021 100644
--- a/source/val/validate_instruction.cpp
+++ b/source/val/validate_instruction.cpp
@@ -475,6 +475,12 @@ spv_result_t InstructionPass(ValidationState_t& _, const Instruction* inst) {
     const uint32_t entry_point = inst->word(1);
     _.RegisterExecutionModeForEntryPoint(entry_point,
                                          spv::ExecutionMode(inst->word(2)));
+    if (inst->GetOperandAs<spv::ExecutionMode>(1) ==
+            spv::ExecutionMode::LocalSize ||
+        inst->GetOperandAs<spv::ExecutionMode>(1) ==
+            spv::ExecutionMode::LocalSizeId) {
+      _.RegisterEntryPointLocalSize(entry_point, inst);
+    }
   } else if (opcode == spv::Op::OpVariable) {
     const auto storage_class = inst->GetOperandAs<spv::StorageClass>(2);
     if (auto error = LimitCheckNumVars(_, inst->id(), storage_class)) {
diff --git a/source/val/validate_interfaces.cpp b/source/val/validate_interfaces.cpp
index 54ebfd78..8b96dc82 100644
--- a/source/val/validate_interfaces.cpp
+++ b/source/val/validate_interfaces.cpp
@@ -34,11 +34,13 @@ const uint32_t kMaxLocations = 4096 * 4;
 bool is_interface_variable(const Instruction* inst, bool is_spv_1_4) {
   if (is_spv_1_4) {
     // Starting in SPIR-V 1.4, all global variables are interface variables.
-    return inst->opcode() == spv::Op::OpVariable &&
+    return (inst->opcode() == spv::Op::OpVariable ||
+            inst->opcode() == spv::Op::OpUntypedVariableKHR) &&
            inst->GetOperandAs<spv::StorageClass>(2u) !=
                spv::StorageClass::Function;
   } else {
-    return inst->opcode() == spv::Op::OpVariable &&
+    return (inst->opcode() == spv::Op::OpVariable ||
+            inst->opcode() == spv::Op::OpUntypedVariableKHR) &&
            (inst->GetOperandAs<spv::StorageClass>(2u) ==
                 spv::StorageClass::Input ||
             inst->GetOperandAs<spv::StorageClass>(2u) ==
@@ -242,8 +244,9 @@ spv_result_t GetLocationsForVariable(
     std::unordered_set<uint32_t>* output_index1_locations) {
   const bool is_fragment = entry_point->GetOperandAs<spv::ExecutionModel>(0) ==
                            spv::ExecutionModel::Fragment;
-  const bool is_output =
-      variable->GetOperandAs<spv::StorageClass>(2) == spv::StorageClass::Output;
+  const auto sc_index = 2u;
+  const bool is_output = variable->GetOperandAs<spv::StorageClass>(sc_index) ==
+                         spv::StorageClass::Output;
   auto ptr_type_id = variable->GetOperandAs<uint32_t>(0);
   auto ptr_type = _.FindDef(ptr_type_id);
   auto type_id = ptr_type->GetOperandAs<uint32_t>(2);
@@ -254,37 +257,24 @@ spv_result_t GetLocationsForVariable(
   // equal. Also track Patch and PerTaskNV decorations.
   bool has_location = false;
   uint32_t location = 0;
-  bool has_component = false;
   uint32_t component = 0;
   bool has_index = false;
   uint32_t index = 0;
   bool has_patch = false;
   bool has_per_task_nv = false;
   bool has_per_vertex_khr = false;
+  // Duplicate Location, Component, Index are checked elsewhere.
   for (auto& dec : _.id_decorations(variable->id())) {
     if (dec.dec_type() == spv::Decoration::Location) {
-      if (has_location && dec.params()[0] != location) {
-        return _.diag(SPV_ERROR_INVALID_DATA, variable)
-               << "Variable has conflicting location decorations";
-      }
       has_location = true;
       location = dec.params()[0];
     } else if (dec.dec_type() == spv::Decoration::Component) {
-      if (has_component && dec.params()[0] != component) {
-        return _.diag(SPV_ERROR_INVALID_DATA, variable)
-               << "Variable has conflicting component decorations";
-      }
-      has_component = true;
       component = dec.params()[0];
     } else if (dec.dec_type() == spv::Decoration::Index) {
       if (!is_output || !is_fragment) {
         return _.diag(SPV_ERROR_INVALID_DATA, variable)
                << "Index can only be applied to Fragment output variables";
       }
-      if (has_index && dec.params()[0] != index) {
-        return _.diag(SPV_ERROR_INVALID_DATA, variable)
-               << "Variable has conflicting index decorations";
-      }
       has_index = true;
       index = dec.params()[0];
     } else if (dec.dec_type() == spv::Decoration::BuiltIn) {
@@ -532,11 +522,15 @@ spv_result_t ValidateLocations(ValidationState_t& _,
   std::unordered_set<uint32_t> input_locations;
   std::unordered_set<uint32_t> output_locations_index0;
   std::unordered_set<uint32_t> output_locations_index1;
+  std::unordered_set<uint32_t> patch_locations_index0;
+  std::unordered_set<uint32_t> patch_locations_index1;
   std::unordered_set<uint32_t> seen;
   for (uint32_t i = 3; i < entry_point->operands().size(); ++i) {
     auto interface_id = entry_point->GetOperandAs<uint32_t>(i);
     auto interface_var = _.FindDef(interface_id);
-    auto storage_class = interface_var->GetOperandAs<spv::StorageClass>(2);
+    const auto sc_index = 2u;
+    auto storage_class =
+        interface_var->GetOperandAs<spv::StorageClass>(sc_index);
     if (storage_class != spv::StorageClass::Input &&
         storage_class != spv::StorageClass::Output) {
       continue;
@@ -547,6 +541,26 @@ spv_result_t ValidateLocations(ValidationState_t& _,
       continue;
     }
 
+    // The two Tessellation stages have a "Patch" variable that interface with
+    // the Location mechanism, but are not suppose to be tied to the "normal"
+    // input/output Location.
+    // TODO - SPIR-V allows the Patch decoration to be applied to struct
+    // members, but is not allowed in GLSL/HLSL
+    bool has_patch = false;
+    for (auto& dec : _.id_decorations(interface_var->id())) {
+      if (dec.dec_type() == spv::Decoration::Patch) {
+        has_patch = true;
+        if (auto error = GetLocationsForVariable(_, entry_point, interface_var,
+                                                 &patch_locations_index0,
+                                                 &patch_locations_index1))
+          return error;
+        break;
+      }
+    }
+    if (has_patch) {
+      continue;
+    }
+
     auto locations = (storage_class == spv::StorageClass::Input)
                          ? &input_locations
                          : &output_locations_index0;
diff --git a/source/val/validate_layout.cpp b/source/val/validate_layout.cpp
index dbc1f1e5..baf36b89 100644
--- a/source/val/validate_layout.cpp
+++ b/source/val/validate_layout.cpp
@@ -35,6 +35,7 @@ spv_result_t ModuleScopedInstructions(ValidationState_t& _,
                                       const Instruction* inst, spv::Op opcode) {
   switch (opcode) {
     case spv::Op::OpExtInst:
+    case spv::Op::OpExtInstWithForwardRefsKHR:
       if (spvExtInstIsDebugInfo(inst->ext_inst_type())) {
         const uint32_t ext_inst_index = inst->word(4);
         bool local_debug_info = false;
@@ -74,8 +75,8 @@ spv_result_t ModuleScopedInstructions(ValidationState_t& _,
 
         if (local_debug_info) {
           if (_.in_function_body() == false) {
-            // DebugScope, DebugNoScope, DebugDeclare, DebugValue must
-            // appear in a function body.
+            // TODO - Print the actual name of the instruction as this list is
+            // not complete (see ext_inst_name in ValidateExtInst() for example)
             return _.diag(SPV_ERROR_INVALID_LAYOUT, inst)
                    << "DebugScope, DebugNoScope, DebugDeclare, DebugValue "
                    << "of debug info extension must appear in a function "
@@ -243,6 +244,7 @@ spv_result_t FunctionScopedInstructions(ValidationState_t& _,
         break;
 
       case spv::Op::OpExtInst:
+      case spv::Op::OpExtInstWithForwardRefsKHR:
         if (spvExtInstIsDebugInfo(inst->ext_inst_type())) {
           const uint32_t ext_inst_index = inst->word(4);
           bool local_debug_info = false;
diff --git a/source/val/validate_logicals.cpp b/source/val/validate_logicals.cpp
index 4479e439..8a2e5d8c 100644
--- a/source/val/validate_logicals.cpp
+++ b/source/val/validate_logicals.cpp
@@ -159,9 +159,11 @@ spv_result_t LogicalsPass(ValidationState_t& _, const Instruction* inst) {
 
         const spv::Op type_opcode = type_inst->opcode();
         switch (type_opcode) {
+          case spv::Op::OpTypeUntypedPointerKHR:
           case spv::Op::OpTypePointer: {
             if (_.addressing_model() == spv::AddressingModel::Logical &&
-                !_.features().variable_pointers)
+                !_.HasCapability(
+                    spv::Capability::VariablePointersStorageBuffer))
               return _.diag(SPV_ERROR_INVALID_DATA, inst)
                      << "Using pointers with OpSelect requires capability "
                      << "VariablePointers or VariablePointersStorageBuffer";
diff --git a/source/val/validate_memory.cpp b/source/val/validate_memory.cpp
index 5b25eeb3..32f64271 100644
--- a/source/val/validate_memory.cpp
+++ b/source/val/validate_memory.cpp
@@ -233,6 +233,7 @@ std::pair<spv::StorageClass, spv::StorageClass> GetStorageClass(
   spv::StorageClass src_sc = spv::StorageClass::Max;
   switch (inst->opcode()) {
     case spv::Op::OpCooperativeMatrixLoadNV:
+    case spv::Op::OpCooperativeMatrixLoadTensorNV:
     case spv::Op::OpCooperativeMatrixLoadKHR:
     case spv::Op::OpLoad: {
       auto load_pointer = _.FindDef(inst->GetOperandAs<uint32_t>(2));
@@ -241,6 +242,7 @@ std::pair<spv::StorageClass, spv::StorageClass> GetStorageClass(
       break;
     }
     case spv::Op::OpCooperativeMatrixStoreNV:
+    case spv::Op::OpCooperativeMatrixStoreTensorNV:
     case spv::Op::OpCooperativeMatrixStoreKHR:
     case spv::Op::OpStore: {
       auto store_pointer = _.FindDef(inst->GetOperandAs<uint32_t>(0));
@@ -330,6 +332,7 @@ spv_result_t CheckMemoryAccess(ValidationState_t& _, const Instruction* inst,
   if (mask & uint32_t(spv::MemoryAccessMask::MakePointerAvailableKHR)) {
     if (inst->opcode() == spv::Op::OpLoad ||
         inst->opcode() == spv::Op::OpCooperativeMatrixLoadNV ||
+        inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV ||
         inst->opcode() == spv::Op::OpCooperativeMatrixLoadKHR) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
              << "MakePointerAvailableKHR cannot be used with OpLoad.";
@@ -349,7 +352,9 @@ spv_result_t CheckMemoryAccess(ValidationState_t& _, const Instruction* inst,
 
   if (mask & uint32_t(spv::MemoryAccessMask::MakePointerVisibleKHR)) {
     if (inst->opcode() == spv::Op::OpStore ||
-        inst->opcode() == spv::Op::OpCooperativeMatrixStoreNV) {
+        inst->opcode() == spv::Op::OpCooperativeMatrixStoreNV ||
+        inst->opcode() == spv::Op::OpCooperativeMatrixStoreKHR ||
+        inst->opcode() == spv::Op::OpCooperativeMatrixStoreTensorNV) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
              << "MakePointerVisibleKHR cannot be used with OpStore.";
     }
@@ -406,42 +411,80 @@ spv_result_t CheckMemoryAccess(ValidationState_t& _, const Instruction* inst,
 }
 
 spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
+  const bool untyped_pointer = inst->opcode() == spv::Op::OpUntypedVariableKHR;
+
   auto result_type = _.FindDef(inst->type_id());
-  if (!result_type || result_type->opcode() != spv::Op::OpTypePointer) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "OpVariable Result Type <id> " << _.getIdName(inst->type_id())
-           << " is not a pointer type.";
+  if (untyped_pointer) {
+    if (!result_type ||
+        result_type->opcode() != spv::Op::OpTypeUntypedPointerKHR)
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "Result type must be an untyped pointer";
+  } else {
+    if (!result_type || result_type->opcode() != spv::Op::OpTypePointer) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "OpVariable Result Type <id> " << _.getIdName(inst->type_id())
+             << " is not a pointer type.";
+    }
   }
 
-  const auto type_index = 2;
-  const auto value_id = result_type->GetOperandAs<uint32_t>(type_index);
-  auto value_type = _.FindDef(value_id);
+  const auto storage_class_index = 2u;
+  auto storage_class =
+      inst->GetOperandAs<spv::StorageClass>(storage_class_index);
+  uint32_t value_id = 0;
+  if (untyped_pointer) {
+    const auto has_data_type = 3u < inst->operands().size();
+    if (has_data_type) {
+      value_id = inst->GetOperandAs<uint32_t>(3u);
+      auto data_type = _.FindDef(value_id);
+      if (!data_type || !spvOpcodeGeneratesType(data_type->opcode())) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << "Data type must be a type instruction";
+      }
+    } else {
+      if (storage_class == spv::StorageClass::Function ||
+          storage_class == spv::StorageClass::Private ||
+          storage_class == spv::StorageClass::Workgroup) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << "Data type must be specified for Function, Private, and "
+                  "Workgroup storage classes";
+      }
+      if (spvIsVulkanEnv(_.context()->target_env)) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << "Vulkan requires that data type be specified";
+      }
+    }
+  }
 
-  const auto initializer_index = 3;
-  const auto storage_class_index = 2;
+  // For OpVariable the data type comes from pointee type of the result type,
+  // while for OpUntypedVariableKHR the data type comes from the operand.
+  if (!untyped_pointer) {
+    value_id = result_type->GetOperandAs<uint32_t>(2);
+  }
+  auto value_type = value_id == 0 ? nullptr : _.FindDef(value_id);
+
+  const auto initializer_index = untyped_pointer ? 4u : 3u;
   if (initializer_index < inst->operands().size()) {
     const auto initializer_id = inst->GetOperandAs<uint32_t>(initializer_index);
     const auto initializer = _.FindDef(initializer_id);
     const auto is_module_scope_var =
-        initializer && (initializer->opcode() == spv::Op::OpVariable) &&
+        initializer &&
+        (initializer->opcode() == spv::Op::OpVariable ||
+         initializer->opcode() == spv::Op::OpUntypedVariableKHR) &&
         (initializer->GetOperandAs<spv::StorageClass>(storage_class_index) !=
          spv::StorageClass::Function);
     const auto is_constant =
         initializer && spvOpcodeIsConstant(initializer->opcode());
     if (!initializer || !(is_constant || is_module_scope_var)) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
-             << "OpVariable Initializer <id> " << _.getIdName(initializer_id)
+             << "Variable Initializer <id> " << _.getIdName(initializer_id)
              << " is not a constant or module-scope variable.";
     }
     if (initializer->type_id() != value_id) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
-             << "Initializer type must match the type pointed to by the Result "
-                "Type";
+             << "Initializer type must match the data type";
     }
   }
 
-  auto storage_class =
-      inst->GetOperandAs<spv::StorageClass>(storage_class_index);
   if (storage_class != spv::StorageClass::Workgroup &&
       storage_class != spv::StorageClass::CrossWorkgroup &&
       storage_class != spv::StorageClass::Private &&
@@ -465,7 +508,7 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
         }
       }
     }
-    if (!builtin &&
+    if (!builtin && value_type &&
         ContainsInvalidBool(_, value_type, storage_input_or_output)) {
       if (storage_input_or_output) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
@@ -494,7 +537,7 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
 
   if (storage_class == spv::StorageClass::Generic) {
     return _.diag(SPV_ERROR_INVALID_BINARY, inst)
-           << "OpVariable storage class cannot be Generic";
+           << "Variable storage class cannot be Generic";
   }
 
   if (inst->function() && storage_class != spv::StorageClass::Function) {
@@ -516,17 +559,17 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
       result_type->GetOperandAs<spv::StorageClass>(result_storage_class_index);
   if (storage_class != result_storage_class) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "From SPIR-V spec, section 3.32.8 on OpVariable:\n"
-           << "Its Storage Class operand must be the same as the Storage Class "
-           << "operand of the result type.";
+           << "Storage class must match result type storage class";
   }
 
   // Variable pointer related restrictions.
-  const auto pointee = _.FindDef(result_type->word(3));
+  const auto pointee = untyped_pointer
+                           ? value_id == 0 ? nullptr : _.FindDef(value_id)
+                           : _.FindDef(result_type->word(3));
   if (_.addressing_model() == spv::AddressingModel::Logical &&
       !_.options()->relax_logical_pointer) {
     // VariablePointersStorageBuffer is implied by VariablePointers.
-    if (pointee->opcode() == spv::Op::OpTypePointer) {
+    if (pointee && pointee->opcode() == spv::Op::OpTypePointer) {
       if (!_.HasCapability(spv::Capability::VariablePointersStorageBuffer)) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
                << "In Logical addressing, variables may not allocate a pointer "
@@ -545,7 +588,7 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
     // Vulkan Push Constant Interface section: Check type of PushConstant
     // variables.
     if (storage_class == spv::StorageClass::PushConstant) {
-      if (pointee->opcode() != spv::Op::OpTypeStruct) {
+      if (pointee && pointee->opcode() != spv::Op::OpTypeStruct) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
                << _.VkErrorID(6808) << "PushConstant OpVariable <id> "
                << _.getIdName(inst->id()) << " has illegal type.\n"
@@ -557,11 +600,11 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
     // Vulkan Descriptor Set Interface: Check type of UniformConstant and
     // Uniform variables.
     if (storage_class == spv::StorageClass::UniformConstant) {
-      if (!IsAllowedTypeOrArrayOfSame(
-              _, pointee,
-              {spv::Op::OpTypeImage, spv::Op::OpTypeSampler,
-               spv::Op::OpTypeSampledImage,
-               spv::Op::OpTypeAccelerationStructureKHR})) {
+      if (pointee && !IsAllowedTypeOrArrayOfSame(
+                         _, pointee,
+                         {spv::Op::OpTypeImage, spv::Op::OpTypeSampler,
+                          spv::Op::OpTypeSampledImage,
+                          spv::Op::OpTypeAccelerationStructureKHR})) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
                << _.VkErrorID(4655) << "UniformConstant OpVariable <id> "
                << _.getIdName(inst->id()) << " has illegal type.\n"
@@ -574,7 +617,8 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
     }
 
     if (storage_class == spv::StorageClass::Uniform) {
-      if (!IsAllowedTypeOrArrayOfSame(_, pointee, {spv::Op::OpTypeStruct})) {
+      if (pointee &&
+          !IsAllowedTypeOrArrayOfSame(_, pointee, {spv::Op::OpTypeStruct})) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
                << _.VkErrorID(6807) << "Uniform OpVariable <id> "
                << _.getIdName(inst->id()) << " has illegal type.\n"
@@ -587,7 +631,8 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
     }
 
     if (storage_class == spv::StorageClass::StorageBuffer) {
-      if (!IsAllowedTypeOrArrayOfSame(_, pointee, {spv::Op::OpTypeStruct})) {
+      if (pointee &&
+          !IsAllowedTypeOrArrayOfSame(_, pointee, {spv::Op::OpTypeStruct})) {
         return _.diag(SPV_ERROR_INVALID_ID, inst)
                << _.VkErrorID(6807) << "StorageBuffer OpVariable <id> "
                << _.getIdName(inst->id()) << " has illegal type.\n"
@@ -620,11 +665,17 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
         }
       }
     }
+  }
 
-    // Initializers in Vulkan are only allowed in some storage clases
-    if (inst->operands().size() > 3) {
+  // Vulkan Appendix A: Check that if contains initializer, then
+  // storage class is Output, Private, or Function.
+  if (inst->operands().size() > initializer_index &&
+      storage_class != spv::StorageClass::Output &&
+      storage_class != spv::StorageClass::Private &&
+      storage_class != spv::StorageClass::Function) {
+    if (spvIsVulkanEnv(_.context()->target_env)) {
       if (storage_class == spv::StorageClass::Workgroup) {
-        auto init_id = inst->GetOperandAs<uint32_t>(3);
+        auto init_id = inst->GetOperandAs<uint32_t>(initializer_index);
         auto init = _.FindDef(init_id);
         if (init->opcode() != spv::Op::OpConstantNull) {
           return _.diag(SPV_ERROR_INVALID_ID, inst)
@@ -651,7 +702,7 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
     }
   }
 
-  if (inst->operands().size() > 3) {
+  if (initializer_index < inst->operands().size()) {
     if (storage_class == spv::StorageClass::TaskPayloadWorkgroupEXT) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
              << "OpVariable, <id> " << _.getIdName(inst->id())
@@ -675,10 +726,10 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
   }
 
   auto pointee_base = pointee;
-  while (pointee_base->opcode() == spv::Op::OpTypeArray) {
+  while (pointee_base && pointee_base->opcode() == spv::Op::OpTypeArray) {
     pointee_base = _.FindDef(pointee_base->GetOperandAs<uint32_t>(1u));
   }
-  if (pointee_base->opcode() == spv::Op::OpTypePointer) {
+  if (pointee_base && pointee_base->opcode() == spv::Op::OpTypePointer) {
     if (pointee_base->GetOperandAs<spv::StorageClass>(1u) ==
         spv::StorageClass::PhysicalStorageBuffer) {
       // check for AliasedPointer/RestrictPointer
@@ -768,7 +819,7 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
   // Cooperative matrix types can only be allocated in Function or Private
   if ((storage_class != spv::StorageClass::Function &&
        storage_class != spv::StorageClass::Private) &&
-      ContainsCooperativeMatrix(_, pointee)) {
+      pointee && ContainsCooperativeMatrix(_, pointee)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "Cooperative matrix types (or types containing them) can only be "
               "allocated "
@@ -784,7 +835,8 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
         (!_.HasCapability(spv::Capability::Float16) &&
          _.ContainsSizedIntOrFloatType(value_id, spv::Op::OpTypeFloat, 16))) {
       auto underlying_type = value_type;
-      while (underlying_type->opcode() == spv::Op::OpTypePointer) {
+      while (underlying_type &&
+             underlying_type->opcode() == spv::Op::OpTypePointer) {
         storage_class = underlying_type->GetOperandAs<spv::StorageClass>(1u);
         underlying_type =
             _.FindDef(underlying_type->GetOperandAs<uint32_t>(2u));
@@ -800,7 +852,8 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
           }
           break;
         case spv::StorageClass::Uniform:
-          if (!_.HasCapability(
+          if (underlying_type &&
+              !_.HasCapability(
                   spv::Capability::UniformAndStorageBuffer16BitAccess)) {
             if (underlying_type->opcode() == spv::Op::OpTypeArray ||
                 underlying_type->opcode() == spv::Op::OpTypeRuntimeArray) {
@@ -848,7 +901,8 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
     if (!_.HasCapability(spv::Capability::Int8) &&
         _.ContainsSizedIntOrFloatType(value_id, spv::Op::OpTypeInt, 8)) {
       auto underlying_type = value_type;
-      while (underlying_type->opcode() == spv::Op::OpTypePointer) {
+      while (underlying_type &&
+             underlying_type->opcode() == spv::Op::OpTypePointer) {
         storage_class = underlying_type->GetOperandAs<spv::StorageClass>(1u);
         underlying_type =
             _.FindDef(underlying_type->GetOperandAs<uint32_t>(2u));
@@ -864,7 +918,8 @@ spv_result_t ValidateVariable(ValidationState_t& _, const Instruction* inst) {
           }
           break;
         case spv::StorageClass::Uniform:
-          if (!_.HasCapability(
+          if (underlying_type &&
+              !_.HasCapability(
                   spv::Capability::UniformAndStorageBuffer8BitAccess)) {
             if (underlying_type->opcode() == spv::Op::OpTypeArray ||
                 underlying_type->opcode() == spv::Op::OpTypeRuntimeArray) {
@@ -929,21 +984,23 @@ spv_result_t ValidateLoad(ValidationState_t& _, const Instruction* inst) {
   }
 
   const auto pointer_type = _.FindDef(pointer->type_id());
-  if (!pointer_type || pointer_type->opcode() != spv::Op::OpTypePointer) {
+  if (!pointer_type ||
+      (pointer_type->opcode() != spv::Op::OpTypePointer &&
+       pointer_type->opcode() != spv::Op::OpTypeUntypedPointerKHR)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "OpLoad type for pointer <id> " << _.getIdName(pointer_id)
            << " is not a pointer type.";
   }
 
-  uint32_t pointee_data_type;
-  spv::StorageClass storage_class;
-  if (!_.GetPointerTypeInfo(pointer_type->id(), &pointee_data_type,
-                            &storage_class) ||
-      result_type->id() != pointee_data_type) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "OpLoad Result Type <id> " << _.getIdName(inst->type_id())
-           << " does not match Pointer <id> " << _.getIdName(pointer->id())
-           << "s type.";
+  if (pointer_type->opcode() == spv::Op::OpTypePointer) {
+    const auto pointee_type =
+        _.FindDef(pointer_type->GetOperandAs<uint32_t>(2));
+    if (!pointee_type || result_type->id() != pointee_type->id()) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "OpLoad Result Type <id> " << _.getIdName(inst->type_id())
+             << " does not match Pointer <id> " << _.getIdName(pointer->id())
+             << "s type.";
+    }
   }
 
   if (!_.options()->before_hlsl_legalization &&
@@ -986,17 +1043,23 @@ spv_result_t ValidateStore(ValidationState_t& _, const Instruction* inst) {
            << " is not a logical pointer.";
   }
   const auto pointer_type = _.FindDef(pointer->type_id());
-  if (!pointer_type || pointer_type->opcode() != spv::Op::OpTypePointer) {
+  if (!pointer_type ||
+      (pointer_type->opcode() != spv::Op::OpTypePointer &&
+       pointer_type->opcode() != spv::Op::OpTypeUntypedPointerKHR)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "OpStore type for pointer <id> " << _.getIdName(pointer_id)
            << " is not a pointer type.";
   }
-  const auto type_id = pointer_type->GetOperandAs<uint32_t>(2);
-  const auto type = _.FindDef(type_id);
-  if (!type || spv::Op::OpTypeVoid == type->opcode()) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "OpStore Pointer <id> " << _.getIdName(pointer_id)
-           << "s type is void.";
+
+  Instruction* type = nullptr;
+  if (pointer_type->opcode() == spv::Op::OpTypePointer) {
+    const auto type_id = pointer_type->GetOperandAs<uint32_t>(2);
+    type = _.FindDef(type_id);
+    if (!type || spv::Op::OpTypeVoid == type->opcode()) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "OpStore Pointer <id> " << _.getIdName(pointer_id)
+             << "s type is void.";
+    }
   }
 
   // validate storage class
@@ -1073,7 +1136,7 @@ spv_result_t ValidateStore(ValidationState_t& _, const Instruction* inst) {
            << "s type is void.";
   }
 
-  if (type->id() != object_type->id()) {
+  if (type && (type->id() != object_type->id())) {
     if (!_.options()->relax_struct_store ||
         type->opcode() != spv::Op::OpTypeStruct ||
         object_type->opcode() != spv::Op::OpTypeStruct) {
@@ -1106,6 +1169,23 @@ spv_result_t ValidateStore(ValidationState_t& _, const Instruction* inst) {
     }
   }
 
+  if (spvIsVulkanEnv(_.context()->target_env) &&
+      !_.options()->before_hlsl_legalization) {
+    const auto isForbiddenType = [](const Instruction* type_inst) {
+      auto opcode = type_inst->opcode();
+      return opcode == spv::Op::OpTypeImage ||
+             opcode == spv::Op::OpTypeSampler ||
+             opcode == spv::Op::OpTypeSampledImage ||
+             opcode == spv::Op::OpTypeAccelerationStructureKHR;
+    };
+    if (_.ContainsType(object_type->id(), isForbiddenType)) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << _.VkErrorID(6924)
+             << "Cannot store to OpTypeImage, OpTypeSampler, "
+                "OpTypeSampledImage, or OpTypeAccelerationStructureKHR objects";
+    }
+  }
+
   return SPV_SUCCESS;
 }
 
@@ -1178,7 +1258,8 @@ spv_result_t ValidateCopyMemory(ValidationState_t& _, const Instruction* inst) {
 
   const auto target_pointer_type = _.FindDef(target->type_id());
   if (!target_pointer_type ||
-      target_pointer_type->opcode() != spv::Op::OpTypePointer) {
+      (target_pointer_type->opcode() != spv::Op::OpTypePointer &&
+       target_pointer_type->opcode() != spv::Op::OpTypeUntypedPointerKHR)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "Target operand <id> " << _.getIdName(target_id)
            << " is not a pointer.";
@@ -1186,35 +1267,52 @@ spv_result_t ValidateCopyMemory(ValidationState_t& _, const Instruction* inst) {
 
   const auto source_pointer_type = _.FindDef(source->type_id());
   if (!source_pointer_type ||
-      source_pointer_type->opcode() != spv::Op::OpTypePointer) {
+      (source_pointer_type->opcode() != spv::Op::OpTypePointer &&
+       source_pointer_type->opcode() != spv::Op::OpTypeUntypedPointerKHR)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "Source operand <id> " << _.getIdName(source_id)
            << " is not a pointer.";
   }
 
   if (inst->opcode() == spv::Op::OpCopyMemory) {
-    const auto target_type =
-        _.FindDef(target_pointer_type->GetOperandAs<uint32_t>(2));
-    if (!target_type || target_type->opcode() == spv::Op::OpTypeVoid) {
-      return _.diag(SPV_ERROR_INVALID_ID, inst)
-             << "Target operand <id> " << _.getIdName(target_id)
-             << " cannot be a void pointer.";
+    const bool target_typed =
+        target_pointer_type->opcode() == spv::Op::OpTypePointer;
+    const bool source_typed =
+        source_pointer_type->opcode() == spv::Op::OpTypePointer;
+    Instruction* target_type = nullptr;
+    Instruction* source_type = nullptr;
+    if (target_typed) {
+      target_type = _.FindDef(target_pointer_type->GetOperandAs<uint32_t>(2));
+
+      if (!target_type || target_type->opcode() == spv::Op::OpTypeVoid) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << "Target operand <id> " << _.getIdName(target_id)
+               << " cannot be a void pointer.";
+      }
     }
 
-    const auto source_type =
-        _.FindDef(source_pointer_type->GetOperandAs<uint32_t>(2));
-    if (!source_type || source_type->opcode() == spv::Op::OpTypeVoid) {
-      return _.diag(SPV_ERROR_INVALID_ID, inst)
-             << "Source operand <id> " << _.getIdName(source_id)
-             << " cannot be a void pointer.";
+    if (source_typed) {
+      source_type = _.FindDef(source_pointer_type->GetOperandAs<uint32_t>(2));
+      if (!source_type || source_type->opcode() == spv::Op::OpTypeVoid) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << "Source operand <id> " << _.getIdName(source_id)
+               << " cannot be a void pointer.";
+      }
     }
 
-    if (target_type->id() != source_type->id()) {
+    if (target_type && source_type && target_type->id() != source_type->id()) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
              << "Target <id> " << _.getIdName(source_id)
              << "s type does not match Source <id> "
              << _.getIdName(source_type->id()) << "s type.";
     }
+
+    if (!target_type && !source_type) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "One of Source or Target must be a typed pointer";
+    }
+
+    if (auto error = CheckMemoryAccess(_, inst, 2)) return error;
   } else {
     const auto size_id = inst->GetOperandAs<uint32_t>(2);
     const auto size = _.FindDef(size_id);
@@ -1230,7 +1328,6 @@ spv_result_t ValidateCopyMemory(ValidationState_t& _, const Instruction* inst) {
              << "Size operand <id> " << _.getIdName(size_id)
              << " must be a scalar integer type.";
     }
-
     bool is_zero = true;
     switch (size->opcode()) {
       case spv::Op::OpConstantNull:
@@ -1257,18 +1354,125 @@ spv_result_t ValidateCopyMemory(ValidationState_t& _, const Instruction* inst) {
         // Cannot infer any other opcodes.
         break;
     }
+
+    if (_.HasCapability(spv::Capability::Shader)) {
+      bool is_int = false;
+      bool is_const = false;
+      uint32_t value = 0;
+      std::tie(is_int, is_const, value) = _.EvalInt32IfConst(size_id);
+      if (is_const) {
+        if (value % 4 != 0) {
+          const auto source_sc =
+              source_pointer_type->GetOperandAs<spv::StorageClass>(1);
+          const auto target_sc =
+              target_pointer_type->GetOperandAs<spv::StorageClass>(1);
+          const bool int8 = _.HasCapability(spv::Capability::Int8);
+          const bool ubo_int8 = _.HasCapability(
+              spv::Capability::UniformAndStorageBuffer8BitAccess);
+          const bool ssbo_int8 =
+              _.HasCapability(spv::Capability::StorageBuffer8BitAccess) ||
+              ubo_int8;
+          const bool pc_int8 =
+              _.HasCapability(spv::Capability::StoragePushConstant8);
+          const bool wg_int8 = _.HasCapability(
+              spv::Capability::WorkgroupMemoryExplicitLayout8BitAccessKHR);
+          const bool int16 = _.HasCapability(spv::Capability::Int16) || int8;
+          const bool ubo_int16 =
+              _.HasCapability(
+                  spv::Capability::UniformAndStorageBuffer16BitAccess) ||
+              ubo_int8;
+          const bool ssbo_int16 =
+              _.HasCapability(spv::Capability::StorageBuffer16BitAccess) ||
+              ubo_int16 || ssbo_int8;
+          const bool pc_int16 =
+              _.HasCapability(spv::Capability::StoragePushConstant16) ||
+              pc_int8;
+          const bool io_int16 =
+              _.HasCapability(spv::Capability::StorageInputOutput16);
+          const bool wg_int16 = _.HasCapability(
+              spv::Capability::WorkgroupMemoryExplicitLayout16BitAccessKHR);
+
+          bool source_int16_match = false;
+          bool target_int16_match = false;
+          bool source_int8_match = false;
+          bool target_int8_match = false;
+          switch (source_sc) {
+            case spv::StorageClass::StorageBuffer:
+              source_int16_match = ssbo_int16;
+              source_int8_match = ssbo_int8;
+              break;
+            case spv::StorageClass::Uniform:
+              source_int16_match = ubo_int16;
+              source_int8_match = ubo_int8;
+              break;
+            case spv::StorageClass::PushConstant:
+              source_int16_match = pc_int16;
+              source_int8_match = pc_int8;
+              break;
+            case spv::StorageClass::Input:
+            case spv::StorageClass::Output:
+              source_int16_match = io_int16;
+              break;
+            case spv::StorageClass::Workgroup:
+              source_int16_match = wg_int16;
+              source_int8_match = wg_int8;
+              break;
+            default:
+              break;
+          }
+          switch (target_sc) {
+            case spv::StorageClass::StorageBuffer:
+              target_int16_match = ssbo_int16;
+              target_int8_match = ssbo_int8;
+              break;
+            case spv::StorageClass::Uniform:
+              target_int16_match = ubo_int16;
+              target_int8_match = ubo_int8;
+              break;
+            case spv::StorageClass::PushConstant:
+              target_int16_match = pc_int16;
+              target_int8_match = pc_int8;
+              break;
+            // Input is read-only so it cannot be the target pointer.
+            case spv::StorageClass::Output:
+              target_int16_match = io_int16;
+              break;
+            case spv::StorageClass::Workgroup:
+              target_int16_match = wg_int16;
+              target_int8_match = wg_int8;
+              break;
+            default:
+              break;
+          }
+          if (!int8 && !int16 && !(source_int16_match && target_int16_match)) {
+            return _.diag(SPV_ERROR_INVALID_ID, inst)
+                   << "Size must be a multiple of 4";
+          }
+          if (value % 2 != 0) {
+            if (!int8 && !(source_int8_match && target_int8_match)) {
+              return _.diag(SPV_ERROR_INVALID_ID, inst)
+                     << "Size must be a multiple of 2";
+            }
+          }
+        }
+      }
+    }
+
+    if (auto error = CheckMemoryAccess(_, inst, 3)) return error;
   }
   if (auto error = ValidateCopyMemoryMemoryAccess(_, inst)) return error;
 
   // Get past the pointers to avoid checking a pointer copy.
-  auto sub_type = _.FindDef(target_pointer_type->GetOperandAs<uint32_t>(2));
-  while (sub_type->opcode() == spv::Op::OpTypePointer) {
-    sub_type = _.FindDef(sub_type->GetOperandAs<uint32_t>(2));
-  }
-  if (_.HasCapability(spv::Capability::Shader) &&
-      _.ContainsLimitedUseIntOrFloatType(sub_type->id())) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "Cannot copy memory of objects containing 8- or 16-bit types";
+  if (target_pointer_type->opcode() == spv::Op::OpTypePointer) {
+    auto sub_type = _.FindDef(target_pointer_type->GetOperandAs<uint32_t>(2));
+    while (sub_type->opcode() == spv::Op::OpTypePointer) {
+      sub_type = _.FindDef(sub_type->GetOperandAs<uint32_t>(2));
+    }
+    if (_.HasCapability(spv::Capability::Shader) &&
+        _.ContainsLimitedUseIntOrFloatType(sub_type->id())) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "Cannot copy memory of objects containing 8- or 16-bit types";
+    }
   }
 
   return SPV_SUCCESS;
@@ -1279,27 +1483,50 @@ spv_result_t ValidateAccessChain(ValidationState_t& _,
   std::string instr_name =
       "Op" + std::string(spvOpcodeString(static_cast<spv::Op>(inst->opcode())));
 
-  // The result type must be OpTypePointer.
+  const bool untyped_pointer = spvOpcodeGeneratesUntypedPointer(inst->opcode());
+
+  // The result type must be OpTypePointer for regular access chains and an
+  // OpTypeUntypedPointerKHR for untyped access chains.
   auto result_type = _.FindDef(inst->type_id());
-  if (spv::Op::OpTypePointer != result_type->opcode()) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "The Result Type of " << instr_name << " <id> "
-           << _.getIdName(inst->id()) << " must be OpTypePointer. Found Op"
-           << spvOpcodeString(static_cast<spv::Op>(result_type->opcode()))
-           << ".";
+  if (untyped_pointer) {
+    if (!result_type ||
+        spv::Op::OpTypeUntypedPointerKHR != result_type->opcode()) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "The Result Type of " << instr_name << " <id> "
+             << _.getIdName(inst->id())
+             << " must be OpTypeUntypedPointerKHR. Found Op"
+             << spvOpcodeString(static_cast<spv::Op>(result_type->opcode()))
+             << ".";
+    }
+  } else {
+    if (!result_type || spv::Op::OpTypePointer != result_type->opcode()) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "The Result Type of " << instr_name << " <id> "
+             << _.getIdName(inst->id()) << " must be OpTypePointer. Found Op"
+             << spvOpcodeString(static_cast<spv::Op>(result_type->opcode()))
+             << ".";
+    }
   }
 
-  // Result type is a pointer. Find out what it's pointing to.
-  // This will be used to make sure the indexing results in the same type.
-  // OpTypePointer word 3 is the type being pointed to.
-  const auto result_type_pointee = _.FindDef(result_type->word(3));
+  if (untyped_pointer) {
+    // Base type must be a non-pointer type.
+    const auto base_type = _.FindDef(inst->GetOperandAs<uint32_t>(2));
+    if (!base_type || !spvOpcodeGeneratesType(base_type->opcode()) ||
+        base_type->opcode() == spv::Op::OpTypePointer ||
+        base_type->opcode() == spv::Op::OpTypeUntypedPointerKHR) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "Base type must be a non-pointer type";
+    }
+  }
 
   // Base must be a pointer, pointing to the base of a composite object.
-  const auto base_index = 2;
+  const auto base_index = untyped_pointer ? 3 : 2;
   const auto base_id = inst->GetOperandAs<uint32_t>(base_index);
   const auto base = _.FindDef(base_id);
   const auto base_type = _.FindDef(base->type_id());
-  if (!base_type || spv::Op::OpTypePointer != base_type->opcode()) {
+  if (!base_type || !(spv::Op::OpTypePointer == base_type->opcode() ||
+                      (untyped_pointer && spv::Op::OpTypeUntypedPointerKHR ==
+                                              base_type->opcode()))) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "The Base <id> " << _.getIdName(base_id) << " in " << instr_name
            << " instruction must be a pointer.";
@@ -1317,14 +1544,18 @@ spv_result_t ValidateAccessChain(ValidationState_t& _,
   }
 
   // The type pointed to by OpTypePointer (word 3) must be a composite type.
-  auto type_pointee = _.FindDef(base_type->word(3));
+  auto type_pointee = untyped_pointer
+                          ? _.FindDef(inst->GetOperandAs<uint32_t>(2))
+                          : _.FindDef(base_type->word(3));
 
   // Check Universal Limit (SPIR-V Spec. Section 2.17).
   // The number of indexes passed to OpAccessChain may not exceed 255
   // The instruction includes 4 words + N words (for N indexes)
   size_t num_indexes = inst->words().size() - 4;
   if (inst->opcode() == spv::Op::OpPtrAccessChain ||
-      inst->opcode() == spv::Op::OpInBoundsPtrAccessChain) {
+      inst->opcode() == spv::Op::OpInBoundsPtrAccessChain ||
+      inst->opcode() == spv::Op::OpUntypedPtrAccessChainKHR ||
+      inst->opcode() == spv::Op::OpUntypedInBoundsPtrAccessChainKHR) {
     // In pointer access chains, the element operand is required, but not
     // counted as an index.
     --num_indexes;
@@ -1343,9 +1574,11 @@ spv_result_t ValidateAccessChain(ValidationState_t& _,
   // instruction. The second index will apply similarly to that result, and so
   // on. Once any non-composite type is reached, there must be no remaining
   // (unused) indexes.
-  auto starting_index = 4;
+  auto starting_index = untyped_pointer ? 5 : 4;
   if (inst->opcode() == spv::Op::OpPtrAccessChain ||
-      inst->opcode() == spv::Op::OpInBoundsPtrAccessChain) {
+      inst->opcode() == spv::Op::OpInBoundsPtrAccessChain ||
+      inst->opcode() == spv::Op::OpUntypedPtrAccessChainKHR ||
+      inst->opcode() == spv::Op::OpUntypedInBoundsPtrAccessChainKHR) {
     ++starting_index;
   }
   for (size_t i = starting_index; i < inst->words().size(); ++i) {
@@ -1374,33 +1607,30 @@ spv_result_t ValidateAccessChain(ValidationState_t& _,
       case spv::Op::OpTypeStruct: {
         // In case of structures, there is an additional constraint on the
         // index: the index must be an OpConstant.
-        if (spv::Op::OpConstant != cur_word_instr->opcode()) {
+        int64_t cur_index;
+        if (!_.EvalConstantValInt64(cur_word, &cur_index)) {
           return _.diag(SPV_ERROR_INVALID_ID, cur_word_instr)
                  << "The <id> passed to " << instr_name
                  << " to index into a "
                     "structure must be an OpConstant.";
         }
-        // Get the index value from the OpConstant (word 3 of OpConstant).
-        // OpConstant could be a signed integer. But it's okay to treat it as
-        // unsigned because a negative constant int would never be seen as
-        // correct as a struct offset, since structs can't have more than 2
-        // billion members.
-        const uint32_t cur_index = cur_word_instr->word(3);
+
         // The index points to the struct member we want, therefore, the index
         // should be less than the number of struct members.
-        const uint32_t num_struct_members =
-            static_cast<uint32_t>(type_pointee->words().size() - 2);
-        if (cur_index >= num_struct_members) {
+        const int64_t num_struct_members =
+            static_cast<int64_t>(type_pointee->words().size() - 2);
+        if (cur_index >= num_struct_members || cur_index < 0) {
           return _.diag(SPV_ERROR_INVALID_ID, cur_word_instr)
                  << "Index is out of bounds: " << instr_name
-                 << " can not find index " << cur_index
+                 << " cannot find index " << cur_index
                  << " into the structure <id> "
                  << _.getIdName(type_pointee->id()) << ". This structure has "
                  << num_struct_members << " members. Largest valid index is "
                  << num_struct_members - 1 << ".";
         }
         // Struct members IDs start at word 2 of OpTypeStruct.
-        auto structMemberId = type_pointee->word(cur_index + 2);
+        const size_t word_index = static_cast<size_t>(cur_index) + 2;
+        auto structMemberId = type_pointee->word(word_index);
         type_pointee = _.FindDef(structMemberId);
         break;
       }
@@ -1413,18 +1643,145 @@ spv_result_t ValidateAccessChain(ValidationState_t& _,
       }
     }
   }
-  // At this point, we have fully walked down from the base using the indeces.
-  // The type being pointed to should be the same as the result type.
-  if (type_pointee->id() != result_type_pointee->id()) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << instr_name << " result type (Op"
-           << spvOpcodeString(
-                  static_cast<spv::Op>(result_type_pointee->opcode()))
-           << ") does not match the type that results from indexing into the "
-              "base "
-              "<id> (Op"
-           << spvOpcodeString(static_cast<spv::Op>(type_pointee->opcode()))
-           << ").";
+
+  if (!untyped_pointer) {
+    // Result type is a pointer. Find out what it's pointing to.
+    // This will be used to make sure the indexing results in the same type.
+    // OpTypePointer word 3 is the type being pointed to.
+    const auto result_type_pointee = _.FindDef(result_type->word(3));
+    // At this point, we have fully walked down from the base using the indeces.
+    // The type being pointed to should be the same as the result type.
+    if (type_pointee->id() != result_type_pointee->id()) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << instr_name << " result type (Op"
+             << spvOpcodeString(
+                    static_cast<spv::Op>(result_type_pointee->opcode()))
+             << ") does not match the type that results from indexing into the "
+                "base "
+                "<id> (Op"
+             << spvOpcodeString(static_cast<spv::Op>(type_pointee->opcode()))
+             << ").";
+    }
+  }
+
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateRawAccessChain(ValidationState_t& _,
+                                    const Instruction* inst) {
+  std::string instr_name = "Op" + std::string(spvOpcodeString(inst->opcode()));
+
+  // The result type must be OpTypePointer.
+  const auto result_type = _.FindDef(inst->type_id());
+  if (spv::Op::OpTypePointer != result_type->opcode()) {
+    return _.diag(SPV_ERROR_INVALID_DATA, inst)
+           << "The Result Type of " << instr_name << " <id> "
+           << _.getIdName(inst->id()) << " must be OpTypePointer. Found Op"
+           << spvOpcodeString(result_type->opcode()) << '.';
+  }
+
+  // The pointed storage class must be valid.
+  const auto storage_class = result_type->GetOperandAs<spv::StorageClass>(1);
+  if (storage_class != spv::StorageClass::StorageBuffer &&
+      storage_class != spv::StorageClass::PhysicalStorageBuffer &&
+      storage_class != spv::StorageClass::Uniform) {
+    return _.diag(SPV_ERROR_INVALID_DATA, inst)
+           << "The Result Type of " << instr_name << " <id> "
+           << _.getIdName(inst->id())
+           << " must point to a storage class of "
+              "StorageBuffer, PhysicalStorageBuffer, or Uniform.";
+  }
+
+  // The pointed type must not be one in the list below.
+  const auto result_type_pointee =
+      _.FindDef(result_type->GetOperandAs<uint32_t>(2));
+  if (result_type_pointee->opcode() == spv::Op::OpTypeArray ||
+      result_type_pointee->opcode() == spv::Op::OpTypeMatrix ||
+      result_type_pointee->opcode() == spv::Op::OpTypeStruct) {
+    return _.diag(SPV_ERROR_INVALID_DATA, inst)
+           << "The Result Type of " << instr_name << " <id> "
+           << _.getIdName(inst->id())
+           << " must not point to "
+              "OpTypeArray, OpTypeMatrix, or OpTypeStruct.";
+  }
+
+  // Validate Stride is a OpConstant.
+  const auto stride = _.FindDef(inst->GetOperandAs<uint32_t>(3));
+  if (stride->opcode() != spv::Op::OpConstant) {
+    return _.diag(SPV_ERROR_INVALID_DATA, inst)
+           << "The Stride of " << instr_name << " <id> "
+           << _.getIdName(inst->id()) << " must be OpConstant. Found Op"
+           << spvOpcodeString(stride->opcode()) << '.';
+  }
+  // Stride type must be OpTypeInt
+  const auto stride_type = _.FindDef(stride->type_id());
+  if (stride_type->opcode() != spv::Op::OpTypeInt) {
+    return _.diag(SPV_ERROR_INVALID_DATA, inst)
+           << "The type of Stride of " << instr_name << " <id> "
+           << _.getIdName(inst->id()) << " must be OpTypeInt. Found Op"
+           << spvOpcodeString(stride_type->opcode()) << '.';
+  }
+
+  // Index and Offset type must be OpTypeInt with a width of 32
+  const auto ValidateType = [&](const char* name,
+                                int operandIndex) -> spv_result_t {
+    const auto value = _.FindDef(inst->GetOperandAs<uint32_t>(operandIndex));
+    const auto value_type = _.FindDef(value->type_id());
+    if (value_type->opcode() != spv::Op::OpTypeInt) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "The type of " << name << " of " << instr_name << " <id> "
+             << _.getIdName(inst->id()) << " must be OpTypeInt. Found Op"
+             << spvOpcodeString(value_type->opcode()) << '.';
+    }
+    const auto width = value_type->GetOperandAs<uint32_t>(1);
+    if (width != 32) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "The integer width of " << name << " of " << instr_name
+             << " <id> " << _.getIdName(inst->id()) << " must be 32. Found "
+             << width << '.';
+    }
+    return SPV_SUCCESS;
+  };
+  spv_result_t result;
+  result = ValidateType("Index", 4);
+  if (result != SPV_SUCCESS) {
+    return result;
+  }
+  result = ValidateType("Offset", 5);
+  if (result != SPV_SUCCESS) {
+    return result;
+  }
+
+  uint32_t access_operands = 0;
+  if (inst->operands().size() >= 7) {
+    access_operands = inst->GetOperandAs<uint32_t>(6);
+  }
+  if (access_operands &
+      uint32_t(spv::RawAccessChainOperandsMask::RobustnessPerElementNV)) {
+    uint64_t stride_value = 0;
+    if (_.EvalConstantValUint64(stride->id(), &stride_value) &&
+        stride_value == 0) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "Stride must not be zero when per-element robustness is used.";
+    }
+  }
+  if (access_operands &
+          uint32_t(spv::RawAccessChainOperandsMask::RobustnessPerComponentNV) ||
+      access_operands &
+          uint32_t(spv::RawAccessChainOperandsMask::RobustnessPerElementNV)) {
+    if (storage_class == spv::StorageClass::PhysicalStorageBuffer) {
+      return _.diag(SPV_ERROR_INVALID_DATA, inst)
+             << "Storage class cannot be PhysicalStorageBuffer when "
+                "raw access chain robustness is used.";
+    }
+  }
+  if (access_operands &
+          uint32_t(spv::RawAccessChainOperandsMask::RobustnessPerComponentNV) &&
+      access_operands &
+          uint32_t(spv::RawAccessChainOperandsMask::RobustnessPerElementNV)) {
+    return _.diag(SPV_ERROR_INVALID_DATA, inst)
+           << "Per-component robustness and per-element robustness are "
+              "mutually exclusive.";
   }
 
   return SPV_SUCCESS;
@@ -1432,7 +1789,8 @@ spv_result_t ValidateAccessChain(ValidationState_t& _,
 
 spv_result_t ValidatePtrAccessChain(ValidationState_t& _,
                                     const Instruction* inst) {
-  if (_.addressing_model() == spv::AddressingModel::Logical) {
+  if (_.addressing_model() == spv::AddressingModel::Logical &&
+      inst->opcode() == spv::Op::OpPtrAccessChain) {
     if (!_.features().variable_pointers) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
              << "Generating variable pointers requires capability "
@@ -1443,9 +1801,13 @@ spv_result_t ValidatePtrAccessChain(ValidationState_t& _,
   // Need to call first, will make sure Base is a valid ID
   if (auto error = ValidateAccessChain(_, inst)) return error;
 
+  const bool untyped_pointer = spvOpcodeGeneratesUntypedPointer(inst->opcode());
+
   const auto base_id = inst->GetOperandAs<uint32_t>(2);
   const auto base = _.FindDef(base_id);
-  const auto base_type = _.FindDef(base->type_id());
+  const auto base_type = untyped_pointer
+                             ? _.FindDef(inst->GetOperandAs<uint32_t>(2))
+                             : _.FindDef(base->type_id());
   const auto base_type_storage_class =
       base_type->GetOperandAs<spv::StorageClass>(1);
 
@@ -1463,15 +1825,17 @@ spv_result_t ValidatePtrAccessChain(ValidationState_t& _,
   }
 
   if (spvIsVulkanEnv(_.context()->target_env)) {
+    const auto untyped_cap =
+        untyped_pointer && _.HasCapability(spv::Capability::UntypedPointersKHR);
     if (base_type_storage_class == spv::StorageClass::Workgroup) {
-      if (!_.HasCapability(spv::Capability::VariablePointers)) {
+      if (!_.HasCapability(spv::Capability::VariablePointers) && !untyped_cap) {
         return _.diag(SPV_ERROR_INVALID_DATA, inst)
                << _.VkErrorID(7651)
                << "OpPtrAccessChain Base operand pointing to Workgroup "
                   "storage class must use VariablePointers capability";
       }
     } else if (base_type_storage_class == spv::StorageClass::StorageBuffer) {
-      if (!_.features().variable_pointers) {
+      if (!_.features().variable_pointers && !untyped_cap) {
         return _.diag(SPV_ERROR_INVALID_DATA, inst)
                << _.VkErrorID(7652)
                << "OpPtrAccessChain Base operand pointing to StorageBuffer "
@@ -1479,7 +1843,8 @@ spv_result_t ValidatePtrAccessChain(ValidationState_t& _,
                   "VariablePointersStorageBuffer capability";
       }
     } else if (base_type_storage_class !=
-               spv::StorageClass::PhysicalStorageBuffer) {
+                   spv::StorageClass::PhysicalStorageBuffer &&
+               !untyped_cap) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
              << _.VkErrorID(7650)
              << "OpPtrAccessChain Base operand must point to Workgroup, "
@@ -1506,18 +1871,28 @@ spv_result_t ValidateArrayLength(ValidationState_t& state,
            << " must be OpTypeInt with width 32 and signedness 0.";
   }
 
-  // The structure that is passed in must be an pointer to a structure, whose
-  // last element is a runtime array.
-  auto pointer = state.FindDef(inst->GetOperandAs<uint32_t>(2));
-  auto pointer_type = state.FindDef(pointer->type_id());
-  if (pointer_type->opcode() != spv::Op::OpTypePointer) {
+  const bool untyped = inst->opcode() == spv::Op::OpUntypedArrayLengthKHR;
+  auto pointer_ty_id = state.GetOperandTypeId(inst, (untyped ? 3 : 2));
+  auto pointer_ty = state.FindDef(pointer_ty_id);
+  if (untyped) {
+    if (pointer_ty->opcode() != spv::Op::OpTypeUntypedPointerKHR) {
+      return state.diag(SPV_ERROR_INVALID_ID, inst)
+             << "Pointer must be an untyped pointer";
+    }
+  } else if (pointer_ty->opcode() != spv::Op::OpTypePointer) {
     return state.diag(SPV_ERROR_INVALID_ID, inst)
            << "The Structure's type in " << instr_name << " <id> "
            << state.getIdName(inst->id())
            << " must be a pointer to an OpTypeStruct.";
   }
 
-  auto structure_type = state.FindDef(pointer_type->GetOperandAs<uint32_t>(2));
+  Instruction* structure_type = nullptr;
+  if (untyped) {
+    structure_type = state.FindDef(inst->GetOperandAs<uint32_t>(2));
+  } else {
+    structure_type = state.FindDef(pointer_ty->GetOperandAs<uint32_t>(2));
+  }
+
   if (structure_type->opcode() != spv::Op::OpTypeStruct) {
     return state.diag(SPV_ERROR_INVALID_ID, inst)
            << "The Structure's type in " << instr_name << " <id> "
@@ -1536,11 +1911,12 @@ spv_result_t ValidateArrayLength(ValidationState_t& state,
 
   // The array member must the index of the last element (the run time
   // array).
-  if (inst->GetOperandAs<uint32_t>(3) != num_of_members - 1) {
+  const auto index = untyped ? 4 : 3;
+  if (inst->GetOperandAs<uint32_t>(index) != num_of_members - 1) {
     return state.diag(SPV_ERROR_INVALID_ID, inst)
            << "The array member in " << instr_name << " <id> "
            << state.getIdName(inst->id())
-           << " must be an the last member of the struct.";
+           << " must be the last member of the struct.";
   }
   return SPV_SUCCESS;
 }
@@ -1725,47 +2101,62 @@ spv_result_t ValidateCooperativeMatrixLoadStoreKHR(ValidationState_t& _,
 
   const auto pointer_type_id = pointer->type_id();
   const auto pointer_type = _.FindDef(pointer_type_id);
-  if (!pointer_type || pointer_type->opcode() != spv::Op::OpTypePointer) {
+  if (!pointer_type ||
+      !(pointer_type->opcode() == spv::Op::OpTypePointer ||
+        pointer_type->opcode() == spv::Op::OpTypeUntypedPointerKHR)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << opname << " type for pointer <id> " << _.getIdName(pointer_id)
            << " is not a pointer type.";
   }
 
+  const bool untyped =
+      pointer_type->opcode() == spv::Op::OpTypeUntypedPointerKHR;
   const auto storage_class_index = 1u;
   const auto storage_class =
       pointer_type->GetOperandAs<spv::StorageClass>(storage_class_index);
 
-  if (storage_class != spv::StorageClass::Workgroup &&
-      storage_class != spv::StorageClass::StorageBuffer &&
-      storage_class != spv::StorageClass::PhysicalStorageBuffer) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << _.VkErrorID(8973) << opname
-           << " storage class for pointer type <id> "
-           << _.getIdName(pointer_type_id)
-           << " is not Workgroup, StorageBuffer, or PhysicalStorageBuffer.";
+  if (spvIsVulkanEnv(_.context()->target_env)) {
+    if (storage_class != spv::StorageClass::Workgroup &&
+        storage_class != spv::StorageClass::StorageBuffer &&
+        storage_class != spv::StorageClass::PhysicalStorageBuffer) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << _.VkErrorID(8973) << opname
+             << " storage class for pointer type <id> "
+             << _.getIdName(pointer_type_id)
+             << " is not Workgroup, StorageBuffer, or PhysicalStorageBuffer.";
+    }
   }
 
-  const auto pointee_id = pointer_type->GetOperandAs<uint32_t>(2);
-  const auto pointee_type = _.FindDef(pointee_id);
-  if (!pointee_type || !(_.IsIntScalarOrVectorType(pointee_id) ||
-                         _.IsFloatScalarOrVectorType(pointee_id))) {
-    return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << opname << " Pointer <id> " << _.getIdName(pointer->id())
-           << "s Type must be a scalar or vector type.";
+  if (!untyped) {
+    const auto pointee_id = pointer_type->GetOperandAs<uint32_t>(2);
+    const auto pointee_type = _.FindDef(pointee_id);
+    if (!pointee_type || !(_.IsIntScalarOrVectorType(pointee_id) ||
+                           _.IsFloatScalarOrVectorType(pointee_id))) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << opname << " Pointer <id> " << _.getIdName(pointer->id())
+             << "s Type must be a scalar or vector type.";
+    }
   }
 
   const auto layout_index =
       (inst->opcode() == spv::Op::OpCooperativeMatrixLoadKHR) ? 3u : 2u;
-  const auto colmajor_id = inst->GetOperandAs<uint32_t>(layout_index);
-  const auto colmajor = _.FindDef(colmajor_id);
-  if (!colmajor || !_.IsIntScalarType(colmajor->type_id()) ||
-      !(spvOpcodeIsConstant(colmajor->opcode()) ||
-        spvOpcodeIsSpecConstant(colmajor->opcode()))) {
+  const auto layout_id = inst->GetOperandAs<uint32_t>(layout_index);
+  const auto layout_inst = _.FindDef(layout_id);
+  if (!layout_inst || !_.IsIntScalarType(layout_inst->type_id()) ||
+      !spvOpcodeIsConstant(layout_inst->opcode())) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
-           << "MemoryLayout operand <id> " << _.getIdName(colmajor_id)
+           << "MemoryLayout operand <id> " << _.getIdName(layout_id)
            << " must be a 32-bit integer constant instruction.";
   }
 
+  bool stride_required = false;
+  uint64_t layout;
+  if (_.EvalConstantValUint64(layout_id, &layout)) {
+    stride_required =
+        (layout == (uint64_t)spv::CooperativeMatrixLayout::RowMajorKHR) ||
+        (layout == (uint64_t)spv::CooperativeMatrixLayout::ColumnMajorKHR);
+  }
+
   const auto stride_index =
       (inst->opcode() == spv::Op::OpCooperativeMatrixLoadKHR) ? 4u : 3u;
   if (inst->operands().size() > stride_index) {
@@ -1776,6 +2167,9 @@ spv_result_t ValidateCooperativeMatrixLoadStoreKHR(ValidationState_t& _,
              << "Stride operand <id> " << _.getIdName(stride_id)
              << " must be a scalar integer type.";
     }
+  } else if (stride_required) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << "MemoryLayout " << layout << " requires a Stride.";
   }
 
   const auto memory_access_index =
@@ -1788,6 +2182,222 @@ spv_result_t ValidateCooperativeMatrixLoadStoreKHR(ValidationState_t& _,
   return SPV_SUCCESS;
 }
 
+// Returns the number of instruction words taken up by a tensor addressing
+// operands argument and its implied operands.
+int TensorAddressingOperandsNumWords(spv::TensorAddressingOperandsMask mask) {
+  int result = 1;  // Count the mask
+  if ((mask & spv::TensorAddressingOperandsMask::TensorView) !=
+      spv::TensorAddressingOperandsMask::MaskNone)
+    ++result;
+  if ((mask & spv::TensorAddressingOperandsMask::DecodeFunc) !=
+      spv::TensorAddressingOperandsMask::MaskNone)
+    ++result;
+  return result;
+}
+
+spv_result_t ValidateCooperativeMatrixLoadStoreTensorNV(
+    ValidationState_t& _, const Instruction* inst) {
+  uint32_t type_id;
+  const char* opname;
+  if (inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) {
+    type_id = inst->type_id();
+    opname = "spv::Op::OpCooperativeMatrixLoadTensorNV";
+  } else {
+    // get Object operand's type
+    type_id = _.FindDef(inst->GetOperandAs<uint32_t>(1))->type_id();
+    opname = "spv::Op::OpCooperativeMatrixStoreTensorNV";
+  }
+
+  auto matrix_type = _.FindDef(type_id);
+
+  if (matrix_type->opcode() != spv::Op::OpTypeCooperativeMatrixKHR) {
+    if (inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "spv::Op::OpCooperativeMatrixLoadTensorNV Result Type <id> "
+             << _.getIdName(type_id) << " is not a cooperative matrix type.";
+    } else {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "spv::Op::OpCooperativeMatrixStoreTensorNV Object type <id> "
+             << _.getIdName(type_id) << " is not a cooperative matrix type.";
+    }
+  }
+
+  const auto pointer_index =
+      (inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) ? 2u : 0u;
+  const auto pointer_id = inst->GetOperandAs<uint32_t>(pointer_index);
+  const auto pointer = _.FindDef(pointer_id);
+  if (!pointer ||
+      ((_.addressing_model() == spv::AddressingModel::Logical) &&
+       ((!_.features().variable_pointers &&
+         !spvOpcodeReturnsLogicalPointer(pointer->opcode())) ||
+        (_.features().variable_pointers &&
+         !spvOpcodeReturnsLogicalVariablePointer(pointer->opcode()))))) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << opname << " Pointer <id> " << _.getIdName(pointer_id)
+           << " is not a logical pointer.";
+  }
+
+  const auto pointer_type_id = pointer->type_id();
+  const auto pointer_type = _.FindDef(pointer_type_id);
+  if (!pointer_type || pointer_type->opcode() != spv::Op::OpTypePointer) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << opname << " type for pointer <id> " << _.getIdName(pointer_id)
+           << " is not a pointer type.";
+  }
+
+  const auto storage_class_index = 1u;
+  const auto storage_class =
+      pointer_type->GetOperandAs<spv::StorageClass>(storage_class_index);
+
+  if (storage_class != spv::StorageClass::Workgroup &&
+      storage_class != spv::StorageClass::StorageBuffer &&
+      storage_class != spv::StorageClass::PhysicalStorageBuffer) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << _.VkErrorID(8973) << opname
+           << " storage class for pointer type <id> "
+           << _.getIdName(pointer_type_id)
+           << " is not Workgroup, StorageBuffer, or PhysicalStorageBuffer.";
+  }
+
+  if (inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) {
+    const auto object_index = 3;
+    const auto object_id = inst->GetOperandAs<uint32_t>(object_index);
+    const auto object = _.FindDef(object_id);
+    if (!object || object->type_id() != type_id) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << opname << " Object <id> " << _.getIdName(object_id)
+             << " type does not match Result Type.";
+    }
+  }
+
+  const auto tensor_layout_index =
+      (inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) ? 4u : 2u;
+  const auto tensor_layout_id =
+      inst->GetOperandAs<uint32_t>(tensor_layout_index);
+  const auto tensor_layout = _.FindDef(tensor_layout_id);
+  if (!tensor_layout || _.FindDef(tensor_layout->type_id())->opcode() !=
+                            spv::Op::OpTypeTensorLayoutNV) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << opname << " TensorLayout <id> " << _.getIdName(tensor_layout_id)
+           << " does not have a tensor layout type.";
+  }
+
+  const auto memory_access_index =
+      (inst->opcode() == spv::Op::OpCooperativeMatrixLoadTensorNV) ? 5u : 3u;
+  if (inst->operands().size() > memory_access_index) {
+    if (auto error = CheckMemoryAccess(_, inst, memory_access_index))
+      return error;
+  }
+
+  const auto memory_access_mask =
+      inst->GetOperandAs<uint32_t>(memory_access_index);
+  const auto tensor_operands_index =
+      memory_access_index + MemoryAccessNumWords(memory_access_mask);
+  const auto tensor_operands =
+      inst->GetOperandAs<spv::TensorAddressingOperandsMask>(
+          tensor_operands_index);
+
+  if (inst->operands().size() <
+      tensor_operands_index +
+          TensorAddressingOperandsNumWords(tensor_operands)) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << opname << " not enough tensor addressing operands.";
+  }
+
+  uint32_t tensor_operand_index = tensor_operands_index + 1;
+  if ((tensor_operands & spv::TensorAddressingOperandsMask::TensorView) !=
+      spv::TensorAddressingOperandsMask::MaskNone) {
+    const auto tensor_view_id =
+        inst->GetOperandAs<uint32_t>(tensor_operand_index);
+    const auto tensor_view = _.FindDef(tensor_view_id);
+    if (!tensor_view || _.FindDef(tensor_view->type_id())->opcode() !=
+                            spv::Op::OpTypeTensorViewNV) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << opname << " TensorView <id> " << _.getIdName(tensor_view_id)
+             << " does not have a tensor view type.";
+    }
+
+    tensor_operand_index++;
+  }
+
+  if ((tensor_operands & spv::TensorAddressingOperandsMask::DecodeFunc) !=
+      spv::TensorAddressingOperandsMask::MaskNone) {
+    if (inst->opcode() == spv::Op::OpCooperativeMatrixStoreTensorNV) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << "OpCooperativeMatrixStoreTensorNV does not support DecodeFunc.";
+    }
+    const auto decode_func_id =
+        inst->GetOperandAs<uint32_t>(tensor_operand_index);
+    const auto decode_func = _.FindDef(decode_func_id);
+
+    if (!decode_func || decode_func->opcode() != spv::Op::OpFunction) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << opname << " DecodeFunc <id> " << _.getIdName(decode_func_id)
+             << " is not a function.";
+    }
+
+    const auto component_type_index = 1;
+    const auto component_type_id =
+        matrix_type->GetOperandAs<uint32_t>(component_type_index);
+
+    const auto function_type =
+        _.FindDef(decode_func->GetOperandAs<uint32_t>(3));
+    if (function_type->GetOperandAs<uint32_t>(1) != component_type_id) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << opname << " DecodeFunc <id> " << _.getIdName(decode_func_id)
+             << " return type must match matrix component type.";
+    }
+
+    const auto decode_ptr_type_id = function_type->GetOperandAs<uint32_t>(2);
+    const auto decode_ptr_type = _.FindDef(decode_ptr_type_id);
+    auto decode_storage_class =
+        decode_ptr_type->GetOperandAs<spv::StorageClass>(storage_class_index);
+
+    if (decode_storage_class != spv::StorageClass::PhysicalStorageBuffer) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << opname << " DecodeFunc <id> " << _.getIdName(decode_func_id)
+             << " first parameter must be pointer to PhysicalStorageBuffer.";
+    }
+
+    const auto tensor_layout_type = _.FindDef(tensor_layout->type_id());
+
+    for (uint32_t param = 3; param < 5; ++param) {
+      const auto param_type_id = function_type->GetOperandAs<uint32_t>(param);
+      const auto param_type = _.FindDef(param_type_id);
+      if (param_type->opcode() != spv::Op::OpTypeArray) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << opname << " DecodeFunc <id> " << _.getIdName(decode_func_id)
+               << " second/third parameter must be array of 32-bit integer "
+                  "with "
+               << " dimension equal to the tensor dimension.";
+      }
+      const auto length_index = 2u;
+      uint64_t array_length;
+      if (_.EvalConstantValUint64(
+              param_type->GetOperandAs<uint32_t>(length_index),
+              &array_length)) {
+        const auto tensor_layout_dim_id =
+            tensor_layout_type->GetOperandAs<uint32_t>(1);
+        uint64_t dim_value;
+        if (_.EvalConstantValUint64(tensor_layout_dim_id, &dim_value)) {
+          if (array_length != dim_value) {
+            return _.diag(SPV_ERROR_INVALID_ID, inst)
+                   << opname << " DecodeFunc <id> "
+                   << _.getIdName(decode_func_id)
+                   << " second/third parameter must be array of 32-bit integer "
+                      "with "
+                   << " dimension equal to the tensor dimension.";
+          }
+        }
+      }
+    }
+
+    tensor_operand_index++;
+  }
+
+  return SPV_SUCCESS;
+}
+
 spv_result_t ValidatePtrComparison(ValidationState_t& _,
                                    const Instruction* inst) {
   if (_.addressing_model() == spv::AddressingModel::Logical &&
@@ -1817,7 +2427,8 @@ spv_result_t ValidatePtrComparison(ValidationState_t& _,
            << "The types of Operand 1 and Operand 2 must match";
   }
   const auto op1_type = _.FindDef(op1->type_id());
-  if (!op1_type || op1_type->opcode() != spv::Op::OpTypePointer) {
+  if (!op1_type || (op1_type->opcode() != spv::Op::OpTypePointer &&
+                    op1_type->opcode() != spv::Op::OpTypeUntypedPointerKHR)) {
     return _.diag(SPV_ERROR_INVALID_ID, inst)
            << "Operand type must be a pointer";
   }
@@ -1849,6 +2460,7 @@ spv_result_t ValidatePtrComparison(ValidationState_t& _,
 spv_result_t MemoryPass(ValidationState_t& _, const Instruction* inst) {
   switch (inst->opcode()) {
     case spv::Op::OpVariable:
+    case spv::Op::OpUntypedVariableKHR:
       if (auto error = ValidateVariable(_, inst)) return error;
       break;
     case spv::Op::OpLoad:
@@ -1862,14 +2474,22 @@ spv_result_t MemoryPass(ValidationState_t& _, const Instruction* inst) {
       if (auto error = ValidateCopyMemory(_, inst)) return error;
       break;
     case spv::Op::OpPtrAccessChain:
+    case spv::Op::OpUntypedPtrAccessChainKHR:
+    case spv::Op::OpUntypedInBoundsPtrAccessChainKHR:
       if (auto error = ValidatePtrAccessChain(_, inst)) return error;
       break;
     case spv::Op::OpAccessChain:
     case spv::Op::OpInBoundsAccessChain:
     case spv::Op::OpInBoundsPtrAccessChain:
+    case spv::Op::OpUntypedAccessChainKHR:
+    case spv::Op::OpUntypedInBoundsAccessChainKHR:
       if (auto error = ValidateAccessChain(_, inst)) return error;
       break;
+    case spv::Op::OpRawAccessChainNV:
+      if (auto error = ValidateRawAccessChain(_, inst)) return error;
+      break;
     case spv::Op::OpArrayLength:
+    case spv::Op::OpUntypedArrayLengthKHR:
       if (auto error = ValidateArrayLength(_, inst)) return error;
       break;
     case spv::Op::OpCooperativeMatrixLoadNV:
@@ -1886,6 +2506,11 @@ spv_result_t MemoryPass(ValidationState_t& _, const Instruction* inst) {
       if (auto error = ValidateCooperativeMatrixLoadStoreKHR(_, inst))
         return error;
       break;
+    case spv::Op::OpCooperativeMatrixLoadTensorNV:
+    case spv::Op::OpCooperativeMatrixStoreTensorNV:
+      if (auto error = ValidateCooperativeMatrixLoadStoreTensorNV(_, inst))
+        return error;
+      break;
     case spv::Op::OpPtrEqual:
     case spv::Op::OpPtrNotEqual:
     case spv::Op::OpPtrDiff:
diff --git a/source/val/validate_misc.cpp b/source/val/validate_misc.cpp
index d71fd2d2..a404134b 100644
--- a/source/val/validate_misc.cpp
+++ b/source/val/validate_misc.cpp
@@ -50,10 +50,22 @@ spv_result_t ValidateShaderClock(ValidationState_t& _,
   bool is_int32 = false, is_const_int32 = false;
   uint32_t value = 0;
   std::tie(is_int32, is_const_int32, value) = _.EvalInt32IfConst(scope);
-  if (is_const_int32 && spv::Scope(value) != spv::Scope::Subgroup &&
-      spv::Scope(value) != spv::Scope::Device) {
-    return _.diag(SPV_ERROR_INVALID_DATA, inst)
-           << _.VkErrorID(4652) << "Scope must be Subgroup or Device";
+  if (is_const_int32) {
+    spv::Scope scope_val{value};
+    if (spvIsVulkanEnv(_.context()->target_env)) {
+      if (scope_val != spv::Scope::Subgroup &&
+          scope_val != spv::Scope::Device) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << _.VkErrorID(4652) << "Scope must be Subgroup or Device";
+      }
+    } else if (spvIsOpenCLEnv(_.context()->target_env)) {
+      if (scope_val != spv::Scope::Workgroup &&
+          scope_val != spv::Scope::Subgroup &&
+          scope_val != spv::Scope::Device) {
+        return _.diag(SPV_ERROR_INVALID_DATA, inst)
+               << "Scope must be Subgroup, Workgroup, or Device";
+      }
+    }
   }
 
   // Result Type must be a 64 - bit unsigned integer type or
diff --git a/source/val/validate_mode_setting.cpp b/source/val/validate_mode_setting.cpp
index 82c6c3f0..8502fda5 100644
--- a/source/val/validate_mode_setting.cpp
+++ b/source/val/validate_mode_setting.cpp
@@ -346,6 +346,7 @@ spv_result_t ValidateExecutionMode(ValidationState_t& _,
       case spv::ExecutionMode::LocalSizeHintId:
       case spv::ExecutionMode::LocalSizeId:
       case spv::ExecutionMode::FPFastMathDefault:
+      case spv::ExecutionMode::MaximumRegistersIdINTEL:
         valid_mode = true;
         break;
       default:
@@ -723,6 +724,25 @@ spv_result_t ValidateMemoryModel(ValidationState_t& _,
   return SPV_SUCCESS;
 }
 
+bool PerEntryExecutionMode(spv::ExecutionMode mode) {
+  switch (mode) {
+    // These execution modes can be specified multiple times per entry point.
+    case spv::ExecutionMode::DenormPreserve:
+    case spv::ExecutionMode::DenormFlushToZero:
+    case spv::ExecutionMode::SignedZeroInfNanPreserve:
+    case spv::ExecutionMode::RoundingModeRTE:
+    case spv::ExecutionMode::RoundingModeRTZ:
+    case spv::ExecutionMode::FPFastMathDefault:
+    case spv::ExecutionMode::RoundingModeRTPINTEL:
+    case spv::ExecutionMode::RoundingModeRTNINTEL:
+    case spv::ExecutionMode::FloatingPointModeALTINTEL:
+    case spv::ExecutionMode::FloatingPointModeIEEEINTEL:
+      return false;
+    default:
+      return true;
+  }
+}
+
 }  // namespace
 
 spv_result_t ValidateFloatControls2(ValidationState_t& _) {
@@ -807,5 +827,52 @@ spv_result_t ModeSettingPass(ValidationState_t& _, const Instruction* inst) {
   return SPV_SUCCESS;
 }
 
+spv_result_t ValidateDuplicateExecutionModes(ValidationState_t& _) {
+  using PerEntryKey = std::tuple<spv::ExecutionMode, uint32_t>;
+  using PerOperandKey = std::tuple<spv::ExecutionMode, uint32_t, uint32_t>;
+  std::set<PerEntryKey> seen_per_entry;
+  std::set<PerOperandKey> seen_per_operand;
+
+  const auto lookupMode = [&_](spv::ExecutionMode mode) -> std::string {
+    spv_operand_desc desc = nullptr;
+    if (_.grammar().lookupOperand(SPV_OPERAND_TYPE_EXECUTION_MODE,
+                                  static_cast<uint32_t>(mode),
+                                  &desc) == SPV_SUCCESS) {
+      return std::string(desc->name);
+    }
+    return "Unknown";
+  };
+
+  for (const auto& inst : _.ordered_instructions()) {
+    if (inst.opcode() != spv::Op::OpExecutionMode &&
+        inst.opcode() != spv::Op::OpExecutionModeId) {
+      continue;
+    }
+
+    const auto entry = inst.GetOperandAs<uint32_t>(0);
+    const auto mode = inst.GetOperandAs<spv::ExecutionMode>(1);
+    if (PerEntryExecutionMode(mode)) {
+      if (!seen_per_entry.insert(std::make_tuple(mode, entry)).second) {
+        return _.diag(SPV_ERROR_INVALID_ID, &inst)
+               << lookupMode(mode)
+               << " execution mode must not be specified multiple times per "
+                  "entry point";
+      }
+    } else {
+      // Execution modes allowed multiple times all take a single operand.
+      const auto operand = inst.GetOperandAs<uint32_t>(2);
+      if (!seen_per_operand.insert(std::make_tuple(mode, entry, operand))
+               .second) {
+        return _.diag(SPV_ERROR_INVALID_ID, &inst)
+               << lookupMode(mode)
+               << " execution mode must not be specified multiple times for "
+                  "the same entry point and operands";
+      }
+    }
+  }
+
+  return SPV_SUCCESS;
+}
+
 }  // namespace val
 }  // namespace spvtools
diff --git a/source/val/validate_non_uniform.cpp b/source/val/validate_non_uniform.cpp
index 74449e9d..fd422a50 100644
--- a/source/val/validate_non_uniform.cpp
+++ b/source/val/validate_non_uniform.cpp
@@ -389,20 +389,24 @@ spv_result_t ValidateGroupNonUniformRotateKHR(ValidationState_t& _,
 
   if (inst->words().size() > 6) {
     const uint32_t cluster_size_op_id = inst->GetOperandAs<uint32_t>(5);
-    const uint32_t cluster_size_type = _.GetTypeId(cluster_size_op_id);
-    if (!_.IsUnsignedIntScalarType(cluster_size_type)) {
+    const Instruction* cluster_size_inst = _.FindDef(cluster_size_op_id);
+    if (!cluster_size_inst ||
+        !_.IsUnsignedIntScalarType(cluster_size_inst->type_id())) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
              << "ClusterSize must be a scalar of integer type, whose "
                 "Signedness operand is 0.";
     }
 
-    uint64_t cluster_size;
-    if (!_.GetConstantValUint64(cluster_size_op_id, &cluster_size)) {
+    if (!spvOpcodeIsConstant(cluster_size_inst->opcode())) {
       return _.diag(SPV_ERROR_INVALID_DATA, inst)
              << "ClusterSize must come from a constant instruction.";
     }
 
-    if ((cluster_size == 0) || ((cluster_size & (cluster_size - 1)) != 0)) {
+    uint64_t cluster_size;
+    const bool valid_const =
+        _.EvalConstantValUint64(cluster_size_op_id, &cluster_size);
+    if (valid_const &&
+        ((cluster_size == 0) || ((cluster_size & (cluster_size - 1)) != 0))) {
       return _.diag(SPV_WARNING, inst)
              << "Behavior is undefined unless ClusterSize is at least 1 and a "
                 "power of 2.";
diff --git a/source/val/validate_tensor_layout.cpp b/source/val/validate_tensor_layout.cpp
new file mode 100644
index 00000000..35c766b8
--- /dev/null
+++ b/source/val/validate_tensor_layout.cpp
@@ -0,0 +1,184 @@
+// Copyright (c) 2024 NVIDIA Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Validate instructions that manipulate tensor layout and view objects
+
+#include "source/opcode.h"
+#include "source/spirv_target_env.h"
+#include "source/val/instruction.h"
+#include "source/val/validate.h"
+#include "source/val/validation_state.h"
+
+namespace spvtools {
+namespace val {
+namespace {
+
+spv_result_t ValidateTensorLayoutResultTypeNV(ValidationState_t& _,
+                                              const Instruction* inst) {
+  const auto result_type_index = 0;
+  const auto result_type_id = inst->GetOperandAs<uint32_t>(result_type_index);
+  const auto result_type = _.FindDef(result_type_id);
+
+  if (!result_type || spv::Op::OpTypeTensorLayoutNV != result_type->opcode()) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode()) << " Result Type <id> "
+           << _.getIdName(result_type_id) << " is not a tensor layout type.";
+  }
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateTensorViewResultTypeNV(ValidationState_t& _,
+                                            const Instruction* inst) {
+  const auto result_type_index = 0;
+  const auto result_type_id = inst->GetOperandAs<uint32_t>(result_type_index);
+  const auto result_type = _.FindDef(result_type_id);
+
+  if (!result_type || spv::Op::OpTypeTensorViewNV != result_type->opcode()) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode()) << " Result Type <id> "
+           << _.getIdName(result_type_id) << " is not a tensor view type.";
+  }
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateCreateTensorLayoutNV(ValidationState_t& _,
+                                          const Instruction* inst) {
+  if (auto error = ValidateTensorLayoutResultTypeNV(_, inst)) return error;
+
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateCreateTensorViewNV(ValidationState_t& _,
+                                        const Instruction* inst) {
+  if (auto error = ValidateTensorViewResultTypeNV(_, inst)) return error;
+
+  return SPV_SUCCESS;
+}
+
+enum ExpectedNumValues {
+  DIM,
+  DIMx2,
+  ONE,
+  FOUR,
+};
+
+spv_result_t ValidateTensorTypeWithDimValuesNV(ValidationState_t& _,
+                                               const Instruction* inst,
+                                               ExpectedNumValues expected,
+                                               bool is_view) {
+  std::string type_str;
+  if (is_view) {
+    if (auto error = ValidateTensorViewResultTypeNV(_, inst)) return error;
+    type_str = "TensorView";
+  } else {
+    if (auto error = ValidateTensorLayoutResultTypeNV(_, inst)) return error;
+    type_str = "TensorLayout";
+  }
+
+  const auto result_type_id = inst->GetOperandAs<uint32_t>(0);
+  const auto tensor_id = inst->GetOperandAs<uint32_t>(2);
+  const auto tensor = _.FindDef(tensor_id);
+  if (!tensor || result_type_id != tensor->type_id()) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode()) << " Result Type <id> "
+           << _.getIdName(result_type_id) << " does not match " << type_str
+           << " type.";
+  }
+
+  const auto num_values = inst->operands().size() - 3;
+
+  const auto result_type = _.FindDef(result_type_id);
+  const auto dim_index = 1;
+  const auto dim_id = result_type->GetOperandAs<uint32_t>(dim_index);
+  uint64_t dim_value;
+  if (_.EvalConstantValUint64(dim_id, &dim_value)) {
+    uint64_t expected_num_values = 0;
+    switch (expected) {
+      case DIM:
+        expected_num_values = dim_value;
+        break;
+      case DIMx2:
+        expected_num_values = dim_value * 2;
+        break;
+      case ONE:
+        expected_num_values = 1;
+        break;
+      case FOUR:
+        expected_num_values = 4;
+        break;
+    }
+
+    if (num_values != expected_num_values) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << spvOpcodeString(inst->opcode())
+             << " unexpected number of operands.";
+    }
+  }
+
+  for (uint32_t i = 0; i < num_values; ++i) {
+    const auto val_id = inst->GetOperandAs<uint32_t>(i + 3);
+    const auto val = _.FindDef(val_id);
+    if (!val || !_.IsIntScalarType(val->type_id()) ||
+        _.GetBitWidth(val->type_id()) != 32) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << spvOpcodeString(inst->opcode()) << " operand <id> "
+             << _.getIdName(val_id) << " is not a 32-bit integer.";
+    }
+  }
+
+  return SPV_SUCCESS;
+}
+
+}  // namespace
+
+spv_result_t TensorLayoutPass(ValidationState_t& _, const Instruction* inst) {
+  switch (inst->opcode()) {
+    case spv::Op::OpCreateTensorLayoutNV:
+      if (auto error = ValidateCreateTensorLayoutNV(_, inst)) return error;
+      break;
+    case spv::Op::OpCreateTensorViewNV:
+      if (auto error = ValidateCreateTensorViewNV(_, inst)) return error;
+      break;
+    case spv::Op::OpTensorLayoutSetBlockSizeNV:
+    case spv::Op::OpTensorLayoutSetDimensionNV:
+    case spv::Op::OpTensorLayoutSetStrideNV:
+      if (auto error = ValidateTensorTypeWithDimValuesNV(_, inst, DIM, false))
+        return error;
+      break;
+    case spv::Op::OpTensorLayoutSliceNV:
+      if (auto error = ValidateTensorTypeWithDimValuesNV(_, inst, DIMx2, false))
+        return error;
+      break;
+    case spv::Op::OpTensorLayoutSetClampValueNV:
+      if (auto error = ValidateTensorTypeWithDimValuesNV(_, inst, ONE, false))
+        return error;
+      break;
+    case spv::Op::OpTensorViewSetDimensionNV:
+    case spv::Op::OpTensorViewSetStrideNV:
+      if (auto error = ValidateTensorTypeWithDimValuesNV(_, inst, DIM, true))
+        return error;
+      break;
+    case spv::Op::OpTensorViewSetClipNV:
+      if (auto error = ValidateTensorTypeWithDimValuesNV(_, inst, FOUR, true))
+        return error;
+      break;
+    default:
+      break;
+  }
+
+  return SPV_SUCCESS;
+}
+
+}  // namespace val
+}  // namespace spvtools
diff --git a/source/val/validate_type.cpp b/source/val/validate_type.cpp
index 7edd12ff..5101a40c 100644
--- a/source/val/validate_type.cpp
+++ b/source/val/validate_type.cpp
@@ -1,4 +1,5 @@
 // Copyright (c) 2018 Google LLC.
+// Copyright (c) 2024 NVIDIA Corporation
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -24,21 +25,6 @@ namespace spvtools {
 namespace val {
 namespace {
 
-// Returns, as an int64_t, the literal value from an OpConstant or the
-// default value of an OpSpecConstant, assuming it is an integral type.
-// For signed integers, relies the rule that literal value is sign extended
-// to fill out to word granularity.  Assumes that the constant value
-// has
-int64_t ConstantLiteralAsInt64(uint32_t width,
-                               const std::vector<uint32_t>& const_words) {
-  const uint32_t lo_word = const_words[3];
-  if (width <= 32) return int32_t(lo_word);
-  assert(width <= 64);
-  assert(const_words.size() > 4);
-  const uint32_t hi_word = const_words[4];  // Must exist, per spec.
-  return static_cast<int64_t>(uint64_t(lo_word) | uint64_t(hi_word) << 32);
-}
-
 // Validates that type declarations are unique, unless multiple declarations
 // of the same data type are allowed by the specification.
 // (see section 2.8 Types and Variables)
@@ -51,6 +37,7 @@ spv_result_t ValidateUniqueness(ValidationState_t& _, const Instruction* inst) {
   const auto opcode = inst->opcode();
   if (opcode != spv::Op::OpTypeArray && opcode != spv::Op::OpTypeRuntimeArray &&
       opcode != spv::Op::OpTypeStruct && opcode != spv::Op::OpTypePointer &&
+      opcode != spv::Op::OpTypeUntypedPointerKHR &&
       !_.RegisterUniqueTypeDeclaration(inst)) {
     return _.diag(SPV_ERROR_INVALID_DATA, inst)
            << "Duplicate non-aggregate type declarations are not allowed. "
@@ -252,29 +239,17 @@ spv_result_t ValidateTypeArray(ValidationState_t& _, const Instruction* inst) {
            << " is not a constant integer type.";
   }
 
-  switch (length->opcode()) {
-    case spv::Op::OpSpecConstant:
-    case spv::Op::OpConstant: {
-      auto& type_words = const_result_type->words();
-      const bool is_signed = type_words[3] > 0;
-      const uint32_t width = type_words[2];
-      const int64_t ivalue = ConstantLiteralAsInt64(width, length->words());
-      if (ivalue == 0 || (ivalue < 0 && is_signed)) {
-        return _.diag(SPV_ERROR_INVALID_ID, inst)
-               << "OpTypeArray Length <id> " << _.getIdName(length_id)
-               << " default value must be at least 1: found " << ivalue;
-      }
-    } break;
-    case spv::Op::OpConstantNull:
+  int64_t length_value;
+  if (_.EvalConstantValInt64(length_id, &length_value)) {
+    auto& type_words = const_result_type->words();
+    const bool is_signed = type_words[3] > 0;
+    if (length_value == 0 || (length_value < 0 && is_signed)) {
       return _.diag(SPV_ERROR_INVALID_ID, inst)
              << "OpTypeArray Length <id> " << _.getIdName(length_id)
-             << " default value must be at least 1.";
-    case spv::Op::OpSpecConstantOp:
-      // Assume it's OK, rather than try to evaluate the operation.
-      break;
-    default:
-      assert(0 && "bug in spvOpcodeIsConstant() or result type isn't int");
+             << " default value must be at least 1: found " << length_value;
+    }
   }
+
   return SPV_SUCCESS;
 }
 
@@ -608,6 +583,173 @@ spv_result_t ValidateTypeCooperativeMatrix(ValidationState_t& _,
     }
   }
 
+  uint64_t scope_value;
+  if (_.EvalConstantValUint64(scope_id, &scope_value)) {
+    if (scope_value == static_cast<uint32_t>(spv::Scope::Workgroup)) {
+      for (auto entry_point_id : _.entry_points()) {
+        if (!_.EntryPointHasLocalSizeOrId(entry_point_id)) {
+          return _.diag(SPV_ERROR_INVALID_ID, inst)
+                 << "OpTypeCooperativeMatrixKHR with ScopeWorkgroup "
+                 << "used without specifying LocalSize or LocalSizeId "
+                 << "for entry point <id> " << _.getIdName(entry_point_id);
+        }
+        const auto local_size = _.EntryPointLocalSizeOrId(entry_point_id);
+        const auto mode = local_size->GetOperandAs<spv::ExecutionMode>(1);
+        if (mode == spv::ExecutionMode::LocalSizeId) {
+          uint32_t local_size_ids[3] = {
+              local_size->GetOperandAs<uint32_t>(2),
+              local_size->GetOperandAs<uint32_t>(3),
+              local_size->GetOperandAs<uint32_t>(4),
+          };
+          for (auto id : local_size_ids) {
+            if (_.FindDef(id) > inst) {
+              return _.diag(SPV_ERROR_INVALID_ID, inst)
+                     << "OpTypeCooperativeMatrixKHR with ScopeWorkgroup "
+                     << "used before LocalSizeId constant value <id> "
+                     << _.getIdName(id) << " is defined.";
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateTypeUntypedPointerKHR(ValidationState_t& _,
+                                           const Instruction* inst) {
+  if (spvIsVulkanEnv(_.context()->target_env)) {
+    const auto sc = inst->GetOperandAs<spv::StorageClass>(1);
+    switch (sc) {
+      case spv::StorageClass::Workgroup:
+        if (!_.HasCapability(
+                spv::Capability::WorkgroupMemoryExplicitLayoutKHR)) {
+          return _.diag(SPV_ERROR_INVALID_ID, inst)
+                 << "Workgroup storage class untyped pointers in Vulkan "
+                    "require WorkgroupMemoryExplicitLayoutKHR be declared";
+        }
+        break;
+      case spv::StorageClass::StorageBuffer:
+      case spv::StorageClass::PhysicalStorageBuffer:
+      case spv::StorageClass::Uniform:
+      case spv::StorageClass::PushConstant:
+        break;
+      default:
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << "In Vulkan, untyped pointers can only be used in an "
+                  "explicitly laid out storage class";
+    }
+  }
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateTensorDim(ValidationState_t& _, const Instruction* inst) {
+  const auto dim_index = 1;
+  const auto dim_id = inst->GetOperandAs<uint32_t>(dim_index);
+  const auto dim = _.FindDef(dim_id);
+  if (!dim || !_.IsIntScalarType(dim->type_id()) ||
+      _.GetBitWidth(dim->type_id()) != 32) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode()) << " Dim <id> "
+           << _.getIdName(dim_id) << " is not a 32-bit integer.";
+  }
+
+  constexpr uint32_t max_tensor_dim = 5;
+
+  uint64_t dim_value;
+  if (_.EvalConstantValUint64(dim_id, &dim_value)) {
+    if (dim_value == 0 || dim_value > max_tensor_dim) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << spvOpcodeString(inst->opcode()) << " Dim <id> "
+             << _.getIdName(dim_id) << " must be between 1 and "
+             << max_tensor_dim << ".";
+    }
+  }
+
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateTypeTensorLayoutNV(ValidationState_t& _,
+                                        const Instruction* inst) {
+  if (auto error = ValidateTensorDim(_, inst)) return error;
+
+  const auto clamp_index = 2;
+  const auto clamp_id = inst->GetOperandAs<uint32_t>(clamp_index);
+  const auto clamp = _.FindDef(clamp_id);
+  if (!clamp || !_.IsIntScalarType(clamp->type_id()) ||
+      _.GetBitWidth(clamp->type_id()) != 32) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode()) << " ClampMode <id> "
+           << _.getIdName(clamp_id) << " is not a 32-bit integer.";
+  }
+
+  uint64_t clamp_value;
+  if (_.EvalConstantValUint64(clamp_id, &clamp_value)) {
+    if (clamp_value >
+        static_cast<uint32_t>(spv::TensorClampMode::RepeatMirrored)) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << spvOpcodeString(inst->opcode()) << " ClampMode <id> "
+             << _.getIdName(clamp_id) << " must be a valid TensorClampMode.";
+    }
+  }
+
+  return SPV_SUCCESS;
+}
+
+spv_result_t ValidateTypeTensorViewNV(ValidationState_t& _,
+                                      const Instruction* inst) {
+  if (auto error = ValidateTensorDim(_, inst)) return error;
+
+  const auto has_dim_index = 2;
+  const auto has_dim_id = inst->GetOperandAs<uint32_t>(has_dim_index);
+  const auto has_dim = _.FindDef(has_dim_id);
+  if (!has_dim || !_.IsBoolScalarType(has_dim->type_id())) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode()) << " HasDimensions <id> "
+           << _.getIdName(has_dim_id) << " is not a boolean value.";
+  }
+
+  uint32_t permutation_mask = 0;
+  bool all_constant = true;
+  const auto num_dim = inst->operands().size() - 3;
+  for (size_t p_index = 3; p_index < inst->operands().size(); ++p_index) {
+    auto p_id = inst->GetOperandAs<uint32_t>(p_index);
+    const auto p = _.FindDef(p_id);
+    if (!p || !_.IsIntScalarType(p->type_id()) ||
+        _.GetBitWidth(p->type_id()) != 32) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << spvOpcodeString(inst->opcode()) << " Permutation <id> "
+             << _.getIdName(p_id) << " is not a 32-bit integer.";
+    }
+
+    uint64_t p_value;
+    if (_.EvalConstantValUint64(p_id, &p_value)) {
+      if (p_value >= num_dim) {
+        return _.diag(SPV_ERROR_INVALID_ID, inst)
+               << spvOpcodeString(inst->opcode()) << " Permutation <id> "
+               << _.getIdName(p_id) << " must be a valid dimension.";
+      }
+      permutation_mask |= 1 << p_value;
+    } else {
+      all_constant = false;
+    }
+  }
+  if (all_constant && permutation_mask != (1U << num_dim) - 1U) {
+    return _.diag(SPV_ERROR_INVALID_ID, inst)
+           << spvOpcodeString(inst->opcode())
+           << " Permutation values don't form a valid permutation.";
+  }
+
+  uint64_t dim_value;
+  if (_.EvalConstantValUint64(inst->GetOperandAs<uint32_t>(1), &dim_value)) {
+    if (dim_value != num_dim) {
+      return _.diag(SPV_ERROR_INVALID_ID, inst)
+             << spvOpcodeString(inst->opcode())
+             << " Incorrect number of permutation values.";
+    }
+  }
+
   return SPV_SUCCESS;
 }
 }  // namespace
@@ -655,6 +797,15 @@ spv_result_t TypePass(ValidationState_t& _, const Instruction* inst) {
     case spv::Op::OpTypeCooperativeMatrixKHR:
       if (auto error = ValidateTypeCooperativeMatrix(_, inst)) return error;
       break;
+    case spv::Op::OpTypeUntypedPointerKHR:
+      if (auto error = ValidateTypeUntypedPointerKHR(_, inst)) return error;
+      break;
+    case spv::Op::OpTypeTensorLayoutNV:
+      if (auto error = ValidateTypeTensorLayoutNV(_, inst)) return error;
+      break;
+    case spv::Op::OpTypeTensorViewNV:
+      if (auto error = ValidateTypeTensorViewNV(_, inst)) return error;
+      break;
     default:
       break;
   }
diff --git a/source/val/validation_state.cpp b/source/val/validation_state.cpp
index 971e0315..da9174fa 100644
--- a/source/val/validation_state.cpp
+++ b/source/val/validation_state.cpp
@@ -73,9 +73,11 @@ ModuleLayoutSection InstructionLayoutSection(
     case spv::Op::OpTypeForwardPointer:
       return kLayoutTypes;
     case spv::Op::OpVariable:
+    case spv::Op::OpUntypedVariableKHR:
       if (current_section == kLayoutTypes) return kLayoutTypes;
       return kLayoutFunctionDefinitions;
     case spv::Op::OpExtInst:
+    case spv::Op::OpExtInstWithForwardRefsKHR:
       // spv::Op::OpExtInst is only allowed in types section for certain
       // extended instruction sets. This will be checked separately.
       if (current_section == kLayoutTypes) return kLayoutTypes;
@@ -615,7 +617,8 @@ void ValidationState_t::RegisterQCOMImageProcessingTextureConsumer(
     uint32_t texture_id, const Instruction* consumer0,
     const Instruction* consumer1) {
   if (HasDecoration(texture_id, spv::Decoration::WeightTextureQCOM) ||
-      HasDecoration(texture_id, spv::Decoration::BlockMatchTextureQCOM)) {
+      HasDecoration(texture_id, spv::Decoration::BlockMatchTextureQCOM) ||
+      HasDecoration(texture_id, spv::Decoration::BlockMatchSamplerQCOM)) {
     qcom_image_processing_consumers_.insert(consumer0->id());
     if (consumer1) {
       qcom_image_processing_consumers_.insert(consumer1->id());
@@ -867,6 +870,9 @@ uint32_t ValidationState_t::GetComponentType(uint32_t id) const {
     case spv::Op::OpTypeBool:
       return id;
 
+    case spv::Op::OpTypeArray:
+      return inst->word(2);
+
     case spv::Op::OpTypeVector:
       return inst->word(2);
 
@@ -954,6 +960,20 @@ bool ValidationState_t::IsFloatVectorType(uint32_t id) const {
   return false;
 }
 
+bool ValidationState_t::IsFloat16Vector2Or4Type(uint32_t id) const {
+  const Instruction* inst = FindDef(id);
+  assert(inst);
+
+  if (inst->opcode() == spv::Op::OpTypeVector) {
+    uint32_t vectorDim = GetDimension(id);
+    return IsFloatScalarType(GetComponentType(id)) &&
+           (vectorDim == 2 || vectorDim == 4) &&
+           (GetBitWidth(GetComponentType(id)) == 16);
+  }
+
+  return false;
+}
+
 bool ValidationState_t::IsFloatScalarOrVectorType(uint32_t id) const {
   const Instruction* inst = FindDef(id);
   if (!inst) {
@@ -976,6 +996,19 @@ bool ValidationState_t::IsIntScalarType(uint32_t id) const {
   return inst && inst->opcode() == spv::Op::OpTypeInt;
 }
 
+bool ValidationState_t::IsIntArrayType(uint32_t id) const {
+  const Instruction* inst = FindDef(id);
+  if (!inst) {
+    return false;
+  }
+
+  if (inst->opcode() == spv::Op::OpTypeArray) {
+    return IsIntScalarType(GetComponentType(id));
+  }
+
+  return false;
+}
+
 bool ValidationState_t::IsIntVectorType(uint32_t id) const {
   const Instruction* inst = FindDef(id);
   if (!inst) {
@@ -1153,7 +1186,9 @@ bool ValidationState_t::GetStructMemberTypes(
 
 bool ValidationState_t::IsPointerType(uint32_t id) const {
   const Instruction* inst = FindDef(id);
-  return inst && inst->opcode() == spv::Op::OpTypePointer;
+  assert(inst);
+  return inst->opcode() == spv::Op::OpTypePointer ||
+         inst->opcode() == spv::Op::OpTypeUntypedPointerKHR;
 }
 
 bool ValidationState_t::GetPointerTypeInfo(
@@ -1163,6 +1198,12 @@ bool ValidationState_t::GetPointerTypeInfo(
 
   const Instruction* inst = FindDef(id);
   assert(inst);
+  if (inst->opcode() == spv::Op::OpTypeUntypedPointerKHR) {
+    *storage_class = spv::StorageClass(inst->word(2));
+    *data_type = 0;
+    return true;
+  }
+
   if (inst->opcode() != spv::Op::OpTypePointer) return false;
 
   *storage_class = spv::StorageClass(inst->word(2));
@@ -1195,7 +1236,7 @@ bool ValidationState_t::IsCooperativeMatrixAType(uint32_t id) const {
   if (!IsCooperativeMatrixKHRType(id)) return false;
   const Instruction* inst = FindDef(id);
   uint64_t matrixUse = 0;
-  if (GetConstantValUint64(inst->word(6), &matrixUse)) {
+  if (EvalConstantValUint64(inst->word(6), &matrixUse)) {
     return matrixUse ==
            static_cast<uint64_t>(spv::CooperativeMatrixUse::MatrixAKHR);
   }
@@ -1206,7 +1247,7 @@ bool ValidationState_t::IsCooperativeMatrixBType(uint32_t id) const {
   if (!IsCooperativeMatrixKHRType(id)) return false;
   const Instruction* inst = FindDef(id);
   uint64_t matrixUse = 0;
-  if (GetConstantValUint64(inst->word(6), &matrixUse)) {
+  if (EvalConstantValUint64(inst->word(6), &matrixUse)) {
     return matrixUse ==
            static_cast<uint64_t>(spv::CooperativeMatrixUse::MatrixBKHR);
   }
@@ -1216,7 +1257,7 @@ bool ValidationState_t::IsCooperativeMatrixAccType(uint32_t id) const {
   if (!IsCooperativeMatrixKHRType(id)) return false;
   const Instruction* inst = FindDef(id);
   uint64_t matrixUse = 0;
-  if (GetConstantValUint64(inst->word(6), &matrixUse)) {
+  if (EvalConstantValUint64(inst->word(6), &matrixUse)) {
     return matrixUse == static_cast<uint64_t>(
                             spv::CooperativeMatrixUse::MatrixAccumulatorKHR);
   }
@@ -1249,8 +1290,9 @@ bool ValidationState_t::IsUnsigned64BitHandle(uint32_t id) const {
 }
 
 spv_result_t ValidationState_t::CooperativeMatrixShapesMatch(
-    const Instruction* inst, uint32_t m1, uint32_t m2) {
-  const auto m1_type = FindDef(m1);
+    const Instruction* inst, uint32_t result_type_id, uint32_t m2,
+    bool is_conversion, bool swap_row_col) {
+  const auto m1_type = FindDef(result_type_id);
   const auto m2_type = FindDef(m2);
 
   if (m1_type->opcode() != m2_type->opcode()) {
@@ -1266,6 +1308,10 @@ spv_result_t ValidationState_t::CooperativeMatrixShapesMatch(
   uint32_t m2_rows_id = m2_type->GetOperandAs<uint32_t>(3);
   uint32_t m2_cols_id = m2_type->GetOperandAs<uint32_t>(4);
 
+  if (swap_row_col) {
+    std::swap(m1_rows_id, m1_cols_id);
+  }
+
   bool m1_is_int32 = false, m1_is_const_int32 = false, m2_is_int32 = false,
        m2_is_const_int32 = false;
   uint32_t m1_value = 0, m2_value = 0;
@@ -1289,7 +1335,7 @@ spv_result_t ValidationState_t::CooperativeMatrixShapesMatch(
   if (m1_is_const_int32 && m2_is_const_int32 && m1_value != m2_value) {
     return diag(SPV_ERROR_INVALID_DATA, inst)
            << "Expected rows of Matrix type and Result Type to be "
-           << "identical";
+           << (swap_row_col ? "swapped with columns" : "identical");
   }
 
   std::tie(m1_is_int32, m1_is_const_int32, m1_value) =
@@ -1300,7 +1346,7 @@ spv_result_t ValidationState_t::CooperativeMatrixShapesMatch(
   if (m1_is_const_int32 && m2_is_const_int32 && m1_value != m2_value) {
     return diag(SPV_ERROR_INVALID_DATA, inst)
            << "Expected columns of Matrix type and Result Type to be "
-           << "identical";
+           << (swap_row_col ? "swapped with rows" : "identical");
   }
 
   if (m1_type->opcode() == spv::Op::OpTypeCooperativeMatrixKHR) {
@@ -1311,7 +1357,12 @@ spv_result_t ValidationState_t::CooperativeMatrixShapesMatch(
     std::tie(m2_is_int32, m2_is_const_int32, m2_value) =
         EvalInt32IfConst(m2_use_id);
 
-    if (m1_is_const_int32 && m2_is_const_int32 && m1_value != m2_value) {
+    if (m1_is_const_int32 && m2_is_const_int32 && m1_value != m2_value &&
+        // CooperativeMatrixConversionsNV allows conversions from Acc->A/B
+        !(is_conversion &&
+          HasCapability(spv::Capability::CooperativeMatrixConversionsNV) &&
+          m2_value ==
+              (uint32_t)spv::CooperativeMatrixUse::MatrixAccumulatorKHR)) {
       return diag(SPV_ERROR_INVALID_DATA, inst)
              << "Expected Use of Matrix type and Result Type to be "
              << "identical";
@@ -1326,20 +1377,23 @@ uint32_t ValidationState_t::GetOperandTypeId(const Instruction* inst,
   return GetTypeId(inst->GetOperandAs<uint32_t>(operand_index));
 }
 
-bool ValidationState_t::GetConstantValUint64(uint32_t id, uint64_t* val) const {
+bool ValidationState_t::EvalConstantValUint64(uint32_t id,
+                                              uint64_t* val) const {
   const Instruction* inst = FindDef(id);
   if (!inst) {
     assert(0 && "Instruction not found");
     return false;
   }
 
-  if (inst->opcode() != spv::Op::OpConstant &&
-      inst->opcode() != spv::Op::OpSpecConstant)
-    return false;
-
   if (!IsIntScalarType(inst->type_id())) return false;
 
-  if (inst->words().size() == 4) {
+  if (inst->opcode() == spv::Op::OpConstantNull) {
+    *val = 0;
+  } else if (inst->opcode() != spv::Op::OpConstant) {
+    // Spec constant values cannot be evaluated so don't consider constant for
+    // static validation
+    return false;
+  } else if (inst->words().size() == 4) {
     *val = inst->word(3);
   } else {
     assert(inst->words().size() == 5);
@@ -1349,6 +1403,32 @@ bool ValidationState_t::GetConstantValUint64(uint32_t id, uint64_t* val) const {
   return true;
 }
 
+bool ValidationState_t::EvalConstantValInt64(uint32_t id, int64_t* val) const {
+  const Instruction* inst = FindDef(id);
+  if (!inst) {
+    assert(0 && "Instruction not found");
+    return false;
+  }
+
+  if (!IsIntScalarType(inst->type_id())) return false;
+
+  if (inst->opcode() == spv::Op::OpConstantNull) {
+    *val = 0;
+  } else if (inst->opcode() != spv::Op::OpConstant) {
+    // Spec constant values cannot be evaluated so don't consider constant for
+    // static validation
+    return false;
+  } else if (inst->words().size() == 4) {
+    *val = int32_t(inst->word(3));
+  } else {
+    assert(inst->words().size() == 5);
+    const uint32_t lo_word = inst->word(3);
+    const uint32_t hi_word = inst->word(4);
+    *val = static_cast<int64_t>(uint64_t(lo_word) | uint64_t(hi_word) << 32);
+  }
+  return true;
+}
+
 std::tuple<bool, bool, uint32_t> ValidationState_t::EvalInt32IfConst(
     uint32_t id) const {
   const Instruction* const inst = FindDef(id);
@@ -1644,6 +1724,39 @@ bool ValidationState_t::ContainsRuntimeArray(uint32_t id) const {
   return ContainsType(id, f, /* traverse_all_types = */ false);
 }
 
+bool ValidationState_t::ContainsUntypedPointer(uint32_t id) const {
+  const auto inst = FindDef(id);
+  if (!inst) return false;
+  if (!spvOpcodeGeneratesType(inst->opcode())) return false;
+  if (inst->opcode() == spv::Op::OpTypeUntypedPointerKHR) return true;
+
+  switch (inst->opcode()) {
+    case spv::Op::OpTypeArray:
+    case spv::Op::OpTypeRuntimeArray:
+    case spv::Op::OpTypeVector:
+    case spv::Op::OpTypeMatrix:
+    case spv::Op::OpTypeImage:
+    case spv::Op::OpTypeSampledImage:
+    case spv::Op::OpTypeCooperativeMatrixNV:
+      return ContainsUntypedPointer(inst->GetOperandAs<uint32_t>(1u));
+    case spv::Op::OpTypePointer:
+      if (IsForwardPointer(id)) return false;
+      return ContainsUntypedPointer(inst->GetOperandAs<uint32_t>(2u));
+    case spv::Op::OpTypeFunction:
+    case spv::Op::OpTypeStruct: {
+      for (uint32_t i = 1; i < inst->operands().size(); ++i) {
+        if (ContainsUntypedPointer(inst->GetOperandAs<uint32_t>(i)))
+          return true;
+      }
+      return false;
+    }
+    default:
+      return false;
+  }
+
+  return false;
+}
+
 bool ValidationState_t::IsValidStorageClass(
     spv::StorageClass storage_class) const {
   if (spvIsVulkanEnv(context()->target_env)) {
@@ -2265,6 +2378,8 @@ std::string ValidationState_t::VkErrorID(uint32_t id,
       return VUID_WRAP(VUID-StandaloneSpirv-Uniform-06807);
     case 6808:
       return VUID_WRAP(VUID-StandaloneSpirv-PushConstant-06808);
+    case 6924:
+      return VUID_WRAP(VUID-StandaloneSpirv-OpTypeImage-06924);
     case 6925:
       return VUID_WRAP(VUID-StandaloneSpirv-Uniform-06925);
     case 7041:
@@ -2307,6 +2422,12 @@ std::string ValidationState_t::VkErrorID(uint32_t id,
       return VUID_WRAP(VUID-StandaloneSpirv-OpEntryPoint-08722);
     case 8973:
       return VUID_WRAP(VUID-StandaloneSpirv-Pointer-08973);
+    case 9638:
+      return VUID_WRAP(VUID-StandaloneSpirv-OpTypeImage-09638);
+    case 9658:
+      return VUID_WRAP(VUID-StandaloneSpirv-OpEntryPoint-09658);
+    case 9659:
+      return VUID_WRAP(VUID-StandaloneSpirv-OpEntryPoint-09659);
     default:
       return "";  // unknown id
   }
diff --git a/source/val/validation_state.h b/source/val/validation_state.h
index 0cd6c789..44551add 100644
--- a/source/val/validation_state.h
+++ b/source/val/validation_state.h
@@ -240,6 +240,21 @@ class ValidationState_t {
     entry_point_to_execution_modes_[entry_point].insert(execution_mode);
   }
 
+  /// Registers that the entry point declares its local size
+  void RegisterEntryPointLocalSize(uint32_t entry_point,
+                                   const Instruction* inst) {
+    entry_point_to_local_size_or_id_[entry_point] = inst;
+  }
+  /// Returns whether the entry point declares its local size
+  bool EntryPointHasLocalSizeOrId(uint32_t entry_point) const {
+    return entry_point_to_local_size_or_id_.find(entry_point) !=
+           entry_point_to_local_size_or_id_.end();
+  }
+  /// Returns the id of the local size
+  const Instruction* EntryPointLocalSizeOrId(uint32_t entry_point) const {
+    return entry_point_to_local_size_or_id_.find(entry_point)->second;
+  }
+
   /// Returns the interface descriptions of a given entry point.
   const std::vector<EntryPointDescription>& entry_point_descriptions(
       uint32_t entry_point) {
@@ -602,9 +617,11 @@ class ValidationState_t {
   bool IsVoidType(uint32_t id) const;
   bool IsFloatScalarType(uint32_t id) const;
   bool IsFloatVectorType(uint32_t id) const;
+  bool IsFloat16Vector2Or4Type(uint32_t id) const;
   bool IsFloatScalarOrVectorType(uint32_t id) const;
   bool IsFloatMatrixType(uint32_t id) const;
   bool IsIntScalarType(uint32_t id) const;
+  bool IsIntArrayType(uint32_t id) const;
   bool IsIntVectorType(uint32_t id) const;
   bool IsIntScalarOrVectorType(uint32_t id) const;
   bool IsUnsignedIntScalarType(uint32_t id) const;
@@ -647,9 +664,8 @@ class ValidationState_t {
                     const std::function<bool(const Instruction*)>& f,
                     bool traverse_all_types = true) const;
 
-  // Gets value from OpConstant and OpSpecConstant as uint64.
-  // Returns false on failure (no instruction, wrong instruction, not int).
-  bool GetConstantValUint64(uint32_t id, uint64_t* val) const;
+  // Returns true if |id| is type id that contains an untyped pointer.
+  bool ContainsUntypedPointer(uint32_t id) const;
 
   // Returns type_id if id has type or zero otherwise.
   uint32_t GetTypeId(uint32_t id) const;
@@ -725,6 +741,14 @@ class ValidationState_t {
     pointer_to_storage_image_.insert(type_id);
   }
 
+  // Tries to evaluate a any scalar integer OpConstant as uint64.
+  // OpConstantNull is defined as zero for scalar int (will return true)
+  // OpSpecConstant* return false since their values cannot be relied upon
+  // during validation.
+  bool EvalConstantValUint64(uint32_t id, uint64_t* val) const;
+  // Same as EvalConstantValUint64 but returns a signed int
+  bool EvalConstantValInt64(uint32_t id, int64_t* val) const;
+
   // Tries to evaluate a 32-bit signed or unsigned scalar integer constant.
   // Returns tuple <is_int32, is_const_int32, value>.
   // OpSpecConstant* return |is_const_int32| as false since their values cannot
@@ -750,11 +774,14 @@ class ValidationState_t {
     return SpvDecorationString(uint32_t(decoration));
   }
 
-  // Returns whether type m1 and type m2 are cooperative matrices with
-  // the same "shape" (matching scope, rows, cols). If any are specialization
-  // constants, we assume they can match because we can't prove they don't.
+  // Returns whether type result_type_id and type m2 are cooperative matrices
+  // with the same "shape" (matching scope, rows, cols). If any are
+  // specialization constants, we assume they can match because we can't prove
+  // they don't.
   spv_result_t CooperativeMatrixShapesMatch(const Instruction* inst,
-                                            uint32_t m1, uint32_t m2);
+                                            uint32_t result_type_id,
+                                            uint32_t m2, bool is_conversion,
+                                            bool swap_row_col = false);
 
   // Returns true if |lhs| and |rhs| logically match and, if the decorations of
   // |rhs| are a subset of |lhs|.
@@ -940,6 +967,10 @@ class ValidationState_t {
   std::unordered_map<uint32_t, std::set<spv::ExecutionMode>>
       entry_point_to_execution_modes_;
 
+  // Mapping entry point -> local size execution mode instruction
+  std::unordered_map<uint32_t, const Instruction*>
+      entry_point_to_local_size_or_id_;
+
   /// Mapping function -> array of entry points inside this
   /// module which can (indirectly) call the function.
   std::unordered_map<uint32_t, std::vector<uint32_t>> function_to_entry_points_;
diff --git a/source/wasm/build.sh b/source/wasm/build.sh
index 69468c9c..f4663565 100755
--- a/source/wasm/build.sh
+++ b/source/wasm/build.sh
@@ -70,8 +70,8 @@ build() {
 }
 
 if [ ! -d external/spirv-headers ] ; then
-    echo "Fetching SPIRV-headers"
-    git clone https://github.com/KhronosGroup/SPIRV-Headers.git external/spirv-headers
+    echo "Fetching deps"
+    utils/git-sync-deps
 fi
 
 echo Building ${BASH_REMATCH[1]}
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 40c64f80..119e9c9f 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -88,6 +88,7 @@ endfunction()
 set(TEST_SOURCES
   test_fixture.h
   unit_spirv.h
+  ${spirv-tools_SOURCE_DIR}/tools/io.h
 
   assembly_context_test.cpp
   assembly_format_test.cpp
@@ -110,6 +111,7 @@ set(TEST_SOURCES
   fix_word_test.cpp
   generator_magic_number_test.cpp
   hex_float_test.cpp
+  hex_to_text_test.cpp
   immediate_int_test.cpp
   libspirv_macros_test.cpp
   named_id_test.cpp
@@ -151,8 +153,10 @@ set(TEST_SOURCES
   text_to_binary.subgroup_dispatch_test.cpp
   text_to_binary.reserved_sampling_test.cpp
   text_word_get_test.cpp
+  to_string_test.cpp
 
   unit_spirv.cpp
+  ${spirv-tools_SOURCE_DIR}/tools/io.cpp
 )
 
 spvtools_pch(TEST_SOURCES pch_test)
diff --git a/test/binary_parse_test.cpp b/test/binary_parse_test.cpp
index 1a868dba..1b8d72ec 100644
--- a/test/binary_parse_test.cpp
+++ b/test/binary_parse_test.cpp
@@ -1157,7 +1157,7 @@ INSTANTIATE_TEST_SUITE_P(
         {"OpSource !9999 100",
          "Invalid source language operand: 9999, if you are creating a new "
          "source language please use value 0 (Unknown) and when ready, add "
-         "your source language to SPRIV-Headers"},
+         "your source language to SPIRV-Headers"},
         {"OpEntryPoint !9999", "Invalid execution model operand: 9999"},
         {"OpMemoryModel !9999", "Invalid addressing model operand: 9999"},
         {"OpMemoryModel Logical !9999", "Invalid memory model operand: 9999"},
diff --git a/test/binary_to_text.literal_test.cpp b/test/binary_to_text.literal_test.cpp
index 5956984b..58e1f187 100644
--- a/test/binary_to_text.literal_test.cpp
+++ b/test/binary_to_text.literal_test.cpp
@@ -33,6 +33,7 @@ TEST_P(RoundTripLiteralsTest, Sample) {
   for (bool endian_swap : kSwapEndians) {
     EXPECT_THAT(
         EncodeAndDecodeSuccessfully(GetParam(), SPV_BINARY_TO_TEXT_OPTION_NONE,
+                                    SPV_TEXT_TO_BINARY_OPTION_NONE,
                                     SPV_ENV_UNIVERSAL_1_0, endian_swap),
         Eq(GetParam()));
   }
@@ -68,6 +69,7 @@ TEST_P(RoundTripSpecialCaseLiteralsTest, Sample) {
   for (bool endian_swap : kSwapEndians) {
     EXPECT_THAT(EncodeAndDecodeSuccessfully(std::get<0>(GetParam()),
                                             SPV_BINARY_TO_TEXT_OPTION_NONE,
+                                            SPV_TEXT_TO_BINARY_OPTION_NONE,
                                             SPV_ENV_UNIVERSAL_1_0, endian_swap),
                 Eq(std::get<1>(GetParam())));
   }
diff --git a/test/binary_to_text_test.cpp b/test/binary_to_text_test.cpp
index 85d5bd1d..ecf4d1e0 100644
--- a/test/binary_to_text_test.cpp
+++ b/test/binary_to_text_test.cpp
@@ -247,9 +247,9 @@ using RoundTripInstructionsTest = spvtest::TextToBinaryTestBase<
     ::testing::TestWithParam<std::tuple<spv_target_env, std::string>>>;
 
 TEST_P(RoundTripInstructionsTest, Sample) {
-  EXPECT_THAT(EncodeAndDecodeSuccessfully(std::get<1>(GetParam()),
-                                          SPV_BINARY_TO_TEXT_OPTION_NONE,
-                                          std::get<0>(GetParam())),
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  std::get<1>(GetParam()), SPV_BINARY_TO_TEXT_OPTION_NONE,
+                  SPV_TEXT_TO_BINARY_OPTION_NONE, std::get<0>(GetParam())),
               Eq(std::get<1>(GetParam())));
 }
 
@@ -402,6 +402,32 @@ INSTANTIATE_TEST_SUITE_P(
                 "OpDecorateId %1 MaxByteOffsetId %2\n",
             })));
 
+INSTANTIATE_TEST_SUITE_P(
+    CacheControlsINTEL, RoundTripInstructionsTest,
+    Combine(
+        ::testing::Values(SPV_ENV_UNIVERSAL_1_0),
+        ::testing::ValuesIn(std::vector<std::string>{
+            "OpDecorate %1 CacheControlLoadINTEL 0 UncachedINTEL\n",
+            "OpDecorate %1 CacheControlLoadINTEL 1 CachedINTEL\n",
+            "OpDecorate %1 CacheControlLoadINTEL 2 StreamingINTEL\n",
+            "OpDecorate %1 CacheControlLoadINTEL 3 InvalidateAfterReadINTEL\n",
+            "OpDecorate %1 CacheControlLoadINTEL 4 ConstCachedINTEL\n",
+            "OpDecorate %1 CacheControlStoreINTEL 0 UncachedINTEL\n",
+            "OpDecorate %1 CacheControlStoreINTEL 1 WriteThroughINTEL\n",
+            "OpDecorate %1 CacheControlStoreINTEL 2 WriteBackINTEL\n",
+            "OpDecorate %1 CacheControlStoreINTEL 3 StreamingINTEL\n",
+        })));
+
+INSTANTIATE_TEST_SUITE_P(
+    HostAccessINTEL, RoundTripInstructionsTest,
+    Combine(::testing::Values(SPV_ENV_UNIVERSAL_1_0),
+            ::testing::ValuesIn(std::vector<std::string>{
+                "OpDecorate %1 HostAccessINTEL NoneINTEL \"none\"\n",
+                "OpDecorate %1 HostAccessINTEL ReadINTEL \"read\"\n",
+                "OpDecorate %1 HostAccessINTEL WriteINTEL \"write\"\n",
+                "OpDecorate %1 HostAccessINTEL ReadWriteINTEL \"readwrite\"\n",
+            })));
+
 using MaskSorting = TextToBinaryTest;
 
 TEST_F(MaskSorting, MasksAreSortedFromLSBToMSB) {
@@ -464,6 +490,1462 @@ OpStore %2 %3 Aligned|Volatile 4 ; bogus, but not indented
       expected);
 }
 
+TEST_F(IndentTest, NestedIf) {
+  const std::string input = R"(
+OpCapability Shader
+OpMemoryModel Logical Simple
+OpEntryPoint Fragment %100 "main"
+OpExecutionMode %100 OriginUpperLeft
+OpName %var "var"
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%bool = OpTypeBool
+%5 = OpConstantNull %bool
+%true = OpConstantTrue %bool
+%false = OpConstantFalse %bool
+%uint = OpTypeInt 32 0
+%int = OpTypeInt 32 1
+%uint_42 = OpConstant %uint 42
+%int_42 = OpConstant %int 42
+%13 = OpTypeFunction %uint
+%uint_0 = OpConstant %uint 0
+%uint_1 = OpConstant %uint 1
+%uint_2 = OpConstant %uint 2
+%uint_3 = OpConstant %uint 3
+%uint_4 = OpConstant %uint 4
+%uint_5 = OpConstant %uint 5
+%uint_6 = OpConstant %uint 6
+%uint_7 = OpConstant %uint 7
+%uint_8 = OpConstant %uint 8
+%uint_10 = OpConstant %uint 10
+%uint_20 = OpConstant %uint 20
+%uint_30 = OpConstant %uint 30
+%uint_40 = OpConstant %uint 40
+%uint_50 = OpConstant %uint 50
+%uint_90 = OpConstant %uint 90
+%uint_99 = OpConstant %uint 99
+%_ptr_Private_uint = OpTypePointer Private %uint
+%var = OpVariable %_ptr_Private_uint Private
+%uint_999 = OpConstant %uint 999
+%100 = OpFunction %void None %3
+%10 = OpLabel
+OpStore %var %uint_0
+OpSelectionMerge %99 None
+OpBranchConditional %5 %30 %40
+%30 = OpLabel
+OpStore %var %uint_1
+OpBranch %99
+%40 = OpLabel
+OpStore %var %uint_2
+OpBranch %99
+%99 = OpLabel
+OpStore %var %uint_999
+OpReturn
+OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %20 = OpConstant %8 6
+         %21 = OpConstant %8 7
+         %22 = OpConstant %8 8
+         %23 = OpConstant %8 10
+         %24 = OpConstant %8 20
+         %25 = OpConstant %8 30
+         %26 = OpConstant %8 40
+         %27 = OpConstant %8 50
+         %28 = OpConstant %8 90
+         %29 = OpConstant %8 99
+         %31 = OpTypePointer Private %8
+          %1 = OpVariable %31 Private
+         %32 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+
+         %10 = OpLabel
+                 OpStore %1 %14
+                 OpSelectionMerge %99 None
+                 OpBranchConditional %5 %30 %40
+
+         %30 =     OpLabel
+                     OpStore %1 %15
+                     OpBranch %99
+
+         %40 =     OpLabel
+                     OpStore %1 %16
+                     OpBranch %99
+
+         %99 = OpLabel
+                 OpStore %1 %32
+                 OpReturn
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
+TEST_F(IndentTest, NestedWhile) {
+  const std::string input = R"(
+OpCapability Shader
+OpMemoryModel Logical Simple
+OpEntryPoint Fragment %100 "main"
+OpExecutionMode %100 OriginUpperLeft
+OpName %var "var"
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%bool = OpTypeBool
+%5 = OpConstantNull %bool
+%true = OpConstantTrue %bool
+%false = OpConstantFalse %bool
+%uint = OpTypeInt 32 0
+%int = OpTypeInt 32 1
+%uint_42 = OpConstant %uint 42
+%int_42 = OpConstant %int 42
+%13 = OpTypeFunction %uint
+%uint_0 = OpConstant %uint 0
+%uint_1 = OpConstant %uint 1
+%uint_2 = OpConstant %uint 2
+%uint_3 = OpConstant %uint 3
+%uint_4 = OpConstant %uint 4
+%uint_5 = OpConstant %uint 5
+%uint_6 = OpConstant %uint 6
+%uint_7 = OpConstant %uint 7
+%uint_8 = OpConstant %uint 8
+%uint_10 = OpConstant %uint 10
+%uint_20 = OpConstant %uint 20
+%uint_30 = OpConstant %uint 30
+%uint_40 = OpConstant %uint 40
+%uint_50 = OpConstant %uint 50
+%uint_90 = OpConstant %uint 90
+%uint_99 = OpConstant %uint 99
+%_ptr_Private_uint = OpTypePointer Private %uint
+%var = OpVariable %_ptr_Private_uint Private
+%uint_999 = OpConstant %uint 999
+%100 = OpFunction %void None %3
+%10 = OpLabel
+OpStore %var %uint_0
+OpBranch %20
+%20 = OpLabel
+OpStore %var %uint_1
+OpLoopMerge %99 %20 None
+OpBranch %80
+%80 = OpLabel
+OpStore %var %uint_2
+OpBranchConditional %5 %99 %20
+%99 = OpLabel
+OpStore %var %uint_3
+OpReturn
+OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %30 = OpConstant %8 99
+         %31 = OpTypePointer Private %8
+          %1 = OpVariable %31 Private
+         %32 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+
+         %10 = OpLabel
+                 OpStore %1 %14
+                 OpBranch %20
+
+         %20 = OpLabel
+                 OpStore %1 %15
+                 OpLoopMerge %99 %20 None
+                 OpBranch %80
+
+         %80 =     OpLabel
+                     OpStore %1 %16
+                     OpBranchConditional %5 %99 %20
+
+         %99 = OpLabel
+                 OpStore %1 %17
+                 OpReturn
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
+TEST_F(IndentTest, NestedLoopInLoop) {
+  const std::string input = R"(
+OpCapability Shader
+OpMemoryModel Logical Simple
+OpEntryPoint Fragment %100 "main"
+OpExecutionMode %100 OriginUpperLeft
+OpName %var "var"
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%bool = OpTypeBool
+%5 = OpConstantNull %bool
+%true = OpConstantTrue %bool
+%false = OpConstantFalse %bool
+%uint = OpTypeInt 32 0
+%int = OpTypeInt 32 1
+%uint_42 = OpConstant %uint 42
+%int_42 = OpConstant %int 42
+%13 = OpTypeFunction %uint
+%uint_0 = OpConstant %uint 0
+%uint_1 = OpConstant %uint 1
+%uint_2 = OpConstant %uint 2
+%uint_3 = OpConstant %uint 3
+%uint_4 = OpConstant %uint 4
+%uint_5 = OpConstant %uint 5
+%uint_6 = OpConstant %uint 6
+%uint_7 = OpConstant %uint 7
+%uint_8 = OpConstant %uint 8
+%uint_10 = OpConstant %uint 10
+%uint_20 = OpConstant %uint 20
+%uint_30 = OpConstant %uint 30
+%uint_40 = OpConstant %uint 40
+%uint_50 = OpConstant %uint 50
+%uint_90 = OpConstant %uint 90
+%uint_99 = OpConstant %uint 99
+%_ptr_Private_uint = OpTypePointer Private %uint
+%var = OpVariable %_ptr_Private_uint Private
+%uint_999 = OpConstant %uint 999
+%100 = OpFunction %void None %3
+%10 = OpLabel
+OpBranch %20
+%20 = OpLabel
+OpLoopMerge %99 %50 None
+OpBranchConditional %5 %30 %99
+%30 = OpLabel
+OpLoopMerge %49 %40 None
+OpBranchConditional %true %35 %49
+%35 = OpLabel
+OpBranch %37
+%37 = OpLabel
+OpBranch %40
+%40 = OpLabel
+OpBranch %30
+%49 = OpLabel
+OpBranch %50
+%50 = OpLabel
+OpBranch %20
+%99 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %31 = OpConstant %8 99
+         %32 = OpTypePointer Private %8
+          %1 = OpVariable %32 Private
+         %33 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+
+         %10 = OpLabel
+                 OpBranch %20
+
+         %20 = OpLabel
+                 OpLoopMerge %99 %50 None
+                 OpBranchConditional %5 %30 %99
+
+         %30 =     OpLabel
+                     OpLoopMerge %49 %40 None
+                     OpBranchConditional %6 %35 %49
+
+         %35 =         OpLabel
+                         OpBranch %37
+
+         %37 =         OpLabel
+                         OpBranch %40
+
+         %40 =       OpLabel
+                       OpBranch %30
+
+         %49 =     OpLabel
+                     OpBranch %50
+
+         %50 =   OpLabel
+                   OpBranch %20
+
+         %99 = OpLabel
+                 OpReturn
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
+TEST_F(IndentTest, NestedSwitch) {
+  const std::string input = R"(
+OpCapability Shader
+OpMemoryModel Logical Simple
+OpEntryPoint Fragment %100 "main"
+OpExecutionMode %100 OriginUpperLeft
+OpName %var "var"
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%bool = OpTypeBool
+%5 = OpConstantNull %bool
+%true = OpConstantTrue %bool
+%false = OpConstantFalse %bool
+%uint = OpTypeInt 32 0
+%int = OpTypeInt 32 1
+%uint_42 = OpConstant %uint 42
+%int_42 = OpConstant %int 42
+%13 = OpTypeFunction %uint
+%uint_0 = OpConstant %uint 0
+%uint_1 = OpConstant %uint 1
+%uint_2 = OpConstant %uint 2
+%uint_3 = OpConstant %uint 3
+%uint_4 = OpConstant %uint 4
+%uint_5 = OpConstant %uint 5
+%uint_6 = OpConstant %uint 6
+%uint_7 = OpConstant %uint 7
+%uint_8 = OpConstant %uint 8
+%uint_10 = OpConstant %uint 10
+%uint_20 = OpConstant %uint 20
+%uint_30 = OpConstant %uint 30
+%uint_40 = OpConstant %uint 40
+%uint_50 = OpConstant %uint 50
+%uint_90 = OpConstant %uint 90
+%uint_99 = OpConstant %uint 99
+%_ptr_Private_uint = OpTypePointer Private %uint
+%var = OpVariable %_ptr_Private_uint Private
+%uint_999 = OpConstant %uint 999
+%100 = OpFunction %void None %3
+%10 = OpLabel
+OpSelectionMerge %99 None
+OpSwitch %uint_42 %80 20 %20 30 %30
+%20 = OpLabel
+OpBranch %80
+%80 = OpLabel
+OpBranch %30
+%30 = OpLabel
+OpBranch %99
+%99 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %31 = OpConstant %8 99
+         %32 = OpTypePointer Private %8
+          %1 = OpVariable %32 Private
+         %33 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+
+         %10 = OpLabel
+                 OpSelectionMerge %99 None
+                 OpSwitch %11 %80 20 %20 30 %30
+
+         %20 =     OpLabel
+                     OpBranch %80
+
+         %80 =     OpLabel
+                     OpBranch %30
+
+         %30 =     OpLabel
+                     OpBranch %99
+
+         %99 = OpLabel
+                 OpReturn
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
+TEST_F(IndentTest, ReorderedIf) {
+  const std::string input = R"(
+               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %31 = OpConstant %8 99
+         %32 = OpTypePointer Private %8
+          %1 = OpVariable %32 Private
+         %33 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+         %10 = OpLabel
+               OpSelectionMerge %99 None
+               OpBranchConditional %5 %20 %50
+         %99 = OpLabel
+               OpReturn
+         %20 = OpLabel
+               OpSelectionMerge %49 None
+               OpBranchConditional %5 %30 %40
+         %49 = OpLabel
+               OpBranch %99
+         %40 = OpLabel
+               OpBranch %49
+         %30 = OpLabel
+               OpBranch %49
+         %50 = OpLabel
+               OpSelectionMerge %79 None
+               OpBranchConditional %5 %60 %70
+         %79 = OpLabel
+               OpBranch %99
+         %60 = OpLabel
+               OpBranch %79
+         %70 = OpLabel
+               OpBranch %79
+               OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %31 = OpConstant %8 99
+         %32 = OpTypePointer Private %8
+          %1 = OpVariable %32 Private
+         %33 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+         %10 = OpLabel
+               OpSelectionMerge %99 None
+               OpBranchConditional %5 %20 %50
+         %20 = OpLabel
+               OpSelectionMerge %49 None
+               OpBranchConditional %5 %30 %40
+         %30 = OpLabel
+               OpBranch %49
+         %40 = OpLabel
+               OpBranch %49
+         %49 = OpLabel
+               OpBranch %99
+         %50 = OpLabel
+               OpSelectionMerge %79 None
+               OpBranchConditional %5 %60 %70
+         %60 = OpLabel
+               OpBranch %79
+         %70 = OpLabel
+               OpBranch %79
+         %79 = OpLabel
+               OpBranch %99
+         %99 = OpLabel
+               OpReturn
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_REORDER_BLOCKS,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
+TEST_F(IndentTest, ReorderedFallThroughInSwitch) {
+  const std::string input = R"(
+               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %31 = OpConstant %8 99
+         %32 = OpTypePointer Private %8
+          %1 = OpVariable %32 Private
+         %33 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+         %10 = OpLabel
+               OpSelectionMerge %99 None
+               OpSwitch %11 %50 20 %20 50 %50
+         %99 = OpLabel
+               OpReturn
+         %20 = OpLabel
+               OpSelectionMerge %49 None
+               OpBranchConditional %5 %30 %40
+         %49 = OpLabel
+               OpBranchConditional %5 %99 %50
+         %30 = OpLabel
+               OpBranch %49
+         %40 = OpLabel
+               OpBranch %49
+         %50 = OpLabel
+               OpSelectionMerge %79 None
+               OpBranchConditional %5 %60 %70
+         %79 = OpLabel
+               OpBranch %99
+         %60 = OpLabel
+               OpBranch %79
+         %70 = OpLabel
+               OpBranch %79
+               OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+               OpMemoryModel Logical Simple
+               OpEntryPoint Fragment %100 "main"
+               OpExecutionMode %100 OriginUpperLeft
+               OpName %1 "var"
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %4 = OpTypeBool
+          %5 = OpConstantNull %4
+          %6 = OpConstantTrue %4
+          %7 = OpConstantFalse %4
+          %8 = OpTypeInt 32 0
+          %9 = OpTypeInt 32 1
+         %11 = OpConstant %8 42
+         %12 = OpConstant %9 42
+         %13 = OpTypeFunction %8
+         %14 = OpConstant %8 0
+         %15 = OpConstant %8 1
+         %16 = OpConstant %8 2
+         %17 = OpConstant %8 3
+         %18 = OpConstant %8 4
+         %19 = OpConstant %8 5
+         %21 = OpConstant %8 6
+         %22 = OpConstant %8 7
+         %23 = OpConstant %8 8
+         %24 = OpConstant %8 10
+         %25 = OpConstant %8 20
+         %26 = OpConstant %8 30
+         %27 = OpConstant %8 40
+         %28 = OpConstant %8 50
+         %29 = OpConstant %8 90
+         %31 = OpConstant %8 99
+         %32 = OpTypePointer Private %8
+          %1 = OpVariable %32 Private
+         %33 = OpConstant %8 999
+        %100 = OpFunction %2 None %3
+         %10 = OpLabel
+               OpSelectionMerge %99 None
+               OpSwitch %11 %50 20 %20 50 %50
+         %20 = OpLabel
+               OpSelectionMerge %49 None
+               OpBranchConditional %5 %30 %40
+         %30 = OpLabel
+               OpBranch %49
+         %40 = OpLabel
+               OpBranch %49
+         %49 = OpLabel
+               OpBranchConditional %5 %99 %50
+         %50 = OpLabel
+               OpSelectionMerge %79 None
+               OpBranchConditional %5 %60 %70
+         %60 = OpLabel
+               OpBranch %79
+         %70 = OpLabel
+               OpBranch %79
+         %79 = OpLabel
+               OpBranch %99
+         %99 = OpLabel
+               OpReturn
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_REORDER_BLOCKS,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
+TEST_F(IndentTest, ReorderedNested) {
+  const std::string input = R"(
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %4 "main" %204
+OpExecutionMode %4 OriginUpperLeft
+OpSource GLSL 450
+OpName %4 "main"
+OpName %16 "ff(vf2;f1;"
+OpName %14 "g"
+OpName %15 "f"
+OpName %19 "vg"
+OpName %20 "Block140"
+OpMemberName %20 0 "a"
+OpMemberName %20 1 "b"
+OpName %22 "b140"
+OpName %35 "sv"
+OpName %39 "s"
+OpName %46 "f"
+OpName %51 "g"
+OpName %57 "x"
+OpName %69 "param"
+OpName %75 "i"
+OpName %80 "vc"
+OpName %88 "j"
+OpName %95 "size"
+OpName %174 "v"
+OpName %187 "i"
+OpName %204 "o_color"
+OpMemberDecorate %20 0 Offset 0
+OpMemberDecorate %20 1 Offset 16
+OpDecorate %20 Block
+OpDecorate %22 DescriptorSet 1
+OpDecorate %22 Binding 0
+OpDecorate %39 DescriptorSet 0
+OpDecorate %39 Binding 1
+OpDecorate %95 SpecId 20
+OpDecorate %204 Location 2
+%2 = OpTypeVoid
+%3 = OpTypeFunction %2
+%6 = OpTypeFloat 32
+%7 = OpTypeVector %6 2
+%8 = OpTypePointer Function %7
+%9 = OpTypeVector %6 4
+%10 = OpTypeInt 32 0
+%11 = OpConstant %10 2
+%12 = OpTypeArray %9 %11
+%13 = OpTypeFunction %12 %8 %6
+%18 = OpTypePointer Private %9
+%19 = OpVariable %18 Private
+%20 = OpTypeStruct %6 %9
+%21 = OpTypePointer Uniform %20
+%22 = OpVariable %21 Uniform
+%23 = OpTypeInt 32 1
+%24 = OpConstant %23 1
+%25 = OpTypePointer Uniform %9
+%28 = OpConstant %6 0
+%29 = OpConstantComposite %9 %28 %28 %28 %28
+%34 = OpTypePointer Function %9
+%36 = OpTypeImage %6 2D 0 0 0 1 Unknown
+%37 = OpTypeSampledImage %36
+%38 = OpTypePointer UniformConstant %37
+%39 = OpVariable %38 UniformConstant
+%41 = OpConstantComposite %7 %28 %28
+%45 = OpTypePointer Function %6
+%47 = OpConstant %23 0
+%48 = OpTypePointer Uniform %6
+%53 = OpConstant %6 1
+%55 = OpTypeBool
+%56 = OpTypePointer Function %55
+%58 = OpConstant %10 0
+%59 = OpTypePointer Private %6
+%74 = OpTypePointer Function %23
+%87 = OpTypePointer Function %10
+%95 = OpSpecConstant %10 2
+%100 = OpConstant %10 1
+%109 = OpConstantComposite %9 %53 %53 %53 %53
+%127 = OpConstant %23 10
+%139 = OpConstant %6 2
+%143 = OpConstant %6 3
+%158 = OpConstant %6 4
+%177 = OpConstant %6 0.5
+%195 = OpConstant %23 100
+%202 = OpTypeVector %10 4
+%203 = OpTypePointer Output %202
+%204 = OpVariable %203 Output
+%4 = OpFunction %2 None %3
+%5 = OpLabel
+%35 = OpVariable %34 Function
+%46 = OpVariable %45 Function
+%51 = OpVariable %45 Function
+%57 = OpVariable %56 Function
+%69 = OpVariable %8 Function
+%75 = OpVariable %74 Function
+%80 = OpVariable %34 Function
+%88 = OpVariable %87 Function
+%174 = OpVariable %45 Function
+%187 = OpVariable %74 Function
+%26 = OpAccessChain %25 %22 %24
+%27 = OpLoad %9 %26
+OpStore %19 %27
+%40 = OpLoad %37 %39
+%42 = OpImageSampleImplicitLod %9 %40 %41
+%43 = OpLoad %9 %19
+%44 = OpFAdd %9 %42 %43
+OpStore %35 %44
+%49 = OpAccessChain %48 %22 %47
+%50 = OpLoad %6 %49
+OpStore %46 %50
+%52 = OpLoad %6 %46
+%54 = OpFAdd %6 %52 %53
+OpStore %51 %54
+%60 = OpAccessChain %59 %19 %58
+%61 = OpLoad %6 %60
+%62 = OpFOrdGreaterThan %55 %61 %28
+OpSelectionMerge %64 None
+OpBranchConditional %62 %63 %64
+%64 = OpLabel
+%73 = OpPhi %55 %62 %5 %72 %63
+OpStore %57 %73
+OpStore %75 %47
+OpBranch %76
+%197 = OpLabel
+OpBranch %190
+%63 = OpLabel
+%65 = OpLoad %6 %46
+%66 = OpLoad %6 %51
+%67 = OpCompositeConstruct %7 %65 %66
+%68 = OpLoad %6 %51
+OpStore %69 %67
+%70 = OpFunctionCall %12 %16 %69 %68
+%71 = OpCompositeExtract %6 %70 0 0
+%72 = OpFOrdGreaterThan %55 %71 %28
+OpBranch %64
+%77 = OpLabel
+%81 = OpLoad %9 %19
+OpStore %80 %81
+%82 = OpAccessChain %45 %80 %58
+%83 = OpLoad %6 %82
+%84 = OpFOrdGreaterThan %55 %83 %28
+OpSelectionMerge %86 None
+OpBranchConditional %84 %85 %113
+%85 = OpLabel
+OpStore %88 %58
+OpBranch %89
+%89 = OpLabel
+OpLoopMerge %91 %92 None
+OpBranch %93
+%93 = OpLabel
+%94 = OpLoad %10 %88
+%96 = OpULessThan %55 %94 %95
+OpBranchConditional %96 %90 %91
+%105 = OpLabel
+OpBranch %92
+%198 = OpLabel
+OpBranch %191
+%163 = OpLabel
+OpBranch %136
+%104 = OpLabel
+OpBranch %91
+%76 = OpLabel
+OpLoopMerge %78 %79 None
+OpBranch %77
+%92 = OpLabel
+%107 = OpLoad %10 %88
+%108 = OpIAdd %10 %107 %24
+OpStore %88 %108
+OpBranch %89
+%91 = OpLabel
+%110 = OpLoad %9 %80
+%111 = OpFAdd %9 %110 %109
+OpStore %80 %111
+OpBranch %79
+%113 = OpLabel
+%114 = OpLoad %9 %80
+%115 = OpFSub %9 %114 %109
+OpStore %80 %115
+OpBranch %86
+%132 = OpLabel
+%137 = OpLoad %6 %51
+%138 = OpFAdd %6 %137 %53
+OpStore %51 %138
+OpBranch %133
+%86 = OpLabel
+%116 = OpAccessChain %45 %80 %100
+%117 = OpLoad %6 %116
+%118 = OpFOrdGreaterThan %55 %117 %28
+OpSelectionMerge %120 None
+OpBranchConditional %118 %119 %120
+%119 = OpLabel
+OpBranch %78
+%120 = OpLabel
+%122 = OpAccessChain %45 %80 %11
+%123 = OpLoad %6 %122
+%124 = OpFAdd %6 %123 %53
+%125 = OpAccessChain %45 %80 %11
+OpStore %125 %124
+OpBranch %79
+%79 = OpLabel
+%126 = OpLoad %23 %75
+%128 = OpSLessThan %55 %126 %127
+OpBranchConditional %128 %76 %78
+%78 = OpLabel
+%129 = OpAccessChain %48 %22 %47
+%130 = OpLoad %6 %129
+%131 = OpConvertFToS %23 %130
+OpSelectionMerge %136 None
+OpSwitch %131 %135 0 %132 1 %132 2 %132 3 %133 4 %134
+%90 = OpLabel
+%97 = OpLoad %9 %19
+%98 = OpLoad %9 %80
+%99 = OpFAdd %9 %98 %97
+OpStore %80 %99
+%101 = OpAccessChain %45 %80 %100
+%102 = OpLoad %6 %101
+%103 = OpFOrdLessThan %55 %102 %28
+OpSelectionMerge %105 None
+OpBranchConditional %103 %104 %105
+%161 = OpLabel
+OpLoopMerge %163 %164 None
+OpBranch %165
+%165 = OpLabel
+%166 = OpLoad %6 %51
+%167 = OpFOrdLessThan %55 %166 %139
+OpBranchConditional %167 %162 %163
+%164 = OpLabel
+OpBranch %161
+%162 = OpLabel
+%168 = OpLoad %6 %46
+%169 = OpFOrdLessThan %55 %168 %53
+OpSelectionMerge %171 None
+OpBranchConditional %169 %170 %171
+%135 = OpLabel
+%159 = OpLoad %6 %51
+%160 = OpFAdd %6 %159 %158
+OpStore %51 %160
+OpBranch %161
+%133 = OpLabel
+%140 = OpLoad %6 %51
+%141 = OpFAdd %6 %140 %139
+OpStore %51 %141
+OpBranch %136
+%134 = OpLabel
+%144 = OpLoad %6 %51
+%145 = OpFAdd %6 %144 %143
+OpStore %51 %145
+OpBranch %146
+%146 = OpLabel
+OpLoopMerge %148 %149 None
+OpBranch %150
+%150 = OpLabel
+%151 = OpLoad %6 %51
+%152 = OpFOrdLessThan %55 %151 %139
+OpBranchConditional %152 %147 %148
+%147 = OpLabel
+%153 = OpLoad %6 %46
+%154 = OpFOrdLessThan %55 %153 %53
+OpSelectionMerge %156 None
+OpBranchConditional %154 %155 %156
+%155 = OpLabel
+OpBranch %148
+%156 = OpLabel
+OpBranch %149
+%149 = OpLabel
+OpBranch %146
+%148 = OpLabel
+OpBranch %135
+%136 = OpLabel
+OpStore %174 %53
+%175 = OpAccessChain %45 %35 %58
+%176 = OpLoad %6 %175
+%178 = OpFOrdLessThanEqual %55 %176 %177
+OpSelectionMerge %180 None
+OpBranchConditional %178 %179 %181
+%179 = OpLabel
+OpStore %174 %28
+OpBranch %180
+%185 = OpLabel
+OpStore %174 %139
+OpBranch %186
+%181 = OpLabel
+%182 = OpAccessChain %45 %35 %58
+%183 = OpLoad %6 %182
+%184 = OpFOrdGreaterThanEqual %55 %183 %177
+OpSelectionMerge %186 None
+OpBranchConditional %184 %185 %186
+%170 = OpLabel
+OpBranch %163
+%171 = OpLabel
+OpBranch %164
+%186 = OpLabel
+OpBranch %180
+%188 = OpLabel
+OpLoopMerge %190 %191 None
+OpBranch %189
+%189 = OpLabel
+%192 = OpLoad %9 %19
+%193 = OpFAdd %9 %192 %109
+OpStore %19 %193
+%194 = OpLoad %23 %187
+%196 = OpSGreaterThan %55 %194 %195
+OpSelectionMerge %198 None
+OpBranchConditional %196 %197 %198
+%180 = OpLabel
+OpStore %187 %47
+OpBranch %188
+%191 = OpLabel
+%200 = OpLoad %23 %187
+%201 = OpIAdd %23 %200 %24
+OpStore %187 %201
+OpBranch %188
+%190 = OpLabel
+OpReturn
+OpFunctionEnd
+%16 = OpFunction %12 None %13
+%14 = OpFunctionParameter %8
+%15 = OpFunctionParameter %6
+%17 = OpLabel
+%30 = OpCompositeConstruct %9 %15 %15 %15 %15
+%31 = OpCompositeConstruct %12 %29 %30
+OpReturnValue %31
+OpFunctionEnd
+)";
+  const std::string expected =
+      R"(               OpCapability Shader
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %4 "main" %204
+               OpExecutionMode %4 OriginUpperLeft
+               OpSource GLSL 450
+               OpName %4 "main"
+               OpName %16 "ff(vf2;f1;"
+               OpName %14 "g"
+               OpName %15 "f"
+               OpName %19 "vg"
+               OpName %20 "Block140"
+               OpMemberName %20 0 "a"
+               OpMemberName %20 1 "b"
+               OpName %22 "b140"
+               OpName %35 "sv"
+               OpName %39 "s"
+               OpName %46 "f"
+               OpName %51 "g"
+               OpName %57 "x"
+               OpName %69 "param"
+               OpName %75 "i"
+               OpName %80 "vc"
+               OpName %88 "j"
+               OpName %95 "size"
+               OpName %174 "v"
+               OpName %187 "i"
+               OpName %204 "o_color"
+               OpMemberDecorate %20 0 Offset 0
+               OpMemberDecorate %20 1 Offset 16
+               OpDecorate %20 Block
+               OpDecorate %22 DescriptorSet 1
+               OpDecorate %22 Binding 0
+               OpDecorate %39 DescriptorSet 0
+               OpDecorate %39 Binding 1
+               OpDecorate %95 SpecId 20
+               OpDecorate %204 Location 2
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %6 = OpTypeFloat 32
+          %7 = OpTypeVector %6 2
+          %8 = OpTypePointer Function %7
+          %9 = OpTypeVector %6 4
+         %10 = OpTypeInt 32 0
+         %11 = OpConstant %10 2
+         %12 = OpTypeArray %9 %11
+         %13 = OpTypeFunction %12 %8 %6
+         %18 = OpTypePointer Private %9
+         %19 = OpVariable %18 Private
+         %20 = OpTypeStruct %6 %9
+         %21 = OpTypePointer Uniform %20
+         %22 = OpVariable %21 Uniform
+         %23 = OpTypeInt 32 1
+         %24 = OpConstant %23 1
+         %25 = OpTypePointer Uniform %9
+         %28 = OpConstant %6 0
+         %29 = OpConstantComposite %9 %28 %28 %28 %28
+         %34 = OpTypePointer Function %9
+         %36 = OpTypeImage %6 2D 0 0 0 1 Unknown
+         %37 = OpTypeSampledImage %36
+         %38 = OpTypePointer UniformConstant %37
+         %39 = OpVariable %38 UniformConstant
+         %41 = OpConstantComposite %7 %28 %28
+         %45 = OpTypePointer Function %6
+         %47 = OpConstant %23 0
+         %48 = OpTypePointer Uniform %6
+         %53 = OpConstant %6 1
+         %55 = OpTypeBool
+         %56 = OpTypePointer Function %55
+         %58 = OpConstant %10 0
+         %59 = OpTypePointer Private %6
+         %74 = OpTypePointer Function %23
+         %87 = OpTypePointer Function %10
+         %95 = OpSpecConstant %10 2
+        %100 = OpConstant %10 1
+        %109 = OpConstantComposite %9 %53 %53 %53 %53
+        %127 = OpConstant %23 10
+        %139 = OpConstant %6 2
+        %143 = OpConstant %6 3
+        %158 = OpConstant %6 4
+        %177 = OpConstant %6 0.5
+        %195 = OpConstant %23 100
+        %202 = OpTypeVector %10 4
+        %203 = OpTypePointer Output %202
+        %204 = OpVariable %203 Output
+          %4 = OpFunction %2 None %3
+
+          %5 = OpLabel
+         %35 =   OpVariable %34 Function
+         %46 =   OpVariable %45 Function
+         %51 =   OpVariable %45 Function
+         %57 =   OpVariable %56 Function
+         %69 =   OpVariable %8 Function
+         %75 =   OpVariable %74 Function
+         %80 =   OpVariable %34 Function
+         %88 =   OpVariable %87 Function
+        %174 =   OpVariable %45 Function
+        %187 =   OpVariable %74 Function
+         %26 =   OpAccessChain %25 %22 %24
+         %27 =   OpLoad %9 %26
+                 OpStore %19 %27
+         %40 =   OpLoad %37 %39
+         %42 =   OpImageSampleImplicitLod %9 %40 %41
+         %43 =   OpLoad %9 %19
+         %44 =   OpFAdd %9 %42 %43
+                 OpStore %35 %44
+         %49 =   OpAccessChain %48 %22 %47
+         %50 =   OpLoad %6 %49
+                 OpStore %46 %50
+         %52 =   OpLoad %6 %46
+         %54 =   OpFAdd %6 %52 %53
+                 OpStore %51 %54
+         %60 =   OpAccessChain %59 %19 %58
+         %61 =   OpLoad %6 %60
+         %62 =   OpFOrdGreaterThan %55 %61 %28
+                 OpSelectionMerge %64 None
+                 OpBranchConditional %62 %63 %64
+
+         %63 =     OpLabel
+         %65 =       OpLoad %6 %46
+         %66 =       OpLoad %6 %51
+         %67 =       OpCompositeConstruct %7 %65 %66
+         %68 =       OpLoad %6 %51
+                     OpStore %69 %67
+         %70 =       OpFunctionCall %12 %16 %69 %68
+         %71 =       OpCompositeExtract %6 %70 0 0
+         %72 =       OpFOrdGreaterThan %55 %71 %28
+                     OpBranch %64
+
+         %64 = OpLabel
+         %73 =   OpPhi %55 %62 %5 %72 %63
+                 OpStore %57 %73
+                 OpStore %75 %47
+                 OpBranch %76
+
+         %76 = OpLabel
+                 OpLoopMerge %78 %79 None
+                 OpBranch %77
+
+         %77 =     OpLabel
+         %81 =       OpLoad %9 %19
+                     OpStore %80 %81
+         %82 =       OpAccessChain %45 %80 %58
+         %83 =       OpLoad %6 %82
+         %84 =       OpFOrdGreaterThan %55 %83 %28
+                     OpSelectionMerge %86 None
+                     OpBranchConditional %84 %85 %113
+
+         %85 =         OpLabel
+                         OpStore %88 %58
+                         OpBranch %89
+
+         %89 =         OpLabel
+                         OpLoopMerge %91 %92 None
+                         OpBranch %93
+
+         %93 =             OpLabel
+         %94 =               OpLoad %10 %88
+         %96 =               OpULessThan %55 %94 %95
+                             OpBranchConditional %96 %90 %91
+
+         %90 =                 OpLabel
+         %97 =                   OpLoad %9 %19
+         %98 =                   OpLoad %9 %80
+         %99 =                   OpFAdd %9 %98 %97
+                                 OpStore %80 %99
+        %101 =                   OpAccessChain %45 %80 %100
+        %102 =                   OpLoad %6 %101
+        %103 =                   OpFOrdLessThan %55 %102 %28
+                                 OpSelectionMerge %105 None
+                                 OpBranchConditional %103 %104 %105
+
+        %104 =                     OpLabel
+                                     OpBranch %91
+
+        %105 =                 OpLabel
+                                 OpBranch %92
+
+         %92 =           OpLabel
+        %107 =             OpLoad %10 %88
+        %108 =             OpIAdd %10 %107 %24
+                           OpStore %88 %108
+                           OpBranch %89
+
+         %91 =         OpLabel
+        %110 =           OpLoad %9 %80
+        %111 =           OpFAdd %9 %110 %109
+                         OpStore %80 %111
+                         OpBranch %79
+
+        %113 =         OpLabel
+        %114 =           OpLoad %9 %80
+        %115 =           OpFSub %9 %114 %109
+                         OpStore %80 %115
+                         OpBranch %86
+
+         %86 =     OpLabel
+        %116 =       OpAccessChain %45 %80 %100
+        %117 =       OpLoad %6 %116
+        %118 =       OpFOrdGreaterThan %55 %117 %28
+                     OpSelectionMerge %120 None
+                     OpBranchConditional %118 %119 %120
+
+        %119 =         OpLabel
+                         OpBranch %78
+
+        %120 =     OpLabel
+        %122 =       OpAccessChain %45 %80 %11
+        %123 =       OpLoad %6 %122
+        %124 =       OpFAdd %6 %123 %53
+        %125 =       OpAccessChain %45 %80 %11
+                     OpStore %125 %124
+                     OpBranch %79
+
+         %79 =   OpLabel
+        %126 =     OpLoad %23 %75
+        %128 =     OpSLessThan %55 %126 %127
+                   OpBranchConditional %128 %76 %78
+
+         %78 = OpLabel
+        %129 =   OpAccessChain %48 %22 %47
+        %130 =   OpLoad %6 %129
+        %131 =   OpConvertFToS %23 %130
+                 OpSelectionMerge %136 None
+                 OpSwitch %131 %135 0 %132 1 %132 2 %132 3 %133 4 %134
+
+        %132 =     OpLabel
+        %137 =       OpLoad %6 %51
+        %138 =       OpFAdd %6 %137 %53
+                     OpStore %51 %138
+                     OpBranch %133
+
+        %133 =     OpLabel
+        %140 =       OpLoad %6 %51
+        %141 =       OpFAdd %6 %140 %139
+                     OpStore %51 %141
+                     OpBranch %136
+
+        %134 =     OpLabel
+        %144 =       OpLoad %6 %51
+        %145 =       OpFAdd %6 %144 %143
+                     OpStore %51 %145
+                     OpBranch %146
+
+        %146 =     OpLabel
+                     OpLoopMerge %148 %149 None
+                     OpBranch %150
+
+        %150 =         OpLabel
+        %151 =           OpLoad %6 %51
+        %152 =           OpFOrdLessThan %55 %151 %139
+                         OpBranchConditional %152 %147 %148
+
+        %147 =             OpLabel
+        %153 =               OpLoad %6 %46
+        %154 =               OpFOrdLessThan %55 %153 %53
+                             OpSelectionMerge %156 None
+                             OpBranchConditional %154 %155 %156
+
+        %155 =                 OpLabel
+                                 OpBranch %148
+
+        %156 =             OpLabel
+                             OpBranch %149
+
+        %149 =       OpLabel
+                       OpBranch %146
+
+        %148 =     OpLabel
+                     OpBranch %135
+
+        %135 =     OpLabel
+        %159 =       OpLoad %6 %51
+        %160 =       OpFAdd %6 %159 %158
+                     OpStore %51 %160
+                     OpBranch %161
+
+        %161 =     OpLabel
+                     OpLoopMerge %163 %164 None
+                     OpBranch %165
+
+        %165 =         OpLabel
+        %166 =           OpLoad %6 %51
+        %167 =           OpFOrdLessThan %55 %166 %139
+                         OpBranchConditional %167 %162 %163
+
+        %162 =             OpLabel
+        %168 =               OpLoad %6 %46
+        %169 =               OpFOrdLessThan %55 %168 %53
+                             OpSelectionMerge %171 None
+                             OpBranchConditional %169 %170 %171
+
+        %170 =                 OpLabel
+                                 OpBranch %163
+
+        %171 =             OpLabel
+                             OpBranch %164
+
+        %164 =       OpLabel
+                       OpBranch %161
+
+        %163 =     OpLabel
+                     OpBranch %136
+
+        %136 = OpLabel
+                 OpStore %174 %53
+        %175 =   OpAccessChain %45 %35 %58
+        %176 =   OpLoad %6 %175
+        %178 =   OpFOrdLessThanEqual %55 %176 %177
+                 OpSelectionMerge %180 None
+                 OpBranchConditional %178 %179 %181
+
+        %179 =     OpLabel
+                     OpStore %174 %28
+                     OpBranch %180
+
+        %181 =     OpLabel
+        %182 =       OpAccessChain %45 %35 %58
+        %183 =       OpLoad %6 %182
+        %184 =       OpFOrdGreaterThanEqual %55 %183 %177
+                     OpSelectionMerge %186 None
+                     OpBranchConditional %184 %185 %186
+
+        %185 =         OpLabel
+                         OpStore %174 %139
+                         OpBranch %186
+
+        %186 =     OpLabel
+                     OpBranch %180
+
+        %180 = OpLabel
+                 OpStore %187 %47
+                 OpBranch %188
+
+        %188 = OpLabel
+                 OpLoopMerge %190 %191 None
+                 OpBranch %189
+
+        %189 =     OpLabel
+        %192 =       OpLoad %9 %19
+        %193 =       OpFAdd %9 %192 %109
+                     OpStore %19 %193
+        %194 =       OpLoad %23 %187
+        %196 =       OpSGreaterThan %55 %194 %195
+                     OpSelectionMerge %198 None
+                     OpBranchConditional %196 %197 %198
+
+        %197 =         OpLabel
+                         OpBranch %190
+
+        %198 =     OpLabel
+                     OpBranch %191
+
+        %191 =   OpLabel
+        %200 =     OpLoad %23 %187
+        %201 =     OpIAdd %23 %200 %24
+                   OpStore %187 %201
+                   OpBranch %188
+
+        %190 = OpLabel
+                 OpReturn
+               OpFunctionEnd
+         %16 = OpFunction %12 None %13
+         %14 = OpFunctionParameter %8
+         %15 = OpFunctionParameter %6
+
+         %17 = OpLabel
+         %30 =   OpCompositeConstruct %9 %15 %15 %15 %15
+         %31 =   OpCompositeConstruct %12 %29 %30
+                 OpReturnValue %31
+               OpFunctionEnd
+)";
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input,
+                  SPV_BINARY_TO_TEXT_OPTION_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT |
+                      SPV_BINARY_TO_TEXT_OPTION_REORDER_BLOCKS,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+              expected);
+}
+
 using FriendlyNameDisassemblyTest = spvtest::TextToBinaryTest;
 
 TEST_F(FriendlyNameDisassemblyTest, Sample) {
@@ -494,16 +1976,628 @@ OpMemoryModel Logical GLSL450
 %2 = OpTypeVoid
 )";
   const std::string expected =
-      R"(OpCapability Shader ; 0x00000014
-OpMemoryModel Logical GLSL450 ; 0x0000001c
-%1 = OpTypeInt 32 0 ; 0x00000028
-%2 = OpTypeVoid ; 0x00000038
+      R"(OpCapability Shader                                 ; 0x00000014
+OpMemoryModel Logical GLSL450                       ; 0x0000001c
+%1 = OpTypeInt 32 0                                 ; 0x00000028
+%2 = OpTypeVoid                                     ; 0x00000038
 )";
   EXPECT_THAT(EncodeAndDecodeSuccessfully(
                   input, SPV_BINARY_TO_TEXT_OPTION_SHOW_BYTE_OFFSET),
               expected);
 }
 
+TEST_F(TextToBinaryTest, Comments) {
+  const std::string input = R"(OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %63 "main" %4 %22
+OpExecutionMode %63 OriginUpperLeft
+OpSource GLSL 450
+OpName %4 "_ue"
+OpName %8 "_uf"
+OpName %11 "_ug"
+OpName %12 "_uA"
+OpMemberName %12 0 "_ux"
+OpName %14 "_uc"
+OpName %15 "_uB"
+OpMemberName %15 0 "_ux"
+OpName %20 "_ud"
+OpName %22 "_ucol"
+OpName %26 "ANGLEDepthRangeParams"
+OpMemberName %26 0 "near"
+OpMemberName %26 1 "far"
+OpMemberName %26 2 "diff"
+OpMemberName %26 3 "reserved"
+OpName %27 "ANGLEUniformBlock"
+OpMemberName %27 0 "viewport"
+OpMemberName %27 1 "clipDistancesEnabled"
+OpMemberName %27 2 "xfbActiveUnpaused"
+OpMemberName %27 3 "xfbVerticesPerInstance"
+OpMemberName %27 4 "numSamples"
+OpMemberName %27 5 "xfbBufferOffsets"
+OpMemberName %27 6 "acbBufferOffsets"
+OpMemberName %27 7 "depthRange"
+OpName %29 "ANGLEUniforms"
+OpName %33 "_uc"
+OpName %32 "_uh"
+OpName %49 "_ux"
+OpName %50 "_uy"
+OpName %48 "_ui"
+OpName %63 "main"
+OpName %65 "param"
+OpName %68 "param"
+OpName %73 "param"
+OpDecorate %4 Location 0
+OpDecorate %8 RelaxedPrecision
+OpDecorate %8 DescriptorSet 0
+OpDecorate %8 Binding 0
+OpDecorate %11 DescriptorSet 0
+OpDecorate %11 Binding 1
+OpMemberDecorate %12 0 Offset 0
+OpMemberDecorate %12 0 RelaxedPrecision
+OpDecorate %12 Block
+OpDecorate %14 DescriptorSet 0
+OpDecorate %14 Binding 2
+OpMemberDecorate %15 0 Offset 0
+OpMemberDecorate %15 0 RelaxedPrecision
+OpDecorate %15 BufferBlock
+OpDecorate %20 DescriptorSet 0
+OpDecorate %20 Binding 3
+OpDecorate %22 RelaxedPrecision
+OpDecorate %22 Location 0
+OpMemberDecorate %26 0 Offset 0
+OpMemberDecorate %26 1 Offset 4
+OpMemberDecorate %26 2 Offset 8
+OpMemberDecorate %26 3 Offset 12
+OpMemberDecorate %27 0 Offset 0
+OpMemberDecorate %27 1 Offset 16
+OpMemberDecorate %27 2 Offset 20
+OpMemberDecorate %27 3 Offset 24
+OpMemberDecorate %27 4 Offset 28
+OpMemberDecorate %27 5 Offset 32
+OpMemberDecorate %27 6 Offset 48
+OpMemberDecorate %27 7 Offset 64
+OpMemberDecorate %27 2 RelaxedPrecision
+OpMemberDecorate %27 4 RelaxedPrecision
+OpDecorate %27 Block
+OpDecorate %29 DescriptorSet 0
+OpDecorate %29 Binding 4
+OpDecorate %32 RelaxedPrecision
+OpDecorate %33 RelaxedPrecision
+OpDecorate %36 RelaxedPrecision
+OpDecorate %37 RelaxedPrecision
+OpDecorate %38 RelaxedPrecision
+OpDecorate %39 RelaxedPrecision
+OpDecorate %41 RelaxedPrecision
+OpDecorate %42 RelaxedPrecision
+OpDecorate %43 RelaxedPrecision
+OpDecorate %48 RelaxedPrecision
+OpDecorate %49 RelaxedPrecision
+OpDecorate %50 RelaxedPrecision
+OpDecorate %52 RelaxedPrecision
+OpDecorate %53 RelaxedPrecision
+OpDecorate %54 RelaxedPrecision
+OpDecorate %55 RelaxedPrecision
+OpDecorate %56 RelaxedPrecision
+OpDecorate %57 RelaxedPrecision
+OpDecorate %58 RelaxedPrecision
+OpDecorate %59 RelaxedPrecision
+OpDecorate %60 RelaxedPrecision
+OpDecorate %67 RelaxedPrecision
+OpDecorate %68 RelaxedPrecision
+OpDecorate %72 RelaxedPrecision
+OpDecorate %73 RelaxedPrecision
+OpDecorate %75 RelaxedPrecision
+OpDecorate %76 RelaxedPrecision
+OpDecorate %77 RelaxedPrecision
+OpDecorate %80 RelaxedPrecision
+OpDecorate %81 RelaxedPrecision
+%1 = OpTypeFloat 32
+%2 = OpTypeVector %1 4
+%5 = OpTypeImage %1 2D 0 0 0 1 Unknown
+%6 = OpTypeSampledImage %5
+%9 = OpTypeImage %1 2D 0 0 0 2 Rgba8
+%12 = OpTypeStruct %2
+%15 = OpTypeStruct %2
+%16 = OpTypeInt 32 0
+%17 = OpConstant %16 2
+%18 = OpTypeArray %15 %17
+%23 = OpTypeInt 32 1
+%24 = OpTypeVector %23 4
+%25 = OpTypeVector %16 4
+%26 = OpTypeStruct %1 %1 %1 %1
+%27 = OpTypeStruct %2 %16 %16 %23 %23 %24 %25 %26
+%35 = OpTypeVector %1 2
+%40 = OpTypeVector %23 2
+%61 = OpTypeVoid
+%69 = OpConstant %16 0
+%78 = OpConstant %16 1
+%3 = OpTypePointer Input %2
+%7 = OpTypePointer UniformConstant %6
+%10 = OpTypePointer UniformConstant %9
+%13 = OpTypePointer Uniform %12
+%19 = OpTypePointer Uniform %18
+%21 = OpTypePointer Output %2
+%28 = OpTypePointer Uniform %27
+%30 = OpTypePointer Function %2
+%70 = OpTypePointer Uniform %2
+%31 = OpTypeFunction %2 %30
+%47 = OpTypeFunction %2 %30 %30
+%62 = OpTypeFunction %61
+%4 = OpVariable %3 Input
+%8 = OpVariable %7 UniformConstant
+%11 = OpVariable %10 UniformConstant
+%14 = OpVariable %13 Uniform
+%20 = OpVariable %19 Uniform
+%22 = OpVariable %21 Output
+%29 = OpVariable %28 Uniform
+%32 = OpFunction %2 None %31
+%33 = OpFunctionParameter %30
+%34 = OpLabel
+%36 = OpLoad %6 %8
+%37 = OpLoad %2 %33
+%38 = OpVectorShuffle %35 %37 %37 0 1
+%39 = OpImageSampleImplicitLod %2 %36 %38
+%41 = OpLoad %2 %33
+%42 = OpVectorShuffle %35 %41 %41 2 3
+%43 = OpConvertFToS %40 %42
+%44 = OpLoad %9 %11
+%45 = OpImageRead %2 %44 %43
+%46 = OpFAdd %2 %39 %45
+OpReturnValue %46
+OpFunctionEnd
+%48 = OpFunction %2 None %47
+%49 = OpFunctionParameter %30
+%50 = OpFunctionParameter %30
+%51 = OpLabel
+%52 = OpLoad %2 %49
+%53 = OpVectorShuffle %35 %52 %52 0 1
+%54 = OpLoad %2 %50
+%55 = OpVectorShuffle %35 %54 %54 2 3
+%56 = OpCompositeExtract %1 %53 0
+%57 = OpCompositeExtract %1 %53 1
+%58 = OpCompositeExtract %1 %55 0
+%59 = OpCompositeExtract %1 %55 1
+%60 = OpCompositeConstruct %2 %56 %57 %58 %59
+OpReturnValue %60
+OpFunctionEnd
+%63 = OpFunction %61 None %62
+%64 = OpLabel
+%65 = OpVariable %30 Function
+%68 = OpVariable %30 Function
+%73 = OpVariable %30 Function
+%66 = OpLoad %2 %4
+OpStore %65 %66
+%67 = OpFunctionCall %2 %32 %65
+%71 = OpAccessChain %70 %14 %69
+%72 = OpLoad %2 %71
+OpStore %68 %72
+%74 = OpAccessChain %70 %20 %69 %69
+%75 = OpLoad %2 %74
+OpStore %73 %75
+%76 = OpFunctionCall %2 %48 %68 %73
+%77 = OpFAdd %2 %67 %76
+%79 = OpAccessChain %70 %20 %78 %69
+%80 = OpLoad %2 %79
+%81 = OpFAdd %2 %77 %80
+OpStore %22 %81
+OpReturn
+OpFunctionEnd
+)";
+  const std::string expected = R"(               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %63 "main" %4 %22
+               OpExecutionMode %63 OriginUpperLeft
+
+               ; Debug Information
+               OpSource GLSL 450
+               OpName %4 "_ue"                      ; id %4
+               OpName %8 "_uf"                      ; id %8
+               OpName %11 "_ug"                     ; id %11
+               OpName %12 "_uA"                     ; id %12
+               OpMemberName %12 0 "_ux"
+               OpName %14 "_uc"                     ; id %14
+               OpName %15 "_uB"                     ; id %15
+               OpMemberName %15 0 "_ux"
+               OpName %20 "_ud"                     ; id %20
+               OpName %22 "_ucol"                   ; id %22
+               OpName %26 "ANGLEDepthRangeParams"   ; id %26
+               OpMemberName %26 0 "near"
+               OpMemberName %26 1 "far"
+               OpMemberName %26 2 "diff"
+               OpMemberName %26 3 "reserved"
+               OpName %27 "ANGLEUniformBlock"       ; id %27
+               OpMemberName %27 0 "viewport"
+               OpMemberName %27 1 "clipDistancesEnabled"
+               OpMemberName %27 2 "xfbActiveUnpaused"
+               OpMemberName %27 3 "xfbVerticesPerInstance"
+               OpMemberName %27 4 "numSamples"
+               OpMemberName %27 5 "xfbBufferOffsets"
+               OpMemberName %27 6 "acbBufferOffsets"
+               OpMemberName %27 7 "depthRange"
+               OpName %29 "ANGLEUniforms"           ; id %29
+               OpName %33 "_uc"                     ; id %33
+               OpName %32 "_uh"                     ; id %32
+               OpName %49 "_ux"                     ; id %49
+               OpName %50 "_uy"                     ; id %50
+               OpName %48 "_ui"                     ; id %48
+               OpName %63 "main"                    ; id %63
+               OpName %65 "param"                   ; id %65
+               OpName %68 "param"                   ; id %68
+               OpName %73 "param"                   ; id %73
+
+               ; Annotations
+               OpDecorate %4 Location 0
+               OpDecorate %8 RelaxedPrecision
+               OpDecorate %8 DescriptorSet 0
+               OpDecorate %8 Binding 0
+               OpDecorate %11 DescriptorSet 0
+               OpDecorate %11 Binding 1
+               OpMemberDecorate %12 0 Offset 0
+               OpMemberDecorate %12 0 RelaxedPrecision
+               OpDecorate %12 Block
+               OpDecorate %14 DescriptorSet 0
+               OpDecorate %14 Binding 2
+               OpMemberDecorate %15 0 Offset 0
+               OpMemberDecorate %15 0 RelaxedPrecision
+               OpDecorate %15 BufferBlock
+               OpDecorate %20 DescriptorSet 0
+               OpDecorate %20 Binding 3
+               OpDecorate %22 RelaxedPrecision
+               OpDecorate %22 Location 0
+               OpMemberDecorate %26 0 Offset 0
+               OpMemberDecorate %26 1 Offset 4
+               OpMemberDecorate %26 2 Offset 8
+               OpMemberDecorate %26 3 Offset 12
+               OpMemberDecorate %27 0 Offset 0
+               OpMemberDecorate %27 1 Offset 16
+               OpMemberDecorate %27 2 Offset 20
+               OpMemberDecorate %27 3 Offset 24
+               OpMemberDecorate %27 4 Offset 28
+               OpMemberDecorate %27 5 Offset 32
+               OpMemberDecorate %27 6 Offset 48
+               OpMemberDecorate %27 7 Offset 64
+               OpMemberDecorate %27 2 RelaxedPrecision
+               OpMemberDecorate %27 4 RelaxedPrecision
+               OpDecorate %27 Block
+               OpDecorate %29 DescriptorSet 0
+               OpDecorate %29 Binding 4
+               OpDecorate %32 RelaxedPrecision
+               OpDecorate %33 RelaxedPrecision
+               OpDecorate %36 RelaxedPrecision
+               OpDecorate %37 RelaxedPrecision
+               OpDecorate %38 RelaxedPrecision
+               OpDecorate %39 RelaxedPrecision
+               OpDecorate %41 RelaxedPrecision
+               OpDecorate %42 RelaxedPrecision
+               OpDecorate %43 RelaxedPrecision
+               OpDecorate %48 RelaxedPrecision
+               OpDecorate %49 RelaxedPrecision
+               OpDecorate %50 RelaxedPrecision
+               OpDecorate %52 RelaxedPrecision
+               OpDecorate %53 RelaxedPrecision
+               OpDecorate %54 RelaxedPrecision
+               OpDecorate %55 RelaxedPrecision
+               OpDecorate %56 RelaxedPrecision
+               OpDecorate %57 RelaxedPrecision
+               OpDecorate %58 RelaxedPrecision
+               OpDecorate %59 RelaxedPrecision
+               OpDecorate %60 RelaxedPrecision
+               OpDecorate %67 RelaxedPrecision
+               OpDecorate %68 RelaxedPrecision
+               OpDecorate %72 RelaxedPrecision
+               OpDecorate %73 RelaxedPrecision
+               OpDecorate %75 RelaxedPrecision
+               OpDecorate %76 RelaxedPrecision
+               OpDecorate %77 RelaxedPrecision
+               OpDecorate %80 RelaxedPrecision
+               OpDecorate %81 RelaxedPrecision
+
+               ; Types, variables and constants
+          %1 = OpTypeFloat 32
+          %2 = OpTypeVector %1 4
+          %5 = OpTypeImage %1 2D 0 0 0 1 Unknown
+          %6 = OpTypeSampledImage %5
+          %9 = OpTypeImage %1 2D 0 0 0 2 Rgba8
+         %12 = OpTypeStruct %2                      ; Block
+         %15 = OpTypeStruct %2                      ; BufferBlock
+         %16 = OpTypeInt 32 0
+         %17 = OpConstant %16 2
+         %18 = OpTypeArray %15 %17
+         %23 = OpTypeInt 32 1
+         %24 = OpTypeVector %23 4
+         %25 = OpTypeVector %16 4
+         %26 = OpTypeStruct %1 %1 %1 %1
+         %27 = OpTypeStruct %2 %16 %16 %23 %23 %24 %25 %26  ; Block
+         %35 = OpTypeVector %1 2
+         %40 = OpTypeVector %23 2
+         %61 = OpTypeVoid
+         %69 = OpConstant %16 0
+         %78 = OpConstant %16 1
+          %3 = OpTypePointer Input %2
+          %7 = OpTypePointer UniformConstant %6
+         %10 = OpTypePointer UniformConstant %9
+         %13 = OpTypePointer Uniform %12
+         %19 = OpTypePointer Uniform %18
+         %21 = OpTypePointer Output %2
+         %28 = OpTypePointer Uniform %27
+         %30 = OpTypePointer Function %2
+         %70 = OpTypePointer Uniform %2
+         %31 = OpTypeFunction %2 %30
+         %47 = OpTypeFunction %2 %30 %30
+         %62 = OpTypeFunction %61
+          %4 = OpVariable %3 Input                  ; Location 0
+          %8 = OpVariable %7 UniformConstant        ; RelaxedPrecision, DescriptorSet 0, Binding 0
+         %11 = OpVariable %10 UniformConstant       ; DescriptorSet 0, Binding 1
+         %14 = OpVariable %13 Uniform               ; DescriptorSet 0, Binding 2
+         %20 = OpVariable %19 Uniform               ; DescriptorSet 0, Binding 3
+         %22 = OpVariable %21 Output                ; RelaxedPrecision, Location 0
+         %29 = OpVariable %28 Uniform               ; DescriptorSet 0, Binding 4
+
+               ; Function 32
+         %32 = OpFunction %2 None %31               ; RelaxedPrecision
+         %33 = OpFunctionParameter %30              ; RelaxedPrecision
+         %34 = OpLabel
+         %36 = OpLoad %6 %8                         ; RelaxedPrecision
+         %37 = OpLoad %2 %33                        ; RelaxedPrecision
+         %38 = OpVectorShuffle %35 %37 %37 0 1      ; RelaxedPrecision
+         %39 = OpImageSampleImplicitLod %2 %36 %38  ; RelaxedPrecision
+         %41 = OpLoad %2 %33                        ; RelaxedPrecision
+         %42 = OpVectorShuffle %35 %41 %41 2 3      ; RelaxedPrecision
+         %43 = OpConvertFToS %40 %42                ; RelaxedPrecision
+         %44 = OpLoad %9 %11
+         %45 = OpImageRead %2 %44 %43
+         %46 = OpFAdd %2 %39 %45
+               OpReturnValue %46
+               OpFunctionEnd
+
+               ; Function 48
+         %48 = OpFunction %2 None %47               ; RelaxedPrecision
+         %49 = OpFunctionParameter %30              ; RelaxedPrecision
+         %50 = OpFunctionParameter %30              ; RelaxedPrecision
+         %51 = OpLabel
+         %52 = OpLoad %2 %49                        ; RelaxedPrecision
+         %53 = OpVectorShuffle %35 %52 %52 0 1      ; RelaxedPrecision
+         %54 = OpLoad %2 %50                        ; RelaxedPrecision
+         %55 = OpVectorShuffle %35 %54 %54 2 3      ; RelaxedPrecision
+         %56 = OpCompositeExtract %1 %53 0          ; RelaxedPrecision
+         %57 = OpCompositeExtract %1 %53 1          ; RelaxedPrecision
+         %58 = OpCompositeExtract %1 %55 0          ; RelaxedPrecision
+         %59 = OpCompositeExtract %1 %55 1          ; RelaxedPrecision
+         %60 = OpCompositeConstruct %2 %56 %57 %58 %59  ; RelaxedPrecision
+               OpReturnValue %60
+               OpFunctionEnd
+
+               ; Function 63
+         %63 = OpFunction %61 None %62
+         %64 = OpLabel
+         %65 = OpVariable %30 Function
+         %68 = OpVariable %30 Function              ; RelaxedPrecision
+         %73 = OpVariable %30 Function              ; RelaxedPrecision
+         %66 = OpLoad %2 %4
+               OpStore %65 %66
+         %67 = OpFunctionCall %2 %32 %65            ; RelaxedPrecision
+         %71 = OpAccessChain %70 %14 %69
+         %72 = OpLoad %2 %71                        ; RelaxedPrecision
+               OpStore %68 %72
+         %74 = OpAccessChain %70 %20 %69 %69
+         %75 = OpLoad %2 %74                        ; RelaxedPrecision
+               OpStore %73 %75
+         %76 = OpFunctionCall %2 %48 %68 %73        ; RelaxedPrecision
+         %77 = OpFAdd %2 %67 %76                    ; RelaxedPrecision
+         %79 = OpAccessChain %70 %20 %78 %69
+         %80 = OpLoad %2 %79                        ; RelaxedPrecision
+         %81 = OpFAdd %2 %77 %80                    ; RelaxedPrecision
+               OpStore %22 %81
+               OpReturn
+               OpFunctionEnd
+)";
+
+  EXPECT_THAT(
+      EncodeAndDecodeSuccessfully(
+          input,
+          SPV_BINARY_TO_TEXT_OPTION_COMMENT | SPV_BINARY_TO_TEXT_OPTION_INDENT,
+          SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+      expected);
+}
+
+TEST_F(TextToBinaryTest, NestedWithComments) {
+  const std::string input = R"(OpCapability Shader
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %4 "main" %8 %44
+               OpExecutionMode %4 OriginUpperLeft
+               OpSource ESSL 310
+               OpName %4 "main"
+               OpName %8 "v"
+               OpName %44 "color"
+               OpDecorate %8 RelaxedPrecision
+               OpDecorate %8 Location 0
+               OpDecorate %9 RelaxedPrecision
+               OpDecorate %18 RelaxedPrecision
+               OpDecorate %19 RelaxedPrecision
+               OpDecorate %20 RelaxedPrecision
+               OpDecorate %23 RelaxedPrecision
+               OpDecorate %24 RelaxedPrecision
+               OpDecorate %25 RelaxedPrecision
+               OpDecorate %26 RelaxedPrecision
+               OpDecorate %27 RelaxedPrecision
+               OpDecorate %28 RelaxedPrecision
+               OpDecorate %29 RelaxedPrecision
+               OpDecorate %30 RelaxedPrecision
+               OpDecorate %31 RelaxedPrecision
+               OpDecorate %33 RelaxedPrecision
+               OpDecorate %34 RelaxedPrecision
+               OpDecorate %35 RelaxedPrecision
+               OpDecorate %36 RelaxedPrecision
+               OpDecorate %37 RelaxedPrecision
+               OpDecorate %39 RelaxedPrecision
+               OpDecorate %40 RelaxedPrecision
+               OpDecorate %41 RelaxedPrecision
+               OpDecorate %42 RelaxedPrecision
+               OpDecorate %44 RelaxedPrecision
+               OpDecorate %44 Location 0
+               OpDecorate %45 RelaxedPrecision
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %6 = OpTypeFloat 32
+          %7 = OpTypePointer Input %6
+          %8 = OpVariable %7 Input
+         %10 = OpConstant %6 0
+         %11 = OpTypeBool
+         %15 = OpTypeVector %6 4
+         %16 = OpTypePointer Function %15
+         %21 = OpConstant %6 -0.5
+         %22 = OpConstant %6 -0.300000012
+         %38 = OpConstant %6 0.5
+         %43 = OpTypePointer Output %15
+         %44 = OpVariable %43 Output
+          %4 = OpFunction %2 None %3
+          %5 = OpLabel
+          %9 = OpLoad %6 %8
+         %12 = OpFOrdLessThanEqual %11 %9 %10
+               OpSelectionMerge %14 None
+               OpBranchConditional %12 %13 %32
+         %13 = OpLabel
+         %18 = OpLoad %6 %8
+         %19 = OpExtInst %6 %1 Log %18
+         %20 = OpLoad %6 %8
+         %23 = OpExtInst %6 %1 FClamp %20 %21 %22
+         %24 = OpFMul %6 %19 %23
+         %25 = OpLoad %6 %8
+         %26 = OpExtInst %6 %1 Sin %25
+         %27 = OpLoad %6 %8
+         %28 = OpExtInst %6 %1 Cos %27
+         %29 = OpLoad %6 %8
+         %30 = OpExtInst %6 %1 Exp %29
+         %31 = OpCompositeConstruct %15 %24 %26 %28 %30
+               OpBranch %14
+         %32 = OpLabel
+         %33 = OpLoad %6 %8
+         %34 = OpExtInst %6 %1 Sqrt %33
+         %35 = OpLoad %6 %8
+         %36 = OpExtInst %6 %1 FSign %35
+         %37 = OpLoad %6 %8
+         %39 = OpExtInst %6 %1 FMax %37 %38
+         %40 = OpLoad %6 %8
+         %41 = OpExtInst %6 %1 Floor %40
+         %42 = OpCompositeConstruct %15 %34 %36 %39 %41
+               OpBranch %14
+         %14 = OpLabel
+         %45 = OpPhi %15 %31 %13 %42 %32
+               OpStore %44 %45
+               OpReturn
+               OpFunctionEnd
+)";
+  const std::string expected = R"(               OpCapability Shader
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %4 "main" %8 %44
+               OpExecutionMode %4 OriginUpperLeft
+
+               ; Debug Information
+               OpSource ESSL 310
+               OpName %4 "main"                     ; id %4
+               OpName %8 "v"                        ; id %8
+               OpName %44 "color"                   ; id %44
+
+               ; Annotations
+               OpDecorate %8 RelaxedPrecision
+               OpDecorate %8 Location 0
+               OpDecorate %9 RelaxedPrecision
+               OpDecorate %18 RelaxedPrecision
+               OpDecorate %19 RelaxedPrecision
+               OpDecorate %20 RelaxedPrecision
+               OpDecorate %23 RelaxedPrecision
+               OpDecorate %24 RelaxedPrecision
+               OpDecorate %25 RelaxedPrecision
+               OpDecorate %26 RelaxedPrecision
+               OpDecorate %27 RelaxedPrecision
+               OpDecorate %28 RelaxedPrecision
+               OpDecorate %29 RelaxedPrecision
+               OpDecorate %30 RelaxedPrecision
+               OpDecorate %31 RelaxedPrecision
+               OpDecorate %33 RelaxedPrecision
+               OpDecorate %34 RelaxedPrecision
+               OpDecorate %35 RelaxedPrecision
+               OpDecorate %36 RelaxedPrecision
+               OpDecorate %37 RelaxedPrecision
+               OpDecorate %39 RelaxedPrecision
+               OpDecorate %40 RelaxedPrecision
+               OpDecorate %41 RelaxedPrecision
+               OpDecorate %42 RelaxedPrecision
+               OpDecorate %44 RelaxedPrecision
+               OpDecorate %44 Location 0
+               OpDecorate %45 RelaxedPrecision
+
+               ; Types, variables and constants
+          %2 = OpTypeVoid
+          %3 = OpTypeFunction %2
+          %6 = OpTypeFloat 32
+          %7 = OpTypePointer Input %6
+          %8 = OpVariable %7 Input                  ; RelaxedPrecision, Location 0
+         %10 = OpConstant %6 0
+         %11 = OpTypeBool
+         %15 = OpTypeVector %6 4
+         %16 = OpTypePointer Function %15
+         %21 = OpConstant %6 -0.5
+         %22 = OpConstant %6 -0.300000012
+         %38 = OpConstant %6 0.5
+         %43 = OpTypePointer Output %15
+         %44 = OpVariable %43 Output                ; RelaxedPrecision, Location 0
+
+
+               ; Function 4
+          %4 = OpFunction %2 None %3
+
+          %5 = OpLabel
+          %9 =   OpLoad %6 %8                       ; RelaxedPrecision
+         %12 =   OpFOrdLessThanEqual %11 %9 %10
+                 OpSelectionMerge %14 None
+                 OpBranchConditional %12 %13 %32
+
+         %13 =     OpLabel
+         %18 =       OpLoad %6 %8                   ; RelaxedPrecision
+         %19 =       OpExtInst %6 %1 Log %18        ; RelaxedPrecision
+         %20 =       OpLoad %6 %8                   ; RelaxedPrecision
+         %23 =       OpExtInst %6 %1 FClamp %20 %21 %22     ; RelaxedPrecision
+         %24 =       OpFMul %6 %19 %23                      ; RelaxedPrecision
+         %25 =       OpLoad %6 %8                           ; RelaxedPrecision
+         %26 =       OpExtInst %6 %1 Sin %25                ; RelaxedPrecision
+         %27 =       OpLoad %6 %8                           ; RelaxedPrecision
+         %28 =       OpExtInst %6 %1 Cos %27                ; RelaxedPrecision
+         %29 =       OpLoad %6 %8                           ; RelaxedPrecision
+         %30 =       OpExtInst %6 %1 Exp %29                ; RelaxedPrecision
+         %31 =       OpCompositeConstruct %15 %24 %26 %28 %30   ; RelaxedPrecision
+                     OpBranch %14
+
+         %32 =     OpLabel
+         %33 =       OpLoad %6 %8                   ; RelaxedPrecision
+         %34 =       OpExtInst %6 %1 Sqrt %33       ; RelaxedPrecision
+         %35 =       OpLoad %6 %8                   ; RelaxedPrecision
+         %36 =       OpExtInst %6 %1 FSign %35      ; RelaxedPrecision
+         %37 =       OpLoad %6 %8                   ; RelaxedPrecision
+         %39 =       OpExtInst %6 %1 FMax %37 %38   ; RelaxedPrecision
+         %40 =       OpLoad %6 %8                   ; RelaxedPrecision
+         %41 =       OpExtInst %6 %1 Floor %40      ; RelaxedPrecision
+         %42 =       OpCompositeConstruct %15 %34 %36 %39 %41   ; RelaxedPrecision
+                     OpBranch %14
+
+         %14 = OpLabel
+         %45 =   OpPhi %15 %31 %13 %42 %32          ; RelaxedPrecision
+                 OpStore %44 %45
+                 OpReturn
+               OpFunctionEnd
+)";
+
+  EXPECT_THAT(
+      EncodeAndDecodeSuccessfully(
+          input,
+          SPV_BINARY_TO_TEXT_OPTION_COMMENT | SPV_BINARY_TO_TEXT_OPTION_INDENT |
+              SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT,
+          SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS),
+      expected);
+}
+
 // Test version string.
 TEST_F(TextToBinaryTest, VersionString) {
   auto words = CompileSuccessfully("");
diff --git a/test/diff/diff_test.cpp b/test/diff/diff_test.cpp
index 3b63c69c..da869315 100644
--- a/test/diff/diff_test.cpp
+++ b/test/diff/diff_test.cpp
@@ -20,7 +20,6 @@
 #include "source/opt/ir_context.h"
 #include "source/spirv_constant.h"
 #include "spirv-tools/libspirv.hpp"
-#include "tools/io.h"
 #include "tools/util/cli_consumer.h"
 
 #include <fstream>
diff --git a/test/diff/diff_test_utils.cpp b/test/diff/diff_test_utils.cpp
index 14bb8215..3bea9c3b 100644
--- a/test/diff/diff_test_utils.cpp
+++ b/test/diff/diff_test_utils.cpp
@@ -18,7 +18,6 @@
 #include "source/opt/ir_context.h"
 
 #include "spirv-tools/libspirv.hpp"
-#include "tools/io.h"
 #include "tools/util/cli_consumer.h"
 
 #include "gtest/gtest.h"
diff --git a/test/enum_set_test.cpp b/test/enum_set_test.cpp
index 11105f99..08a4693d 100644
--- a/test/enum_set_test.cpp
+++ b/test/enum_set_test.cpp
@@ -846,9 +846,6 @@ TEST_P(CapabilitySetForEachTest, MoveConstructor) {
   CapabilitySet copy(GetParam().capabilities);
   CapabilitySet moved(std::move(copy));
   EXPECT_THAT(ElementsIn(moved), Eq(GetParam().expected));
-
-  // The moved-from set is empty.
-  EXPECT_THAT(ElementsIn(copy), Eq(std::vector<spv::Capability>{}));
 }
 
 TEST_P(CapabilitySetForEachTest, OperatorEquals) {
@@ -858,7 +855,7 @@ TEST_P(CapabilitySetForEachTest, OperatorEquals) {
 
 TEST_P(CapabilitySetForEachTest, OperatorEqualsSelfAssign) {
   CapabilitySet assigned{GetParam().capabilities};
-  assigned = assigned;
+  assigned = assigned;  // NOLINT
   EXPECT_THAT(ElementsIn(assigned), Eq(GetParam().expected));
 }
 
diff --git a/test/ext_inst.non_semantic_test.cpp b/test/ext_inst.non_semantic_test.cpp
index 870684e9..50621893 100644
--- a/test/ext_inst.non_semantic_test.cpp
+++ b/test/ext_inst.non_semantic_test.cpp
@@ -41,8 +41,7 @@ TEST_F(NonSemanticRoundTripTest, NonSemanticInsts) {
 %8 = OpExtInstImport "NonSemantic.Testing.AnotherUnknownExtInstSet"
 %9 = OpExtInst %4 %8 613874321 %7 %5 %6
 )";
-  std::string disassembly = EncodeAndDecodeSuccessfully(
-      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_ENV_UNIVERSAL_1_0);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
diff --git a/test/fuzz/CMakeLists.txt b/test/fuzz/CMakeLists.txt
index 56af0b9d..6232d6c4 100644
--- a/test/fuzz/CMakeLists.txt
+++ b/test/fuzz/CMakeLists.txt
@@ -123,7 +123,8 @@ if (${SPIRV_BUILD_FUZZER})
           transformation_wrap_early_terminator_in_function_test.cpp
           transformation_wrap_region_in_selection_test.cpp
           transformation_wrap_vector_synonym_test.cpp
-          uniform_buffer_element_descriptor_test.cpp)
+          uniform_buffer_element_descriptor_test.cpp
+          ${spirv-tools_SOURCE_DIR}/tools/io.cpp)
 
   if (${SPIRV_ENABLE_LONG_FUZZER_TESTS})
     # These are long-running tests that depend on random seeds.  We do not want
diff --git a/test/fuzz/fuzz_test_util.cpp b/test/fuzz/fuzz_test_util.cpp
index 93c9c584..b238455d 100644
--- a/test/fuzz/fuzz_test_util.cpp
+++ b/test/fuzz/fuzz_test_util.cpp
@@ -145,7 +145,7 @@ void DumpTransformationsJson(
     const protobufs::TransformationSequence& transformations,
     const char* filename) {
   std::string json_string;
-  auto json_options = google::protobuf::util::JsonOptions();
+  auto json_options = google::protobuf::util::JsonPrintOptions();
   json_options.add_whitespace = true;
   auto json_generation_status = google::protobuf::util::MessageToJsonString(
       transformations, &json_string, json_options);
diff --git a/test/fuzz/transformation_add_no_contraction_decoration_test.cpp b/test/fuzz/transformation_add_no_contraction_decoration_test.cpp
index 4fc9d2d5..1280b815 100644
--- a/test/fuzz/transformation_add_no_contraction_decoration_test.cpp
+++ b/test/fuzz/transformation_add_no_contraction_decoration_test.cpp
@@ -36,7 +36,6 @@ TEST(TransformationAddNoContractionDecorationTest, BasicScenarios) {
                OpName %8 "x"
                OpName %10 "y"
                OpName %14 "i"
-               OpDecorate %32 NoContraction
           %2 = OpTypeVoid
           %3 = OpTypeFunction %2
           %6 = OpTypeFloat 32
@@ -110,9 +109,8 @@ TEST(TransformationAddNoContractionDecorationTest, BasicScenarios) {
   ASSERT_FALSE(TransformationAddNoContractionDecoration(24).IsApplicable(
       context.get(), transformation_context));
 
-  // It is valid to add NoContraction to each of these ids (and it's fine to
-  // have duplicates of the decoration, in the case of 32).
-  for (uint32_t result_id : {32u, 32u, 27u, 29u, 39u}) {
+  // It is valid to add NoContraction to each of these ids.
+  for (uint32_t result_id : {32u, 27u, 29u, 39u}) {
     TransformationAddNoContractionDecoration transformation(result_id);
     ASSERT_TRUE(
         transformation.IsApplicable(context.get(), transformation_context));
@@ -134,8 +132,6 @@ TEST(TransformationAddNoContractionDecorationTest, BasicScenarios) {
                OpName %10 "y"
                OpName %14 "i"
                OpDecorate %32 NoContraction
-               OpDecorate %32 NoContraction
-               OpDecorate %32 NoContraction
                OpDecorate %27 NoContraction
                OpDecorate %29 NoContraction
                OpDecorate %39 NoContraction
diff --git a/test/fuzz/transformation_add_relaxed_decoration_test.cpp b/test/fuzz/transformation_add_relaxed_decoration_test.cpp
index c4408827..979eeb72 100644
--- a/test/fuzz/transformation_add_relaxed_decoration_test.cpp
+++ b/test/fuzz/transformation_add_relaxed_decoration_test.cpp
@@ -86,9 +86,8 @@ TEST(TransformationAddRelaxedDecorationTest, BasicScenarios) {
   // Invalid: 28 is in a dead block, but returns bool (not numeric).
   ASSERT_FALSE(TransformationAddRelaxedDecoration(28).IsApplicable(
       context.get(), transformation_context));
-  // It is valid to add RelaxedPrecision to 25 (and it's fine to
-  // have a duplicate).
-  for (uint32_t result_id : {25u, 25u}) {
+  // It is valid to add RelaxedPrecision to 25
+  for (uint32_t result_id : {25u}) {
     TransformationAddRelaxedDecoration transformation(result_id);
     ASSERT_TRUE(
         transformation.IsApplicable(context.get(), transformation_context));
@@ -110,7 +109,6 @@ TEST(TransformationAddRelaxedDecorationTest, BasicScenarios) {
                OpName %10 "b"
                OpName %14 "c"
                OpDecorate %25 RelaxedPrecision
-               OpDecorate %25 RelaxedPrecision
           %2 = OpTypeVoid
           %3 = OpTypeFunction %2
           %6 = OpTypeInt 32 1
diff --git a/test/hex_to_text_test.cpp b/test/hex_to_text_test.cpp
new file mode 100644
index 00000000..cc5c673f
--- /dev/null
+++ b/test/hex_to_text_test.cpp
@@ -0,0 +1,429 @@
+// Copyright (c) 2024 Google LLC.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <vector>
+
+#include "gmock/gmock.h"
+#include "test/test_fixture.h"
+#include "tools/io.h"
+
+namespace spvtools {
+namespace {
+
+using spvtest::ScopedContext;
+
+class HexToText : public ::testing::Test {
+ public:
+  void VerifyDisassembly(const char* hex_stream,
+                         const char* expected_disassembly) {
+    std::vector<char> stream(hex_stream, hex_stream + strlen(hex_stream));
+    std::vector<uint32_t> binary;
+
+    // Convert hext to binary first.
+    EXPECT_TRUE(ConvertHexToBinary(stream, &binary));
+
+    // Then disassemble it.
+    spv_diagnostic diagnostic = nullptr;
+    spv_text disassembly = nullptr;
+    EXPECT_EQ(spvBinaryToText(ScopedContext().context, binary.data(),
+                              binary.size(), SPV_BINARY_TO_TEXT_OPTION_NONE,
+                              &disassembly, &diagnostic),
+              SPV_SUCCESS);
+    EXPECT_EQ(diagnostic, nullptr);
+
+    // Verify disassembly is as expected and clean up.
+    EXPECT_STREQ(disassembly->str, expected_disassembly);
+
+    spvDiagnosticDestroy(diagnostic);
+    spvTextDestroy(disassembly);
+  }
+
+  void EnsureError(const char* hex_stream) {
+    std::vector<char> stream(hex_stream, hex_stream + strlen(hex_stream));
+    std::vector<uint32_t> binary;
+
+    // Make sure there is a parse error
+    EXPECT_FALSE(ConvertHexToBinary(stream, &binary));
+  }
+};
+
+// The actual assembly doesn't matter, just the hex parsing.  All the tests use
+// the following SPIR-V.
+constexpr char kDisassembly[] = R"(; SPIR-V
+; Version: 1.6
+; Generator: Khronos SPIR-V Tools Assembler; 0
+; Bound: 11
+; Schema: 0
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint Vertex %1 "main" %2 %3
+OpName %2 "fancy_attribute"
+OpName %3 "useful_output"
+OpDecorate %2 Location 4
+OpDecorate %3 Location 2
+%4 = OpTypeFloat 32
+%5 = OpTypePointer Input %4
+%2 = OpVariable %5 Input
+%6 = OpTypePointer Output %4
+%3 = OpVariable %6 Output
+%7 = OpTypeVoid
+%8 = OpTypeFunction %7
+%1 = OpFunction %7 None %8
+%9 = OpLabel
+%10 = OpLoad %4 %2
+OpStore %3 %10
+OpReturn
+OpFunctionEnd
+)";
+
+TEST_F(HexToText, Words) {
+  constexpr char kHex[] = R"(0x07230203, 0x00010600, 0x00070000, 0x0000000b
+0x00000000, 0x00020011, 0x00000001, 0x0003000e
+0x00000000, 0x00000001, 0x0007000f, 0x00000000
+0x00000001, 0x6e69616d, 0x00000000, 0x00000002
+0x00000003, 0x00060005, 0x00000002, 0x636e6166
+0x74615f79, 0x62697274, 0x00657475, 0x00060005
+0x00000003, 0x66657375, 0x6f5f6c75, 0x75707475
+0x00000074, 0x00040047, 0x00000002, 0x0000001e
+0x00000004, 0x00040047, 0x00000003, 0x0000001e
+0x00000002, 0x00030016, 0x00000004, 0x00000020
+0x00040020, 0x00000005, 0x00000001, 0x00000004
+0x0004003b, 0x00000005, 0x00000002, 0x00000001
+0x00040020, 0x00000006, 0x00000003, 0x00000004
+0x0004003b, 0x00000006, 0x00000003, 0x00000003
+0x00020013, 0x00000007, 0x00030021, 0x00000008
+0x00000007, 0x00050036, 0x00000007, 0x00000001
+0x00000000, 0x00000008, 0x000200f8, 0x00000009
+0x0004003d, 0x00000004, 0x0000000a, 0x00000002
+0x0003003e, 0x00000003, 0x0000000a, 0x000100fd
+0x00010038)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, WordsLeadingSpace) {
+  constexpr char kHex[] = R"(    
+x07230203, x00010600, x00070000, x0000000b
+x00000000, x00020011, x00000001, x0003000e
+x00000000, x00000001, x0007000f, x00000000
+x00000001, x6e69616d, x00000000, x00000002
+x00000003, x00060005, x00000002, x636e6166
+x74615f79, x62697274, x00657475, x00060005
+x00000003, x66657375, x6f5f6c75, x75707475
+x00000074, x00040047, x00000002, x0000001e
+x00000004, x00040047, x00000003, x0000001e
+x00000002, x00030016, x00000004, x00000020
+x00040020, x00000005, x00000001, x00000004
+x0004003b, x00000005, x00000002, x00000001
+x00040020, x00000006, x00000003, x00000004
+x0004003b, x00000006, x00000003, x00000003
+x00020013, x00000007, x00030021, x00000008
+x00000007, x00050036, x00000007, x00000001
+x00000000, x00000008, x000200f8, x00000009
+x0004003d, x00000004, x0000000a, x00000002
+x0003003e, x00000003, x0000000a, x000100fd
+x00010038)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, WordsTrailingSpace) {
+  constexpr char kHex[] = R"(0X7230203, 0X10600, 0X70000, 0XB
+0X0, 0X20011, 0X1, 0X3000E
+0X0, 0X1, 0X7000F, 0X0
+0X1, X6E69616D, 0X0, 0X2
+0X3, 0X60005, 0X2, X636E6166
+X74615F79, X62697274, 0X657475, 0X60005
+0X3, X66657375, X6F5F6C75, X75707475
+0X74, 0X40047, 0X2, 0X1E
+0X4, 0X40047, 0X3, 0X1E
+0X2, 0X30016, 0X4, 0X20
+0X40020, 0X5, 0X1, 0X4
+0X4003B, 0X5, 0X2, 0X1
+0X40020, 0X6, 0X3, 0X4
+0X4003B, 0X6, 0X3, 0X3
+0X20013, 0X7, 0X30021, 0X8
+0X7, 0X50036, 0X7, 0X1
+0X0, 0X8, 0X200F8, 0X9
+0X4003D, 0X4, 0XA, 0X2
+0X3003E, 0X3, 0XA, 0X100FD
+0X10038     
+
+)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, BytesLittleEndian) {
+  constexpr char kHex[] = R"(
+0x03  0x02  0x23  0x07  0x00  0x06  0x01  0x00  0x00  0x00  0x07  0x00  0x0b  0x00  0x00  0x00
+0x00  0x00  0x00  0x00  0x11  0x00  0x02  0x00  0x01  0x00  0x00  0x00  0x0e  0x00  0x03  0x00
+0x00  0x00  0x00  0x00  0x01  0x00  0x00  0x00  0x0f  0x00  0x07  0x00  0x00  0x00  0x00  0x00
+0x01  0x00  0x00  0x00  0x6d  0x61  0x69  0x6e  0x00  0x00  0x00  0x00  0x02  0x00  0x00  0x00
+0x03  0x00  0x00  0x00  0x05  0x00  0x06  0x00  0x02  0x00  0x00  0x00  0x66  0x61  0x6e  0x63
+0x79  0x5f  0x61  0x74  0x74  0x72  0x69  0x62  0x75  0x74  0x65  0x00  0x05  0x00  0x06  0x00
+0x03  0x00  0x00  0x00  0x75  0x73  0x65  0x66  0x75  0x6c  0x5f  0x6f  0x75  0x74  0x70  0x75
+0x74  0x00  0x00  0x00  0x47  0x00  0x04  0x00  0x02  0x00  0x00  0x00  0x1e  0x00  0x00  0x00
+0x04  0x00  0x00  0x00  0x47  0x00  0x04  0x00  0x03  0x00  0x00  0x00  0x1e  0x00  0x00  0x00
+0x02  0x00  0x00  0x00  0x16  0x00  0x03  0x00  0x04  0x00  0x00  0x00  0x20  0x00  0x00  0x00
+0x20  0x00  0x04  0x00  0x05  0x00  0x00  0x00  0x01  0x00  0x00  0x00  0x04  0x00  0x00  0x00
+0x3b  0x00  0x04  0x00  0x05  0x00  0x00  0x00  0x02  0x00  0x00  0x00  0x01  0x00  0x00  0x00
+0x20  0x00  0x04  0x00  0x06  0x00  0x00  0x00  0x03  0x00  0x00  0x00  0x04  0x00  0x00  0x00
+0x3b  0x00  0x04  0x00  0x06  0x00  0x00  0x00  0x03  0x00  0x00  0x00  0x03  0x00  0x00  0x00
+0x13  0x00  0x02  0x00  0x07  0x00  0x00  0x00  0x21  0x00  0x03  0x00  0x08  0x00  0x00  0x00
+0x07  0x00  0x00  0x00  0x36  0x00  0x05  0x00  0x07  0x00  0x00  0x00  0x01  0x00  0x00  0x00
+0x00  0x00  0x00  0x00  0x08  0x00  0x00  0x00  0xf8  0x00  0x02  0x00  0x09  0x00  0x00  0x00
+0x3d  0x00  0x04  0x00  0x04  0x00  0x00  0x00  0x0a  0x00  0x00  0x00  0x02  0x00  0x00  0x00
+0x3e  0x00  0x03  0x00  0x03  0x00  0x00  0x00  0x0a  0x00  0x00  0x00  0xfd  0x00  0x01  0x00
+0x38  0x00  0x01  0x00
+)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, BytesBigEndian) {
+  constexpr char kHex[] = R"(
+X07,X23,X02,X03, X00,X01,X06,X00, X00,X07,X00,X00, X00,X00,X00,X0B
+X00,X00,X00,X00, X00,X02,X00,X11, X00,X00,X00,X01, X00,X03,X00,X0E
+X00,X00,X00,X00, X00,X00,X00,X01, X00,X07,X00,X0F, X00,X00,X00,X00
+X00,X00,X00,X01, X6E,X69,X61,X6D, X00,X00,X00,X00, X00,X00,X00,X02
+X00,X00,X00,X03, X00,X06,X00,X05, X00,X00,X00,X02, X63,X6E,X61,X66
+X74,X61,X5F,X79, X62,X69,X72,X74, X00,X65,X74,X75, X00,X06,X00,X05
+X00,X00,X00,X03, X66,X65,X73,X75, X6F,X5F,X6C,X75, X75,X70,X74,X75
+X00,X00,X00,X74, X00,X04,X00,X47, X00,X00,X00,X02, X00,X00,X00,X1E
+X00,X00,X00,X04, X00,X04,X00,X47, X00,X00,X00,X03, X00,X00,X00,X1E
+X00,X00,X00,X02, X00,X03,X00,X16, X00,X00,X00,X04, X00,X00,X00,X20
+X00,X04,X00,X20, X00,X00,X00,X05, X00,X00,X00,X01, X00,X00,X00,X04
+X00,X04,X00,X3B, X00,X00,X00,X05, X00,X00,X00,X02, X00,X00,X00,X01
+X00,X04,X00,X20, X00,X00,X00,X06, X00,X00,X00,X03, X00,X00,X00,X04
+X00,X04,X00,X3B, X00,X00,X00,X06, X00,X00,X00,X03, X00,X00,X00,X03
+X00,X02,X00,X13, X00,X00,X00,X07, X00,X03,X00,X21, X00,X00,X00,X08
+X00,X00,X00,X07, X00,X05,X00,X36, X00,X00,X00,X07, X00,X00,X00,X01
+X00,X00,X00,X00, X00,X00,X00,X08, X00,X02,X00,XF8, X00,X00,X00,X09
+X00,X04,X00,X3D, X00,X00,X00,X04, X00,X00,X00,X0A, X00,X00,X00,X02
+X00,X03,X00,X3E, X00,X00,X00,X03, X00,X00,X00,X0A, X00,X01,X00,XFD
+X00,X01,X00,X38,
+)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, StreamLittleEndian) {
+  constexpr char kHex[] = R"(
+03  02  23  07  00  06  01  00  00  00  07  00  0b  00  00  00
+00  00  00  00  11  00  02  00  01  00  00  00  0e  00  03  00
+00  00  00  00  01  00  00  00  0f  00  07  00  00  00  00  00
+01  00  00  00  6d  61  69  6e  00  00  00  00  02  00  00  00
+03  00  00  00  05  00  06  00  02  00  00  00  66  61  6e  63
+79  5f  61  74  74  72  69  62  75  74  65  00  05  00  06  00
+03  00  00  00  75  73  65  66  75  6c  5f  6f  75  74  70  75
+74  00  00  00  47  00  04  00  02  00  00  00  1e  00  00  00
+04  00  00  00  47  00  04  00  03  00  00  00  1e  00  00  00
+02  00  00  00  16  00  03  00  04  00  00  00  20  00  00  00
+20  00  04  00  05  00  00  00  01  00  00  00  04  00  00  00
+3b  00  04  00  05  00  00  00  02  00  00  00  01  00  00  00
+20  00  04  00  06  00  00  00  03  00  00  00  04  00  00  00
+3b  00  04  00  06  00  00  00  03  00  00  00  03  00  00  00
+13  00  02  00  07  00  00  00  21  00  03  00  08  00  00  00
+07  00  00  00  36  00  05  00  07  00  00  00  01  00  00  00
+00  00  00  00  08  00  00  00  f8  00  02  00  09  00  00  00
+3d  00  04  00  04  00  00  00  0a  00  00  00  02  00  00  00
+3e  00  03  00  03  00  00  00  0a  00  00  00  fd  00  01  00
+38  00  01  00
+)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, StreamLittleEndianNoDelim) {
+  constexpr char kHex[] = R"(
+0302230700060100000007000B000000
+0000000011000200010000000E000300
+00000000010000000F00070000000000
+010000006D61696E0000000002000000
+03000000050006000200000066616E63
+795F6174747269627574650005000600
+0300000075736566756C5F6F75747075
+7400000047000400020000001E000000
+0400000047000400030000001E000000
+02000000160003000400000020000000
+20000400050000000100000004000000
+3B000400050000000200000001000000
+20000400060000000300000004000000
+3B000400060000000300000003000000
+13000200070000002100030008000000
+07000000360005000700000001000000
+0000000008000000F800020009000000
+3D000400040000000A00000002000000
+3E000300030000000A000000FD000100
+38000100
+)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, StreamBigEndian) {
+  constexpr char kHex[] = R"(
+07230203, 00010600, 00070000, 0000000b
+00000000, 00020011, 00000001, 0003000e
+00000000, 00000001, 0007000f, 00000000
+00000001, 6e69616d, 00000000, 00000002
+00000003, 00060005, 00000002, 636e6166
+74615f79, 62697274, 00657475, 00060005
+00000003, 66657375, 6f5f6c75, 75707475
+00000074, 00040047, 00000002, 0000001e
+00000004, 00040047, 00000003, 0000001e
+00000002, 00030016, 00000004, 00000020
+00040020, 00000005, 00000001, 00000004
+0004003b, 00000005, 00000002, 00000001
+00040020, 00000006, 00000003, 00000004
+0004003b, 00000006, 00000003, 00000003
+00020013, 00000007, 00030021, 00000008
+00000007, 00050036, 00000007, 00000001
+00000000, 00000008, 000200f8, 00000009
+0004003d, 00000004, 0000000a, 00000002
+0003003e, 00000003, 0000000a, 000100fd
+00010038,
+)";
+
+  VerifyDisassembly(kHex, kDisassembly);
+}
+
+TEST_F(HexToText, WordsNoDelimieter) {
+  constexpr char kHex[] = R"(0x07230203 0x00010600 0x00070000 0x0000000b
+0x00000000 0x00020011 0x00000001 0x0003000e
+0x00000000 0x00000001 0x0007000f 0x00000000
+0x00000001 0x6e69616d 0x00000000 0x00000002
+0x00000003 0x00060005 0x00000002 0x636e6166
+0x74615f79 0x62697274 0x00657475 0x00060005
+0x00000003 0x666573750x6f5f6c75 0x75707475
+0x00000074 0x00040047 0x00000002 0x0000001e
+0x00000004 0x00040047 0x00000003 0x0000001e
+0x00000002 0x00030016 0x00000004 0x00000020
+0x00040020 0x00000005 0x00000001 0x00000004
+0x0004003b 0x00000005 0x00000002 0x00000001
+0x00040020 0x00000006 0x00000003 0x00000004
+0x0004003b 0x00000006 0x00000003 0x00000003
+0x00020013 0x00000007 0x00030021 0x00000008
+0x00000007 0x00050036 0x00000007 0x00000001
+0x00000000 0x00000008 0x000200f8 0x00000009
+0x0004003d 0x00000004 0x0000000a 0x00000002
+0x0003003e 0x00000003 0x0000000a 0x000100fd
+0x00010038)";
+
+  EnsureError(kHex);
+}
+
+TEST_F(HexToText, InvalidFirstToken) {
+  constexpr char kHex[] = R"(0x17230203, 0x00010600, 0x00070000, 0x0000000b
+0x00000000, 0x00020011, 0x00000001, 0x0003000e
+0x00000000, 0x00000001, 0x0007000f, 0x00000000
+0x00000001, 0x6e69616d, 0x00000000, 0x00000002
+0x00000003, 0x00060005, 0x00000002, 0x636e6166
+0x74615f79, 0x62697274, 0x00657475, 0x00060005
+0x00000003, 0x66657375, 0x6f5f6c75, 0x75707475
+0x00000074, 0x00040047, 0x00000002, 0x0000001e
+0x00000004, 0x00040047, 0x00000003, 0x0000001e
+0x00000002, 0x00030016, 0x00000004, 0x00000020
+0x00040020, 0x00000005, 0x00000001, 0x00000004
+0x0004003b, 0x00000005, 0x00000002, 0x00000001
+0x00040020, 0x00000006, 0x00000003, 0x00000004
+0x0004003b, 0x00000006, 0x00000003, 0x00000003
+0x00020013, 0x00000007, 0x00030021, 0x00000008
+0x00000007, 0x00050036, 0x00000007, 0x00000001
+0x00000000, 0x00000008, 0x000200f8, 0x00000009
+0x0004003d, 0x00000004, 0x0000000a, 0x00000002
+0x0003003e, 0x00000003, 0x0000000a, 0x000100fd
+0x00010038)";
+
+  EnsureError(kHex);
+}
+
+TEST_F(HexToText, NonHexCharacter) {
+  // Note: a 6 is replaced with G in this stream
+  constexpr char kHex[] = R"(0x07230203, 0x00010600, 0x00070000, 0x0000000b
+0x00000000, 0x00020011, 0x00000001, 0x0003000e
+0x00000000, 0x00000001, 0x0007000f, 0x00000000
+0x00000001, 0x6e69616d, 0x00000000, 0x00000002
+0x00000003, 0x00060005, 0x00000002, 0x636e6166
+0x74615f79, 0x62697274, 0x00657475, 0x00060005
+0x00000003, 0x66657375, 0x6f5f6c75, 0x75707475
+0x00000074, 0x00040047, 0x00000002, 0x0000001e
+0x00000004, 0x00040047, 0x00000003, 0x0000001e
+0x00000002, 0x0003001G, 0x00000004, 0x00000020
+0x00040020, 0x00000005, 0x00000001, 0x00000004
+0x0004003b, 0x00000005, 0x00000002, 0x00000001
+0x00040020, 0x00000006, 0x00000003, 0x00000004
+0x0004003b, 0x00000006, 0x00000003, 0x00000003
+0x00020013, 0x00000007, 0x00030021, 0x00000008
+0x00000007, 0x00050036, 0x00000007, 0x00000001
+0x00000000, 0x00000008, 0x000200f8, 0x00000009
+0x0004003d, 0x00000004, 0x0000000a, 0x00000002
+0x0003003e, 0x00000003, 0x0000000a, 0x000100fd
+0x00010038)";
+
+  EnsureError(kHex);
+}
+
+TEST_F(HexToText, MissingExpectedPrefix) {
+  constexpr char kHex[] = R"(0x07230203, 0x00010600, 0x00070000, 0x0000000b
+0x00000000, 0x00020011, 0x00000001, 0x0003000e
+0x00000000, 0x00000001, 0x0007000f, 0x00000000
+0x00000001, 0x6e69616d, 0x00000000, 0x00000002
+0x00000003, 0x00060005, 0x00000002, 0x636e6166
+0x74615f79, 0x62697274, 0x00657475, 0x00060005
+0x00000003, 0x66657375, 0x6f5f6c75, 0x75707475
+0x00000074, 0x00040047, 0x00000002, 0x0000001e
+0x00000004, 0x00040047, 0x00000003, 0x0000001e
+0x00000002, 0x00030016, 0x00000004, 0x00000020
+0x00040020, 0x00000005,   00000001, 0x00000004
+0x0004003b, 0x00000005, 0x00000002, 0x00000001
+0x00040020, 0x00000006, 0x00000003, 0x00000004
+0x0004003b, 0x00000006, 0x00000003, 0x00000003
+0x00020013, 0x00000007, 0x00030021, 0x00000008
+0x00000007, 0x00050036, 0x00000007, 0x00000001
+0x00000000, 0x00000008, 0x000200f8, 0x00000009
+0x0004003d, 0x00000004, 0x0000000a, 0x00000002
+0x0003003e, 0x00000003, 0x0000000a, 0x000100fd
+0x00010038)";
+
+  EnsureError(kHex);
+}
+
+TEST_F(HexToText, UnexpectedPrefix) {
+  constexpr char kHex[] = R"(07230203, 00010600, 00070000, 0000000b
+00000000, 00020011, 00000001, 0003000e
+00000000, 00000001, 0007000f, 00000000
+00000001, 6e69616d, 00000000, 00000002
+00000003, 00060005, 00000002, 636e6166
+74615f79, 62697274, 00657475, 00060005
+00000003, 66657375, 6f5f6c75, 75707475
+00000074, 00040047, 00000002, 0000001e
+00000004, 00040047, 00000003, 0000001e
+00000002, 00030016, 00000004, 00000020
+00040020, 00000005, 0x00000001, 00000004
+0004003b, 00000005, 00000002, 00000001
+00040020, 00000006, 00000003, 00000004
+0004003b, 00000006, 00000003, 00000003
+00020013, 00000007, 00030021, 00000008
+00000007, 00050036, 00000007, 00000001
+00000000, 00000008, 000200f8, 00000009
+0004003d, 00000004, 0000000a, 00000002
+0003003e, 00000003, 0000000a, 000100fd
+00010038)";
+
+  EnsureError(kHex);
+}
+}  // namespace
+}  // namespace spvtools
diff --git a/test/immediate_int_test.cpp b/test/immediate_int_test.cpp
index 8e7a8fd3..44f96e21 100644
--- a/test/immediate_int_test.cpp
+++ b/test/immediate_int_test.cpp
@@ -136,19 +136,25 @@ TEST_F(ImmediateIntTest, IntegerFollowingImmediate) {
 }
 
 // Literal floats after !<integer> are handled correctly.
+// Insert OpNop to avoid reading the immediate value as the extra FP encoding
+// operand to OpTypeFloat.
 TEST_F(ImmediateIntTest, FloatFollowingImmediate) {
-  EXPECT_EQ(
-      CompiledInstructions("%1 = OpTypeFloat 32\n%2 = OpConstant %1 0.123"),
-      CompiledInstructions("%1 = OpTypeFloat 32\n!0x0004002b %1 !2 0.123"));
-  EXPECT_EQ(
-      CompiledInstructions("%1 = OpTypeFloat 32\n%2 = OpConstant %1 -0.5"),
-      CompiledInstructions("%1 = OpTypeFloat 32\n!0x0004002b %1 !2 -0.5"));
-  EXPECT_EQ(
-      CompiledInstructions("%1 = OpTypeFloat 32\n%2 = OpConstant %1 0.123"),
-      CompiledInstructions("%1 = OpTypeFloat 32\n!0x0004002b %1 %2 0.123"));
-  EXPECT_EQ(
-      CompiledInstructions("%1 = OpTypeFloat 32\n%2 = OpConstant  %1 -0.5"),
-      CompiledInstructions("%1 = OpTypeFloat 32\n!0x0004002b %1 %2 -0.5"));
+  EXPECT_EQ(CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop %2 = OpConstant %1 0.123"),
+            CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop !0x0004002b %1 !2 0.123"));
+  EXPECT_EQ(CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop %2 = OpConstant %1 -0.5"),
+            CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop !0x0004002b %1 !2 -0.5"));
+  EXPECT_EQ(CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop %2 = OpConstant %1 0.123"),
+            CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop !0x0004002b %1 %2 0.123"));
+  EXPECT_EQ(CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop %2 = OpConstant  %1 -0.5"),
+            CompiledInstructions(
+                "%1 = OpTypeFloat 32\nOpNop !0x0004002b %1 %2 -0.5"));
 
   EXPECT_EQ(Concatenate({
                 MakeInstruction(spv::Op::OpTypeInt, {1, 64, 0}),
@@ -203,9 +209,9 @@ TEST_F(ImmediateIntTest, InvalidStatement) {
 
 TEST_F(ImmediateIntTest, InvalidStatementBetweenValidOnes) {
   EXPECT_THAT(Subvector(CompileSuccessfully(
-                            "%10 = OpTypeFloat 32 !5 !6 !7 OpEmitVertex"),
+                            "%10 = OpTypeInt 32 0 !5 !6 !7 OpEmitVertex"),
                         kFirstInstruction),
-              ElementsAre(spvOpcodeMake(3, spv::Op::OpTypeFloat), 1, 32, 5, 6,
+              ElementsAre(spvOpcodeMake(4, spv::Op::OpTypeInt), 1, 32, 0, 5, 6,
                           7, spvOpcodeMake(1, spv::Op::OpEmitVertex)));
 }
 
diff --git a/test/link/matching_imports_to_exports_test.cpp b/test/link/matching_imports_to_exports_test.cpp
index 6b02fc46..c7c962fa 100644
--- a/test/link/matching_imports_to_exports_test.cpp
+++ b/test/link/matching_imports_to_exports_test.cpp
@@ -174,14 +174,18 @@ OpDecorate %1 LinkageAttributes "foo" Export
 %1 = OpVariable %2 Uniform %3
 )";
 
-  spvtest::Binary linked_binary;
-  EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
-            AssembleAndLink({body1, body2}, &linked_binary))
-      << GetErrorMessage();
-  EXPECT_THAT(
-      GetErrorMessage(),
-      HasSubstr("Type mismatch on symbol \"foo\" between imported "
-                "variable/function %1 and exported variable/function %4"));
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
+              AssembleAndLink({body1, body2}, &linked_binary))
+        << GetErrorMessage();
+    EXPECT_THAT(
+        GetErrorMessage(),
+        HasSubstr("Type mismatch on symbol \"foo\" between imported "
+                  "variable/function %1 and exported variable/function %4"));
+  }
 }
 
 TEST_F(MatchingImportsToExports, MultipleDefinitions) {
@@ -216,13 +220,17 @@ OpDecorate %1 LinkageAttributes "foo" Export
 %1 = OpVariable %2 Uniform %3
 )";
 
-  spvtest::Binary linked_binary;
-  EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
-            AssembleAndLink({body1, body2, body3}, &linked_binary))
-      << GetErrorMessage();
-  EXPECT_THAT(GetErrorMessage(),
-              HasSubstr("Too many external references, 2, were found "
-                        "for \"foo\"."));
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
+              AssembleAndLink({body1, body2, body3}, &linked_binary))
+        << GetErrorMessage();
+    EXPECT_THAT(GetErrorMessage(),
+                HasSubstr("Too many external references, 2, were found "
+                          "for \"foo\"."));
+  }
 }
 
 TEST_F(MatchingImportsToExports, SameNameDifferentTypes) {
@@ -289,14 +297,18 @@ OpDecorate %1 LinkageAttributes "foo" Export
 %1 = OpVariable %2 Uniform %3
 )";
 
-  spvtest::Binary linked_binary;
-  EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
-            AssembleAndLink({body1, body2}, &linked_binary))
-      << GetErrorMessage();
-  EXPECT_THAT(
-      GetErrorMessage(),
-      HasSubstr("Type mismatch on symbol \"foo\" between imported "
-                "variable/function %1 and exported variable/function %4"));
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
+              AssembleAndLink({body1, body2}, &linked_binary))
+        << GetErrorMessage();
+    EXPECT_THAT(
+        GetErrorMessage(),
+        HasSubstr("Type mismatch on symbol \"foo\" between imported "
+                  "variable/function %1 and exported variable/function %4"));
+  }
 }
 
 TEST_F(MatchingImportsToExports,
@@ -557,5 +569,340 @@ OpFunctionEnd
   EXPECT_EQ(expected_res, res_body);
 }
 
+TEST_F(MatchingImportsToExports, FunctionCall) {
+  const std::string body1 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %3 "param"
+OpDecorate %1 LinkageAttributes "foo" Import
+ %5 = OpTypeVoid
+ %6 = OpTypeInt 32 0
+ %9 = OpTypePointer Function %6
+ %7 = OpTypeFunction %5 %9
+ %1 = OpFunction %5 None %7
+ %3 = OpFunctionParameter %9
+OpFunctionEnd
+ %8 = OpFunction %5 None %7
+ %4 = OpFunctionParameter %9
+%10 = OpLabel
+%11 = OpFunctionCall %5 %1 %4
+OpReturn
+OpFunctionEnd
+)";
+  const std::string body2 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpDecorate %1 LinkageAttributes "foo" Export
+%3 = OpTypeVoid
+%4 = OpTypeInt 32 0
+%7 = OpTypePointer Function %4
+%5 = OpTypeFunction %3 %7
+%1 = OpFunction %3 None %5
+%2 = OpFunctionParameter %7
+%6 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    ASSERT_EQ(SPV_SUCCESS,
+              AssembleAndLink({body1, body2}, &linked_binary, options))
+        << GetErrorMessage();
+
+    const std::string expected_res = R"(OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpModuleProcessed "Linked by SPIR-V Tools Linker"
+%3 = OpTypeVoid
+%4 = OpTypeInt 32 0
+%5 = OpTypePointer Function %4
+%6 = OpTypeFunction %3 %5
+%7 = OpFunction %3 None %6
+%8 = OpFunctionParameter %5
+%9 = OpLabel
+%10 = OpFunctionCall %3 %1 %8
+OpReturn
+OpFunctionEnd
+%1 = OpFunction %3 None %6
+%2 = OpFunctionParameter %5
+%11 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+    std::string res_body;
+    SetDisassembleOptions(SPV_BINARY_TO_TEXT_OPTION_NO_HEADER);
+    ASSERT_EQ(SPV_SUCCESS, Disassemble(linked_binary, &res_body))
+        << GetErrorMessage();
+    EXPECT_EQ(expected_res, res_body);
+  }
+}
+
+TEST_F(MatchingImportsToExports, FunctionSignatureMismatchPointer) {
+  const std::string body1 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %3 "param"
+OpDecorate %1 LinkageAttributes "foo" Import
+ %5 = OpTypeVoid
+ %6 = OpTypeInt 8 0
+ %9 = OpTypePointer Function %6
+ %7 = OpTypeFunction %5 %9
+ %1 = OpFunction %5 None %7
+ %3 = OpFunctionParameter %9
+OpFunctionEnd
+ %8 = OpFunction %5 None %7
+ %4 = OpFunctionParameter %9
+%10 = OpLabel
+%11 = OpFunctionCall %5 %1 %4
+OpReturn
+OpFunctionEnd
+)";
+  const std::string body2 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpDecorate %1 LinkageAttributes "foo" Export
+%3 = OpTypeVoid
+%4 = OpTypeInt 32 0
+%7 = OpTypePointer Function %4
+%5 = OpTypeFunction %3 %7
+%1 = OpFunction %3 None %5
+%2 = OpFunctionParameter %7
+%6 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  spvtest::Binary linked_binary;
+  ASSERT_EQ(SPV_ERROR_INVALID_BINARY,
+            AssembleAndLink({body1, body2}, &linked_binary))
+      << GetErrorMessage();
+  EXPECT_THAT(
+      GetErrorMessage(),
+      HasSubstr("Type mismatch on symbol \"foo\" between imported "
+                "variable/function %1 and exported variable/function %11"));
+
+  LinkerOptions options;
+  options.SetAllowPtrTypeMismatch(true);
+  ASSERT_EQ(SPV_SUCCESS,
+            AssembleAndLink({body1, body2}, &linked_binary, options))
+      << GetErrorMessage();
+
+  const std::string expected_res = R"(OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpModuleProcessed "Linked by SPIR-V Tools Linker"
+%3 = OpTypeVoid
+%4 = OpTypeInt 8 0
+%5 = OpTypePointer Function %4
+%6 = OpTypeFunction %3 %5
+%7 = OpTypeInt 32 0
+%8 = OpTypePointer Function %7
+%9 = OpTypeFunction %3 %8
+%10 = OpFunction %3 None %6
+%11 = OpFunctionParameter %5
+%12 = OpLabel
+%13 = OpBitcast %8 %11
+%14 = OpFunctionCall %3 %1 %13
+OpReturn
+OpFunctionEnd
+%1 = OpFunction %3 None %9
+%2 = OpFunctionParameter %8
+%15 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+  std::string res_body;
+  SetDisassembleOptions(SPV_BINARY_TO_TEXT_OPTION_NO_HEADER);
+  ASSERT_EQ(SPV_SUCCESS, Disassemble(linked_binary, &res_body))
+      << GetErrorMessage();
+  EXPECT_EQ(expected_res, res_body);
+}
+
+TEST_F(MatchingImportsToExports, FunctionSignatureMismatchValue) {
+  const std::string body1 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %3 "param"
+OpDecorate %1 LinkageAttributes "foo" Import
+ %5 = OpTypeVoid
+ %6 = OpTypeInt 8 0
+ %7 = OpTypeFunction %5 %6
+ %1 = OpFunction %5 None %7
+ %3 = OpFunctionParameter %6
+OpFunctionEnd
+ %8 = OpFunction %5 None %7
+ %4 = OpFunctionParameter %6
+%10 = OpLabel
+%11 = OpFunctionCall %5 %1 %4
+OpReturn
+OpFunctionEnd
+)";
+  const std::string body2 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpDecorate %1 LinkageAttributes "foo" Export
+%3 = OpTypeVoid
+%4 = OpTypeInt 32 0
+%5 = OpTypeFunction %3 %4
+%1 = OpFunction %3 None %5
+%2 = OpFunctionParameter %4
+%6 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    ASSERT_EQ(SPV_ERROR_INVALID_BINARY,
+              AssembleAndLink({body1, body2}, &linked_binary))
+        << GetErrorMessage();
+    EXPECT_THAT(
+        GetErrorMessage(),
+        HasSubstr("Type mismatch on symbol \"foo\" between imported "
+                  "variable/function %1 and exported variable/function %10"));
+  }
+}
+
+TEST_F(MatchingImportsToExports, FunctionSignatureMismatchTypePointerInt) {
+  const std::string body1 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %3 "param"
+OpDecorate %1 LinkageAttributes "foo" Import
+ %5 = OpTypeVoid
+ %6 = OpTypeInt 64 0
+ %7 = OpTypeFunction %5 %6
+ %1 = OpFunction %5 None %7
+ %3 = OpFunctionParameter %6
+OpFunctionEnd
+ %8 = OpFunction %5 None %7
+ %4 = OpFunctionParameter %6
+%10 = OpLabel
+%11 = OpFunctionCall %5 %1 %4
+OpReturn
+OpFunctionEnd
+)";
+  const std::string body2 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpDecorate %1 LinkageAttributes "foo" Export
+%3 = OpTypeVoid
+%4 = OpTypeInt 64 0
+%7 = OpTypePointer Function %4
+%5 = OpTypeFunction %3 %7
+%1 = OpFunction %3 None %5
+%2 = OpFunctionParameter %7
+%6 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    ASSERT_EQ(SPV_ERROR_INVALID_BINARY,
+              AssembleAndLink({body1, body2}, &linked_binary))
+        << GetErrorMessage();
+    EXPECT_THAT(
+        GetErrorMessage(),
+        HasSubstr("Type mismatch on symbol \"foo\" between imported "
+                  "variable/function %1 and exported variable/function %10"));
+  }
+}
+
+TEST_F(MatchingImportsToExports, FunctionSignatureMismatchTypeIntPointer) {
+  const std::string body1 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %3 "param"
+OpDecorate %1 LinkageAttributes "foo" Import
+ %5 = OpTypeVoid
+ %6 = OpTypeInt 64 0
+ %9 = OpTypePointer Function %6
+ %7 = OpTypeFunction %5 %9
+ %1 = OpFunction %5 None %7
+ %3 = OpFunctionParameter %9
+OpFunctionEnd
+ %8 = OpFunction %5 None %7
+ %4 = OpFunctionParameter %9
+%10 = OpLabel
+%11 = OpFunctionCall %5 %1 %4
+OpReturn
+OpFunctionEnd
+)";
+  const std::string body2 = R"(
+OpCapability Linkage
+OpCapability Addresses
+OpCapability Kernel
+OpMemoryModel Physical64 OpenCL
+OpName %1 "foo"
+OpName %2 "param"
+OpDecorate %1 LinkageAttributes "foo" Export
+%3 = OpTypeVoid
+%4 = OpTypeInt 64 0
+%5 = OpTypeFunction %3 %4
+%1 = OpFunction %3 None %5
+%2 = OpFunctionParameter %4
+%6 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  LinkerOptions options;
+  for (int i = 0; i < 2; i++) {
+    spvtest::Binary linked_binary;
+    options.SetAllowPtrTypeMismatch(i == 1);
+    ASSERT_EQ(SPV_ERROR_INVALID_BINARY,
+              AssembleAndLink({body1, body2}, &linked_binary))
+        << GetErrorMessage();
+    EXPECT_THAT(
+        GetErrorMessage(),
+        HasSubstr("Type mismatch on symbol \"foo\" between imported "
+                  "variable/function %1 and exported variable/function %11"));
+  }
+}
+
 }  // namespace
 }  // namespace spvtools
diff --git a/test/opcode_require_capabilities_test.cpp b/test/opcode_require_capabilities_test.cpp
index 37097c6f..615c0942 100644
--- a/test/opcode_require_capabilities_test.cpp
+++ b/test/opcode_require_capabilities_test.cpp
@@ -61,8 +61,33 @@ INSTANTIATE_TEST_SUITE_P(
         ExpectedOpCodeCapabilities{
             spv::Op::OpImageSparseSampleImplicitLod,
             CapabilitySet{spv::Capability::SparseResidency}},
-        ExpectedOpCodeCapabilities{spv::Op::OpCopyMemorySized,
-                                   CapabilitySet{spv::Capability::Addresses}},
+        ExpectedOpCodeCapabilities{
+            spv::Op::OpCopyMemorySized,
+            CapabilitySet{spv::Capability::Addresses,
+                          spv::Capability::UntypedPointersKHR}},
+        ExpectedOpCodeCapabilities{spv::Op::OpArrayLength,
+                                   CapabilitySet{spv::Capability::Shader}},
+        ExpectedOpCodeCapabilities{spv::Op::OpFunction, CapabilitySet()},
+        ExpectedOpCodeCapabilities{spv::Op::OpConvertFToS, CapabilitySet()},
+        ExpectedOpCodeCapabilities{
+            spv::Op::OpEmitStreamVertex,
+            CapabilitySet{spv::Capability::GeometryStreams}},
+        ExpectedOpCodeCapabilities{
+            spv::Op::OpTypeNamedBarrier,
+            CapabilitySet{spv::Capability::NamedBarrier}},
+        ExpectedOpCodeCapabilities{
+            spv::Op::OpGetKernelMaxNumSubgroups,
+            CapabilitySet{spv::Capability::SubgroupDispatch}},
+        ExpectedOpCodeCapabilities{spv::Op::OpImageQuerySamples,
+                                   CapabilitySet{spv::Capability::Kernel,
+                                                 spv::Capability::ImageQuery}},
+        ExpectedOpCodeCapabilities{
+            spv::Op::OpImageSparseSampleImplicitLod,
+            CapabilitySet{spv::Capability::SparseResidency}},
+        ExpectedOpCodeCapabilities{
+            spv::Op::OpCopyMemorySized,
+            CapabilitySet{spv::Capability::Addresses,
+                          spv::Capability::UntypedPointersKHR}},
         ExpectedOpCodeCapabilities{spv::Op::OpArrayLength,
                                    CapabilitySet{spv::Capability::Shader}},
         ExpectedOpCodeCapabilities{spv::Op::OpFunction, CapabilitySet()},
diff --git a/test/opt/CMakeLists.txt b/test/opt/CMakeLists.txt
index 92d266bb..4ef119de 100644
--- a/test/opt/CMakeLists.txt
+++ b/test/opt/CMakeLists.txt
@@ -60,9 +60,6 @@ add_spvtools_unittest(TARGET opt
        inline_opaque_test.cpp
        inline_test.cpp
        insert_extract_elim_test.cpp
-       inst_bindless_check_test.cpp
-       inst_buff_addr_check_test.cpp
-       inst_debug_printf_test.cpp
        instruction_list_test.cpp
        instruction_test.cpp
        interface_var_sroa_test.cpp
@@ -81,6 +78,7 @@ add_spvtools_unittest(TARGET opt
        modify_maximal_reconvergence_test.cpp
        module_test.cpp
        module_utils.h
+       opextinst_forward_ref_fixup_pass_test.cpp
        optimizer_test.cpp
        pass_manager_test.cpp
        pass_merge_return_test.cpp
@@ -105,6 +103,7 @@ add_spvtools_unittest(TARGET opt
        strip_debug_info_test.cpp
        strip_nonsemantic_info_test.cpp
        struct_cfg_analysis_test.cpp
+       struct_packing_test.cpp
        switch_descriptorset_test.cpp
        trim_capabilities_pass_test.cpp
        type_manager_test.cpp
diff --git a/test/opt/aggressive_dead_code_elim_test.cpp b/test/opt/aggressive_dead_code_elim_test.cpp
index 845c6a58..5b88117e 100644
--- a/test/opt/aggressive_dead_code_elim_test.cpp
+++ b/test/opt/aggressive_dead_code_elim_test.cpp
@@ -7568,7 +7568,7 @@ TEST_F(AggressiveDCETest, PreserveInterface) {
 OpExtension "SPV_KHR_ray_tracing"
 %1 = OpExtInstImport "GLSL.std.450"
 OpMemoryModel Logical GLSL450
-OpEntryPoint RayGenerationNV %2 "main" %3 %4
+OpEntryPoint RayGenerationKHR %2 "main" %3 %4
 OpDecorate %3 Location 0
 OpDecorate %4 DescriptorSet 2
 OpDecorate %4 Binding 0
@@ -7577,8 +7577,8 @@ OpDecorate %4 Binding 0
 %uint = OpTypeInt 32 0
 %uint_0 = OpConstant %uint 0
 %float = OpTypeFloat 32
-%_ptr_CallableDataNV_float = OpTypePointer CallableDataNV %float
-%3 = OpVariable %_ptr_CallableDataNV_float CallableDataNV
+%_ptr_CallableDataKHR_float = OpTypePointer CallableDataKHR %float
+%3 = OpVariable %_ptr_CallableDataKHR_float CallableDataKHR
 %13 = OpTypeAccelerationStructureKHR
 %_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
 %4 = OpVariable %_ptr_UniformConstant_13 UniformConstant
@@ -7992,6 +7992,247 @@ OpFunctionEnd
   SinglePassRunAndCheck<AggressiveDCEPass>(test, test, true, true);
 }
 
+TEST_F(AggressiveDCETest, StoringAPointer) {
+  // A store that stores a pointer should not be kept live because the value
+  // being stored is eventually loaded from.
+
+  const std::string text = R"(
+               OpCapability CooperativeMatrixKHR
+               OpCapability Shader
+               OpExtension "SPV_KHR_cooperative_matrix"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %1 "main" %2
+               OpExecutionMode %1 LocalSize 64 1 1
+               OpSource HLSL 600
+               OpDecorate %2 DescriptorSet 0
+               OpDecorate %2 Binding 0
+               OpDecorate %_runtimearr_int ArrayStride 4
+               OpMemberDecorate %_struct_4 0 Offset 0
+               OpDecorate %_struct_4 Block
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+      %int_1 = OpConstant %int 1
+       %uint = OpTypeInt 32 0
+     %uint_0 = OpConstant %uint 0
+    %uint_64 = OpConstant %uint 64
+     %uint_3 = OpConstant %uint 3
+    %uint_16 = OpConstant %uint 16
+     %uint_4 = OpConstant %uint 4
+%coop_stride = OpConstant %int 42
+%_runtimearr_int = OpTypeRuntimeArray %int
+  %_struct_4 = OpTypeStruct %_runtimearr_int
+%_ptr_StorageBuffer__struct_4 = OpTypePointer StorageBuffer %_struct_4
+       %void = OpTypeVoid
+         %16 = OpTypeFunction %void
+; CHECK: [[mat:%\w+]] = OpTypeCooperativeMatrixKHR %int %uint_3 %uint_16 %uint_4 %uint_0
+         %17 = OpTypeCooperativeMatrixKHR %int %uint_3 %uint_16 %uint_4 %uint_0
+; CHECK: [[struct:%\w+]] = OpTypeStruct [[mat]]
+ %_struct_18 = OpTypeStruct %17
+; CHECK: [[ptr:%\w+]] = OpTypePointer Function [[struct]]
+%_ptr_Function__struct_18 = OpTypePointer Function %_struct_18
+%_ptr_StorageBuffer_int = OpTypePointer StorageBuffer %int
+%_ptr_Function_17 = OpTypePointer Function %17
+%_ptr_Function_int = OpTypePointer Function %int
+%_ptr_Function__ptr_Function_int = OpTypePointer Function %_ptr_Function_int
+          %2 = OpVariable %_ptr_StorageBuffer__struct_4 StorageBuffer
+
+; The stored to the fist two variables should be removed and the variables
+; as well. The only function scope variable should be the cooperative matrix.
+; CHECK: OpFunction
+; CHECK-NOT: OpVariable %_ptr_Function__ptr_Function_int Function
+; CHECK: OpVariable [[ptr]] Function
+; CHECK-NOT: OpVariable
+          %1 = OpFunction %void None %16
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function__ptr_Function_int Function
+         %26 = OpVariable %_ptr_Function__ptr_Function_int Function
+         %27 = OpVariable %_ptr_Function__struct_18 Function
+         %28 = OpAccessChain %_ptr_StorageBuffer_int %2 %int_0 %uint_0
+         %29 = OpCooperativeMatrixLoadKHR %17 %28 %int_1 %coop_stride
+         %30 = OpCompositeConstruct %_struct_18 %29
+               OpStore %27 %30
+         %31 = OpAccessChain %_ptr_Function_17 %27 %int_0
+         %32 = OpAccessChain %_ptr_Function_int %27 %int_0 %uint_0
+               OpStore %26 %32
+         %33 = OpLoad %int %32
+         %34 = OpIAdd %int %33 %int_1
+               OpStore %25 %32
+               OpStore %32 %34
+         %35 = OpAccessChain %_ptr_StorageBuffer_int %2 %int_0 %uint_64
+         %36 = OpLoad %17 %31
+               OpCooperativeMatrixStoreKHR %35 %36 %int_0 %coop_stride
+               OpReturn
+               OpFunctionEnd
+)";
+
+  // For physical storage buffer support
+  SetTargetEnv(SPV_ENV_VULKAN_1_2);
+  SinglePassRunAndMatch<AggressiveDCEPass>(text, true);
+}
+
+TEST_F(AggressiveDCETest, FunctionDeclaration) {
+  // Ensure the optimizer can handle traversing over a function declaration
+  // 'myfunc' which has no blocks
+
+  const std::string text = R"(OpCapability Linkage
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %PSMain "main" %entryPointParam_PSMain
+OpExecutionMode %PSMain OriginUpperLeft
+OpSource Slang 1
+OpName %myfunc "myfunc"
+OpName %entryPointParam_PSMain "entryPointParam_PSMain"
+OpName %PSMain "PSMain"
+OpDecorate %myfunc LinkageAttributes "_S6myfuncp0pv4f" Import
+OpDecorate %entryPointParam_PSMain Location 0
+%void = OpTypeVoid
+%5 = OpTypeFunction %void
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%8 = OpTypeFunction %v4float
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%entryPointParam_PSMain = OpVariable %_ptr_Output_v4float Output
+%myfunc = OpFunction %v4float None %8
+OpFunctionEnd
+%PSMain = OpFunction %void None %5
+%10 = OpLabel
+%11 = OpFunctionCall %v4float %myfunc
+OpStore %entryPointParam_PSMain %11
+OpReturn
+OpFunctionEnd
+)";
+
+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  SinglePassRunAndCheck<AggressiveDCEPass>(text, text, true, true);
+}
+
+TEST_F(AggressiveDCETest, MarkCentroidInterpolantLive) {
+  const std::string spirv =
+      R"(OpCapability InterpolationFunction
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %in_var_COLOR %out_var_SV_Target
+OpExecutionMode %main OriginUpperLeft
+OpSource HLSL 680
+OpName %in_var_COLOR "in.var.COLOR"
+OpName %out_var_SV_Target "out.var.SV_Target"
+OpName %main "main"
+OpName %param_var_p1 "param.var.p1"
+OpDecorate %in_var_COLOR Location 0
+OpDecorate %out_var_SV_Target Location 0
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%void = OpTypeVoid
+%11 = OpTypeFunction %void
+%_ptr_Function_v4float = OpTypePointer Function %v4float
+%in_var_COLOR = OpVariable %_ptr_Input_v4float Input
+%out_var_SV_Target = OpVariable %_ptr_Output_v4float Output
+%main = OpFunction %void None %11
+%13 = OpLabel
+%14 = OpVariable %_ptr_Function_v4float Function
+%param_var_p1 = OpVariable %_ptr_Function_v4float Function
+%15 = OpLoad %v4float %in_var_COLOR
+OpStore %param_var_p1 %15
+%16 = OpExtInst %v4float %1 InterpolateAtCentroid %param_var_p1
+OpStore %14 %16
+%17 = OpLoad %v4float %14
+OpStore %out_var_SV_Target %17
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndCheck<AggressiveDCEPass>(spirv, spirv, true, false);
+}
+
+TEST_F(AggressiveDCETest, MarkSampleInterpolantLive) {
+  const std::string spirv =
+      R"(OpCapability InterpolationFunction
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %in_var_COLOR %out_var_SV_Target
+OpExecutionMode %main OriginUpperLeft
+OpSource HLSL 680
+OpName %in_var_COLOR "in.var.COLOR"
+OpName %out_var_SV_Target "out.var.SV_Target"
+OpName %main "main"
+OpName %param_var_p1 "param.var.p1"
+OpDecorate %in_var_COLOR Location 0
+OpDecorate %out_var_SV_Target Location 0
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 1
+%v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%void = OpTypeVoid
+%12 = OpTypeFunction %void
+%_ptr_Function_v4float = OpTypePointer Function %v4float
+%in_var_COLOR = OpVariable %_ptr_Input_v4float Input
+%out_var_SV_Target = OpVariable %_ptr_Output_v4float Output
+%int_123 = OpConstant %int 123
+%main = OpFunction %void None %12
+%15 = OpLabel
+%16 = OpVariable %_ptr_Function_v4float Function
+%param_var_p1 = OpVariable %_ptr_Function_v4float Function
+%17 = OpLoad %v4float %in_var_COLOR
+OpStore %param_var_p1 %17
+%18 = OpExtInst %v4float %1 InterpolateAtSample %param_var_p1 %int_123
+OpStore %16 %18
+%19 = OpLoad %v4float %16
+OpStore %out_var_SV_Target %19
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndCheck<AggressiveDCEPass>(spirv, spirv, true, false);
+}
+
+TEST_F(AggressiveDCETest, MarkOffsetInterpolantLive) {
+  const std::string spirv =
+      R"(OpCapability InterpolationFunction
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %in_var_COLOR %out_var_SV_Target
+OpExecutionMode %main OriginUpperLeft
+OpSource HLSL 680
+OpName %in_var_COLOR "in.var.COLOR"
+OpName %out_var_SV_Target "out.var.SV_Target"
+OpName %main "main"
+OpName %param_var_p1 "param.var.p1"
+OpDecorate %in_var_COLOR Location 0
+OpDecorate %out_var_SV_Target Location 0
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 1
+%v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%void = OpTypeVoid
+%12 = OpTypeFunction %void
+%_ptr_Function_v4float = OpTypePointer Function %v4float
+%in_var_COLOR = OpVariable %_ptr_Input_v4float Input
+%out_var_SV_Target = OpVariable %_ptr_Output_v4float Output
+%int_123 = OpConstant %int 123
+%main = OpFunction %void None %12
+%15 = OpLabel
+%16 = OpVariable %_ptr_Function_v4float Function
+%param_var_p1 = OpVariable %_ptr_Function_v4float Function
+%17 = OpLoad %v4float %in_var_COLOR
+OpStore %param_var_p1 %17
+%18 = OpExtInst %v4float %1 InterpolateAtOffset %param_var_p1 %int_123
+OpStore %16 %18
+%19 = OpLoad %v4float %16
+OpStore %out_var_SV_Target %19
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndCheck<AggressiveDCEPass>(spirv, spirv, true, false);
+}
+
 }  // namespace
 }  // namespace opt
 }  // namespace spvtools
diff --git a/test/opt/copy_prop_array_test.cpp b/test/opt/copy_prop_array_test.cpp
index 16719b87..7d8a3254 100644
--- a/test/opt/copy_prop_array_test.cpp
+++ b/test/opt/copy_prop_array_test.cpp
@@ -1977,6 +1977,175 @@ OpFunctionEnd
 
   SinglePassRunAndCheck<CopyPropagateArrays>(text, text, false);
 }
+
+TEST_F(CopyPropArrayPassTest, InterpolateFunctions) {
+  const std::string before = R"(OpCapability InterpolationFunction
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %in_var_COLOR
+OpExecutionMode %main OriginUpperLeft
+OpSource HLSL 680
+OpName %in_var_COLOR "in.var.COLOR"
+OpName %main "main"
+OpName %offset "offset"
+OpDecorate %in_var_COLOR Location 0
+%int = OpTypeInt 32 1
+%int_0 = OpConstant %int 0
+%float = OpTypeFloat 32
+%float_0 = OpConstant %float 0
+%v2float = OpTypeVector %float 2
+%v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%void = OpTypeVoid
+%19 = OpTypeFunction %void
+%_ptr_Function_v4float = OpTypePointer Function %v4float
+%in_var_COLOR = OpVariable %_ptr_Input_v4float Input
+%main = OpFunction %void None %19
+%20 = OpLabel
+%45 = OpVariable %_ptr_Function_v4float Function
+%25 = OpLoad %v4float %in_var_COLOR
+OpStore %45 %25
+; CHECK: OpExtInst %v4float %1 InterpolateAtCentroid %in_var_COLOR
+%52 = OpExtInst %v4float %1 InterpolateAtCentroid %45
+; CHECK: OpExtInst %v4float %1 InterpolateAtSample %in_var_COLOR %int_0
+%54 = OpExtInst %v4float %1 InterpolateAtSample %45 %int_0
+%offset = OpCompositeConstruct %v2float %float_0 %float_0
+; CHECK: OpExtInst %v4float %1 InterpolateAtOffset %in_var_COLOR %offset
+%56 = OpExtInst %v4float %1 InterpolateAtOffset %45 %offset
+OpReturn
+OpFunctionEnd
+)";
+
+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  SetDisassembleOptions(SPV_BINARY_TO_TEXT_OPTION_NO_HEADER |
+                        SPV_BINARY_TO_TEXT_OPTION_FRIENDLY_NAMES);
+  SinglePassRunAndMatch<CopyPropagateArrays>(before, false);
+}
+
+TEST_F(CopyPropArrayPassTest, InterpolateMultiPropagation) {
+  const std::string before = R"(OpCapability InterpolationFunction
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %in_var_COLOR
+OpExecutionMode %main OriginUpperLeft
+OpSource HLSL 680
+OpName %in_var_COLOR "in.var.COLOR"
+OpName %main "main"
+OpName %param_var_color "param.var.color"
+OpDecorate %in_var_COLOR Location 0
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%void = OpTypeVoid
+%19 = OpTypeFunction %void
+%_ptr_Function_v4float = OpTypePointer Function %v4float
+%in_var_COLOR = OpVariable %_ptr_Input_v4float Input
+%main = OpFunction %void None %19
+%20 = OpLabel
+%45 = OpVariable %_ptr_Function_v4float Function
+%param_var_color = OpVariable %_ptr_Function_v4float Function
+%25 = OpLoad %v4float %in_var_COLOR
+OpStore %param_var_color %25
+; CHECK: OpExtInst %v4float %1 InterpolateAtCentroid %in_var_COLOR
+%52 = OpExtInst %v4float %1 InterpolateAtCentroid %param_var_color
+%49 = OpLoad %v4float %param_var_color
+OpStore %45 %49
+; CHECK: OpExtInst %v4float %1 InterpolateAtCentroid %in_var_COLOR
+%54 = OpExtInst %v4float %1 InterpolateAtCentroid %45
+OpReturn
+OpFunctionEnd
+)";
+
+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  SetDisassembleOptions(SPV_BINARY_TO_TEXT_OPTION_NO_HEADER |
+                        SPV_BINARY_TO_TEXT_OPTION_FRIENDLY_NAMES);
+  SinglePassRunAndMatch<CopyPropagateArrays>(before, false);
+}
+
+TEST_F(CopyPropArrayPassTest, PropagateScalar) {
+  const std::string before = R"(OpCapability InterpolationFunction
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %in_var_SV_InstanceID
+OpExecutionMode %main OriginUpperLeft
+OpSource HLSL 680
+OpName %in_var_SV_InstanceID "in.var.SV_InstanceID"
+OpName %main "main"
+OpDecorate %in_var_SV_InstanceID Location 0
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%void = OpTypeVoid
+%19 = OpTypeFunction %void
+%_ptr_Function_float = OpTypePointer Function %float
+%in_var_SV_InstanceID = OpVariable %_ptr_Input_float Input
+%main = OpFunction %void None %19
+%20 = OpLabel
+%45 = OpVariable %_ptr_Function_float Function
+%25 = OpLoad %v4float %in_var_SV_InstanceID
+OpStore %45 %25
+; CHECK: OpExtInst %v4float %1 InterpolateAtCentroid %in_var_SV_InstanceID
+%52 = OpExtInst %v4float %1 InterpolateAtCentroid %45
+OpReturn
+OpFunctionEnd
+)";
+
+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  SetDisassembleOptions(SPV_BINARY_TO_TEXT_OPTION_NO_HEADER |
+                        SPV_BINARY_TO_TEXT_OPTION_FRIENDLY_NAMES);
+  SinglePassRunAndMatch<CopyPropagateArrays>(before, false);
+}
+
+TEST_F(CopyPropArrayPassTest, StoreToAccessChain) {
+  const std::string before = R"(OpCapability InterpolationFunction
+OpCapability MeshShadingEXT
+OpExtension "SPV_EXT_mesh_shader"
+OpMemoryModel Logical GLSL450
+OpEntryPoint MeshEXT %1 "main" %2 %3
+OpExecutionMode %1 LocalSize 128 1 1
+OpExecutionMode %1 OutputTrianglesEXT
+OpExecutionMode %1 OutputVertices 64
+OpExecutionMode %1 OutputPrimitivesEXT 126
+OpDecorate %3 Flat
+OpDecorate %3 Location 2
+%uint = OpTypeInt 32 0
+%uint_4 = OpConstant %uint 4
+%uint_32 = OpConstant %uint 32
+%_arr_uint_uint_32 = OpTypeArray %uint %uint_32
+%_struct_8 = OpTypeStruct %_arr_uint_uint_32
+%_ptr_TaskPayloadWorkgroupEXT__struct_8 = OpTypePointer TaskPayloadWorkgroupEXT %_struct_8
+%uint_64 = OpConstant %uint 64
+%_arr_uint_uint_64 = OpTypeArray %uint %uint_64
+%_ptr_Output__arr_uint_uint_64 = OpTypePointer Output %_arr_uint_uint_64
+%void = OpTypeVoid
+%14 = OpTypeFunction %void
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Function__arr_uint_uint_32 = OpTypePointer Function %_arr_uint_uint_32
+%_ptr_Output_uint = OpTypePointer Output %uint
+%2 = OpVariable %_ptr_TaskPayloadWorkgroupEXT__struct_8 TaskPayloadWorkgroupEXT
+%3 = OpVariable %_ptr_Output__arr_uint_uint_64 Output
+%1 = OpFunction %void None %14
+%18 = OpLabel
+%19 = OpVariable %_ptr_Function__arr_uint_uint_32 Function
+%20 = OpLoad %_struct_8 %2
+%21 = OpCompositeExtract %_arr_uint_uint_32 %20 0
+; CHECK: %28 = OpAccessChain %_ptr_TaskPayloadWorkgroupEXT__arr_uint_uint_32 %2 %uint_0
+OpStore %19 %21
+; CHECK: %22 = OpAccessChain %_ptr_TaskPayloadWorkgroupEXT_uint %28 %uint_4
+%22 = OpAccessChain %_ptr_Function_uint %19 %uint_4
+%23 = OpLoad %uint %22
+%24 = OpAccessChain %_ptr_Output_uint %3 %uint_4
+OpStore %24 %23
+OpReturn
+OpFunctionEnd
+)";
+
+  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
+  SinglePassRunAndMatch<CopyPropagateArrays>(before, true);
+}
 }  // namespace
 }  // namespace opt
 }  // namespace spvtools
diff --git a/test/opt/debug_info_manager_test.cpp b/test/opt/debug_info_manager_test.cpp
index 3df26a97..9c757280 100644
--- a/test/opt/debug_info_manager_test.cpp
+++ b/test/opt/debug_info_manager_test.cpp
@@ -799,6 +799,84 @@ void main(float in_var_color : COLOR) {
             7);
 }
 
+TEST(DebugInfoManager, ConvertGlobalToLocal) {
+  const std::string text = R"(
+               OpCapability Shader
+          %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "PSMain" %3
+               OpExecutionMode %2 OriginUpperLeft
+          %4 = OpString "C:\\local\\Temp\\2528091a-6811-4e62-9ed5-02f1547c2016.hlsl"
+          %5 = OpString "float"
+          %6 = OpString "Pi"
+      %float = OpTypeFloat 32
+%float_3_1415 = OpConstant %float 3.1415
+       %uint = OpTypeInt 32 0
+    %uint_32 = OpConstant %uint 32
+%_ptr_Private_float = OpTypePointer Private %float
+%_ptr_Function_float = OpTypePointer Function %float
+       %void = OpTypeVoid
+     %uint_3 = OpConstant %uint 3
+     %uint_0 = OpConstant %uint 0
+     %uint_4 = OpConstant %uint 4
+     %uint_1 = OpConstant %uint 1
+     %uint_5 = OpConstant %uint 5
+     %uint_8 = OpConstant %uint 8
+     %uint_6 = OpConstant %uint 6
+    %uint_20 = OpConstant %uint 20
+         %25 = OpTypeFunction %void
+    %uint_11 = OpConstant %uint 11
+          %3 = OpVariable %_ptr_Private_float Private
+          %8 = OpExtInst %void %1 DebugTypeBasic %5 %uint_32 %uint_3 %uint_0
+         %12 = OpExtInst %void %1 DebugSource %4
+         %13 = OpExtInst %void %1 DebugCompilationUnit %uint_1 %uint_4 %12 %uint_5
+         %17 = OpExtInst %void %1 DebugGlobalVariable %6 %8 %12 %uint_6 %uint_20 %13 %6 %3 %uint_8
+          %2 = OpFunction %void None %25
+         %27 = OpLabel
+         %29 = OpVariable %_ptr_Function_float Function
+               OpStore %3 %float_3_1415
+         %28 = OpExtInst %void %1 DebugLine %12 %uint_11 %uint_11 %uint_1 %uint_1
+               OpReturn
+               OpFunctionEnd
+  )";
+
+  std::unique_ptr<IRContext> context =
+      BuildModule(SPV_ENV_UNIVERSAL_1_1, nullptr, text,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  auto* def_use_mgr = context->get_def_use_mgr();
+  auto* dbg_var = def_use_mgr->GetDef(17);
+  EXPECT_EQ(dbg_var->GetCommonDebugOpcode(),
+            OpenCLDebugInfo100DebugGlobalVariable);
+  EXPECT_EQ(dbg_var->NumInOperands(), 11);
+
+  std::vector<Operand> originalOperands;
+  for (uint32_t i = 0; i < dbg_var->NumInOperands(); ++i) {
+    originalOperands.emplace_back(dbg_var->GetInOperand((i)));
+  }
+
+  auto* local_var = def_use_mgr->GetDef(29);
+  auto* dbg_info_mgr = context->get_debug_info_mgr();
+  dbg_info_mgr->ConvertDebugGlobalToLocalVariable(dbg_var, local_var);
+
+  EXPECT_EQ(dbg_var->NumInOperands(), 9);
+
+  // This checks that the first two inoperands are correct.
+  EXPECT_EQ(dbg_var->GetCommonDebugOpcode(),
+            OpenCLDebugInfo100DebugLocalVariable);
+
+  // Then next 6 operands should be the same as the original instruction.
+  EXPECT_EQ(dbg_var->GetInOperand(2), originalOperands[2]);
+  EXPECT_EQ(dbg_var->GetInOperand(3), originalOperands[3]);
+  EXPECT_EQ(dbg_var->GetInOperand(4), originalOperands[4]);
+  EXPECT_EQ(dbg_var->GetInOperand(5), originalOperands[5]);
+  EXPECT_EQ(dbg_var->GetInOperand(6), originalOperands[6]);
+  EXPECT_EQ(dbg_var->GetInOperand(7), originalOperands[7]);
+
+  // The flags operand should have shifted because operand 8 and 9 in the global
+  // instruction are not relevant.
+  EXPECT_EQ(dbg_var->GetInOperand(8), originalOperands[10]);
+}
+
 }  // namespace
 }  // namespace analysis
 }  // namespace opt
diff --git a/test/opt/desc_sroa_test.cpp b/test/opt/desc_sroa_test.cpp
index 5c166d83..f86fa3a8 100644
--- a/test/opt/desc_sroa_test.cpp
+++ b/test/opt/desc_sroa_test.cpp
@@ -198,7 +198,8 @@ TEST_F(DescriptorScalarReplacementTest, ExpandArrayOfTextures) {
 
   )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, ExpandArrayOfSamplers) {
@@ -249,7 +250,8 @@ TEST_F(DescriptorScalarReplacementTest, ExpandArrayOfSamplers) {
                OpFunctionEnd
   )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, ExpandArrayOfSSBOs) {
@@ -308,7 +310,8 @@ TEST_F(DescriptorScalarReplacementTest, ExpandArrayOfSSBOs) {
                OpFunctionEnd
   )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, NameNewVariables) {
@@ -370,7 +373,8 @@ TEST_F(DescriptorScalarReplacementTest, NameNewVariables) {
                OpFunctionEnd
   )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, DontExpandCBuffers) {
@@ -430,7 +434,8 @@ TEST_F(DescriptorScalarReplacementTest, DontExpandCBuffers) {
                OpFunctionEnd
 )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, DontExpandStructuredBuffers) {
@@ -497,7 +502,8 @@ TEST_F(DescriptorScalarReplacementTest, DontExpandStructuredBuffers) {
                OpFunctionEnd
 )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, StructureArrayNames) {
@@ -511,7 +517,39 @@ TEST_F(DescriptorScalarReplacementTest, StructureArrayNames) {
   )";
 
   const std::string text = checks + GetStructureArrayTestSpirv();
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
+}
+
+TEST_F(DescriptorScalarReplacementTest,
+       FlattensArraysOfStructsButNoResourceArrays) {
+  // Check that only the composite array is flattenned, but internal resource
+  // arrays are left as-is.
+  const std::string checks = R"(
+; CHECK:     OpName %globalS_0__0__t "globalS[0][0].t"
+; CHECK:     OpName %globalS_0__0__s "globalS[0][0].s"
+; CHECK:     OpName %globalS_1__1__t "globalS[1][1].t"
+; CHECK:     OpName %globalS_1__1__s "globalS[1][1].s"
+; CHECK-NOT: OpName %globalS_1__1__t_0_
+; CHECK-NOT: OpName %globalS_1__1__s_0_
+  )";
+
+  const std::string text = checks + GetStructureArrayTestSpirv();
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/false);
+}
+
+TEST_F(DescriptorScalarReplacementTest, FlattenNothingIfAskedTo) {
+  // Not useful, but checks what happens if both are set to false.
+  // In such case, nothing happens.
+  const std::string checks = R"(
+; CHECK:     OpName %globalS
+; CHECK-NOT: OpName %globalS_
+  )";
+
+  const std::string text = checks + GetStructureArrayTestSpirv();
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/false, /* flatten_arrays=*/false);
 }
 
 TEST_F(DescriptorScalarReplacementTest, StructureArrayBindings) {
@@ -525,7 +563,8 @@ TEST_F(DescriptorScalarReplacementTest, StructureArrayBindings) {
   )";
 
   const std::string text = checks + GetStructureArrayTestSpirv();
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, StructureArrayReplacements) {
@@ -540,7 +579,8 @@ TEST_F(DescriptorScalarReplacementTest, StructureArrayReplacements) {
   )";
 
   const std::string text = checks + GetStructureArrayTestSpirv();
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, ResourceStructAsFunctionParam) {
@@ -724,7 +764,9 @@ TEST_F(DescriptorScalarReplacementTest, ResourceStructAsFunctionParam) {
 ; CHECK:                          OpFAdd %v4float [[sample_3]] [[sample_4]]
 )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(checks + shader, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      checks + shader, true, /* flatten_composites=*/true,
+      /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, BindingForResourceArrayOfStructs) {
@@ -765,7 +807,8 @@ TEST_F(DescriptorScalarReplacementTest, BindingForResourceArrayOfStructs) {
                OpFunctionEnd
 )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(shader, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      shader, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, MemberDecorationForResourceStruct) {
@@ -828,7 +871,8 @@ TEST_F(DescriptorScalarReplacementTest, MemberDecorationForResourceStruct) {
                OpFunctionEnd
 )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(shader, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      shader, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, DecorateStringForReflect) {
@@ -915,7 +959,8 @@ TEST_F(DescriptorScalarReplacementTest, DecorateStringForReflect) {
                OpFunctionEnd
 )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(shader, true);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      shader, true, /* flatten_composites=*/true, /* flatten_arrays=*/true);
 }
 
 TEST_F(DescriptorScalarReplacementTest, ExpandArrayInOpEntryPoint) {
@@ -983,7 +1028,161 @@ TEST_F(DescriptorScalarReplacementTest, ExpandArrayInOpEntryPoint) {
                OpFunctionEnd
   )";
 
-  SinglePassRunAndMatch<DescriptorScalarReplacement>(text, false);
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, false, /* flatten_composites=*/true, /* flatten_arrays=*/true);
+}
+
+TEST_F(DescriptorScalarReplacementTest,
+       ExpandArrayWhenCompositeExpensionIsOff) {
+  const std::string text = R"(; SPIR-V
+; Version: 1.6
+; Bound: 31
+; Schema: 0
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+
+; CHECK:       OpEntryPoint GLCompute %main "main" %output_0_ %output_1_
+
+               OpEntryPoint GLCompute %main "main" %output
+               OpExecutionMode %main LocalSize 1 1 1
+               OpSource HLSL 670
+               OpName %type_RWByteAddressBuffer "type.RWByteAddressBuffer"
+               OpName %output "output"
+               OpName %main "main"
+               OpName %src_main "src.main"
+               OpName %bb_entry "bb.entry"
+
+; CHECK:       OpDecorate %output_1_ DescriptorSet 0
+; CHECK:       OpDecorate %output_1_ Binding 1
+; CHECK:       OpDecorate %output_0_ DescriptorSet 0
+; CHECK:       OpDecorate %output_0_ Binding 0
+
+               OpDecorate %output DescriptorSet 0
+               OpDecorate %output Binding 0
+
+               OpDecorate %_runtimearr_uint ArrayStride 4
+               OpMemberDecorate %type_RWByteAddressBuffer 0 Offset 0
+               OpDecorate %type_RWByteAddressBuffer Block
+        %int = OpTypeInt 32 1
+      %int_1 = OpConstant %int 1
+       %uint = OpTypeInt 32 0
+     %uint_0 = OpConstant %uint 0
+     %uint_2 = OpConstant %uint 2
+    %uint_32 = OpConstant %uint 32
+%_runtimearr_uint = OpTypeRuntimeArray %uint
+%type_RWByteAddressBuffer = OpTypeStruct %_runtimearr_uint
+%_arr_type_RWByteAddressBuffer_uint_2 = OpTypeArray %type_RWByteAddressBuffer %uint_2
+%_ptr_StorageBuffer__arr_type_RWByteAddressBuffer_uint_2 = OpTypePointer StorageBuffer %_arr_type_RWByteAddressBuffer_uint_2
+       %void = OpTypeVoid
+         %23 = OpTypeFunction %void
+%_ptr_StorageBuffer_type_RWByteAddressBuffer = OpTypePointer StorageBuffer %type_RWByteAddressBuffer
+%_ptr_StorageBuffer_uint = OpTypePointer StorageBuffer %uint
+
+; CHECK: %output_1_ = OpVariable %_ptr_StorageBuffer_type_RWByteAddressBuffer StorageBuffer
+; CHECK: %output_0_ = OpVariable %_ptr_StorageBuffer_type_RWByteAddressBuffer StorageBuffer
+
+     %output = OpVariable %_ptr_StorageBuffer__arr_type_RWByteAddressBuffer_uint_2 StorageBuffer
+
+       %main = OpFunction %void None %23
+         %26 = OpLabel
+         %27 = OpFunctionCall %void %src_main
+               OpReturn
+               OpFunctionEnd
+   %src_main = OpFunction %void None %23
+   %bb_entry = OpLabel
+         %28 = OpAccessChain %_ptr_StorageBuffer_type_RWByteAddressBuffer %output %int_1
+         %29 = OpShiftRightLogical %uint %uint_0 %uint_2
+         %30 = OpAccessChain %_ptr_StorageBuffer_uint %28 %uint_0 %29
+               OpStore %30 %uint_32
+               OpReturn
+               OpFunctionEnd
+  )";
+
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, false, /* flatten_composites=*/false, /* flatten_arrays=*/true);
+}
+
+TEST_F(DescriptorScalarReplacementTest, ExpandStructButNotArray) {
+  const std::string text = R"(; SPIR-V
+; Version: 1.6
+; Generator: Khronos SPIR-V Tools Assembler; 0
+; Bound: 41
+; Schema: 0
+                                   OpCapability Shader
+                                   OpMemoryModel Logical GLSL450
+                                   OpEntryPoint Fragment %main "main" %out_var_SV_Target
+                                   OpExecutionMode %main OriginUpperLeft
+                                   OpSource HLSL 660
+                                   OpName %type_2d_image "type.2d.image"
+                                   OpName %Textures "Textures"
+                                   OpName %type_sampler "type.sampler"
+                                   OpName %out_var_SV_Target "out.var.SV_Target"
+                                   OpName %main "main"
+                                   OpName %type_sampled_image "type.sampled.image"
+                                   OpName %TheStruct "TheStruct"
+                                   OpMemberName %StructOfResources 0 "Texture"
+                                   OpMemberName %StructOfResources 1 "Sampler"
+; CHECK:                           OpName %TheStruct_Sampler "TheStruct.Sampler"
+; CHECK:                           OpName %TheStruct_Texture "TheStruct.Texture"
+                                   OpDecorate %out_var_SV_Target Location 0
+                                   OpDecorate %Textures DescriptorSet 0
+                                   OpDecorate %Textures Binding 0
+                                   OpDecorate %TheStruct DescriptorSet 0
+                                   OpDecorate %TheStruct Binding 10
+; CHECK:                           OpDecorate %TheStruct_Sampler DescriptorSet 0
+; CHECK:                           OpDecorate %TheStruct_Sampler Binding 11
+; CHECK:                           OpDecorate %TheStruct_Texture DescriptorSet 0
+; CHECK:                           OpDecorate %TheStruct_Texture Binding 10
+                            %int = OpTypeInt 32 1
+                          %int_0 = OpConstant %int 0
+                          %int_1 = OpConstant %int 1
+                          %float = OpTypeFloat 32
+                        %float_0 = OpConstant %float 0
+                        %v2float = OpTypeVector %float 2
+                             %13 = OpConstantComposite %v2float %float_0 %float_0
+                           %uint = OpTypeInt 32 0
+                        %uint_10 = OpConstant %uint 10
+                  %type_2d_image = OpTypeImage %float 2D 2 0 0 1 Unknown
+     %_arr_type_2d_image_uint_10 = OpTypeArray %type_2d_image %uint_10
+%_ptr_UniformConstant__arr_type_2d_image_uint_10 = OpTypePointer UniformConstant %_arr_type_2d_image_uint_10
+                   %type_sampler = OpTypeSampler
+              %StructOfResources = OpTypeStruct %type_2d_image %type_sampler
+%_ptr_UniformConstant__struct_18 = OpTypePointer UniformConstant %StructOfResources
+                        %v4float = OpTypeVector %float 4
+            %_ptr_Output_v4float = OpTypePointer Output %v4float
+                           %void = OpTypeVoid
+                             %23 = OpTypeFunction %void
+%_ptr_UniformConstant_type_2d_image = OpTypePointer UniformConstant %type_2d_image
+ %_ptr_UniformConstant_type_sampler = OpTypePointer UniformConstant %type_sampler
+             %type_sampled_image = OpTypeSampledImage %type_2d_image
+                       %Textures = OpVariable %_ptr_UniformConstant__arr_type_2d_image_uint_10 UniformConstant
+              %out_var_SV_Target = OpVariable %_ptr_Output_v4float Output
+                      %TheStruct = OpVariable %_ptr_UniformConstant__struct_18 UniformConstant
+                           %main = OpFunction %void None %23
+                             %26 = OpLabel
+                             %27 = OpAccessChain %_ptr_UniformConstant_type_2d_image %Textures %int_0
+                             %28 = OpLoad %type_2d_image %27
+                             %29 = OpAccessChain %_ptr_UniformConstant_type_sampler %TheStruct %int_1
+                             %31 = OpLoad %type_sampler %29
+; CHECK:                     %31 = OpLoad %type_sampler %TheStruct_Sampler
+                             %32 = OpSampledImage %type_sampled_image %28 %31
+                             %33 = OpImageSampleImplicitLod %v4float %32 %13 None
+                             %34 = OpAccessChain %_ptr_UniformConstant_type_2d_image %TheStruct %int_0
+                             %35 = OpLoad %type_2d_image %34
+; CHECK:                     %35 = OpLoad %type_2d_image %TheStruct_Texture
+                             %36 = OpAccessChain %_ptr_UniformConstant_type_sampler %TheStruct %int_1
+                             %37 = OpLoad %type_sampler %36
+; CHECK:                     %37 = OpLoad %type_sampler %TheStruct_Sampler
+                             %38 = OpSampledImage %type_sampled_image %35 %37
+                             %39 = OpImageSampleImplicitLod %v4float %38 %13 None
+                             %40 = OpFAdd %v4float %33 %39
+                                   OpStore %out_var_SV_Target %40
+                                   OpReturn
+                                   OpFunctionEnd
+  )";
+
+  SinglePassRunAndMatch<DescriptorScalarReplacement>(
+      text, false, /* flatten_composites=*/true, /* flatten_arrays=*/false);
 }
 
 }  // namespace
diff --git a/test/opt/fix_storage_class_test.cpp b/test/opt/fix_storage_class_test.cpp
index 684e006e..01a75e0d 100644
--- a/test/opt/fix_storage_class_test.cpp
+++ b/test/opt/fix_storage_class_test.cpp
@@ -916,6 +916,123 @@ TEST_F(FixStorageClassTest, SupportsU64Index) {
   SinglePassRunAndMatch<FixStorageClass>(text, false);
 }
 
+TEST_F(FixStorageClassTest, CorrectlyProcessAccessChainOnCoopMatrix) {
+  const std::string text = R"(OpCapability CooperativeMatrixKHR
+OpCapability Shader
+OpExtension "SPV_KHR_cooperative_matrix"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %1 "main"
+OpExecutionMode %1 LocalSize 64 1 1
+OpSource HLSL 600
+%int = OpTypeInt 32 1
+%int_0 = OpConstant %int 0
+%uint = OpTypeInt 32 0
+%uint_0 = OpConstant %uint 0
+%uint_3 = OpConstant %uint 3
+%uint_16 = OpConstant %uint 16
+%uint_4 = OpConstant %uint 4
+%9 = OpTypeCooperativeMatrixKHR %int %uint_3 %uint_16 %uint_4 %uint_0
+%void = OpTypeVoid
+%11 = OpTypeFunction %void
+%_struct_12 = OpTypeStruct %9
+%_ptr_Function__struct_12 = OpTypePointer Function %_struct_12
+%_ptr_Function_9 = OpTypePointer Function %9
+%_ptr_Function_int = OpTypePointer Function %int
+%_ptr_Function__ptr_Function_int = OpTypePointer Function %_ptr_Function_int
+%1 = OpFunction %void None %11
+%17 = OpLabel
+%18 = OpVariable %_ptr_Function__ptr_Function_int Function
+%19 = OpVariable %_ptr_Function__struct_12 Function
+%20 = OpAccessChain %_ptr_Function_9 %19 %int_0
+%21 = OpAccessChain %_ptr_Function_int %20 %uint_4
+OpStore %18 %21
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndCheck<FixStorageClass>(text, text, false, false);
+}
+
+// Tests that the pass is not confused when there are multiple definitions
+// of a pointer type to the same type with the same storage class.
+TEST_F(FixStorageClassTest, DuplicatePointerType) {
+  const std::string text = R"(OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %1 "main"
+OpExecutionMode %1 LocalSize 64 1 1
+OpSource HLSL 600
+%uint = OpTypeInt 32 0
+%uint_0 = OpConstant %uint 0
+%uint_3 = OpConstant %uint 3
+%_arr_uint_uint_3 = OpTypeArray %uint %uint_3
+%void = OpTypeVoid
+%7 = OpTypeFunction %void
+%_struct_8 = OpTypeStruct %_arr_uint_uint_3
+%_ptr_Function__struct_8 = OpTypePointer Function %_struct_8
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Function__arr_uint_uint_3 = OpTypePointer Function %_arr_uint_uint_3
+%_ptr_Function_uint_0 = OpTypePointer Function %uint
+%_ptr_Function__ptr_Function_uint_0 = OpTypePointer Function %_ptr_Function_uint_0
+%1 = OpFunction %void None %7
+%14 = OpLabel
+%15 = OpVariable %_ptr_Function__ptr_Function_uint_0 Function
+%16 = OpVariable %_ptr_Function__struct_8 Function
+%17 = OpAccessChain %_ptr_Function__arr_uint_uint_3 %16 %uint_0
+%18 = OpAccessChain %_ptr_Function_uint_0 %17 %uint_0
+OpStore %15 %18
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndCheck<FixStorageClass>(text, text, false);
+}
+
+// This example is generated by DXC when certain inline spiir-v is used.
+// The intention is that the function scope variable will eventually be
+// optimized away, removing the type mismatch. We want to make sure the
+// OpCopyObject is rewritten, and that the pass does not fail.
+TEST_F(FixStorageClassTest, DoNotFailWithMismatchedPointerTypes) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %1 "main" %38
+               OpExecutionMode %1 LocalSize 64 1 1
+               OpSource HLSL 600
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+      %float = OpTypeFloat 32
+       %uint = OpTypeInt 32 0
+    %uint_64 = OpConstant %uint 64
+%_arr_float_uint_64 = OpTypeArray %float %uint_64
+%_ptr_Workgroup__arr_float_uint_64 = OpTypePointer Workgroup %_arr_float_uint_64
+       %void = OpTypeVoid
+         %80 = OpTypeFunction %void
+%_ptr_Workgroup_float = OpTypePointer Workgroup %float
+%_ptr_Function__ptr_Workgroup_float = OpTypePointer Function %_ptr_Workgroup_float
+%_ptr_Workgroup_float_0 = OpTypePointer Workgroup %float
+         %38 = OpVariable %_ptr_Workgroup__arr_float_uint_64 Workgroup
+          %1 = OpFunction %void None %80
+         %98 = OpLabel
+; CHECK: [[var:%\d+]] = OpVariable %_ptr_Function__ptr_Workgroup_float Function
+        %113 = OpVariable %_ptr_Function__ptr_Workgroup_float Function
+; CHECK: [[ac:%\d+]] = OpAccessChain %_ptr_Workgroup_float_0 {{%\d+}} %int_0
+        %136 = OpAccessChain %_ptr_Workgroup_float_0 %38 %int_0
+; Verify that the type for the OpCopyObject has changed to match [[ac]].
+; CHECK: [[copy:%\d+]] = OpCopyObject %_ptr_Workgroup_float_0 [[ac]]
+        %137 = OpCopyObject %_ptr_Workgroup_float %136
+; This has a type mismatch, but this is because we do not have a way to copy
+; a pointer from one type to another, so FixStorageClass cannot do anything
+; about it. We want fix storage class to leave it as is, and the validator
+; will report an error if the store is not remove by a later optimization.
+; CHECK: OpStore [[var]] [[copy]]
+               OpStore %113 %137
+               OpReturn
+               OpFunctionEnd
+)";
+
+  SinglePassRunAndMatch<FixStorageClass>(text, false);
+}
+
 }  // namespace
 }  // namespace opt
 }  // namespace spvtools
diff --git a/test/opt/fold_test.cpp b/test/opt/fold_test.cpp
index a4e0447c..003c4491 100644
--- a/test/opt/fold_test.cpp
+++ b/test/opt/fold_test.cpp
@@ -215,6 +215,8 @@ OpCapability Float64
 OpCapability Int8
 OpCapability Int16
 OpCapability Int64
+OpCapability CooperativeMatrixKHR
+OpExtension "SPV_KHR_cooperative_matrix"
 %1 = OpExtInstImport "GLSL.std.450"
 OpMemoryModel Logical GLSL450
 OpEntryPoint Fragment %main "main"
@@ -434,6 +436,12 @@ OpName %main "main"
 %ushort_0xBC00 = OpConstant %ushort 0xBC00
 %short_0xBC00 = OpConstant %short 0xBC00
 %int_arr_2_undef = OpUndef %int_arr_2
+%int_coop_matrix = OpTypeCooperativeMatrixKHR %int %uint_3 %uint_3 %uint_32 %uint_0
+%undef_int_coop_matrix = OpUndef %int_coop_matrix
+%uint_coop_matrix = OpTypeCooperativeMatrixKHR %uint %uint_3 %uint_3 %uint_32 %uint_0
+%undef_uint_coop_matrix = OpUndef %uint_coop_matrix
+%float_coop_matrix = OpTypeCooperativeMatrixKHR %float %uint_3 %uint_3 %uint_32 %uint_0
+%undef_float_coop_matrix = OpUndef %float_coop_matrix
 )";
 
   return header;
@@ -924,7 +932,7 @@ INSTANTIATE_TEST_SUITE_P(TestCase, IntegerInstructionFoldingTest,
             "%2 = OpBitcast %ushort %short_0xBC00\n" +
             "OpReturn\n" +
             "OpFunctionEnd",
-        2, 0xFFFFBC00),
+        2, 0xBC00),
     // Test case 53: Bit-cast half 1 to ushort
     InstructionFoldingCase<uint32_t>(
         Header() + "%main = OpFunction %void None %void_func\n" +
@@ -940,7 +948,7 @@ INSTANTIATE_TEST_SUITE_P(TestCase, IntegerInstructionFoldingTest,
             "%2 = OpBitcast %short %ushort_0xBC00\n" +
             "OpReturn\n" +
             "OpFunctionEnd",
-        2, 0xBC00),
+        2, 0xFFFFBC00),
     // Test case 55: Bit-cast short 0xBC00 to short
     InstructionFoldingCase<uint32_t>(
         Header() + "%main = OpFunction %void None %void_func\n" +
@@ -996,7 +1004,7 @@ INSTANTIATE_TEST_SUITE_P(TestCase, IntegerInstructionFoldingTest,
             "%2 = OpBitcast %ubyte %byte_n1\n" +
             "OpReturn\n" +
             "OpFunctionEnd",
-        2, 0xFFFFFFFF),
+        2, 0xFF),
     // Test case 62: Negate 2.
     InstructionFoldingCase<uint32_t>(
         Header() + "%main = OpFunction %void None %void_func\n" +
@@ -4148,6 +4156,62 @@ INSTANTIATE_TEST_SUITE_P(IntegerArithmeticTestCases, GeneralInstructionFoldingTe
           "%2 = OpSLessThan %bool %long_0 %long_2\n" +
           "OpReturn\n" +
           "OpFunctionEnd",
+        2, 0),
+    // Test case 41: Don't fold OpSNegate for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpSNegate %int_coop_matrix %undef_int_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 42: Don't fold OpIAdd for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpIAdd %int_coop_matrix %undef_int_coop_matrix %undef_int_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 43: Don't fold OpISub for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpISub %int_coop_matrix %undef_int_coop_matrix %undef_int_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 44: Don't fold OpIMul for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpIMul %int_coop_matrix %undef_int_coop_matrix %undef_int_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 45: Don't fold OpSDiv for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpSDiv %int_coop_matrix %undef_int_coop_matrix %undef_int_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 46: Don't fold OpUDiv for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpUDiv %uint_coop_matrix %undef_uint_coop_matrix %undef_uint_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 47: Don't fold OpMatrixTimesScalar for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpMatrixTimesScalar %uint_coop_matrix %undef_uint_coop_matrix %uint_3\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
         2, 0)
 ));
 
@@ -4689,6 +4753,54 @@ INSTANTIATE_TEST_SUITE_P(FloatRedundantFoldingTest, GeneralInstructionFoldingTes
             "%2 = OpFDiv %half %half_1 %half_2\n" +
             "OpReturn\n" +
             "OpFunctionEnd",
+        2, 0),
+    // Test case 24: Don't fold OpFNegate for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpFNegate %float_coop_matrix %undef_float_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 25: Don't fold OpIAdd for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpFAdd %float_coop_matrix %undef_float_coop_matrix %undef_float_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 26: Don't fold OpISub for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpFSub %float_coop_matrix %undef_float_coop_matrix %undef_float_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 27: Don't fold OpIMul for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpFMul %float_coop_matrix %undef_float_coop_matrix %undef_float_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 28: Don't fold OpSDiv for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpFDiv %float_coop_matrix %undef_float_coop_matrix %undef_float_coop_matrix\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        2, 0),
+    // Test case 29: Don't fold OpMatrixTimesScalar for cooperative matrices.
+    InstructionFoldingCase<uint32_t>(
+        Header() + "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%2 = OpMatrixTimesScalar %float_coop_matrix %undef_float_coop_matrix %float_3\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
         2, 0)
 ));
 
@@ -5828,7 +5940,195 @@ INSTANTIATE_TEST_SUITE_P(MergeNegateTest, MatchingInstructionFoldingTest,
             "%2 = OpFNegate %v2double %v2double_null\n" +
             "OpReturn\n" +
             "OpFunctionEnd",
-        2, true)
+        2, true),
+    // Test case 20: fold snegate with OpIMul.
+    // -(x * 2) = x * -2
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK: [[long:%\\w+]] = OpTypeInt 64 1\n" +
+          "; CHECK: [[long_n2:%\\w+]] = OpConstant [[long]] -2\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[long]]\n" +
+          "; CHECK: %4 = OpIMul [[long]] [[ld]] [[long_n2]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_long Function\n" +
+          "%2 = OpLoad %long %var\n" +
+          "%3 = OpIMul %long %2 %long_2\n" +
+          "%4 = OpSNegate %long %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 21: fold snegate with OpIMul.
+    // -(x * 2) = x * -2
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK-DAG: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK-DAG: [[uint:%\\w+]] = OpTypeInt 32 0\n" +
+          "; CHECK: [[uint_n2:%\\w+]] = OpConstant [[uint]] 4294967294\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpIMul [[int]] [[ld]] [[uint_n2]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpIMul %int %2 %uint_2\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 22: fold snegate with OpIMul.
+    // -(-24 * x) = x * 24
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK-DAG: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK: [[int_24:%\\w+]] = OpConstant [[int]] 24\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpIMul [[int]] [[ld]] [[int_24]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpIMul %int %int_n24 %2\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 23: fold snegate with OpIMul with UINT_MAX
+    // -(UINT_MAX * x) = x
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpCopyObject [[int]] [[ld]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpIMul %int %uint_max %2\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 24: fold snegate with OpIMul using -INT_MAX
+    // -(x * 2147483649u) = x * 2147483647u
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK: [[uint:%\\w+]] = OpTypeInt 32 0\n" +
+          "; CHECK: [[uint_2147483647:%\\w+]] = OpConstant [[uint]] 2147483647\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpIMul [[int]] [[ld]] [[uint_2147483647]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpIMul %int %2 %uint_2147483649\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 25: fold snegate with OpSDiv (long).
+    // -(x / 2) = x / -2
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK: [[long:%\\w+]] = OpTypeInt 64 1\n" +
+          "; CHECK: [[long_n2:%\\w+]] = OpConstant [[long]] -2\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[long]]\n" +
+          "; CHECK: %4 = OpSDiv [[long]] [[ld]] [[long_n2]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_long Function\n" +
+          "%2 = OpLoad %long %var\n" +
+          "%3 = OpSDiv %long %2 %long_2\n" +
+          "%4 = OpSNegate %long %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 26: fold snegate with OpSDiv (int).
+    // -(x / 2) = x / -2
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK-DAG: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK-DAG: [[uint:%\\w+]] = OpTypeInt 32 0\n" +
+          "; CHECK: [[uint_n2:%\\w+]] = OpConstant [[uint]] 4294967294\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpSDiv [[int]] [[ld]] [[uint_n2]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpSDiv %int %2 %uint_2\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 27: fold snegate with OpSDiv.
+    // -(-24 / x) = 24 / x
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK-DAG: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK: [[int_24:%\\w+]] = OpConstant [[int]] 24\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpSDiv [[int]] [[int_24]] [[ld]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpSDiv %int %int_n24 %2\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 28: fold snegate with OpSDiv with UINT_MAX
+    // -(UINT_MAX / x) = (1 / x)
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK: [[uint:%\\w+]] = OpTypeInt 32 0\n" +
+          "; CHECK: [[uint_1:%\\w+]] = OpConstant [[uint]] 1\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpSDiv [[int]] [[uint_1]] [[ld]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpSDiv %int %uint_max %2\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 29: fold snegate with OpSDiv using -INT_MAX
+    // -(x / 2147483647u) = x / 2147483647
+  InstructionFoldingCase<bool>(
+      Header() +
+          "; CHECK: [[int:%\\w+]] = OpTypeInt 32 1\n" +
+          "; CHECK: [[uint:%\\w+]] = OpTypeInt 32 0\n" +
+          "; CHECK: [[uint_2147483647:%\\w+]] = OpConstant [[uint]] 2147483647\n" +
+          "; CHECK: [[ld:%\\w+]] = OpLoad [[int]]\n" +
+          "; CHECK: %4 = OpSDiv [[int]] [[ld]] [[uint_2147483647]]\n" +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpSDiv %int %2 %uint_2147483649\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, true),
+    // Test case 30: Don't fold snegate int OpUDiv. The operands are interpreted
+    // as unsigned, so negating an operand is not the same a negating the
+    // result.
+  InstructionFoldingCase<bool>(
+      Header() +
+          "%main = OpFunction %void None %void_func\n" +
+          "%main_lab = OpLabel\n" +
+          "%var = OpVariable %_ptr_int Function\n" +
+          "%2 = OpLoad %int %var\n" +
+          "%3 = OpUDiv %int %2 %uint_1\n" +
+          "%4 = OpSNegate %int %3\n" +
+          "OpReturn\n" +
+          "OpFunctionEnd",
+      4, false)
 ));
 
 INSTANTIATE_TEST_SUITE_P(ReciprocalFDivTest, MatchingInstructionFoldingTest,
@@ -7827,7 +8127,21 @@ INSTANTIATE_TEST_SUITE_P(CompositeExtractOrInsertMatchingTest, MatchingInstructi
             "%5 = OpCompositeInsert %int_arr_2 %int_1 %4 1\n" +
             "OpReturn\n" +
             "OpFunctionEnd",
-        5, true)
+        5, true),
+    // Test case 19: Don't fold for isomorphic structs
+    InstructionFoldingCase<bool>(
+        Header() +
+            "%structA = OpTypeStruct %ulong\n" +
+            "%structB = OpTypeStruct %ulong\n" +
+            "%structC = OpTypeStruct %structB\n" +
+            "%struct_a_undef = OpUndef %structA\n" +
+            "%main = OpFunction %void None %void_func\n" +
+            "%main_lab = OpLabel\n" +
+            "%3 = OpCompositeExtract %ulong %struct_a_undef 0\n" +
+            "%4 = OpCompositeConstruct %structB %3\n" +
+            "OpReturn\n" +
+            "OpFunctionEnd",
+        4, false)
 ));
 
 INSTANTIATE_TEST_SUITE_P(DotProductMatchingTest, MatchingInstructionFoldingTest,
@@ -7933,21 +8247,15 @@ INSTANTIATE_TEST_SUITE_P(VectorShuffleMatchingTest, MatchingInstructionFoldingTe
         3, true)
  ));
 
+// Issue #5658: The Adreno compiler does not handle 16-bit FMA instructions well.
+// We want to avoid this by not generating FMA. We decided to never generate
+// FMAs because, from a SPIR-V perspective, it is neutral. The ICD can generate
+// the FMA if it wants. The simplest code is no code.
 INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTest,
 ::testing::Values(
-   // Test case 0: (x * y) + a = Fma(x, y, a)
+   // Test case 0: Don't fold (x * y) + a
    InstructionFoldingCase<bool>(
        Header() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[lx]] [[ly]] [[la]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
            "%main = OpFunction %void None %void_func\n" +
            "%main_lab = OpLabel\n" +
            "%x = OpVariable %_ptr_float Function\n" +
@@ -7961,20 +8269,10 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpStore %a %3\n" +
            "OpReturn\n" +
            "OpFunctionEnd",
-       3, true),
-    // Test case 1:  a + (x * y) = Fma(x, y, a)
+       3, false),
+    // Test case 1: Don't fold a + (x * y)
    InstructionFoldingCase<bool>(
        Header() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[lx]] [[ly]] [[la]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
            "%main = OpFunction %void None %void_func\n" +
            "%main_lab = OpLabel\n" +
            "%x = OpVariable %_ptr_float Function\n" +
@@ -7988,20 +8286,10 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpStore %a %3\n" +
            "OpReturn\n" +
            "OpFunctionEnd",
-       3, true),
-   // Test case 2: (x * y) + a = Fma(x, y, a) with vectors
+       3, false),
+   // Test case 2: Don't fold (x * y) + a with vectors
    InstructionFoldingCase<bool>(
        Header() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[lx]] [[ly]] [[la]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
            "%main = OpFunction %void None %void_func\n" +
            "%main_lab = OpLabel\n" +
            "%x = OpVariable %_ptr_v4float Function\n" +
@@ -8015,20 +8303,10 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpStore %a %3\n" +
            "OpReturn\n" +
            "OpFunctionEnd",
-       3, true),
-    // Test case 3:  a + (x * y) = Fma(x, y, a) with vectors
+       3,false),
+    // Test case 3: Don't fold a + (x * y) with vectors
    InstructionFoldingCase<bool>(
        Header() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[lx]] [[ly]] [[la]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
            "%main = OpFunction %void None %void_func\n" +
            "%main_lab = OpLabel\n" +
            "%x = OpVariable %_ptr_float Function\n" +
@@ -8042,46 +8320,8 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpStore %a %3\n" +
            "OpReturn\n" +
            "OpFunctionEnd",
-       3, true),
-    // Test 4: that the OpExtInstImport instruction is generated if it is missing.
-   InstructionFoldingCase<bool>(
-           std::string() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[lx]] [[ly]] [[la]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
-           "OpCapability Shader\n" +
-           "OpMemoryModel Logical GLSL450\n" +
-           "OpEntryPoint Fragment %main \"main\"\n" +
-           "OpExecutionMode %main OriginUpperLeft\n" +
-           "OpSource GLSL 140\n" +
-           "OpName %main \"main\"\n" +
-           "%void = OpTypeVoid\n" +
-           "%void_func = OpTypeFunction %void\n" +
-           "%bool = OpTypeBool\n" +
-           "%float = OpTypeFloat 32\n" +
-           "%_ptr_float = OpTypePointer Function %float\n" +
-           "%main = OpFunction %void None %void_func\n" +
-           "%main_lab = OpLabel\n" +
-           "%x = OpVariable %_ptr_float Function\n" +
-           "%y = OpVariable %_ptr_float Function\n" +
-           "%a = OpVariable %_ptr_float Function\n" +
-           "%lx = OpLoad %float %x\n" +
-           "%ly = OpLoad %float %y\n" +
-           "%mul = OpFMul %float %lx %ly\n" +
-           "%la = OpLoad %float %a\n" +
-           "%3 = OpFAdd %float %mul %la\n" +
-           "OpStore %a %3\n" +
-           "OpReturn\n" +
-           "OpFunctionEnd",
-       3, true),
-   // Test 5: Don't fold if the multiple is marked no contract.
+       3, false),
+   // Test 4: Don't fold if the multiple is marked no contract.
    InstructionFoldingCase<bool>(
        std::string() +
            "OpCapability Shader\n" +
@@ -8110,7 +8350,7 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpReturn\n" +
            "OpFunctionEnd",
        3, false),
-       // Test 6: Don't fold if the add is marked no contract.
+       // Test 5: Don't fold if the add is marked no contract.
        InstructionFoldingCase<bool>(
            std::string() +
                "OpCapability Shader\n" +
@@ -8139,20 +8379,9 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
                "OpReturn\n" +
                "OpFunctionEnd",
            3, false),
-    // Test case 7: (x * y) - a = Fma(x, y, -a)
+    // Test case 6: Don't fold (x * y) - a
     InstructionFoldingCase<bool>(
        Header() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[na:%\\w+]] = OpFNegate {{%\\w+}} [[la]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[lx]] [[ly]] [[na]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
            "%main = OpFunction %void None %void_func\n" +
            "%main_lab = OpLabel\n" +
            "%x = OpVariable %_ptr_float Function\n" +
@@ -8166,21 +8395,10 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpStore %a %3\n" +
            "OpReturn\n" +
            "OpFunctionEnd",
-       3, true),
-   // Test case 8: a - (x * y) = Fma(-x, y, a)
+       3, false),
+   // Test case 7: Don't fold a - (x * y)
    InstructionFoldingCase<bool>(
        Header() +
-           "; CHECK: [[ext:%\\w+]] = OpExtInstImport \"GLSL.std.450\"\n" +
-           "; CHECK: OpFunction\n" +
-           "; CHECK: [[x:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[y:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[a:%\\w+]] = OpVariable {{%\\w+}} Function\n" +
-           "; CHECK: [[lx:%\\w+]] = OpLoad {{%\\w+}} [[x]]\n" +
-           "; CHECK: [[ly:%\\w+]] = OpLoad {{%\\w+}} [[y]]\n" +
-           "; CHECK: [[la:%\\w+]] = OpLoad {{%\\w+}} [[a]]\n" +
-           "; CHECK: [[nx:%\\w+]] = OpFNegate {{%\\w+}} [[lx]]\n" +
-           "; CHECK: [[fma:%\\w+]] = OpExtInst {{%\\w+}} [[ext]] Fma [[nx]] [[ly]] [[la]]\n" +
-           "; CHECK: OpStore {{%\\w+}} [[fma]]\n" +
            "%main = OpFunction %void None %void_func\n" +
            "%main_lab = OpLabel\n" +
            "%x = OpVariable %_ptr_float Function\n" +
@@ -8194,7 +8412,7 @@ INSTANTIATE_TEST_SUITE_P(FmaGenerationMatchingTest, MatchingInstructionFoldingTe
            "OpStore %a %3\n" +
            "OpReturn\n" +
            "OpFunctionEnd",
-       3, true)
+       3, false)
 ));
 
 using MatchingInstructionWithNoResultFoldingTest =
diff --git a/test/opt/inline_test.cpp b/test/opt/inline_test.cpp
index 1e5d9f3b..ef7ac37d 100644
--- a/test/opt/inline_test.cpp
+++ b/test/opt/inline_test.cpp
@@ -3749,13 +3749,13 @@ float4 main(float4 color : COLOR) : SV_TARGET {
       %color = OpFunctionParameter %_ptr_Function_v4float
    %bb_entry = OpLabel
         %140 = OpExtInst %void %1 DebugFunctionDefinition %22 %src_main
-        %141 = OpExtInst %void %1 DebugLine %5 %uint_1 %uint_1 %uint_1 %uint_1
+        %141 = OpExtInst %void %1 DebugLine %15 %uint_1 %uint_1 %uint_1 %uint_1
          %34 = OpExtInst %void %1 DebugScope %22
          %36 = OpExtInst %void %1 DebugDeclare %25 %color %13
          %38 = OpExtInst %void %1 DebugScope %26
-        %142 = OpExtInst %void %1 DebugLine %5 %uint_2 %uint_2 %uint_10 %uint_10
+        %142 = OpExtInst %void %1 DebugLine %15 %uint_2 %uint_2 %uint_10 %uint_10
          %39 = OpLoad %v4float %color
-        %143 = OpExtInst %void %1 DebugLine %5 %uint_2 %uint_2 %uint_3 %uint_3
+        %143 = OpExtInst %void %1 DebugLine %15 %uint_2 %uint_2 %uint_3 %uint_3
                OpReturnValue %39
                OpFunctionEnd
 )";
@@ -4422,6 +4422,55 @@ OpFunctionEnd
   SinglePassRunAndMatch<InlineExhaustivePass>(text, true);
 }
 
+TEST_F(InlineTest, DecorateReturnVariableWithAliasedPointer) {
+  const std::string text = R"(OpCapability Int64
+               OpCapability VariablePointers
+               OpCapability PhysicalStorageBufferAddresses
+               OpCapability Shader
+               OpExtension "SPV_KHR_storage_buffer_storage_class"
+               OpExtension "SPV_KHR_variable_pointers"
+               OpExtension "SPV_KHR_physical_storage_buffer"
+               OpMemoryModel PhysicalStorageBuffer64 GLSL450
+               OpEntryPoint GLCompute %1 "main"
+               OpExecutionMode %1 LocalSize 8 8 1
+               OpDecorate %_ptr_PhysicalStorageBuffer__struct_5 ArrayStride 8
+               OpMemberDecorate %_struct_3 0 Offset 0
+               OpMemberDecorate %_struct_3 1 Offset 8
+               OpDecorate %_ptr_PhysicalStorageBuffer_int ArrayStride 4
+               OpMemberDecorate %_struct_5 0 Offset 0
+               OpMemberDecorate %_struct_5 1 Offset 4
+               OpDecorate %6 Aliased
+; CHECK:       OpDecorate %22 AliasedPointer
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+               OpTypeForwardPointer %_ptr_PhysicalStorageBuffer__struct_5 PhysicalStorageBuffer
+  %_struct_3 = OpTypeStruct %int %_ptr_PhysicalStorageBuffer__struct_5
+%_ptr_PhysicalStorageBuffer_int = OpTypePointer PhysicalStorageBuffer %int
+  %_struct_5 = OpTypeStruct %int %int
+         %11 = OpTypeFunction %_ptr_PhysicalStorageBuffer_int %_ptr_PhysicalStorageBuffer__struct_5
+%_ptr_PhysicalStorageBuffer__struct_5 = OpTypePointer PhysicalStorageBuffer %_struct_5
+%_ptr_Function__struct_3 = OpTypePointer Function %_struct_3
+          %1 = OpFunction %void None %8
+         %13 = OpLabel
+         %14 = OpVariable %_ptr_Function__struct_3 Function
+         %15 = OpLoad %_struct_3 %14
+         %16 = OpCompositeExtract %_ptr_PhysicalStorageBuffer__struct_5 %15 1
+         %17 = OpFunctionCall %_ptr_PhysicalStorageBuffer_int %18 %16
+               OpReturn
+               OpFunctionEnd
+         %18 = OpFunction %_ptr_PhysicalStorageBuffer_int None %11
+          %6 = OpFunctionParameter %_ptr_PhysicalStorageBuffer__struct_5
+         %19 = OpLabel
+         %20 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %6 %int_0
+               OpReturnValue %20
+               OpFunctionEnd)";
+
+  SetTargetEnv(SPV_ENV_VULKAN_1_2);
+  SinglePassRunAndMatch<InlineExhaustivePass>(text, true);
+}
+
 // TODO(greg-lunarg): Add tests to verify handling of these cases:
 //
 //    Empty modules
diff --git a/test/opt/inst_bindless_check_test.cpp b/test/opt/inst_bindless_check_test.cpp
deleted file mode 100644
index 08da367f..00000000
--- a/test/opt/inst_bindless_check_test.cpp
+++ /dev/null
@@ -1,5312 +0,0 @@
-// Copyright (c) 2017-2022 Valve Corporation
-// Copyright (c) 2017-2022 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Bindless Check Instrumentation Tests.
-
-#include <string>
-#include <vector>
-
-#include "test/opt/pass_fixture.h"
-#include "test/opt/pass_utils.h"
-
-namespace spvtools {
-namespace opt {
-namespace {
-
-using InstBindlessTest = PassTest<::testing::Test>;
-
-static const std::string kFuncName = "inst_bindless_check_desc";
-
-static const std::string kImportDeco = R"(
-;CHECK: OpDecorate %)" + kFuncName + R"( LinkageAttributes ")" +
-                                       kFuncName + R"(" Import
-)";
-
-static const std::string kImportStub = R"(
-;CHECK: %)" + kFuncName + R"( = OpFunction %bool None {{%\w+}}
-;CHECK: OpFunctionEnd
-)";
-
-TEST_F(InstBindlessTest, Simple) {
-  // Texture2D g_tColor[128];
-  //
-  // layout(push_constant) cbuffer PerViewConstantBuffer_t
-  // {
-  //   uint g_nDataIdx;
-  // };
-  //
-  // SamplerState g_sAniso;
-  //
-  // struct PS_INPUT
-  // {
-  //   float2 vTextureCoords : TEXCOORD2;
-  // };
-  //
-  // struct PS_OUTPUT
-  // {
-  //   float4 vColor : SV_Target0;
-  // };
-  //
-  // PS_OUTPUT MainPs(PS_INPUT i)
-  // {
-  //   PS_OUTPUT ps_output;
-  //   ps_output.vColor =
-  //       g_tColor[ g_nDataIdx ].Sample(g_sAniso, i.vTextureCoords.xy);
-  //   return ps_output;
-  // }
-
-  const std::string entry = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-)";
-
-  // clang-format off
-  const std::string names_annots = R"(
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 3
-OpDecorate %g_tColor Binding 0
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %g_sAniso DescriptorSet 0
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0)"
-+ kImportDeco +
-R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-)";
-
-  const std::string consts_types_vars = R"(
-%void = OpTypeVoid
-%10 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%16 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_16_uint_128 = OpTypeArray %16 %uint_128
-%_ptr_UniformConstant__arr_16_uint_128 = OpTypePointer UniformConstant %_arr_16_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_16_uint_128 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_16 = OpTypePointer UniformConstant %16
-%24 = OpTypeSampler
-%_ptr_UniformConstant_24 = OpTypePointer UniformConstant %24
-%g_sAniso = OpVariable %_ptr_UniformConstant_24 UniformConstant
-%26 = OpTypeSampledImage %16
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %10
-%29 = OpLabel
-%30 = OpLoad %v2float %i_vTextureCoords
-%31 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%32 = OpLoad %uint %31
-%33 = OpAccessChain %_ptr_UniformConstant_16 %g_tColor %32
-%34 = OpLoad %16 %33
-%35 = OpLoad %24 %g_sAniso
-%36 = OpSampledImage %26 %34 %35
-%37 = OpImageSampleImplicitLod %v4float %36 %30
-OpStore %_entryPointOutput_vColor %37
-;CHECK-NOT: %37 = OpImageSampleImplicitLod %v4float %36 %30
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %37
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_57 {{%\w+}} %uint_3 %uint_0 %32 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %16 %33
-;CHECK: {{%\w+}} = OpSampledImage %26 {{%\w+}} %35
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %30
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(
-      entry + names_annots + consts_types_vars + kImportStub + main_func, true,
-      23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentMultipleInstructions) {
-  // Texture2D g_tColor[128];
-  //
-  // layout(push_constant) cbuffer PerViewConstantBuffer_t
-  // {
-  //   uint g_nDataIdx;
-  //   uint g_nDataIdx2;
-  // };
-  //
-  // SamplerState g_sAniso;
-  //
-  // struct PS_INPUT
-  // {
-  //   float2 vTextureCoords : TEXCOORD2;
-  // };
-  //
-  // struct PS_OUTPUT
-  // {
-  //   float4 vColor : SV_Target0;
-  // };
-  //
-  // PS_OUTPUT MainPs(PS_INPUT i)
-  // {
-  //   PS_OUTPUT ps_output;
-  //
-  //   float t  = g_tColor[g_nDataIdx ].Sample(g_sAniso, i.vTextureCoords.xy);
-  //   float t2 = g_tColor[g_nDataIdx2].Sample(g_sAniso, i.vTextureCoords.xy);
-  //   ps_output.vColor = t + t2;
-  //   return ps_output;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 3
-OpDecorate %g_tColor Binding 4
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpMemberDecorate %PerViewConstantBuffer_t 1 Offset 4
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %g_sAniso DescriptorSet 3
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%10 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%int_1 = OpConstant %int 1
-%17 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_17_uint_128 = OpTypeArray %17 %uint_128
-%_ptr_UniformConstant__arr_17_uint_128 = OpTypePointer UniformConstant %_arr_17_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_17_uint_128 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_17 = OpTypePointer UniformConstant %17
-%25 = OpTypeSampler
-%_ptr_UniformConstant_25 = OpTypePointer UniformConstant %25
-%g_sAniso = OpVariable %_ptr_UniformConstant_25 UniformConstant
-%27 = OpTypeSampledImage %17
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %10
-%30 = OpLabel
-%31 = OpLoad %v2float %i_vTextureCoords
-%32 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%33 = OpLoad %uint %32
-%34 = OpAccessChain %_ptr_UniformConstant_17 %g_tColor %33
-%35 = OpLoad %17 %34
-%36 = OpLoad %25 %g_sAniso
-%37 = OpSampledImage %27 %35 %36
-%38 = OpImageSampleImplicitLod %v4float %37 %31
-;CHECK-NOT: %38 = OpImageSampleImplicitLod %v4float %37 %31
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_60 {{%\w+}} %uint_3 %uint_4 %33 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %17 %34
-;CHECK: {{%\w+}} = OpSampledImage %27 {{%\w+}} %36
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %31
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-%39 = OpAccessChain %_ptr_PushConstant_uint %_ %int_1
-%40 = OpLoad %uint %39
-%41 = OpAccessChain %_ptr_UniformConstant_17 %g_tColor %40
-%42 = OpLoad %17 %41
-%43 = OpSampledImage %27 %42 %36
-%44 = OpImageSampleImplicitLod %v4float %43 %31
-%45 = OpFAdd %v4float %38 %44
-;CHECK-NOT: %44 = OpImageSampleImplicitLod %v4float %43 %31
-;CHECK-NOT: %45 = OpFAdd %v4float %38 %44
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_66 {{%\w+}} %uint_3 %uint_4 %40 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %17 %41
-;CHECK: {{%\w+}} = OpSampledImage %27 {{%\w+}} %36
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %31
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: %45 = OpFAdd %v4float {{%\w+}} {{%\w+}}
-OpStore %_entryPointOutput_vColor %45
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentOpImage) {
-  // This test verifies that the pass will correctly instrument shader
-  // using OpImage. This test was created by editing the SPIR-V
-  // from the Simple test.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability StorageImageReadWithoutFormat
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 3
-OpDecorate %g_tColor Binding 9
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%v2int = OpTypeVector %int 2
-%int_0 = OpConstant %int 0
-%20 = OpTypeImage %float 2D 0 0 0 0 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%39 = OpTypeSampledImage %20
-%_arr_39_uint_128 = OpTypeArray %39 %uint_128
-%_ptr_UniformConstant__arr_39_uint_128 = OpTypePointer UniformConstant %_arr_39_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_39_uint_128 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_39 = OpTypePointer UniformConstant %39
-%_ptr_Input_v2int = OpTypePointer Input %v2int
-%i_vTextureCoords = OpVariable %_ptr_Input_v2int Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%53 = OpLoad %v2int %i_vTextureCoords
-%63 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%64 = OpLoad %uint %63
-%65 = OpAccessChain %_ptr_UniformConstant_39 %g_tColor %64
-%66 = OpLoad %39 %65
-%75 = OpImage %20 %66
-%71 = OpImageRead %v4float %75 %53
-OpStore %_entryPointOutput_vColor %71
-;CHECK-NOT: %71 = OpImageRead %v4float %75 %53
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %71
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_3 %uint_9 %64 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %39 %65
-;CHECK: {{%\w+}} = OpImage %20 {{%\w+}}
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %53
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentSampledImage) {
-  // This test verifies that the pass will correctly instrument shader
-  // using sampled image. This test was created by editing the SPIR-V
-  // from the Simple test.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 4
-OpDecorate %g_tColor Binding 11
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%20 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%39 = OpTypeSampledImage %20
-%_arr_39_uint_128 = OpTypeArray %39 %uint_128
-%_ptr_UniformConstant__arr_39_uint_128 = OpTypePointer UniformConstant %_arr_39_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_39_uint_128 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_39 = OpTypePointer UniformConstant %39
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%53 = OpLoad %v2float %i_vTextureCoords
-%63 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%64 = OpLoad %uint %63
-%65 = OpAccessChain %_ptr_UniformConstant_39 %g_tColor %64
-%66 = OpLoad %39 %65
-%71 = OpImageSampleImplicitLod %v4float %66 %53
-OpStore %_entryPointOutput_vColor %71
-;CHECK-NOT: %71 = OpImageSampleImplicitLod %v4float %66 %53
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %71
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_50 {{%\w+}} %uint_4 %uint_11 %64 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %39 %65
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %53
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentImageWrite) {
-  // This test verifies that the pass will correctly instrument shader
-  // doing bindless image write. This test was created by editing the SPIR-V
-  // from the Simple test.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability StorageImageWriteWithoutFormat
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 30
-OpDecorate %g_tColor Binding 2
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%v2int = OpTypeVector %int 2
-%int_0 = OpConstant %int 0
-%20 = OpTypeImage %float 2D 0 0 0 0 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%80 = OpConstantNull %v4float
-%_arr_20_uint_128 = OpTypeArray %20 %uint_128
-%_ptr_UniformConstant__arr_20_uint_128 = OpTypePointer UniformConstant %_arr_20_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_20_uint_128 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
-%_ptr_Input_v2int = OpTypePointer Input %v2int
-%i_vTextureCoords = OpVariable %_ptr_Input_v2int Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%53 = OpLoad %v2int %i_vTextureCoords
-%63 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%64 = OpLoad %uint %63
-%65 = OpAccessChain %_ptr_UniformConstant_20 %g_tColor %64
-%66 = OpLoad %20 %65
-OpImageWrite %66 %53 %80
-OpStore %_entryPointOutput_vColor %80
-;CHECK-NOT: OpImageWrite %66 %53 %80
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %80
-;CHECK: %32 = OpLoad %16 %31
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_30 %uint_2 %30 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %16 %31
-;CHECK: OpImageWrite {{%\w+}} %28 %19
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %_entryPointOutput_vColor %19
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentVertexSimple) {
-  // This test verifies that the pass will correctly instrument shader
-  // doing bindless image write. This test was created by editing the SPIR-V
-  // from the Simple test.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability Sampled1D
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Vertex %main "main" %_ %coords2D
-OpSource GLSL 450
-OpName %main "main"
-OpName %lod "lod"
-OpName %coords1D "coords1D"
-OpName %gl_PerVertex "gl_PerVertex"
-OpMemberName %gl_PerVertex 0 "gl_Position"
-OpMemberName %gl_PerVertex 1 "gl_PointSize"
-OpMemberName %gl_PerVertex 2 "gl_ClipDistance"
-OpMemberName %gl_PerVertex 3 "gl_CullDistance"
-OpName %_ ""
-OpName %texSampler1D "texSampler1D"
-OpName %foo "foo"
-OpMemberName %foo 0 "g_idx"
-OpName %__0 ""
-OpName %coords2D "coords2D"
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_VertexIndex BuiltIn VertexIndex
-;CHECK: OpDecorate %gl_InstanceIndex BuiltIn InstanceIndex
-OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
-OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
-OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
-OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
-OpDecorate %gl_PerVertex Block
-OpDecorate %texSampler1D DescriptorSet 2
-OpDecorate %texSampler1D Binding 13
-OpMemberDecorate %foo 0 Offset 0
-OpDecorate %foo Block
-OpDecorate %__0 DescriptorSet 7
-OpDecorate %__0 Binding 5
-OpDecorate %coords2D Location 0
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Function_float = OpTypePointer Function %float
-%float_3 = OpConstant %float 3
-%float_1_78900003 = OpConstant %float 1.78900003
-%v4float = OpTypeVector %float 4
-%uint = OpTypeInt 32 0
-%uint_1 = OpConstant %uint 1
-%_arr_float_uint_1 = OpTypeArray %float %uint_1
-%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
-%_ptr_Output_gl_PerVertex = OpTypePointer Output %gl_PerVertex
-%_ = OpVariable %_ptr_Output_gl_PerVertex Output
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%21 = OpTypeImage %float 1D 0 0 0 1 Unknown
-%22 = OpTypeSampledImage %21
-%uint_128 = OpConstant %uint 128
-%_arr_22_uint_128 = OpTypeArray %22 %uint_128
-%_ptr_UniformConstant__arr_22_uint_128 = OpTypePointer UniformConstant %_arr_22_uint_128
-%texSampler1D = OpVariable %_ptr_UniformConstant__arr_22_uint_128 UniformConstant
-%foo = OpTypeStruct %int
-%_ptr_Uniform_foo = OpTypePointer Uniform %foo
-%__0 = OpVariable %_ptr_Uniform_foo Uniform
-%_ptr_Uniform_int = OpTypePointer Uniform %int
-%_ptr_UniformConstant_22 = OpTypePointer UniformConstant %22
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%v2float = OpTypeVector %float 2
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%coords2D = OpVariable %_ptr_Input_v2float Input
-;CHECK: %_ptr_Input_uint = OpTypePointer Input %uint
-;CHECK: %gl_VertexIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: %gl_InstanceIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%lod = OpVariable %_ptr_Function_float Function
-%coords1D = OpVariable %_ptr_Function_float Function
-OpStore %lod %float_3
-OpStore %coords1D %float_1_78900003
-%31 = OpAccessChain %_ptr_Uniform_int %__0 %int_0
-%32 = OpLoad %int %31
-%34 = OpAccessChain %_ptr_UniformConstant_22 %texSampler1D %32
-%35 = OpLoad %22 %34
-%36 = OpLoad %float %coords1D
-%37 = OpLoad %float %lod
-%38 = OpImageSampleExplicitLod %v4float %35 %36 Lod %37
-%40 = OpAccessChain %_ptr_Output_v4float %_ %int_0
-OpStore %40 %38
-;CHECK-NOT: %38 = OpImageSampleExplicitLod %v4float %35 %36 Lod %37
-;CHECK-NOT: %40 = OpAccessChain %_ptr_Output_v4float %_ %int_0
-;CHECK-NOT: OpStore %40 %38
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_70 {{%\w+}} %uint_7 %uint_5 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %int {{%\w+}}
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %int {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_UniformConstant_25 %texSampler1D {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %float %coords1D
-;CHECK: {{%\w+}} = OpLoad %float %lod
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_75 {{%\w+}} %uint_2 %uint_13 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %25 %38
-;CHECK: {{%\w+}} = OpImageSampleExplicitLod %v4float {{%\w+}} %40 Lod %41
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: %43 = OpAccessChain %_ptr_Output_v4float %_ %int_0
-;CHECK: OpStore %43 {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentTeseSimple) {
-  // This test verifies that the pass will correctly instrument tessellation
-  // evaluation shader doing bindless buffer load.
-  //
-  // clang-format off
-  //
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(std140, set = 9, binding = 1) uniform ufoo { uint index; } uniform_index_buffer;
-  //
-  // layout(set = 9, binding = 2) buffer bfoo { vec4 val; } adds[11];
-  //
-  // layout(triangles, equal_spacing, cw) in;
-  //
-  // void main() {
-  //   gl_Position = adds[uniform_index_buffer.index].val;
-  // }
-  //
-
-  const std::string defs = R"(
-OpCapability Tessellation
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint TessellationEvaluation %main "main" %_
-;CHECK: OpEntryPoint TessellationEvaluation %main "main" %_ %gl_PrimitiveID %gl_TessCoord
-OpExecutionMode %main Triangles
-OpExecutionMode %main SpacingEqual
-OpExecutionMode %main VertexOrderCw
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %gl_PerVertex "gl_PerVertex"
-OpMemberName %gl_PerVertex 0 "gl_Position"
-OpMemberName %gl_PerVertex 1 "gl_PointSize"
-OpMemberName %gl_PerVertex 2 "gl_ClipDistance"
-OpMemberName %gl_PerVertex 3 "gl_CullDistance"
-OpName %_ ""
-OpName %bfoo "bfoo"
-OpMemberName %bfoo 0 "val"
-OpName %adds "adds"
-OpName %ufoo "ufoo"
-OpMemberName %ufoo 0 "index"
-OpName %uniform_index_buffer "uniform_index_buffer"
-OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
-OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
-OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
-OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
-OpDecorate %gl_PerVertex Block
-OpMemberDecorate %bfoo 0 Offset 0
-OpDecorate %bfoo Block
-OpDecorate %adds DescriptorSet 9
-OpDecorate %adds Binding 1
-OpMemberDecorate %ufoo 0 Offset 0
-OpDecorate %ufoo Block
-OpDecorate %uniform_index_buffer DescriptorSet 9
-OpDecorate %uniform_index_buffer Binding 2
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_PrimitiveID BuiltIn PrimitiveId
-;CHECK: OpDecorate %gl_TessCoord BuiltIn TessCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v4float = OpTypeVector %float 4
-%uint = OpTypeInt 32 0
-%uint_1 = OpConstant %uint 1
-%_arr_float_uint_1 = OpTypeArray %float %uint_1
-%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
-%_ptr_Output_gl_PerVertex = OpTypePointer Output %gl_PerVertex
-%_ = OpVariable %_ptr_Output_gl_PerVertex Output
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%bfoo = OpTypeStruct %v4float
-%uint_11 = OpConstant %uint 11
-%_arr_bfoo_uint_11 = OpTypeArray %bfoo %uint_11
-%_ptr_StorageBuffer__arr_bfoo_uint_11 = OpTypePointer StorageBuffer %_arr_bfoo_uint_11
-%adds = OpVariable %_ptr_StorageBuffer__arr_bfoo_uint_11 StorageBuffer
-%ufoo = OpTypeStruct %uint
-%_ptr_Uniform_ufoo = OpTypePointer Uniform %ufoo
-%uniform_index_buffer = OpVariable %_ptr_Uniform_ufoo Uniform
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_StorageBuffer_v4float = OpTypePointer StorageBuffer %v4float
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-;CHECK: %_ptr_Input_uint = OpTypePointer Input %uint
-;CHECK: %gl_PrimitiveID = OpVariable %_ptr_Input_uint Input
-;CHECK: %v3float = OpTypeVector %float 3
-;CHECK: %_ptr_Input_v3float = OpTypePointer Input %v3float
-;CHECK: %gl_TessCoord = OpVariable %_ptr_Input_v3float Input
-;CHECK: %v3uint = OpTypeVector %uint 3
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func =
-      R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%25 = OpAccessChain %_ptr_Uniform_uint %uniform_index_buffer %int_0
-%26 = OpLoad %uint %25
-%28 = OpAccessChain %_ptr_StorageBuffer_v4float %adds %26 %int_0
-%29 = OpLoad %v4float %28
-;CHECK-NOT: %29 = OpLoad %v4float %28
-;CHECK: {{%\w+}} = OpLoad %uint %gl_PrimitiveID
-;CHECK: {{%\w+}} = OpLoad %v3float %gl_TessCoord
-;CHECK: {{%\w+}} = OpBitcast %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_2 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_62 {{%\w+}} %uint_9 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %27
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %uint {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-%31 = OpAccessChain %_ptr_Output_v4float %_ %int_0
-OpStore %31 %29
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %uint %gl_PrimitiveID
-;CHECK: {{%\w+}} = OpLoad %v3float %gl_TessCoord
-;CHECK: {{%\w+}} = OpBitcast %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_2 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_64 {{%\w+}} %uint_9 %uint_1 {{%\w+}} {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v4float %29
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: %31 = OpAccessChain %_ptr_Output_v4float %_ %int_0
-;CHECK: OpStore %31 [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentTesc) {
-  // This test verifies that the pass will correctly instrument tessellation
-  // control shader
-  //
-  // clang-format off
-  //
-  // #version 450
-  // layout(vertices = 3) out;
-  // layout(set = 0, binding = 0) uniform texture1D _77;
-  // layout(set = 0, binding = 1) uniform sampler _78;
-
-  // layout(location = 1) flat in int _3[];
-  // layout(location = 0) out vec4 _5[3];
-
-  // void main()
-  // {
-  //     float param;
-  //     if (_3[gl_InvocationID] == 0)
-  //     {
-  //         param = 0.0234375;
-  //     }
-  //     else
-  //     {
-  //         param = 1.0156199932098388671875;
-  //     }
-  //     _5[gl_InvocationID] = textureLod(sampler1D(_77, _78), param, 0.0);
-  //     vec4 _203;
-  //     if (gl_InvocationID == 0)
-  //     {
-  //         _203 = gl_in[0].gl_Position;
-  //     }
-  //     else
-  //     {
-  //         _203 = gl_in[2].gl_Position;
-  //     }
-  //     gl_out[gl_InvocationID].gl_Position = _203;
-  //     gl_TessLevelInner[0] = 2.7999999523162841796875;
-  //     gl_TessLevelInner[1] = 2.7999999523162841796875;
-  //     gl_TessLevelOuter[0] = 2.7999999523162841796875;
-  //     gl_TessLevelOuter[1] = 2.7999999523162841796875;
-  //     gl_TessLevelOuter[2] = 2.7999999523162841796875;
-  //     gl_TessLevelOuter[3] = 2.7999999523162841796875;
-  // }
-  //
-  // clang-format on
-  //
-  //
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Tessellation
-OpCapability Sampled1D
-;CHECK: OpCapability Linkage
-;CHECK: OpExtension "SPV_KHR_storage_buffer_storage_class"
-;CHECK: OpExtension "SPV_KHR_physical_storage_buffer"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-;CHECK: OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint TessellationControl %main "main" %_3 %gl_InvocationID %_5 %gl_in %gl_out %gl_TessLevelInner %gl_TessLevelOuter
-;CHECK: OpEntryPoint TessellationControl %main "main" %_3 %gl_InvocationID %_5 %gl_in %gl_out %gl_TessLevelInner %gl_TessLevelOuter %gl_PrimitiveID
-OpExecutionMode %main OutputVertices 3
-OpSource GLSL 450
-OpName %main "main"
-OpName %_3 "_3"
-OpName %gl_InvocationID "gl_InvocationID"
-OpName %param "param"
-OpName %_5 "_5"
-OpName %_77 "_77"
-OpName %_78 "_78"
-OpName %_203 "_203"
-OpName %gl_PerVertex "gl_PerVertex"
-OpMemberName %gl_PerVertex 0 "gl_Position"
-OpMemberName %gl_PerVertex 1 "gl_PointSize"
-OpMemberName %gl_PerVertex 2 "gl_ClipDistance"
-OpMemberName %gl_PerVertex 3 "gl_CullDistance"
-OpName %gl_in "gl_in"
-OpName %gl_PerVertex_0 "gl_PerVertex"
-OpMemberName %gl_PerVertex_0 0 "gl_Position"
-OpMemberName %gl_PerVertex_0 1 "gl_PointSize"
-OpMemberName %gl_PerVertex_0 2 "gl_ClipDistance"
-OpMemberName %gl_PerVertex_0 3 "gl_CullDistance"
-OpName %gl_out "gl_out"
-OpName %gl_TessLevelInner "gl_TessLevelInner"
-OpName %gl_TessLevelOuter "gl_TessLevelOuter"
-OpDecorate %_3 Flat
-OpDecorate %_3 Location 1
-OpDecorate %gl_InvocationID BuiltIn InvocationId
-OpDecorate %_5 Location 0
-OpDecorate %_77 DescriptorSet 0
-OpDecorate %_77 Binding 0
-OpDecorate %_78 DescriptorSet 0
-OpDecorate %_78 Binding 1
-OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
-OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
-OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
-OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
-OpDecorate %gl_PerVertex Block
-OpMemberDecorate %gl_PerVertex_0 0 BuiltIn Position
-OpMemberDecorate %gl_PerVertex_0 1 BuiltIn PointSize
-OpMemberDecorate %gl_PerVertex_0 2 BuiltIn ClipDistance
-OpMemberDecorate %gl_PerVertex_0 3 BuiltIn CullDistance
-OpDecorate %gl_PerVertex_0 Block
-OpDecorate %gl_TessLevelInner Patch
-OpDecorate %gl_TessLevelInner BuiltIn TessLevelInner
-OpDecorate %gl_TessLevelOuter Patch
-OpDecorate %gl_TessLevelOuter BuiltIn TessLevelOuter
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%int = OpTypeInt 32 1
-%uint = OpTypeInt 32 0
-%uint_32 = OpConstant %uint 32
-%_arr_int_uint_32 = OpTypeArray %int %uint_32
-%_ptr_Input__arr_int_uint_32 = OpTypePointer Input %_arr_int_uint_32
-%_3 = OpVariable %_ptr_Input__arr_int_uint_32 Input
-%_ptr_Input_int = OpTypePointer Input %int
-%gl_InvocationID = OpVariable %_ptr_Input_int Input
-%int_0 = OpConstant %int 0
-%bool = OpTypeBool
-%float = OpTypeFloat 32
-%_ptr_Function_float = OpTypePointer Function %float
-%float_0_0234375 = OpConstant %float 0.0234375
-%float_1_01561999 = OpConstant %float 1.01561999
-%v4float = OpTypeVector %float 4
-%uint_3 = OpConstant %uint 3
-%_arr_v4float_uint_3 = OpTypeArray %v4float %uint_3
-%_ptr_Output__arr_v4float_uint_3 = OpTypePointer Output %_arr_v4float_uint_3
-%_5 = OpVariable %_ptr_Output__arr_v4float_uint_3 Output
-%34 = OpTypeImage %float 1D 0 0 0 1 Unknown
-%_ptr_UniformConstant_34 = OpTypePointer UniformConstant %34
-%_77 = OpVariable %_ptr_UniformConstant_34 UniformConstant
-%38 = OpTypeSampler
-%_ptr_UniformConstant_38 = OpTypePointer UniformConstant %38
-%_78 = OpVariable %_ptr_UniformConstant_38 UniformConstant
-%42 = OpTypeSampledImage %34
-%float_0 = OpConstant %float 0
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_ptr_Function_v4float = OpTypePointer Function %v4float
-%uint_1 = OpConstant %uint 1
-%_arr_float_uint_1 = OpTypeArray %float %uint_1
-%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
-%_arr_gl_PerVertex_uint_32 = OpTypeArray %gl_PerVertex %uint_32
-%_ptr_Input__arr_gl_PerVertex_uint_32 = OpTypePointer Input %_arr_gl_PerVertex_uint_32
-%gl_in = OpVariable %_ptr_Input__arr_gl_PerVertex_uint_32 Input
-%_ptr_Input_v4float = OpTypePointer Input %v4float
-%int_2 = OpConstant %int 2
-%gl_PerVertex_0 = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
-%_arr_gl_PerVertex_0_uint_3 = OpTypeArray %gl_PerVertex_0 %uint_3
-%_ptr_Output__arr_gl_PerVertex_0_uint_3 = OpTypePointer Output %_arr_gl_PerVertex_0_uint_3
-%gl_out = OpVariable %_ptr_Output__arr_gl_PerVertex_0_uint_3 Output
-%uint_2 = OpConstant %uint 2
-%_arr_float_uint_2 = OpTypeArray %float %uint_2
-%_ptr_Output__arr_float_uint_2 = OpTypePointer Output %_arr_float_uint_2
-%gl_TessLevelInner = OpVariable %_ptr_Output__arr_float_uint_2 Output
-%float_2_79999995 = OpConstant %float 2.79999995
-%_ptr_Output_float = OpTypePointer Output %float
-%int_1 = OpConstant %int 1
-%uint_4 = OpConstant %uint 4
-%_arr_float_uint_4 = OpTypeArray %float %uint_4
-%_ptr_Output__arr_float_uint_4 = OpTypePointer Output %_arr_float_uint_4
-%gl_TessLevelOuter = OpVariable %_ptr_Output__arr_float_uint_4 Output
-%int_3 = OpConstant %int 3
-)";
-
-  const std::string main_func =
-      R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%param = OpVariable %_ptr_Function_float Function
-%_203 = OpVariable %_ptr_Function_v4float Function
-%14 = OpLoad %int %gl_InvocationID
-%15 = OpAccessChain %_ptr_Input_int %_3 %14
-%16 = OpLoad %int %15
-%19 = OpIEqual %bool %16 %int_0
-OpSelectionMerge %21 None
-OpBranchConditional %19 %20 %26
-%20 = OpLabel
-;CHECK-NOT: %15 = OpAccessChain %_ptr_Input_int %_3 %14
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %int %gl_InvocationID
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_Input_int %_3 {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %int {{%\w+}}
-;CHECK: {{%\w+}} = OpIEqual %bool {{%\w+}} %int_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpStore %param %float_0_0234375
-OpBranch %21
-%26 = OpLabel
-OpStore %param %float_1_01561999
-OpBranch %21
-%21 = OpLabel
-%33 = OpLoad %int %gl_InvocationID
-%37 = OpLoad %34 %_77
-%41 = OpLoad %38 %_78
-%43 = OpSampledImage %42 %37 %41
-%44 = OpLoad %float %param
-;CHECK: {{%\w+}} = OpLoad %int %gl_InvocationID
-;CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %uint %gl_PrimitiveID
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_1 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %inst_bindless_check_desc %uint_23 %uint_129 {{%\w+}} %uint_0 %uint_0 %uint_0 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-%46 = OpImageSampleExplicitLod %v4float %43 %44 Lod %float_0
-%48 = OpAccessChain %_ptr_Output_v4float %_5 %33
-OpStore %48 %46
-;CHECK-NOT: %48 = OpAccessChain %_ptr_Output_v4float %_5 %33
-;CHECK-NOT: OpStore %48 %46
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: [[access_chain:%\w+]] = OpAccessChain %_ptr_Output_v4float %_5 {{%\w+}}
-;CHECK: OpStore [[access_chain]] [[phi_result]]
-%49 = OpLoad %int %gl_InvocationID
-%50 = OpIEqual %bool %49 %int_0
-OpSelectionMerge %52 None
-OpBranchConditional %50 %51 %64
-%51 = OpLabel
-%62 = OpAccessChain %_ptr_Input_v4float %gl_in %int_0 %int_0
-%63 = OpLoad %v4float %62
-OpStore %_203 %63
-OpBranch %52
-%64 = OpLabel
-%66 = OpAccessChain %_ptr_Input_v4float %gl_in %int_2 %int_0
-%67 = OpLoad %v4float %66
-OpStore %_203 %67
-OpBranch %52
-%52 = OpLabel
-%72 = OpLoad %int %gl_InvocationID
-%73 = OpLoad %v4float %_203
-%74 = OpAccessChain %_ptr_Output_v4float %gl_out %72 %int_0
-OpStore %74 %73
-%81 = OpAccessChain %_ptr_Output_float %gl_TessLevelInner %int_0
-OpStore %81 %float_2_79999995
-%83 = OpAccessChain %_ptr_Output_float %gl_TessLevelInner %int_1
-OpStore %83 %float_2_79999995
-%88 = OpAccessChain %_ptr_Output_float %gl_TessLevelOuter %int_0
-OpStore %88 %float_2_79999995
-%89 = OpAccessChain %_ptr_Output_float %gl_TessLevelOuter %int_1
-OpStore %89 %float_2_79999995
-%90 = OpAccessChain %_ptr_Output_float %gl_TessLevelOuter %int_2
-OpStore %90 %float_2_79999995
-%92 = OpAccessChain %_ptr_Output_float %gl_TessLevelOuter %int_3
-OpStore %92 %float_2_79999995
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, MultipleDebugFunctions) {
-  // Same source as Simple, but compiled -g and not optimized, especially not
-  // inlined. The OpSource has had the source extracted for the sake of brevity.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%2 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-%1 = OpString "foo5.frag"
-OpSource HLSL 500 %1
-OpName %MainPs "MainPs"
-OpName %PS_INPUT "PS_INPUT"
-OpMemberName %PS_INPUT 0 "vTextureCoords"
-OpName %PS_OUTPUT "PS_OUTPUT"
-OpMemberName %PS_OUTPUT 0 "vColor"
-OpName %_MainPs_struct_PS_INPUT_vf21_ "@MainPs(struct-PS_INPUT-vf21;"
-OpName %i "i"
-OpName %ps_output "ps_output"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %g_sAniso "g_sAniso"
-OpName %i_0 "i"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpName %param "param"
-OpDecorate %g_tColor DescriptorSet 1
-OpDecorate %g_tColor Binding 2
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %g_sAniso DescriptorSet 1
-OpDecorate %g_sAniso Binding 3
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%4 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%PS_INPUT = OpTypeStruct %v2float
-%_ptr_Function_PS_INPUT = OpTypePointer Function %PS_INPUT
-%v4float = OpTypeVector %float 4
-%PS_OUTPUT = OpTypeStruct %v4float
-%13 = OpTypeFunction %PS_OUTPUT %_ptr_Function_PS_INPUT
-%_ptr_Function_PS_OUTPUT = OpTypePointer Function %PS_OUTPUT
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%21 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_21_uint_128 = OpTypeArray %21 %uint_128
-%_ptr_UniformConstant__arr_21_uint_128 = OpTypePointer UniformConstant %_arr_21_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_21_uint_128 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
-%36 = OpTypeSampler
-%_ptr_UniformConstant_36 = OpTypePointer UniformConstant %36
-%g_sAniso = OpVariable %_ptr_UniformConstant_36 UniformConstant
-%40 = OpTypeSampledImage %21
-%_ptr_Function_v2float = OpTypePointer Function %v2float
-%_ptr_Function_v4float = OpTypePointer Function %v4float
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string func1 = R"(
-%MainPs = OpFunction %void None %4
-%6 = OpLabel
-%i_0 = OpVariable %_ptr_Function_PS_INPUT Function
-%param = OpVariable %_ptr_Function_PS_INPUT Function
-OpLine %1 21 0
-%54 = OpLoad %v2float %i_vTextureCoords
-%55 = OpAccessChain %_ptr_Function_v2float %i_0 %int_0
-OpStore %55 %54
-%59 = OpLoad %PS_INPUT %i_0
-OpStore %param %59
-%60 = OpFunctionCall %PS_OUTPUT %_MainPs_struct_PS_INPUT_vf21_ %param
-%61 = OpCompositeExtract %v4float %60 0
-OpStore %_entryPointOutput_vColor %61
-OpReturn
-OpFunctionEnd
-)";
-
-  const std::string func2 = R"(
-%_MainPs_struct_PS_INPUT_vf21_ = OpFunction %PS_OUTPUT None %13
-%i = OpFunctionParameter %_ptr_Function_PS_INPUT
-%16 = OpLabel
-%ps_output = OpVariable %_ptr_Function_PS_OUTPUT Function
-OpLine %1 24 0
-%31 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%32 = OpLoad %uint %31
-%34 = OpAccessChain %_ptr_UniformConstant_21 %g_tColor %32
-%35 = OpLoad %21 %34
-%39 = OpLoad %36 %g_sAniso
-%41 = OpSampledImage %40 %35 %39
-%43 = OpAccessChain %_ptr_Function_v2float %i %int_0
-%44 = OpLoad %v2float %43
-%45 = OpImageSampleImplicitLod %v4float %41 %44
-;CHECK-NOT: %45 = OpImageSampleImplicitLod %v4float %41 %44
-;CHECK: {{%\w+}} = OpLoad %v2float {{%\w+}}
-;CHECK: OpNoLine
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_128 {{%\w+}} %uint_1 %uint_2 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %27 {{%\w+}}
-;CHECK: {{%\w+}} = OpSampledImage %37 {{%\w+}} {{%\w+}}
-;CHECK: OpLine %5 24 0
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} {{%\w+}}
-;CHECK: OpNoLine
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-%47 = OpAccessChain %_ptr_Function_v4float %ps_output %int_0
-OpStore %47 %45
-;CHECK-NOT: OpStore %47 %45
-;CHECK: [[store_loc:%\w+]] = OpAccessChain %_ptr_Function_v4float %ps_output %int_0
-;CHECK: OpStore [[store_loc]] [[phi_result]]
-OpLine %1 25 0
-%48 = OpLoad %PS_OUTPUT %ps_output
-OpReturnValue %48
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(
-      defs + kImportStub + func1 + func2, true, 23u);
-}
-
-TEST_F(InstBindlessTest, RuntimeArray) {
-  // This test verifies that the pass will correctly instrument shader
-  // with runtime descriptor array. This test was created by editing the
-  // SPIR-V from the Simple test.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability RuntimeDescriptorArray
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 1
-OpDecorate %g_tColor Binding 2
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %g_sAniso DescriptorSet 1
-OpDecorate %g_sAniso Binding 3
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%20 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_1 = OpConstant %uint 1
-%_rarr_20 = OpTypeRuntimeArray %20
-%_ptr_UniformConstant__arr_20 = OpTypePointer UniformConstant %_rarr_20
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_20 UniformConstant
-%PerViewConstantBuffer_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
-%35 = OpTypeSampler
-%_ptr_UniformConstant_35 = OpTypePointer UniformConstant %35
-%g_sAniso = OpVariable %_ptr_UniformConstant_35 UniformConstant
-%39 = OpTypeSampledImage %20
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%53 = OpLoad %v2float %i_vTextureCoords
-%63 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%64 = OpLoad %uint %63
-%65 = OpAccessChain %_ptr_UniformConstant_20 %g_tColor %64
-%66 = OpLoad %20 %65
-%67 = OpLoad %35 %g_sAniso
-%68 = OpSampledImage %39 %66 %67
-%71 = OpImageSampleImplicitLod %v4float %68 %53
-OpStore %_entryPointOutput_vColor %71
-;CHECK-NOT: %71 = OpImageSampleImplicitLod %v4float %68 %53
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %71
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[check_result:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_60 {{%\w+}} %uint_1 %uint_2 %32 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %16 %33
-;CHECK: {{%\w+}} = OpSampledImage %26 {{%\w+}} %35
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %30
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result_1:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor [[phi_result_1]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstrumentInitCheckOnScalarDescriptor) {
-  // This test verifies that the pass will correctly instrument vanilla
-  // texture sample on a scalar descriptor with an initialization check if the
-  // input_init_enable argument is set to true. This can happen when the
-  // descriptor indexing extension is enabled in the API but the SPIR-V
-  // does not have the extension enabled because it does not contain a
-  // runtime array. This is the same shader as NoInstrumentNonBindless.
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 1
-OpDecorate %g_tColor Binding 2
-OpDecorate %g_sAniso DescriptorSet 1
-OpDecorate %g_sAniso Binding 2
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%8 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%12 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%_ptr_UniformConstant_12 = OpTypePointer UniformConstant %12
-%g_tColor = OpVariable %_ptr_UniformConstant_12 UniformConstant
-%14 = OpTypeSampler
-%_ptr_UniformConstant_14 = OpTypePointer UniformConstant %14
-%g_sAniso = OpVariable %_ptr_UniformConstant_14 UniformConstant
-%16 = OpTypeSampledImage %12
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%MainPs = OpFunction %void None %8
-%19 = OpLabel
-%20 = OpLoad %v2float %i_vTextureCoords
-%21 = OpLoad %12 %g_tColor
-%22 = OpLoad %14 %g_sAniso
-%23 = OpSampledImage %16 %21 %22
-%24 = OpImageSampleImplicitLod %v4float %23 %20
-OpStore %_entryPointOutput_vColor %24
-;CHECK-NOT: %24 = OpImageSampleImplicitLod %v4float %23 %20
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %24
-;CHECK: [[check_result:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_40 {{%\w+}} %uint_1 %uint_2 %uint_0 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[check_result]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %12 %g_tColor
-;CHECK: {{%\w+}} = OpSampledImage %16 {{%\w+}} %22
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, SPV14AddToEntryPoint) {
-  const std::string text = R"(
-OpCapability Shader
-OpExtension "SPV_EXT_descriptor_indexing"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %foo "foo" %gid %image_var %sampler_var
-;CHECK: OpEntryPoint Fragment {{%\w+}} "foo" {{%\w+}} {{%\w+}} {{%\w+}} %gl_FragCoord
-OpExecutionMode %foo OriginUpperLeft
-OpDecorate %image_var DescriptorSet 4
-OpDecorate %image_var Binding 1
-OpDecorate %sampler_var DescriptorSet 4
-OpDecorate %sampler_var Binding 2
-OpDecorate %gid DescriptorSet 0
-OpDecorate %gid Binding 2
-OpDecorate %struct Block
-OpMemberDecorate %struct 0 Offset 0
-%void = OpTypeVoid
-%int = OpTypeInt 32 0
-%int_0 = OpConstant %int 0
-%v3int = OpTypeVector %int 3
-%float = OpTypeFloat 32
-%v3float = OpTypeVector %float 3
-%v4float = OpTypeVector %float 4
-%struct = OpTypeStruct %v3int
-%ptr_ssbo_struct = OpTypePointer StorageBuffer %struct
-%ptr_ssbo_v3int = OpTypePointer StorageBuffer %v3int
-%gid = OpVariable %ptr_ssbo_struct StorageBuffer
-%image = OpTypeImage %float 3D 0 0 0 1 Unknown
-%ptr_uc_image = OpTypePointer UniformConstant %image
-%sampler = OpTypeSampler
-%ptr_uc_sampler = OpTypePointer UniformConstant %sampler
-%image_var = OpVariable %ptr_uc_image UniformConstant
-%sampler_var = OpVariable %ptr_uc_sampler UniformConstant
-%sampled = OpTypeSampledImage %image
-%void_fn = OpTypeFunction %void
-%foo = OpFunction %void None %void_fn
-%entry = OpLabel
-%ld_image = OpLoad %image %image_var
-%ld_sampler = OpLoad %sampler %sampler_var
-%gep = OpAccessChain %ptr_ssbo_v3int %gid %int_0
-%ld_gid = OpLoad %v3int %gep
-%convert = OpConvertUToF %v3float %ld_gid
-%sampled_image = OpSampledImage %sampled %ld_image %ld_sampler
-%sample = OpImageSampleImplicitLod %v4float %sampled_image %convert
-OpReturn
-OpFunctionEnd
-)";
-
-  SetTargetEnv(SPV_ENV_VULKAN_1_1_SPIRV_1_4);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, SPV14AddToEntryPoints) {
-  const std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %foo "foo" %gid %image_var %sampler_var
-;CHECK: OpEntryPoint Fragment {{%\w+}} "foo" {{%\w+}} {{%\w+}} {{%\w+}} %gl_FragCoord
-OpEntryPoint Fragment %foo "bar" %gid %image_var %sampler_var
-;CHECK: OpEntryPoint Fragment {{%\w+}} "bar" {{%\w+}} {{%\w+}} {{%\w+}} %gl_FragCoord
-OpExecutionMode %foo OriginUpperLeft
-OpDecorate %image_var DescriptorSet 3
-OpDecorate %image_var Binding 2
-OpDecorate %sampler_var DescriptorSet 3
-OpDecorate %sampler_var Binding 3
-OpDecorate %gid DescriptorSet 3
-OpDecorate %gid Binding 4
-OpDecorate %struct Block
-OpMemberDecorate %struct 0 Offset 0
-%void = OpTypeVoid
-%int = OpTypeInt 32 0
-%int_0 = OpConstant %int 0
-%v3int = OpTypeVector %int 3
-%float = OpTypeFloat 32
-%v3float = OpTypeVector %float 3
-%v4float = OpTypeVector %float 4
-%struct = OpTypeStruct %v3int
-%ptr_ssbo_struct = OpTypePointer StorageBuffer %struct
-%ptr_ssbo_v3int = OpTypePointer StorageBuffer %v3int
-%gid = OpVariable %ptr_ssbo_struct StorageBuffer
-%image = OpTypeImage %float 3D 0 0 0 1 Unknown
-%ptr_uc_image = OpTypePointer UniformConstant %image
-%sampler = OpTypeSampler
-%ptr_uc_sampler = OpTypePointer UniformConstant %sampler
-%image_var = OpVariable %ptr_uc_image UniformConstant
-%sampler_var = OpVariable %ptr_uc_sampler UniformConstant
-%sampled = OpTypeSampledImage %image
-%void_fn = OpTypeFunction %void
-%foo = OpFunction %void None %void_fn
-%entry = OpLabel
-%ld_image = OpLoad %image %image_var
-%ld_sampler = OpLoad %sampler %sampler_var
-%gep = OpAccessChain %ptr_ssbo_v3int %gid %int_0
-%ld_gid = OpLoad %v3int %gep
-%convert = OpConvertUToF %v3float %ld_gid
-%sampled_image = OpSampledImage %sampled %ld_image %ld_sampler
-%sample = OpImageSampleImplicitLod %v4float %sampled_image %convert
-OpReturn
-OpFunctionEnd
-)";
-
-  SetTargetEnv(SPV_ENV_VULKAN_1_1_SPIRV_1_4);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstBoundsAndInitLoadUnsizedUBOArray) {
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(location=0) in nonuniformEXT flat int nu_ii;
-  // layout(location=0) out float b;
-  //
-  // layout(set = 6, binding=3)  uniform uname { float a; }  uniformBuffer[];
-  //
-  // void main()
-  // {
-  //     b = uniformBuffer[nu_ii].a;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability ShaderNonUniform
-OpCapability RuntimeDescriptorArray
-OpCapability UniformBufferArrayNonUniformIndexing
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %b %nu_ii
-;CHECK: OpEntryPoint Fragment %main "main" %b %nu_ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %b "b"
-OpName %uname "uname"
-OpMemberName %uname 0 "a"
-OpName %uniformBuffer "uniformBuffer"
-OpName %nu_ii "nu_ii"
-OpDecorate %b Location 0
-OpMemberDecorate %uname 0 Offset 0
-OpDecorate %uname Block
-OpDecorate %uniformBuffer DescriptorSet 6
-OpDecorate %uniformBuffer Binding 3
-OpDecorate %nu_ii Flat
-OpDecorate %nu_ii Location 0
-OpDecorate %nu_ii NonUniform
-OpDecorate %16 NonUniform
-OpDecorate %20 NonUniform
-;CHECK: OpDecorate {{%\w+}} NonUniform
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-;CHECK: OpDecorate {{%\w+}} NonUniform
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%b = OpVariable %_ptr_Output_float Output
-%uname = OpTypeStruct %float
-%_runtimearr_uname = OpTypeRuntimeArray %uname
-%_ptr_Uniform__runtimearr_uname = OpTypePointer Uniform %_runtimearr_uname
-%uniformBuffer = OpVariable %_ptr_Uniform__runtimearr_uname Uniform
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%nu_ii = OpVariable %_ptr_Input_int Input
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %v4float = OpTypeVector %float 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%16 = OpLoad %int %nu_ii
-%19 = OpAccessChain %_ptr_Uniform_float %uniformBuffer %16 %int_0
-%20 = OpLoad %float %19
-OpStore %b %20
-;CHECK-NOT: %20 = OpLoad %float %19
-;CHECK-NOT: OpStore %b %20
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint %7
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_46 {{%\w+}} %uint_6 %uint_3 {{%\w+}} {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %float %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %b [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstBoundsAndInitLoadUnsizedSSBOArrayDeprecated) {
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(location=0) in nonuniformEXT flat int nu_ii;
-  // layout(location=0) out float b;
-  //
-  // layout(set = 7, binding=3)  buffer bname { float b; }  storageBuffer[];
-  //
-  // void main()
-  // {
-  //     b = storageBuffer[nu_ii].b;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability ShaderNonUniform
-OpCapability RuntimeDescriptorArray
-OpCapability StorageBufferArrayNonUniformIndexing
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %b %nu_ii
-;CHECK: OpEntryPoint Fragment %main "main" %b %nu_ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %b "b"
-OpName %bname "bname"
-OpMemberName %bname 0 "a"
-OpName %storageBuffer "storageBuffer"
-OpName %nu_ii "nu_ii"
-OpDecorate %b Location 0
-OpMemberDecorate %bname 0 Offset 0
-OpDecorate %bname Block
-OpDecorate %storageBuffer DescriptorSet 7
-OpDecorate %storageBuffer Binding 3
-OpDecorate %nu_ii Flat
-OpDecorate %nu_ii Location 0
-OpDecorate %nu_ii NonUniform
-OpDecorate %16 NonUniform
-OpDecorate %20 NonUniform
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%b = OpVariable %_ptr_Output_float Output
-%bname = OpTypeStruct %float
-%_runtimearr_bname = OpTypeRuntimeArray %bname
-%_ptr_StorageBuffer__runtimearr_bname = OpTypePointer StorageBuffer %_runtimearr_bname
-%storageBuffer = OpVariable %_ptr_StorageBuffer__runtimearr_bname StorageBuffer
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%nu_ii = OpVariable %_ptr_Input_int Input
-%int_0 = OpConstant %int 0
-%_ptr_StorageBuffer_float = OpTypePointer StorageBuffer %float
-;CHECK: %uint = OpTypeInt 32 0
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %v4float = OpTypeVector %float 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%16 = OpLoad %int %nu_ii
-%19 = OpAccessChain %_ptr_StorageBuffer_float %storageBuffer %16 %int_0
-%20 = OpLoad %float %19
-OpStore %b %20
-;CHECK-NOT: %20 = OpLoad %float %19
-;CHECK-NOT: OpStore %b %20
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint %7
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_46 {{%\w+}} %uint_7 %uint_3 {{%\w+}} {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %float %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %b [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstBoundsAndInitLoadUnsizedSSBOArray) {
-  // Same as Deprecated but declaring as StorageBuffer Block
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability ShaderNonUniform
-OpCapability RuntimeDescriptorArray
-OpCapability StorageBufferArrayNonUniformIndexing
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %b %nu_ii
-;CHECK: OpEntryPoint Fragment %main "main" %b %nu_ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %b "b"
-OpName %bname "bname"
-OpMemberName %bname 0 "a"
-OpName %storageBuffer "storageBuffer"
-OpName %nu_ii "nu_ii"
-OpDecorate %b Location 0
-OpMemberDecorate %bname 0 Offset 0
-OpDecorate %bname Block
-OpDecorate %storageBuffer DescriptorSet 0
-OpDecorate %storageBuffer Binding 3
-OpDecorate %nu_ii Flat
-OpDecorate %nu_ii Location 0
-OpDecorate %nu_ii NonUniform
-OpDecorate %16 NonUniform
-OpDecorate %20 NonUniform
-;CHECK: OpDecorate {{%\w+}} NonUniform
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-;CHECK: OpDecorate {{%\w+}} NonUniform
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%b = OpVariable %_ptr_Output_float Output
-%bname = OpTypeStruct %float
-%_runtimearr_bname = OpTypeRuntimeArray %bname
-%_ptr_StorageBuffer__runtimearr_bname = OpTypePointer StorageBuffer %_runtimearr_bname
-%storageBuffer = OpVariable %_ptr_StorageBuffer__runtimearr_bname StorageBuffer
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%nu_ii = OpVariable %_ptr_Input_int Input
-%int_0 = OpConstant %int 0
-%_ptr_StorageBuffer_float = OpTypePointer StorageBuffer %float
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %v4float = OpTypeVector %float 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%16 = OpLoad %int %nu_ii
-%19 = OpAccessChain %_ptr_StorageBuffer_float %storageBuffer %16 %int_0
-%20 = OpLoad %float %19
-OpStore %b %20
-;CHECK-NOT: %20 = OpLoad %float %19
-;CHECK-NOT: OpStore %b %20
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint %7
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_46 {{%\w+}} %uint_0 %uint_3 {{%\w+}} {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %float %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %b {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstInitLoadUBOScalar) {
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(location=0) out float b;
-  // layout(set=7, binding=3)  uniform uname { float a; }  uniformBuffer;
-  //
-  // void main()
-  // {
-  //     b = uniformBuffer.a;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %b
-;CHECK: OpEntryPoint Fragment %main "main" %b %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %b "b"
-OpName %uname "uname"
-OpMemberName %uname 0 "a"
-OpName %uniformBuffer "uniformBuffer"
-OpDecorate %b Location 0
-OpMemberDecorate %uname 0 Offset 0
-OpDecorate %uname Block
-OpDecorate %uniformBuffer DescriptorSet 7
-OpDecorate %uniformBuffer Binding 3
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%b = OpVariable %_ptr_Output_float Output
-%uname = OpTypeStruct %float
-%_ptr_Uniform_uname = OpTypePointer Uniform %uname
-%uniformBuffer = OpVariable %_ptr_Uniform_uname Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: %int = OpTypeInt 32 1
-;CHECK: %_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: %uint = OpTypeInt 32 0
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %v4float = OpTypeVector %float 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%15 = OpAccessChain %_ptr_Uniform_float %uniformBuffer %int_0
-%16 = OpLoad %float %15
-OpStore %b %16
-;CHECK-NOT: %16 = OpLoad %float %15
-;CHECK-NOT: OpStore %b %16
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[check_result:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_33 {{%\w+}} %uint_7 %uint_3 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[check_result]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %float %15
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %b [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstBoundsInitStoreUnsizedSSBOArray) {
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(location=0) in nonuniformEXT flat int nu_ii;
-  // layout(location=1) in float b;
-  //
-  // layout(set=5, binding=4)  buffer bname { float b; }  storageBuffer[];
-  //
-  // void main()
-  // {
-  //     storageBuffer[nu_ii].b = b;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(OpCapability Shader
-OpCapability ShaderNonUniform
-OpCapability RuntimeDescriptorArray
-OpCapability StorageBufferArrayNonUniformIndexing
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %nu_ii %b
-;CHECK: OpEntryPoint Fragment %main "main" %nu_ii %b %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %bname "bname"
-OpMemberName %bname 0 "b"
-OpName %storageBuffer "storageBuffer"
-OpName %nu_ii "nu_ii"
-OpName %b "b"
-OpMemberDecorate %bname 0 Offset 0
-OpDecorate %bname BufferBlock
-OpDecorate %storageBuffer DescriptorSet 5
-OpDecorate %storageBuffer Binding 4
-OpDecorate %nu_ii Flat
-OpDecorate %nu_ii Location 0
-OpDecorate %nu_ii NonUniform
-OpDecorate %14 NonUniform
-OpDecorate %b Location 1
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%bname = OpTypeStruct %float
-%_runtimearr_bname = OpTypeRuntimeArray %bname
-%_ptr_Uniform__runtimearr_bname = OpTypePointer Uniform %_runtimearr_bname
-%storageBuffer = OpVariable %_ptr_Uniform__runtimearr_bname Uniform
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%nu_ii = OpVariable %_ptr_Input_int Input
-%int_0 = OpConstant %int 0
-%_ptr_Input_float = OpTypePointer Input %float
-%b = OpVariable %_ptr_Input_float Input
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%14 = OpLoad %int %nu_ii
-%18 = OpLoad %float %b
-%20 = OpAccessChain %_ptr_Uniform_float %storageBuffer %14 %int_0
-OpStore %20 %18
-;CHECK-NOT: OpStore %20 %18
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint %7
-;CHECK: [[check_result:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_46 {{%\w+}} %uint_5 %uint_4 {{%\w+}} {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[check_result]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %20 %19
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstBoundsInitLoadSizedUBOArray) {
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(location=0) in nonuniformEXT flat int nu_ii;
-  // layout(location=0) out float b;
-  //
-  // layout(set=1, binding=3)  uniform uname { float a; }  uniformBuffer[128];
-  //
-  // void main()
-  // {
-  //     b = uniformBuffer[nu_ii].a;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability ShaderNonUniform
-OpCapability UniformBufferArrayNonUniformIndexing
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %b %nu_ii
-;CHECK: OpEntryPoint Fragment %main "main" %b %nu_ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %b "b"
-OpName %uname "uname"
-OpMemberName %uname 0 "a"
-OpName %uniformBuffer "uniformBuffer"
-OpName %nu_ii "nu_ii"
-OpDecorate %b Location 0
-OpMemberDecorate %uname 0 Offset 0
-OpDecorate %uname Block
-OpDecorate %uniformBuffer DescriptorSet 1
-OpDecorate %uniformBuffer Binding 3
-OpDecorate %nu_ii Flat
-OpDecorate %nu_ii Location 0
-OpDecorate %nu_ii NonUniform
-OpDecorate %18 NonUniform
-OpDecorate %22 NonUniform
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-;CHECK: OpDecorate [[load_result:%\w+]] NonUniform
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%b = OpVariable %_ptr_Output_float Output
-%uname = OpTypeStruct %float
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_uname_uint_128 = OpTypeArray %uname %uint_128
-%_ptr_Uniform__arr_uname_uint_128 = OpTypePointer Uniform %_arr_uname_uint_128
-%uniformBuffer = OpVariable %_ptr_Uniform__arr_uname_uint_128 Uniform
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%nu_ii = OpVariable %_ptr_Input_int Input
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%18 = OpLoad %int %nu_ii
-%21 = OpAccessChain %_ptr_Uniform_float %uniformBuffer %18 %int_0
-%22 = OpLoad %float %21
-OpStore %b %22
-;CHECK-NOT: %22 = OpLoad %float %21
-;CHECK-NOT: OpStore %b %22
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint %7
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_47 {{%\w+}} %uint_1 %uint_3 {{%\w+}} {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %float %22
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %b {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsComputeShaderInitLoadVariableSizedSampledImagesArray) {
-  // #version 450
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout (local_size_x = 1, local_size_y = 1) in;
-  //
-  // layout(set = 2, binding = 0, std140) buffer Input {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 2, binding = 1, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability RuntimeDescriptorArray
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint GLCompute %main "main"
-;CHECK: OpEntryPoint GLCompute %main "main" %gl_GlobalInvocationID
-OpExecutionMode %main LocalSize 1 1 1
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %Input "Input"
-OpMemberName %Input 0 "index"
-OpMemberName %Input 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %Input 0 Offset 0
-OpMemberDecorate %Input 1 Offset 4
-OpDecorate %Input BufferBlock
-OpDecorate %sbo DescriptorSet 2
-OpDecorate %sbo Binding 0
-OpDecorate %images DescriptorSet 2
-OpDecorate %images Binding 1
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_GlobalInvocationID BuiltIn GlobalInvocationId
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%Input = OpTypeStruct %uint %float
-%_ptr_Uniform_Input = OpTypePointer Uniform %Input
-%sbo = OpVariable %_ptr_Uniform_Input Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: %v3uint = OpTypeVector %uint 3
-;CHECK: %_ptr_Input_v3uint = OpTypePointer Input %v3uint
-;CHECK: %gl_GlobalInvocationID = OpVariable %_ptr_Input_v3uint Input
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint %gl_GlobalInvocationID
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_48 {{%\w+}} %uint_2 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %uint {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_UniformConstant_13 %images {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %13 {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %v3uint %gl_GlobalInvocationID
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_51 {{%\w+}} %uint_2 %uint_1 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 {{%\w+}}
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK: {{%\w+}} = OpLoad %v3uint %gl_GlobalInvocationID
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_54 {{%\w+}} %uint_2 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %31 {{%\w+}}
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsRayGenerationInitLoadVariableSizedSampledImagesArray) {
-  // #version 460
-  // #extension GL_EXT_nonuniform_qualifier : require
-  // #extension GL_NV_ray_tracing : require
-  //
-  // layout(set = 3, binding = 1, std140) buffer StorageBuffer {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 3, binding = 5, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability RuntimeDescriptorArray
-OpCapability RayTracingNV
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpExtension "SPV_NV_ray_tracing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint RayGenerationNV %main "main"
-;CHECK: OpEntryPoint RayGenerationNV %main "main" [[launch_id:%\w+]]
-OpSource GLSL 460
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpSourceExtension "GL_NV_ray_tracing"
-OpName %main "main"
-OpName %StorageBuffer "StorageBuffer"
-OpMemberName %StorageBuffer 0 "index"
-OpMemberName %StorageBuffer 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %StorageBuffer 0 Offset 0
-OpMemberDecorate %StorageBuffer 1 Offset 4
-OpDecorate %StorageBuffer BufferBlock
-OpDecorate %sbo DescriptorSet 3
-OpDecorate %sbo Binding 1
-OpDecorate %images DescriptorSet 3
-OpDecorate %images Binding 5
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate [[launch_id]] BuiltIn LaunchIdNV
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%StorageBuffer = OpTypeStruct %uint %float
-%_ptr_Uniform_StorageBuffer = OpTypePointer Uniform %StorageBuffer
-%sbo = OpVariable %_ptr_Uniform_StorageBuffer Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5313 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} %uint_3 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %uint {{%\w+}} {{%\w+}} [[null_uint]] {{%\w+}}
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_UniformConstant_13 %images {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %13 {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5313 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_3 %uint_5 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 {{%\w+}}
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5313 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_55 {{%\w+}} %uint_3 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore {{%\w+}} {{%\w+}}
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsIntersectionInitLoadVariableSizedSampledImagesArray) {
-  // #version 460
-  // #extension GL_EXT_nonuniform_qualifier : require
-  // #extension GL_NV_ray_tracing : require
-  //
-  // layout(set = 5, binding = 1, std140) buffer StorageBuffer {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 5, binding = 3, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability RuntimeDescriptorArray
-OpCapability RayTracingNV
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpExtension "SPV_NV_ray_tracing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint IntersectionNV %main "main"
-;CHECK: OpEntryPoint IntersectionNV %main "main" [[launch_id:%\w+]]
-OpSource GLSL 460
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpSourceExtension "GL_NV_ray_tracing"
-OpName %main "main"
-OpName %StorageBuffer "StorageBuffer"
-OpMemberName %StorageBuffer 0 "index"
-OpMemberName %StorageBuffer 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %StorageBuffer 0 Offset 0
-OpMemberDecorate %StorageBuffer 1 Offset 4
-OpDecorate %StorageBuffer BufferBlock
-OpDecorate %sbo DescriptorSet 5
-OpDecorate %sbo Binding 1
-OpDecorate %images DescriptorSet 5
-OpDecorate %images Binding 3
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate [[launch_id]] BuiltIn LaunchIdNV
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%StorageBuffer = OpTypeStruct %uint %float
-%_ptr_Uniform_StorageBuffer = OpTypePointer Uniform %StorageBuffer
-%sbo = OpVariable %_ptr_Uniform_StorageBuffer Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: [[launch_id]] = OpVariable %_ptr_Input_v3uint Input
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5314 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} %uint_5 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %uint {{%\w+}} {{%\w+}} [[null_uint]] {{%\w+}}
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_UniformConstant_13 %images {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %13 {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5314 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_5 %uint_3 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 {{%\w+}}
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: {{%\w+}} = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5314 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_55 {{%\w+}} %uint_5 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %31 {{%\w+}}
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsAnyHitInitLoadVariableSizedSampledImagesArray) {
-  // #version 460
-  // #extension GL_EXT_nonuniform_qualifier : require
-  // #extension GL_NV_ray_tracing : require
-  //
-  // layout(set = 2, binding = 1, std140) buffer StorageBuffer {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 2, binding = 3, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability RuntimeDescriptorArray
-OpCapability RayTracingNV
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpExtension "SPV_NV_ray_tracing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint AnyHitNV %main "main"
-;CHECK: OpEntryPoint AnyHitNV %main "main" [[launch_id:%\w+]]
-OpSource GLSL 460
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpSourceExtension "GL_NV_ray_tracing"
-OpName %main "main"
-OpName %StorageBuffer "StorageBuffer"
-OpMemberName %StorageBuffer 0 "index"
-OpMemberName %StorageBuffer 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %StorageBuffer 0 Offset 0
-OpMemberDecorate %StorageBuffer 1 Offset 4
-OpDecorate %StorageBuffer BufferBlock
-OpDecorate %sbo DescriptorSet 2
-OpDecorate %sbo Binding 1
-OpDecorate %images DescriptorSet 2
-OpDecorate %images Binding 3
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate [[launch_id]] BuiltIn LaunchIdNV
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%StorageBuffer = OpTypeStruct %uint %float
-%_ptr_Uniform_StorageBuffer = OpTypePointer Uniform %StorageBuffer
-%sbo = OpVariable %_ptr_Uniform_StorageBuffer Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: [[launch_id]] = OpVariable %_ptr_Input_v3uint Input
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: %20 = OpLoad %uint %19
-;CHECK-NOT: %22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-;CHECK-NOT: %23 = OpLoad %13 %22
-;CHECK-NOT: %27 = OpImageRead %v4float %23 %25
-;CHECK-NOT: %29 = OpCompositeExtract %float %27 0
-;CHECK-NOT: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5315 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} %uint_2 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %uint {{%\w+}} {{%\w+}} [[null_uint]] {{%\w+}}
-;CHECK: %27 = OpAccessChain %_ptr_UniformConstant_13 %images [[phi_result]]
-;CHECK: %28 = OpLoad %13 %27
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5315 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_2 %uint_3 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 %27
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: %30 = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5315 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_55 {{%\w+}} %uint_2 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %31 %30
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsClosestHitInitLoadVariableSizedSampledImagesArray) {
-  // #version 460
-  // #extension GL_EXT_nonuniform_qualifier : require
-  // #extension GL_NV_ray_tracing : require
-  //
-  // layout(set = 1, binding = 2, std140) buffer StorageBuffer {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 1, binding = 3, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability RuntimeDescriptorArray
-OpCapability RayTracingNV
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpExtension "SPV_NV_ray_tracing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint ClosestHitNV %main "main"
-;CHECK: OpEntryPoint ClosestHitNV %main "main" [[launch_id:%\w+]]
-OpSource GLSL 460
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpSourceExtension "GL_NV_ray_tracing"
-OpName %main "main"
-OpName %StorageBuffer "StorageBuffer"
-OpMemberName %StorageBuffer 0 "index"
-OpMemberName %StorageBuffer 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %StorageBuffer 0 Offset 0
-OpMemberDecorate %StorageBuffer 1 Offset 4
-OpDecorate %StorageBuffer BufferBlock
-OpDecorate %sbo DescriptorSet 1
-OpDecorate %sbo Binding 2
-OpDecorate %images DescriptorSet 1
-OpDecorate %images Binding 3
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate [[launch_id]] BuiltIn LaunchIdNV
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%StorageBuffer = OpTypeStruct %uint %float
-%_ptr_Uniform_StorageBuffer = OpTypePointer Uniform %StorageBuffer
-%sbo = OpVariable %_ptr_Uniform_StorageBuffer Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: [[launch_id]] = OpVariable %_ptr_Input_v3uint Input
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: %20 = OpLoad %uint %19
-;CHECK-NOT: %22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-;CHECK-NOT: %23 = OpLoad %13 %22
-;CHECK-NOT: %27 = OpImageRead %v4float %23 %25
-;CHECK-NOT: %29 = OpCompositeExtract %float %27 0
-;CHECK-NOT: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5316 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} %uint_1 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %uint {{%\w+}} {{%\w+}} [[null_uint]] {{%\w+}}
-;CHECK: %27 = OpAccessChain %_ptr_UniformConstant_13 %images [[phi_result]]
-;CHECK: %28 = OpLoad %13 %27
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5316 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_1 %uint_3 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 %27
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: %30 = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5316 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_55 {{%\w+}} %uint_1 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %31 %30
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsMissInitLoadVariableSizedSampledImagesArray) {
-  // #version 460
-  // #extension GL_EXT_nonuniform_qualifier : require
-  // #extension GL_NV_ray_tracing : require
-  //
-  // layout(set = 1, binding = 2, std140) buffer StorageBuffer {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 1, binding = 3, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability RuntimeDescriptorArray
-OpCapability RayTracingNV
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpExtension "SPV_NV_ray_tracing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint MissNV %main "main"
-;CHECK: OpEntryPoint MissNV %main "main" [[launch_id:%\w+]]
-OpSource GLSL 460
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpSourceExtension "GL_NV_ray_tracing"
-OpName %main "main"
-OpName %StorageBuffer "StorageBuffer"
-OpMemberName %StorageBuffer 0 "index"
-OpMemberName %StorageBuffer 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %StorageBuffer 0 Offset 0
-OpMemberDecorate %StorageBuffer 1 Offset 4
-OpDecorate %StorageBuffer BufferBlock
-OpDecorate %sbo DescriptorSet 1
-OpDecorate %sbo Binding 2
-OpDecorate %images DescriptorSet 1
-OpDecorate %images Binding 3
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate [[launch_id]] BuiltIn LaunchIdNV
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%StorageBuffer = OpTypeStruct %uint %float
-%_ptr_Uniform_StorageBuffer = OpTypePointer Uniform %StorageBuffer
-%sbo = OpVariable %_ptr_Uniform_StorageBuffer Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: [[launch_id]] = OpVariable %_ptr_Input_v3uint Input
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: %20 = OpLoad %uint %19
-;CHECK-NOT: %22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-;CHECK-NOT: %27 = OpImageRead %v4float %23 %25
-;CHECK-NOT: %29 = OpCompositeExtract %float %27 0
-;CHECK-NOT OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5317 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} %uint_1 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %uint {{%\w+}} {{%\w+}} [[null_uint]] {{%\w+}}
-;CHECK: %27 = OpAccessChain %_ptr_UniformConstant_13 %images [[phi_result]]
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5317 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_1 %uint_3 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 %27
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: %30 = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5317 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_55 {{%\w+}} %uint_1 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %31 %30
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest,
-       InstBoundsCallableInitLoadVariableSizedSampledImagesArray) {
-  // #version 460
-  // #extension GL_EXT_nonuniform_qualifier : require
-  // #extension GL_NV_ray_tracing : require
-  //
-  // layout(set = 1, binding = 2, std140) buffer StorageBuffer {
-  //   uint index;
-  //   float red;
-  // } sbo;
-  //
-  // layout(set = 1, binding = 3, rgba32f) readonly uniform image2D images[];
-  //
-  // void main()
-  // {
-  //    sbo.red = imageLoad(images[sbo.index], ivec2(0, 0)).r;
-  // }
-
-  // clang-format off
-  const std::string defs = R"(
-OpCapability RuntimeDescriptorArray
-OpCapability RayTracingNV
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-OpExtension "SPV_NV_ray_tracing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint CallableNV %main "main"
-;CHECK: OpEntryPoint CallableNV %main "main" [[launch_id:%\w+]]
-OpSource GLSL 460
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpSourceExtension "GL_NV_ray_tracing"
-OpName %main "main"
-OpName %StorageBuffer "StorageBuffer"
-OpMemberName %StorageBuffer 0 "index"
-OpMemberName %StorageBuffer 1 "red"
-OpName %sbo "sbo"
-OpName %images "images"
-OpMemberDecorate %StorageBuffer 0 Offset 0
-OpMemberDecorate %StorageBuffer 1 Offset 4
-OpDecorate %StorageBuffer BufferBlock
-OpDecorate %sbo DescriptorSet 1
-OpDecorate %sbo Binding 2
-OpDecorate %images DescriptorSet 1
-OpDecorate %images Binding 3
-OpDecorate %images NonWritable
-)" + kImportDeco + R"(
-;CHECK: OpDecorate [[launch_id]] BuiltIn LaunchIdNV
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%uint = OpTypeInt 32 0
-%float = OpTypeFloat 32
-%StorageBuffer = OpTypeStruct %uint %float
-%_ptr_Uniform_StorageBuffer = OpTypePointer Uniform %StorageBuffer
-%sbo = OpVariable %_ptr_Uniform_StorageBuffer Uniform
-%int = OpTypeInt 32 1
-%int_1 = OpConstant %int 1
-%13 = OpTypeImage %float 2D 0 0 0 2 Rgba32f
-%_runtimearr_13 = OpTypeRuntimeArray %13
-%_ptr_UniformConstant__runtimearr_13 = OpTypePointer UniformConstant %_runtimearr_13
-%images = OpVariable %_ptr_UniformConstant__runtimearr_13 UniformConstant
-%int_0 = OpConstant %int 0
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%v2int = OpTypeVector %int 2
-%25 = OpConstantComposite %v2int %int_0 %int_0
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-;CHECK: [[null_uint:%\w+]] = OpConstantNull %uint
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%19 = OpAccessChain %_ptr_Uniform_uint %sbo %int_0
-%20 = OpLoad %uint %19
-%22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-%23 = OpLoad %13 %22
-%27 = OpImageRead %v4float %23 %25
-%29 = OpCompositeExtract %float %27 0
-;CHECK-NOT: %20 = OpLoad %uint %19
-;CHECK-NOT: %22 = OpAccessChain %_ptr_UniformConstant_13 %images %20
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5318 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} %uint_1 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %uint {{%\w+}} {{%\w+}} [[null_uint]] {{%\w+}}
-;CHECK: %27 = OpAccessChain %_ptr_UniformConstant_13 %images {{%\w+}}
-;CHECK-NOT: %23 = OpLoad %13 %22
-;CHECK-NOT: %27 = OpImageRead %v4float %23 %25
-;CHECK-NOT: %29 = OpCompositeExtract %float %27 0
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5318 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_1 %uint_3 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 %27
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: %30 = OpCompositeExtract %float {{%\w+}} 0
-;CHECK: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-%31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-OpStore %31 %29
-;CHECK-NOT: %31 = OpAccessChain %_ptr_Uniform_float %sbo %int_1
-;CHECK-NOT: OpStore %31 %29
-;CHECK: {{%\w+}} = OpLoad %v3uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5318 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_55 {{%\w+}} %uint_1 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %31 %30
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, InstBoundsInitSameBlockOpReplication) {
-  // Test that same block ops like OpSampledImage are replicated properly
-  // where needed.
-  //
-  // clang-format off
-  //
-  // #version 450 core
-  // #extension GL_EXT_nonuniform_qualifier : enable
-  //
-  // layout(location = 0) in vec2 inTexcoord;
-  // layout(location = 0) out vec4 outColor;
-  //
-  // layout(set = 1, binding = 0) uniform Uniforms {
-  //   vec2 var0;
-  // } uniforms;
-  //
-  // layout(set = 1, binding = 1) uniform sampler uniformSampler;
-  // layout(set = 1, binding = 2) uniform texture2D uniformTex;
-  // layout(set = 1, binding = 3) uniform texture2D uniformTexArr[8];
-  //
-  // void main() {
-  //   int index = 0;
-  //   float x = texture(sampler2D(uniformTexArr[nonuniformEXT(index)], uniformSampler), inTexcoord.xy).x;
-  //   float y = texture(sampler2D(uniformTex, uniformSampler), inTexcoord.xy * uniforms.var0.xy).x;
-  //   outColor = vec4(x, y, 0.0, 0.0);
-  // }
-  //
-
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability ShaderNonUniformEXT
-OpCapability SampledImageArrayNonUniformIndexingEXT
-;CHECK: OpCapability Linkage
-OpExtension "SPV_EXT_descriptor_indexing"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %inTexcoord %outColor
-;CHECK: OpEntryPoint Fragment %main "main" %inTexcoord %outColor %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_nonuniform_qualifier"
-OpName %main "main"
-OpName %index "index"
-OpName %x "x"
-OpName %uniformTexArr "uniformTexArr"
-OpName %uniformSampler "uniformSampler"
-OpName %inTexcoord "inTexcoord"
-OpName %y "y"
-OpName %uniformTex "uniformTex"
-OpName %Uniforms "Uniforms"
-OpMemberName %Uniforms 0 "var0"
-OpName %uniforms "uniforms"
-OpName %outColor "outColor"
-OpDecorate %uniformTexArr DescriptorSet 1
-OpDecorate %uniformTexArr Binding 3
-OpDecorate %19 NonUniformEXT
-OpDecorate %22 NonUniformEXT
-OpDecorate %uniformSampler DescriptorSet 1
-OpDecorate %uniformSampler Binding 1
-OpDecorate %inTexcoord Location 0
-OpDecorate %uniformTex DescriptorSet 1
-OpDecorate %uniformTex Binding 2
-OpMemberDecorate %Uniforms 0 Offset 0
-OpDecorate %Uniforms Block
-OpDecorate %uniforms DescriptorSet 1
-OpDecorate %uniforms Binding 0
-OpDecorate %outColor Location 0
-;CHECK: OpDecorate {{%\w+}} NonUniform
-;CHECK: OpDecorate {{%\w+}} NonUniform
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-;CHECK: OpDecorate [[desc_state_result:%\w+]] NonUniform
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%int = OpTypeInt 32 1
-%_ptr_Function_int = OpTypePointer Function %int
-%int_0 = OpConstant %int 0
-%float = OpTypeFloat 32
-%_ptr_Function_float = OpTypePointer Function %float
-%13 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_8 = OpConstant %uint 8
-%_arr_13_uint_8 = OpTypeArray %13 %uint_8
-%_ptr_UniformConstant__arr_13_uint_8 = OpTypePointer UniformConstant %_arr_13_uint_8
-%uniformTexArr = OpVariable %_ptr_UniformConstant__arr_13_uint_8 UniformConstant
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%23 = OpTypeSampler
-%_ptr_UniformConstant_23 = OpTypePointer UniformConstant %23
-%uniformSampler = OpVariable %_ptr_UniformConstant_23 UniformConstant
-%27 = OpTypeSampledImage %13
-%v2float = OpTypeVector %float 2
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%inTexcoord = OpVariable %_ptr_Input_v2float Input
-%v4float = OpTypeVector %float 4
-%uint_0 = OpConstant %uint 0
-%uniformTex = OpVariable %_ptr_UniformConstant_13 UniformConstant
-%Uniforms = OpTypeStruct %v2float
-%_ptr_Uniform_Uniforms = OpTypePointer Uniform %Uniforms
-%uniforms = OpVariable %_ptr_Uniform_Uniforms Uniform
-%_ptr_Uniform_v2float = OpTypePointer Uniform %v2float
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%outColor = OpVariable %_ptr_Output_v4float Output
-%float_0 = OpConstant %float 0
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-;CHECK: [[null_v2float:%\w+]] = OpConstantNull %v2float
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%index = OpVariable %_ptr_Function_int Function
-%x = OpVariable %_ptr_Function_float Function
-%y = OpVariable %_ptr_Function_float Function
-OpStore %index %int_0
-%19 = OpLoad %int %index
-%21 = OpAccessChain %_ptr_UniformConstant_13 %uniformTexArr %19
-%22 = OpLoad %13 %21
-%26 = OpLoad %23 %uniformSampler
-%28 = OpSampledImage %27 %22 %26
-%32 = OpLoad %v2float %inTexcoord
-%34 = OpImageSampleImplicitLod %v4float %28 %32
-%36 = OpCompositeExtract %float %34 0
-;CHECK-NOT: %34 = OpImageSampleImplicitLod %v4float %28 %32
-;CHECK-NOT: %36 = OpCompositeExtract %float %34 0
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpBitcast %uint %19
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_80 {{%\w+}} %uint_1 %uint_3 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 %21
-;CHECK: {{%\w+}} = OpSampledImage %27 {{%\w+}} %26
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %32
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-OpStore %x %36
-%39 = OpLoad %13 %uniformTex
-%40 = OpLoad %23 %uniformSampler
-%41 = OpSampledImage %27 %39 %40
-%42 = OpLoad %v2float %inTexcoord
-%47 = OpAccessChain %_ptr_Uniform_v2float %uniforms %int_0
-%48 = OpLoad %v2float %47
-%49 = OpFMul %v2float %42 %48
-;CHECK-NOT: %48 = OpLoad %v2float %47
-;CHECK-NOT: %49 = OpFMul %v2float %42 %48
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_88 {{%\w+}} %uint_1 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v2float %47
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v2float {{%\w+}} {{%\w+}} [[null_v2float]] {{%\w+}}
-;CHECK: %49 = OpFMul %v2float %42 [[phi_result]]
-%50 = OpImageSampleImplicitLod %v4float %41 %49
-%51 = OpCompositeExtract %float %50 0
-OpStore %y %51
-;CHECK-NOT: %50 = OpImageSampleImplicitLod %v4float %41 %49
-;CHECK-NOT: %51 = OpCompositeExtract %float %50 0
-;CHECK: {{%\w+}} = OpSampledImage %27 %39 %40
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_90 {{%\w+}} %uint_1 %uint_2 %uint_0 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %13 %uniformTex
-;CHECK: {{%\w+}} = OpSampledImage %27 {{%\w+}} %40
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %49
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: %51 = OpCompositeExtract %float {{%\w+}} 0
-OpStore %y %51
-%54 = OpLoad %float %x
-%55 = OpLoad %float %y
-%57 = OpCompositeConstruct %v4float %54 %55 %float_0 %float_0
-OpStore %outColor %57
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(defs + kImportStub + main_func,
-                                               true, 23u);
-}
-
-TEST_F(InstBindlessTest, MultipleUniformNonAggregateRefsNoDescInit) {
-  // Check that uniform refs do not go out-of-bounds. All checks use same input
-  // buffer read function call result at top of function for uniform buffer
-  // length. Because descriptor indexing is not being checked, we can avoid one
-  // buffer load.
-  //
-  // Texture2D g_tColor;
-  // SamplerState g_sAniso;
-  //
-  // layout(push_constant) cbuffer PerViewPushConst_t { bool g_B; };
-  //
-  // cbuffer PerViewConstantBuffer_t {
-  //   float2 g_TexOff0;
-  //   float2 g_TexOff1;
-  // };
-  //
-  // struct PS_INPUT {
-  //   float2 vTextureCoords : TEXCOORD2;
-  // };
-  //
-  // struct PS_OUTPUT {
-  //   float4 vColor : SV_Target0;
-  // };
-  //
-  // PS_OUTPUT MainPs(PS_INPUT i) {
-  //   PS_OUTPUT ps_output;
-  //   float2 off;
-  //   float2 vtc;
-  //   if (g_B)
-  //     off = g_TexOff0;
-  //   else
-  //     off = g_TexOff1;
-  //   vtc = i.vTextureCoords.xy + off;
-  //   ps_output.vColor = g_tColor.Sample(g_sAniso, vtc);
-  //   return ps_output;
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %PerViewPushConst_t "PerViewPushConst_t"
-OpMemberName %PerViewPushConst_t 0 "g_B"
-OpName %_ ""
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_TexOff0"
-OpMemberName %PerViewConstantBuffer_t 1 "g_TexOff1"
-OpName %__0 ""
-OpName %g_tColor "g_tColor"
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpMemberDecorate %PerViewPushConst_t 0 Offset 0
-OpDecorate %PerViewPushConst_t Block
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpMemberDecorate %PerViewConstantBuffer_t 1 Offset 8
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %__0 DescriptorSet 0
-OpDecorate %__0 Binding 1
-OpDecorate %g_tColor DescriptorSet 0
-OpDecorate %g_tColor Binding 0
-OpDecorate %g_sAniso DescriptorSet 0
-OpDecorate %g_sAniso Binding 2
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%uint = OpTypeInt 32 0
-%PerViewPushConst_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewPushConst_t = OpTypePointer PushConstant %PerViewPushConst_t
-%_ = OpVariable %_ptr_PushConstant_PerViewPushConst_t PushConstant
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%bool = OpTypeBool
-%uint_0 = OpConstant %uint 0
-%PerViewConstantBuffer_t = OpTypeStruct %v2float %v2float
-%_ptr_Uniform_PerViewConstantBuffer_t = OpTypePointer Uniform %PerViewConstantBuffer_t
-%__0 = OpVariable %_ptr_Uniform_PerViewConstantBuffer_t Uniform
-%_ptr_Uniform_v2float = OpTypePointer Uniform %v2float
-%int_1 = OpConstant %int 1
-%49 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%_ptr_UniformConstant_49 = OpTypePointer UniformConstant %49
-%g_tColor = OpVariable %_ptr_UniformConstant_49 UniformConstant
-%53 = OpTypeSampler
-%_ptr_UniformConstant_53 = OpTypePointer UniformConstant %53
-%g_sAniso = OpVariable %_ptr_UniformConstant_53 UniformConstant
-%57 = OpTypeSampledImage %49
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v2float:%\w+]] = OpConstantNull %v2float
- )" + kImportStub + R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%69 = OpLoad %v2float %i_vTextureCoords
-%82 = OpAccessChain %_ptr_PushConstant_uint %_ %int_0
-%83 = OpLoad %uint %82
-%84 = OpINotEqual %bool %83 %uint_0
-OpSelectionMerge %91 None
-OpBranchConditional %84 %85 %88
-%85 = OpLabel
-%86 = OpAccessChain %_ptr_Uniform_v2float %__0 %int_0
-%87 = OpLoad %v2float %86
-;CHECK-NOT:     %87 = OpLoad %v2float %86
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 %uint_7
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[desc_state_result:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_72 {{%\w+}} %uint_0 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[desc_state_result]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v2float %86
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
- ;CHECK: {{%\w+}} = OpPhi %v2float {{%\w+}} {{%\w+}} [[null_v2float]] {{%\w+}}
-OpBranch %91
-%88 = OpLabel
-%89 = OpAccessChain %_ptr_Uniform_v2float %__0 %int_1
-%90 = OpLoad %v2float %89
-;CHECK-NOT:     %90 = OpLoad %v2float %89
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_8 %uint_7
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_76 {{%\w+}} %uint_0 %uint_1 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v2float %89
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v2float {{%\w+}} {{%\w+}} [[null_v2float]] {{%\w+}}
-OpBranch %91
-%91 = OpLabel
-%115 = OpPhi %v2float %87 %85 %90 %88
-;CHECK-NOT:       %115 = OpPhi %v2float %87 %85 %90 %88
-;CHECK: %115 = OpPhi %v2float {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-%95 = OpFAdd %v2float %69 %115
-%96 = OpLoad %49 %g_tColor
-%97 = OpLoad %53 %g_sAniso
-%98 = OpSampledImage %57 %96 %97
-%100 = OpImageSampleImplicitLod %v4float %98 %95
-OpStore %_entryPointOutput_vColor %100
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, UniformArrayRefNoDescInit) {
-  // Check that uniform array ref does not go out-of-bounds.
-  //
-  // Texture2D g_tColor;
-  // SamplerState g_sAniso;
-  //
-  // layout(push_constant) cbuffer PerViewPushConst_t { uint g_c; };
-  //
-  // struct PerBatchEnvMapConstantBuffer_t {
-  //   float4x3 g_matEnvMapWorldToLocal;
-  //   float4 g_vEnvironmentMapBoxMins;
-  //   float2 g_TexOff;
-  // };
-  //
-  // cbuffer _BindlessFastEnvMapCB_PS_t {
-  //   PerBatchEnvMapConstantBuffer_t g_envMapConstants[128];
-  // };
-  //
-  // struct PS_INPUT {
-  //   float2 vTextureCoords : TEXCOORD2;
-  // };
-  //
-  // struct PS_OUTPUT {
-  //   float4 vColor : SV_Target0;
-  // };
-  //
-  // PS_OUTPUT MainPs(PS_INPUT i) {
-  //   PS_OUTPUT ps_output;
-  //   float2 off;
-  //   float2 vtc;
-  //   off = g_envMapConstants[g_c].g_TexOff;
-  //   vtc = i.vTextureCoords.xy + off;
-  //   ps_output.vColor = g_tColor.Sample(g_sAniso, vtc);
-  //   return ps_output;
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %PerBatchEnvMapConstantBuffer_t "PerBatchEnvMapConstantBuffer_t"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 0 "g_matEnvMapWorldToLocal"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 1 "g_vEnvironmentMapBoxMins"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 2 "g_TexOff"
-OpName %_BindlessFastEnvMapCB_PS_t "_BindlessFastEnvMapCB_PS_t"
-OpMemberName %_BindlessFastEnvMapCB_PS_t 0 "g_envMapConstants"
-OpName %_ ""
-OpName %PerViewPushConst_t "PerViewPushConst_t"
-OpMemberName %PerViewPushConst_t 0 "g_c"
-OpName %__0 ""
-OpName %g_tColor "g_tColor"
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 RowMajor
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 Offset 0
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 MatrixStride 16
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 1 Offset 48
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 2 Offset 64
-OpDecorate %_arr_PerBatchEnvMapConstantBuffer_t_uint_128 ArrayStride 80
-OpMemberDecorate %_BindlessFastEnvMapCB_PS_t 0 Offset 0
-OpDecorate %_BindlessFastEnvMapCB_PS_t Block
-OpDecorate %_ DescriptorSet 0
-OpDecorate %_ Binding 2
-OpMemberDecorate %PerViewPushConst_t 0 Offset 0
-OpDecorate %PerViewPushConst_t Block
-OpDecorate %g_tColor DescriptorSet 0
-OpDecorate %g_tColor Binding 0
-OpDecorate %g_sAniso DescriptorSet 0
-OpDecorate %g_sAniso Binding 1
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%v3float = OpTypeVector %float 3
-%mat4v3float = OpTypeMatrix %v3float 4
-%PerBatchEnvMapConstantBuffer_t = OpTypeStruct %mat4v3float %v4float %v2float
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_PerBatchEnvMapConstantBuffer_t_uint_128 = OpTypeArray %PerBatchEnvMapConstantBuffer_t %uint_128
-%_BindlessFastEnvMapCB_PS_t = OpTypeStruct %_arr_PerBatchEnvMapConstantBuffer_t_uint_128
-%_ptr_Uniform__BindlessFastEnvMapCB_PS_t = OpTypePointer Uniform %_BindlessFastEnvMapCB_PS_t
-%_ = OpVariable %_ptr_Uniform__BindlessFastEnvMapCB_PS_t Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%PerViewPushConst_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewPushConst_t = OpTypePointer PushConstant %PerViewPushConst_t
-%__0 = OpVariable %_ptr_PushConstant_PerViewPushConst_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%int_2 = OpConstant %int 2
-%_ptr_Uniform_v2float = OpTypePointer Uniform %v2float
-%46 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
-%g_tColor = OpVariable %_ptr_UniformConstant_46 UniformConstant
-%50 = OpTypeSampler
-%_ptr_UniformConstant_50 = OpTypePointer UniformConstant %50
-%g_sAniso = OpVariable %_ptr_UniformConstant_50 UniformConstant
-%54 = OpTypeSampledImage %46
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v2float:%\w+]] = OpConstantNull %v2float
-)" + kImportStub + R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%66 = OpLoad %v2float %i_vTextureCoords
-%79 = OpAccessChain %_ptr_PushConstant_uint %__0 %int_0
-%80 = OpLoad %uint %79
-%81 = OpAccessChain %_ptr_Uniform_v2float %_ %int_0 %80 %int_2
-%82 = OpLoad %v2float %81
-;CHECK-NOT: %82 = OpLoad %v2float %81
-;CHECK: {{%\w+}} = OpIMul %uint %uint_80 %80
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_64
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_7
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_79 {{%\w+}} %uint_0 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v2float %81
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v2float {{%\w+}} {{%\w+}} [[null_v2float]] {{%\w+}}
-%86 = OpFAdd %v2float %66 %82
-;CHECK-NOT: %86 = OpFAdd %v2float %66 %82
-;CHECK: %86 = OpFAdd %v2float %66 {{%\w+}}
-%87 = OpLoad %46 %g_tColor
-%88 = OpLoad %50 %g_sAniso
-%89 = OpSampledImage %54 %87 %88
-%91 = OpImageSampleImplicitLod %v4float %89 %86
-OpStore %_entryPointOutput_vColor %91
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, UniformArrayRefWithDescInit) {
-  // The buffer-oob and desc-init checks should use the same debug
-  // output buffer write function.
-  //
-  // Same source as UniformArrayRefNoDescInit
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %PerBatchEnvMapConstantBuffer_t "PerBatchEnvMapConstantBuffer_t"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 0 "g_matEnvMapWorldToLocal"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 1 "g_vEnvironmentMapBoxMins"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 2 "g_TexOff"
-OpName %_BindlessFastEnvMapCB_PS_t "_BindlessFastEnvMapCB_PS_t"
-OpMemberName %_BindlessFastEnvMapCB_PS_t 0 "g_envMapConstants"
-OpName %_ ""
-OpName %PerViewPushConst_t "PerViewPushConst_t"
-OpMemberName %PerViewPushConst_t 0 "g_c"
-OpName %__0 ""
-OpName %g_tColor "g_tColor"
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 RowMajor
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 Offset 0
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 MatrixStride 16
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 1 Offset 48
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 2 Offset 64
-OpDecorate %_arr_PerBatchEnvMapConstantBuffer_t_uint_128 ArrayStride 80
-OpMemberDecorate %_BindlessFastEnvMapCB_PS_t 0 Offset 0
-OpDecorate %_BindlessFastEnvMapCB_PS_t Block
-OpDecorate %_ DescriptorSet 0
-OpDecorate %_ Binding 2
-OpMemberDecorate %PerViewPushConst_t 0 Offset 0
-OpDecorate %PerViewPushConst_t Block
-OpDecorate %g_tColor DescriptorSet 0
-OpDecorate %g_tColor Binding 0
-OpDecorate %g_sAniso DescriptorSet 0
-OpDecorate %g_sAniso Binding 1
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%v3float = OpTypeVector %float 3
-%mat4v3float = OpTypeMatrix %v3float 4
-%PerBatchEnvMapConstantBuffer_t = OpTypeStruct %mat4v3float %v4float %v2float
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_PerBatchEnvMapConstantBuffer_t_uint_128 = OpTypeArray %PerBatchEnvMapConstantBuffer_t %uint_128
-%_BindlessFastEnvMapCB_PS_t = OpTypeStruct %_arr_PerBatchEnvMapConstantBuffer_t_uint_128
-%_ptr_Uniform__BindlessFastEnvMapCB_PS_t = OpTypePointer Uniform %_BindlessFastEnvMapCB_PS_t
-%_ = OpVariable %_ptr_Uniform__BindlessFastEnvMapCB_PS_t Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%PerViewPushConst_t = OpTypeStruct %uint
-%_ptr_PushConstant_PerViewPushConst_t = OpTypePointer PushConstant %PerViewPushConst_t
-%__0 = OpVariable %_ptr_PushConstant_PerViewPushConst_t PushConstant
-%_ptr_PushConstant_uint = OpTypePointer PushConstant %uint
-%int_2 = OpConstant %int 2
-%_ptr_Uniform_v2float = OpTypePointer Uniform %v2float
-%46 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
-%g_tColor = OpVariable %_ptr_UniformConstant_46 UniformConstant
-%50 = OpTypeSampler
-%_ptr_UniformConstant_50 = OpTypePointer UniformConstant %50
-%g_sAniso = OpVariable %_ptr_UniformConstant_50 UniformConstant
-%54 = OpTypeSampledImage %46
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %v4uint = OpTypeVector %uint 4
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v2float:%\w+]] = OpConstantNull %v2float
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)" + kImportStub + R"(
-%MainPs = OpFunction %void None %3
-%5 = OpLabel
-%66 = OpLoad %v2float %i_vTextureCoords
-%79 = OpAccessChain %_ptr_PushConstant_uint %__0 %int_0
-%80 = OpLoad %uint %79
-%81 = OpAccessChain %_ptr_Uniform_v2float %_ %int_0 %80 %int_2
-%82 = OpLoad %v2float %81
-%86 = OpFAdd %v2float %66 %82
-;CHECK-NOT: %82 = OpLoad %v2float %81
-;CHECK-NOT: %86 = OpFAdd %v2float %66 %82
-;CHECK: {{%\w+}} = OpIMul %uint %uint_80 %80
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_64
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_7
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_79 {{%\w+}} %uint_0 %uint_2 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v2float %81
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v2float {{%\w+}} {{%\w+}} [[null_v2float]] {{%\w+}}
-;CHECK: %86 = OpFAdd %v2float %66 {{%\w+}}
-%87 = OpLoad %46 %g_tColor
-%88 = OpLoad %50 %g_sAniso
-%89 = OpSampledImage %54 %87 %88
-%91 = OpImageSampleImplicitLod %v4float %89 %86
-OpStore %_entryPointOutput_vColor %91
-;CHECK-NOT: %91 = OpImageSampleImplicitLod %v4float %89 %86
-;CHECK-NOT:       OpStore %_entryPointOutput_vColor %91
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_84 {{%\w+}} %uint_0 %uint_0 %uint_0 %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %46 %g_tColor
-;CHECK: {{%\w+}} = OpSampledImage %54 {{%\w+}} %88
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %86
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor {{%\w+}}
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, Descriptor16BitIdxRef) {
-  // Check that descriptor indexed with 16bit index is inbounds and
-  // initialized
-  //
-  // Use Simple source with min16uint g_nDataIdx
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability Int16
-OpCapability StoragePushConstant16
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %g_tColor %_ %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %g_tColor %_ %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %g_tColor "g_tColor"
-OpName %PerViewConstantBuffer_t "PerViewConstantBuffer_t"
-OpMemberName %PerViewConstantBuffer_t 0 "g_nDataIdx"
-OpName %_ ""
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpDecorate %g_tColor DescriptorSet 1
-OpDecorate %g_tColor Binding 2
-OpMemberDecorate %PerViewConstantBuffer_t 0 Offset 0
-OpDecorate %PerViewConstantBuffer_t Block
-OpDecorate %g_sAniso DescriptorSet 1
-OpDecorate %g_sAniso Binding 2
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%10 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%16 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_16_uint_128 = OpTypeArray %16 %uint_128
-%_ptr_UniformConstant__arr_16_uint_128 = OpTypePointer UniformConstant %_arr_16_uint_128
-%g_tColor = OpVariable %_ptr_UniformConstant__arr_16_uint_128 UniformConstant
-%ushort = OpTypeInt 16 0
-%PerViewConstantBuffer_t = OpTypeStruct %ushort
-%_ptr_PushConstant_PerViewConstantBuffer_t = OpTypePointer PushConstant %PerViewConstantBuffer_t
-%_ = OpVariable %_ptr_PushConstant_PerViewConstantBuffer_t PushConstant
-%_ptr_PushConstant_ushort = OpTypePointer PushConstant %ushort
-%_ptr_UniformConstant_16 = OpTypePointer UniformConstant %16
-%25 = OpTypeSampler
-%_ptr_UniformConstant_25 = OpTypePointer UniformConstant %25
-%g_sAniso = OpVariable %_ptr_UniformConstant_25 UniformConstant
-%27 = OpTypeSampledImage %16
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)" + kImportStub + R"(
-%MainPs = OpFunction %void None %10
-%30 = OpLabel
-;CHECK:  OpBranch %39
-;CHECK:  %39 = OpLabel
-%31 = OpLoad %v2float %i_vTextureCoords
-%32 = OpAccessChain %_ptr_PushConstant_ushort %_ %int_0
-%33 = OpLoad %ushort %32
-%34 = OpAccessChain %_ptr_UniformConstant_16 %g_tColor %33
-%35 = OpLoad %16 %34
-%36 = OpLoad %25 %g_sAniso
-%37 = OpSampledImage %27 %35 %36
-%38 = OpImageSampleImplicitLod %v4float %37 %31
-OpStore %_entryPointOutput_vColor %38
-;CHECK-NOT: %38 = OpImageSampleImplicitLod %v4float %37 %31
-;CHECK-NOT: OpStore %_entryPointOutput_vColor %38
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpUConvert %uint %33
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_61 {{%\w+}} %uint_1 %uint_2 {{%\w+}} %uint_0
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %16 %34
-;CHECK: {{%\w+}} = OpSampledImage %27 {{%\w+}} %36
-;CHECK: {{%\w+}} = OpImageSampleImplicitLod %v4float {{%\w+}} %31
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %_entryPointOutput_vColor [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, UniformArray16bitIdxRef) {
-  // Check that uniform array ref with 16bit index does not go out-of-bounds.
-  //
-  // Texture2D g_tColor;
-  // SamplerState g_sAniso;
-  //
-  // layout(push_constant) cbuffer PerViewPushConst_t { min16uint g_c; };
-  //
-  // struct PerBatchEnvMapConstantBuffer_t {
-  //   float4x3 g_matEnvMapWorldToLocal;
-  //   float4 g_vEnvironmentMapBoxMins;
-  //   float2 g_TexOff;
-  // };
-  //
-  // cbuffer _BindlessFastEnvMapCB_PS_t {
-  //   PerBatchEnvMapConstantBuffer_t g_envMapConstants[128];
-  // };
-  //
-  // struct PS_INPUT {
-  //   float2 vTextureCoords : TEXCOORD2;
-  // };
-  //
-  // struct PS_OUTPUT {
-  //   float4 vColor : SV_Target0;
-  // };
-  //
-  // PS_OUTPUT MainPs(PS_INPUT i) {
-  //   PS_OUTPUT ps_output;
-  //   float2 off;
-  //   float2 vtc;
-  //   off = g_envMapConstants[g_c].g_TexOff;
-  //   vtc = i.vTextureCoords.xy + off;
-  //   ps_output.vColor = g_tColor.Sample(g_sAniso, vtc);
-  //   return ps_output;
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability Int16
-OpCapability StoragePushConstant16
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor
-;CHECK: OpEntryPoint Fragment %MainPs "MainPs" %_ %__0 %g_tColor %g_sAniso %i_vTextureCoords %_entryPointOutput_vColor %gl_FragCoord
-OpExecutionMode %MainPs OriginUpperLeft
-OpSource HLSL 500
-OpName %MainPs "MainPs"
-OpName %PerBatchEnvMapConstantBuffer_t "PerBatchEnvMapConstantBuffer_t"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 0 "g_matEnvMapWorldToLocal"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 1 "g_vEnvironmentMapBoxMins"
-OpMemberName %PerBatchEnvMapConstantBuffer_t 2 "g_TexOff"
-OpName %_BindlessFastEnvMapCB_PS_t "_BindlessFastEnvMapCB_PS_t"
-OpMemberName %_BindlessFastEnvMapCB_PS_t 0 "g_envMapConstants"
-OpName %_ ""
-OpName %PerViewPushConst_t "PerViewPushConst_t"
-OpMemberName %PerViewPushConst_t 0 "g_c"
-OpName %__0 ""
-OpName %g_tColor "g_tColor"
-OpName %g_sAniso "g_sAniso"
-OpName %i_vTextureCoords "i.vTextureCoords"
-OpName %_entryPointOutput_vColor "@entryPointOutput.vColor"
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 RowMajor
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 Offset 0
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 0 MatrixStride 16
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 1 Offset 48
-OpMemberDecorate %PerBatchEnvMapConstantBuffer_t 2 Offset 64
-OpDecorate %_arr_PerBatchEnvMapConstantBuffer_t_uint_128 ArrayStride 80
-OpMemberDecorate %_BindlessFastEnvMapCB_PS_t 0 Offset 0
-OpDecorate %_BindlessFastEnvMapCB_PS_t Block
-OpDecorate %_ DescriptorSet 0
-OpDecorate %_ Binding 0
-OpMemberDecorate %PerViewPushConst_t 0 Offset 0
-OpDecorate %PerViewPushConst_t Block
-OpDecorate %g_tColor DescriptorSet 0
-OpDecorate %g_tColor Binding 0
-OpDecorate %g_sAniso DescriptorSet 0
-OpDecorate %g_sAniso Binding 0
-OpDecorate %i_vTextureCoords Location 0
-OpDecorate %_entryPointOutput_vColor Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%14 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%v3float = OpTypeVector %float 3
-%mat4v3float = OpTypeMatrix %v3float 4
-%PerBatchEnvMapConstantBuffer_t = OpTypeStruct %mat4v3float %v4float %v2float
-%uint = OpTypeInt 32 0
-%uint_128 = OpConstant %uint 128
-%_arr_PerBatchEnvMapConstantBuffer_t_uint_128 = OpTypeArray %PerBatchEnvMapConstantBuffer_t %uint_128
-%_BindlessFastEnvMapCB_PS_t = OpTypeStruct %_arr_PerBatchEnvMapConstantBuffer_t_uint_128
-%_ptr_Uniform__BindlessFastEnvMapCB_PS_t = OpTypePointer Uniform %_BindlessFastEnvMapCB_PS_t
-%_ = OpVariable %_ptr_Uniform__BindlessFastEnvMapCB_PS_t Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%ushort = OpTypeInt 16 0
-%PerViewPushConst_t = OpTypeStruct %ushort
-%_ptr_PushConstant_PerViewPushConst_t = OpTypePointer PushConstant %PerViewPushConst_t
-%__0 = OpVariable %_ptr_PushConstant_PerViewPushConst_t PushConstant
-%_ptr_PushConstant_ushort = OpTypePointer PushConstant %ushort
-%int_2 = OpConstant %int 2
-%_ptr_Uniform_v2float = OpTypePointer Uniform %v2float
-%30 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%_ptr_UniformConstant_30 = OpTypePointer UniformConstant %30
-%g_tColor = OpVariable %_ptr_UniformConstant_30 UniformConstant
-%32 = OpTypeSampler
-%_ptr_UniformConstant_32 = OpTypePointer UniformConstant %32
-%g_sAniso = OpVariable %_ptr_UniformConstant_32 UniformConstant
-%34 = OpTypeSampledImage %30
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%i_vTextureCoords = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_entryPointOutput_vColor = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v2float:%\w+]] = OpConstantNull %v2float
-)" + kImportStub + R"(
-%MainPs = OpFunction %void None %14
-%37 = OpLabel
-%38 = OpLoad %v2float %i_vTextureCoords
-%39 = OpAccessChain %_ptr_PushConstant_ushort %__0 %int_0
-%40 = OpLoad %ushort %39
-%41 = OpAccessChain %_ptr_Uniform_v2float %_ %int_0 %40 %int_2
-%42 = OpLoad %v2float %41
-%43 = OpFAdd %v2float %38 %42
-;CHECK-NOT: %42 = OpLoad %v2float %41
-;CHECK-NOT: %43 = OpFAdd %v2float %38 %42
-;CHECK: {{%\w+}} = OpUConvert %uint %40
-;CHECK: {{%\w+}} = OpIMul %uint %uint_80 {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_64
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_7
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_82 {{%\w+}} %uint_0 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v2float %41
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %v2float {{%\w+}} {{%\w+}} [[null_v2float]] {{%\w+}}
-;CHECK: %43 = OpFAdd %v2float %38 {{%\w+}}
-%44 = OpLoad %30 %g_tColor
-%45 = OpLoad %32 %g_sAniso
-%46 = OpSampledImage %34 %44 %45
-%47 = OpImageSampleImplicitLod %v4float %46 %43
-OpStore %_entryPointOutput_vColor %47
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, UniformMatrixRefRowMajor) {
-  // The buffer-oob row major matrix check
-  //
-  // #version 450
-  // #extension GL_EXT_scalar_block_layout : enable
-  //
-  // layout(location = 0) in highp vec4 a_position;
-  // layout(location = 0) out mediump float v_vtxResult;
-  //
-  // layout(set = 0, binding = 0, std430, row_major) uniform Block
-  // {
-  //    lowp mat4x2 var;
-  // };
-  //
-  // void main (void)
-  // {
-  //    v_vtxResult = var[2][1];
-  // }
-
-  // clang-format off
-  std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Vertex %main "main" %v_vtxResult %_ %a_position
-;CHECK: OpEntryPoint Vertex %main "main" %v_vtxResult %_ %a_position %gl_VertexIndex %gl_InstanceIndex
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_scalar_block_layout"
-OpName %main "main"
-OpName %v_vtxResult "v_vtxResult"
-OpName %Block "Block"
-OpMemberName %Block 0 "var"
-OpName %_ ""
-OpName %a_position "a_position"
-OpDecorate %v_vtxResult RelaxedPrecision
-OpDecorate %v_vtxResult Location 0
-OpMemberDecorate %Block 0 RowMajor
-OpMemberDecorate %Block 0 RelaxedPrecision
-OpMemberDecorate %Block 0 Offset 0
-OpMemberDecorate %Block 0 MatrixStride 16
-OpDecorate %Block Block
-OpDecorate %_ DescriptorSet 0
-OpDecorate %_ Binding 0
-OpDecorate %21 RelaxedPrecision
-;CHECK-NOT: OpDecorate %21 RelaxedPrecision
-;CHECK: OpDecorate %v_vtxResult RelaxedPrecision
-;CHECK: OpDecorate [[phi_result:%\w+]] RelaxedPrecision
-OpDecorate %a_position Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_VertexIndex BuiltIn VertexIndex
-;CHECK: OpDecorate %gl_InstanceIndex BuiltIn InstanceIndex
-;CHECK: OpDecorate [[load_result:%\w+]] RelaxedPrecision
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%v_vtxResult = OpVariable %_ptr_Output_float Output
-%v2float = OpTypeVector %float 2
-%mat4v2float = OpTypeMatrix %v2float 4
-%Block = OpTypeStruct %mat4v2float
-%_ptr_Uniform_Block = OpTypePointer Uniform %Block
-%_ = OpVariable %_ptr_Uniform_Block Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%int_2 = OpConstant %int 2
-%uint = OpTypeInt 32 0
-%uint_1 = OpConstant %uint 1
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-%v4float = OpTypeVector %float 4
-%_ptr_Input_v4float = OpTypePointer Input %v4float
-%a_position = OpVariable %_ptr_Input_v4float Input
-;CHECK: %_ptr_Input_uint = OpTypePointer Input %uint
-;CHECK: %gl_VertexIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: %gl_InstanceIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-%20 = OpAccessChain %_ptr_Uniform_float %_ %int_0 %int_2 %uint_1
-%21 = OpLoad %float %20
-;CHECK-NOT: %21 = OpLoad %float %20
-;CHECK: {{%\w+}} = OpIMul %uint %uint_4 %int_2
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIMul %uint %uint_16 %uint_1
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_3
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[desc_state:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_46 {{%\w+}} %uint_0 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[desc_state]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[load_result]] = OpLoad %float %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result]] = OpPhi %float [[load_result]] {{%\w+}} [[null_float]] {{%\w+}}
-OpStore %v_vtxResult %21
-;CHECK-NOT: OpStore %v_vtxResult %21$
-;CHECK: OpStore %v_vtxResult [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, UniformMatrixRefColumnMajor) {
-  // The buffer-oob column major matrix check
-  //
-  // #version 450
-  // #extension GL_EXT_scalar_block_layout : enable
-  //
-  // layout(location = 0) in highp vec4 a_position;
-  // layout(location = 0) out mediump float v_vtxResult;
-  //
-  // layout(set = 0, binding = 0, std430, column_major) uniform Block
-  // {
-  //    lowp mat4x2 var;
-  // };
-  //
-  // void main (void)
-  // {
-  //    v_vtxResult = var[2][1];
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Vertex %main "main" %v_vtxResult %_ %a_position
-;CHECK: OpEntryPoint Vertex %main "main" %v_vtxResult %_ %a_position %gl_VertexIndex %gl_InstanceIndex
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_scalar_block_layout"
-OpName %main "main"
-OpName %v_vtxResult "v_vtxResult"
-OpName %Block "Block"
-OpMemberName %Block 0 "var"
-OpName %_ ""
-OpName %a_position "a_position"
-OpDecorate %v_vtxResult RelaxedPrecision
-OpDecorate %v_vtxResult Location 0
-OpMemberDecorate %Block 0 ColMajor
-OpMemberDecorate %Block 0 RelaxedPrecision
-OpMemberDecorate %Block 0 Offset 0
-OpMemberDecorate %Block 0 MatrixStride 8
-OpDecorate %Block Block
-OpDecorate %_ DescriptorSet 0
-OpDecorate %_ Binding 0
-OpDecorate %21 RelaxedPrecision
-;CHECK-NOT: OpDecorate %21 RelaxedPrecision
-;CHECK: OpDecorate %v_vtxResult RelaxedPrecision
-;CHECK: OpDecorate [[phi_result:%\w+]] RelaxedPrecision
-OpDecorate %a_position Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_VertexIndex BuiltIn VertexIndex
-;CHECK: OpDecorate %gl_InstanceIndex BuiltIn InstanceIndex
-;CHECK: OpDecorate [[load_result:%\w+]] RelaxedPrecision
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%_ptr_Output_float = OpTypePointer Output %float
-%v_vtxResult = OpVariable %_ptr_Output_float Output
-%v2float = OpTypeVector %float 2
-%mat4v2float = OpTypeMatrix %v2float 4
-%Block = OpTypeStruct %mat4v2float
-%_ptr_Uniform_Block = OpTypePointer Uniform %Block
-%_ = OpVariable %_ptr_Uniform_Block Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%int_2 = OpConstant %int 2
-%uint = OpTypeInt 32 0
-%uint_1 = OpConstant %uint 1
-%_ptr_Uniform_float = OpTypePointer Uniform %float
-%v4float = OpTypeVector %float 4
-%_ptr_Input_v4float = OpTypePointer Input %v4float
-%a_position = OpVariable %_ptr_Input_v4float Input
-;CHECK: %_ptr_Input_uint = OpTypePointer Input %uint
-;CHECK: %gl_VertexIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: %gl_InstanceIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: [[null_float:%\w+]] = OpConstantNull %float
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%20 = OpAccessChain %_ptr_Uniform_float %_ %int_0 %int_2 %uint_1
-%21 = OpLoad %float %20
-;CHECK-NOT: %21 = OpLoad %float %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpIMul %uint %uint_8 %int_2
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIMul %uint %uint_4 %uint_1
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_3
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[desc_state:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_46 {{%\w+}} %uint_0 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[desc_state]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK:[[load_result]] = OpLoad %float %20
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result]] = OpPhi %float [[load_result]] {{%\w+}} [[null_float]] {{%\w+}}
-OpStore %v_vtxResult %21
-;CHECK-NOT: OpStore %v_vtxResult %21$
-;CHECK: OpStore %v_vtxResult [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  ValidatorOptions()->uniform_buffer_standard_layout = true;
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, UniformMatrixVecRefRowMajor) {
-  // The buffer-oob row major matrix vector ref check
-  //
-  // #version 450
-  // #extension GL_EXT_scalar_block_layout : enable
-  //
-  // layout(location = 0) in highp vec4 a_position;
-  // layout(location = 0) out highp vec2 v_vtxResult;
-  //
-  // layout(set = 3, binding = 7, std430, row_major) uniform Block
-  // {
-  //    lowp mat2 var[3][4];
-  // };
-  //
-  // void main (void)
-  // {
-  //    v_vtxResult = var[2][3][1];
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Vertex %main "main" %v_vtxResult %_ %a_position
-;CHECK: OpEntryPoint Vertex %main "main" %v_vtxResult %_ %a_position %gl_VertexIndex %gl_InstanceIndex
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_scalar_block_layout"
-OpName %main "main"
-OpName %v_vtxResult "v_vtxResult"
-OpName %Block "Block"
-OpMemberName %Block 0 "var"
-OpName %_ ""
-OpName %a_position "a_position"
-OpDecorate %v_vtxResult Location 0
-OpDecorate %_arr_mat2v2float_uint_4 ArrayStride 32
-OpDecorate %_arr__arr_mat2v2float_uint_4_uint_3 ArrayStride 128
-OpMemberDecorate %Block 0 RowMajor
-OpMemberDecorate %Block 0 RelaxedPrecision
-OpMemberDecorate %Block 0 Offset 0
-OpMemberDecorate %Block 0 MatrixStride 16
-OpDecorate %Block Block
-OpDecorate %_ DescriptorSet 3
-OpDecorate %_ Binding 7
-OpDecorate %26 RelaxedPrecision
-;CHECK-NOT: OpDecorate %26 RelaxedPrecision
-;CHECK: OpDecorate [[phi_result:%\w+]] RelaxedPrecision
-OpDecorate %a_position Location 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_VertexIndex BuiltIn VertexIndex
-;CHECK: OpDecorate %gl_InstanceIndex BuiltIn InstanceIndex
-;CHECK: OpDecorate [[load_result:%\w+]] RelaxedPrecision
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%_ptr_Output_v2float = OpTypePointer Output %v2float
-%v_vtxResult = OpVariable %_ptr_Output_v2float Output
-%mat2v2float = OpTypeMatrix %v2float 2
-%uint = OpTypeInt 32 0
-%uint_4 = OpConstant %uint 4
-%_arr_mat2v2float_uint_4 = OpTypeArray %mat2v2float %uint_4
-%uint_3 = OpConstant %uint 3
-%_arr__arr_mat2v2float_uint_4_uint_3 = OpTypeArray %_arr_mat2v2float_uint_4 %uint_3
-%Block = OpTypeStruct %_arr__arr_mat2v2float_uint_4_uint_3
-%_ptr_Uniform_Block = OpTypePointer Uniform %Block
-%_ = OpVariable %_ptr_Uniform_Block Uniform
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%int_2 = OpConstant %int 2
-%int_3 = OpConstant %int 3
-%int_1 = OpConstant %int 1
-%_ptr_Uniform_v2float = OpTypePointer Uniform %v2float
-%v4float = OpTypeVector %float 4
-%_ptr_Input_v4float = OpTypePointer Input %v4float
-%a_position = OpVariable %_ptr_Input_v4float Input
-;CHECK: %_ptr_Input_uint = OpTypePointer Input %uint
-;CHECK: %gl_VertexIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: %gl_InstanceIndex = OpVariable %_ptr_Input_uint Input
-;CHECK: [[null_v2float:%\w+]] = OpConstantNull %v2float
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%25 = OpAccessChain %_ptr_Uniform_v2float %_ %int_0 %int_2 %int_3 %int_1
-;CHECK: {{%\w+}} = OpIMul %uint %uint_128 %int_2
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIMul %uint %uint_32 %int_3
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpIMul %uint %uint_4 %int_1
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_19
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[desc_state:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_52 {{%\w+}} %uint_3 %uint_7 %uint_0 {{%\w+}}
-%26 = OpLoad %v2float %25
-OpStore %v_vtxResult %26
-;CHECK-NOT: %26 = OpLoad %v2float %25
-;CHECK-NOT: OpStore %v_vtxResult %26
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[desc_state]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[load_result]] = OpLoad %v2float %25
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result]] = OpPhi %v2float [[load_result]] {{%\w+}} [[null_v2float]] {{%\w+}}
-;CHECK: OpStore %v_vtxResult [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, ImageBufferOOBRead) {
-  // Texel buffer (imagebuffer) oob check for ImageRead
-  //
-  // #version 450
-  // layout(set=3, binding=7, r32f) uniform readonly imageBuffer s;
-  // layout(location=11) out vec4 x;
-  // layout(location=13) in flat int ii;
-  //
-  // void main(){
-  //    x = imageLoad(s, ii);
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability ImageBuffer
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %x %s %ii
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpName %main "main"
-OpName %x "x"
-OpName %s "s"
-OpName %ii "ii"
-OpDecorate %x Location 11
-OpDecorate %s DescriptorSet 3
-OpDecorate %s Binding 7
-OpDecorate %s NonWritable
-OpDecorate %ii Flat
-OpDecorate %ii Location 13
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v4float = OpTypeVector %float 4
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%x = OpVariable %_ptr_Output_v4float Output
-%10 = OpTypeImage %float Buffer 0 0 0 2 R32f
-%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10
-%s = OpVariable %_ptr_UniformConstant_10 UniformConstant
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%ii = OpVariable %_ptr_Input_int Input
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-%main = OpFunction %void None %3
-%5 = OpLabel
-;CHECK: OpBranch %19
-;CHECK: %19 = OpLabel
-%13 = OpLoad %10 %s
-%17 = OpLoad %int %ii
-%18 = OpImageRead %v4float %13 %17
-OpStore %x %18
-;CHECK-NOT: %18 = OpImageRead %v4float %13 %17
-;CHECK-NOT: OpStore %x %18
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_34 {{%\w+}} %uint_3 %uint_7 %uint_0 %22
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %10 %s
-;CHECK: {{%\w+}} = OpImageRead %v4float {{%\w+}} %17
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %x [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, ImageBufferOOBWrite) {
-  // Texel buffer (imagebuffer) oob check for ImageWrite
-  //
-  // #version 450
-  // layout(set=3, binding=7, r32f) uniform readonly imageBuffer s;
-  // layout(location=11) out vec4 x;
-  // layout(location=13) in flat int ii;
-  //
-  // void main(){
-  //    imageStore(s, ii, x);
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability ImageBuffer
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %s %ii %x
-;CHECK: OpEntryPoint Fragment %main "main" %s %ii %x %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpName %main "main"
-OpName %s "s"
-OpName %ii "ii"
-OpName %x "x"
-OpDecorate %s DescriptorSet 3
-OpDecorate %s Binding 7
-OpDecorate %s NonReadable
-OpDecorate %ii Flat
-OpDecorate %ii Location 13
-OpDecorate %x Location 11
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%7 = OpTypeImage %float Buffer 0 0 0 2 R32f
-%_ptr_UniformConstant_7 = OpTypePointer UniformConstant %7
-%s = OpVariable %_ptr_UniformConstant_7 UniformConstant
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%ii = OpVariable %_ptr_Input_int Input
-%v4float = OpTypeVector %float 4
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%x = OpVariable %_ptr_Output_v4float Output
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: %19 = OpLabel
-%10 = OpLoad %7 %s
-%14 = OpLoad %int %ii
-%18 = OpLoad %v4float %x
-OpImageWrite %10 %14 %18
-;CHECK-NOT: OpImageWrite %10 %14 %18
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_35 {{%\w+}} %uint_3 %uint_7 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %7 %s
-;CHECK: OpImageWrite {{%\w+}} %14 %18
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, TextureBufferOOBFetch) {
-  // Texel buffer (texturebuffer) oob check for ImageFetch
-  //
-  // #version 450
-  // layout(set=3, binding=7) uniform textureBuffer s;
-  // layout(location=11) out vec4 x;
-  // layout(location=13) in flat int ii;
-  //
-  // void main(){
-  //    x = texelFetch(s, ii);
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability SampledBuffer
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %x %s %ii
-;CHECK: OpEntryPoint Fragment %main "main" %x %s %ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpName %main "main"
-OpName %x "x"
-OpName %s "s"
-OpName %ii "ii"
-OpDecorate %x Location 11
-OpDecorate %s DescriptorSet 3
-OpDecorate %s Binding 7
-OpDecorate %ii Flat
-OpDecorate %ii Location 13
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v4float = OpTypeVector %float 4
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%x = OpVariable %_ptr_Output_v4float Output
-%10 = OpTypeImage %float Buffer 0 0 0 1 Unknown
-%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10
-%s = OpVariable %_ptr_UniformConstant_10 UniformConstant
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%ii = OpVariable %_ptr_Input_int Input
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-%main = OpFunction %void None %3
-%5 = OpLabel
-;CHECK: OpBranch %19
-;CHECK: %19 = OpLabel
-%13 = OpLoad %10 %s
-%17 = OpLoad %int %ii
-%18 = OpImageFetch %v4float %13 %17
-OpStore %x %18
-;CHECK-NOT: %18 = OpImageFetch %v4float %13 %17
-;CHECK-NOT: OpStore %x %18
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_33 {{%\w+}} %uint_3 %uint_7 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %10 %s
-;CHECK: {{%\w+}} = OpImageFetch %v4float {{%\w+}} %17
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %x [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, SamplerBufferOOBFetch) {
-  // Texel buffer (samplerbuffer) oob check for ImageFetch
-  //
-  // #version 450
-  // layout(set=3, binding=7) uniform samplerBuffer s;
-  // layout(location=11) out vec4 x;
-  // layout(location=13) in flat int ii;
-  //
-  // void main(){
-  //    x = texelFetch(s, ii);
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability SampledBuffer
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %x %s %ii
-;CHECK: OpEntryPoint Fragment %main "main" %x %s %ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpName %main "main"
-OpName %x "x"
-OpName %s "s"
-OpName %ii "ii"
-OpDecorate %x Location 11
-OpDecorate %s DescriptorSet 3
-OpDecorate %s Binding 7
-OpDecorate %ii Flat
-OpDecorate %ii Location 13
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v4float = OpTypeVector %float 4
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%x = OpVariable %_ptr_Output_v4float Output
-%10 = OpTypeImage %float Buffer 0 0 0 1 Unknown
-%11 = OpTypeSampledImage %10
-%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11
-%s = OpVariable %_ptr_UniformConstant_11 UniformConstant
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%ii = OpVariable %_ptr_Input_int Input
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-;CHECK: OpBranch %21
-;CHECK: %21 = OpLabel
-%14 = OpLoad %11 %s
-%18 = OpLoad %int %ii
-%19 = OpImage %10 %14
-%20 = OpImageFetch %v4float %19 %18
-OpStore %x %20
-;CHECK-NOT: %20 = OpImageFetch %v4float %19 %18
-;CHECK-NOT: OpStore %x %20
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_35 {{%\w+}} %uint_3 %uint_7 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %11 %s
-;CHECK: {{%\w+}} = OpImage %10 {{%\w+}}
-;CHECK: {{%\w+}} = OpImageFetch %v4float {{%\w+}} {{%\w+}}
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %x [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, SamplerBufferConstructorOOBFetch) {
-  // Texel buffer (samplerbuffer constructor) oob check for ImageFetch
-  //
-  // #version 450
-  // layout(set=3, binding=7) uniform textureBuffer tBuf;
-  // layout(set=3, binding=8) uniform sampler s;
-  // layout(location=11) out vec4 x;
-  // layout(location=13) in flat int ii;
-  //
-  // void main(){
-  //    x = texelFetch(samplerBuffer(tBuf, s), ii);
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability SampledBuffer
-;CHECK: OpCapability Linkage
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %main "main" %x %tBuf %s %ii
-;CHECK: OpEntryPoint Fragment %main "main" %x %tBuf %s %ii %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpName %main "main"
-OpName %x "x"
-OpName %tBuf "tBuf"
-OpName %s "s"
-OpName %ii "ii"
-OpDecorate %x Location 11
-OpDecorate %tBuf DescriptorSet 3
-OpDecorate %tBuf Binding 7
-OpDecorate %s DescriptorSet 3
-OpDecorate %s Binding 8
-OpDecorate %ii Flat
-OpDecorate %ii Location 13
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v4float = OpTypeVector %float 4
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%x = OpVariable %_ptr_Output_v4float Output
-%10 = OpTypeImage %float Buffer 0 0 0 1 Unknown
-%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10
-%tBuf = OpVariable %_ptr_UniformConstant_10 UniformConstant
-%14 = OpTypeSampler
-%_ptr_UniformConstant_14 = OpTypePointer UniformConstant %14
-%s = OpVariable %_ptr_UniformConstant_14 UniformConstant
-%18 = OpTypeSampledImage %10
-%int = OpTypeInt 32 1
-%_ptr_Input_int = OpTypePointer Input %int
-%ii = OpVariable %_ptr_Input_int Input
-;CHECK: %_ptr_Input_v4float = OpTypePointer Input %v4float
-;CHECK: %gl_FragCoord = OpVariable %_ptr_Input_v4float Input
-;CHECK: [[null_v4float:%\w+]] = OpConstantNull %v4float
-%main = OpFunction %void None %3
-%5 = OpLabel
-%13 = OpLoad %10 %tBuf
-%17 = OpLoad %14 %s
-%19 = OpSampledImage %18 %13 %17
-%23 = OpLoad %int %ii
-%24 = OpImage %10 %19
-%25 = OpImageFetch %v4float %24 %23
-OpStore %x %25
-;CHECK-NOT: %25 = OpImageFetch %v4float %24 %23
-;CHECK-NOT: OpStore %x %25
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_43 {{%\w+}} %uint_3 %uint_7 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %10 %tBuf
-;CHECK: {{%\w+}} = OpSampledImage %18 {{%\w+}} %17
-;CHECK: {{%\w+}} = OpImage %10 {{%\w+}}
-;CHECK: {{%\w+}} = OpImageFetch %v4float {{%\w+}} %23
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v4float {{%\w+}} {{%\w+}} [[null_v4float]] {{%\w+}}
-;CHECK: OpStore %x [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, DeviceBufferAddressOOB) {
-  // #version 450
-  // #extension GL_EXT_buffer_reference : enable
-  //  layout(buffer_reference, buffer_reference_align = 16) buffer bufStruct;
-  // layout(set = 0, binding = 0) uniform ufoo {
-  //     bufStruct data;
-  //     int nWrites;
-  // } u_info;
-  // layout(buffer_reference, std140) buffer bufStruct {
-  //     int a[4];
-  // };
-  // void main() {
-  //     for (int i=0; i < u_info.nWrites; ++i) {
-  //         u_info.data.a[i] = 0xdeadca71;
-  //     }
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability PhysicalStorageBufferAddresses
-;CHECK: OpCapability Linkage
-;CHECK: OpCapability Int64
-OpExtension "SPV_KHR_physical_storage_buffer"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint Vertex %main "main" %u_info
-;CHECK: OpEntryPoint Vertex %main "main" %u_info %gl_VertexIndex %gl_InstanceIndex
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_buffer_reference"
-OpName %main "main"
-OpName %i "i"
-OpName %ufoo "ufoo"
-OpMemberName %ufoo 0 "data"
-OpMemberName %ufoo 1 "nWrites"
-OpName %bufStruct "bufStruct"
-OpMemberName %bufStruct 0 "a"
-OpName %u_info "u_info"
-OpMemberDecorate %ufoo 0 Offset 0
-OpMemberDecorate %ufoo 1 Offset 8
-OpDecorate %ufoo Block
-OpDecorate %_arr_int_uint_4 ArrayStride 16
-OpMemberDecorate %bufStruct 0 Offset 0
-OpDecorate %bufStruct Block
-OpDecorate %u_info DescriptorSet 0
-OpDecorate %u_info Binding 0
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%int = OpTypeInt 32 1
-%_ptr_Function_int = OpTypePointer Function %int
-%int_0 = OpConstant %int 0
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_bufStruct PhysicalStorageBuffer
-%ufoo = OpTypeStruct %_ptr_PhysicalStorageBuffer_bufStruct %int
-%uint = OpTypeInt 32 0
-%uint_4 = OpConstant %uint 4
-%_arr_int_uint_4 = OpTypeArray %int %uint_4
-%bufStruct = OpTypeStruct %_arr_int_uint_4
-%_ptr_PhysicalStorageBuffer_bufStruct = OpTypePointer PhysicalStorageBuffer %bufStruct
-%_ptr_Uniform_ufoo = OpTypePointer Uniform %ufoo
-%u_info = OpVariable %_ptr_Uniform_ufoo Uniform
-%int_1 = OpConstant %int 1
-%_ptr_Uniform_int = OpTypePointer Uniform %int
-%bool = OpTypeBool
-%_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct = OpTypePointer Uniform %_ptr_PhysicalStorageBuffer_bufStruct
-%int_n559035791 = OpConstant %int -559035791
-%_ptr_PhysicalStorageBuffer_int = OpTypePointer PhysicalStorageBuffer %int
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%i = OpVariable %_ptr_Function_int Function
-OpStore %i %int_0
-OpBranch %10
-%10 = OpLabel
-OpLoopMerge %12 %13 None
-OpBranch %14
-%14 = OpLabel
-%15 = OpLoad %int %i
-%26 = OpAccessChain %_ptr_Uniform_int %u_info %int_1
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_8 %uint_3
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_56 {{%\w+}} %uint_0 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[load_result:%\w+]] = OpLoad %int %26
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %int [[load_result]] {{%\w+}} {{%\w+}} {{%\w+}}
-%27 = OpLoad %int %26
-%29 = OpSLessThan %bool %15 %27
-;CHECK-NOT: %27 = OpLoad %int %26
-;CHECK-NOT: %29 = OpSLessThan %bool %15 %27
-;CHECK: %29 = OpSLessThan %bool %15 [[phi_result]]
-OpBranchConditional %29 %11 %12
-%11 = OpLabel
-%31 = OpAccessChain %_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct %u_info %int_0
-%32 = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %31
-;CHECK-NOT: %32 = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %31
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 %uint_7
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_61 {{%\w+}} %uint_0 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[load_result_2:%\w+]] = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %31
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpConvertUToPtr %_ptr_PhysicalStorageBuffer_bufStruct {{%\w+}}
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result_2:%\w+]] = OpPhi %_ptr_PhysicalStorageBuffer_bufStruct [[load_result_2]] {{%\w+}} {{%\w+}} {{%\w+}}
-%33 = OpLoad %int %i
-%36 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %32 %int_0 %33
-;CHECK-NOT: %36 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %32 %int_0 %33
-;CHECK: %36 = OpAccessChain %_ptr_PhysicalStorageBuffer_int [[phi_result_2]] %int_0 %33
-OpStore %36 %int_n559035791 Aligned 16
-OpBranch %13
-%13 = OpLabel
-%37 = OpLoad %int %i
-%38 = OpIAdd %int %37 %int_1
-OpStore %i %38
-OpBranch %10
-%12 = OpLabel
-OpReturn
-OpFunctionEnd)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-TEST_F(InstBindlessTest, VertexIndexOOB) {
-  // #version 450
-  // layout(std140, binding = 0) uniform foo { uint tex_index[1]; }
-  // uniform_index_buffer; layout(location = 0) out flat uint index; vec2
-  // vertices[3]; void main() {
-  //     vertices[0] = vec2(-1.0, -1.0);
-  //     vertices[1] = vec2( 1.0, -1.0);
-  //     vertices[2] = vec2( 0.0,  1.0);
-  //     gl_Position = vec4(vertices[gl_VertexIndex % 3], 0.0, 1.0);
-  //     index = uniform_index_buffer.tex_index[0];
-  // }
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Vertex %main "main" %vertices %_ %gl_VertexIndex %index %uniform_index_buffer
-OpSource GLSL 450
-OpName %main "main"
-OpName %vertices "vertices"
-OpName %gl_PerVertex "gl_PerVertex"
-OpMemberName %gl_PerVertex 0 "gl_Position"
-OpMemberName %gl_PerVertex 1 "gl_PointSize"
-OpMemberName %gl_PerVertex 2 "gl_ClipDistance"
-OpMemberName %gl_PerVertex 3 "gl_CullDistance"
-OpName %_ ""
-OpName %gl_VertexIndex "gl_VertexIndex"
-OpName %index "index"
-OpName %foo "foo"
-OpMemberName %foo 0 "tex_index"
-OpName %uniform_index_buffer "uniform_index_buffer"
-OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
-OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
-OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
-OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
-OpDecorate %gl_PerVertex Block
-OpDecorate %gl_VertexIndex BuiltIn VertexIndex
-OpDecorate %index Flat
-OpDecorate %index Location 0
-OpDecorate %_arr_uint_uint_1 ArrayStride 16
-OpMemberDecorate %foo 0 Offset 0
-OpDecorate %foo Block
-OpDecorate %uniform_index_buffer DescriptorSet 0
-OpDecorate %uniform_index_buffer Binding 0
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%uint = OpTypeInt 32 0
-%uint_3 = OpConstant %uint 3
-%_arr_v2float_uint_3 = OpTypeArray %v2float %uint_3
-%_ptr_Private__arr_v2float_uint_3 = OpTypePointer Private %_arr_v2float_uint_3
-%vertices = OpVariable %_ptr_Private__arr_v2float_uint_3 Private
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%float_n1 = OpConstant %float -1
-%16 = OpConstantComposite %v2float %float_n1 %float_n1
-%_ptr_Private_v2float = OpTypePointer Private %v2float
-%int_1 = OpConstant %int 1
-%float_1 = OpConstant %float 1
-%21 = OpConstantComposite %v2float %float_1 %float_n1
-%int_2 = OpConstant %int 2
-%float_0 = OpConstant %float 0
-%25 = OpConstantComposite %v2float %float_0 %float_1
-%v4float = OpTypeVector %float 4
-%uint_1 = OpConstant %uint 1
-%_arr_float_uint_1 = OpTypeArray %float %uint_1
-%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
-%_ptr_Output_gl_PerVertex = OpTypePointer Output %gl_PerVertex
-%_ = OpVariable %_ptr_Output_gl_PerVertex Output
-%_ptr_Input_int = OpTypePointer Input %int
-%gl_VertexIndex = OpVariable %_ptr_Input_int Input
-%int_3 = OpConstant %int 3
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%_ptr_Output_uint = OpTypePointer Output %uint
-%index = OpVariable %_ptr_Output_uint Output
-%_arr_uint_uint_1 = OpTypeArray %uint %uint_1
-%foo = OpTypeStruct %_arr_uint_uint_1
-%_ptr_Uniform_foo = OpTypePointer Uniform %foo
-%uniform_index_buffer = OpVariable %_ptr_Uniform_foo Uniform
-%_ptr_Uniform_uint = OpTypePointer Uniform %uint
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%18 = OpAccessChain %_ptr_Private_v2float %vertices %int_0
-OpStore %18 %16
-%22 = OpAccessChain %_ptr_Private_v2float %vertices %int_1
-OpStore %22 %21
-%26 = OpAccessChain %_ptr_Private_v2float %vertices %int_2
-OpStore %26 %25
-%35 = OpLoad %int %gl_VertexIndex
-%37 = OpSMod %int %35 %int_3
-%38 = OpAccessChain %_ptr_Private_v2float %vertices %37
-%39 = OpLoad %v2float %38
-%40 = OpCompositeExtract %float %39 0
-%41 = OpCompositeExtract %float %39 1
-%42 = OpCompositeConstruct %v4float %40 %41 %float_0 %float_1
-%44 = OpAccessChain %_ptr_Output_v4float %_ %int_0
-OpStore %44 %42
-%52 = OpAccessChain %_ptr_Uniform_uint %uniform_index_buffer %int_0 %int_0
-%53 = OpLoad %uint %52
-;CHECK-NOT: %53 = OpLoad %uint %52
-;CHECK: {{%\w+}} = OpIMul %uint %uint_16 %int_0
-;CHECK: {{%\w+}} = OpIAdd %uint %uint_0 {{%\w+}}
-;CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_3
-;CHECK: {{%\w+}} = OpLoad %int %gl_VertexIndex
-;CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_87 {{%\w+}} %uint_0 %uint_0 %uint_0 {{%\w+}}
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %uint %52
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %uint {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %index [[phi_result]]
-OpStore %index %53
-;CHECK-NOT: OpStore %index %53
-OpReturn
-;CHECK: OpReturn
-OpFunctionEnd)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBindlessCheckPass>(text, true, 23u);
-}
-
-// TODO(greg-lunarg): Add tests to verify handling of these cases:
-//
-//   Compute shader
-//   Geometry shader
-//   Tessellation control shader
-//   Tessellation eval shader
-//   OpImage
-//   SampledImage variable
-
-}  // namespace
-}  // namespace opt
-}  // namespace spvtools
diff --git a/test/opt/inst_buff_addr_check_test.cpp b/test/opt/inst_buff_addr_check_test.cpp
deleted file mode 100644
index 72d34385..00000000
--- a/test/opt/inst_buff_addr_check_test.cpp
+++ /dev/null
@@ -1,772 +0,0 @@
-// Copyright (c) 2019-2022 Valve Corporation
-// Copyright (c) 2019-2022 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Bindless Check Instrumentation Tests.
-// Tests ending with V2 use version 2 record format.
-
-#include <string>
-#include <vector>
-
-#include "test/opt/pass_fixture.h"
-#include "test/opt/pass_utils.h"
-
-namespace spvtools {
-namespace opt {
-namespace {
-
-static const std::string kFuncName = "inst_buff_addr_search_and_test";
-static const std::string kImportDeco = R"(
-;CHECK: OpDecorate %)" + kFuncName + R"( LinkageAttributes ")" +
-                                       kFuncName + R"(" Import
-)";
-static const std::string kImportStub = R"(
-;CHECK: %)" + kFuncName + R"( = OpFunction %bool None {{%\w+}}
-;CHECK: OpFunctionEnd
-)";
-// clang-format on
-
-using InstBuffAddrTest = PassTest<::testing::Test>;
-
-TEST_F(InstBuffAddrTest, InstPhysicalStorageBufferStore) {
-  // #version 450
-  // #extension GL_EXT_buffer_reference : enable
-  //
-  // layout(buffer_reference, buffer_reference_align = 16) buffer bufStruct;
-  //
-  // layout(set = 0, binding = 0) uniform ufoo {
-  //     bufStruct data;
-  //     uint offset;
-  // } u_info;
-  //
-  // layout(buffer_reference, std140) buffer bufStruct {
-  //     layout(offset = 0) int a[2];
-  //     layout(offset = 32) int b;
-  // };
-  //
-  // void main() {
-  //     u_info.data.b = 0xca7;
-  // }
-
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability PhysicalStorageBufferAddresses
-;CHECK: OpCapability Int64
-OpExtension "SPV_EXT_physical_storage_buffer"
-;CHECK: OpExtension "SPV_KHR_storage_buffer_storage_class"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint GLCompute %main "main"
-;CHECK: OpEntryPoint GLCompute %main "main" %gl_GlobalInvocationID
-OpExecutionMode %main LocalSize 1 1 1
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_buffer_reference"
-OpName %main "main"
-OpName %ufoo "ufoo"
-OpMemberName %ufoo 0 "data"
-OpMemberName %ufoo 1 "offset"
-OpName %bufStruct "bufStruct"
-OpMemberName %bufStruct 0 "a"
-OpMemberName %bufStruct 1 "b"
-OpName %u_info "u_info"
-)";
-
-  // clang-format off
-  const std::string decorates = R"(
-OpMemberDecorate %ufoo 0 Offset 0
-OpMemberDecorate %ufoo 1 Offset 8
-OpDecorate %ufoo Block
-OpDecorate %_arr_int_uint_2 ArrayStride 16
-OpMemberDecorate %bufStruct 0 Offset 0
-OpMemberDecorate %bufStruct 1 Offset 32
-OpDecorate %bufStruct Block
-OpDecorate %u_info DescriptorSet 0
-OpDecorate %u_info Binding 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_GlobalInvocationID BuiltIn GlobalInvocationId
-)";
-
-  const std::string globals = R"(
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_bufStruct PhysicalStorageBuffer
-%uint = OpTypeInt 32 0
-%ufoo = OpTypeStruct %_ptr_PhysicalStorageBuffer_bufStruct %uint
-%int = OpTypeInt 32 1
-%uint_2 = OpConstant %uint 2
-%_arr_int_uint_2 = OpTypeArray %int %uint_2
-%bufStruct = OpTypeStruct %_arr_int_uint_2 %int
-%_ptr_PhysicalStorageBuffer_bufStruct = OpTypePointer PhysicalStorageBuffer %bufStruct
-%_ptr_Uniform_ufoo = OpTypePointer Uniform %ufoo
-%u_info = OpVariable %_ptr_Uniform_ufoo Uniform
-%int_0 = OpConstant %int 0
-%_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct = OpTypePointer Uniform %_ptr_PhysicalStorageBuffer_bufStruct
-%int_1 = OpConstant %int 1
-%int_3239 = OpConstant %int 3239
-%_ptr_PhysicalStorageBuffer_int = OpTypePointer PhysicalStorageBuffer %int
-;CHECK: %ulong = OpTypeInt 64 0
-;CHECK: %bool = OpTypeBool
-;CHECK: %v3uint = OpTypeVector %uint 3
-;CHECK: %_ptr_Input_v3uint = OpTypePointer Input %v3uint
-;CHECK: %gl_GlobalInvocationID = OpVariable %_ptr_Input_v3uint Input
-)";
-// clang-format off
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%17 = OpAccessChain %_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct %u_info %int_0
-%18 = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %17
-%22 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %18 %int_1
-;CHECK-NOT: %17 = OpAccessChain %_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct %u_info %int_0
-;CHECK-NOT: %18 = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %17
-;CHECK-NOT: %22 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %18 %int_1
-;CHECK: %20 = OpAccessChain %_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct %u_info %int_0
-;CHECK: %21 = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %20
-;CHECK: %22 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %21 %int_1
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %22
-;CHECK: {{%\w+}} = OpLoad %v3uint %gl_GlobalInvocationID
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_49 {{%\w+}} {{%\w+}} %uint_4
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpStore %22 %int_3239 Aligned 16
-;CHECK: OpStore %22 %int_3239 Aligned 16
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-
-  // SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBuffAddrCheckPass>(
-      defs + decorates + globals + kImportStub + main_func, true, 23u);
-}
-
-TEST_F(InstBuffAddrTest, InstPhysicalStorageBufferLoadAndStore) {
-  // #version 450
-  // #extension GL_EXT_buffer_reference : enable
-
-  // // forward reference
-  // layout(buffer_reference) buffer blockType;
-
-  // layout(buffer_reference, std430, buffer_reference_align = 16) buffer
-  // blockType {
-  //   int x;
-  //   blockType next;
-  // };
-
-  // layout(std430) buffer rootBlock {
-  //   blockType root;
-  // } r;
-
-  // void main()
-  // {
-  //   blockType b = r.root;
-  //   b = b.next;
-  //   b.x = 531;
-  // }
-
-  const std::string defs = R"(
-OpCapability Shader
-OpCapability PhysicalStorageBufferAddresses
-;CHECK: OpCapability Int64
-OpExtension "SPV_EXT_physical_storage_buffer"
-OpExtension "SPV_KHR_storage_buffer_storage_class"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint GLCompute %main "main"
-OpExecutionMode %main LocalSize 1 1 1
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_buffer_reference"
-OpName %main "main"
-;CHECK: OpEntryPoint GLCompute %main "main" %gl_GlobalInvocationID
-OpName %blockType "blockType"
-OpMemberName %blockType 0 "x"
-OpMemberName %blockType 1 "next"
-OpName %rootBlock "rootBlock"
-OpMemberName %rootBlock 0 "root"
-OpName %r "r"
-)";
-
-// clang-format off
-  const std::string decorates = R"(
-OpMemberDecorate %blockType 0 Offset 0
-OpMemberDecorate %blockType 1 Offset 8
-OpDecorate %blockType Block
-OpMemberDecorate %rootBlock 0 Offset 0
-OpDecorate %rootBlock Block
-OpDecorate %r DescriptorSet 0
-OpDecorate %r Binding 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_GlobalInvocationID BuiltIn GlobalInvocationId
-)";
-
-  const std::string globals = R"(
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_blockType PhysicalStorageBuffer
-%int = OpTypeInt 32 1
-%blockType = OpTypeStruct %int %_ptr_PhysicalStorageBuffer_blockType
-%_ptr_PhysicalStorageBuffer_blockType = OpTypePointer PhysicalStorageBuffer %blockType
-%rootBlock = OpTypeStruct %_ptr_PhysicalStorageBuffer_blockType
-%_ptr_StorageBuffer_rootBlock = OpTypePointer StorageBuffer %rootBlock
-%r = OpVariable %_ptr_StorageBuffer_rootBlock StorageBuffer
-%int_0 = OpConstant %int 0
-%_ptr_StorageBuffer__ptr_PhysicalStorageBuffer_blockType = OpTypePointer StorageBuffer %_ptr_PhysicalStorageBuffer_blockType
-%int_1 = OpConstant %int 1
-%_ptr_PhysicalStorageBuffer__ptr_PhysicalStorageBuffer_blockType = OpTypePointer PhysicalStorageBuffer %_ptr_PhysicalStorageBuffer_blockType
-%int_531 = OpConstant %int 531
-%_ptr_PhysicalStorageBuffer_int = OpTypePointer PhysicalStorageBuffer %int
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%16 = OpAccessChain %_ptr_StorageBuffer__ptr_PhysicalStorageBuffer_blockType %r %int_0
-%17 = OpLoad %_ptr_PhysicalStorageBuffer_blockType %16
-%21 = OpAccessChain %_ptr_PhysicalStorageBuffer__ptr_PhysicalStorageBuffer_blockType %17 %int_1
-%22 = OpLoad %_ptr_PhysicalStorageBuffer_blockType %21 Aligned 8
-%26 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %22 %int_0
-OpStore %26 %int_531 Aligned 16
-;CHECK-NOT: %22 = OpLoad %_ptr_PhysicalStorageBuffer_blockType %21 Aligned 8
-;CHECK-NOT: %26 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %22 %int_0
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %21
-;CHECK: {{%\w+}} = OpLoad %v3uint %gl_GlobalInvocationID
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_45 {{%\w+}} {{%\w+}} %uint_8
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %_ptr_PhysicalStorageBuffer_blockType %21 Aligned 8
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpConvertUToPtr %_ptr_PhysicalStorageBuffer_blockType %52
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpPhi %_ptr_PhysicalStorageBuffer_blockType {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: %26 = OpAccessChain %_ptr_PhysicalStorageBuffer_int {{%\w+}} %int_0
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %26
-;CHECK: {{%\w+}} = OpLoad %v3uint %gl_GlobalInvocationID
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 2
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_5 {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_47 {{%\w+}} {{%\w+}} %uint_4
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %26 %int_531 Aligned 16
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBuffAddrCheckPass>(
-      defs + decorates + globals + kImportStub + main_func, true, 23u);
-}
-
-TEST_F(InstBuffAddrTest, StructLoad) {
-  // #version 450
-  //   #extension GL_EXT_buffer_reference : enable
-  //   #extension GL_ARB_gpu_shader_int64 : enable
-  //   struct Test {
-  //   float a;
-  // };
-  //
-  // layout(buffer_reference, std430, buffer_reference_align = 16) buffer
-  // TestBuffer { Test test; };
-  //
-  // Test GetTest(uint64_t ptr) {
-  //   return TestBuffer(ptr).test;
-  // }
-  //
-  // void main() {
-  //   GetTest(0xe0000000);
-  // }
-
-  const std::string defs =
-      R"(
-OpCapability Shader
-OpCapability Int64
-OpCapability PhysicalStorageBufferAddresses
-;CHECK: OpExtension "SPV_KHR_storage_buffer_storage_class"
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint Fragment %main "main"
-;CHECK: OpEntryPoint Fragment %main "main" %gl_FragCoord
-OpExecutionMode %main OriginUpperLeft
-OpSource GLSL 450
-OpSourceExtension "GL_ARB_gpu_shader_int64"
-OpSourceExtension "GL_EXT_buffer_reference"
-OpName %main "main"
-OpName %Test "Test"
-OpMemberName %Test 0 "a"
-OpName %Test_0 "Test"
-OpMemberName %Test_0 0 "a"
-OpName %TestBuffer "TestBuffer"
-OpMemberName %TestBuffer 0 "test"
-)";
-
-  // clang-format off
-  const std::string decorates = R"(
-OpMemberDecorate %Test_0 0 Offset 0
-OpMemberDecorate %TestBuffer 0 Offset 0
-OpDecorate %TestBuffer Block
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_FragCoord BuiltIn FragCoord
-)";
-
-  const std::string globals = R"(
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%ulong = OpTypeInt 64 0
-%float = OpTypeFloat 32
-%Test = OpTypeStruct %float
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_TestBuffer PhysicalStorageBuffer
-%Test_0 = OpTypeStruct %float
-%TestBuffer = OpTypeStruct %Test_0
-%_ptr_PhysicalStorageBuffer_TestBuffer = OpTypePointer PhysicalStorageBuffer %TestBuffer
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%_ptr_PhysicalStorageBuffer_Test_0 = OpTypePointer PhysicalStorageBuffer %Test_0
-%ulong_18446744073172680704 = OpConstant %ulong 18446744073172680704
-;CHECK: {{%\w+}} = OpConstantNull %Test_0
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%37 = OpConvertUToPtr %_ptr_PhysicalStorageBuffer_TestBuffer %ulong_18446744073172680704
-%38 = OpAccessChain %_ptr_PhysicalStorageBuffer_Test_0 %37 %int_0
-%39 = OpLoad %Test_0 %38 Aligned 16
-;CHECK-NOT: %39 = OpLoad %Test_0 %38 Aligned 16
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %38
-;CHECK: {{%\w+}} = OpLoad %v4float %gl_FragCoord
-;CHECK: {{%\w+}} = OpBitcast %v4uint {{%\w+}}
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 0
-;CHECK: {{%\w+}} = OpCompositeExtract %uint {{%\w+}} 1
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_4 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_38 {{%\w+}} {{%\w+}} %uint_4
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %Test_0 %38 Aligned 16
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %Test_0 {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-%40 = OpCopyLogical %Test %39
-;CHECK-NOT: %40 = OpCopyLogical %Test %39
-;CHECK: %40 = OpCopyLogical %Test [[phi_result]]
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBuffAddrCheckPass>(
-      defs + decorates + globals + kImportStub + main_func, true);
-}
-
-TEST_F(InstBuffAddrTest, PaddedStructLoad) {
-  // #version 450
-  // #extension GL_EXT_buffer_reference : enable
-  // #extension GL_ARB_gpu_shader_int64 : enable
-  // struct Test {
-  //   uvec3 pad_1;  // Offset 0 Size 12
-  //   double pad_2; // Offset 16 Size 8 (alignment requirement)
-  //   float a;      // Offset 24 Size 4
-  // }; // Total Size 28
-  //
-  // layout(buffer_reference, std430, buffer_reference_align = 16) buffer
-  // TestBuffer { Test test; };
-  //
-  // Test GetTest(uint64_t ptr) {
-  //   return TestBuffer(ptr).test;
-  // }
-  //
-  // void main() {
-  //   GetTest(0xe0000000);
-  // }
-
-  const std::string defs =
-      R"(
-OpCapability Shader
-OpCapability Float64
-OpCapability Int64
-OpCapability PhysicalStorageBufferAddresses
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint Vertex %main "main"
-OpSource GLSL 450
-OpSourceExtension "GL_ARB_gpu_shader_int64"
-OpSourceExtension "GL_EXT_buffer_reference"
-OpName %main "main"
-OpName %Test "Test"
-OpMemberName %Test 0 "pad_1"
-OpMemberName %Test 1 "pad_2"
-OpMemberName %Test 2 "a"
-OpName %GetTest_u641_ "GetTest(u641;"
-OpName %ptr "ptr"
-OpName %Test_0 "Test"
-OpMemberName %Test_0 0 "pad_1"
-OpMemberName %Test_0 1 "pad_2"
-OpMemberName %Test_0 2 "a"
-OpName %TestBuffer "TestBuffer"
-OpMemberName %TestBuffer 0 "test"
-OpName %param "param"
-)";
-
-  // clang-format off
-  const std::string decorates = R"(
-OpDecorate %TestBuffer Block
-OpMemberDecorate %Test_0 0 Offset 0
-OpMemberDecorate %Test_0 1 Offset 16
-OpMemberDecorate %Test_0 2 Offset 24
-OpMemberDecorate %TestBuffer 0 Offset 0
-)" + kImportDeco + R"(
-;CHECK: OpDecorate %gl_VertexIndex BuiltIn VertexIndex
-;CHECK: OpDecorate %gl_InstanceIndex BuiltIn InstanceIndex
-)";
-
-  const std::string globals = R"(
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%ulong = OpTypeInt 64 0
-%_ptr_Function_ulong = OpTypePointer Function %ulong
-%uint = OpTypeInt 32 0
-%v3uint = OpTypeVector %uint 3
-%double = OpTypeFloat 64
-%float = OpTypeFloat 32
-%Test = OpTypeStruct %v3uint %double %float
-%13 = OpTypeFunction %Test %_ptr_Function_ulong
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_TestBuffer PhysicalStorageBuffer
-%Test_0 = OpTypeStruct %v3uint %double %float
-%TestBuffer = OpTypeStruct %Test_0
-%_ptr_PhysicalStorageBuffer_TestBuffer = OpTypePointer PhysicalStorageBuffer %TestBuffer
-%int = OpTypeInt 32 1
-%int_0 = OpConstant %int 0
-%_ptr_PhysicalStorageBuffer_Test_0 = OpTypePointer PhysicalStorageBuffer %Test_0
-%_ptr_Function_Test = OpTypePointer Function %Test
-%ulong_18446744073172680704 = OpConstant %ulong 18446744073172680704
-;CHECK: {{%\w+}} = OpConstantNull %Test_0
-)";
-
-  const std::string main_func = R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%param = OpVariable %_ptr_Function_ulong Function
-OpStore %param %ulong_18446744073172680704
-%35 = OpFunctionCall %Test %GetTest_u641_ %param
-OpReturn
-OpFunctionEnd
-%GetTest_u641_ = OpFunction %Test None %13
-%ptr = OpFunctionParameter %_ptr_Function_ulong
-%16 = OpLabel
-%28 = OpVariable %_ptr_Function_Test Function
-%17 = OpLoad %ulong %ptr
-%21 = OpConvertUToPtr %_ptr_PhysicalStorageBuffer_TestBuffer %17
-%25 = OpAccessChain %_ptr_PhysicalStorageBuffer_Test_0 %21 %int_0
-%26 = OpLoad %Test_0 %25 Aligned 16
-%29 = OpCopyLogical %Test %26
-;CHECK-NOT: %30 = OpLoad %Test %28
-;CHECK-NOT: %26 = OpLoad %Test_0 %25 Aligned 16
-;CHECK-NOT: %29 = OpCopyLogical %Test %26
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %25
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_63 {{%\w+}} {{%\w+}} %uint_28
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %Test_0 %25 Aligned 16
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %Test_0 {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: %29 = OpCopyLogical %Test [[phi_result]]
-OpStore %28 %29
-%30 = OpLoad %Test %28
-OpReturnValue %30
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBuffAddrCheckPass>(
-      defs + decorates + globals + kImportStub + main_func, true);
-}
-
-TEST_F(InstBuffAddrTest, DeviceBufferAddressOOB) {
-  // #version 450
-  // #extension GL_EXT_buffer_reference : enable
-  //  layout(buffer_reference, buffer_reference_align = 16) buffer bufStruct;
-  // layout(set = 0, binding = 0) uniform ufoo {
-  //     bufStruct data;
-  //     int nWrites;
-  // } u_info;
-  // layout(buffer_reference, std140) buffer bufStruct {
-  //     int a[4];
-  // };
-  // void main() {
-  //     for (int i=0; i < u_info.nWrites; ++i) {
-  //         u_info.data.a[i] = 0xdeadca71;
-  //     }
-  // }
-
-  // clang-format off
-  const std::string text = R"(
-OpCapability Shader
-OpCapability PhysicalStorageBufferAddresses
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint Vertex %main "main" %u_info
-;CHECK: OpEntryPoint Vertex %main "main" %u_info %gl_VertexIndex %gl_InstanceIndex
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_buffer_reference"
-OpName %main "main"
-OpName %i "i"
-OpName %ufoo "ufoo"
-OpMemberName %ufoo 0 "data"
-OpMemberName %ufoo 1 "nWrites"
-OpName %bufStruct "bufStruct"
-OpMemberName %bufStruct 0 "a"
-OpName %u_info "u_info"
-OpMemberDecorate %ufoo 0 Offset 0
-OpMemberDecorate %ufoo 1 Offset 8
-OpDecorate %ufoo Block
-OpDecorate %_arr_int_uint_4 ArrayStride 16
-OpMemberDecorate %bufStruct 0 Offset 0
-OpDecorate %bufStruct Block
-OpDecorate %u_info DescriptorSet 0
-OpDecorate %u_info Binding 0
-)" + kImportDeco + R"(
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%int = OpTypeInt 32 1
-%_ptr_Function_int = OpTypePointer Function %int
-%int_0 = OpConstant %int 0
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_bufStruct PhysicalStorageBuffer
-%ufoo = OpTypeStruct %_ptr_PhysicalStorageBuffer_bufStruct %int
-%uint = OpTypeInt 32 0
-%uint_4 = OpConstant %uint 4
-%_arr_int_uint_4 = OpTypeArray %int %uint_4
-%bufStruct = OpTypeStruct %_arr_int_uint_4
-%_ptr_PhysicalStorageBuffer_bufStruct = OpTypePointer PhysicalStorageBuffer %bufStruct
-%_ptr_Uniform_ufoo = OpTypePointer Uniform %ufoo
-%u_info = OpVariable %_ptr_Uniform_ufoo Uniform
-%int_1 = OpConstant %int 1
-%_ptr_Uniform_int = OpTypePointer Uniform %int
-%bool = OpTypeBool
-%_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct = OpTypePointer Uniform %_ptr_PhysicalStorageBuffer_bufStruct
-%int_n559035791 = OpConstant %int -559035791
-%_ptr_PhysicalStorageBuffer_int = OpTypePointer PhysicalStorageBuffer %int
-)" + kImportStub + R"(
-%main = OpFunction %void None %3
-%5 = OpLabel
-%i = OpVariable %_ptr_Function_int Function
-OpStore %i %int_0
-OpBranch %10
-%10 = OpLabel
-OpLoopMerge %12 %13 None
-OpBranch %14
-%14 = OpLabel
-%15 = OpLoad %int %i
-%26 = OpAccessChain %_ptr_Uniform_int %u_info %int_1
-%27 = OpLoad %int %26
-%29 = OpSLessThan %bool %15 %27
-OpBranchConditional %29 %11 %12
-%11 = OpLabel
-%31 = OpAccessChain %_ptr_Uniform__ptr_PhysicalStorageBuffer_bufStruct %u_info %int_0
-%32 = OpLoad %_ptr_PhysicalStorageBuffer_bufStruct %31
-%33 = OpLoad %int %i
-%36 = OpAccessChain %_ptr_PhysicalStorageBuffer_int %32 %int_0 %33
-OpStore %36 %int_n559035791 Aligned 16
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %36
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: {{%\w+}} = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_63 {{%\w+}} {{%\w+}} %uint_4
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpStore %36 %int_n559035791 Aligned 16
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-OpBranch %13
-%13 = OpLabel
-%37 = OpLoad %int %i
-%38 = OpIAdd %int %37 %int_1
-OpStore %i %38
-OpBranch %10
-%12 = OpLabel
-OpReturn
-OpFunctionEnd)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstBuffAddrCheckPass>(text, true, 23);
-}
-
-TEST_F(InstBuffAddrTest, UVec3ScalarAddressOOB) {
-  // clang-format off
-  // #version 450
-  //    #extension GL_EXT_buffer_reference : enable
-  //    #extension GL_EXT_scalar_block_layout : enable
-  //    layout(buffer_reference, std430, scalar) readonly buffer IndexBuffer
-  //    {
-  //        uvec3 indices[];
-  //    };
-  //    layout(set = 0, binding = 0) uniform ufoo {
-  //        IndexBuffer data;
-  //        int nReads;
-  //    } u_info;
-  //    void main() {
-  //        uvec3 readvec;
-  //        for (int i=0; i < u_info.nReads; ++i) {
-  //            readvec = u_info.data.indices[i];
-  //        }
-  //    }
-  const std::string text = R"(
-OpCapability Shader
-OpCapability PhysicalStorageBufferAddresses
-%1 = OpExtInstImport "GLSL.std.450"
-OpMemoryModel PhysicalStorageBuffer64 GLSL450
-OpEntryPoint Vertex %main "main" %u_info
-OpSource GLSL 450
-OpSourceExtension "GL_EXT_buffer_reference"
-OpSourceExtension "GL_EXT_scalar_block_layout"
-OpName %main "main"
-OpName %i "i"
-OpName %ufoo "ufoo"
-OpMemberName %ufoo 0 "data"
-OpMemberName %ufoo 1 "nReads"
-OpName %IndexBuffer "IndexBuffer"
-OpMemberName %IndexBuffer 0 "indices"
-OpName %u_info "u_info"
-OpName %readvec "readvec"
-OpMemberDecorate %ufoo 0 Offset 0
-OpMemberDecorate %ufoo 1 Offset 8
-OpDecorate %ufoo Block
-OpDecorate %_runtimearr_v3uint ArrayStride 12
-OpMemberDecorate %IndexBuffer 0 NonWritable
-OpMemberDecorate %IndexBuffer 0 Offset 0
-OpDecorate %IndexBuffer Block
-OpDecorate %u_info DescriptorSet 0
-OpDecorate %u_info Binding 0
-)" + kImportDeco + R"(
-%void = OpTypeVoid
-%3 = OpTypeFunction %void
-%int = OpTypeInt 32 1
-%_ptr_Function_int = OpTypePointer Function %int
-%int_0 = OpConstant %int 0
-OpTypeForwardPointer %_ptr_PhysicalStorageBuffer_IndexBuffer PhysicalStorageBuffer
-%ufoo = OpTypeStruct %_ptr_PhysicalStorageBuffer_IndexBuffer %int
-%uint = OpTypeInt 32 0
-%v3uint = OpTypeVector %uint 3
-%_runtimearr_v3uint = OpTypeRuntimeArray %v3uint
-%IndexBuffer = OpTypeStruct %_runtimearr_v3uint
-%_ptr_PhysicalStorageBuffer_IndexBuffer = OpTypePointer PhysicalStorageBuffer %IndexBuffer
-%_ptr_Uniform_ufoo = OpTypePointer Uniform %ufoo
-%u_info = OpVariable %_ptr_Uniform_ufoo Uniform
-%int_1 = OpConstant %int 1
-%_ptr_Uniform_int = OpTypePointer Uniform %int
-%bool = OpTypeBool
-)" + kImportStub + R"(
-%_ptr_Function_v3uint = OpTypePointer Function %v3uint
-%_ptr_Uniform__ptr_PhysicalStorageBuffer_IndexBuffer = OpTypePointer Uniform %_ptr_PhysicalStorageBuffer_IndexBuffer
-%_ptr_PhysicalStorageBuffer_v3uint = OpTypePointer PhysicalStorageBuffer %v3uint
-%main = OpFunction %void None %3
-%5 = OpLabel
-%i = OpVariable %_ptr_Function_int Function
-%readvec = OpVariable %_ptr_Function_v3uint Function
-OpStore %i %int_0
-OpBranch %10
-%10 = OpLabel
-OpLoopMerge %12 %13 None
-OpBranch %14
-%14 = OpLabel
-%15 = OpLoad %int %i
-%26 = OpAccessChain %_ptr_Uniform_int %u_info %int_1
-%27 = OpLoad %int %26
-%29 = OpSLessThan %bool %15 %27
-OpBranchConditional %29 %11 %12
-%11 = OpLabel
-%33 = OpAccessChain %_ptr_Uniform__ptr_PhysicalStorageBuffer_IndexBuffer %u_info %int_0
-%34 = OpLoad %_ptr_PhysicalStorageBuffer_IndexBuffer %33
-%35 = OpLoad %int %i
-%37 = OpAccessChain %_ptr_PhysicalStorageBuffer_v3uint %34 %int_0 %35
-%38 = OpLoad %v3uint %37 Aligned 4
-OpStore %readvec %38
-;CHECK-NOT: %38 = OpLoad %v3uint %37 Aligned 4
-;CHECK-NOT: OpStore %readvec %38
-;CHECK: {{%\w+}} = OpConvertPtrToU %ulong %37
-;CHECK: {{%\w+}} = OpLoad %uint %gl_VertexIndex
-;CHECK: {{%\w+}} = OpLoad %uint %gl_InstanceIndex
-;CHECK: {{%\w+}} = OpCompositeConstruct %v4uint %uint_0 {{%\w+}} {{%\w+}} %uint_0
-;CHECK: [[test_result:%\w+]] = OpFunctionCall %bool %)" + kFuncName + R"( %uint_23 %uint_67 {{%\w+}} {{%\w+}} %uint_12
-;CHECK: OpSelectionMerge {{%\w+}} None
-;CHECK: OpBranchConditional [[test_result]] {{%\w+}} {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: {{%\w+}} = OpLoad %v3uint %37 Aligned 4
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: OpBranch {{%\w+}}
-;CHECK: {{%\w+}} = OpLabel
-;CHECK: [[phi_result:%\w+]] = OpPhi %v3uint {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-;CHECK: OpStore %readvec [[phi_result]]
-OpBranch %13
-%13 = OpLabel
-%39 = OpLoad %int %i
-%40 = OpIAdd %int %39 %int_1
-OpStore %i %40
-OpBranch %10
-%12 = OpLabel
-OpReturn
-OpFunctionEnd
-)";
-  // clang-format on
-
-  SetTargetEnv(SPV_ENV_UNIVERSAL_1_4);
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  ValidatorOptions()->scalar_block_layout = true;
-  SinglePassRunAndMatch<InstBuffAddrCheckPass>(text, true, 23);
-}
-
-}  // namespace
-}  // namespace opt
-}  // namespace spvtools
diff --git a/test/opt/inst_debug_printf_test.cpp b/test/opt/inst_debug_printf_test.cpp
deleted file mode 100644
index 24c0bc65..00000000
--- a/test/opt/inst_debug_printf_test.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-// Copyright (c) 2020-2022 Valve Corporation
-// Copyright (c) 2020-2022 LunarG Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Debug Printf Instrumentation Tests.
-
-#include <string>
-#include <vector>
-
-#include "test/opt/pass_fixture.h"
-#include "test/opt/pass_utils.h"
-
-namespace spvtools {
-namespace opt {
-namespace {
-
-static const std::string kOutputDecorations = R"(
-; CHECK: OpDecorate [[output_buffer_type:%inst_printf_OutputBuffer]] Block
-; CHECK: OpMemberDecorate [[output_buffer_type]] 0 Offset 0
-; CHECK: OpMemberDecorate [[output_buffer_type]] 1 Offset 4
-; CHECK: OpMemberDecorate [[output_buffer_type]] 2 Offset 8
-; CHECK: OpDecorate [[output_buffer_var:%\w+]] DescriptorSet 7
-; CHECK: OpDecorate [[output_buffer_var]] Binding 3
-)";
-
-static const std::string kOutputGlobals = R"(
-; CHECK: [[output_buffer_type]] = OpTypeStruct %uint %uint %_runtimearr_uint
-; CHECK: [[output_ptr_type:%\w+]] = OpTypePointer StorageBuffer [[output_buffer_type]]
-; CHECK: [[output_buffer_var]] = OpVariable [[output_ptr_type]] StorageBuffer
-)";
-
-using InstDebugPrintfTest = PassTest<::testing::Test>;
-
-TEST_F(InstDebugPrintfTest, V4Float32) {
-  // SamplerState g_sDefault;
-  // Texture2D g_tColor;
-  //
-  // struct PS_INPUT
-  // {
-  //   float2 vBaseTexCoord : TEXCOORD0;
-  // };
-  //
-  // struct PS_OUTPUT
-  // {
-  //   float4 vDiffuse : SV_Target0;
-  // };
-  //
-  // PS_OUTPUT MainPs(PS_INPUT i)
-  // {
-  //   PS_OUTPUT o;
-  //
-  //   o.vDiffuse.rgba = g_tColor.Sample(g_sDefault, (i.vBaseTexCoord.xy).xy);
-  //   debugPrintfEXT("diffuse: %v4f", o.vDiffuse.rgba);
-  //   return o;
-  // }
-
-  const std::string defs =
-      R"(OpCapability Shader
-OpExtension "SPV_KHR_non_semantic_info"
-%1 = OpExtInstImport "NonSemantic.DebugPrintf"
-; CHECK-NOT: OpExtension "SPV_KHR_non_semantic_info"
-; CHECK-NOT: %1 = OpExtInstImport "NonSemantic.DebugPrintf"
-; CHECK: OpExtension "SPV_KHR_storage_buffer_storage_class"
-OpMemoryModel Logical GLSL450
-OpEntryPoint Fragment %2 "MainPs" %3 %4
-; CHECK: OpEntryPoint Fragment %2 "MainPs" %3 %4
-OpExecutionMode %2 OriginUpperLeft
-%5 = OpString "Color is %vn"
-)";
-
-  // clang-format off
-  const std::string decorates =
-      R"(OpDecorate %6 DescriptorSet 0
-OpDecorate %6 Binding 1
-OpDecorate %7 DescriptorSet 0
-OpDecorate %7 Binding 0
-OpDecorate %3 Location 0
-OpDecorate %4 Location 0
-)" + kOutputDecorations;
-
-  const std::string globals =
-      R"(%void = OpTypeVoid
-%9 = OpTypeFunction %void
-%float = OpTypeFloat 32
-%v2float = OpTypeVector %float 2
-%v4float = OpTypeVector %float 4
-%13 = OpTypeImage %float 2D 0 0 0 1 Unknown
-%_ptr_UniformConstant_13 = OpTypePointer UniformConstant %13
-%6 = OpVariable %_ptr_UniformConstant_13 UniformConstant
-%15 = OpTypeSampler
-%_ptr_UniformConstant_15 = OpTypePointer UniformConstant %15
-%7 = OpVariable %_ptr_UniformConstant_15 UniformConstant
-%17 = OpTypeSampledImage %13
-%_ptr_Input_v2float = OpTypePointer Input %v2float
-%3 = OpVariable %_ptr_Input_v2float Input
-%_ptr_Output_v4float = OpTypePointer Output %v4float
-%4 = OpVariable %_ptr_Output_v4float Output
-; CHECK: %uint = OpTypeInt 32 0
-; CHECK: [[func_type:%\w+]] = OpTypeFunction %void %uint %uint %uint %uint %uint %uint %uint
-; CHECK: %_runtimearr_uint = OpTypeRuntimeArray %uint
-)" + kOutputGlobals + R"(
-; CHECK: %_ptr_StorageBuffer_uint = OpTypePointer StorageBuffer %uint
-; CHECK: %bool = OpTypeBool
-)";
-  // clang-format on
-
-  const std::string main =
-      R"(%2 = OpFunction %void None %9
-%20 = OpLabel
-%21 = OpLoad %v2float %3
-%22 = OpLoad %13 %6
-%23 = OpLoad %15 %7
-%24 = OpSampledImage %17 %22 %23
-%25 = OpImageSampleImplicitLod %v4float %24 %21
-%26 = OpExtInst %void %1 1 %5 %25
-; CHECK-NOT: %26 = OpExtInst %void %1 1 %5 %25
-; CHECK: {{%\w+}} = OpCompositeExtract %float %25 0
-; CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-; CHECK: {{%\w+}} = OpCompositeExtract %float %25 1
-; CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-; CHECK: {{%\w+}} = OpCompositeExtract %float %25 2
-; CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-; CHECK: {{%\w+}} = OpCompositeExtract %float %25 3
-; CHECK: {{%\w+}} = OpBitcast %uint {{%\w+}}
-; CHECK: {{%\w+}} = OpFunctionCall %void %inst_printf_stream_write_5 %uint_23 %uint_36 %uint_5 {{%\w+}} {{%\w+}} {{%\w+}} {{%\w+}}
-; CHECK: OpBranch {{%\w+}}
-; CHECK: {{%\w+}} = OpLabel
-OpStore %4 %25
-OpReturn
-OpFunctionEnd
-)";
-
-  const std::string output_func = R"(
-; CHECK: %inst_printf_stream_write_5 = OpFunction %void None {{%\w+}}
-; CHECK: [[sw_shader_id:%\w+]] = OpFunctionParameter %uint
-; CHECK: [[sw_inst_idx:%\w+]] = OpFunctionParameter %uint
-; CHECK: [[sw_param_1:%\w+]] = OpFunctionParameter %uint
-; CHECK: [[sw_param_2:%\w+]] = OpFunctionParameter %uint
-; CHECK: [[sw_param_3:%\w+]] = OpFunctionParameter %uint
-; CHECK: [[sw_param_4:%\w+]] = OpFunctionParameter %uint
-; CHECK: [[sw_param_5:%\w+]] = OpFunctionParameter %uint
-; CHECK: {{%\w+}} = OpLabel
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_1
-; CHECK: {{%\w+}} = OpAtomicIAdd %uint {{%\w+}} %uint_4 %uint_0 %uint_8
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_8
-; CHECK: {{%\w+}} = OpArrayLength %uint [[output_buffer_var]] 2
-; CHECK: {{%\w+}} = OpULessThanEqual %bool {{%\w+}} {{%\w+}}
-; CHECK: OpSelectionMerge {{%\w+}} None
-; CHECK: OpBranchConditional {{%\w+}} {{%\w+}} {{%\w+}}
-; CHECK: {{%\w+}} = OpLabel
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_0
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} %uint_8
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_1
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_shader_id]]
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_2
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_inst_idx]]
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_3
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_param_1]]
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_4
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_param_2]]
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_5
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_param_3]]
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_6
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_param_4]]
-; CHECK: {{%\w+}} = OpIAdd %uint {{%\w+}} %uint_7
-; CHECK: {{%\w+}} = OpAccessChain %_ptr_StorageBuffer_uint [[output_buffer_var]] %uint_2 {{%\w+}}
-; CHECK: OpStore {{%\w+}} [[sw_param_5]]
-; CHECK: OpBranch {{%\w+}}
-; CHECK: {{%\w+}} = OpLabel
-; CHECK: OpReturn
-; CHECK: OpFunctionEnd
-)";
-
-  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
-  SinglePassRunAndMatch<InstDebugPrintfPass>(
-      defs + decorates + globals + main + output_func, true);
-}
-
-// TODO(greg-lunarg): Add tests to verify handling of these cases:
-//
-//   Compute shader
-//   Geometry shader
-//   Tessellation control shader
-//   Tessellation eval shader
-//   Vertex shader
-
-}  // namespace
-}  // namespace opt
-}  // namespace spvtools
diff --git a/test/opt/ir_context_test.cpp b/test/opt/ir_context_test.cpp
index 621fe8cf..d499506e 100644
--- a/test/opt/ir_context_test.cpp
+++ b/test/opt/ir_context_test.cpp
@@ -871,6 +871,7 @@ TEST_F(IRContextTest, AsanErrorTest) {
   opt::Function* fun =
       context->cfg()->block(5)->GetParent();  // Computes the CFG analysis
   opt::DominatorAnalysis* dom = nullptr;
+  // NOLINTNEXTLINE
   dom = context->GetDominatorAnalysis(fun);  // Computes the dominator analysis,
                                              // which depends on the CFG
                                              // analysis
@@ -1154,10 +1155,7 @@ struct TargetEnvCompareTestData {
 
 using TargetEnvCompareTest = ::testing::TestWithParam<TargetEnvCompareTestData>;
 
-TEST_P(TargetEnvCompareTest, Case) {
-  // If new environments are added, then we must update the list of tests.
-  ASSERT_EQ(SPV_ENV_VULKAN_1_3 + 1, SPV_ENV_MAX);
-
+TEST_P(TargetEnvCompareTest, IsTargetEnvAtLeast) {
   const auto& tc = GetParam();
 
   std::unique_ptr<Module> module(new Module());
@@ -1421,6 +1419,8 @@ TEST_F(IRContextTest, RemovesMultipleCapabilities) {
             1);
 }
 
+// If new environments are added, then we must update the list of tests.
+static_assert(SPV_ENV_VULKAN_1_4 + 1 == SPV_ENV_MAX);
 INSTANTIATE_TEST_SUITE_P(
     TestCase, TargetEnvCompareTest,
     ::testing::Values(
@@ -1463,6 +1463,7 @@ INSTANTIATE_TEST_SUITE_P(
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_1, SPV_ENV_UNIVERSAL_1_1},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_1, SPV_ENV_UNIVERSAL_1_2},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_1, SPV_ENV_UNIVERSAL_1_3},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_0},
         TargetEnvCompareTestData{SPV_ENV_UNIVERSAL_1_4, SPV_ENV_VULKAN_1_1},
         TargetEnvCompareTestData{SPV_ENV_UNIVERSAL_1_5, SPV_ENV_VULKAN_1_1},
         TargetEnvCompareTestData{SPV_ENV_UNIVERSAL_1_6, SPV_ENV_VULKAN_1_1},
@@ -1472,6 +1473,7 @@ INSTANTIATE_TEST_SUITE_P(
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_2, SPV_ENV_UNIVERSAL_1_3},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_2, SPV_ENV_UNIVERSAL_1_4},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_2, SPV_ENV_UNIVERSAL_1_5},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_2, SPV_ENV_VULKAN_1_1},
         TargetEnvCompareTestData{SPV_ENV_UNIVERSAL_1_6, SPV_ENV_VULKAN_1_2},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_0},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_1},
@@ -1479,7 +1481,16 @@ INSTANTIATE_TEST_SUITE_P(
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_3},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_4},
         TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_5},
-        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_6}));
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_UNIVERSAL_1_6},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_3, SPV_ENV_VULKAN_1_2},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_0},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_1},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_2},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_3},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_4},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_5},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_6},
+        TargetEnvCompareTestData{SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_3}));
 
 }  // namespace
 }  // namespace opt
diff --git a/test/opt/loop_optimizations/unroll_simple.cpp b/test/opt/loop_optimizations/unroll_simple.cpp
index 6468adf4..b4fd3eaa 100644
--- a/test/opt/loop_optimizations/unroll_simple.cpp
+++ b/test/opt/loop_optimizations/unroll_simple.cpp
@@ -510,36 +510,36 @@ OpBranch %24
 %24 = OpLabel
 %35 = OpPhi %8 %10 %23 %34 %26
 %s1 = OpExtInst %6 %ext DebugScope %dbg_main
-%d10 = OpExtInst %6 %ext DebugLine %file_name %uint_1 %uint_1 %uint_0 %uint_0
+%d10 = OpExtInst %6 %ext DebugLine %src %uint_1 %uint_1 %uint_0 %uint_0
 %value0 = OpExtInst %6 %ext DebugValue %dbg_f %35 %null_expr
 OpLoopMerge %25 %26 Unroll
 OpBranch %27
 %27 = OpLabel
 %s2 = OpExtInst %6 %ext DebugScope %dbg_main
-%d1 = OpExtInst %6 %ext DebugLine %file_name %uint_1 %uint_1 %uint_1 %uint_1
+%d1 = OpExtInst %6 %ext DebugLine %src %uint_1 %uint_1 %uint_1 %uint_1
 %29 = OpSLessThan %12 %35 %11
-%d2 = OpExtInst %6 %ext DebugLine %file_name %uint_2 %uint_2 %uint_0 %uint_0
+%d2 = OpExtInst %6 %ext DebugLine %src %uint_2 %uint_2 %uint_0 %uint_0
 OpBranchConditional %29 %30 %25
 %30 = OpLabel
 %s3 = OpExtInst %6 %ext DebugScope %bb
 %decl0 = OpExtInst %6 %ext DebugDeclare %dbg_f %5 %null_expr
 %decl1 = OpExtInst %6 %ext DebugValue %dbg_i %5 %deref_expr
-%d3 = OpExtInst %6 %ext DebugLine %file_name %uint_3 %uint_3 %uint_0 %uint_0
+%d3 = OpExtInst %6 %ext DebugLine %src %uint_3 %uint_3 %uint_0 %uint_0
 %32 = OpAccessChain %19 %5 %35
-%d4 = OpExtInst %6 %ext DebugLine %file_name %uint_4 %uint_4 %uint_0 %uint_0
+%d4 = OpExtInst %6 %ext DebugLine %src %uint_4 %uint_4 %uint_0 %uint_0
 OpStore %32 %18
-%d5 = OpExtInst %6 %ext DebugLine %file_name %uint_5 %uint_5 %uint_0 %uint_0
+%d5 = OpExtInst %6 %ext DebugLine %src %uint_5 %uint_5 %uint_0 %uint_0
 OpBranch %26
 %26 = OpLabel
 %s4 = OpExtInst %6 %ext DebugScope %dbg_main
-%d6 = OpExtInst %6 %ext DebugLine %file_name %uint_6 %uint_6 %uint_0 %uint_0
+%d6 = OpExtInst %6 %ext DebugLine %src %uint_6 %uint_6 %uint_0 %uint_0
 %34 = OpIAdd %8 %35 %20
 %value1 = OpExtInst %6 %ext DebugValue %dbg_f %34 %null_expr
-%d7 = OpExtInst %6 %ext DebugLine %file_name %uint_7 %uint_7 %uint_0 %uint_0
+%d7 = OpExtInst %6 %ext DebugLine %src %uint_7 %uint_7 %uint_0 %uint_0
 OpBranch %24
 %25 = OpLabel
 %s5 = OpExtInst %6 %ext DebugScope %dbg_main
-%d8 = OpExtInst %6 %ext DebugLine %file_name %uint_8 %uint_8 %uint_0 %uint_0
+%d8 = OpExtInst %6 %ext DebugLine %src %uint_8 %uint_8 %uint_0 %uint_0
 OpReturn
 OpFunctionEnd)";
 
diff --git a/test/opt/opextinst_forward_ref_fixup_pass_test.cpp b/test/opt/opextinst_forward_ref_fixup_pass_test.cpp
new file mode 100644
index 00000000..b9ac5d27
--- /dev/null
+++ b/test/opt/opextinst_forward_ref_fixup_pass_test.cpp
@@ -0,0 +1,338 @@
+// Copyright (c) 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "spirv-tools/optimizer.hpp"
+#include "test/opt/pass_fixture.h"
+#include "test/opt/pass_utils.h"
+
+namespace spvtools {
+namespace opt {
+namespace {
+
+using OpExtInstForwardRefFixupPassTest = PassTest<::testing::Test>;
+
+TEST_F(OpExtInstForwardRefFixupPassTest, NoChangeWithougExtendedInstructions) {
+  const std::string kTest = R"(
+; CHECK-NOT:   SomeOpcode
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %main "main"
+               OpExecutionMode %main LocalSize 1 1 1
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %main = OpFunction %void None %3
+          %6 = OpLabel
+               OpReturn
+               OpFunctionEnd;
+  )";
+  const auto result =
+      SinglePassRunAndMatch<OpExtInstWithForwardReferenceFixupPass>(
+          kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithoutChange);
+}
+
+TEST_F(OpExtInstForwardRefFixupPassTest, NoForwardRef_NoChange) {
+  const std::string kTest = R"(OpCapability Shader
+OpExtension "SPV_KHR_non_semantic_info"
+%1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%3 = OpString "/usr/local/google/home/nathangauer/projects/DirectXShaderCompiler/repro.hlsl"
+%4 = OpString "// RUN: %dxc -T cs_6_0 %s -E main -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source | FileCheck %s
+
+[numthreads(1, 1, 1)]
+void main() {
+}
+"
+%5 = OpString "main"
+%6 = OpString ""
+%7 = OpString "3f3d3740"
+%8 = OpString " -E main -T cs_6_0 -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source -Qembed_debug"
+OpName %main "main"
+%void = OpTypeVoid
+%uint = OpTypeInt 32 0
+%uint_3 = OpConstant %uint 3
+%uint_1 = OpConstant %uint 1
+%uint_4 = OpConstant %uint 4
+%uint_5 = OpConstant %uint 5
+%15 = OpTypeFunction %void
+%16 = OpExtInst %void %1 DebugTypeFunction %uint_3 %void
+%17 = OpExtInst %void %1 DebugSource %3 %4
+%18 = OpExtInst %void %1 DebugCompilationUnit %uint_1 %uint_4 %17 %uint_5
+%19 = OpExtInst %void %1 DebugFunction %5 %16 %17 %uint_4 %uint_1 %18 %6 %uint_3 %uint_4
+%20 = OpExtInst %void %1 DebugEntryPoint %19 %18 %7 %8
+%main = OpFunction %void None %15
+%21 = OpLabel
+%22 = OpExtInst %void %1 DebugFunctionDefinition %19 %main
+%23 = OpExtInst %void %1 DebugLine %17 %uint_5 %uint_5 %uint_1 %uint_1
+OpReturn
+OpFunctionEnd
+)";
+  SinglePassRunAndCheck<OpExtInstWithForwardReferenceFixupPass>(
+      kTest, kTest, /* skip_nop= */ false);
+}
+
+TEST_F(OpExtInstForwardRefFixupPassTest,
+       NoForwardRef_ReplaceOpExtInstWithForwardWithOpExtInst) {
+  const std::string kTest = R"(
+                       OpCapability Shader
+                       OpExtension "SPV_KHR_non_semantic_info"
+                       OpExtension "SPV_KHR_relaxed_extended_instruction"
+; CHECK-NOT:           OpExtension "SPV_KHR_relaxed_extended_instruction"
+                  %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+                       OpMemoryModel Logical GLSL450
+                       OpEntryPoint GLCompute %main "main"
+                       OpExecutionMode %main LocalSize 1 1 1
+                  %3 = OpString "/usr/local/google/home/nathangauer/projects/DirectXShaderCompiler/repro.hlsl"
+                  %4 = OpString "// RUN: %dxc -T cs_6_0 %s -E main -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source | FileCheck %s
+
+[numthreads(1, 1, 1)]
+void main() {
+}
+"
+                  %5 = OpString "main"
+                  %6 = OpString ""
+                  %7 = OpString "3f3d3740"
+                  %8 = OpString " -E main -T cs_6_0 -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source -Qembed_debug"
+                       OpName %main "main"
+               %void = OpTypeVoid
+               %uint = OpTypeInt 32 0
+             %uint_3 = OpConstant %uint 3
+             %uint_1 = OpConstant %uint 1
+             %uint_4 = OpConstant %uint 4
+             %uint_5 = OpConstant %uint 5
+                 %20 = OpTypeFunction %void
+                 %10 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction %uint_3 %void
+                 %12 = OpExtInstWithForwardRefsKHR %void %1 DebugSource %3 %4
+                 %13 = OpExtInstWithForwardRefsKHR %void %1 DebugCompilationUnit %uint_1 %uint_4 %12 %uint_5
+                 %17 = OpExtInstWithForwardRefsKHR %void %1 DebugFunction %5 %10 %12 %uint_4 %uint_1 %13 %6 %uint_3 %uint_4
+                 %18 = OpExtInstWithForwardRefsKHR %void %1 DebugEntryPoint %17 %13 %7 %8
+;  CHECK-NOT: {{.*}} = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction %uint_3 %void
+;  CHECK-NOT: {{.*}} = OpExtInstWithForwardRefsKHR %void %1 DebugSource {{.*}} {{.*}}
+;  CHECK-NOT: {{.*}} = OpExtInstWithForwardRefsKHR %void %1 DebugCompilationUnit %uint_1 %uint_4 {{.*}} %uint_5
+;  CHECK-NOT: {{.*}} = OpExtInstWithForwardRefsKHR %void %1 DebugFunction {{.*}} {{.*}} {{.*}} %uint_4 %uint_1 {{.*}} {{.*}} %uint_3 %uint_4
+;  CHECK-NOT: {{.*}} = OpExtInstWithForwardRefsKHR %void %1 DebugEntryPoint {{.*}} {{.*}} {{.*}} {{.*}}
+;  CHECK:     {{.*}} = OpExtInst %void %1 DebugTypeFunction %uint_3 %void
+;  CHECK:     {{.*}} = OpExtInst %void %1 DebugSource {{.*}} {{.*}}
+;  CHECK:     {{.*}} = OpExtInst %void %1 DebugCompilationUnit %uint_1 %uint_4 {{.*}} %uint_5
+;  CHECK:     {{.*}} = OpExtInst %void %1 DebugFunction {{.*}} {{.*}} {{.*}} %uint_4 %uint_1 {{.*}} {{.*}} %uint_3 %uint_4
+;  CHECK:     {{.*}} = OpExtInst %void %1 DebugEntryPoint {{.*}} {{.*}} {{.*}} {{.*}}
+               %main = OpFunction %void None %20
+                 %21 = OpLabel
+                 %22 = OpExtInst %void %1 DebugFunctionDefinition %17 %main
+                 %23 = OpExtInst %void %1 DebugLine %12 %uint_5 %uint_5 %uint_1 %uint_1
+; CHECK:      {{.*}} = OpExtInst %void %1 DebugFunctionDefinition {{.*}} %main
+; CHECK:      {{.*}} = OpExtInst %void %1 DebugLine {{.*}} %uint_5 %uint_5 %uint_1 %uint_1
+                       OpReturn
+                       OpFunctionEnd
+  )";
+  const auto result =
+      SinglePassRunAndMatch<OpExtInstWithForwardReferenceFixupPass>(
+          kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(OpExtInstForwardRefFixupPassTest, ForwardRefs_NoChange) {
+  const std::string kTest = R"(OpCapability Shader
+OpExtension "SPV_KHR_non_semantic_info"
+OpExtension "SPV_KHR_relaxed_extended_instruction"
+%1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%3 = OpString "/usr/local/google/home/nathangauer/projects/DirectXShaderCompiler/repro.hlsl"
+%4 = OpString "// RUN: %dxc -T cs_6_0 %s -E main -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source | FileCheck %s
+
+class A {
+  void foo() {
+  }
+};
+
+[numthreads(1, 1, 1)]
+void main() {
+  A a;
+  a.foo();
+}
+"
+%5 = OpString "A"
+%6 = OpString "A.foo"
+%7 = OpString ""
+%8 = OpString "this"
+%9 = OpString "main"
+%10 = OpString "a"
+%11 = OpString "d59ae9c2"
+%12 = OpString " -E main -T cs_6_0 -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source -Vd -Qembed_debug"
+OpName %main "main"
+OpName %A "A"
+%void = OpTypeVoid
+%uint = OpTypeInt 32 0
+%uint_1 = OpConstant %uint 1
+%uint_4 = OpConstant %uint 4
+%uint_5 = OpConstant %uint 5
+%uint_0 = OpConstant %uint 0
+%uint_3 = OpConstant %uint 3
+%uint_7 = OpConstant %uint 7
+%uint_288 = OpConstant %uint 288
+%uint_9 = OpConstant %uint 9
+%uint_13 = OpConstant %uint 13
+%uint_10 = OpConstant %uint 10
+%26 = OpTypeFunction %void
+%uint_12 = OpConstant %uint 12
+%A = OpTypeStruct
+%_ptr_Function_A = OpTypePointer Function %A
+%uint_11 = OpConstant %uint 11
+%30 = OpExtInst %void %1 DebugExpression
+%31 = OpExtInst %void %1 DebugSource %3 %4
+%32 = OpExtInst %void %1 DebugCompilationUnit %uint_1 %uint_4 %31 %uint_5
+%33 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeComposite %5 %uint_0 %31 %uint_3 %uint_7 %32 %5 %uint_0 %uint_3 %34
+%35 = OpExtInst %void %1 DebugTypeFunction %uint_3 %void %33
+%34 = OpExtInst %void %1 DebugFunction %6 %35 %31 %uint_4 %uint_3 %33 %7 %uint_3 %uint_4
+%36 = OpExtInst %void %1 DebugLocalVariable %8 %33 %31 %uint_4 %uint_3 %34 %uint_288 %uint_1
+%37 = OpExtInst %void %1 DebugTypeFunction %uint_3 %void
+%38 = OpExtInst %void %1 DebugFunction %9 %37 %31 %uint_9 %uint_1 %32 %7 %uint_3 %uint_9
+%39 = OpExtInst %void %1 DebugLexicalBlock %31 %uint_9 %uint_13 %38
+%40 = OpExtInst %void %1 DebugLocalVariable %10 %33 %31 %uint_10 %uint_5 %39 %uint_4
+%41 = OpExtInst %void %1 DebugEntryPoint %38 %32 %11 %12
+%42 = OpExtInst %void %1 DebugInlinedAt %uint_11 %39
+%main = OpFunction %void None %26
+%43 = OpLabel
+%44 = OpVariable %_ptr_Function_A Function
+%45 = OpExtInst %void %1 DebugFunctionDefinition %38 %main
+%57 = OpExtInst %void %1 DebugScope %39
+%47 = OpExtInst %void %1 DebugLine %31 %uint_10 %uint_10 %uint_3 %uint_5
+%48 = OpExtInst %void %1 DebugDeclare %40 %44 %30
+%58 = OpExtInst %void %1 DebugScope %34 %42
+%50 = OpExtInst %void %1 DebugLine %31 %uint_4 %uint_5 %uint_3 %uint_3
+%51 = OpExtInst %void %1 DebugDeclare %36 %44 %30
+%59 = OpExtInst %void %1 DebugNoScope
+%53 = OpExtInst %void %1 DebugLine %31 %uint_12 %uint_12 %uint_1 %uint_1
+OpReturn
+OpFunctionEnd
+)";
+  SinglePassRunAndCheck<OpExtInstWithForwardReferenceFixupPass>(
+      kTest, kTest, /* skip_nop= */ false);
+}
+
+TEST_F(OpExtInstForwardRefFixupPassTest,
+       ForwardRefs_ReplaceOpExtInstWithOpExtInstWithForwardRefs) {
+  const std::string kTest = R"(
+                        OpCapability Shader
+                        OpExtension "SPV_KHR_non_semantic_info"
+; CHECK:                OpExtension "SPV_KHR_relaxed_extended_instruction"
+                   %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+                        OpMemoryModel Logical GLSL450
+                        OpEntryPoint GLCompute %main "main"
+                        OpExecutionMode %main LocalSize 1 1 1
+                   %3 = OpString "/usr/local/google/home/nathangauer/projects/DirectXShaderCompiler/repro.hlsl"
+                   %4 = OpString "// RUN: %dxc -T cs_6_0 %s -E main -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source | FileCheck %s
+
+class A {
+  void foo() {
+  }
+};
+
+[numthreads(1, 1, 1)]
+void main() {
+  A a;
+  a.foo();
+}
+"
+                   %5 = OpString "A"
+                   %6 = OpString "A.foo"
+                   %7 = OpString ""
+                   %8 = OpString "this"
+                   %9 = OpString "main"
+                  %10 = OpString "a"
+                  %11 = OpString "d59ae9c2"
+                  %12 = OpString " -E main -T cs_6_0 -spirv -fspv-target-env=vulkan1.1 -fspv-debug=vulkan-with-source -Vd -Qembed_debug"
+                        OpName %main "main"
+                        OpName %A "A"
+                %void = OpTypeVoid
+                %uint = OpTypeInt 32 0
+              %uint_1 = OpConstant %uint 1
+              %uint_4 = OpConstant %uint 4
+              %uint_5 = OpConstant %uint 5
+              %uint_0 = OpConstant %uint 0
+              %uint_3 = OpConstant %uint 3
+              %uint_7 = OpConstant %uint 7
+            %uint_288 = OpConstant %uint 288
+              %uint_9 = OpConstant %uint 9
+             %uint_13 = OpConstant %uint 13
+             %uint_10 = OpConstant %uint 10
+                  %40 = OpTypeFunction %void
+             %uint_12 = OpConstant %uint 12
+                   %A = OpTypeStruct
+         %_ptr_Function_A = OpTypePointer Function %A
+             %uint_11 = OpConstant %uint 11
+                  %15 = OpExtInst %void %1 DebugExpression
+                  %16 = OpExtInst %void %1 DebugSource %3 %4
+                  %17 = OpExtInst %void %1 DebugCompilationUnit %uint_1 %uint_4 %16 %uint_5
+                  %21 = OpExtInst %void %1 DebugTypeComposite %5 %uint_0 %16 %uint_3 %uint_7 %17 %5 %uint_0 %uint_3 %25
+                  %26 = OpExtInst %void %1 DebugTypeFunction %uint_3 %void %21
+                  %25 = OpExtInst %void %1 DebugFunction %6 %26 %16 %uint_4 %uint_3 %21 %7 %uint_3 %uint_4
+                  %27 = OpExtInst %void %1 DebugLocalVariable %8 %21 %16 %uint_4 %uint_3 %25 %uint_288 %uint_1
+                  %29 = OpExtInst %void %1 DebugTypeFunction %uint_3 %void
+                  %30 = OpExtInst %void %1 DebugFunction %9 %29 %16 %uint_9 %uint_1 %17 %7 %uint_3 %uint_9
+                  %32 = OpExtInst %void %1 DebugLexicalBlock %16 %uint_9 %uint_13 %30
+                  %34 = OpExtInst %void %1 DebugLocalVariable %10 %21 %16 %uint_10 %uint_5 %32 %uint_4
+                  %36 = OpExtInst %void %1 DebugEntryPoint %30 %17 %11 %12
+                  %37 = OpExtInst %void %1 DebugInlinedAt %uint_11 %32
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugExpression
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugSource
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugCompilationUnit
+; CHECK:       {{.*}} = OpExtInstWithForwardRefsKHR %void {{.*}} DebugTypeComposite
+; CHECK-NOT:   {{.*}} = OpExtInst %void {{.*}} DebugTypeComposite
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugTypeFunction
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugFunction
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugLocalVariable
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugTypeFunction
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugFunction
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugLexicalBlock
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugLocalVariable
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugEntryPoint
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugInlinedAt
+                %main = OpFunction %void None %40
+                  %43 = OpLabel
+                  %44 = OpVariable %_ptr_Function_A Function
+                  %45 = OpExtInst %void %1 DebugFunctionDefinition %30 %main
+                  %51 = OpExtInst %void %1 DebugScope %32
+                  %46 = OpExtInst %void %1 DebugLine %16 %uint_10 %uint_10 %uint_3 %uint_5
+                  %47 = OpExtInst %void %1 DebugDeclare %34 %44 %15
+                  %52 = OpExtInst %void %1 DebugScope %25 %37
+                  %48 = OpExtInst %void %1 DebugLine %16 %uint_4 %uint_5 %uint_3 %uint_3
+                  %49 = OpExtInst %void %1 DebugDeclare %27 %44 %15
+                  %53 = OpExtInst %void %1 DebugNoScope
+                  %50 = OpExtInst %void %1 DebugLine %16 %uint_12 %uint_12 %uint_1 %uint_1
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugFunctionDefinition
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugScope
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugLine
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugDeclare
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugScope
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugLine
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugDeclare
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugNoScope
+; CHECK:       {{.*}} = OpExtInst %void %1 DebugLine
+                        OpReturn
+                        OpFunctionEnd
+  )";
+  const auto result =
+      SinglePassRunAndMatch<OpExtInstWithForwardReferenceFixupPass>(
+          kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+}  // namespace
+}  // namespace opt
+}  // namespace spvtools
diff --git a/test/opt/propagator_test.cpp b/test/opt/propagator_test.cpp
index 307a2a12..0a98cfa8 100644
--- a/test/opt/propagator_test.cpp
+++ b/test/opt/propagator_test.cpp
@@ -184,7 +184,7 @@ TEST_F(PropagatorTest, PropagateThroughPhis) {
       }
     } else if (instr->opcode() == spv::Op::OpPhi) {
       phi_instr = instr;
-      SSAPropagator::PropStatus retval;
+      SSAPropagator::PropStatus retval = SSAPropagator::kNotInteresting;
       for (uint32_t i = 2; i < instr->NumOperands(); i += 2) {
         uint32_t phi_arg_id = instr->GetSingleWordOperand(i);
         auto it = values_.find(phi_arg_id);
diff --git a/test/opt/spread_volatile_semantics_test.cpp b/test/opt/spread_volatile_semantics_test.cpp
index 4328c396..664c986f 100644
--- a/test/opt/spread_volatile_semantics_test.cpp
+++ b/test/opt/spread_volatile_semantics_test.cpp
@@ -306,7 +306,7 @@ OpDecorate %images DescriptorSet 0
 OpDecorate %images Binding 1
 OpDecorate %images NonWritable
 
-; CHECK:     OpEntryPoint RayGenerationNV {{%\w+}} "RayGeneration" [[var:%\w+]]
+; CHECK:     OpEntryPoint RayGenerationKHR {{%\w+}} "RayGeneration" [[var:%\w+]]
 ; CHECK:     OpDecorate [[var]] BuiltIn SubgroupSize
 ; CHECK:     OpDecorate [[var]] Volatile
 ; CHECK-NOT: OpDecorate {{%\w+}} Volatile
@@ -397,8 +397,8 @@ OpDecorate %images DescriptorSet 0
 OpDecorate %images Binding 1
 OpDecorate %images NonWritable
 
-; CHECK:     OpEntryPoint RayGenerationNV {{%\w+}} "RayGeneration" [[var:%\w+]]
-; CHECK:     OpEntryPoint ClosestHitNV {{%\w+}} "ClosestHit" [[var]]
+; CHECK:     OpEntryPoint RayGenerationKHR {{%\w+}} "RayGeneration" [[var:%\w+]]
+; CHECK:     OpEntryPoint ClosestHitKHR {{%\w+}} "ClosestHit" [[var]]
 ; CHECK:     OpDecorate [[var]] BuiltIn SubgroupSize
 ; CHECK:     OpDecorate [[var]] Volatile
 ; CHECK-NOT: OpDecorate {{%\w+}} Volatile
diff --git a/test/opt/struct_packing_test.cpp b/test/opt/struct_packing_test.cpp
new file mode 100644
index 00000000..1b8e8d1a
--- /dev/null
+++ b/test/opt/struct_packing_test.cpp
@@ -0,0 +1,242 @@
+// Copyright (c) 2024 Epic Games, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <string>
+
+#include "gmock/gmock.h"
+#include "source/opt/struct_packing_pass.h"
+#include "test/opt/pass_fixture.h"
+#include "test/opt/pass_utils.h"
+
+namespace spvtools {
+namespace opt {
+namespace {
+
+using StructPackingTest = PassTest<::testing::Test>;
+
+TEST_F(StructPackingTest, PackSimpleStructStd140) {
+  // #version 420
+  //
+  // layout(std140, binding = 0) uniform Globals {
+  //   layout(offset = 16) vec3 a_xyz;
+  //   float a_w;
+  //   layout(offset = 128) vec3 b_xyz;
+  //   int b_w;
+  // };
+  //
+  // void main() {}
+  const std::string spirv = R"(
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main"
+OpExecutionMode %main OriginLowerLeft
+OpSource GLSL 420
+OpName %main "main"
+OpName %Globals "Globals"
+OpMemberName %Globals 0 "a_xyz"
+OpMemberName %Globals 1 "a_w"
+OpMemberName %Globals 2 "b_xyz"
+OpMemberName %Globals 3 "b_w"
+OpName %_ ""
+; CHECK: OpMemberDecorate %Globals 0 Offset 0
+OpMemberDecorate %Globals 0 Offset 16
+; CHECK: OpMemberDecorate %Globals 1 Offset 12
+OpMemberDecorate %Globals 1 Offset 28
+; CHECK: OpMemberDecorate %Globals 2 Offset 16
+OpMemberDecorate %Globals 2 Offset 128
+; CHECK: OpMemberDecorate %Globals 3 Offset 28
+OpMemberDecorate %Globals 3 Offset 140
+OpDecorate %Globals Block
+OpDecorate %_ DescriptorSet 0
+OpDecorate %_ Binding 0
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%float = OpTypeFloat 32
+%v3float = OpTypeVector %float 3
+%int = OpTypeInt 32 1
+%Globals = OpTypeStruct %v3float %float %v3float %int
+%_ptr_Uniform_Globals = OpTypePointer Uniform %Globals
+%_ = OpVariable %_ptr_Uniform_Globals Uniform
+%main = OpFunction %void None %3
+%5 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndMatch<StructPackingPass>(
+      spirv, true, "Globals", StructPackingPass::PackingRules::Std140);
+}
+
+TEST_F(StructPackingTest, PackSimpleStructWithPaddingStd140) {
+  // #version 420
+  //
+  // layout(std140, binding = 0) uniform Globals {
+  //   layout(offset = 16) vec3 a_xyz;
+  //   float a_w;
+  //   float b_x_padding_yzw;
+  //   layout(offset = 128) vec3 c_xyz;
+  //   int c_w;
+  // };
+  //
+  // void main() {}
+  const std::string spirv = R"(
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main"
+OpExecutionMode %main OriginLowerLeft
+OpSource GLSL 420
+OpName %main "main"
+OpName %Globals "Globals"
+OpMemberName %Globals 0 "a_xyz"
+OpMemberName %Globals 1 "a_w"
+OpMemberName %Globals 2 "b_x_padding_yzw"
+OpMemberName %Globals 3 "c_xyz"
+OpMemberName %Globals 4 "c_w"
+OpName %_ ""
+; CHECK: OpMemberDecorate %Globals 0 Offset 0
+OpMemberDecorate %Globals 0 Offset 16
+; CHECK: OpMemberDecorate %Globals 1 Offset 12
+OpMemberDecorate %Globals 1 Offset 28
+; CHECK: OpMemberDecorate %Globals 2 Offset 16
+OpMemberDecorate %Globals 2 Offset 32
+; CHECK: OpMemberDecorate %Globals 3 Offset 32
+OpMemberDecorate %Globals 3 Offset 128
+; CHECK: OpMemberDecorate %Globals 4 Offset 44
+OpMemberDecorate %Globals 4 Offset 140
+OpDecorate %Globals Block
+OpDecorate %_ DescriptorSet 0
+OpDecorate %_ Binding 0
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%float = OpTypeFloat 32
+%v3float = OpTypeVector %float 3
+%int = OpTypeInt 32 1
+%Globals = OpTypeStruct %v3float %float %float %v3float %int
+%_ptr_Uniform_Globals = OpTypePointer Uniform %Globals
+%_ = OpVariable %_ptr_Uniform_Globals Uniform
+%main = OpFunction %void None %3
+%5 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndMatch<StructPackingPass>(
+      spirv, true, "Globals", StructPackingPass::PackingRules::Std140);
+}
+
+TEST_F(StructPackingTest, PackSimpleScalarArrayStd140) {
+  // #version 420
+  //
+  // layout(std140, binding = 0) uniform Globals {
+  //   layout(offset = 16) float a[2];
+  //   layout(offset = 128) float b[2]; // Must become offset 32 with std140
+  // };
+  //
+  // void main() {}
+  const std::string spirv = R"(
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main"
+OpExecutionMode %main OriginLowerLeft
+OpSource GLSL 420
+OpName %main "main"
+OpName %Globals "Globals"
+OpMemberName %Globals 0 "a"
+OpMemberName %Globals 1 "b"
+OpName %_ ""
+OpDecorate %_arr_float_uint_2 ArrayStride 16
+OpDecorate %_arr_float_uint_2_0 ArrayStride 16
+; CHECK: OpMemberDecorate %Globals 0 Offset 0
+OpMemberDecorate %Globals 0 Offset 16
+; CHECK: OpMemberDecorate %Globals 1 Offset 32
+OpMemberDecorate %Globals 1 Offset 128
+OpDecorate %Globals Block
+OpDecorate %_ DescriptorSet 0
+OpDecorate %_ Binding 0
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%float = OpTypeFloat 32
+%uint = OpTypeInt 32 0
+%uint_2 = OpConstant %uint 2
+%_arr_float_uint_2 = OpTypeArray %float %uint_2
+%_arr_float_uint_2_0 = OpTypeArray %float %uint_2
+%Globals = OpTypeStruct %_arr_float_uint_2 %_arr_float_uint_2_0
+%_ptr_Uniform_Globals = OpTypePointer Uniform %Globals
+%_ = OpVariable %_ptr_Uniform_Globals Uniform
+%main = OpFunction %void None %3
+%5 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndMatch<StructPackingPass>(
+      spirv, true, "Globals", StructPackingPass::PackingRules::Std140);
+}
+
+TEST_F(StructPackingTest, PackSimpleScalarArrayStd430) {
+  // #version 430
+  //
+  // layout(std430, binding = 0) buffer Globals {
+  //   layout(offset = 16) float a[2];
+  //   layout(offset = 128) float b[2]; // Must become offset 8 with std430
+  // };
+  //
+  // void main() {}
+  const std::string spirv = R"(
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main"
+OpExecutionMode %main OriginLowerLeft
+OpSource GLSL 430
+OpName %main "main"
+OpName %Globals "Globals"
+OpMemberName %Globals 0 "a"
+OpMemberName %Globals 1 "b"
+OpName %_ ""
+OpDecorate %_arr_float_uint_2 ArrayStride 4
+OpDecorate %_arr_float_uint_2_0 ArrayStride 4
+; CHECK: OpMemberDecorate %Globals 0 Offset 0
+OpMemberDecorate %Globals 0 Offset 16
+; CHECK: OpMemberDecorate %Globals 1 Offset 8
+OpMemberDecorate %Globals 1 Offset 128
+OpDecorate %Globals BufferBlock
+OpDecorate %_ DescriptorSet 0
+OpDecorate %_ Binding 0
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%float = OpTypeFloat 32
+%uint = OpTypeInt 32 0
+%uint_2 = OpConstant %uint 2
+%_arr_float_uint_2 = OpTypeArray %float %uint_2
+%_arr_float_uint_2_0 = OpTypeArray %float %uint_2
+%Globals = OpTypeStruct %_arr_float_uint_2 %_arr_float_uint_2_0
+%_ptr_Uniform_Globals = OpTypePointer Uniform %Globals
+%_ = OpVariable %_ptr_Uniform_Globals Uniform
+%main = OpFunction %void None %3
+%5 = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  SinglePassRunAndMatch<StructPackingPass>(
+      spirv, true, "Globals", StructPackingPass::PackingRules::Std430);
+}
+
+}  // namespace
+}  // namespace opt
+}  // namespace spvtools
diff --git a/test/opt/trim_capabilities_pass_test.cpp b/test/opt/trim_capabilities_pass_test.cpp
index d74ccdf2..1569ad73 100644
--- a/test/opt/trim_capabilities_pass_test.cpp
+++ b/test/opt/trim_capabilities_pass_test.cpp
@@ -12,6 +12,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include <gtest/gtest-param-test.h>
+#include <gtest/gtest.h>
+
+#include <tuple>
+
 #include "spirv-tools/optimizer.hpp"
 #include "test/opt/pass_fixture.h"
 #include "test/opt/pass_utils.h"
@@ -63,8 +68,8 @@ TEST_F(TrimCapabilitiesPassTest, CheckKnownAliasTransformations) {
                OpCapability DotProductInput4x8BitKHR
                OpCapability DotProductInput4x8BitPackedKHR
                OpCapability DotProductKHR
-               OpCapability ComputeDerivativeGroupQuadsNV
-               OpCapability ComputeDerivativeGroupLinearNV
+               OpCapability ComputeDerivativeGroupQuadsKHR
+               OpCapability ComputeDerivativeGroupLinearKHR
 ; CHECK: OpCapability Linkage
 ; CHECK-NOT: OpCapability StorageUniform16
 ; CHECK-NOT: OpCapability StorageUniformBufferBlock16
@@ -91,8 +96,8 @@ TEST_F(TrimCapabilitiesPassTest, CheckKnownAliasTransformations) {
 ; CHECK-NOT: OpCapability DotProductInput4x8BitKHR
 ; CHECK-NOT: OpCapability DotProductInput4x8BitPackedKHR
 ; CHECK-NOT: OpCapability DotProductKHR
-; CHECK-NOT: OpCapability ComputeDerivativeGroupQuadsNV
-; CHECK-NOT: OpCapability ComputeDerivativeGroupLinearNV
+; CHECK-NOT: OpCapability ComputeDerivativeGroupQuadsKHR
+; CHECK-NOT: OpCapability ComputeDerivativeGroupLinearKHR
 ; CHECK: OpCapability UniformAndStorageBuffer16BitAccess
 ; CHECK: OpCapability StorageBuffer16BitAccess
 ; CHECK: OpCapability ShaderViewportIndexLayerEXT
@@ -2136,11 +2141,11 @@ TEST_F(TrimCapabilitiesPassTest, Float64_RemainsWhenUsed) {
 TEST_F(TrimCapabilitiesPassTest,
        ComputeDerivativeGroupQuads_ReamainsWithExecMode) {
   const std::string kTest = R"(
-               OpCapability ComputeDerivativeGroupQuadsNV
-               OpCapability ComputeDerivativeGroupLinearNV
-; CHECK-NOT:   OpCapability ComputeDerivativeGroupLinearNV
-; CHECK:       OpCapability ComputeDerivativeGroupQuadsNV
-; CHECK-NOT:   OpCapability ComputeDerivativeGroupLinearNV
+               OpCapability ComputeDerivativeGroupQuadsKHR
+               OpCapability ComputeDerivativeGroupLinearKHR
+; CHECK-NOT:   OpCapability ComputeDerivativeGroupLinearKHR
+; CHECK:       OpCapability ComputeDerivativeGroupQuadsKHR
+; CHECK-NOT:   OpCapability ComputeDerivativeGroupLinearKHR
                OpCapability Shader
 ; CHECK:       OpExtension "SPV_NV_compute_shader_derivatives"
                OpExtension "SPV_NV_compute_shader_derivatives"
@@ -2162,11 +2167,11 @@ TEST_F(TrimCapabilitiesPassTest,
 TEST_F(TrimCapabilitiesPassTest,
        ComputeDerivativeGroupLinear_ReamainsWithExecMode) {
   const std::string kTest = R"(
-               OpCapability ComputeDerivativeGroupLinearNV
-               OpCapability ComputeDerivativeGroupQuadsNV
-; CHECK-NOT:   OpCapability ComputeDerivativeGroupQuadsNV
-; CHECK:       OpCapability ComputeDerivativeGroupLinearNV
-; CHECK-NOT:   OpCapability ComputeDerivativeGroupQuadsNV
+               OpCapability ComputeDerivativeGroupLinearKHR
+               OpCapability ComputeDerivativeGroupQuadsKHR
+; CHECK-NOT:   OpCapability ComputeDerivativeGroupQuadsKHR
+; CHECK:       OpCapability ComputeDerivativeGroupLinearKHR
+; CHECK-NOT:   OpCapability ComputeDerivativeGroupQuadsKHR
                OpCapability Shader
 ; CHECK:       OpExtension "SPV_NV_compute_shader_derivatives"
                OpExtension "SPV_NV_compute_shader_derivatives"
@@ -2366,6 +2371,94 @@ TEST_F(TrimCapabilitiesPassTest,
   EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
 }
 
+TEST_F(TrimCapabilitiesPassTest,
+       StorageImageWriteWithoutFormat_RemainsWhenRequiredWithWrite) {
+  const std::string kTest = R"(
+               OpCapability StorageImageWriteWithoutFormat
+; CHECK:       OpCapability StorageImageWriteWithoutFormat
+               OpCapability Shader
+               OpCapability StorageImageExtendedFormats
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %main "main" %id %img
+               OpExecutionMode %main LocalSize 8 8 8
+               OpSource HLSL 670
+               OpName %type_image "type.3d.image"
+               OpName %img "img"
+               OpName %main "main"
+               OpDecorate %id BuiltIn GlobalInvocationId
+               OpDecorate %img DescriptorSet 0
+               OpDecorate %img Binding 0
+      %float = OpTypeFloat 32
+    %float_4 = OpConstant %float 4
+    %float_5 = OpConstant %float 5
+    %v2float = OpTypeVector %float 2
+          %9 = OpConstantComposite %v2float %float_4 %float_5
+ %type_image = OpTypeImage %float 3D 2 0 0 2 Unknown
+    %ptr_img = OpTypePointer UniformConstant %type_image
+       %uint = OpTypeInt 32 0
+     %v3uint = OpTypeVector %uint 3
+  %ptr_input = OpTypePointer Input %v3uint
+       %void = OpTypeVoid
+         %15 = OpTypeFunction %void
+        %img = OpVariable %ptr_img UniformConstant
+         %id = OpVariable %ptr_input Input
+       %main = OpFunction %void None %15
+         %16 = OpLabel
+         %17 = OpLoad %v3uint %id
+         %18 = OpLoad %type_image %img
+               OpImageWrite %18 %17 %9 None
+               OpReturn
+               OpFunctionEnd
+  )";
+  const auto result =
+      SinglePassRunAndMatch<TrimCapabilitiesPass>(kTest, /* skip_nop= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithoutChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       StorageImageWriteWithoutFormat_RemovedWithWriteOnKnownFormat) {
+  const std::string kTest = R"(
+               OpCapability StorageImageWriteWithoutFormat
+; CHECK-NOT:   OpCapability StorageImageWriteWithoutFormat
+               OpCapability Shader
+               OpCapability StorageImageExtendedFormats
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %main "main" %id %img
+               OpExecutionMode %main LocalSize 8 8 8
+               OpSource HLSL 670
+               OpName %type_image "type.3d.image"
+               OpName %img "img"
+               OpName %main "main"
+               OpDecorate %id BuiltIn GlobalInvocationId
+               OpDecorate %img DescriptorSet 0
+               OpDecorate %img Binding 0
+      %float = OpTypeFloat 32
+    %float_4 = OpConstant %float 4
+    %float_5 = OpConstant %float 5
+    %v2float = OpTypeVector %float 2
+          %9 = OpConstantComposite %v2float %float_4 %float_5
+ %type_image = OpTypeImage %float 3D 2 0 0 2 Rg32f
+    %ptr_img = OpTypePointer UniformConstant %type_image
+       %uint = OpTypeInt 32 0
+     %v3uint = OpTypeVector %uint 3
+  %ptr_input = OpTypePointer Input %v3uint
+       %void = OpTypeVoid
+         %15 = OpTypeFunction %void
+        %img = OpVariable %ptr_img UniformConstant
+         %id = OpVariable %ptr_input Input
+       %main = OpFunction %void None %15
+         %16 = OpLabel
+         %17 = OpLoad %v3uint %id
+         %18 = OpLoad %type_image %img
+               OpImageWrite %18 %17 %9 None
+               OpReturn
+               OpFunctionEnd
+  )";
+  const auto result =
+      SinglePassRunAndMatch<TrimCapabilitiesPass>(kTest, /* skip_nop= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
 TEST_F(TrimCapabilitiesPassTest, PhysicalStorageBuffer_RemovedWhenUnused) {
   const std::string kTest = R"(
                OpCapability PhysicalStorageBufferAddresses
@@ -2660,6 +2753,568 @@ TEST_F(TrimCapabilitiesPassTest,
   EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithoutChange);
 }
 
+TEST_F(TrimCapabilitiesPassTest, GroupNonUniform_RemovedWhenUnused) {
+  const std::string kTest = R"(
+               OpCapability Shader
+               OpCapability GroupNonUniformVote
+; CHECK-NOT:   OpCapability GroupNonUniformVote
+               OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:   OpCapability GroupNonUniformArithmetic
+               OpCapability GroupNonUniformClustered
+; CHECK-NOT:   OpCapability GroupNonUniformClustered
+               OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:   OpCapability GroupNonUniformPartitionedNV
+               OpCapability GroupNonUniform
+; CHECK-NOT:   OpCapability GroupNonUniform
+               OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:   OpExtension "SPV_NV_shader_subgroup_partitioned"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %main "main"
+               OpExecutionMode %main LocalSize 1 2 4
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %main = OpFunction %void None %3
+          %6 = OpLabel
+               OpReturn
+               OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniform_RemainsGroupNonUniformWhenInUse) {
+  const std::string kTest = R"(
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:       OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK:           OpCapability GroupNonUniform
+                   OpCapability Shader
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformElect %bool %scope_subgroup
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniformVote_Remains_OpGroupNonUniformAll) {
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK:           OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:       OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformAll %bool %scope_subgroup %true
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniformVote_Remains_OpGroupNonUniformAny) {
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK:           OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:       OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformAny %bool %scope_subgroup %true
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniformArithmetic_Remains_OpGroupNonUniformIAdd_Reduce) {
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK:           OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformIAdd %uint %scope_subgroup Reduce %uint_1
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniformArithmetic_Remains_OpGroupNonUniformIAdd_InclusiveScan) {
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK:           OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformIAdd %uint %scope_subgroup InclusiveScan %uint_1
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniformArithmetic_Remains_OpGroupNonUniformIAdd_ExclusiveScan) {
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK:           OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformIAdd %uint %scope_subgroup ExclusiveScan %uint_1
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       GroupNonUniformClustered_Remains_OpGroupNonUniformIAdd_ClusteredReduce) {
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:       OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK:           OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = OpGroupNonUniformIAdd %uint %scope_subgroup ClusteredReduce %uint_1 %uint_1
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+struct SubgroupTestCase {
+  // The result type of the subgroup instruction.
+  std::string resultType;
+  // The opcode of the subgroup instruction.
+  std::string opcode;
+  // The actual operand of the subgroup instruction.
+  std::string operand;
+};
+
+static const std::vector<SubgroupTestCase> kSubgroupTestCases{
+    // clang-format off
+  { "uint",  "OpGroupNonUniformIAdd",       "uint_1"  },
+  { "float", "OpGroupNonUniformFAdd",       "float_1" },
+  { "uint",  "OpGroupNonUniformIMul",       "uint_1"  },
+  { "float", "OpGroupNonUniformFMul",       "float_1" },
+  { "int",   "OpGroupNonUniformSMin",       "int_1"   },
+  { "uint",  "OpGroupNonUniformUMin",       "uint_1"  },
+  { "float", "OpGroupNonUniformFMin",       "float_1" },
+  { "int",   "OpGroupNonUniformSMax",       "int_1"   },
+  { "uint",  "OpGroupNonUniformUMax",       "uint_1"  },
+  { "float", "OpGroupNonUniformFMax",       "float_1" },
+  { "uint",  "OpGroupNonUniformBitwiseAnd", "uint_1"  },
+  { "uint",  "OpGroupNonUniformBitwiseOr",  "uint_1"  },
+  { "uint",  "OpGroupNonUniformBitwiseXor", "uint_1"  },
+  { "bool",  "OpGroupNonUniformLogicalAnd", "true"    },
+  { "bool",  "OpGroupNonUniformLogicalOr",  "true"    },
+  { "bool",  "OpGroupNonUniformLogicalXor", "true"    }
+    // clang-format on
+};
+
+using TrimCapabilitiesPassTestSubgroupNV_Unsigned = PassTest<
+    ::testing::TestWithParam<std::tuple<SubgroupTestCase, std::string>>>;
+TEST_P(TrimCapabilitiesPassTestSubgroupNV_Unsigned,
+       GroupNonUniformPartitionedNV_Remains) {
+  SubgroupTestCase test_case = std::get<0>(GetParam());
+  const std::string operation = std::get<1>(GetParam());
+
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:       OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK:           OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK:           OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+            %int = OpTypeInt 32 1
+          %float = OpTypeFloat 32
+         %v4uint = OpTypeVector %uint 4
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+          %int_1 = OpConstant %int 1
+        %float_1 = OpConstant %float 1
+     %uint4_1111 = OpConstantComposite %v4uint %uint_1 %uint_1 %uint_1 %uint_1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = )" + test_case.opcode +
+                            " %" + test_case.resultType + " %scope_subgroup " +
+                            operation + " %" + test_case.operand +
+                            R"( %uint4_1111
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    TrimCapabilitiesPassTestSubgroupNV_Unsigned_I,
+    TrimCapabilitiesPassTestSubgroupNV_Unsigned,
+    ::testing::Combine(::testing::ValuesIn(kSubgroupTestCases),
+                       ::testing::Values("PartitionedReduceNV",
+                                         "PartitionedInclusiveScanNV",
+                                         "PartitionedExclusiveScanNV")),
+    [](const ::testing::TestParamInfo<
+        TrimCapabilitiesPassTestSubgroupNV_Unsigned::ParamType>& info) {
+      return std::get<0>(info.param).opcode + "_" + std::get<1>(info.param);
+    });
+
+using TrimCapabilitiesPassTestSubgroupArithmetic_Unsigned = PassTest<
+    ::testing::TestWithParam<std::tuple<SubgroupTestCase, std::string>>>;
+TEST_P(TrimCapabilitiesPassTestSubgroupArithmetic_Unsigned,
+       GroupNonUniformPartitionedArithmetic_Remains) {
+  SubgroupTestCase test_case = std::get<0>(GetParam());
+  const std::string operation = std::get<1>(GetParam());
+
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK:           OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK-NOT:       OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+            %int = OpTypeInt 32 1
+          %float = OpTypeFloat 32
+         %v4uint = OpTypeVector %uint 4
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+          %int_1 = OpConstant %int 1
+        %float_1 = OpConstant %float 1
+     %uint4_1111 = OpConstantComposite %v4uint %uint_1 %uint_1 %uint_1 %uint_1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = )" + test_case.opcode +
+                            " %" + test_case.resultType + " %scope_subgroup " +
+                            operation + " %" + test_case.operand + R"( %uint_1
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    TrimCapabilitiesPassTestSubgroupArithmetic_Unsigned_I,
+    TrimCapabilitiesPassTestSubgroupArithmetic_Unsigned,
+    ::testing::Combine(::testing::ValuesIn(kSubgroupTestCases),
+                       ::testing::Values("Reduce", "InclusiveScan",
+                                         "ExclusiveScan")),
+    [](const ::testing::TestParamInfo<
+        TrimCapabilitiesPassTestSubgroupArithmetic_Unsigned::ParamType>& info) {
+      return std::get<0>(info.param).opcode + "_" + std::get<1>(info.param);
+    });
+
+using TrimCapabilitiesPassTestSubgroupClustered_Unsigned = PassTest<
+    ::testing::TestWithParam<std::tuple<SubgroupTestCase, std::string>>>;
+TEST_P(TrimCapabilitiesPassTestSubgroupClustered_Unsigned,
+       GroupNonUniformPartitionedClustered_Remains) {
+  SubgroupTestCase test_case = std::get<0>(GetParam());
+  const std::string operation = std::get<1>(GetParam());
+
+  const std::string kTest = R"(
+                   OpCapability Shader
+                   OpCapability GroupNonUniformVote
+; CHECK-NOT:       OpCapability GroupNonUniformVote
+                   OpCapability GroupNonUniformArithmetic
+; CHECK-NOT:       OpCapability GroupNonUniformArithmetic
+                   OpCapability GroupNonUniformClustered
+; CHECK:           OpCapability GroupNonUniformClustered
+                   OpCapability GroupNonUniformPartitionedNV
+; CHECK-NOT:       OpCapability GroupNonUniformPartitionedNV
+                   OpCapability GroupNonUniform
+; CHECK-NOT:       OpCapability GroupNonUniform
+                   OpExtension "SPV_NV_shader_subgroup_partitioned"
+; CHECK-NOT:       OpExtension "SPV_NV_shader_subgroup_partitioned"
+                   OpMemoryModel Logical GLSL450
+                   OpEntryPoint GLCompute %main "main"
+                   OpExecutionMode %main LocalSize 1 2 4
+           %void = OpTypeVoid
+           %bool = OpTypeBool
+           %uint = OpTypeInt 32 0
+            %int = OpTypeInt 32 1
+          %float = OpTypeFloat 32
+         %v4uint = OpTypeVector %uint 4
+ %scope_subgroup = OpConstant %uint 3
+         %uint_1 = OpConstant %uint 1
+          %int_1 = OpConstant %int 1
+        %float_1 = OpConstant %float 1
+     %uint4_1111 = OpConstantComposite %v4uint %uint_1 %uint_1 %uint_1 %uint_1
+           %true = OpConstantTrue %bool
+              %3 = OpTypeFunction %void
+           %main = OpFunction %void None %3
+              %6 = OpLabel
+              %7 = )" + test_case.opcode +
+                            " %" + test_case.resultType + " %scope_subgroup " +
+                            operation + " %" + test_case.operand + R"( %uint_1
+                   OpReturn
+                   OpFunctionEnd;
+  )";
+  const auto result = SinglePassRunAndMatch<TrimCapabilitiesPass>(
+      kTest, /* do_validation= */ true);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest, InterpolationFunction_RemovedIfNotUsed) {
+  const std::string kTest = R"(
+               OpCapability Shader
+               OpCapability InterpolationFunction
+; CHECK-NOT:   OpCapability InterpolationFunction
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %out_var_SV_Target
+               OpExecutionMode %main OriginUpperLeft
+               OpSource HLSL 660
+               OpName %out_var_SV_Target "out.var.SV_Target"
+               OpName %main "main"
+               OpDecorate %out_var_SV_Target Location 0
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+%out_var_SV_Target = OpVariable %_ptr_Output_v4float Output
+       %main = OpFunction %void None %7
+          %8 = OpLabel
+               OpReturn
+               OpFunctionEnd
+  )";
+  const auto result =
+      SinglePassRunAndMatch<TrimCapabilitiesPass>(kTest, /* skip_nop= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);
+}
+
+TEST_F(TrimCapabilitiesPassTest,
+       InterpolationFunction_RemainsWithInterpolateAtCentroid) {
+  const std::string kTest = R"(
+               OpCapability Shader
+               OpCapability InterpolationFunction
+; CHECK:       OpCapability InterpolationFunction
+     %std450 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %out_var_SV_Target %gl_PointCoord
+               OpExecutionMode %main OriginUpperLeft
+               OpSource HLSL 660
+               OpName %out_var_SV_Target "out.var.SV_Target"
+               OpName %main "main"
+               OpDecorate %out_var_SV_Target Location 0
+               OpDecorate %gl_PointCoord BuiltIn PointCoord
+      %float = OpTypeFloat 32
+    %v2float = OpTypeVector %float 2
+    %v4float = OpTypeVector %float 4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%_ptr_Input_v2float = OpTypePointer Input %v2float
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+%out_var_SV_Target = OpVariable %_ptr_Output_v4float Output
+%gl_PointCoord = OpVariable %_ptr_Input_v2float Input
+       %main = OpFunction %void None %7
+          %8 = OpLabel
+          %9 = OpExtInst %v4float %std450 InterpolateAtCentroid %gl_PointCoord
+               OpReturn
+               OpFunctionEnd
+  )";
+  const auto result =
+      SinglePassRunAndMatch<TrimCapabilitiesPass>(kTest, /* skip_nop= */ false);
+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithoutChange);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    TrimCapabilitiesPassTestSubgroupClustered_Unsigned_I,
+    TrimCapabilitiesPassTestSubgroupClustered_Unsigned,
+    ::testing::Combine(::testing::ValuesIn(kSubgroupTestCases),
+                       ::testing::Values("ClusteredReduce")),
+    [](const ::testing::TestParamInfo<
+        TrimCapabilitiesPassTestSubgroupClustered_Unsigned::ParamType>& info) {
+      return std::get<0>(info.param).opcode + "_" + std::get<1>(info.param);
+    });
+
 }  // namespace
 }  // namespace opt
 }  // namespace spvtools
diff --git a/test/opt/type_manager_test.cpp b/test/opt/type_manager_test.cpp
index 946f06cc..865bfbb0 100644
--- a/test/opt/type_manager_test.cpp
+++ b/test/opt/type_manager_test.cpp
@@ -175,6 +175,9 @@ std::vector<std::unique_ptr<Type>> GenerateAllTypes() {
   types.emplace_back(new RayQueryKHR());
   types.emplace_back(new HitObjectNV());
 
+  types.emplace_back(new TensorLayoutNV(1002, 1000));
+  types.emplace_back(new TensorViewNV(1002, 1003, {1000, 1001}));
+
   return types;
 }
 
@@ -942,10 +945,11 @@ OpMemoryModel Logical GLSL450
   EXPECT_NE(context, nullptr);
 
   std::vector<std::unique_ptr<Type>> types = GenerateAllTypes();
-  uint32_t id = 1u;
+  uint32_t id = 0u;
   for (auto& t : types) {
-    context->get_type_mgr()->RegisterType(id, *t);
+    context->get_type_mgr()->RegisterType(++id, *t);
     EXPECT_EQ(*t, *context->get_type_mgr()->GetType(id));
+    EXPECT_EQ(id, context->get_type_mgr()->GetId(t.get()));
   }
   types.clear();
 
@@ -1101,11 +1105,14 @@ OpMemoryModel Logical GLSL450
 %uint = OpTypeInt 32 0
 %1 = OpTypePointer Input %uint
 %2 = OpTypePointer Uniform %uint
+%1000 = OpConstant %uint 0
+%1001 = OpConstant %uint 1
 %1002 = OpConstant %uint 2
 %8 = OpConstant %uint 8
 %24 = OpConstant %uint 24
 %42 = OpConstant %uint 42
 %100 = OpConstant %uint 100
+%1003 = OpConstantFalse %bool
   )";
 
   std::unique_ptr<IRContext> context =
@@ -1199,6 +1206,39 @@ OpMemoryModel Logical GLSL450
   Match(text, context.get());
 }
 
+// Structures containing circular type references
+// (from https://github.com/KhronosGroup/SPIRV-Tools/issues/5623).
+TEST(TypeManager, CircularPointerToStruct) {
+  const std::string text = R"(
+               OpCapability VariablePointers
+               OpCapability PhysicalStorageBufferAddresses
+               OpCapability Int64
+               OpCapability Shader
+               OpExtension "SPV_KHR_variable_pointers"
+               OpExtension "SPV_KHR_physical_storage_buffer"
+               OpMemoryModel PhysicalStorageBuffer64 GLSL450
+               OpEntryPoint Fragment %1 "main"
+               OpExecutionMode %1 OriginUpperLeft
+               OpExecutionMode %1 DepthReplacing
+               OpDecorate %1200 ArrayStride 24
+               OpMemberDecorate %600 0 Offset 0
+               OpMemberDecorate %800 0 Offset 0
+               OpMemberDecorate %120 0 Offset 16
+               OpTypeForwardPointer %1200 PhysicalStorageBuffer
+                 %600 = OpTypeStruct %1200
+                 %800 = OpTypeStruct %1200
+                 %120 = OpTypeStruct %800
+                %1200 = OpTypePointer PhysicalStorageBuffer %120
+  )";
+
+  std::unique_ptr<IRContext> context =
+      BuildModule(SPV_ENV_UNIVERSAL_1_1, nullptr, text,
+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  TypeManager manager(nullptr, context.get());
+  uint32_t id = manager.FindPointerToType(600, spv::StorageClass::Function);
+  EXPECT_EQ(id, 1201);
+}
+
 }  // namespace
 }  // namespace analysis
 }  // namespace opt
diff --git a/test/reduce/CMakeLists.txt b/test/reduce/CMakeLists.txt
index 121cd4f0..d3eaa846 100644
--- a/test/reduce/CMakeLists.txt
+++ b/test/reduce/CMakeLists.txt
@@ -31,6 +31,7 @@ add_spvtools_unittest(TARGET reduce
         structured_construct_to_block_test.cpp
         structured_loop_to_selection_test.cpp
         validation_during_reduction_test.cpp
+        ${spirv-tools_SOURCE_DIR}/tools/io.cpp
         LIBS SPIRV-Tools-reduce
         )
 
diff --git a/test/target_env_test.cpp b/test/target_env_test.cpp
index 7917cbfb..faffa8a1 100644
--- a/test/target_env_test.cpp
+++ b/test/target_env_test.cpp
@@ -170,5 +170,60 @@ INSTANTIATE_TEST_SUITE_P(
         {VK(99, 0), SPV(1, 0), false, SPV_ENV_UNIVERSAL_1_0},
     }));
 
-}  // namespace
+// A test case for parsing the text header of disassembly.
+struct ParseEnvInDisassemblyCase {
+  std::string text;
+  bool success;        // Expect to successfully parse?
+  spv_target_env env;  // The parsed environment, if successful.
+};
+
+using TargetParseEnvInDisassemblyTest =
+    ::testing::TestWithParam<ParseEnvInDisassemblyCase>;
+
+constexpr spv_target_env kSentinelEnv = SPV_ENV_OPENCL_2_2;
+
+TEST_P(TargetParseEnvInDisassemblyTest, Samples) {
+  const std::string& text = GetParam().text;
+  const std::vector<char> text_vec(text.begin(), text.end());
+  spv_target_env got_env = kSentinelEnv;
+  bool parsed = spvReadEnvironmentFromText(text_vec, &got_env);
+  EXPECT_EQ(parsed, GetParam().success);
+  EXPECT_EQ(got_env, GetParam().env) << '"' << text << '"';
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    TargetTextParsing, TargetParseEnvInDisassemblyTest,
+    ValuesIn(std::vector<ParseEnvInDisassemblyCase>{
+        {"; Version: 1.0", true, SPV_ENV_UNIVERSAL_1_0},
+        {"; Version: 1.1", true, SPV_ENV_UNIVERSAL_1_1},
+        {"; Version: 1.2", true, SPV_ENV_UNIVERSAL_1_2},
+        {"; Version: 1.3", true, SPV_ENV_UNIVERSAL_1_3},
+        {"; Version: 1.4", true, SPV_ENV_UNIVERSAL_1_4},
+        {"; Version: 1.5", true, SPV_ENV_UNIVERSAL_1_5},
+        {"; Version: 1.6", true, SPV_ENV_UNIVERSAL_1_6},
+        {"; Version: 1.7", false, kSentinelEnv},
+        {"; Version: 1.8", false, kSentinelEnv},
+        {"; Version: 1.9", false, kSentinelEnv},
+        {"; Version: 2.0", false, kSentinelEnv},
+
+        // Check trailing text
+        {"; Version: 1.1\n", true, SPV_ENV_UNIVERSAL_1_1},
+        {"; Version: 1.1\t", true, SPV_ENV_UNIVERSAL_1_1},
+        {"; Version: 1.1 ", true, SPV_ENV_UNIVERSAL_1_1},
+        {"; Version: 1.1x", true, SPV_ENV_UNIVERSAL_1_1},
+        // Not a digit.
+        {"; Version: 1.10", false, kSentinelEnv},
+
+        // Unexpected prefix
+        {";Version: 1.1", false, kSentinelEnv},
+
+        // Leading spaces
+        {"     \t ; Version: 1.1", true, SPV_ENV_UNIVERSAL_1_1},
+        // Previous lines
+        {"; SPIR-V\n; Version: 1.1", true, SPV_ENV_UNIVERSAL_1_1},
+
+        // After a non-header line
+        {"OpCapability Shader\n; Version: 1.1", false, kSentinelEnv}}));
+
+}  // anonymous namespace
 }  // namespace spvtools
diff --git a/test/test_fixture.h b/test/test_fixture.h
index 029fc854..424f5eeb 100644
--- a/test/test_fixture.h
+++ b/test/test_fixture.h
@@ -111,13 +111,15 @@ class TextToBinaryTestBase : public T {
   std::string EncodeAndDecodeSuccessfully(
       const std::string& txt,
       uint32_t disassemble_options = SPV_BINARY_TO_TEXT_OPTION_NONE,
+      uint32_t assemble_options = SPV_TEXT_TO_BINARY_OPTION_NONE,
       spv_target_env env = SPV_ENV_UNIVERSAL_1_0, bool flip_words = false) {
     DestroyBinary();
     DestroyDiagnostic();
     ScopedContext context(env);
     disassemble_options |= SPV_BINARY_TO_TEXT_OPTION_NO_HEADER;
-    spv_result_t error = spvTextToBinary(context.context, txt.c_str(),
-                                         txt.size(), &binary, &diagnostic);
+    spv_result_t error =
+        spvTextToBinaryWithOptions(context.context, txt.c_str(), txt.size(),
+                                   assemble_options, &binary, &diagnostic);
     if (error) {
       spvDiagnosticPrint(diagnostic);
       spvDiagnosticDestroy(diagnostic);
diff --git a/test/text_to_binary.annotation_test.cpp b/test/text_to_binary.annotation_test.cpp
index 826812bf..edf886f6 100644
--- a/test/text_to_binary.annotation_test.cpp
+++ b/test/text_to_binary.annotation_test.cpp
@@ -55,10 +55,10 @@ TEST_P(OpDecorateSimpleTest, AnySimpleDecoration) {
                                  {1, uint32_t(std::get<1>(GetParam()).value())},
                                  std::get<1>(GetParam()).operands())));
   // Also check disassembly.
-  EXPECT_THAT(
-      EncodeAndDecodeSuccessfully(input.str(), SPV_BINARY_TO_TEXT_OPTION_NONE,
-                                  std::get<0>(GetParam())),
-      Eq(input.str()));
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input.str(), SPV_BINARY_TO_TEXT_OPTION_NONE,
+                  SPV_TEXT_TO_BINARY_OPTION_NONE, std::get<0>(GetParam())),
+              Eq(input.str()));
 }
 
 // Like above, but parameters to the decoration are IDs.
@@ -78,10 +78,10 @@ TEST_P(OpDecorateSimpleIdTest, AnySimpleDecoration) {
                                  {1, uint32_t(std::get<1>(GetParam()).value())},
                                  std::get<1>(GetParam()).operands())));
   // Also check disassembly.
-  EXPECT_THAT(
-      EncodeAndDecodeSuccessfully(input.str(), SPV_BINARY_TO_TEXT_OPTION_NONE,
-                                  std::get<0>(GetParam())),
-      Eq(input.str()));
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input.str(), SPV_BINARY_TO_TEXT_OPTION_NONE,
+                  SPV_TEXT_TO_BINARY_OPTION_NONE, std::get<0>(GetParam())),
+              Eq(input.str()));
 }
 
 #define CASE(NAME) spv::Decoration::NAME, #NAME
@@ -460,10 +460,10 @@ TEST_P(OpMemberDecorateSimpleTest, AnySimpleDecoration) {
                          {1, 42, uint32_t(std::get<1>(GetParam()).value())},
                          std::get<1>(GetParam()).operands())));
   // Also check disassembly.
-  EXPECT_THAT(
-      EncodeAndDecodeSuccessfully(input.str(), SPV_BINARY_TO_TEXT_OPTION_NONE,
-                                  std::get<0>(GetParam())),
-      Eq(input.str()));
+  EXPECT_THAT(EncodeAndDecodeSuccessfully(
+                  input.str(), SPV_BINARY_TO_TEXT_OPTION_NONE,
+                  SPV_TEXT_TO_BINARY_OPTION_NONE, std::get<0>(GetParam())),
+              Eq(input.str()));
 }
 
 #define CASE(NAME) spv::Decoration::NAME, #NAME
diff --git a/test/text_to_binary.composite_test.cpp b/test/text_to_binary.composite_test.cpp
index 6ae1cd35..2f255ac4 100644
--- a/test/text_to_binary.composite_test.cpp
+++ b/test/text_to_binary.composite_test.cpp
@@ -35,7 +35,8 @@ using CompositeRoundTripTest = RoundTripTest;
 TEST_F(CompositeRoundTripTest, Good) {
   std::string spirv = "%2 = OpCopyLogical %1 %3\n";
   std::string disassembly = EncodeAndDecodeSuccessfully(
-      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_ENV_UNIVERSAL_1_4);
+      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_TEXT_TO_BINARY_OPTION_NONE,
+      SPV_ENV_UNIVERSAL_1_4);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
diff --git a/test/text_to_binary.extension_test.cpp b/test/text_to_binary.extension_test.cpp
index 8e78312e..59f2af9e 100644
--- a/test/text_to_binary.extension_test.cpp
+++ b/test/text_to_binary.extension_test.cpp
@@ -130,9 +130,10 @@ TEST_P(ExtensionRoundTripTest, Samples) {
   EXPECT_THAT(CompiledInstructions(ac.input, env), Eq(ac.expected));
 
   // Check round trip through the disassembler.
-  EXPECT_THAT(EncodeAndDecodeSuccessfully(ac.input,
-                                          SPV_BINARY_TO_TEXT_OPTION_NONE, env),
-              Eq(ac.input))
+  EXPECT_THAT(
+      EncodeAndDecodeSuccessfully(ac.input, SPV_BINARY_TO_TEXT_OPTION_NONE,
+                                  SPV_TEXT_TO_BINARY_OPTION_NONE, env),
+      Eq(ac.input))
       << "target env: " << spvTargetEnvDescription(env) << "\n";
 }
 
@@ -1300,5 +1301,80 @@ INSTANTIATE_TEST_SUITE_P(
                   (uint32_t)spv::FPFastMathModeMask::AllowTransform})},
         })));
 
+// SPV_EXT_replicated_composites
+
+INSTANTIATE_TEST_SUITE_P(
+    SPV_EXT_replicated_composites, ExtensionRoundTripTest,
+    Combine(Values(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_UNIVERSAL_1_6,
+                   SPV_ENV_VULKAN_1_0, SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_2,
+                   SPV_ENV_VULKAN_1_3, SPV_ENV_OPENCL_2_1),
+            ValuesIn(std::vector<AssemblyCase>{
+                {"OpExtension \"SPV_EXT_replicated_composites\"\n",
+                 MakeInstruction(spv::Op::OpExtension,
+                                 MakeVector("SPV_EXT_replicated_composites"))},
+                {"OpCapability ReplicatedCompositesEXT\n",
+                 MakeInstruction(
+                     spv::Op::OpCapability,
+                     {(uint32_t)spv::Capability::ReplicatedCompositesEXT})},
+                {"%2 = OpConstantCompositeReplicateEXT %1 %3\n",
+                 MakeInstruction(spv::Op::OpConstantCompositeReplicateEXT,
+                                 {1, 2, 3})},
+                {"%2 = OpSpecConstantCompositeReplicateEXT %1 %3\n",
+                 MakeInstruction(spv::Op::OpSpecConstantCompositeReplicateEXT,
+                                 {1, 2, 3})},
+                {"%2 = OpCompositeConstructReplicateEXT %1 %3\n",
+                 MakeInstruction(spv::Op::OpCompositeConstructReplicateEXT,
+                                 {1, 2, 3})},
+            })));
+
+// SPV_KHR_untyped_pointers
+INSTANTIATE_TEST_SUITE_P(
+    SPV_KHR_untyped_pointers, ExtensionRoundTripTest,
+    Combine(
+        Values(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_UNIVERSAL_1_3, SPV_ENV_VULKAN_1_0,
+               SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_2),
+        ValuesIn(std::vector<AssemblyCase>{
+            {"OpExtension \"SPV_KHR_untyped_pointers\"\n",
+             MakeInstruction(spv::Op::OpExtension,
+                             MakeVector("SPV_KHR_untyped_pointers"))},
+            {"OpCapability UntypedPointersKHR\n",
+             MakeInstruction(spv::Op::OpCapability,
+                             {(int)spv::Capability::UntypedPointersKHR})},
+            {"OpCapability UntypedPointersKHR\n",
+             MakeInstruction(spv::Op::OpCapability, {4473})},
+            {"%1 = OpTypeUntypedPointerKHR Workgroup\n",
+             MakeInstruction(spv::Op::OpTypeUntypedPointerKHR,
+                             {1, int(spv::StorageClass::Workgroup)})},
+            {"%2 = OpUntypedVariableKHR %1 Workgroup %3\n",
+             MakeInstruction(spv::Op::OpUntypedVariableKHR,
+                             {1, 2, int(spv::StorageClass::Workgroup), 3})},
+            {"%2 = OpUntypedVariableKHR %1 Workgroup %3 %4\n",
+             MakeInstruction(spv::Op::OpUntypedVariableKHR,
+                             {1, 2, int(spv::StorageClass::Workgroup), 3, 4})},
+            {"%2 = OpUntypedAccessChainKHR %1 %3 %4\n",
+             MakeInstruction(spv::Op::OpUntypedAccessChainKHR, {1, 2, 3, 4})},
+            {"%2 = OpUntypedAccessChainKHR %1 %3 %4 %5 %6 %7\n",
+             MakeInstruction(spv::Op::OpUntypedAccessChainKHR,
+                             {1, 2, 3, 4, 5, 6, 7})},
+            {"%2 = OpUntypedInBoundsAccessChainKHR %1 %3 %4\n",
+             MakeInstruction(spv::Op::OpUntypedInBoundsAccessChainKHR,
+                             {1, 2, 3, 4})},
+            {"%2 = OpUntypedInBoundsAccessChainKHR %1 %3 %4 %5 %6 %7\n",
+             MakeInstruction(spv::Op::OpUntypedInBoundsAccessChainKHR,
+                             {1, 2, 3, 4, 5, 6, 7})},
+            {"%2 = OpUntypedPtrAccessChainKHR %1 %3 %4 %5\n",
+             MakeInstruction(spv::Op::OpUntypedPtrAccessChainKHR,
+                             {1, 2, 3, 4, 5})},
+            {"%2 = OpUntypedPtrAccessChainKHR %1 %3 %4 %5 %6 %7\n",
+             MakeInstruction(spv::Op::OpUntypedPtrAccessChainKHR,
+                             {1, 2, 3, 4, 5, 6, 7})},
+            {"%2 = OpUntypedInBoundsPtrAccessChainKHR %1 %3 %4 %5\n",
+             MakeInstruction(spv::Op::OpUntypedInBoundsPtrAccessChainKHR,
+                             {1, 2, 3, 4, 5})},
+            {"%2 = OpUntypedInBoundsPtrAccessChainKHR %1 %3 %4 %5 %6 %7\n",
+             MakeInstruction(spv::Op::OpUntypedInBoundsPtrAccessChainKHR,
+                             {1, 2, 3, 4, 5, 6, 7})},
+        })));
+
 }  // namespace
 }  // namespace spvtools
diff --git a/test/text_to_binary.memory_test.cpp b/test/text_to_binary.memory_test.cpp
index 629ab661..43523d18 100644
--- a/test/text_to_binary.memory_test.cpp
+++ b/test/text_to_binary.memory_test.cpp
@@ -107,7 +107,8 @@ TEST_F(MemoryRoundTripTest, OpPtrEqualGood) {
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_4),
               Eq(MakeInstruction(spv::Op::OpPtrEqual, {1, 2, 3, 4})));
   std::string disassembly = EncodeAndDecodeSuccessfully(
-      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_ENV_UNIVERSAL_1_4);
+      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_TEXT_TO_BINARY_OPTION_NONE,
+      SPV_ENV_UNIVERSAL_1_4);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -124,7 +125,8 @@ TEST_F(MemoryRoundTripTest, OpPtrNotEqualGood) {
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_4),
               Eq(MakeInstruction(spv::Op::OpPtrNotEqual, {1, 2, 3, 4})));
   std::string disassembly = EncodeAndDecodeSuccessfully(
-      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_ENV_UNIVERSAL_1_4);
+      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_TEXT_TO_BINARY_OPTION_NONE,
+      SPV_ENV_UNIVERSAL_1_4);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -141,7 +143,8 @@ TEST_F(MemoryRoundTripTest, OpPtrDiffGood) {
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_4),
               Eq(MakeInstruction(spv::Op::OpPtrDiff, {1, 2, 3, 4})));
   std::string disassembly = EncodeAndDecodeSuccessfully(
-      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_ENV_UNIVERSAL_1_4);
+      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_TEXT_TO_BINARY_OPTION_NONE,
+      SPV_ENV_UNIVERSAL_1_4);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -151,7 +154,8 @@ TEST_F(MemoryRoundTripTest, OpPtrDiffV13Good) {
   // write tests.
   std::string spirv = "%2 = OpPtrDiff %1 %3 %4\n";
   std::string disassembly = EncodeAndDecodeSuccessfully(
-      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_ENV_UNIVERSAL_1_4);
+      spirv, SPV_BINARY_TO_TEXT_OPTION_NONE, SPV_TEXT_TO_BINARY_OPTION_NONE,
+      SPV_ENV_UNIVERSAL_1_4);
 }
 
 // OpCopyMemory
@@ -160,8 +164,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryNoMemAccessGood) {
   std::string spirv = "OpCopyMemory %1 %2\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -182,8 +185,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessNoneGood) {
   std::string spirv = "OpCopyMemory %1 %2 None\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 0})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -191,8 +193,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessVolatileGood) {
   std::string spirv = "OpCopyMemory %1 %2 Volatile\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 1})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -200,8 +201,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessAligned8Good) {
   std::string spirv = "OpCopyMemory %1 %2 Aligned 8\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 2, 8})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -209,8 +209,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessNontemporalGood) {
   std::string spirv = "OpCopyMemory %1 %2 Nontemporal\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 4})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -218,8 +217,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessAvGood) {
   std::string spirv = "OpCopyMemory %1 %2 MakePointerAvailable %3\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 8, 3})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -227,8 +225,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessVisGood) {
   std::string spirv = "OpCopyMemory %1 %2 MakePointerVisible %3\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 16, 3})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -236,8 +233,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessNonPrivateGood) {
   std::string spirv = "OpCopyMemory %1 %2 NonPrivatePointer\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 32})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -248,8 +244,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryAccessMixedGood) {
       "MakePointerVisible|NonPrivatePointer 16 %3 %4\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 63, 16, 3, 4})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -258,8 +253,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryTwoAccessV13Good) {
   // Note: This will assemble but should not validate for SPIR-V 1.3
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_3),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 1, 1})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -267,8 +261,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryTwoAccessV14Good) {
   std::string spirv = "OpCopyMemory %1 %2 Volatile Volatile\n";
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_4),
               Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 1, 1})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -280,8 +273,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemoryTwoAccessMixedV14Good) {
   EXPECT_THAT(
       CompiledInstructions(spirv),
       Eq(MakeInstruction(spv::Op::OpCopyMemory, {1, 2, 21, 3, 42, 16, 4})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -291,8 +283,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedNoMemAccessGood) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -313,8 +304,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessNoneGood) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 None\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 0})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -322,8 +312,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessVolatileGood) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 Volatile\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 1})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -331,8 +320,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessAligned8Good) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 Aligned 8\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 2, 8})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -340,8 +328,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessNontemporalGood) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 Nontemporal\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 4})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -349,8 +336,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessAvGood) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 MakePointerAvailable %4\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 8, 4})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -359,8 +345,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessVisGood) {
   EXPECT_THAT(
       CompiledInstructions(spirv),
       Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 16, 4})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -368,8 +353,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessNonPrivateGood) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 NonPrivatePointer\n";
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 32})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -381,8 +365,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedAccessMixedGood) {
   EXPECT_THAT(
       CompiledInstructions(spirv),
       Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 63, 16, 4, 5})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -391,8 +374,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedTwoAccessV13Good) {
   // Note: This will assemble but should not validate for SPIR-V 1.3
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_3),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 1, 1})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -400,8 +382,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedTwoAccessV14Good) {
   std::string spirv = "OpCopyMemorySized %1 %2 %3 Volatile Volatile\n";
   EXPECT_THAT(CompiledInstructions(spirv, SPV_ENV_UNIVERSAL_1_4),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized, {1, 2, 3, 1, 1})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
@@ -413,8 +394,7 @@ TEST_F(MemoryRoundTripTest, OpCopyMemorySizedTwoAccessMixedV14Good) {
   EXPECT_THAT(CompiledInstructions(spirv),
               Eq(MakeInstruction(spv::Op::OpCopyMemorySized,
                                  {1, 2, 3, 21, 4, 42, 16, 5})));
-  std::string disassembly =
-      EncodeAndDecodeSuccessfully(spirv, SPV_BINARY_TO_TEXT_OPTION_NONE);
+  std::string disassembly = EncodeAndDecodeSuccessfully(spirv);
   EXPECT_THAT(disassembly, Eq(spirv));
 }
 
diff --git a/test/to_string_test.cpp b/test/to_string_test.cpp
new file mode 100644
index 00000000..5973318e
--- /dev/null
+++ b/test/to_string_test.cpp
@@ -0,0 +1,28 @@
+// Copyright (c) 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "source/to_string.h"
+
+#include "gmock/gmock.h"
+
+namespace {
+
+TEST(ToString, Uint32) {
+  EXPECT_EQ(spvtools::to_string(0u), "0");
+  EXPECT_EQ(spvtools::to_string(1u), "1");
+  EXPECT_EQ(spvtools::to_string(1234567890u), "1234567890");
+  EXPECT_EQ(spvtools::to_string(0xffffffffu), "4294967295");
+}
+
+}  // namespace
diff --git a/test/util/bitutils_test.cpp b/test/util/bitutils_test.cpp
index 3be7ed26..aea78976 100644
--- a/test/util/bitutils_test.cpp
+++ b/test/util/bitutils_test.cpp
@@ -188,6 +188,46 @@ TEST(BitUtilsTest, IsBitSetAtPositionAll) {
     EXPECT_TRUE(IsBitAtPositionSet(max_u64, i));
   }
 }
+
+struct ExtendedValueTestCase {
+  uint32_t input;
+  uint32_t bit_width;
+  uint32_t expected_result;
+};
+
+using SignExtendedValueTest = ::testing::TestWithParam<ExtendedValueTestCase>;
+
+TEST_P(SignExtendedValueTest, SignExtendValue) {
+  const auto& tc = GetParam();
+  auto result = SignExtendValue(tc.input, tc.bit_width);
+  EXPECT_EQ(result, tc.expected_result);
+}
+INSTANTIATE_TEST_SUITE_P(
+    SignExtendValue, SignExtendedValueTest,
+    ::testing::Values(ExtendedValueTestCase{1, 1, 0xFFFFFFFF},
+                      ExtendedValueTestCase{1, 2, 0x1},
+                      ExtendedValueTestCase{2, 1, 0x0},
+                      ExtendedValueTestCase{0x8, 4, 0xFFFFFFF8},
+                      ExtendedValueTestCase{0x8765, 16, 0xFFFF8765},
+                      ExtendedValueTestCase{0x7765, 16, 0x7765},
+                      ExtendedValueTestCase{0xDEADBEEF, 32, 0xDEADBEEF}));
+
+using ZeroExtendedValueTest = ::testing::TestWithParam<ExtendedValueTestCase>;
+
+TEST_P(ZeroExtendedValueTest, ZeroExtendValue) {
+  const auto& tc = GetParam();
+  auto result = ZeroExtendValue(tc.input, tc.bit_width);
+  EXPECT_EQ(result, tc.expected_result);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ZeroExtendValue, ZeroExtendedValueTest,
+    ::testing::Values(ExtendedValueTestCase{1, 1, 0x1},
+                      ExtendedValueTestCase{1, 2, 0x1},
+                      ExtendedValueTestCase{2, 1, 0x0},
+                      ExtendedValueTestCase{0x8, 4, 0x8},
+                      ExtendedValueTestCase{0xFF8765, 16, 0x8765},
+                      ExtendedValueTestCase{0xDEADBEEF, 32, 0xDEADBEEF}));
 }  // namespace
 }  // namespace utils
 }  // namespace spvtools
diff --git a/test/val/CMakeLists.txt b/test/val/CMakeLists.txt
index 62d93bdd..9d6f6ea6 100644
--- a/test/val/CMakeLists.txt
+++ b/test/val/CMakeLists.txt
@@ -46,6 +46,7 @@ add_spvtools_unittest(TARGET val_abcde
        val_extension_spv_khr_bit_instructions_test.cpp
        val_extension_spv_khr_terminate_invocation_test.cpp
        val_extension_spv_khr_subgroup_rotate_test.cpp
+       val_extension_spv_nv_raw_access_chains.cpp
        val_ext_inst_test.cpp
        val_ext_inst_debug_test.cpp
        ${VAL_TEST_COMMON_SRCS}
diff --git a/test/val/val_annotation_test.cpp b/test/val/val_annotation_test.cpp
index 97dde2df..e4a94749 100644
--- a/test/val/val_annotation_test.cpp
+++ b/test/val/val_annotation_test.cpp
@@ -230,6 +230,49 @@ OpFunctionEnd
           "FPFastMathMode and NoContraction cannot decorate the same target"));
 }
 
+TEST_F(DecorationTest, RestrictOnUntypedPointer) {
+  const std::string text = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpCapability SampleRateShading
+OpCapability TransformFeedback
+OpCapability GeometryStreams
+OpCapability Tessellation
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpDecorate %param Restrict
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void = OpTypeVoid
+%f_ty = OpTypeFunction %void %ptr
+%f = OpFunction %void None %f_ty
+%param = OpFunctionParameter %ptr
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(text);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(DecorationTest, ArrayStrideUntypedPointerKHR) {
+  const std::string text = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpDecorate %ptr ArrayStride 4
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+)";
+
+  CompileSuccessfully(text);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
 using MemberOnlyDecorations = spvtest::ValidateBase<std::string>;
 
 TEST_P(MemberOnlyDecorations, MemberDecoration) {
diff --git a/test/val/val_arithmetics_test.cpp b/test/val/val_arithmetics_test.cpp
index 58ac4423..8b2a8d0b 100644
--- a/test/val/val_arithmetics_test.cpp
+++ b/test/val/val_arithmetics_test.cpp
@@ -1280,14 +1280,14 @@ TEST_F(ValidateArithmetics, CoopMatMatrixTimesScalarMismatchFail) {
 
 TEST_F(ValidateArithmetics, CoopMatScopeFail) {
   const std::string types = R"(
-%workgroup = OpConstant %u32 2
+%device = OpConstant %u32 1
 
-%mat16x16_wg = OpTypeCooperativeMatrixNV %f16 %workgroup %u32_16 %u32_16
-%f16matwg_16x16_1 = OpConstantComposite %mat16x16_wg %f16_1
+%mat16x16_dv = OpTypeCooperativeMatrixNV %f16 %device %u32_16 %u32_16
+%f16matdv_16x16_1 = OpConstantComposite %mat16x16_dv %f16_1
 )";
 
   const std::string body = R"(
-%val1 = OpCooperativeMatrixMulAddNV %mat16x16 %f16mat_16x4_1 %f16mat_4x16_1 %f16matwg_16x16_1
+%val1 = OpCooperativeMatrixMulAddNV %mat16x16 %f16mat_16x4_1 %f16mat_4x16_1 %f16matdv_16x16_1
 )";
 
   CompileSuccessfully(GenerateCoopMatCode(types, body).c_str());
@@ -1475,7 +1475,10 @@ std::string GenerateCoopMatKHRCode(const std::string& extra_types,
 OpCapability Shader
 OpCapability Float16
 OpCapability CooperativeMatrixKHR
+OpCapability CooperativeMatrixReductionsNV
+OpCapability CooperativeMatrixPerElementOperationsNV
 OpExtension "SPV_KHR_cooperative_matrix"
+OpExtension "SPV_NV_cooperative_matrix2"
 OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical GLSL450
 OpEntryPoint GLCompute %main "main"
@@ -1487,6 +1490,7 @@ OpEntryPoint GLCompute %main "main"
 %u32 = OpTypeInt 32 0
 %s32 = OpTypeInt 32 1
 
+%u32_8 = OpConstant %u32 8
 %u32_16 = OpConstant %u32 16
 %u32_4 = OpConstant %u32 4
 %subgroup = OpConstant %u32 3
@@ -1579,13 +1583,13 @@ TEST_F(ValidateArithmetics, CoopMatMatrixKHRTimesScalarMismatchFail) {
 
 TEST_F(ValidateArithmetics, CoopMatKHRScopeFail) {
   const std::string types = R"(
-%workgroup = OpConstant %u32 2
-%mat16x16_wg = OpTypeCooperativeMatrixKHR %f16 %workgroup %u32_16 %u32_16 %useC
-%f16matwg_16x16_1 = OpConstantComposite %mat16x16_wg %f16_1
+%device = OpConstant %u32 1
+%mat16x16_dv = OpTypeCooperativeMatrixKHR %f16 %device %u32_16 %u32_16 %useC
+%f16matdv_16x16_1 = OpConstantComposite %mat16x16_dv %f16_1
 )";
 
   const std::string body = R"(
-%val1 = OpFAdd %f16matA %f16matwg_16x16_1 %f16mat_A_1
+%val1 = OpFAdd %f16matA %f16matdv_16x16_1 %f16mat_A_1
 )";
 
   CompileSuccessfully(GenerateCoopMatKHRCode(types, body).c_str());
@@ -1612,6 +1616,241 @@ TEST_F(ValidateArithmetics, CoopMatKHRDimFail) {
       HasSubstr("Cooperative matrix 'N' mismatch: CooperativeMatrixMulAddKHR"));
 }
 
+TEST_F(ValidateArithmetics, CoopMat2ReduceSuccess) {
+  const std::string extra_types = R"(
+
+%f16matC8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_8 %useC
+%f16matC16x8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_16 %u32_8 %useC
+%f16matC8x16 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_16 %useC
+
+%functy = OpTypeFunction %f16 %f16 %f16
+%reducefunc = OpFunction %f16 None %functy
+%x =  OpFunctionParameter %f16
+%y =  OpFunctionParameter %f16
+%entry2 = OpLabel
+%sum = OpFAdd %f16 %x %y
+OpReturnValue %sum
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixReduceNV %f16matC8 %f16mat_C_1 2x2 %reducefunc
+%val2 = OpCooperativeMatrixReduceNV %f16matC16x8 %f16mat_C_1 Row %reducefunc
+%val3 = OpCooperativeMatrixReduceNV %f16matC8x16 %f16mat_C_1 Column %reducefunc
+%val4 = OpCooperativeMatrixReduceNV %f16matC %f16mat_C_1 Row|Column %reducefunc
+%val5 = OpCooperativeMatrixReduceNV %f16matC8 %f16mat_C_1 Row|Column %reducefunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateArithmetics, CoopMat2Reduce2x2DimFail) {
+  const std::string extra_types = R"(
+
+%functy = OpTypeFunction %f16 %f16 %f16
+%reducefunc = OpFunction %f16 None %functy
+%x =  OpFunctionParameter %f16
+%y =  OpFunctionParameter %f16
+%entry2 = OpLabel
+%sum = OpFAdd %f16 %x %y
+OpReturnValue %sum
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixReduceNV %f16matC %f16mat_C_1 2x2 %reducefunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("For Reduce2x2, result rows/cols must be half of "
+                        "matrix rows/cols: CooperativeMatrixReduceNV"));
+}
+
+TEST_F(ValidateArithmetics, CoopMat2ReduceRowDimFail) {
+  const std::string extra_types = R"(
+
+%f16matC8x16 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_16 %useC
+
+%functy = OpTypeFunction %f16 %f16 %f16
+%reducefunc = OpFunction %f16 None %functy
+%x =  OpFunctionParameter %f16
+%y =  OpFunctionParameter %f16
+%entry2 = OpLabel
+%sum = OpFAdd %f16 %x %y
+OpReturnValue %sum
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixReduceNV %f16matC8x16 %f16mat_C_1 Row %reducefunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("For ReduceRow, result rows must match matrix rows: "
+                        "CooperativeMatrixReduceNV"));
+}
+
+TEST_F(ValidateArithmetics, CoopMat2ReduceColDimFail) {
+  const std::string extra_types = R"(
+
+%f16matC16x8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_16 %u32_8 %useC
+
+%functy = OpTypeFunction %f16 %f16 %f16
+%reducefunc = OpFunction %f16 None %functy
+%x =  OpFunctionParameter %f16
+%y =  OpFunctionParameter %f16
+%entry2 = OpLabel
+%sum = OpFAdd %f16 %x %y
+OpReturnValue %sum
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixReduceNV %f16matC16x8 %f16mat_C_1 Column %reducefunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("For ReduceColumn, result cols must match matrix cols: "
+                        "CooperativeMatrixReduceNV"));
+}
+
+TEST_F(ValidateArithmetics, CoopMat2ReduceMaskFail) {
+  const std::string extra_types = R"(
+
+%f16matC8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_8 %useC
+
+%functy = OpTypeFunction %f16 %f16 %f16
+%reducefunc = OpFunction %f16 None %functy
+%x =  OpFunctionParameter %f16
+%y =  OpFunctionParameter %f16
+%entry2 = OpLabel
+%sum = OpFAdd %f16 %x %y
+OpReturnValue %sum
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixReduceNV %f16matC8 %f16mat_C_1 Row|Column|2x2 %reducefunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Reduce 2x2 must not be used with Row/Column: "
+                        "CooperativeMatrixReduceNV"));
+}
+
+TEST_F(ValidateArithmetics, CoopMat2ReduceFuncTypeFail) {
+  const std::string extra_types = R"(
+
+%functy = OpTypeFunction %f32 %f32 %f32
+%reducefunc = OpFunction %f32 None %functy
+%x =  OpFunctionParameter %f32
+%y =  OpFunctionParameter %f32
+%entry2 = OpLabel
+%sum = OpFAdd %f32 %x %y
+OpReturnValue %sum
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixReduceNV %f16matC %f16mat_C_1 Row|Column %reducefunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("CombineFunc return type and parameters must match "
+                        "matrix component type: CooperativeMatrixReduceNV"));
+}
+
+TEST_F(ValidateArithmetics, CoopMat2PerElementOpSuccess) {
+  const std::string extra_types = R"(
+
+%functy = OpTypeFunction %f16 %u32 %u32 %f16
+%functy2 = OpTypeFunction %f16 %u32 %u32 %f16 %u32
+
+%elemfunc = OpFunction %f16 None %functy
+%row =  OpFunctionParameter %u32
+%col =  OpFunctionParameter %u32
+%el =  OpFunctionParameter %f16
+%entry2 = OpLabel
+OpReturnValue %el
+OpFunctionEnd
+
+%elemfunc2 = OpFunction %f16 None %functy2
+%row2 =  OpFunctionParameter %u32
+%col2 =  OpFunctionParameter %u32
+%el2 =  OpFunctionParameter %f16
+%x =  OpFunctionParameter %u32
+%entry3 = OpLabel
+OpReturnValue %el2
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixPerElementOpNV %f16matC %f16mat_C_1 %elemfunc
+%val2 = OpCooperativeMatrixPerElementOpNV %f16matC %f16mat_C_1 %elemfunc2 %f16_1
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateArithmetics, CoopMat2PerElementOpElemTyFail) {
+  const std::string extra_types = R"(
+
+%functy = OpTypeFunction %f32 %u32 %u32 %f32
+
+%elemfunc = OpFunction %f32 None %functy
+%row =  OpFunctionParameter %u32
+%col =  OpFunctionParameter %u32
+%el =  OpFunctionParameter %f32
+%entry2 = OpLabel
+OpReturnValue %el
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixPerElementOpNV %f16matC %f16mat_C_1 %elemfunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must match matrix component type"));
+}
+
+TEST_F(ValidateArithmetics, CoopMat2PerElementOpRowTyFail) {
+  const std::string extra_types = R"(
+
+%functy = OpTypeFunction %f16 %f16 %u32 %f16
+
+%elemfunc = OpFunction %f16 None %functy
+%row =  OpFunctionParameter %f16
+%col =  OpFunctionParameter %u32
+%el =  OpFunctionParameter %f16
+%entry2 = OpLabel
+OpReturnValue %el
+OpFunctionEnd
+
+  )";
+  const std::string body = R"(
+%val1 = OpCooperativeMatrixPerElementOpNV %f16matC %f16mat_C_1 %elemfunc
+)";
+
+  CompileSuccessfully(GenerateCoopMatKHRCode(extra_types, body).c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("must be a 32-bit integer"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_atomics_test.cpp b/test/val/val_atomics_test.cpp
index b266ad66..1cec51eb 100644
--- a/test/val/val_atomics_test.cpp
+++ b/test/val/val_atomics_test.cpp
@@ -318,7 +318,8 @@ TEST_F(ValidateAtomics, AtomicAddFloatVulkan) {
   EXPECT_THAT(
       getDiagnosticString(),
       HasSubstr("Opcode AtomicFAddEXT requires one of these capabilities: "
-                "AtomicFloat32AddEXT AtomicFloat64AddEXT AtomicFloat16AddEXT"));
+                "AtomicFloat16VectorNV AtomicFloat32AddEXT AtomicFloat64AddEXT "
+                "AtomicFloat16AddEXT"));
 }
 
 TEST_F(ValidateAtomics, AtomicMinFloatVulkan) {
@@ -331,7 +332,8 @@ TEST_F(ValidateAtomics, AtomicMinFloatVulkan) {
   EXPECT_THAT(
       getDiagnosticString(),
       HasSubstr("Opcode AtomicFMinEXT requires one of these capabilities: "
-                "AtomicFloat32MinMaxEXT AtomicFloat64MinMaxEXT AtomicFloat16MinMaxEXT"));
+                "AtomicFloat16VectorNV AtomicFloat32MinMaxEXT "
+                "AtomicFloat64MinMaxEXT AtomicFloat16MinMaxEXT"));
 }
 
 TEST_F(ValidateAtomics, AtomicMaxFloatVulkan) {
@@ -343,8 +345,10 @@ TEST_F(ValidateAtomics, AtomicMaxFloatVulkan) {
   ASSERT_EQ(SPV_ERROR_INVALID_CAPABILITY, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
-      HasSubstr("Opcode AtomicFMaxEXT requires one of these capabilities: "
-                "AtomicFloat32MinMaxEXT AtomicFloat64MinMaxEXT AtomicFloat16MinMaxEXT"));
+      HasSubstr(
+          "Opcode AtomicFMaxEXT requires one of these capabilities: "
+          "AtomicFloat16VectorNV AtomicFloat32MinMaxEXT AtomicFloat64MinMaxEXT "
+          "AtomicFloat16MinMaxEXT"));
 }
 
 TEST_F(ValidateAtomics, AtomicAddFloatVulkanWrongType1) {
@@ -1138,9 +1142,8 @@ OpAtomicStore %f32_1 %device %relaxed %f32_1
 
   CompileSuccessfully(GenerateKernelCode(body));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
-  EXPECT_THAT(
-      getDiagnosticString(),
-      HasSubstr("AtomicStore: expected Pointer to be of type OpTypePointer"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("AtomicStore: expected Pointer to be a pointer type"));
 }
 
 TEST_F(ValidateAtomics, AtomicStoreWrongPointerDataType) {
@@ -1603,7 +1606,7 @@ TEST_F(ValidateAtomics, AtomicFlagTestAndSetNotPointer) {
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("AtomicFlagTestAndSet: "
-                        "expected Pointer to be of type OpTypePointer"));
+                        "expected Pointer to be a pointer type"));
 }
 
 TEST_F(ValidateAtomics, AtomicFlagTestAndSetNotIntPointer) {
@@ -1677,7 +1680,7 @@ OpAtomicFlagClear %u32_1 %device %relaxed
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("AtomicFlagClear: "
-                        "expected Pointer to be of type OpTypePointer"));
+                        "expected Pointer to be a pointer type"));
 }
 
 TEST_F(ValidateAtomics, AtomicFlagClearNotIntPointer) {
@@ -2713,6 +2716,255 @@ TEST_F(ValidateAtomics, IIncrementBadPointerDataType) {
                         "value of type Result Type"));
 }
 
+TEST_F(ValidateAtomics, AtomicFloat16VectorSuccess) {
+  const std::string definitions = R"(
+%f16 = OpTypeFloat 16
+%f16vec2 = OpTypeVector %f16 2
+%f16vec4 = OpTypeVector %f16 4
+
+%f16_1 = OpConstant %f16 1
+%f16vec2_1 = OpConstantComposite %f16vec2 %f16_1 %f16_1
+%f16vec4_1 = OpConstantComposite %f16vec4 %f16_1 %f16_1 %f16_1 %f16_1
+
+%f16vec2_ptr = OpTypePointer Workgroup %f16vec2
+%f16vec4_ptr = OpTypePointer Workgroup %f16vec4
+%f16vec2_var = OpVariable %f16vec2_ptr Workgroup
+%f16vec4_var = OpVariable %f16vec4_ptr Workgroup
+)";
+
+  const std::string body = R"(
+%val3 = OpAtomicFMinEXT %f16vec2 %f16vec2_var %device %relaxed %f16vec2_1
+%val4 = OpAtomicFMaxEXT %f16vec2 %f16vec2_var %device %relaxed %f16vec2_1
+%val8 = OpAtomicFAddEXT %f16vec2 %f16vec2_var %device %relaxed %f16vec2_1
+%val9 = OpAtomicExchange %f16vec2 %f16vec2_var %device %relaxed %f16vec2_1
+
+%val11 = OpAtomicFMinEXT %f16vec4 %f16vec4_var %device %relaxed %f16vec4_1
+%val12 = OpAtomicFMaxEXT %f16vec4 %f16vec4_var %device %relaxed %f16vec4_1
+%val18 = OpAtomicFAddEXT %f16vec4 %f16vec4_var %device %relaxed %f16vec4_1
+%val19 = OpAtomicExchange %f16vec4 %f16vec4_var %device %relaxed %f16vec4_1
+
+)";
+
+  CompileSuccessfully(GenerateShaderComputeCode(
+                          body,
+                          "OpCapability Float16\n"
+                          "OpCapability AtomicFloat16VectorNV\n"
+                          "OpExtension \"SPV_NV_shader_atomic_fp16_vector\"\n",
+                          definitions),
+                      SPV_ENV_VULKAN_1_0);
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+}
+
+static constexpr char Float16Vector3Defs[] = R"(
+%f16 = OpTypeFloat 16
+%f16vec3 = OpTypeVector %f16 3
+
+%f16_1 = OpConstant %f16 1
+%f16vec3_1 = OpConstantComposite %f16vec3 %f16_1 %f16_1 %f16_1
+
+%f16vec3_ptr = OpTypePointer Workgroup %f16vec3
+%f16vec3_var = OpVariable %f16vec3_ptr Workgroup
+)";
+
+TEST_F(ValidateAtomics, AtomicFloat16Vector3MinFail) {
+  const std::string definitions = Float16Vector3Defs;
+
+  const std::string body = R"(
+%val11 = OpAtomicFMinEXT %f16vec3 %f16vec3_var %device %relaxed %f16vec3_1
+)";
+
+  CompileSuccessfully(GenerateShaderComputeCode(
+                          body,
+                          "OpCapability Float16\n"
+                          "OpCapability AtomicFloat16VectorNV\n"
+                          "OpExtension \"SPV_NV_shader_atomic_fp16_vector\"\n",
+                          definitions),
+                      SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("AtomicFMinEXT: expected Result Type to be float scalar type"));
+}
+
+TEST_F(ValidateAtomics, AtomicFloat16Vector3MaxFail) {
+  const std::string definitions = Float16Vector3Defs;
+
+  const std::string body = R"(
+%val12 = OpAtomicFMaxEXT %f16vec3 %f16vec3_var %device %relaxed %f16vec3_1
+)";
+
+  CompileSuccessfully(GenerateShaderComputeCode(
+                          body,
+                          "OpCapability Float16\n"
+                          "OpCapability AtomicFloat16VectorNV\n"
+                          "OpExtension \"SPV_NV_shader_atomic_fp16_vector\"\n",
+                          definitions),
+                      SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("AtomicFMaxEXT: expected Result Type to be float scalar type"));
+}
+
+TEST_F(ValidateAtomics, AtomicFloat16Vector3AddFail) {
+  const std::string definitions = Float16Vector3Defs;
+
+  const std::string body = R"(
+%val18 = OpAtomicFAddEXT %f16vec3 %f16vec3_var %device %relaxed %f16vec3_1
+)";
+
+  CompileSuccessfully(GenerateShaderComputeCode(
+                          body,
+                          "OpCapability Float16\n"
+                          "OpCapability AtomicFloat16VectorNV\n"
+                          "OpExtension \"SPV_NV_shader_atomic_fp16_vector\"\n",
+                          definitions),
+                      SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("AtomicFAddEXT: expected Result Type to be float scalar type"));
+}
+
+TEST_F(ValidateAtomics, AtomicFloat16Vector3ExchangeFail) {
+  const std::string definitions = Float16Vector3Defs;
+
+  const std::string body = R"(
+%val19 = OpAtomicExchange %f16vec3 %f16vec3_var %device %relaxed %f16vec3_1
+)";
+
+  CompileSuccessfully(GenerateShaderComputeCode(
+                          body,
+                          "OpCapability Float16\n"
+                          "OpCapability AtomicFloat16VectorNV\n"
+                          "OpExtension \"SPV_NV_shader_atomic_fp16_vector\"\n",
+                          definitions),
+                      SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("AtomicExchange: expected Result Type to be integer or "
+                        "float scalar type"));
+}
+
+TEST_F(ValidateAtomics, AtomicLoadUntypedPointer) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int_1 = OpConstant %int 1
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%load = OpAtomicLoad %int %var %int_1 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateAtomics, AtomicStoreUntypedPointer) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int_1 = OpConstant %int 1
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpAtomicStore %var %int_1 %int_0 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateAtomics, AtomicExchangeUntypedPointer) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int_1 = OpConstant %int 1
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%ex = OpAtomicExchange %int %var %int_1 %int_0 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateAtomics, AtomicFlagClearUntypedPointer) {
+  const std::string spirv = R"(
+OpCapability Kernel
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical OpenCL
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int_1 = OpConstant %int 1
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpAtomicFlagClear %var %int_1 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Untyped pointers are not supported by atomic flag instructions"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_cfg_test.cpp b/test/val/val_cfg_test.cpp
index 233aee64..ae2e45bb 100644
--- a/test/val/val_cfg_test.cpp
+++ b/test/val/val_cfg_test.cpp
@@ -5118,6 +5118,129 @@ OpFunctionEnd
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
+TEST_F(ValidateCFG, StructurallyUnreachableContinuePredecessor) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main"
+               OpExecutionMode %main OriginUpperLeft
+               OpSource ESSL 310
+               OpName %main "main"
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+        %int = OpTypeInt 32 1
+      %int_1 = OpConstant %int 1
+     %int_n7 = OpConstant %int -7
+       %bool = OpTypeBool
+       %main = OpFunction %void None %3
+          %8 = OpLabel
+               OpBranch %9
+          %9 = OpLabel
+         %10 = OpPhi %int %int_1 %8 %int_n7 %15
+         %12 = OpSGreaterThan %bool %10 %int_n7
+               OpLoopMerge %13 %15 None
+               OpBranchConditional %12 %14 %13
+         %14 = OpLabel
+               OpBranch %15
+         %15 = OpLabel
+               OpBranch %9
+         %17 = OpLabel
+               OpBranch %15
+         %13 = OpLabel
+               OpReturn
+               OpFunctionEnd
+)";
+
+  CompileSuccessfully(text);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateCFG, FullyLoopPrecedingSwitchToContinue) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main"
+               OpExecutionMode %main OriginUpperLeft
+               OpName %main "main"
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %bool = OpTypeBool
+       %true = OpConstantTrue %bool
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+      %int_1 = OpConstant %int 1
+       %main = OpFunction %void None %3
+          %4 = OpLabel
+               OpBranch %7
+          %7 = OpLabel
+               OpLoopMerge %8 %6 None
+               OpBranch %5
+          %5 = OpLabel
+               OpSelectionMerge %9 None
+               OpBranchConditional %true %10 %9
+         %10 = OpLabel
+               OpSelectionMerge %16 None
+               OpSwitch %int_0 %13
+         %13 = OpLabel
+               OpBranch %19
+         %19 = OpLabel
+               OpLoopMerge %20 %18 None
+               OpBranch %17
+         %17 = OpLabel
+               OpReturn
+         %18 = OpLabel
+               OpBranch %19
+         %20 = OpLabel
+               OpSelectionMerge %23 None
+               OpSwitch %int_1 %21
+         %21 = OpLabel
+               OpBranch %6
+         %23 = OpLabel
+               OpBranch %16
+         %16 = OpLabel
+               OpBranch %9
+          %9 = OpLabel
+               OpBranch %6
+          %6 = OpLabel
+               OpBranch %7
+          %8 = OpLabel
+               OpUnreachable
+               OpFunctionEnd
+)";
+
+  CompileSuccessfully(text);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateCFG, CaseBreak) {
+  const std::string text = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main"
+OpExecutionMode %main OriginUpperLeft
+OpName %main "main"
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%bool = OpTypeBool
+%true = OpConstantTrue %bool
+%int = OpTypeInt 32 1
+%int_0 = OpConstant %int 0
+%int_1 = OpConstant %int 1
+%main = OpFunction %void None %3
+%4 = OpLabel
+OpSelectionMerge %merge None
+OpSwitch %int_1 %case 2 %merge
+%case = OpLabel
+OpBranch %merge
+%merge = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(text);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_conversion_test.cpp b/test/val/val_conversion_test.cpp
index 0128aa1f..3869626e 100644
--- a/test/val/val_conversion_test.cpp
+++ b/test/val/val_conversion_test.cpp
@@ -1338,11 +1338,11 @@ OpEntryPoint GLCompute %main "main"
 %u32_8 = OpConstant %u32 8
 %u32_4 = OpConstant %u32 4
 %subgroup = OpConstant %u32 3
-%workgroup = OpConstant %u32 2
+%device = OpConstant %u32 1
 %use_A = OpConstant %u32 0
 
 %f16mat = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_8 %use_A
-%f32mat = OpTypeCooperativeMatrixKHR %f32 %workgroup %u32_8 %u32_8 %use_A
+%f32mat = OpTypeCooperativeMatrixKHR %f32 %device %u32_8 %u32_8 %use_A
 
 %f16_1 = OpConstant %f16 1
 
@@ -1940,6 +1940,64 @@ OpExtension "SPV_KHR_ray_query"
                         "uint vector as input"));
 }
 
+TEST_F(ValidateConversion, BitcastUntypedPointerInput) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%cast = OpBitcast %int %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateConversion, BitcastUntypedPointerOutput) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%cast = OpBitcast %ptr %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
 using ValidateSmallConversions = spvtest::ValidateBase<std::string>;
 
 CodeGenerator GetSmallConversionsCodeGenerator() {
@@ -2082,6 +2140,192 @@ INSTANTIATE_TEST_SUITE_P(SmallConversionInstructions, ValidateSmallConversions,
                                 "%inst = OpBitcast %short %ld_half",
                                 "%inst = OpBitcast %short2 %ld_half2"));
 
+TEST_F(ValidateConversion, CoopMat2ConversionSuccess) {
+  const std::string body = R"(
+OpCapability Shader
+OpCapability Float16
+OpCapability Int16
+OpCapability CooperativeMatrixConversionsNV
+OpCapability CooperativeMatrixKHR
+OpExtension "SPV_KHR_cooperative_matrix"
+OpExtension "SPV_NV_cooperative_matrix2"
+OpExtension "SPV_KHR_vulkan_memory_model"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+%void = OpTypeVoid
+%func = OpTypeFunction %void
+%bool = OpTypeBool
+%f16 = OpTypeFloat 16
+%f32 = OpTypeFloat 32
+%u16 = OpTypeInt 16 0
+%u32 = OpTypeInt 32 0
+%s16 = OpTypeInt 16 1
+%s32 = OpTypeInt 32 1
+
+%u32_8 = OpConstant %u32 8
+%u32_16 = OpConstant %u32 16
+%use_A = OpConstant %u32 0
+%use_B = OpConstant %u32 1
+%use_Acc = OpConstant %u32 2
+%subgroup = OpConstant %u32 3
+
+%f16matA = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_8 %use_A
+%f32matA = OpTypeCooperativeMatrixKHR %f32 %subgroup %u32_8 %u32_8 %use_A
+%u16matA = OpTypeCooperativeMatrixKHR %u16 %subgroup %u32_8 %u32_8 %use_A
+%u32matA = OpTypeCooperativeMatrixKHR %u32 %subgroup %u32_8 %u32_8 %use_A
+%s16matA = OpTypeCooperativeMatrixKHR %s16 %subgroup %u32_8 %u32_8 %use_A
+%s32matA = OpTypeCooperativeMatrixKHR %s32 %subgroup %u32_8 %u32_8 %use_A
+
+%f16matB = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_8 %use_B
+%f32matB = OpTypeCooperativeMatrixKHR %f32 %subgroup %u32_8 %u32_8 %use_B
+%u16matB = OpTypeCooperativeMatrixKHR %u16 %subgroup %u32_8 %u32_8 %use_B
+%u32matB = OpTypeCooperativeMatrixKHR %u32 %subgroup %u32_8 %u32_8 %use_B
+%s16matB = OpTypeCooperativeMatrixKHR %s16 %subgroup %u32_8 %u32_8 %use_B
+%s32matB = OpTypeCooperativeMatrixKHR %s32 %subgroup %u32_8 %u32_8 %use_B
+
+%f16matAcc = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_8 %use_Acc
+%f32matAcc = OpTypeCooperativeMatrixKHR %f32 %subgroup %u32_8 %u32_8 %use_Acc
+%u16matAcc = OpTypeCooperativeMatrixKHR %u16 %subgroup %u32_8 %u32_8 %use_Acc
+%u32matAcc = OpTypeCooperativeMatrixKHR %u32 %subgroup %u32_8 %u32_8 %use_Acc
+%s16matAcc = OpTypeCooperativeMatrixKHR %s16 %subgroup %u32_8 %u32_8 %use_Acc
+%s32matAcc = OpTypeCooperativeMatrixKHR %s32 %subgroup %u32_8 %u32_8 %use_Acc
+
+%f16matAcc16x8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_16 %u32_8 %use_Acc
+%f16matB8x16 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_8 %u32_16 %use_B
+
+%f16_1 = OpConstant %f16 1
+%f32_1 = OpConstant %f32 1
+%u16_1 = OpConstant %u16 1
+%u32_1 = OpConstant %u32 1
+%s16_1 = OpConstant %s16 1
+%s32_1 = OpConstant %s32 1
+
+%f16matAcc_1 = OpConstantComposite %f16matAcc %f16_1
+%f32matAcc_1 = OpConstantComposite %f32matAcc %f32_1
+%u16matAcc_1 = OpConstantComposite %u16matAcc %u16_1
+%u32matAcc_1 = OpConstantComposite %u32matAcc %u32_1
+%s16matAcc_1 = OpConstantComposite %s16matAcc %s16_1
+%s32matAcc_1 = OpConstantComposite %s32matAcc %s32_1
+
+%f16matAcc16x8_1 = OpConstantComposite %f16matAcc16x8 %f16_1
+
+%main = OpFunction %void None %func
+%main_entry = OpLabel
+
+%val11A = OpConvertFToU %u16matA %f16matAcc_1
+%val12A = OpConvertFToU %u32matA %f16matAcc_1
+%val13A = OpConvertFToS %s16matA %f16matAcc_1
+%val14A = OpConvertFToS %s32matA %f16matAcc_1
+%val15A = OpFConvert %f32matA %f16matAcc_1
+
+%val11B = OpConvertFToU %u16matB %f16matAcc_1
+%val12B = OpConvertFToU %u32matB %f16matAcc_1
+%val13B = OpConvertFToS %s16matB %f16matAcc_1
+%val14B = OpConvertFToS %s32matB %f16matAcc_1
+%val15B = OpFConvert %f32matB %f16matAcc_1
+
+%val21A = OpConvertFToU %u16matA %f32matAcc_1
+%val22A = OpConvertFToU %u32matA %f32matAcc_1
+%val23A = OpConvertFToS %s16matA %f32matAcc_1
+%val24A = OpConvertFToS %s32matA %f32matAcc_1
+%val25A = OpFConvert %f16matA %f32matAcc_1
+
+%val21B = OpConvertFToU %u16matB %f32matAcc_1
+%val22B = OpConvertFToU %u32matB %f32matAcc_1
+%val23B = OpConvertFToS %s16matB %f32matAcc_1
+%val24B = OpConvertFToS %s32matB %f32matAcc_1
+%val25B = OpFConvert %f16matB %f32matAcc_1
+
+%val31A = OpConvertUToF %f16matA %u16matAcc_1
+%val32A = OpConvertUToF %f32matA %u16matAcc_1
+%val33A = OpUConvert %u32matA %u16matAcc_1
+%val34A = OpSConvert %s32matA %u16matAcc_1
+
+%val31B = OpConvertUToF %f16matB %u16matAcc_1
+%val32B = OpConvertUToF %f32matB %u16matAcc_1
+%val33B = OpUConvert %u32matB %u16matAcc_1
+%val34B = OpSConvert %s32matB %u16matAcc_1
+
+%val41A = OpConvertSToF %f16matA %s16matAcc_1
+%val42A = OpConvertSToF %f32matA %s16matAcc_1
+%val43A = OpUConvert %u32matA %s16matAcc_1
+%val44A = OpSConvert %s32matA %s16matAcc_1
+
+%val41B = OpConvertSToF %f16matB %s16matAcc_1
+%val42B = OpConvertSToF %f32matB %s16matAcc_1
+%val43B = OpUConvert %u32matB %s16matAcc_1
+%val44B = OpSConvert %s32matB %s16matAcc_1
+
+%val51A = OpCooperativeMatrixConvertNV %f16matA %f16matAcc_1
+%val52A = OpCooperativeMatrixConvertNV %f32matA %f32matAcc_1
+%val53A = OpCooperativeMatrixConvertNV %u16matA %u16matAcc_1
+%val54A = OpCooperativeMatrixConvertNV %s16matA %s16matAcc_1
+
+%val51B = OpCooperativeMatrixConvertNV %f16matB %f16matAcc_1
+%val52B = OpCooperativeMatrixConvertNV %f32matB %f32matAcc_1
+%val53B = OpCooperativeMatrixConvertNV %u16matB %u16matAcc_1
+%val54B = OpCooperativeMatrixConvertNV %s16matB %s16matAcc_1
+
+%val61B = OpCooperativeMatrixTransposeNV %f16matB %f16matAcc_1
+%val62B = OpCooperativeMatrixTransposeNV %f32matB %f32matAcc_1
+%val63B = OpCooperativeMatrixTransposeNV %u16matB %u16matAcc_1
+%val64B = OpCooperativeMatrixTransposeNV %s16matB %s16matAcc_1
+
+%val71B = OpCooperativeMatrixTransposeNV %f16matB8x16 %f16matAcc16x8_1
+
+OpReturn
+OpFunctionEnd)";
+
+  CompileSuccessfully(body.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateConversion, CoopMat2TransposeShapeFail) {
+  const std::string body = R"(
+OpCapability Shader
+OpCapability Float16
+OpCapability Int16
+OpCapability CooperativeMatrixConversionsNV
+OpCapability CooperativeMatrixKHR
+OpExtension "SPV_KHR_cooperative_matrix"
+OpExtension "SPV_NV_cooperative_matrix2"
+OpExtension "SPV_KHR_vulkan_memory_model"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+%void = OpTypeVoid
+%func = OpTypeFunction %void
+%bool = OpTypeBool
+%f16 = OpTypeFloat 16
+%u32 = OpTypeInt 32 0
+
+%u32_8 = OpConstant %u32 8
+%u32_16 = OpConstant %u32 16
+%use_B = OpConstant %u32 1
+%use_Acc = OpConstant %u32 2
+%subgroup = OpConstant %u32 3
+
+%f16matAcc16x8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_16 %u32_8 %use_Acc
+%f16matB16x8 = OpTypeCooperativeMatrixKHR %f16 %subgroup %u32_16 %u32_8 %use_B
+
+%f16_1 = OpConstant %f16 1
+
+%f16matAcc16x8_1 = OpConstantComposite %f16matAcc16x8 %f16_1
+
+%main = OpFunction %void None %func
+%main_entry = OpLabel
+
+%val71B = OpCooperativeMatrixTransposeNV %f16matB16x8 %f16matAcc16x8_1
+
+OpReturn
+OpFunctionEnd)";
+
+  CompileSuccessfully(body.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Expected rows of Matrix type and Result Type to be "
+                        "swapped with columns"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_decoration_test.cpp b/test/val/val_decoration_test.cpp
index ba0e9597..b5738d70 100644
--- a/test/val/val_decoration_test.cpp
+++ b/test/val/val_decoration_test.cpp
@@ -9362,6 +9362,37 @@ OpFunctionEnd
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
 }
 
+TEST_F(ValidateDecorations, UntypedVariableDuplicateInterface) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var %var
+OpName %var "var"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Non-unique OpEntryPoint interface '2[%var]' is disallowed"));
+}
+
 TEST_F(ValidateDecorations, PhysicalStorageBufferMissingOffset) {
   const std::string spirv = R"(
 OpCapability Shader
@@ -9444,6 +9475,968 @@ OpFunctionEnd
           "contains an array with stride 0, but with an element size of 4"));
 }
 
+TEST_F(ValidateDecorations, MatrixArrayMissingMajorness) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpMemberDecorate %block 0 MatrixStride 16
+OpDecorate %array ArrayStride 32
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%int_2 = OpConstant %int 2
+%vec = OpTypeVector %float 2
+%mat = OpTypeMatrix %vec 2
+%array = OpTypeArray %mat %int_2
+%block = OpTypeStruct %array
+%ptr = OpTypePointer Uniform %block
+%var = OpVariable %ptr Uniform
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "must be explicitly laid out with RowMajor or ColMajor decorations"));
+}
+
+TEST_F(ValidateDecorations, MatrixArrayMissingStride) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpMemberDecorate %block 0 ColMajor
+OpDecorate %array ArrayStride 32
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%int_2 = OpConstant %int 2
+%vec = OpTypeVector %float 2
+%mat = OpTypeMatrix %vec 2
+%array = OpTypeArray %mat %int_2
+%block = OpTypeStruct %array
+%ptr = OpTypePointer Uniform %block
+%var = OpVariable %ptr Uniform
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("must be explicitly laid out with MatrixStride decorations"));
+}
+
+TEST_F(ValidateDecorations, MatrixArrayBadStride) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpMemberDecorate %block 0 ColMajor
+OpMemberDecorate %block 0 MatrixStride 8
+OpDecorate %array ArrayStride 32
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%int_2 = OpConstant %int 2
+%vec = OpTypeVector %float 2
+%mat = OpTypeMatrix %vec 2
+%array = OpTypeArray %mat %int_2
+%block = OpTypeStruct %array
+%ptr = OpTypePointer Uniform %block
+%var = OpVariable %ptr Uniform
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("is a matrix with stride 8 not satisfying alignment to 16"));
+}
+
+TEST_F(ValidateDecorations, MatrixArrayArrayMissingMajorness) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpMemberDecorate %block 0 MatrixStride 16
+OpDecorate %array ArrayStride 32
+OpDecorate %rta ArrayStride 64
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%int_2 = OpConstant %int 2
+%vec = OpTypeVector %float 2
+%mat = OpTypeMatrix %vec 2
+%array = OpTypeArray %mat %int_2
+%rta = OpTypeRuntimeArray %array
+%block = OpTypeStruct %rta
+%ptr = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "must be explicitly laid out with RowMajor or ColMajor decorations"));
+}
+
+TEST_F(ValidateDecorations, MatrixArrayArrayMissingStride) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpMemberDecorate %block 0 ColMajor
+OpDecorate %array ArrayStride 32
+OpDecorate %rta ArrayStride 64
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%int_2 = OpConstant %int 2
+%vec = OpTypeVector %float 2
+%mat = OpTypeMatrix %vec 2
+%array = OpTypeArray %mat %int_2
+%rta = OpTypeRuntimeArray %array
+%block = OpTypeStruct %rta
+%ptr = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("must be explicitly laid out with MatrixStride decorations"));
+}
+
+TEST_F(ValidateDecorations, MatrixArrayArrayBadStride) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpMemberDecorate %block 0 ColMajor
+OpMemberDecorate %block 0 MatrixStride 8
+OpDecorate %array ArrayStride 32
+OpDecorate %a ArrayStride 64
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%int_2 = OpConstant %int 2
+%vec = OpTypeVector %float 2
+%mat = OpTypeMatrix %vec 2
+%array = OpTypeArray %mat %int_2
+%a = OpTypeArray %array %int_2
+%block = OpTypeStruct %a
+%ptr = OpTypePointer Uniform %block
+%var = OpVariable %ptr Uniform
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("is a matrix with stride 8 not satisfying alignment to 16"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsInputVertex) {
+  const std::string body = R"(
+               OpCapability Shader
+               OpCapability DrawParameters
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Vertex %main "main" %_ %gl_BaseInstance1 %gl_BaseInstance2
+               OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
+               OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
+               OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
+               OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
+               OpDecorate %gl_PerVertex Block
+               OpDecorate %gl_BaseInstance1 BuiltIn BaseInstance
+               OpDecorate %gl_BaseInstance2 BuiltIn BaseInstance
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+       %uint = OpTypeInt 32 0
+     %uint_1 = OpConstant %uint 1
+%_arr_float_uint_1 = OpTypeArray %float %uint_1
+%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
+%_ptr_Output_gl_PerVertex = OpTypePointer Output %gl_PerVertex
+          %_ = OpVariable %_ptr_Output_gl_PerVertex Output
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+    %float_0 = OpConstant %float 0
+         %17 = OpConstantComposite %v4float %float_0 %float_0 %float_0 %float_0
+%_ptr_Input_int = OpTypePointer Input %int
+%gl_BaseInstance1 = OpVariable %_ptr_Input_int Input
+%gl_BaseInstance2 = OpVariable %_ptr_Input_int Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %20 = OpLoad %int %gl_BaseInstance1
+         %21 = OpConvertSToF %float %20
+         %22 = OpVectorTimesScalar %v4float %17 %21
+         %24 = OpAccessChain %_ptr_Output_v4float %_ %int_0
+               OpStore %24 %22
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_2);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpEntryPoint contains duplicate input variables with "
+                        "BaseInstance builtin"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09658"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsInputMesh) {
+  const std::string body = R"(
+               OpCapability DrawParameters
+               OpCapability MeshShadingEXT
+               OpExtension "SPV_EXT_mesh_shader"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint MeshEXT %main "main" %gl_DrawID_1 %gl_DrawID_2
+               OpExecutionMode %main LocalSize 1 1 1
+               OpExecutionMode %main OutputVertices 32
+               OpExecutionMode %main OutputPrimitivesEXT 32
+               OpExecutionMode %main OutputTrianglesEXT
+               OpDecorate %gl_DrawID_1 BuiltIn DrawIndex
+               OpDecorate %gl_DrawID_2 BuiltIn DrawIndex
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+        %int = OpTypeInt 32 1
+%_ptr_Input_int = OpTypePointer Input %int
+  %gl_DrawID_1 = OpVariable %_ptr_Input_int Input
+  %gl_DrawID_2 = OpVariable %_ptr_Input_int Input
+       %uint = OpTypeInt 32 0
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+          %9 = OpLoad %int %gl_DrawID_1
+         %11 = OpBitcast %uint %9
+         %12 = OpLoad %int %gl_DrawID_2
+         %13 = OpBitcast %uint %12
+               OpSetMeshOutputsEXT %11 %13
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_2);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpEntryPoint contains duplicate input variables with "
+                        "DrawIndex builtin"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09658"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsInputCompute) {
+  const std::string body = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint GLCompute %main "main" %_ %gl_WorkGroupID_1 %gl_WorkGroupID_2
+               OpExecutionMode %main LocalSize 1 1 1
+               OpMemberDecorate %Buffers 0 Offset 0
+               OpDecorate %Buffers Block
+               OpDecorate %_ DescriptorSet 0
+               OpDecorate %_ Binding 0
+               OpDecorate %gl_WorkGroupID_1 BuiltIn WorkgroupId
+               OpDecorate %gl_WorkGroupID_2 BuiltIn WorkgroupId
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v3uint = OpTypeVector %uint 3
+    %Buffers = OpTypeStruct %v3uint
+%_ptr_StorageBuffer_Buffers = OpTypePointer StorageBuffer %Buffers
+          %_ = OpVariable %_ptr_StorageBuffer_Buffers StorageBuffer
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+%_ptr_Input_v3uint = OpTypePointer Input %v3uint
+%gl_WorkGroupID_1 = OpVariable %_ptr_Input_v3uint Input
+%gl_WorkGroupID_2 = OpVariable %_ptr_Input_v3uint Input
+%_ptr_StorageBuffer_v3uint = OpTypePointer StorageBuffer %v3uint
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpLoad %v3uint %gl_WorkGroupID_1
+         %16 = OpLoad %v3uint %gl_WorkGroupID_2
+         %17 = OpIAdd %v3uint %15 %16
+         %19 = OpAccessChain %_ptr_StorageBuffer_v3uint %_ %int_0
+               OpStore %19 %17
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_2);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpEntryPoint contains duplicate input variables with "
+                        "WorkgroupId builtin"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09658"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsOutputFragment) {
+  const std::string body = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %gl_FragDepth_1 %gl_FragDepth_2
+               OpExecutionMode %main OriginUpperLeft
+               OpExecutionMode %main DepthReplacing
+               OpDecorate %gl_FragDepth_1 BuiltIn FragDepth
+               OpDecorate %gl_FragDepth_2 BuiltIn FragDepth
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+%_ptr_Output_float = OpTypePointer Output %float
+%gl_FragDepth_1 = OpVariable %_ptr_Output_float Output
+%gl_FragDepth_2 = OpVariable %_ptr_Output_float Output
+    %float_1 = OpConstant %float 1
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+               OpStore %gl_FragDepth_1 %float_1
+         %10 = OpLoad %float %gl_FragDepth_1
+         %11 = OpFAdd %float %10 %float_1
+               OpStore %gl_FragDepth_2 %11
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_2);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpEntryPoint contains duplicate output variables with "
+                        "FragDepth builtin"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09659"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsRayTmaxKHR) {
+  const std::string body = R"(
+               OpCapability RayTracingKHR
+               OpExtension "SPV_KHR_ray_tracing"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint AnyHitKHR %main "main" %gl_RayTmaxEXT %gl_HitTEXT %incomingPayload
+               OpDecorate %gl_RayTmaxEXT BuiltIn RayTmaxKHR
+               OpDecorate %gl_HitTEXT BuiltIn RayTmaxKHR
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+%_ptr_Function_float = OpTypePointer Function %float
+%_ptr_Input_float = OpTypePointer Input %float
+%gl_RayTmaxEXT = OpVariable %_ptr_Input_float Input
+ %gl_HitTEXT = OpVariable %_ptr_Input_float Input
+    %v4float = OpTypeVector %float 4
+%_ptr_IncomingRayPayloadKHR_v4float = OpTypePointer IncomingRayPayloadKHR %v4float
+%incomingPayload = OpVariable %_ptr_IncomingRayPayloadKHR_v4float IncomingRayPayloadKHR
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+          %a = OpVariable %_ptr_Function_float Function
+          %b = OpVariable %_ptr_Function_float Function
+         %11 = OpLoad %float %gl_RayTmaxEXT
+               OpStore %a %11
+         %14 = OpLoad %float %gl_HitTEXT
+               OpStore %b %14
+         %18 = OpLoad %float %a
+         %19 = OpLoad %float %b
+         %22 = OpCompositeConstruct %v4float %18 %18 %19 %19
+               OpStore %incomingPayload %22
+               OpTerminateRayKHR
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_2);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "OpEntryPoint contains duplicate input variables with RayTmax"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09658"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsBlock) {
+  const std::string body = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Vertex %main "main" %var
+               OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
+               OpMemberDecorate %gl_PerVertex 1 BuiltIn Position
+               OpDecorate %gl_PerVertex Block
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%gl_PerVertex = OpTypeStruct %v4float %v4float
+%_ptr_gl_PerVertex = OpTypePointer Output %gl_PerVertex
+        %var = OpVariable %_ptr_gl_PerVertex Output
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+      %int_1 = OpConstant %int 1
+    %float_0 = OpConstant %float 0
+         %17 = OpConstantComposite %v4float %float_0 %float_0 %float_0 %float_0
+   %ptr_vec4 = OpTypePointer Output %v4float
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %19 = OpAccessChain %ptr_vec4 %var %int_0
+               OpStore %19 %17
+         %22 = OpAccessChain %ptr_vec4 %var %int_1
+               OpStore %22 %17
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_0);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "OpEntryPoint contains duplicate output variables with Position"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09659"));
+}
+
+TEST_F(ValidateDecorations, MultipleBuiltinsBlockMixed) {
+  const std::string body = R"(
+               OpCapability Shader
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Vertex %main "main" %var %position
+               OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
+               OpDecorate %gl_PerVertex Block
+               OpDecorate %position BuiltIn Position
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%gl_PerVertex = OpTypeStruct %v4float
+%_ptr_gl_PerVertex = OpTypePointer Output %gl_PerVertex
+        %var = OpVariable %_ptr_gl_PerVertex Output
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+      %int_1 = OpConstant %int 1
+    %float_0 = OpConstant %float 0
+         %17 = OpConstantComposite %v4float %float_0 %float_0 %float_0 %float_0
+   %ptr_vec4 = OpTypePointer Output %v4float
+   %position = OpVariable %ptr_vec4 Output
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %19 = OpAccessChain %ptr_vec4 %var %int_0
+               OpStore %19 %17
+               OpStore %position %17
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_VULKAN_1_0);
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "OpEntryPoint contains duplicate output variables with Position"));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-09659"));
+}
+
+TEST_F(ValidateDecorations, UntypedVariableWorkgroupRequiresStruct) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Untyped workgroup variables in shaders must be block "
+                        "decorated structs"));
+}
+
+TEST_F(ValidateDecorations, UntypedVariableWorkgroupRequiresBlockStruct) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Untyped workgroup variables in shaders must be block "
+                        "decorated"));
+}
+
+TEST_F(ValidateDecorations, UntypedVariableStorageBufferMissingBlock) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpName %struct "struct"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("StorageBuffer id '2' is missing Block decoration"));
+}
+
+TEST_F(ValidateDecorations, UntypedVariableUniformMissingBlock) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpName %struct "struct"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Uniform
+%var = OpUntypedVariableKHR %ptr Uniform %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Uniform id '2' is missing Block or BufferBlock decoration"));
+}
+
+TEST_F(ValidateDecorations, UntypedVariablePushConstantMissingBlock) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpName %struct "struct"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR PushConstant
+%var = OpUntypedVariableKHR %ptr PushConstant %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("PushConstant id '2' is missing Block decoration"));
+}
+
+using UntypedVariableSetAndBinding = spvtest::ValidateBase<std::string>;
+
+TEST_P(UntypedVariableSetAndBinding, MissingSet) {
+  const auto sc = GetParam();
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpName %var "var"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpDecorate %var Binding 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR )" +
+                            sc + R"(
+%var = OpUntypedVariableKHR %ptr )" + sc + R"( %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%load = OpLoad %struct %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr(sc + " id '2' is missing DescriptorSet decoration"));
+}
+
+TEST_P(UntypedVariableSetAndBinding, MissingBinding) {
+  const auto sc = GetParam();
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpName %var "var"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpDecorate %var DescriptorSet 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR )" +
+                            sc + R"(
+%var = OpUntypedVariableKHR %ptr )" + sc + R"( %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%load = OpLoad %struct %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr(sc + " id '2' is missing Binding decoration"));
+}
+
+INSTANTIATE_TEST_SUITE_P(ValidateUntypedVariableSetAndBinding,
+                         UntypedVariableSetAndBinding,
+                         Values("StorageBuffer", "Uniform"));
+
+using UntypedPointerLayout =
+    spvtest::ValidateBase<std::tuple<std::string, std::string>>;
+
+TEST_P(UntypedPointerLayout, BadOffset) {
+  const auto sc = std::get<0>(GetParam());
+  const auto op = std::get<1>(GetParam());
+  const std::string set = (sc == "StorageBuffer" || sc == "Uniform"
+                               ? R"(OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+)"
+                               : R"()");
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpExecutionMode %main LocalSize 1 1 1
+OpName %var "var"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpMemberDecorate %struct 1 Offset 4
+)" + set + R"(OpMemberDecorate %test_type 0 Offset 0
+OpMemberDecorate %test_type 1 Offset 1
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%struct = OpTypeStruct %int %int
+%test_type = OpTypeStruct %int %int
+%test_val = OpConstantNull %test_type
+%ptr = OpTypeUntypedPointerKHR )" +
+                            sc + R"(
+%var = OpUntypedVariableKHR %ptr )" + sc + R"( %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+)" + op + R"(
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  const bool read_only = sc == "Uniform" || sc == "PushConstant";
+  if (!read_only || op.find("OpStore") == std::string::npos) {
+    EXPECT_THAT(getDiagnosticString(),
+                HasSubstr("member 1 at offset 1 is not aligned to"));
+  }
+}
+
+TEST_P(UntypedPointerLayout, BadStride) {
+  const auto sc = std::get<0>(GetParam());
+  const auto op = std::get<1>(GetParam());
+  const std::string set = (sc == "StorageBuffer" || sc == "Uniform"
+                               ? R"(OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+)"
+                               : R"()");
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpExecutionMode %main LocalSize 1 1 1
+OpName %var "var"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpMemberDecorate %struct 1 Offset 4
+)" + set + R"(OpDecorate %test_type ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int_4 = OpConstant %int 4
+%int4 = OpTypeVector %int 4
+%test_type = OpTypeArray %int4 %int_4
+%test_val = OpConstantNull %test_type
+%struct = OpTypeStruct %int %int
+%ptr = OpTypeUntypedPointerKHR )" +
+                            sc + R"(
+%var = OpUntypedVariableKHR %ptr )" + sc + R"( %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+)" + op + R"(
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  const bool read_only = sc == "Uniform" || sc == "PushConstant";
+  if (!read_only || op.find("OpStore") == std::string::npos) {
+    EXPECT_THAT(
+        getDiagnosticString(),
+        HasSubstr("array with stride 4 not satisfying alignment to 16"));
+  }
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ValidateUntypedPointerLayout, UntypedPointerLayout,
+    Combine(Values("StorageBuffer", "Uniform", "PushConstant", "Workgroup"),
+            Values("%gep = OpUntypedAccessChainKHR %ptr %test_type %var %int_0",
+                   "%gep = OpUntypedInBoundsAccessChainKHR %ptr %test_type "
+                   "%var %int_0",
+                   "%gep = OpUntypedPtrAccessChainKHR %ptr %test_type %var "
+                   "%int_0 %int_0",
+                   "%ld = OpLoad %test_type %var", "OpStore %var %test_val")));
+
+TEST_F(ValidateDecorations, UntypedArrayLengthMissingOffset) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%array = OpTypeRuntimeArray %int
+%struct = OpTypeStruct %array
+%block = OpTypeStruct %array
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %block
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%len = OpUntypedArrayLengthKHR %int %struct %var 0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("member 0 is missing an Offset decoration"));
+}
+
+TEST_F(ValidateDecorations, ComponentMultipleArrays) {
+  const std::string spirv = R"(
+               OpCapability Tessellation
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint TessellationEvaluation %main "main" %_ %FOO %FOO0
+               OpExecutionMode %main Triangles
+               OpExecutionMode %main SpacingEqual
+               OpExecutionMode %main VertexOrderCcw
+               OpSource GLSL 460
+               OpSourceExtension "GL_EXT_nonuniform_qualifier"
+               OpName %main "main"
+               OpName %gl_PerVertex "gl_PerVertex"
+               OpMemberName %gl_PerVertex 0 "gl_Position"
+               OpMemberName %gl_PerVertex 1 "gl_PointSize"
+               OpMemberName %gl_PerVertex 2 "gl_ClipDistance"
+               OpMemberName %gl_PerVertex 3 "gl_CullDistance"
+               OpName %_ ""
+               OpName %FOO "FOO"
+               OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
+               OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
+               OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
+               OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
+               OpDecorate %gl_PerVertex Block
+               OpDecorate %FOO Component 2
+               OpDecorate %FOO Location 1
+               OpDecorate %FOO0 Location 1
+               OpDecorate %FOO0 Component 0
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+       %uint = OpTypeInt 32 0
+     %uint_1 = OpConstant %uint 1
+%_arr_float_uint_1 = OpTypeArray %float %uint_1
+%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
+%_ptr_Output_gl_PerVertex = OpTypePointer Output %gl_PerVertex
+          %_ = OpVariable %_ptr_Output_gl_PerVertex Output
+        %int = OpTypeInt 32 1
+      %int_0 = OpConstant %int 0
+    %v2float = OpTypeVector %float 2
+     %uint_2 = OpConstant %uint 2
+%_arr_v2float_uint_2 = OpTypeArray %v2float %uint_2
+    %uint_32 = OpConstant %uint 32
+%_arr__arr_v2float_uint_2_uint_32 = OpTypeArray %_arr_v2float_uint_2 %uint_32
+%_ptr_Input__arr__arr_v2float_uint_2_uint_32 = OpTypePointer Input %_arr__arr_v2float_uint_2_uint_32
+        %FOO = OpVariable %_ptr_Input__arr__arr_v2float_uint_2_uint_32 Input
+        %FOO0 = OpVariable %_ptr_Input__arr__arr_v2float_uint_2_uint_32 Input
+%_ptr_Input_v2float = OpTypePointer Input %v2float
+      %int_1 = OpConstant %int 1
+     %uint_0 = OpConstant %uint 0
+%_ptr_Output_float = OpTypePointer Output %float
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %24 = OpAccessChain %_ptr_Input_v2float %FOO %int_0 %int_0
+         %25 = OpLoad %v2float %24
+         %27 = OpAccessChain %_ptr_Input_v2float %FOO0 %int_1 %int_1
+         %28 = OpLoad %v2float %27
+         %29 = OpFAdd %v2float %25 %28
+         %32 = OpAccessChain %_ptr_Output_float %_ %int_0 %uint_0
+         %33 = OpCompositeExtract %float %29 0
+               OpStore %32 %33
+         %34 = OpAccessChain %_ptr_Output_float %_ %int_0 %uint_1
+         %35 = OpCompositeExtract %float %29 1
+               OpStore %34 %35
+               OpReturn
+               OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_derivatives_test.cpp b/test/val/val_derivatives_test.cpp
index e605f3a0..6ddafe49 100644
--- a/test/val/val_derivatives_test.cpp
+++ b/test/val/val_derivatives_test.cpp
@@ -156,8 +156,8 @@ TEST_F(ValidateDerivatives, OpDPdxWrongExecutionModel) {
   CompileSuccessfully(GenerateShaderCode(body, "", "Vertex").c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Derivative instructions require Fragment or GLCompute "
-                        "execution model: DPdx"));
+              HasSubstr("Derivative instructions require Fragment, GLCompute, "
+                        "MeshEXT or TaskEXT execution model: DPdx"));
 }
 
 TEST_F(ValidateDerivatives, NoExecutionModeGLCompute) {
@@ -181,8 +181,9 @@ OpFunctionEnd
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Derivative instructions require "
-                        "DerivativeGroupQuadsNV or DerivativeGroupLinearNV "
-                        "execution mode for GLCompute execution model"));
+                        "DerivativeGroupQuadsKHR or DerivativeGroupLinearKHR "
+                        "execution mode for GLCompute, MeshEXT or TaskEXT "
+                        "execution model"));
 }
 
 using ValidateHalfDerivatives = spvtest::ValidateBase<std::string>;
diff --git a/test/val/val_ext_inst_debug_test.cpp b/test/val/val_ext_inst_debug_test.cpp
index 8f0da42d..bd4ab3c7 100644
--- a/test/val/val_ext_inst_debug_test.cpp
+++ b/test/val/val_ext_inst_debug_test.cpp
@@ -21,6 +21,7 @@
 #include <vector>
 
 #include "gmock/gmock.h"
+#include "spirv-tools/libspirv.h"
 #include "test/unit_spirv.h"
 #include "test/val/val_fixtures.h"
 
@@ -84,6 +85,15 @@ using ValidateVulkan100DebugInfoDebugValue =
     spvtest::ValidateBase<std::pair<std::string, std::string>>;
 using ValidateVulkan100DebugInfo = spvtest::ValidateBase<std::string>;
 
+const static std::string shader_extension = R"(
+OpExtension "SPV_KHR_non_semantic_info"
+%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+)";
+
+const static std::string opencl_extension = R"(
+%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
+)";
+
 std::string GenerateShaderCodeForDebugInfo(
     const std::string& op_string_instructions,
     const std::string& op_const_instructions,
@@ -118,6 +128,7 @@ OpCapability Int64
     ss << "OpExecutionMode %main OriginUpperLeft\n";
   }
 
+  ss << "%main_name = OpString \"main\"\n";
   ss << op_string_instructions;
 
   ss << R"(
@@ -181,6 +192,9 @@ OpCapability Int64
 %u32_1 = OpConstant %u32 1
 %u32_2 = OpConstant %u32 2
 %u32_3 = OpConstant %u32 3
+%u32_4 = OpConstant %u32 4
+%u32_5 = OpConstant %u32 5
+%u32_32 = OpConstant %u32 32
 
 %s32_0 = OpConstant %s32 0
 %s32_1 = OpConstant %s32 1
@@ -308,12 +322,8 @@ TEST_F(ValidateOpenCL100DebugInfo, UseDebugInstructionOutOfFunction) {
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", dbg_inst, "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -327,12 +337,8 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugSourceInFunction) {
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", "", dbg_inst,
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", "", dbg_inst, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -352,13 +358,8 @@ TEST_F(ValidateVulkan100DebugInfo, DebugSourceInFunction) {
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 )";
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", "", dbg_inst,
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", "", dbg_inst, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -373,8 +374,6 @@ TEST_P(ValidateLocalDebugInfoOutOfFunction, OpenCLDebugInfo100DebugScope) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %int_name = OpString "int"
 %foo_name = OpString "foo"
 )";
@@ -384,7 +383,7 @@ TEST_P(ValidateLocalDebugInfoOutOfFunction, OpenCLDebugInfo100DebugScope) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %int_info = OpExtInst %void %DbgExt DebugTypeBasic %int_name %u32_0 Signed
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_linkage_name FlagIsPublic 1 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %int_info %dbg_src 1 1 %main_info FlagIsLocal
 %expr = OpExtInst %void %DbgExt DebugExpression
 )";
@@ -392,14 +391,10 @@ TEST_P(ValidateLocalDebugInfoOutOfFunction, OpenCLDebugInfo100DebugScope) {
   const std::string body = R"(
 %foo = OpVariable %u32_ptr_function Function
 %foo_val = OpLoad %u32 %foo
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header + GetParam(), body, extension, "Vertex"));
+      src, "", dbg_inst_header + GetParam(), body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("DebugScope, DebugNoScope, DebugDeclare, DebugValue "
@@ -412,8 +407,6 @@ TEST_P(ValidateLocalDebugInfoOutOfFunction, VulkanDebugInfo100DebugScope) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %int_name = OpString "int"
 %foo_name = OpString "foo"
 )";
@@ -423,7 +416,7 @@ TEST_P(ValidateLocalDebugInfoOutOfFunction, VulkanDebugInfo100DebugScope) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %int_info = OpExtInst %void %DbgExt DebugTypeBasic %int_name %u32_0 %u32_1 %u32_0
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_linkage_name %u32_3 %u32_1
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %int_info %dbg_src %u32_1 %u32_1 %main_info %u32_4
 %expr = OpExtInst %void %DbgExt DebugExpression
 )";
@@ -432,20 +425,10 @@ TEST_P(ValidateLocalDebugInfoOutOfFunction, VulkanDebugInfo100DebugScope) {
 %foo = OpVariable %u32_ptr_function Function
 %main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main
 %foo_val = OpLoad %u32 %foo
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header + GetParam(), body, extension, "Vertex"));
+      src, "", dbg_inst_header + GetParam(), body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("DebugScope, DebugNoScope, DebugDeclare, DebugValue "
@@ -465,27 +448,21 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugFunctionForwardReference) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_linkage_name FlagIsPublic 1 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 )";
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %main_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -494,8 +471,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugFunctionMissingOpFunction) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 )";
 
   const std::string dbg_inst_header = R"(
@@ -503,19 +478,15 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugFunctionMissingOpFunction) {
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_linkage_name FlagIsPublic 1 %dbgNone
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %dbgNone
 )";
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %main_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -528,8 +499,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugScopeBeforeOpVariableInFunction) {
 }
 "
 %float_name = OpString "float"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string size_const = R"(
@@ -542,20 +511,16 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugScopeBeforeOpVariableInFunction) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info 4
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %v4float_info %float_info
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main
 )";
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %main_info
 %foo = OpVariable %f32_ptr_function Function
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, body, extension, "Vertex"));
+      src, size_const, dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -575,12 +540,8 @@ main() {}
 %opaque = OpExtInst %void %DbgExt DebugTypeComposite %ty_name Class %dbg_src 1 1 %comp_unit %ty_name %dbg_none FlagIsPublic
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -613,14 +574,10 @@ main() {}
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info 4
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember %VS_OUTPUT_pos_name %v4float_info %dbg_src 2 3 %VS_OUTPUT_info %u32_0 %int_128 FlagIsPublic
 %VS_OUTPUT_color_info = OpExtInst %void %DbgExt DebugTypeMember %VS_OUTPUT_color_name %v4float_info %dbg_src 3 3 %VS_OUTPUT_info %int_128 %int_128 FlagIsPublic
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -652,14 +609,10 @@ main() {}
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info 4
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember %VS_OUTPUT_pos_name %v4float_info %dbg_src 2 3 %VS_OUTPUT_info %u32_0 %int_128 FlagIsPublic
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("forward referenced IDs have not been defined"));
@@ -753,12 +706,8 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugCompilationUnit) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", dbg_inst, "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -773,12 +722,8 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugCompilationUnitFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %src HLSL
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", dbg_inst, "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Source must be a result id of "
@@ -796,18 +741,8 @@ TEST_F(ValidateVulkan100DebugInfo, DebugCompilationUnitFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %src %u32_5
 )";
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, dbg_inst,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Source must be a result id of "
@@ -833,14 +768,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeBasicFailName) {
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %int_32 %int_32 Float
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Name must be a result id of "
@@ -856,27 +787,16 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeBasicFailName) {
 }
 "
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %u32_32 %u32_32 %u32_3 %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Name must be a result id of "
@@ -902,14 +822,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeBasicFailSize) {
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %float_name Float
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Size must be a result id of "
@@ -925,33 +841,47 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeBasicFailSize) {
 }
 "
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %float_name %u32_3 %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Size must be a result id of "
                         "OpConstant"));
 }
 
+TEST_F(ValidateVulkan100DebugInfo, DebugTypeBasicFailFlags) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() {}"
+%float_name = OpString "float"
+)";
+
+  const std::string constants = R"(
+%f32_32 = OpConstant %f32 32
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_3 %u32_3 %f32_32
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("expected operand Flags must be a result id of 32-bit "
+                        "unsigned OpConstant"));
+}
+
 TEST_F(ValidateOpenCL100DebugInfo, DebugTypePointer) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
@@ -972,14 +902,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypePointer) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %pfloat_info = OpExtInst %void %DbgExt DebugTypePointer %float_info Function FlagIsLocal
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1003,14 +929,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypePointerFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %pfloat_info = OpExtInst %void %DbgExt DebugTypePointer %dbg_src Function FlagIsLocal
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -1037,14 +959,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeQualifier) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %cfloat_info = OpExtInst %void %DbgExt DebugTypeQualifier %float_info ConstType
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1068,14 +986,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeQualifierFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %cfloat_info = OpExtInst %void %DbgExt DebugTypeQualifier %comp_unit ConstType
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -1090,12 +1004,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeQualifier) {
 }
 "
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1103,15 +1011,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeQualifier) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %cfloat_info = OpExtInst %void %DbgExt DebugTypeQualifier %float_info %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1124,12 +1027,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeQualifierFail) {
 }
 "
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1137,15 +1034,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeQualifierFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %cfloat_info = OpExtInst %void %DbgExt DebugTypeQualifier %comp_unit %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -1168,14 +1060,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArray) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %int_32
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1185,7 +1073,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayWithVariableSize) {
 %code = OpString "main() {}"
 %float_name = OpString "float"
 %int_name = OpString "int"
-%main_name = OpString "main"
 %foo_name = OpString "foo"
 )";
 
@@ -1202,14 +1089,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayWithVariableSize) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %uint_info %dbg_src 1 1 %main_info FlagIsLocal
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %foo_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1229,14 +1112,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayFailBaseType) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %comp_unit %int_32
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Base Type is not a valid debug "
@@ -1259,14 +1138,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayFailComponentCount) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %float_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1291,14 +1166,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayFailComponentCountFloat) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %f32_4
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1323,14 +1194,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayFailComponentCountZero) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %u32_0
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1344,7 +1211,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayFailVariableSizeTypeFloat) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-%main_name = OpString "main"
 %foo_name = OpString "foo"
 )";
 
@@ -1360,14 +1226,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeArrayFailVariableSizeTypeFloat) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %float_info %dbg_src 1 1 %main_info FlagIsLocal
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %foo_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1381,12 +1243,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArray) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1394,15 +1250,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArray) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %u32_32
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1412,15 +1263,11 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayWithVariableSize) {
 %code = OpString "main() {}"
 %float_name = OpString "float"
 %uint_name = OpString "uint"
-%main_name = OpString "main"
 %foo_name = OpString "foo"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_6 = OpConstant %u32 6
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1432,15 +1279,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayWithVariableSize) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %uint_info %dbg_src %u32_1 %u32_1 %main_info %u32_4
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %foo_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1449,12 +1291,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailBaseType) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1462,15 +1298,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailBaseType) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %comp_unit %u32_32
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Base Type is not a valid debug "
@@ -1482,12 +1313,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailComponentCount) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1495,15 +1320,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailComponentCount) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %float_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1517,12 +1337,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailComponentCountFloat) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1530,15 +1344,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailComponentCountFloat) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %f32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1552,12 +1361,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayComponentCountZero) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1565,15 +1368,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayComponentCountZero) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1582,15 +1380,11 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailVariableSizeTypeFloat) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-%main_name = OpString "main"
 %foo_name = OpString "foo"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_6 = OpConstant %u32 6
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1601,15 +1395,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeArrayFailVariableSizeTypeFloat) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %float_info %dbg_src %u32_1 %u32_1 %main_info %u32_4
 %float_arr_info = OpExtInst %void %DbgExt DebugTypeArray %float_info %foo_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be OpConstant with a 32- or "
@@ -1634,14 +1423,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeVector) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info 4
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1661,14 +1446,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeVectorFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %dbg_src 4
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Base Type must be a result id of "
@@ -1691,14 +1472,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeVectorFailComponentZero) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %dbg_src 0
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Base Type must be a result id of "
@@ -1721,14 +1498,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeVectorFailComponentFive) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %dbg_src 5
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Base Type must be a result id of "
@@ -1740,12 +1513,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVector) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1753,15 +1520,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVector) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1770,12 +1532,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVectorFail) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1783,15 +1539,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVectorFail) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %dbg_src %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Base Type must be a result id of "
@@ -1803,12 +1554,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVectorFailComponentZero) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1816,15 +1561,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVectorFailComponentZero) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be positive "
@@ -1836,12 +1576,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVectorFailComponentFive) {
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -1849,15 +1583,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeVectorFailComponentFive) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_5
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Component Count must be positive "
@@ -1872,9 +1601,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrix) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %true = OpConstantTrue %bool
 )";
 
@@ -1884,15 +1610,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrix) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %mfloat_info = OpExtInst %void %DbgExt DebugTypeMatrix %vfloat_info %u32_4 %true
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -1904,9 +1625,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorTypeType) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %true = OpConstantTrue %bool
 )";
 
@@ -1916,15 +1634,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorTypeType) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %mfloat_info = OpExtInst %void %DbgExt DebugTypeMatrix %dbg_src %u32_4 %true
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Vector Type must be a result id of "
@@ -1939,9 +1652,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorCountType) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %true = OpConstantTrue %bool
 )";
 
@@ -1951,15 +1661,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorCountType) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %mfloat_info = OpExtInst %void %DbgExt DebugTypeMatrix %vfloat_info %dbg_src %true
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Vector Count must be a result id of "
@@ -1974,9 +1679,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorCountZero) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %true = OpConstantTrue %bool
 )";
 
@@ -1986,15 +1688,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorCountZero) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %mfloat_info = OpExtInst %void %DbgExt DebugTypeMatrix %vfloat_info %u32_0 %true
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Vector Count must be positive "
@@ -2009,9 +1706,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorCountFive) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %true = OpConstantTrue %bool
 )";
 
@@ -2021,15 +1715,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeMatrixFailVectorCountFive) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %vfloat_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %mfloat_info = OpExtInst %void %DbgExt DebugTypeMatrix %vfloat_info %u32_5 %true
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Vector Count must be positive "
@@ -2053,14 +1742,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypedef) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %foo_info = OpExtInst %void %DbgExt DebugTypedef %foo_name %float_info %dbg_src 1 1 %comp_unit
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2086,12 +1771,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugTypedef, Fail) {
 %foo_info = OpExtInst %void %DbgExt DebugTypedef )";
   ss << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, size_const, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, size_const, ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second +
@@ -2117,12 +1798,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypedef) {
 %code = OpString "main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -2130,15 +1805,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypedef) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo_info = OpExtInst %void %DbgExt DebugTypedef %foo_name %float_info %dbg_src %u32_1 %u32_1 %comp_unit
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2148,12 +1818,6 @@ TEST_P(ValidateVulkan100DebugInfoDebugTypedef, Fail) {
 %code = OpString "main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const auto& param = GetParam();
@@ -2166,13 +1830,8 @@ TEST_P(ValidateVulkan100DebugInfoDebugTypedef, Fail) {
 %foo_info = OpExtInst %void %DbgExt DebugTypedef )";
   ss << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second +
@@ -2200,8 +1859,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeFunction) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %float_name = OpString "float"
 )";
 
@@ -2217,14 +1874,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeFunction) {
 %main_type_info2 = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %float_info
 %main_type_info3 = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %float_info %float_info
 %main_type_info4 = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void %float_info %float_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2232,8 +1885,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeFunctionFailReturn) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %float_name = OpString "float"
 )";
 
@@ -2246,14 +1897,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeFunctionFailReturn) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %dbg_src %float_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -2264,8 +1911,6 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeFunctionFailParam) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %float_name = OpString "float"
 )";
 
@@ -2278,14 +1923,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeFunctionFailParam) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %float_info %void
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -2296,15 +1937,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeFunctionAndParams) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -2315,15 +1948,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeFunctionAndParams) {
 %main_type_info2 = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %float_info
 %main_type_info3 = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %float_info %float_info
 %main_type_info4 = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void %float_info %float_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2331,15 +1959,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeFunctionFailReturn) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -2347,15 +1967,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeFunctionFailReturn) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %dbg_src %float_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -2366,15 +1981,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeFunctionFailParam) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 %float_name = OpString "float"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -2382,15 +1989,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeFunctionFailParam) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %float_info %void
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -2417,14 +2019,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugTypeEnum) {
 %foo_info1 = OpExtInst %void %DbgExt DebugTypeEnum %foo_name %float_info %dbg_src 1 1 %comp_unit %int_32 FlagIsPublic %u32_0 %foo_name %u32_1 %foo_name
 %foo_info2 = OpExtInst %void %DbgExt DebugTypeEnum %foo_name %none %dbg_src 1 1 %comp_unit %int_32 FlagIsPublic %u32_0 %foo_name %u32_1 %foo_name
 %foo_info3 = OpExtInst %void %DbgExt DebugTypeEnum %foo_name %none %dbg_src 1 1 %comp_unit %int_32 FlagIsPublic
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2450,12 +2048,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugTypeEnum, Fail) {
 %foo_info = OpExtInst %void %DbgExt DebugTypeEnum )";
   ss << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, size_const, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, size_const, ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -2496,12 +2090,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeEnum) {
 %code = OpString "main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -2512,15 +2100,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugTypeEnum) {
 %foo_info1 = OpExtInst %void %DbgExt DebugTypeEnum %foo_name %float_info %dbg_src %u32_1 %u32_1 %comp_unit %u32_32 %u32_3 %u32_0 %foo_name %u32_1 %foo_name
 %foo_info2 = OpExtInst %void %DbgExt DebugTypeEnum %foo_name %none %dbg_src %u32_1 %u32_1 %comp_unit %u32_32 %u32_3 %u32_0 %foo_name %u32_1 %foo_name
 %foo_info3 = OpExtInst %void %DbgExt DebugTypeEnum %foo_name %none %dbg_src %u32_1 %u32_1 %comp_unit %u32_32 %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2530,12 +2113,6 @@ TEST_P(ValidateVulkan100DebugInfoDebugTypeEnum, Fail) {
 %code = OpString "main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const auto& param = GetParam();
@@ -2548,13 +2125,8 @@ TEST_P(ValidateVulkan100DebugInfoDebugTypeEnum, Fail) {
 %foo_info = OpExtInst %void %DbgExt DebugTypeEnum )";
   ss << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -2604,8 +2176,6 @@ main() {}
 %foo_name = OpString "foo"
 %VS_OUTPUT_pos_name = OpString "pos : SV_POSITION"
 %VS_OUTPUT_linkage_name = OpString "VS_OUTPUT"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string size_const = R"(
@@ -2621,17 +2191,13 @@ main() {}
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info 4
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember %VS_OUTPUT_pos_name %v4float_info %dbg_src 2 3 %VS_OUTPUT_info %u32_0 %int_128 FlagIsPublic
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %v4float_info %float_info
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main
 %foo_info = OpExtInst %void %DbgExt DebugTypeComposite %foo_name Structure %dbg_src 1 1 %comp_unit %foo_name %u32_0 FlagIsPublic
 %child = OpExtInst %void %DbgExt DebugTypeInheritance %foo_info %VS_OUTPUT_info %int_128 %int_128 FlagIsPublic
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2650,8 +2216,6 @@ main() {}
 %foo_name = OpString "foo"
 %VS_OUTPUT_pos_name = OpString "pos : SV_POSITION"
 %VS_OUTPUT_linkage_name = OpString "VS_OUTPUT"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string size_const = R"(
@@ -2672,17 +2236,13 @@ main() {}
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info 4
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember %VS_OUTPUT_pos_name %v4float_info %dbg_src 2 3 %VS_OUTPUT_info %u32_0 %int_128 FlagIsPublic
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %v4float_info %float_info
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main
 %foo_info = OpExtInst %void %DbgExt DebugTypeComposite %foo_name Structure %dbg_src 1 1 %comp_unit %foo_name %u32_0 FlagIsPublic
 %child = OpExtInst %void %DbgExt DebugTypeInheritance %foo_info %VS_OUTPUT_info %int_128 %int_128 FlagIsPublic
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, size_const, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, size_const, ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second + " must be "));
@@ -2746,12 +2306,8 @@ main() {}
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember )";
   ss << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, size_const, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, size_const, ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   if (!param.second.empty()) {
     EXPECT_THAT(getDiagnosticString(),
@@ -2805,12 +2361,8 @@ struct foo : VS_OUTPUT {};
 %child = OpExtInst %void %DbgExt DebugTypeInheritance )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", ss.str(), "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -2849,14 +2401,9 @@ main() {}
 %foo_name = OpString "foo"
 %VS_OUTPUT_pos_name = OpString "pos : SV_POSITION"
 %VS_OUTPUT_linkage_name = OpString "VS_OUTPUT"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %u32_128 = OpConstant %u32 128
 )";
 
@@ -2868,15 +2415,10 @@ main() {}
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember %VS_OUTPUT_pos_name %v4float_info %dbg_src %u32_2 %u32_3 %u32_0 %u32_128 %u32_3
 %VS_OUTPUT_info = OpExtInst %void %DbgExt DebugTypeComposite %VS_OUTPUT_name %u32_1 %dbg_src %u32_1 %u32_1 %comp_unit %VS_OUTPUT_linkage_name %u32_128 %u32_3 %VS_OUTPUT_pos_info
 %foo_info = OpExtInst %void %DbgExt DebugTypeComposite %foo_name %u32_1 %dbg_src %u32_1 %u32_1 %comp_unit %foo_name %u32_0 %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -2895,14 +2437,9 @@ main() {}
 %foo_name = OpString "foo"
 %VS_OUTPUT_pos_name = OpString "pos : SV_POSITION"
 %VS_OUTPUT_linkage_name = OpString "VS_OUTPUT"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %u32_128 = OpConstant %u32 128
 )";
 
@@ -2918,13 +2455,8 @@ main() {}
 %VS_OUTPUT_info = OpExtInst %void %DbgExt DebugTypeComposite )";
   ss << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second + " must be "));
@@ -2971,9 +2503,6 @@ main() {}
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 %u32_128 = OpConstant %u32 128
 )";
 
@@ -2987,13 +2516,8 @@ main() {}
 %VS_OUTPUT_pos_info = OpExtInst %void %DbgExt DebugTypeMember )";
   ss << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   if (!param.second.empty()) {
     EXPECT_THAT(getDiagnosticString(),
@@ -3033,23 +2557,17 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugFunctionDeclaration) {
 };
 main() {}
 "
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
+%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main)";
 
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3061,8 +2579,6 @@ TEST_P(ValidateOpenCL100DebugInfoDebugFunction, Fail) {
 };
 main() {}
 "
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const auto& param = GetParam();
@@ -3072,16 +2588,12 @@ main() {}
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic
+%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic
 %main_info = OpExtInst %void %DbgExt DebugFunction )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", ss.str(), "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3091,25 +2603,25 @@ INSTANTIATE_TEST_SUITE_P(
     AllOpenCL100DebugInfoFail, ValidateOpenCL100DebugInfoDebugFunction,
     ::testing::ValuesIn(std::vector<std::pair<std::string, std::string>>{
         std::make_pair(
-            R"(%u32_0 %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main)",
+            R"(%u32_0 %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main)",
             "Name"),
         std::make_pair(
-            R"(%main_name %dbg_src %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main)",
+            R"(%main_name %dbg_src %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main)",
             "Type"),
         std::make_pair(
-            R"(%main_name %main_type_info %comp_unit 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main)",
+            R"(%main_name %main_type_info %comp_unit 12 1 %comp_unit %main_name FlagIsPublic 13 %main)",
             "Source"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src 12 1 %dbg_src %main_linkage_name FlagIsPublic 13 %main)",
+            R"(%main_name %main_type_info %dbg_src 12 1 %dbg_src %main_name FlagIsPublic 13 %main)",
             "Parent"),
         std::make_pair(
             R"(%main_name %main_type_info %dbg_src 12 1 %comp_unit %void FlagIsPublic 13 %main)",
             "Linkage Name"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %void)",
+            R"(%main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %void)",
             "Function"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic 13 %main %dbg_src)",
+            R"(%main_name %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic 13 %main %dbg_src)",
             "Declaration"),
     }));
 
@@ -3121,8 +2633,6 @@ TEST_P(ValidateOpenCL100DebugInfoDebugFunctionDeclaration, Fail) {
 };
 main() {}
 "
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const auto& param = GetParam();
@@ -3135,12 +2645,8 @@ main() {}
 %main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", ss.str(), "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3151,16 +2657,16 @@ INSTANTIATE_TEST_SUITE_P(
     ValidateOpenCL100DebugInfoDebugFunctionDeclaration,
     ::testing::ValuesIn(std::vector<std::pair<std::string, std::string>>{
         std::make_pair(
-            R"(%u32_0 %main_type_info %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic)",
+            R"(%u32_0 %main_type_info %dbg_src 12 1 %comp_unit %main_name FlagIsPublic)",
             "Name"),
         std::make_pair(
-            R"(%main_name %dbg_src %dbg_src 12 1 %comp_unit %main_linkage_name FlagIsPublic)",
+            R"(%main_name %dbg_src %dbg_src 12 1 %comp_unit %main_name FlagIsPublic)",
             "Type"),
         std::make_pair(
-            R"(%main_name %main_type_info %comp_unit 12 1 %comp_unit %main_linkage_name FlagIsPublic)",
+            R"(%main_name %main_type_info %comp_unit 12 1 %comp_unit %main_name FlagIsPublic)",
             "Source"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src 12 1 %dbg_src %main_linkage_name FlagIsPublic)",
+            R"(%main_name %main_type_info %dbg_src 12 1 %dbg_src %main_name FlagIsPublic)",
             "Parent"),
         std::make_pair(
             R"(%main_name %main_type_info %dbg_src 12 1 %comp_unit %void FlagIsPublic)",
@@ -3175,13 +2681,9 @@ TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDeclaration) {
 };
 main() {}
 "
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_12 = OpConstant %u32 12
 %u32_13 = OpConstant %u32 13
 )";
@@ -3190,17 +2692,12 @@ main() {}
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
-%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3 %u32_13
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3 %u32_13
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3212,13 +2709,9 @@ TEST_P(ValidateVulkan100DebugInfoDebugFunction, Fail) {
 };
 main() {}
 "
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_12 = OpConstant %u32 12
 %u32_13 = OpConstant %u32 13
 )";
@@ -3230,17 +2723,12 @@ main() {}
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
-%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3
+%main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration %main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3
 %main_info = OpExtInst %void %DbgExt DebugFunction )"
      << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3250,22 +2738,22 @@ INSTANTIATE_TEST_SUITE_P(
     AllVulkan100DebugInfoFail, ValidateVulkan100DebugInfoDebugFunction,
     ::testing::ValuesIn(std::vector<std::pair<std::string, std::string>>{
         std::make_pair(
-            R"(%u32_0 %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3 %u32_13)",
+            R"(%u32_0 %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3 %u32_13)",
             "Name"),
         std::make_pair(
-            R"(%main_name %dbg_src %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3 %u32_13)",
+            R"(%main_name %dbg_src %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3 %u32_13)",
             "Type"),
         std::make_pair(
-            R"(%main_name %main_type_info %comp_unit %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3 %u32_13)",
+            R"(%main_name %main_type_info %comp_unit %u32_12 %u32_1 %comp_unit %main_name %u32_3 %u32_13)",
             "Source"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %dbg_src %main_linkage_name %u32_3 %u32_13)",
+            R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %dbg_src %main_name %u32_3 %u32_13)",
             "Parent"),
         std::make_pair(
             R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %void %u32_3 %u32_13)",
             "Linkage Name"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3 %u32_13 %dbg_src)",
+            R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3 %u32_13 %dbg_src)",
             "Declaration"),
     }));
 
@@ -3277,13 +2765,9 @@ TEST_P(ValidateVulkan100DebugInfoDebugFunctionDeclaration, Fail) {
 };
 main() {}
 "
-%main_name = OpString "main"
-%main_linkage_name = OpString "v4f_main_f"
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_12 = OpConstant %u32 12
 %u32_13 = OpConstant %u32 13
 )";
@@ -3298,13 +2782,8 @@ main() {}
 %main_decl = OpExtInst %void %DbgExt DebugFunctionDeclaration )"
      << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3315,27 +2794,54 @@ INSTANTIATE_TEST_SUITE_P(
     ValidateVulkan100DebugInfoDebugFunctionDeclaration,
     ::testing::ValuesIn(std::vector<std::pair<std::string, std::string>>{
         std::make_pair(
-            R"(%u32_0 %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3)",
+            R"(%u32_0 %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3)",
             "Name"),
         std::make_pair(
-            R"(%main_name %dbg_src %dbg_src %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3)",
+            R"(%main_name %dbg_src %dbg_src %u32_12 %u32_1 %comp_unit %main_name %u32_3)",
             "Type"),
         std::make_pair(
-            R"(%main_name %main_type_info %comp_unit %u32_12 %u32_1 %comp_unit %main_linkage_name %u32_3)",
+            R"(%main_name %main_type_info %comp_unit %u32_12 %u32_1 %comp_unit %main_name %u32_3)",
             "Source"),
         std::make_pair(
-            R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %dbg_src %main_linkage_name %u32_3)",
+            R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %dbg_src %main_name %u32_3)",
             "Parent"),
         std::make_pair(
             R"(%main_name %main_type_info %dbg_src %u32_12 %u32_1 %comp_unit %void %u32_3)",
             "Linkage Name"),
     }));
 
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionType) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "main() {}"
+%float_name = OpString "float"
+%uint_name = OpString "uint"
+)";
+
+  const std::string constants = R"(
+%u32_6 = OpConstant %u32 6
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
+%uint_info = OpExtInst %void %DbgExt DebugTypeBasic %uint_name %u32_32 %u32_6 %u32_0
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %uint_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunction: expected operand Type must be a result "
+                        "id of DebugTypeFunction"));
+}
+
 TEST_F(ValidateOpenCL100DebugInfo, DebugLexicalBlock) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
 )";
 
   const std::string dbg_inst_header = R"(
@@ -3343,12 +2849,8 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugLexicalBlock) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_block = OpExtInst %void %DbgExt DebugLexicalBlock %dbg_src 1 1 %comp_unit %main_name)";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3356,7 +2858,6 @@ TEST_P(ValidateOpenCL100DebugInfoDebugLexicalBlock, Fail) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
 )";
 
   const auto& param = GetParam();
@@ -3368,12 +2869,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugLexicalBlock, Fail) {
 %main_block = OpExtInst %void %DbgExt DebugLexicalBlock )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, "", ss.str(), "",
-                                                     extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3400,14 +2897,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugScopeFailScope) {
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %dbg_src
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Scope"));
 }
@@ -3425,14 +2918,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugScopeFailInlinedAt) {
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %comp_unit %dbg_src
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Inlined At"));
 }
@@ -3441,27 +2930,16 @@ TEST_F(ValidateVulkan100DebugInfo, DebugLexicalBlock) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %main_block = OpExtInst %void %DbgExt DebugLexicalBlock %dbg_src %u32_1 %u32_1 %comp_unit %main_name
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3469,12 +2947,6 @@ TEST_P(ValidateVulkan100DebugInfoDebugLexicalBlock, Fail) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "main() {}"
-%main_name = OpString "main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 )";
 
   const auto& param = GetParam();
@@ -3486,13 +2958,8 @@ TEST_P(ValidateVulkan100DebugInfoDebugLexicalBlock, Fail) {
 %main_block = OpExtInst %void %DbgExt DebugLexicalBlock )"
      << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3512,11 +2979,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugScopeFailScope) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 )";
 
   const std::string dbg_inst_header = R"(
@@ -3526,15 +2988,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugScopeFailScope) {
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %dbg_src
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Scope"));
 }
@@ -3543,11 +3000,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugScopeFailInlinedAt) {
   const std::string src = R"(
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 )";
 
   const std::string dbg_inst_header = R"(
@@ -3557,15 +3009,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugScopeFailInlinedAt) {
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %comp_unit %dbg_src
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Inlined At"));
 }
@@ -3587,14 +3034,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugLocalVariable) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %foo = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %float_info %dbg_src 1 10 %comp_unit FlagIsLocal 0
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3620,12 +3063,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugLocalVariable, Fail) {
 %foo = OpExtInst %void %DbgExt DebugLocalVariable )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, size_const, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, size_const, ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3657,10 +3096,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugLocalVariable) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -3668,15 +3104,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugLocalVariable) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %float_info %dbg_src %u32_1 %u32_10 %comp_unit %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, constants, dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3689,10 +3120,7 @@ TEST_P(ValidateVulkan100DebugInfoDebugLocalVariable, Fail) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const auto& param = GetParam();
@@ -3705,13 +3133,8 @@ TEST_P(ValidateVulkan100DebugInfoDebugLocalVariable, Fail) {
 %foo = OpExtInst %void %DbgExt DebugLocalVariable )"
      << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3757,14 +3180,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugDeclare) {
   const std::string body = R"(
 %foo = OpVariable %f32_ptr_function Function
 %decl = OpExtInst %void %DbgExt DebugDeclare %foo_info %foo %null_expr
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, body, extension, "Vertex"));
+      src, size_const, dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3859,12 +3278,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugDeclare, Fail) {
 %decl = OpExtInst %void %DbgExt DebugDeclare )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, ss.str(), extension, "Vertex"));
+      src, size_const, dbg_inst_header, ss.str(), opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -3887,10 +3302,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugDeclare) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -3899,11 +3311,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugDeclare) {
 %null_expr = OpExtInst %void %DbgExt DebugExpression
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %float_info %dbg_src %u32_1 %u32_10 %comp_unit %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const std::string body = R"(
@@ -3912,7 +3319,7 @@ OpExtension "SPV_KHR_non_semantic_info"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, constants, dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -3994,10 +3401,7 @@ TEST_P(ValidateVulkan100DebugInfoDebugDeclare, Fail) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4006,11 +3410,6 @@ TEST_P(ValidateVulkan100DebugInfoDebugDeclare, Fail) {
 %null_expr = OpExtInst %void %DbgExt DebugExpression
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %float_info %dbg_src %u32_1 %u32_10 %comp_unit %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const auto& param = GetParam();
@@ -4022,7 +3421,7 @@ OpExtension "SPV_KHR_non_semantic_info"
      << param.first;
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, ss.str(), extension, "Vertex"));
+      src, constants, dbg_inst_header, ss.str(), shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -4043,12 +3442,8 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugExpression) {
 %null_expr = OpExtInst %void %DbgExt DebugExpression %op0 %op1
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo("", "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      "", "", dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4058,12 +3453,8 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugExpressionFail) {
 %null_expr = OpExtInst %void %DbgExt DebugExpression %op %void
 )";
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo("", "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      "", "", dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -4078,13 +3469,8 @@ TEST_F(ValidateVulkan100DebugInfo, DebugExpression) {
 %null_expr = OpExtInst %void %DbgExt DebugExpression %op0 %op1
 )";
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo("", "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      "", "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4094,13 +3480,8 @@ TEST_F(ValidateVulkan100DebugInfo, DebugExpressionFail) {
 %null_expr = OpExtInst %void %DbgExt DebugExpression %op %void
 )";
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo("", "", dbg_inst_header,
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      "", "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -4132,14 +3513,10 @@ main() {}
 %opaque = OpExtInst %void %DbgExt DebugTypeComposite %ty_name Class %dbg_src 1 1 %comp_unit %ty_name %dbg_none FlagIsPublic
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src 0 0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %opaque %param
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4169,14 +3546,10 @@ main() {}
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src 0 0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %opaque %param
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %temp %dbg_src 0 0 %comp_unit %foo_name %f32_input FlagIsProtected|FlagIsPrivate
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4189,7 +3562,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-%main_name = OpString "main"
 )";
 
   const std::string size_const = R"(
@@ -4206,14 +3578,10 @@ main() {}
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %param %param
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %main_info %param
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4226,7 +3594,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-%main_name = OpString "main"
 )";
 
   const std::string size_const = R"(
@@ -4241,14 +3608,10 @@ main() {}
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src 0 0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %float_info %param
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Target must be DebugTypeComposite or "
@@ -4264,7 +3627,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-%main_name = OpString "main"
 )";
 
   const std::string size_const = R"(
@@ -4281,14 +3643,10 @@ main() {}
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %param %param
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %main_info %float_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -4306,12 +3664,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4322,15 +3674,10 @@ main() {}
 %opaque = OpExtInst %void %DbgExt DebugTypeComposite %ty_name %u32_1 %dbg_src %u32_1 %u32_1 %comp_unit %ty_name %dbg_none %u32_3
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src %u32_0 %u32_0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %opaque %param
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4344,12 +3691,6 @@ main() {}
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4361,15 +3702,10 @@ main() {}
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src %u32_0 %u32_0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %opaque %param
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %temp %dbg_src %u32_0 %u32_0 %comp_unit %foo_name %f32_input %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4382,13 +3718,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-%main_name = OpString "main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4400,15 +3729,10 @@ main() {}
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %param %param
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %main_info %param
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4421,13 +3745,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-%main_name = OpString "main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4437,15 +3754,10 @@ main() {}
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src %u32_0 %u32_0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %float_info %param
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand Target must be DebugTypeComposite or "
@@ -4461,13 +3773,6 @@ main() {}
 %float_name = OpString "float"
 %ty_name = OpString "Texture"
 %t_name = OpString "T"
-%main_name = OpString "main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4478,15 +3783,10 @@ main() {}
 %opaque = OpExtInst %void %DbgExt DebugTypeComposite %ty_name %u32_1 %dbg_src %u32_1 %u32_1 %comp_unit %ty_name %dbg_none %u32_3
 %param = OpExtInst %void %DbgExt DebugTypeTemplateParameter %t_name %float_info %dbg_none %dbg_src %u32_0 %u32_0
 %temp = OpExtInst %void %DbgExt DebugTypeTemplate %opaque %float_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
@@ -4512,14 +3812,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugGlobalVariable) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src 0 0 %comp_unit %foo_name %f32_input FlagIsProtected|FlagIsPrivate
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4542,14 +3838,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugGlobalVariableStaticMember) {
 %t = OpExtInst %void %DbgExt DebugTypeComposite %foo_name Class %dbg_src 0 0 %comp_unit %foo_name %int_32 FlagIsPublic %a
 %a = OpExtInst %void %DbgExt DebugTypeMember %foo_name %float_info %dbg_src 0 0 %t %u32_0 %int_32 FlagIsPublic
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src 0 0 %comp_unit %foo_name %f32_input FlagIsProtected|FlagIsPrivate %a
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4571,14 +3863,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugGlobalVariableDebugInfoNone) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src 0 0 %comp_unit %foo_name %dbgNone FlagIsProtected|FlagIsPrivate
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4599,14 +3887,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugGlobalVariableConst) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %int_32 Float
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src 0 0 %comp_unit %foo_name %int_32 FlagIsProtected|FlagIsPrivate
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, "", extension, "Vertex"));
+      src, size_const, dbg_inst_header, "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4632,12 +3916,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugGlobalVariable, Fail) {
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, size_const, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, size_const, ss.str(), "", opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -4672,12 +3952,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariable) {
 %code = OpString "float foo; void main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4685,15 +3959,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariable) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src %u32_0 %u32_0 %comp_unit %foo_name %f32_input %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4703,12 +3972,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariableStaticMember) {
 %code = OpString "float foo; void main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4718,15 +3981,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariableStaticMember) {
 %a = OpExtInst %void %DbgExt DebugTypeMember %foo_name %float_info %dbg_src %u32_0 %u32_0 %u32_0 %u32_32 %u32_3
 %t = OpExtInst %void %DbgExt DebugTypeComposite %foo_name %u32_1 %dbg_src %u32_0 %u32_0 %comp_unit %foo_name %u32_32 %u32_3 %a
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %t %dbg_src %u32_0 %u32_0 %comp_unit %foo_name %f32_input %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4736,12 +3994,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariableDebugInfoNone) {
 %code = OpString "float foo; void main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4750,15 +4002,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariableDebugInfoNone) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src %u32_0 %u32_0 %comp_unit %foo_name %dbgNone %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4768,12 +4015,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariableConst) {
 %code = OpString "float foo; void main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4781,15 +4022,10 @@ TEST_F(ValidateVulkan100DebugInfo, DebugGlobalVariableConst) {
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable %foo_name %float_info %dbg_src %u32_0 %u32_0 %comp_unit %foo_name %u32_32 %u32_3
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, "", extension, "Vertex"));
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4799,12 +4035,6 @@ TEST_P(ValidateVulkan100DebugInfoDebugGlobalVariable, Fail) {
 %code = OpString "float foo; void main() {}"
 %float_name = OpString "float"
 %foo_name = OpString "foo"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const auto& param = GetParam();
@@ -4817,13 +4047,8 @@ TEST_P(ValidateVulkan100DebugInfoDebugGlobalVariable, Fail) {
 %foo = OpExtInst %void %DbgExt DebugGlobalVariable )"
      << param.first;
 
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
-)";
-
-  CompileSuccessfully(GenerateShaderCodeForDebugInfo(src, constants, ss.str(),
-                                                     "", extension, "Vertex"));
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", ss.str(), "", shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -4857,29 +4082,23 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugInlinedAt) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_linkage_name FlagIsPublic 1 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %inlined_at = OpExtInst %void %DbgExt DebugInlinedAt 0 %main_info
 %inlined_at_recursive = OpExtInst %void %DbgExt DebugInlinedAt 0 %main_info %inlined_at
 )";
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %main_info %inlined_at
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4888,29 +4107,23 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugInlinedAtFail) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_linkage_name FlagIsPublic 1 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %inlined_at = OpExtInst %void %DbgExt DebugInlinedAt 0 %main_info
 %inlined_at_recursive = OpExtInst %void %DbgExt DebugInlinedAt 0 %inlined_at
 )";
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %main_info %inlined_at
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Scope"));
 }
@@ -4920,29 +4133,23 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugInlinedAtFail2) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
 )";
 
   const std::string dbg_inst_header = R"(
 %dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
 %comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit 2 4 %dbg_src HLSL
 %main_type_info = OpExtInst %void %DbgExt DebugTypeFunction FlagIsPublic %void
-%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_linkage_name FlagIsPublic 1 %main
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src 1 1 %comp_unit %main_name FlagIsPublic 1 %main
 %inlined_at = OpExtInst %void %DbgExt DebugInlinedAt 0 %main_info
 %inlined_at_recursive = OpExtInst %void %DbgExt DebugInlinedAt 0 %main_info %main_info
 )";
 
   const std::string body = R"(
 %main_scope = OpExtInst %void %DbgExt DebugScope %main_info %inlined_at
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, "", dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Inlined"));
 }
@@ -4952,14 +4159,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugInlinedAt) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -4969,11 +4168,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugInlinedAt) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %inlined_at = OpExtInst %void %DbgExt DebugInlinedAt %u32_0 %main_info
 %inlined_at_recursive = OpExtInst %void %DbgExt DebugInlinedAt %u32_0 %main_info %inlined_at
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const std::string body = R"(
@@ -4981,7 +4175,7 @@ OpExtension "SPV_KHR_non_semantic_info"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -4990,14 +4184,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugInlinedAtFail) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -5007,11 +4193,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugInlinedAtFail) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %inlined_at = OpExtInst %void %DbgExt DebugInlinedAt %u32_0 %main_info
 %inlined_at_recursive = OpExtInst %void %DbgExt DebugInlinedAt %u32_0 %inlined_at %inlined_at
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const std::string body = R"(
@@ -5019,7 +4200,7 @@ OpExtension "SPV_KHR_non_semantic_info"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Scope"));
 }
@@ -5029,14 +4210,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugInlinedAtFail2) {
 %src = OpString "simple.hlsl"
 %code = OpString "void main() {}"
 %void_name = OpString "void"
-%main_name = OpString "main"
-%main_linkage_name = OpString "v_main"
-)";
-
-  const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -5046,11 +4219,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugInlinedAtFail2) {
 %main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
 %inlined_at = OpExtInst %void %DbgExt DebugInlinedAt %u32_0 %main_info
 %inlined_at_recursive = OpExtInst %void %DbgExt DebugInlinedAt %u32_0 %main_info %main_info
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const std::string body = R"(
@@ -5058,7 +4226,7 @@ OpExtension "SPV_KHR_non_semantic_info"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(), HasSubstr("expected operand Inlined"));
 }
@@ -5087,14 +4255,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugValue) {
 
   const std::string body = R"(
 %value = OpExtInst %void %DbgExt DebugValue %foo_info %int_32 %null_expr %int_3
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, body, extension, "Vertex"));
+      src, size_const, dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -5126,14 +4290,10 @@ TEST_F(ValidateOpenCL100DebugInfo, DebugValueWithVariableIndex) {
 
   const std::string body = R"(
 %value = OpExtInst %void %DbgExt DebugValue %foo_info %int_32 %null_expr %len_info
-)";
-
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, body, extension, "Vertex"));
+      src, size_const, dbg_inst_header, body, opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -5164,12 +4324,8 @@ TEST_P(ValidateOpenCL100DebugInfoDebugValue, Fail) {
 %decl = OpExtInst %void %DbgExt DebugValue )"
      << param.first;
 
-  const std::string extension = R"(
-%DbgExt = OpExtInstImport "OpenCL.DebugInfo.100"
-)";
-
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, size_const, dbg_inst_header, ss.str(), extension, "Vertex"));
+      src, size_const, dbg_inst_header, ss.str(), opencl_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -5192,10 +4348,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugValue) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -5205,11 +4358,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugValue) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %v4float_info %dbg_src %u32_1 %u32_10 %comp_unit %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const std::string body = R"(
@@ -5217,7 +4365,7 @@ OpExtension "SPV_KHR_non_semantic_info"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, constants, dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -5232,10 +4380,7 @@ TEST_F(ValidateVulkan100DebugInfo, DebugValueWithVariableIndex) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -5247,11 +4392,6 @@ TEST_F(ValidateVulkan100DebugInfo, DebugValueWithVariableIndex) {
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %v4float_info %dbg_src %u32_1 %u32_10 %comp_unit %u32_4 %u32_0
 %len_info = OpExtInst %void %DbgExt DebugLocalVariable %len_name %int_info %dbg_src %u32_0 %u32_0 %comp_unit %u32_4
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const std::string body = R"(
@@ -5259,7 +4399,7 @@ OpExtension "SPV_KHR_non_semantic_info"
 )";
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, body, extension, "Vertex"));
+      src, constants, dbg_inst_header, body, shader_extension, "Vertex"));
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
@@ -5272,10 +4412,7 @@ TEST_P(ValidateVulkan100DebugInfoDebugValue, Fail) {
 )";
 
   const std::string constants = R"(
-%u32_4 = OpConstant %u32 4
-%u32_5 = OpConstant %u32 5
 %u32_10 = OpConstant %u32 10
-%u32_32 = OpConstant %u32 32
 )";
 
   const std::string dbg_inst_header = R"(
@@ -5285,11 +4422,6 @@ TEST_P(ValidateVulkan100DebugInfoDebugValue, Fail) {
 %float_info = OpExtInst %void %DbgExt DebugTypeBasic %float_name %u32_32 %u32_3 %u32_0
 %v4float_info = OpExtInst %void %DbgExt DebugTypeVector %float_info %u32_4
 %foo_info = OpExtInst %void %DbgExt DebugLocalVariable %foo_name %v4float_info %dbg_src %u32_1 %u32_10 %comp_unit %u32_4 %u32_0
-)";
-
-  const std::string extension = R"(
-OpExtension "SPV_KHR_non_semantic_info"
-%DbgExt = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
 )";
 
   const auto& param = GetParam();
@@ -5300,7 +4432,7 @@ OpExtension "SPV_KHR_non_semantic_info"
      << param.first;
 
   CompileSuccessfully(GenerateShaderCodeForDebugInfo(
-      src, constants, dbg_inst_header, ss.str(), extension, "Vertex"));
+      src, constants, dbg_inst_header, ss.str(), shader_extension, "Vertex"));
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("expected operand " + param.second));
@@ -5475,6 +4607,428 @@ TEST_F(ValidateVulkan100DebugInfo, VulkanDebugInfoSample) {
   ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDefinition) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDefinitionFailFunction) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_type_info %main
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunctionDefinition: expected operand Function "
+                        "must be a result id of DebugFunction"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDefinitionFailDefinition) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main_name
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunctionDefinition: expected operand Definition "
+                        "must be a result id of OpFunction"));
+}
+
+// TODO - Need to track in function scope
+TEST_F(ValidateVulkan100DebugInfo, DISABLED_DebugFunctionDefinitionDuplicate) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info1 = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+%main_info2 = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def1 = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info1 %main
+%main_def2 = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info2 %main
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunctionDefinition: Was used multiple times in "
+                        "single function block"));
+}
+
+// TODO - Need to track in function scope
+TEST_F(ValidateVulkan100DebugInfo,
+       DISABLED_DebugFunctionDefinitionDuplicateReference) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main
+OpReturn
+OpFunctionEnd
+
+%foo = OpFunction %void None %func
+%foo_entry = OpLabel
+%foo_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %foo
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunctionDefinition: Was referenced a "
+                        "DebugFunction that was already referenced before"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDefinitionWrongDefinition) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+%foo_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main
+OpReturn
+OpFunctionEnd
+
+%foo = OpFunction %void None %func
+%foo_entry = OpLabel
+%foo_def = OpExtInst %void %DbgExt DebugFunctionDefinition %foo_info %main
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunctionDefinition: operand Definition must "
+                        "point to the OpFunction it is inside"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDefinitionNonEntryBlock) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string constants = R"(
+%false = OpConstantFalse %bool
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+OpSelectionMerge %merge_block None
+OpBranchConditional %false %second_block %merge_block
+%second_block = OpLabel
+OpReturn
+%merge_block = OpLabel
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, constants, dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugFunctionDefinition: must be in the entry basic "
+                        "block of the function"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugFunctionDefinitionMultiFunctions) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%comp_unit = OpExtInst %void %DbgExt DebugCompilationUnit %u32_2 %u32_4 %dbg_src %u32_5
+%main_type_info = OpExtInst %void %DbgExt DebugTypeFunction %u32_3 %void
+%main_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+%foo_info = OpExtInst %void %DbgExt DebugFunction %main_name %main_type_info %dbg_src %u32_1 %u32_1 %comp_unit %main_name %u32_3 %u32_1
+)";
+
+  const std::string body = R"(
+%main_def = OpExtInst %void %DbgExt DebugFunctionDefinition %main_info %main
+OpReturn
+OpFunctionEnd
+
+%foo = OpFunction %void None %func
+%foo_entry = OpLabel
+%foo_def = OpExtInst %void %DbgExt DebugFunctionDefinition %foo_info %foo
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLine) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+)";
+
+  const std::string body = R"(
+%line1 = OpExtInst %void %DbgExt DebugLine %dbg_src %u32_1 %u32_2 %u32_0 %u32_0
+%line2 = OpExtInst %void %DbgExt DebugLine %dbg_src %u32_1 %u32_2 %u32_0 %u32_0
+%no_line = OpExtInst %void %DbgExt DebugNoLine
+%line3 = OpExtInst %void %DbgExt DebugLine %dbg_src %u32_1 %u32_2 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugNoLineOutOfBlock) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%no_line = OpExtInst %void %DbgExt DebugNoLine
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("debug info extension must appear in a function body"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineOutOfBlock) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%line = OpExtInst %void %DbgExt DebugLine %dbg_src %u32_1 %u32_2 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, "", shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("debug info extension must appear in a function body"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineSource) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+%int_name = OpString "int"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%int_info = OpExtInst %void %DbgExt DebugTypeBasic %int_name %u32_0 %u32_1 %u32_0
+)";
+
+  const std::string body = R"(
+%line = OpExtInst %void %DbgExt DebugLine %int_info %u32_2 %u32_2 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugLine: expected operand Source must be a result "
+                        "id of DebugSource"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineFloat) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+)";
+
+  const std::string body = R"(
+%line1 = OpExtInst %void %DbgExt DebugLine %dbg_src %f32_1 %u32_2 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugLine: expected operand Line Start must be a "
+                        "result id of 32-bit unsigned OpConstant"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineInt64) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+)";
+
+  const std::string body = R"(
+%line1 = OpExtInst %void %DbgExt DebugLine %dbg_src %u64_1 %u64_1 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugLine: expected operand Line Start must be a "
+                        "result id of 32-bit unsigned OpConstant"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineSpecConstant) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+%spec_int = OpSpecConstant %u32 2
+)";
+
+  const std::string body = R"(
+%line1 = OpExtInst %void %DbgExt DebugLine %dbg_src %spec_int %u32_1 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("DebugLine: expected operand Line Start must be a "
+                        "result id of 32-bit unsigned OpConstant"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineLineEndSmaller) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+)";
+
+  const std::string body = R"(
+%line1 = OpExtInst %void %DbgExt DebugLine %dbg_src %u32_2 %u32_1 %u32_0 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("DebugLine: operand Line End (1) is less than Line Start (2)"));
+}
+
+TEST_F(ValidateVulkan100DebugInfo, DebugLineColumnEndSmaller) {
+  const std::string src = R"(
+%src = OpString "simple.hlsl"
+%code = OpString "int main() { }"
+)";
+
+  const std::string dbg_inst_header = R"(
+%dbg_src = OpExtInst %void %DbgExt DebugSource %src %code
+)";
+
+  const std::string body = R"(
+%line1 = OpExtInst %void %DbgExt DebugLine %dbg_src %u32_1 %u32_1 %u32_1 %u32_0
+)";
+
+  CompileSuccessfully(GenerateShaderCodeForDebugInfo(
+      src, "", dbg_inst_header, body, shader_extension, "Vertex"));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "DebugLine: operand Column End (0) is less than Column Start (1)"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_ext_inst_test.cpp b/test/val/val_ext_inst_test.cpp
index 8f0bcce1..23fd3aac 100644
--- a/test/val/val_ext_inst_test.cpp
+++ b/test/val/val_ext_inst_test.cpp
@@ -447,6 +447,7 @@ OpCapability Matrix
 %u8arr_uniform_constant = OpVariable %u8arr_ptr_uniform_constant UniformConstant
 %u8_ptr_uniform_constant = OpTypePointer UniformConstant %u8
 %u8_ptr_generic = OpTypePointer Generic %u8
+%u8_ptr_input = OpTypePointer Input %u8
 
 %main = OpFunction %void None %func
 %main_entry = OpLabel
@@ -5269,6 +5270,26 @@ TEST_F(ValidateExtInst, OpenCLStdPrintfFormatNotUniformConstStorageClass) {
                         "be UniformConstant"));
 }
 
+TEST_F(ValidateExtInst,
+       OpenCLStdPrintfFormatWithExtensionNotAllowedStorageClass) {
+  const std::string body = R"(
+%format_const = OpAccessChain %u8_ptr_uniform_constant %u8arr_uniform_constant %u32_0
+%format = OpBitcast %u8_ptr_input %format_const
+%val1 = OpExtInst %u32 %extinst printf %format %u32_0 %u32_1
+)";
+
+  const std::string extension = R"(
+OpExtension  "SPV_EXT_relaxed_printf_string_address_space"
+)";
+
+  CompileSuccessfully(GenerateKernelCode(body, extension));
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpenCL.std printf: expected Format storage class to "
+                        "be UniformConstant, Crossworkgroup, Workgroup, "
+                        "Function, or Generic"));
+}
+
 TEST_F(ValidateExtInst, OpenCLStdPrintfFormatNotU8Pointer) {
   const std::string body = R"(
 %format = OpAccessChain %u32_ptr_uniform_constant %u32vec8_uniform_constant %u32_0
@@ -7472,6 +7493,82 @@ OpFunctionEnd
   }
 }
 
+TEST_F(ValidateExtInst, OpExtInstWithForwardNotAllowedSemantic) {
+  const std::string body = R"(
+             OpCapability Shader
+             OpExtension "SPV_KHR_non_semantic_info"
+             OpExtension "SPV_KHR_relaxed_extended_instruction"
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+  %extinst = OpExtInstImport "GLSL.std.450"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %2 "main"
+             OpExecutionMode %2 LocalSize 1 1 1
+        %3 = OpString "sample"
+     %void = OpTypeVoid
+     %uint = OpTypeInt 32 0
+      %f32 = OpTypeFloat 32
+   %uint_0 = OpConstant %uint 0
+    %f32_0 = OpConstant %f32 0
+    %f32_1 = OpConstant %f32 1
+        %7 = OpTypeFunction %void
+        %8 = OpExtInst %void %1 DebugSource %3 %3
+        %9 = OpExtInst %void %1 DebugCompilationUnit %uint_0 %uint_0 %8 %uint_0
+       %10 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction %uint_0 %11
+       %12 = OpExtInstWithForwardRefsKHR %void %1 DebugFunction %3 %10 %8 %uint_0 %uint_0 %11 %3 %uint_0 %uint_0
+       %11 = OpExtInst %void %1 DebugTypeComposite %3 %uint_0 %8 %uint_0 %uint_0 %9 %3 %uint_0 %uint_0 %12
+        %2 = OpFunction %void None %7
+       %13 = OpLabel
+       %18 = OpExtInstWithForwardRefsKHR %f32 %extinst FMin %f32_0 %19
+       %19 = OpExtInst %f32 %extinst FMin %f32_0 %f32_1
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(body);
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "OpExtInstWithForwardRefsKHR is only allowed with non-semantic "
+          "instructions.\n"
+          "  %18 = OpExtInstWithForwardRefsKHR %float %2 FMin %float_0 %19\n"));
+}
+
+TEST_F(ValidateExtInst, OpExtInstRequiresNonSemanticBefore16) {
+  const std::string body = R"(
+             OpCapability Shader
+             OpExtension "SPV_KHR_non_semantic_info"
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+  %extinst = OpExtInstImport "GLSL.std.450"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %2 "main"
+             OpExecutionMode %2 LocalSize 1 1 1
+        %3 = OpString "sample"
+     %void = OpTypeVoid
+     %uint = OpTypeInt 32 0
+   %uint_0 = OpConstant %uint 0
+        %7 = OpTypeFunction %void
+        %8 = OpExtInst %void %1 DebugSource %3 %3
+        %9 = OpExtInst %void %1 DebugCompilationUnit %uint_0 %uint_0 %8 %uint_0
+       %10 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction %uint_0 %11
+       %12 = OpExtInstWithForwardRefsKHR %void %1 DebugFunction %3 %10 %8 %uint_0 %uint_0 %11 %3 %uint_0 %uint_0
+       %11 = OpExtInst %void %1 DebugTypeComposite %3 %uint_0 %8 %uint_0 %uint_0 %9 %3 %uint_0 %uint_0 %12
+        %2 = OpFunction %void None %7
+       %13 = OpLabel
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(body);
+  ASSERT_EQ(SPV_ERROR_MISSING_EXTENSION, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("ExtInstWithForwardRefsKHR requires one of the following "
+                "extensions: SPV_KHR_relaxed_extended_instruction \n"
+                "  %11 = OpExtInstWithForwardRefsKHR %void %1 "
+                "DebugTypeFunction %uint_0 %12\n"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_extension_spv_khr_subgroup_uniform_control_flow.cpp b/test/val/val_extension_spv_khr_subgroup_uniform_control_flow.cpp
new file mode 100644
index 00000000..f528cb9e
--- /dev/null
+++ b/test/val/val_extension_spv_khr_subgroup_uniform_control_flow.cpp
@@ -0,0 +1,110 @@
+// Copyright (c) 2021 Google Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Tests for OpExtension validator rules.
+
+#include <string>
+#include <vector>
+
+#include "gmock/gmock.h"
+#include "source/enum_string_mapping.h"
+#include "source/extensions.h"
+#include "source/spirv_target_env.h"
+#include "test/test_fixture.h"
+#include "test/unit_spirv.h"
+#include "test/val/val_fixtures.h"
+
+namespace spvtools {
+namespace val {
+namespace {
+
+using ::testing::HasSubstr;
+using ::testing::Values;
+using ::testing::ValuesIn;
+
+using ValidateSpvKHRSubgroupUniformControlFlow = spvtest::ValidateBase<bool>;
+
+TEST_F(ValidateSpvKHRSubgroupUniformControlFlow, Valid) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpExtension "SPV_KHR_subgroup_uniform_control_flow"
+    OpMemoryModel Logical Simple
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+    OpExecutionMode %main SubgroupUniformControlFlowKHR
+    
+    %void    = OpTypeVoid
+    %void_fn = OpTypeFunction %void
+
+    %main = OpFunction %void None %void_fn
+    %entry = OpLabel
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateSpvKHRSubgroupUniformControlFlow, RequiresExtension) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpMemoryModel Logical Simple
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+    OpExecutionMode %main SubgroupUniformControlFlowKHR
+    
+    %void    = OpTypeVoid
+    %void_fn = OpTypeFunction %void
+
+    %main = OpFunction %void None %void_fn
+    %entry = OpLabel
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_NE(SPV_SUCCESS, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("2nd operand of ExecutionMode: operand "
+                        "SubgroupUniformControlFlowKHR(4421) "
+                        "requires one of these extensions: "
+                        "SPV_KHR_subgroup_uniform_control_flow"));
+}
+
+TEST_F(ValidateSpvKHRSubgroupUniformControlFlow, RequiresShaderCapability) {
+  const std::string str = R"(
+    OpCapability Kernel
+    OpCapability Addresses
+    OpExtension "SPV_KHR_subgroup_uniform_control_flow"
+    OpMemoryModel Physical32 OpenCL
+    OpEntryPoint Kernel %main "main"
+    OpExecutionMode %main SubgroupUniformControlFlowKHR
+    
+    %void    = OpTypeVoid
+    %void_fn = OpTypeFunction %void
+
+    %main = OpFunction %void None %void_fn
+    %entry = OpLabel
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_NE(SPV_SUCCESS, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Operand 2 of ExecutionMode requires one of these "
+                        "capabilities: Shader"));
+}
+
+}  // namespace
+}  // namespace val
+}  // namespace spvtools
diff --git a/test/val/val_extension_spv_nv_raw_access_chains.cpp b/test/val/val_extension_spv_nv_raw_access_chains.cpp
new file mode 100644
index 00000000..f06d7cd4
--- /dev/null
+++ b/test/val/val_extension_spv_nv_raw_access_chains.cpp
@@ -0,0 +1,510 @@
+// Copyright (c) 2024 The Khronos Group Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <string>
+
+#include "gmock/gmock.h"
+#include "source/spirv_target_env.h"
+#include "test/unit_spirv.h"
+#include "test/val/val_fixtures.h"
+
+namespace spvtools {
+namespace val {
+namespace {
+
+using ::testing::HasSubstr;
+
+using ValidateSpvNVRawAccessChains = spvtest::ValidateBase<bool>;
+
+TEST_F(ValidateSpvNVRawAccessChains, Valid) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %int_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, NoCapability) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %int_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_CAPABILITY, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("requires one of these capabilities: RawAccessChainsNV"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, NoExtension) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %int_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_MISSING_EXTENSION, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("requires one of these extensions: SPV_NV_raw_access_chains"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, ReturnTypeNotPointer) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %int %ssbo %int_16 %int_0 %int_0 RobustnessPerComponentNV
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must be OpTypePointer. Found OpTypeInt"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, Workgroup) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer Workgroup %intStruct
+    %ssbo = OpVariable %intStructPtr Workgroup
+    %intPtr = OpTypePointer Workgroup %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %int_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must point to a storage class of"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, ReturnTypeArray) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %int_1 = OpConstant %int 1
+    %intArray = OpTypeArray %int %int_1
+    %intArrayPtr = OpTypePointer StorageBuffer %intArray
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intArrayPtr %ssbo %int_16 %int_0 %int_0 RobustnessPerComponentNV
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("must not point to"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, VariableStride) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %stride = OpIAdd %int %int_0 %int_0
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %stride %int_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("must be OpConstant"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, RobustnessPerElementZeroStride) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_0 %int_0 %int_0 RobustnessPerElementNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Stride must not be zero when per-element robustness is used"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, BothRobustness) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %int_0 %int_0 RobustnessPerElementNV|RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Per-component robustness and per-element robustness "
+                        "are mutually exclusive"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, StrideFloat) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %float = OpTypeFloat 32
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %float_16 = OpConstant %float 16
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %float_16 %int_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("must be OpTypeInt"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, IndexType) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpCapability Int64
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %long = OpTypeInt 64 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+    %long_0 = OpConstant %long 0
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %long_0 %int_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("The integer width of Index"));
+}
+
+TEST_F(ValidateSpvNVRawAccessChains, OffsetType) {
+  const std::string str = R"(
+    OpCapability Shader
+    OpCapability RawAccessChainsNV
+    OpCapability Int64
+    OpExtension "SPV_KHR_storage_buffer_storage_class"
+    OpExtension "SPV_NV_raw_access_chains"
+    OpMemoryModel Logical GLSL450
+
+    OpEntryPoint GLCompute %main "main"
+    OpExecutionMode %main LocalSize 1 1 1
+
+    OpDecorate %intStruct Block
+    OpMemberDecorate %intStruct 0 Offset 0
+    OpDecorate %ssbo DescriptorSet 0
+    OpDecorate %ssbo Binding 0
+
+    %int = OpTypeInt 32 1
+    %long = OpTypeInt 64 1
+    %void = OpTypeVoid
+    %mainFunctionType = OpTypeFunction %void
+    %intStruct = OpTypeStruct %int
+    %intStructPtr = OpTypePointer StorageBuffer %intStruct
+    %ssbo = OpVariable %intStructPtr StorageBuffer
+    %intPtr = OpTypePointer StorageBuffer %int
+
+    %int_0 = OpConstant %int 0
+    %int_16 = OpConstant %int 16
+    %long_0 = OpConstant %long 0
+
+    %main = OpFunction %void None %mainFunctionType
+    %label = OpLabel
+    %rawChain = OpRawAccessChainNV %intPtr %ssbo %int_16 %int_0 %long_0 RobustnessPerComponentNV
+    %unused = OpLoad %int %rawChain
+    OpReturn
+    OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("The integer width of Offset"));
+}
+
+}  // namespace
+}  // namespace val
+}  // namespace spvtools
diff --git a/test/val/val_extensions_test.cpp b/test/val/val_extensions_test.cpp
index 0ab8c6e3..bc8e9728 100644
--- a/test/val/val_extensions_test.cpp
+++ b/test/val/val_extensions_test.cpp
@@ -61,7 +61,8 @@ INSTANTIATE_TEST_SUITE_P(
         "SPV_AMD_shader_image_load_store_lod", "SPV_AMD_shader_fragment_mask",
         "SPV_GOOGLE_decorate_string", "SPV_GOOGLE_hlsl_functionality1",
         "SPV_NV_shader_subgroup_partitioned", "SPV_EXT_descriptor_indexing",
-        "SPV_KHR_terminate_invocation"));
+        "SPV_KHR_terminate_invocation",
+        "SPV_KHR_relaxed_extended_instruction"));
 
 INSTANTIATE_TEST_SUITE_P(FailSilently, ValidateUnknownExtensions,
                          Values("ERROR_unknown_extension", "SPV_KHR_",
@@ -131,6 +132,214 @@ TEST_F(ValidateExtensionCapabilities, DeclCapabilityFailure) {
   EXPECT_THAT(getDiagnosticString(), HasSubstr("SPV_KHR_device_group"));
 }
 
+TEST_F(ValidateExtensionCapabilities,
+       DeclCapabilityFailureBlockMatchWIndowSAD) {
+  const std::string str = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %v_texcoord %fragColor %target_samp %ref_samp
+               OpExecutionMode %main OriginUpperLeft
+               OpSource GLSL 450
+               OpSourceExtension "GL_QCOM_image_processing"
+               OpSourceExtension "GL_QCOM_image_processing2"
+               OpName %main "main"
+               OpName %tgt_coords "tgt_coords"
+               OpName %v_texcoord "v_texcoord"
+               OpName %ref_coords "ref_coords"
+               OpName %blockSize "blockSize"
+               OpName %fragColor "fragColor"
+               OpName %target_samp "target_samp"
+               OpName %ref_samp "ref_samp"
+               OpDecorate %v_texcoord Location 0
+               OpDecorate %fragColor Location 0
+               OpDecorate %target_samp DescriptorSet 0
+               OpDecorate %target_samp Binding 4
+               OpDecorate %ref_samp DescriptorSet 0
+               OpDecorate %ref_samp Binding 5
+               OpDecorate %target_samp BlockMatchTextureQCOM
+               OpDecorate %target_samp BlockMatchSamplerQCOM
+               OpDecorate %ref_samp BlockMatchTextureQCOM
+               OpDecorate %ref_samp BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %v_texcoord = OpVariable %_ptr_Input_v4float Input
+     %uint_0 = OpConstant %uint 0
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+     %uint_1 = OpConstant %uint 1
+     %uint_2 = OpConstant %uint 2
+     %uint_3 = OpConstant %uint 3
+     %uint_4 = OpConstant %uint 4
+         %39 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %fragColor = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %43 = OpTypeSampledImage %42
+%_ptr_UniformConstant_43 = OpTypePointer UniformConstant %43
+%target_samp = OpVariable %_ptr_UniformConstant_43 UniformConstant
+   %ref_samp = OpVariable %_ptr_UniformConstant_43 UniformConstant
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+ %tgt_coords = OpVariable %_ptr_Function_v2uint Function
+ %ref_coords = OpVariable %_ptr_Function_v2uint Function
+  %blockSize = OpVariable %_ptr_Function_v2uint Function
+         %16 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_0
+         %17 = OpLoad %float %16
+         %18 = OpConvertFToU %uint %17
+         %20 = OpAccessChain %_ptr_Function_uint %tgt_coords %uint_0
+               OpStore %20 %18
+         %22 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_1
+         %23 = OpLoad %float %22
+         %24 = OpConvertFToU %uint %23
+         %25 = OpAccessChain %_ptr_Function_uint %tgt_coords %uint_0
+               OpStore %25 %24
+         %28 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_2
+         %29 = OpLoad %float %28
+         %30 = OpConvertFToU %uint %29
+         %31 = OpAccessChain %_ptr_Function_uint %ref_coords %uint_0
+               OpStore %31 %30
+         %33 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_3
+         %34 = OpLoad %float %33
+         %35 = OpConvertFToU %uint %34
+         %36 = OpAccessChain %_ptr_Function_uint %ref_coords %uint_1
+               OpStore %36 %35
+               OpStore %blockSize %39
+         %46 = OpLoad %43 %target_samp
+         %47 = OpLoad %v2uint %tgt_coords
+         %49 = OpLoad %43 %ref_samp
+         %50 = OpLoad %v2uint %ref_coords
+         %51 = OpLoad %v2uint %blockSize
+         %52 = OpImageBlockMatchWindowSADQCOM %v4float %46 %47 %49 %50 %51
+               OpStore %fragColor %52
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  ASSERT_EQ(SPV_ERROR_MISSING_EXTENSION, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("2nd operand of Decorate"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("requires one of these extensions"));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("SPV_QCOM_image_processing"));
+}
+
+TEST_F(ValidateExtensionCapabilities,
+       DeclCapabilityFailureBlockMatchWIndowSSD) {
+  const std::string str = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %v_texcoord %fragColor %tex2D_src1 %samp %tex2D_src2
+               OpExecutionMode %main OriginUpperLeft
+               OpSource GLSL 450
+               OpSourceExtension "GL_QCOM_image_processing"
+               OpSourceExtension "GL_QCOM_image_processing2"
+               OpName %main "main"
+               OpName %tgt_coords "tgt_coords"
+               OpName %v_texcoord "v_texcoord"
+               OpName %ref_coords "ref_coords"
+               OpName %blockSize "blockSize"
+               OpName %fragColor "fragColor"
+               OpName %tex2D_src1 "tex2D_src1"
+               OpName %samp "samp"
+               OpName %tex2D_src2 "tex2D_src2"
+               OpDecorate %v_texcoord Location 0
+               OpDecorate %fragColor Location 0
+               OpDecorate %tex2D_src1 DescriptorSet 0
+               OpDecorate %tex2D_src1 Binding 1
+               OpDecorate %samp DescriptorSet 0
+               OpDecorate %samp Binding 3
+               OpDecorate %tex2D_src2 DescriptorSet 0
+               OpDecorate %tex2D_src2 Binding 2
+               OpDecorate %tex2D_src1 BlockMatchTextureQCOM
+               OpDecorate %samp BlockMatchSamplerQCOM
+               OpDecorate %tex2D_src2 BlockMatchTextureQCOM
+               OpDecorate %samp BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %v_texcoord = OpVariable %_ptr_Input_v4float Input
+     %uint_0 = OpConstant %uint 0
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+     %uint_1 = OpConstant %uint 1
+     %uint_2 = OpConstant %uint 2
+     %uint_3 = OpConstant %uint 3
+     %uint_4 = OpConstant %uint 4
+         %39 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %fragColor = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %tex2D_src1 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %samp = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %tex2D_src2 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+ %tgt_coords = OpVariable %_ptr_Function_v2uint Function
+ %ref_coords = OpVariable %_ptr_Function_v2uint Function
+  %blockSize = OpVariable %_ptr_Function_v2uint Function
+         %16 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_0
+         %17 = OpLoad %float %16
+         %18 = OpConvertFToU %uint %17
+         %20 = OpAccessChain %_ptr_Function_uint %tgt_coords %uint_0
+               OpStore %20 %18
+         %22 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_1
+         %23 = OpLoad %float %22
+         %24 = OpConvertFToU %uint %23
+         %25 = OpAccessChain %_ptr_Function_uint %tgt_coords %uint_0
+               OpStore %25 %24
+         %28 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_2
+         %29 = OpLoad %float %28
+         %30 = OpConvertFToU %uint %29
+         %31 = OpAccessChain %_ptr_Function_uint %ref_coords %uint_0
+               OpStore %31 %30
+         %33 = OpAccessChain %_ptr_Input_float %v_texcoord %uint_3
+         %34 = OpLoad %float %33
+         %35 = OpConvertFToU %uint %34
+         %36 = OpAccessChain %_ptr_Function_uint %ref_coords %uint_1
+               OpStore %36 %35
+               OpStore %blockSize %39
+         %45 = OpLoad %42 %tex2D_src1
+         %49 = OpLoad %46 %samp
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %tgt_coords
+         %54 = OpLoad %42 %tex2D_src2
+         %55 = OpLoad %46 %samp
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %ref_coords
+         %58 = OpLoad %v2uint %blockSize
+         %59 = OpImageBlockMatchWindowSSDQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %fragColor %59
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(str.c_str());
+  ASSERT_EQ(SPV_ERROR_MISSING_EXTENSION, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("2nd operand of Decorate"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("requires one of these extensions"));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("SPV_QCOM_image_processing"));
+}
+
 using ValidateAMDShaderBallotCapabilities = spvtest::ValidateBase<std::string>;
 
 // Returns a vector of strings for the prefix of a SPIR-V assembly shader
@@ -342,6 +551,44 @@ INSTANTIATE_TEST_SUITE_P(
     }));
 // clang-format on
 
+using ValidateRelaxedExtendedInstructionExt = spvtest::ValidateBase<bool>;
+
+TEST_F(ValidateRelaxedExtendedInstructionExt, RequiresExtension) {
+  const std::string str = R"(
+             OpCapability Shader
+             OpExtension "SPV_KHR_non_semantic_info"
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %2 "main"
+             OpExecutionMode %2 LocalSize 1 1 1
+        %3 = OpString "sample"
+     %void = OpTypeVoid
+     %uint = OpTypeInt 32 0
+   %uint_0 = OpConstant %uint 0
+        %7 = OpTypeFunction %void
+        %8 = OpExtInst %void %1 DebugSource %3 %3
+        %9 = OpExtInst %void %1 DebugCompilationUnit %uint_0 %uint_0 %8 %uint_0
+       %10 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction %uint_0 %11
+       %12 = OpExtInstWithForwardRefsKHR %void %1 DebugFunction %3 %10 %8 %uint_0 %uint_0 %11 %3 %uint_0 %uint_0
+       %11 = OpExtInst %void %1 DebugTypeComposite %3 %uint_0 %8 %uint_0 %uint_0 %9 %3 %uint_0 %uint_0 %12
+        %2 = OpFunction %void None %7
+       %13 = OpLabel
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(str.c_str());
+  EXPECT_NE(SPV_SUCCESS, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "ExtInstWithForwardRefsKHR requires one of the following extensions:"
+          " SPV_KHR_relaxed_extended_instruction \n"
+          "  %10 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction "
+          "%uint_0 "
+          "%11\n"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_fixtures.h b/test/val/val_fixtures.h
index 98d8d32a..db9d0452 100644
--- a/test/val/val_fixtures.h
+++ b/test/val/val_fixtures.h
@@ -76,6 +76,8 @@ class ValidateBase : public ::testing::Test,
     diagnostic_ = nullptr;
   }
 
+  void SetAssembleOptions(uint32_t options) { assemble_options_ = options; }
+
   std::string getDiagnosticString();
   spv_position_t getErrorPosition();
   spv_validator_options getValidatorOptions();
@@ -84,6 +86,7 @@ class ValidateBase : public ::testing::Test,
   spv_diagnostic diagnostic_;
   spv_validator_options options_;
   std::unique_ptr<spvtools::val::ValidationState_t> vstate_;
+  uint32_t assemble_options_ = SPV_TEXT_TO_BINARY_OPTION_NONE;
 };
 
 template <typename T>
@@ -132,8 +135,9 @@ void ValidateBase<T>::CompileSuccessfully(std::string code,
   DestroyBinary();
   spv_diagnostic diagnostic = nullptr;
   ScopedContext context(env);
-  auto status = spvTextToBinary(context.context, code.c_str(), code.size(),
-                                &binary_, &diagnostic);
+  auto status =
+      spvTextToBinaryWithOptions(context.context, code.c_str(), code.size(),
+                                 assemble_options_, &binary_, &diagnostic);
   EXPECT_EQ(SPV_SUCCESS, status)
       << "ERROR: " << diagnostic->error
       << "\nSPIR-V could not be compiled into binary:\n"
diff --git a/test/val/val_function_test.cpp b/test/val/val_function_test.cpp
index 24b52638..119edd3e 100644
--- a/test/val/val_function_test.cpp
+++ b/test/val/val_function_test.cpp
@@ -836,6 +836,113 @@ TEST_F(ValidateFunctionCall, LogicallyMismatchedPointersArraySize) {
               HasSubstr("type does not match Function <id>"));
 }
 
+TEST_F(ValidateFunctionCall, UntypedPointerParameterMismatch) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %var "var"
+OpName %ptr2 "ptr2"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%ptr = OpTypeUntypedPointerKHR Private
+%ptr2 = OpTypeUntypedPointerKHR Private
+%var = OpUntypedVariableKHR %ptr Private %int
+%void_fn = OpTypeFunction %void
+%ptr_fn = OpTypeFunction %void %ptr2
+%foo = OpFunction %void None %ptr_fn
+%param = OpFunctionParameter %ptr2
+%first = OpLabel
+OpReturn
+OpFunctionEnd
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%call = OpFunctionCall %void %foo %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpFunctionCall Argument <id> '2[%var]'s type does not "
+                        "match Function <id> '3[%ptr2]'s parameter type"));
+}
+
+TEST_F(ValidateFunctionCall, UntypedPointerParameterGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %var "var"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%ptr = OpTypeUntypedPointerKHR Private
+%var = OpUntypedVariableKHR %ptr Private %int
+%void_fn = OpTypeFunction %void
+%ptr_fn = OpTypeFunction %void %ptr
+%foo = OpFunction %void None %ptr_fn
+%param = OpFunctionParameter %ptr
+%first = OpLabel
+OpReturn
+OpFunctionEnd
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%call = OpFunctionCall %void %foo %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateFunctionCall,
+       UntypedPointerParameterNotMemoryObjectDeclaration) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %var "var"
+OpName %gep "gep"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Private
+%var = OpUntypedVariableKHR %ptr Private %int
+%void_fn = OpTypeFunction %void
+%ptr_fn = OpTypeFunction %void %ptr
+%foo = OpFunction %void None %ptr_fn
+%param = OpFunctionParameter %ptr
+%first = OpLabel
+OpReturn
+OpFunctionEnd
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = OpUntypedAccessChainKHR %ptr %struct %var %int_0
+%call = OpFunctionCall %void %foo %gep
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Pointer operand '3[%gep]' must be a memory object declaration"));
+}
+
 INSTANTIATE_TEST_SUITE_P(StorageClass, ValidateFunctionCall,
                          Values("UniformConstant", "Input", "Uniform", "Output",
                                 "Workgroup", "Private", "Function",
diff --git a/test/val/val_id_test.cpp b/test/val/val_id_test.cpp
index 7acac563..1e050183 100644
--- a/test/val/val_id_test.cpp
+++ b/test/val/val_id_test.cpp
@@ -578,9 +578,8 @@ TEST_P(ValidateIdWithMessage, OpEntryPointInterfaceIsNotVariableTypeBad) {
   CompileSuccessfully(spirv);
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr(make_message(
-                  "Interfaces passed to OpEntryPoint must be of type "
-                  "OpTypeVariable. Found OpTypePointer.")));
+              HasSubstr("Interfaces passed to OpEntryPoint must be variables. "
+                        "Found OpTypePointer."));
 }
 
 TEST_P(ValidateIdWithMessage, OpEntryPointInterfaceStorageClassBad) {
@@ -1056,7 +1055,7 @@ TEST_P(ValidateIdWithMessage, OpTypeArrayLengthNull) {
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr(make_message("OpTypeArray Length <id> '2[%2]' default "
-                                     "value must be at least 1.")));
+                                     "value must be at least 1: found 0")));
 }
 
 TEST_P(ValidateIdWithMessage, OpTypeArrayLengthSpecConst) {
@@ -1167,6 +1166,160 @@ TEST_P(ValidateIdWithMessage, OpTypePointerBad) {
                              "type.")));
 }
 
+TEST_P(ValidateIdWithMessage, OpTypePointerCanHaveUntypedPointer) {
+  const std::string spirv = R"(
+OpCapability Kernel
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical OpenCL
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%ptr2 = OpTypePointer Private %ptr
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerWorkgroupGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%ptr = OpTypeUntypedPointerKHR Workgroup
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_P(ValidateIdWithMessage,
+       OpTypeUntypedPointerWorkgroupMissingExplicitLayout) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Workgroup storage class untyped pointers in Vulkan require "
+                "WorkgroupMemoryExplicitLayoutKHR be declared"));
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerWorkgroupGoodAll) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%ptr = OpTypeUntypedPointerKHR Workgroup
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerStorageBufferGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerUniformGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%ptr = OpTypeUntypedPointerKHR Uniform
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerPushConstantGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%ptr = OpTypeUntypedPointerKHR PushConstant
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerCrossWorkgroupGood) {
+  const std::string spirv = R"(
+OpCapability Kernel
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical OpenCL
+%ptr = OpTypeUntypedPointerKHR CrossWorkgroup
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateIdWithMessage, OpTypeUntypedPointerVulkanInvalidStorageClass) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%ptr = OpTypeUntypedPointerKHR Private
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("In Vulkan, untyped pointers can only be used in an "
+                        "explicitly laid out storage class"));
+}
+
 TEST_P(ValidateIdWithMessage, OpTypeFunctionGood) {
   std::string spirv = kGLSL450MemoryModel + R"(
 %1 = OpTypeVoid
@@ -2270,9 +2423,8 @@ OpFunctionEnd
   CompileSuccessfully(spirv.c_str());
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr(make_message(
-                  "OpVariable Initializer <id> '8[%8]' is not a constant "
-                  "or module-scope variable")));
+              HasSubstr("Variable Initializer <id> '8[%8]' is not a constant "
+                        "or module-scope variable"));
 }
 
 TEST_P(ValidateIdWithMessage, OpVariableInitializerIsModuleVarGood) {
@@ -4225,7 +4377,7 @@ OpReturn
 OpFunctionEnd
   )";
   const std::string expected_err = "Index is out of bounds: " + instr +
-                                   " can not find index 3 into the structure "
+                                   " cannot find index 3 into the structure "
                                    "<id> '25[%_struct_25]'. This structure "
                                    "has 3 members. Largest valid index is 2.";
   CompileSuccessfully(spirv);
@@ -6404,9 +6556,10 @@ OpMemoryModel Logical VulkanKHR
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
 %9 = OpTypeFunction %1
+%12 = OpConstant %2 4
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 NonPrivatePointerKHR|MakePointerAvailableKHR %7
+OpCopyMemorySized %4 %6 %12 NonPrivatePointerKHR|MakePointerAvailableKHR %7
 OpReturn
 OpFunctionEnd
 )";
@@ -6431,10 +6584,11 @@ OpMemoryModel Logical VulkanKHR
 %6 = OpVariable %5 Uniform
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
+%12 = OpConstant %2 4
 %9 = OpTypeFunction %1
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 NonPrivatePointerKHR|MakePointerVisibleKHR %8
+OpCopyMemorySized %4 %6 %12 NonPrivatePointerKHR|MakePointerVisibleKHR %8
 OpReturn
 OpFunctionEnd
 )";
@@ -6460,10 +6614,11 @@ OpMemoryModel Logical VulkanKHR
 %6 = OpVariable %5 Uniform
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
+%12 = OpConstant %2 4
 %9 = OpTypeFunction %1
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 NonPrivatePointerKHR|MakePointerAvailableKHR|MakePointerVisibleKHR %7 %8
+OpCopyMemorySized %4 %6 %12 NonPrivatePointerKHR|MakePointerAvailableKHR|MakePointerVisibleKHR %7 %8
 OpReturn
 OpFunctionEnd
 )";
@@ -6489,10 +6644,11 @@ OpMemoryModel Logical VulkanKHR
 %6 = OpVariable %5 Uniform
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
+%12 = OpConstant %2 4
 %9 = OpTypeFunction %1
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 MakePointerAvailableKHR %7
+OpCopyMemorySized %4 %6 %12 MakePointerAvailableKHR %7
 OpReturn
 OpFunctionEnd
 )";
@@ -6522,10 +6678,11 @@ OpMemoryModel Logical VulkanKHR
 %6 = OpVariable %5 Uniform
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
+%12 = OpConstant %2 4
 %9 = OpTypeFunction %1
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 MakePointerVisibleKHR %8
+OpCopyMemorySized %4 %6 %12 MakePointerVisibleKHR %8
 OpReturn
 OpFunctionEnd
 )";
@@ -6555,10 +6712,11 @@ OpMemoryModel Logical VulkanKHR
 %6 = OpVariable %5 Uniform
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
+%12 = OpConstant %2 4
 %9 = OpTypeFunction %1
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 NonPrivatePointerKHR
+OpCopyMemorySized %4 %6 %12 NonPrivatePointerKHR
 OpReturn
 OpFunctionEnd
 )";
@@ -6589,10 +6747,11 @@ OpMemoryModel Logical VulkanKHR
 %6 = OpVariable %5 Input
 %7 = OpConstant %2 2
 %8 = OpConstant %2 5
+%12 = OpConstant %2 4
 %9 = OpTypeFunction %1
 %10 = OpFunction %1 None %9
 %11 = OpLabel
-OpCopyMemorySized %4 %6 %7 NonPrivatePointerKHR
+OpCopyMemorySized %4 %6 %12 NonPrivatePointerKHR
 OpReturn
 OpFunctionEnd
 )";
@@ -6907,6 +7066,114 @@ TEST_P(ValidateIdWithMessage, NVBindlessSamplerInStruct) {
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
 }
 
+TEST_P(ValidateIdWithMessage,
+       OpExtInstWithForwardRefsKHRDisallowedNoForwardRef) {
+  std::string spirv = R"(
+             OpCapability Shader
+             OpExtension "SPV_KHR_non_semantic_info"
+             OpExtension "SPV_KHR_relaxed_extended_instruction"
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %main "main"
+             OpExecutionMode %main LocalSize 1 1 1
+     %void = OpTypeVoid
+%main_type = OpTypeFunction %void
+        %4 = OpExtInstWithForwardRefsKHR %void %1 DebugInfoNone
+     %main = OpFunction %void None %main_type
+        %5 = OpLabel
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_6);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_6));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(make_message("Opcode OpExtInstWithForwardRefsKHR must have at "
+                             "least one forward declared ID.")));
+}
+
+TEST_P(ValidateIdWithMessage, OpExtInstNoForwardRef) {
+  std::string spirv = R"(
+             OpCapability Shader
+             OpExtension "SPV_KHR_non_semantic_info"
+             OpExtension "SPV_KHR_relaxed_extended_instruction"
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %main "main"
+             OpExecutionMode %main LocalSize 1 1 1
+     %void = OpTypeVoid
+%main_type = OpTypeFunction %void
+        %4 = OpExtInst %void %1 DebugInfoNone
+     %main = OpFunction %void None %main_type
+        %5 = OpLabel
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_6);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_6));
+}
+
+TEST_P(ValidateIdWithMessage,
+       OpExtInstWithForwardRefsKHRAllowedForwardReferenceInNonSemantic) {
+  std::string spirv = R"(
+             OpCapability Shader
+             OpExtension "SPV_KHR_non_semantic_info"
+             OpExtension "SPV_KHR_relaxed_extended_instruction"
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %2 "main"
+             OpExecutionMode %2 LocalSize 1 1 1
+        %3 = OpString "sample"
+     %void = OpTypeVoid
+     %uint = OpTypeInt 32 0
+   %uint_0 = OpConstant %uint 0
+        %7 = OpTypeFunction %void
+        %8 = OpExtInst %void %1 DebugSource %3 %3
+        %9 = OpExtInst %void %1 DebugCompilationUnit %uint_0 %uint_0 %8 %uint_0
+       %10 = OpExtInstWithForwardRefsKHR %void %1 DebugTypeFunction %uint_0 %11
+       %12 = OpExtInstWithForwardRefsKHR %void %1 DebugFunction %3 %10 %8 %uint_0 %uint_0 %11 %3 %uint_0 %uint_0
+       %11 = OpExtInst %void %1 DebugTypeComposite %3 %uint_0 %8 %uint_0 %uint_0 %9 %3 %uint_0 %uint_0 %12
+        %2 = OpFunction %void None %7
+       %13 = OpLabel
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_6);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_6));
+}
+
+TEST_P(ValidateIdWithMessage, OpExtInstNoForwardDeclAllowed) {
+  std::string spirv = R"(
+             OpCapability Shader
+        %1 = OpExtInstImport "NonSemantic.Shader.DebugInfo.100"
+             OpMemoryModel Logical GLSL450
+             OpEntryPoint GLCompute %2 "main"
+             OpExecutionMode %2 LocalSize 1 1 1
+        %3 = OpString "sample"
+     %void = OpTypeVoid
+     %uint = OpTypeInt 32 0
+   %uint_0 = OpConstant %uint 0
+        %7 = OpTypeFunction %void
+        %8 = OpExtInst %void %1 DebugSource %3 %3
+        %9 = OpExtInst %void %1 DebugCompilationUnit %uint_0 %uint_0 %8 %uint_0
+       %10 = OpExtInst %void %1 DebugTypeFunction %uint_0 %11
+       %12 = OpExtInst %void %1 DebugFunction %3 %10 %8 %uint_0 %uint_0 %11 %3 %uint_0 %uint_0
+       %11 = OpExtInst %void %1 DebugTypeComposite %3 %uint_0 %8 %uint_0 %uint_0 %9 %3 %uint_0 %uint_0 %12
+        %2 = OpFunction %void None %7
+       %13 = OpLabel
+             OpReturn
+             OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_6);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_6));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr(make_message("ID '11[%11]' has not been defined")));
+}
+
 INSTANTIATE_TEST_SUITE_P(, ValidateIdWithMessage, ::testing::Bool());
 
 }  // namespace
diff --git a/test/val/val_image_test.cpp b/test/val/val_image_test.cpp
index 9a704098..93fab045 100644
--- a/test/val/val_image_test.cpp
+++ b/test/val/val_image_test.cpp
@@ -786,6 +786,21 @@ TEST_F(ValidateImage, TypeImageWrongArrayForSubpassDataVulkan) {
               HasSubstr("Dim SubpassData requires Arrayed to be 0"));
 }
 
+TEST_F(ValidateImage, TypeImageDimRectVulkan) {
+  const std::string code = GetShaderHeader("OpCapability InputAttachment\n") +
+                           R"(
+%img_type = OpTypeImage %f32 Rect 0 1 0 2 Unknown
+)" + TrivialMain();
+
+  CompileSuccessfully(code.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_CAPABILITY,
+            ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  // Can't actually hit VUID-StandaloneSpirv-OpTypeImage-09638
+  EXPECT_THAT(
+      getDiagnosticString(),
+      AnyVUID("TypeImage requires one of these capabilities: SampledRect"));
+}
+
 TEST_F(ValidateImage, TypeImageWrongSampledTypeForTileImageDataEXT) {
   const std::string code = GetShaderHeader(
                                "OpCapability TileImageColorReadAccessEXT\n"
@@ -1365,7 +1380,7 @@ TEST_F(ValidateImage, ImageTexelPointerResultTypeNotPointer) {
   CompileSuccessfully(GenerateShaderCode(body).c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Expected Result Type to be OpTypePointer"));
+              HasSubstr("Expected Result Type to be a pointer"));
 }
 
 TEST_F(ValidateImage, ImageTexelPointerResultTypeNotImageClass) {
@@ -1377,7 +1392,7 @@ TEST_F(ValidateImage, ImageTexelPointerResultTypeNotImageClass) {
   CompileSuccessfully(GenerateShaderCode(body).c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Expected Result Type to be OpTypePointer whose "
+              HasSubstr("Expected Result Type to be a pointer whose "
                         "Storage Class operand is Image"));
 }
 
@@ -1391,7 +1406,7 @@ TEST_F(ValidateImage, ImageTexelPointerResultTypeNotNumericNorVoid) {
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
-      HasSubstr("Expected Result Type to be OpTypePointer whose Type operand "
+      HasSubstr("Expected Result Type to be a pointer whose Type operand "
                 "must be a scalar numerical type or OpTypeVoid"));
 }
 
@@ -4436,7 +4451,7 @@ TEST_F(ValidateImage, QuerySizeNotImage) {
   const std::string body = R"(
 %img = OpLoad %type_image_f32_2d_0011 %uniform_image_f32_2d_0011
 %sampler = OpLoad %type_sampler %uniform_sampler
-%simg = OpSampledImage %type_sampled_image_f32_2d_0001 %img %sampler
+%simg = OpSampledImage %type_sampled_image_f32_2d_0011 %img %sampler
 %res1 = OpImageQuerySize %u32vec2 %sampler
 )";
 
@@ -4450,7 +4465,7 @@ TEST_F(ValidateImage, QuerySizeSampledImageDirectly) {
   const std::string body = R"(
 %img = OpLoad %type_image_f32_2d_0011 %uniform_image_f32_2d_0011
 %sampler = OpLoad %type_sampler %uniform_sampler
-%simg = OpSampledImage %type_sampled_image_f32_2d_0001 %img %sampler
+%simg = OpSampledImage %type_sampled_image_f32_2d_0011 %img %sampler
 %res1 = OpImageQuerySize %u32vec2 %simg
 )";
 
@@ -4765,7 +4780,8 @@ TEST_F(ValidateImage, QueryLodWrongExecutionModel) {
   EXPECT_THAT(
       getDiagnosticString(),
       HasSubstr(
-          "OpImageQueryLod requires Fragment or GLCompute execution model"));
+          "OpImageQueryLod requires Fragment, GLCompute, MeshEXT or TaskEXT "
+          "execution model"));
 }
 
 TEST_F(ValidateImage, QueryLodWrongExecutionModelWithFunc) {
@@ -4786,7 +4802,8 @@ OpFunctionEnd
   EXPECT_THAT(
       getDiagnosticString(),
       HasSubstr(
-          "OpImageQueryLod requires Fragment or GLCompute execution model"));
+          "OpImageQueryLod requires Fragment, GLCompute, MeshEXT or TaskEXT "
+          "execution model"));
 }
 
 TEST_F(ValidateImage, QueryLodComputeShaderDerivatives) {
@@ -4798,12 +4815,12 @@ TEST_F(ValidateImage, QueryLodComputeShaderDerivatives) {
 )";
 
   const std::string extra = R"(
-OpCapability ComputeDerivativeGroupLinearNV
-OpExtension "SPV_NV_compute_shader_derivatives"
+OpCapability ComputeDerivativeGroupLinearKHR
+OpExtension "SPV_KHR_compute_shader_derivatives"
 )";
   const std::string mode = R"(
 OpExecutionMode %main LocalSize 8 8 1
-OpExecutionMode %main DerivativeGroupLinearNV
+OpExecutionMode %main DerivativeGroupLinearKHR
 )";
   CompileSuccessfully(
       GenerateShaderCode(body, extra, "GLCompute", mode).c_str());
@@ -4915,8 +4932,8 @@ TEST_F(ValidateImage, QueryLodComputeShaderDerivativesMissingMode) {
 )";
 
   const std::string extra = R"(
-OpCapability ComputeDerivativeGroupLinearNV
-OpExtension "SPV_NV_compute_shader_derivatives"
+OpCapability ComputeDerivativeGroupLinearKHR
+OpExtension "SPV_KHR_compute_shader_derivatives"
 )";
   const std::string mode = R"(
 OpExecutionMode %main LocalSize 8 8 1
@@ -4925,9 +4942,9 @@ OpExecutionMode %main LocalSize 8 8 1
       GenerateShaderCode(body, extra, "GLCompute", mode).c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("OpImageQueryLod requires DerivativeGroupQuadsNV or "
-                        "DerivativeGroupLinearNV execution mode for GLCompute "
-                        "execution model"));
+              HasSubstr("OpImageQueryLod requires DerivativeGroupQuadsKHR or "
+                        "DerivativeGroupLinearKHR execution mode for "
+                        "GLCompute, MeshEXT or TaskEXT execution model"));
 }
 
 TEST_F(ValidateImage, ImplicitLodWrongExecutionModel) {
@@ -4941,8 +4958,8 @@ TEST_F(ValidateImage, ImplicitLodWrongExecutionModel) {
   CompileSuccessfully(GenerateShaderCode(body, "", "Vertex").c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("ImplicitLod instructions require Fragment or "
-                        "GLCompute execution model"));
+              HasSubstr("ImplicitLod instructions require Fragment, "
+                        "GLCompute, MeshEXT or TaskEXT execution model"));
 }
 
 TEST_F(ValidateImage, ImplicitLodComputeShaderDerivatives) {
@@ -4954,12 +4971,12 @@ TEST_F(ValidateImage, ImplicitLodComputeShaderDerivatives) {
 )";
 
   const std::string extra = R"(
-OpCapability ComputeDerivativeGroupLinearNV
-OpExtension "SPV_NV_compute_shader_derivatives"
+OpCapability ComputeDerivativeGroupLinearKHR
+OpExtension "SPV_KHR_compute_shader_derivatives"
 )";
   const std::string mode = R"(
 OpExecutionMode %main LocalSize 8 8 1
-OpExecutionMode %main DerivativeGroupLinearNV
+OpExecutionMode %main DerivativeGroupLinearKHR
 )";
   CompileSuccessfully(
       GenerateShaderCode(body, extra, "GLCompute", mode).c_str());
@@ -4975,8 +4992,8 @@ TEST_F(ValidateImage, ImplicitLodComputeShaderDerivativesMissingMode) {
 )";
 
   const std::string extra = R"(
-OpCapability ComputeDerivativeGroupLinearNV
-OpExtension "SPV_NV_compute_shader_derivatives"
+OpCapability ComputeDerivativeGroupLinearKHR
+OpExtension "SPV_KHR_compute_shader_derivatives"
 )";
   const std::string mode = R"(
 OpExecutionMode %main LocalSize 8 8 1
@@ -4986,9 +5003,9 @@ OpExecutionMode %main LocalSize 8 8 1
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(
       getDiagnosticString(),
-      HasSubstr("ImplicitLod instructions require DerivativeGroupQuadsNV or "
-                "DerivativeGroupLinearNV execution mode for GLCompute "
-                "execution model"));
+      HasSubstr("ImplicitLod instructions require DerivativeGroupQuadsKHR or "
+                "DerivativeGroupLinearKHR execution mode for GLCompute, "
+                "MeshEXT or TaskEXT execution model"));
 }
 
 TEST_F(ValidateImage, ReadSubpassDataWrongExecutionModel) {
@@ -6293,7 +6310,7 @@ TEST_F(ValidateImage, ImageTexelPointer64ResultTypeNotPointer) {
           .c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Expected Result Type to be OpTypePointer"));
+              HasSubstr("Expected Result Type to be a pointer"));
 }
 
 TEST_F(ValidateImage, ImageTexelPointer64ResultTypeNotImageClass) {
@@ -6309,7 +6326,7 @@ TEST_F(ValidateImage, ImageTexelPointer64ResultTypeNotImageClass) {
           .c_str());
   ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Expected Result Type to be OpTypePointer whose "
+              HasSubstr("Expected Result Type to be a pointer whose "
                         "Storage Class operand is Image"));
 }
 
@@ -6490,8 +6507,9 @@ OpFunctionEnd
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("ImplicitLod instructions require "
-                        "DerivativeGroupQuadsNV or DerivativeGroupLinearNV "
-                        "execution mode for GLCompute execution model"));
+                        "DerivativeGroupQuadsKHR or DerivativeGroupLinearKHR "
+                        "execution mode for GLCompute, MeshEXT or TaskEXT "
+                        "execution model"));
 }
 
 TEST_F(ValidateImage, TypeSampledImageNotBufferPost1p6) {
@@ -6733,7 +6751,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationA) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationB) {
@@ -6792,7 +6811,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationB) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationC) {
@@ -6844,7 +6864,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationC) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationD) {
@@ -6896,7 +6917,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADNoDecorationD) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationA) {
@@ -6955,7 +6977,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationA) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationB) {
@@ -7014,7 +7037,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationB) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationC) {
@@ -7066,7 +7090,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationC) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationD) {
@@ -7118,7 +7143,8 @@ TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSSDNoDecorationD) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingSampleWeightedNoDecorationA) {
@@ -7177,7 +7203,8 @@ TEST_F(ValidateImage, QCOMImageProcessingSampleWeightedNoDecorationA) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration WeightTextureQCOM"));
 }
 
 TEST_F(ValidateImage, QCOMImageProcessingSampleWeightedNoDecorationB) {
@@ -7230,10 +7257,11 @@ TEST_F(ValidateImage, QCOMImageProcessingSampleWeightedNoDecorationB) {
   CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
   EXPECT_EQ(SPV_ERROR_INVALID_DATA,
             ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
-  EXPECT_THAT(getDiagnosticString(), HasSubstr("Missing decoration"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration WeightTextureQCOM"));
 }
 
-TEST_F(ValidateImage, QCOMImageProcessingBlockMatchSADInvalidUseA) {
+TEST_F(ValidateImage, QCOMImageProcessingBlockMatchWindowSADInvalidUseA) {
   std::string text = R"(
 ; SPIR-V
 ; Version: 1.0
@@ -7936,114 +7964,2937 @@ TEST_F(ValidateImage, QCOMImageProcessingSampleWeightedInvalidUseB) {
       HasSubstr("Illegal use of QCOM image processing decorated texture"));
 }
 
-TEST_F(ValidateImage, ImageMSArray_ArrayedSampledTypeRequiresCapability) {
-  const std::string code = R"(
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorTargetIT) {
+  const std::string text = R"(
                OpCapability Shader
-               OpCapability StorageImageMultisample
-               OpCapability StorageImageReadWithoutFormat
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
                OpMemoryModel Logical GLSL450
-               OpEntryPoint Fragment %main "main"
-               OpExecutionMode %main OriginUpperLeft
-               OpDecorate %var_image DescriptorSet 0
-               OpDecorate %var_image Binding 1
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchSamplerQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
        %void = OpTypeVoid
-       %func = OpTypeFunction %void
-        %f32 = OpTypeFloat 32
-        %u32 = OpTypeInt 32 0
-     %uint_2 = OpConstant %u32 2
-     %uint_1 = OpConstant %u32 1
-     %v2uint = OpTypeVector %u32 2
-    %v4float = OpTypeVector %f32 4
-    %image = OpTypeImage %f32 2D 2 1 1 2 Unknown
-%ptr_image = OpTypePointer UniformConstant %image
-       %10 = OpConstantComposite %v2uint %uint_1 %uint_2
-%var_image = OpVariable %ptr_image UniformConstant
-     %main = OpFunction %void None %func
- %main_lab = OpLabel
-       %18 = OpLoad %image %var_image
-       %19 = OpImageRead %v4float %18 %10 Sample %uint_2
-             OpReturn
-             OpFunctionEnd
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSADQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
 )";
-
-  const spv_target_env env = SPV_ENV_VULKAN_1_0;
-  CompileSuccessfully(code, env);
-  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
-  EXPECT_THAT(
-      getDiagnosticString(),
-      HasSubstr("Capability ImageMSArray is required to access storage image"));
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
 }
 
-TEST_F(ValidateImage, ImageMSArray_SampledTypeDoesNotRequireCapability) {
-  const std::string code = R"(
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorTargetIS) {
+  const std::string text = R"(
                OpCapability Shader
-               OpCapability StorageImageMultisample
-               OpCapability StorageImageReadWithoutFormat
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
                OpMemoryModel Logical GLSL450
-               OpEntryPoint Fragment %main "main"
-               OpExecutionMode %main OriginUpperLeft
-               OpDecorate %var_image DescriptorSet 0
-               OpDecorate %var_image Binding 1
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
        %void = OpTypeVoid
-       %func = OpTypeFunction %void
-        %f32 = OpTypeFloat 32
-        %u32 = OpTypeInt 32 0
-     %uint_2 = OpConstant %u32 2
-     %uint_1 = OpConstant %u32 1
-     %v2uint = OpTypeVector %u32 2
-    %v4float = OpTypeVector %f32 4
-    %image = OpTypeImage %f32 2D 2 0 1 2 Unknown
-%ptr_image = OpTypePointer UniformConstant %image
-       %10 = OpConstantComposite %v2uint %uint_1 %uint_2
-%var_image = OpVariable %ptr_image UniformConstant
-     %main = OpFunction %void None %func
- %main_lab = OpLabel
-       %18 = OpLoad %image %var_image
-       %19 = OpImageRead %v4float %18 %10 Sample %uint_2
-             OpReturn
-             OpFunctionEnd
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSADQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
 )";
-
-  const spv_target_env env = SPV_ENV_VULKAN_1_0;
-  CompileSuccessfully(code, env);
-  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions(env));
-  EXPECT_THAT(getDiagnosticString(), Eq(""));
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
 }
 
-TEST_F(ValidateImage, ImageMSArray_ArrayedTypeDoesNotRequireCapability) {
-  const std::string code = R"(
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorRefIT) {
+  const std::string text = R"(
                OpCapability Shader
-               OpCapability StorageImageReadWithoutFormat
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
                OpMemoryModel Logical GLSL450
-               OpEntryPoint Fragment %main "main"
-               OpExecutionMode %main OriginUpperLeft
-               OpDecorate %var_image DescriptorSet 0
-               OpDecorate %var_image Binding 1
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %4 BlockMatchSamplerQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchSamplerQCOM
        %void = OpTypeVoid
-       %func = OpTypeFunction %void
-        %f32 = OpTypeFloat 32
-        %u32 = OpTypeInt 32 0
-     %uint_3 = OpConstant %u32 3
-     %uint_2 = OpConstant %u32 2
-     %uint_1 = OpConstant %u32 1
-     %v3uint = OpTypeVector %u32 3
-    %v4float = OpTypeVector %f32 4
-    %image = OpTypeImage %f32 2D 2 1 0 2 Unknown
-%ptr_image = OpTypePointer UniformConstant %image
-       %10 = OpConstantComposite %v3uint %uint_1 %uint_2 %uint_3
-%var_image = OpVariable %ptr_image UniformConstant
-     %main = OpFunction %void None %func
- %main_lab = OpLabel
-       %18 = OpLoad %image %var_image
-       %19 = OpImageRead %v4float %18 %10
-             OpReturn
-             OpFunctionEnd
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSADQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
 )";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
 
-  const spv_target_env env = SPV_ENV_VULKAN_1_0;
-  CompileSuccessfully(code, env);
-  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions(env));
-  EXPECT_THAT(getDiagnosticString(), Eq(""));
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorRefIS) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %4 BlockMatchSamplerQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSADQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorTargetNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchSamplerQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+           OpDecorate %6 BlockMatchSamplerQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSADQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorTargetNIS) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+           OpDecorate %6 BlockMatchSamplerQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSADQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorRefNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %5 BlockMatchSamplerQCOM
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchSamplerQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSADQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADNoDecorRefNIS) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %4 BlockMatchSamplerQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSADQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorTargetIT) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchSamplerQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSSDQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorTargetIS) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSSDQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorRefIT) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %4 BlockMatchSamplerQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSSDQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorRefIS) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %4 BlockMatchSamplerQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchWindowSSDQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorTargetNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchSamplerQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+           OpDecorate %6 BlockMatchSamplerQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSSDQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorTargetNIS) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+           OpDecorate %6 BlockMatchSamplerQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSSDQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorRefNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %5 BlockMatchSamplerQCOM
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchSamplerQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSSDQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDNoDecorRefNIS) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %4 BlockMatchSamplerQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchWindowSSDQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchSamplerQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSADNoDecorTargetIT) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchGatherSADQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSADNoDecorRefIT) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchGatherSADQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSADNoDecorTargetNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchGatherSADQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSADNoDecorRefNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchGatherSADQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSSDNoDecorTargetIT) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchGatherSSDQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSSDNoDecorRefIT) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 DescriptorSet 0
+               OpDecorate %4 Binding 4
+               OpDecorate %4 BlockMatchTextureQCOM
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 5
+       %void = OpTypeVoid
+          %7 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %3 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+         %19 = OpTypeSampledImage %18
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+          %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+          %5 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+         %21 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %7
+         %22 = OpLabel
+         %23 = OpVariable %_ptr_Function_v2uint Function
+         %24 = OpLoad %19 %4
+         %25 = OpLoad %v2uint %23
+         %26 = OpLoad %19 %5
+         %27 = OpLoad %v2uint %23
+         %28 = OpLoad %v2uint %23
+         %29 = OpImageBlockMatchGatherSSDQCOM %v4float %24 %25 %26 %27 %28
+               OpStore %3 %29
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSSDNoDecorTargetNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+           OpDecorate %6 BlockMatchTextureQCOM
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchGatherSSDQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSSDNoDecorRefNIT) {
+  const std::string text = R"(
+           OpCapability Shader
+           OpCapability TextureBlockMatchQCOM
+           OpCapability TextureBlockMatch2QCOM
+           OpExtension "SPV_QCOM_image_processing"
+           OpExtension "SPV_QCOM_image_processing2"
+      %1 = OpExtInstImport "GLSL.std.450"
+           OpMemoryModel Logical GLSL450
+           OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+           OpExecutionMode %2 OriginUpperLeft
+           OpDecorate %3 Location 0
+           OpDecorate %4 DescriptorSet 0
+           OpDecorate %4 Binding 1
+           OpDecorate %4 BlockMatchTextureQCOM
+           OpDecorate %5 DescriptorSet 0
+           OpDecorate %5 Binding 3
+           OpDecorate %6 DescriptorSet 0
+           OpDecorate %6 Binding 2
+   %void = OpTypeVoid
+      %8 = OpTypeFunction %void
+   %uint = OpTypeInt 32 0
+ %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+  %float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Input_float = OpTypePointer Input %float
+%_ptr_Function_uint = OpTypePointer Function %uint
+%uint_4 = OpConstant %uint 4
+    %17 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+     %3 = OpVariable %_ptr_Output_v4float Output
+    %19 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_19 = OpTypePointer UniformConstant %19
+     %4 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %21 = OpTypeSampler
+%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
+    %5 = OpVariable %_ptr_UniformConstant_21 UniformConstant
+   %23 = OpTypeSampledImage %19
+    %6 = OpVariable %_ptr_UniformConstant_19 UniformConstant
+    %2 = OpFunction %void None %8
+   %24 = OpLabel
+   %25 = OpVariable %_ptr_Function_v2uint Function
+   %26 = OpLoad %19 %4
+   %27 = OpLoad %21 %5
+   %28 = OpSampledImage %23 %26 %27
+   %29 = OpLoad %v2uint %25
+   %30 = OpLoad %19 %6
+   %31 = OpLoad %21 %5
+   %32 = OpSampledImage %23 %30 %31
+   %33 = OpImageBlockMatchGatherSSDQCOM %v4float %28 %29 %32 %29 %29
+         OpStore %3 %33
+         OpReturn
+         OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Missing decoration BlockMatchTextureQCOM"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchWindowSADInvalidUseTargetI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchWindowSADQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %5
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADInvalidUseRefI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchWindowSADQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %6
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchWindowSADInvalidUseTargetNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %103 BlockMatchSamplerQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchWindowSADQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %102
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSADInvalidUseRefNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %103 BlockMatchSamplerQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchWindowSADQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %104
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchWindowSSDInvalidUseTargetI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchWindowSSDQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %5
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDInvalidUseRefI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %5 BlockMatchSamplerQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchSamplerQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchWindowSSDQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %6
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchWindowSSDInvalidUseTargetNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %103 BlockMatchSamplerQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchWindowSSDQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %102
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchWindowSSDInvalidUseRefNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %103 BlockMatchSamplerQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchWindowSSDQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %104
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchGatherSADInvalidUseTargetI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchGatherSADQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %5
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSADInvalidUseRefI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchGatherSADQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %6
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchGatherSADInvalidUseTargetNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchGatherSADQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %102
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSADInvalidUseRefNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchGatherSADQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %104
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchGatherSSDInvalidUseTargetI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchGatherSSDQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %5
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSSDInvalidUseRefI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %2 "main" %3 %4 %5 %6
+               OpExecutionMode %2 OriginUpperLeft
+               OpDecorate %3 Location 0
+               OpDecorate %4 Location 0
+               OpDecorate %5 DescriptorSet 0
+               OpDecorate %5 Binding 4
+               OpDecorate %6 DescriptorSet 0
+               OpDecorate %6 Binding 5
+               OpDecorate %5 BlockMatchTextureQCOM
+               OpDecorate %6 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %8 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+          %3 = OpVariable %_ptr_Input_v4float Input
+     %uint_4 = OpConstant %uint 4
+         %16 = OpConstantComposite %v2uint %uint_4 %uint_4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+          %4 = OpVariable %_ptr_Output_v4float Output
+         %18 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_18 = OpTypePointer UniformConstant %18
+         %20 = OpTypeSampledImage %18
+%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20
+          %5 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+          %6 = OpVariable %_ptr_UniformConstant_20 UniformConstant
+    %v2float = OpTypeVector %float 2
+         %23 = OpTypeImage %float 2D 0 1 0 1 Unknown
+          %2 = OpFunction %void None %8
+         %24 = OpLabel
+         %25 = OpVariable %_ptr_Function_v2uint Function
+               OpStore %25 %16
+         %26 = OpLoad %20 %5
+         %27 = OpLoad %v2uint %25
+         %28 = OpLoad %20 %6
+         %29 = OpLoad %v2uint %25
+         %30 = OpLoad %v2uint %25
+         %31 = OpImageBlockMatchGatherSSDQCOM %v4float %26 %27 %28 %29 %30
+               OpStore %4 %31
+         %32 = OpLoad %20 %6
+         %33 = OpLoad %v4float %3
+         %34 = OpVectorShuffle %v2float %33 %33 0 2
+         %35 = OpImageSampleImplicitLod %v4float %32 %34
+               OpStore %4 %35
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage,
+       QCOMImageProcessing2BlockMatchGatherSSDInvalidUseTargetNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchGatherSSDQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %102
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, QCOMImageProcessing2BlockMatchGatherSSDInvalidUseRefNI) {
+  const std::string text = R"(
+               OpCapability Shader
+               OpCapability TextureBlockMatchQCOM
+               OpCapability TextureBlockMatch2QCOM
+               OpExtension "SPV_QCOM_image_processing"
+               OpExtension "SPV_QCOM_image_processing2"
+          %1 = OpExtInstImport "GLSL.std.450"
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main" %100 %101 %102 %103 %104
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %100 Location 0
+               OpDecorate %101 Location 0
+               OpDecorate %102 DescriptorSet 0
+               OpDecorate %102 Binding 1
+               OpDecorate %103 DescriptorSet 0
+               OpDecorate %103 Binding 3
+               OpDecorate %104 DescriptorSet 0
+               OpDecorate %104 Binding 2
+               OpDecorate %102 BlockMatchTextureQCOM
+               OpDecorate %104 BlockMatchTextureQCOM
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+       %uint = OpTypeInt 32 0
+     %v2uint = OpTypeVector %uint 2
+%_ptr_Function_v2uint = OpTypePointer Function %v2uint
+      %float = OpTypeFloat 32
+    %v4float = OpTypeVector %float 4
+%_ptr_Input_v4float = OpTypePointer Input %v4float
+ %100 = OpVariable %_ptr_Input_v4float Input
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+  %101 = OpVariable %_ptr_Output_v4float Output
+         %42 = OpTypeImage %float 2D 0 0 0 1 Unknown
+%_ptr_UniformConstant_42 = OpTypePointer UniformConstant %42
+ %102 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+         %46 = OpTypeSampler
+%_ptr_UniformConstant_46 = OpTypePointer UniformConstant %46
+       %103 = OpVariable %_ptr_UniformConstant_46 UniformConstant
+         %50 = OpTypeSampledImage %42
+ %104 = OpVariable %_ptr_UniformConstant_42 UniformConstant
+    %v2float = OpTypeVector %float 2
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+         %15 = OpVariable %_ptr_Function_v2uint Function
+         %45 = OpLoad %42 %102
+         %49 = OpLoad %46 %103
+         %51 = OpSampledImage %50 %45 %49
+         %52 = OpLoad %v2uint %15
+         %54 = OpLoad %42 %104
+         %55 = OpLoad %46 %103
+         %56 = OpSampledImage %50 %54 %55
+         %57 = OpLoad %v2uint %15
+         %58 = OpLoad %v2uint %15
+         %59 = OpImageBlockMatchGatherSSDQCOM %v4float %51 %52 %56 %57 %58
+               OpStore %101 %59
+         %69 = OpLoad %42 %104
+         %70 = OpLoad %46 %103
+         %71 = OpSampledImage %50 %69 %70
+         %73 = OpLoad %v4float %100
+         %74 = OpVectorShuffle %v2float %73 %73 0 0
+         %75 = OpImageSampleImplicitLod %v4float %71 %74
+               OpStore %101 %75
+               OpReturn
+               OpFunctionEnd
+)";
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Illegal use of QCOM image processing decorated texture"));
+}
+
+TEST_F(ValidateImage, ImageMSArray_ArrayedSampledTypeRequiresCapability) {
+  const std::string code = R"(
+               OpCapability Shader
+               OpCapability StorageImageMultisample
+               OpCapability StorageImageReadWithoutFormat
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main"
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %var_image DescriptorSet 0
+               OpDecorate %var_image Binding 1
+       %void = OpTypeVoid
+       %func = OpTypeFunction %void
+        %f32 = OpTypeFloat 32
+        %u32 = OpTypeInt 32 0
+     %uint_2 = OpConstant %u32 2
+     %uint_1 = OpConstant %u32 1
+     %v2uint = OpTypeVector %u32 2
+    %v4float = OpTypeVector %f32 4
+    %image = OpTypeImage %f32 2D 2 1 1 2 Unknown
+%ptr_image = OpTypePointer UniformConstant %image
+       %10 = OpConstantComposite %v2uint %uint_1 %uint_2
+%var_image = OpVariable %ptr_image UniformConstant
+     %main = OpFunction %void None %func
+ %main_lab = OpLabel
+       %18 = OpLoad %image %var_image
+       %19 = OpImageRead %v4float %18 %10 Sample %uint_2
+             OpReturn
+             OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_VULKAN_1_0;
+  CompileSuccessfully(code, env);
+  ASSERT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Capability ImageMSArray is required to access storage image"));
+}
+
+TEST_F(ValidateImage, ImageMSArray_SampledTypeDoesNotRequireCapability) {
+  const std::string code = R"(
+               OpCapability Shader
+               OpCapability StorageImageMultisample
+               OpCapability StorageImageReadWithoutFormat
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main"
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %var_image DescriptorSet 0
+               OpDecorate %var_image Binding 1
+       %void = OpTypeVoid
+       %func = OpTypeFunction %void
+        %f32 = OpTypeFloat 32
+        %u32 = OpTypeInt 32 0
+     %uint_2 = OpConstant %u32 2
+     %uint_1 = OpConstant %u32 1
+     %v2uint = OpTypeVector %u32 2
+    %v4float = OpTypeVector %f32 4
+    %image = OpTypeImage %f32 2D 2 0 1 2 Unknown
+%ptr_image = OpTypePointer UniformConstant %image
+       %10 = OpConstantComposite %v2uint %uint_1 %uint_2
+%var_image = OpVariable %ptr_image UniformConstant
+     %main = OpFunction %void None %func
+ %main_lab = OpLabel
+       %18 = OpLoad %image %var_image
+       %19 = OpImageRead %v4float %18 %10 Sample %uint_2
+             OpReturn
+             OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_VULKAN_1_0;
+  CompileSuccessfully(code, env);
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions(env));
+  EXPECT_THAT(getDiagnosticString(), Eq(""));
+}
+
+TEST_F(ValidateImage, ImageMSArray_ArrayedTypeDoesNotRequireCapability) {
+  const std::string code = R"(
+               OpCapability Shader
+               OpCapability StorageImageReadWithoutFormat
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint Fragment %main "main"
+               OpExecutionMode %main OriginUpperLeft
+               OpDecorate %var_image DescriptorSet 0
+               OpDecorate %var_image Binding 1
+       %void = OpTypeVoid
+       %func = OpTypeFunction %void
+        %f32 = OpTypeFloat 32
+        %u32 = OpTypeInt 32 0
+     %uint_3 = OpConstant %u32 3
+     %uint_2 = OpConstant %u32 2
+     %uint_1 = OpConstant %u32 1
+     %v3uint = OpTypeVector %u32 3
+    %v4float = OpTypeVector %f32 4
+    %image = OpTypeImage %f32 2D 2 1 0 2 Unknown
+%ptr_image = OpTypePointer UniformConstant %image
+       %10 = OpConstantComposite %v3uint %uint_1 %uint_2 %uint_3
+%var_image = OpVariable %ptr_image UniformConstant
+     %main = OpFunction %void None %func
+ %main_lab = OpLabel
+       %18 = OpLoad %image %var_image
+       %19 = OpImageRead %v4float %18 %10
+             OpReturn
+             OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_VULKAN_1_0;
+  CompileSuccessfully(code, env);
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions(env));
+  EXPECT_THAT(getDiagnosticString(), Eq(""));
+}
+
+TEST_F(ValidateImage, SampledImageTypeDepthMismatch) {
+  const std::string code = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %im_var DescriptorSet 0
+OpDecorate %im_var Binding 0
+OpDecorate %s_var DescriptorSet 1
+OpDecorate %s_var Binding 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%im1_ty = OpTypeImage %float 2D 0 0 0 1 Unknown
+%im2_ty = OpTypeImage %float 2D 1 0 0 1 Unknown
+%s_ty = OpTypeSampler
+%s_im_ty = OpTypeSampledImage %im2_ty
+%ptr_im = OpTypePointer UniformConstant %im1_ty
+%ptr_s = OpTypePointer UniformConstant %s_ty
+%im_var = OpVariable %ptr_im UniformConstant
+%s_var = OpVariable %ptr_s UniformConstant
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%im_ld = OpLoad %im1_ty %im_var
+%s_ld = OpLoad %s_ty %s_var
+%sampled_image = OpSampledImage %s_im_ty %im_ld %s_ld
+OpReturn
+OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_VULKAN_1_0;
+  CompileSuccessfully(code, env);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(env));
+}
+
+TEST_F(ValidateImage, SampledImageTypeArrayedMismatch) {
+  const std::string code = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %im_var DescriptorSet 0
+OpDecorate %im_var Binding 0
+OpDecorate %s_var DescriptorSet 1
+OpDecorate %s_var Binding 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%im1_ty = OpTypeImage %float 2D 0 0 0 1 Unknown
+%im2_ty = OpTypeImage %float 2D 0 1 0 1 Unknown
+%s_ty = OpTypeSampler
+%s_im_ty = OpTypeSampledImage %im2_ty
+%ptr_im = OpTypePointer UniformConstant %im1_ty
+%ptr_s = OpTypePointer UniformConstant %s_ty
+%im_var = OpVariable %ptr_im UniformConstant
+%s_var = OpVariable %ptr_s UniformConstant
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%im_ld = OpLoad %im1_ty %im_var
+%s_ld = OpLoad %s_ty %s_var
+%sampled_image = OpSampledImage %s_im_ty %im_ld %s_ld
+OpReturn
+OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_VULKAN_1_0;
+  CompileSuccessfully(code, env);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Image operands must match result image operands except for depth"));
+}
+
+TEST_F(ValidateImage, SampledImageTypeMultisampledMismatch) {
+  const std::string code = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %im_var DescriptorSet 0
+OpDecorate %im_var Binding 0
+OpDecorate %s_var DescriptorSet 1
+OpDecorate %s_var Binding 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%im1_ty = OpTypeImage %float 2D 0 0 0 1 Unknown
+%im2_ty = OpTypeImage %float 2D 0 0 1 1 Unknown
+%s_ty = OpTypeSampler
+%s_im_ty = OpTypeSampledImage %im2_ty
+%ptr_im = OpTypePointer UniformConstant %im1_ty
+%ptr_s = OpTypePointer UniformConstant %s_ty
+%im_var = OpVariable %ptr_im UniformConstant
+%s_var = OpVariable %ptr_s UniformConstant
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%im_ld = OpLoad %im1_ty %im_var
+%s_ld = OpLoad %s_ty %s_var
+%sampled_image = OpSampledImage %s_im_ty %im_ld %s_ld
+OpReturn
+OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_VULKAN_1_0;
+  CompileSuccessfully(code, env);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Image operands must match result image operands except for depth"));
+}
+
+TEST_F(ValidateImage, SampledImageTypeSampledMismatch) {
+  const std::string code = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %im_var DescriptorSet 0
+OpDecorate %im_var Binding 0
+OpDecorate %s_var DescriptorSet 1
+OpDecorate %s_var Binding 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%im1_ty = OpTypeImage %float 2D 0 0 0 1 Unknown
+%im2_ty = OpTypeImage %float 2D 0 0 0 0 Unknown
+%s_ty = OpTypeSampler
+%s_im_ty = OpTypeSampledImage %im2_ty
+%ptr_im = OpTypePointer UniformConstant %im1_ty
+%ptr_s = OpTypePointer UniformConstant %s_ty
+%im_var = OpVariable %ptr_im UniformConstant
+%s_var = OpVariable %ptr_s UniformConstant
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%im_ld = OpLoad %im1_ty %im_var
+%s_ld = OpLoad %s_ty %s_var
+%sampled_image = OpSampledImage %s_im_ty %im_ld %s_ld
+OpReturn
+OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_UNIVERSAL_1_0;
+  CompileSuccessfully(code, env);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Image operands must match result image operands except for depth"));
+}
+
+TEST_F(ValidateImage, SampledImageTypeFormatMismatch) {
+  const std::string code = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %im_var DescriptorSet 0
+OpDecorate %im_var Binding 0
+OpDecorate %s_var DescriptorSet 1
+OpDecorate %s_var Binding 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%im1_ty = OpTypeImage %float 2D 0 0 0 1 Unknown
+%im2_ty = OpTypeImage %float 2D 0 0 0 1 R32f
+%s_ty = OpTypeSampler
+%s_im_ty = OpTypeSampledImage %im2_ty
+%ptr_im = OpTypePointer UniformConstant %im1_ty
+%ptr_s = OpTypePointer UniformConstant %s_ty
+%im_var = OpVariable %ptr_im UniformConstant
+%s_var = OpVariable %ptr_s UniformConstant
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%im_ld = OpLoad %im1_ty %im_var
+%s_ld = OpLoad %s_ty %s_var
+%sampled_image = OpSampledImage %s_im_ty %im_ld %s_ld
+OpReturn
+OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_UNIVERSAL_1_0;
+  CompileSuccessfully(code, env);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Image operands must match result image operands except for depth"));
+}
+
+TEST_F(ValidateImage, SampledImageTypeAccessQualifierMismatch) {
+  const std::string code = R"(
+OpCapability Kernel
+OpCapability Linkage
+OpMemoryModel Logical OpenCL
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%im1_ty = OpTypeImage %float 2D 0 0 0 0 Unknown ReadWrite
+%im2_ty = OpTypeImage %float 2D 0 0 0 0 Unknown ReadOnly
+%s_ty = OpTypeSampler
+%s_im_ty = OpTypeSampledImage %im2_ty
+%ptr_im = OpTypePointer UniformConstant %im1_ty
+%ptr_s = OpTypePointer UniformConstant %s_ty
+%im_var = OpVariable %ptr_im UniformConstant
+%s_var = OpVariable %ptr_s UniformConstant
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%im_ld = OpLoad %im1_ty %im_var
+%s_ld = OpLoad %s_ty %s_var
+%sampled_image = OpSampledImage %s_im_ty %im_ld %s_ld
+OpReturn
+OpFunctionEnd
+)";
+
+  const spv_target_env env = SPV_ENV_UNIVERSAL_1_0;
+  CompileSuccessfully(code, env);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(env));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr(
+          "Image operands must match result image operands except for depth"));
+}
+
+TEST_F(ValidateImage, ImageTexelPointerNotAPointer) {
+  const std::string code = R"(
+               OpCapability ClipDistance
+               OpMemoryModel Logical Simple
+       %void = OpTypeVoid
+         %57 = OpTypeFunction %void
+        %int = OpTypeInt 32 1
+%int_538976288 = OpConstant %int 538976288
+%int_538976288_0 = OpConstant %int 538976288
+       %8224 = OpFunction %void None %57
+      %65312 = OpLabel
+    %2097184 = OpImageTexelPointer %void %int_538976288 %int_538976288 %int_538976288_0
+               OpUnreachable
+               OpFunctionEnd
+)";
+
+  CompileSuccessfully(code);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Expected Result Type to be a pointer"));
 }
 
 }  // namespace
diff --git a/test/val/val_interfaces_test.cpp b/test/val/val_interfaces_test.cpp
index d75c20cf..50f45573 100644
--- a/test/val/val_interfaces_test.cpp
+++ b/test/val/val_interfaces_test.cpp
@@ -419,9 +419,10 @@ OpFunctionEnd
 )";
 
   CompileSuccessfully(text, SPV_ENV_VULKAN_1_0);
-  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_VULKAN_1_0));
-  EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Variable has conflicting location decorations"));
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("decorated with Location multiple times is not allowed"));
 }
 
 TEST_F(ValidateInterfacesTest, VulkanLocationsVariableAndMemberAssigned) {
@@ -505,9 +506,10 @@ OpFunctionEnd
 )";
 
   CompileSuccessfully(text, SPV_ENV_VULKAN_1_0);
-  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_VULKAN_1_0));
-  EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Member index 1 has conflicting location assignments"));
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("decorated with Location multiple times is not allowed"));
 }
 
 TEST_F(ValidateInterfacesTest, VulkanLocationsMissingAssignmentStructMember) {
@@ -621,6 +623,72 @@ OpFunctionEnd
                 "at location 1"));
 }
 
+TEST_F(ValidateInterfacesTest, VulkanPatchAndNonPatchOverlap) {
+  const std::string text = R"(
+               OpCapability Tessellation
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint TessellationControl %main "main" %a %b
+               OpExecutionMode %main OutputVertices 4
+               OpDecorate %a Location 0
+               OpDecorate %b Patch
+               OpDecorate %b Location 0
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+       %uint = OpTypeInt 32 0
+     %uint_4 = OpConstant %uint 4
+%_arr_float_uint_4 = OpTypeArray %float %uint_4
+%_ptr_Output__arr_float_uint_4 = OpTypePointer Output %_arr_float_uint_4
+          %a = OpVariable %_ptr_Output__arr_float_uint_4 Output
+%_ptr_Output_float = OpTypePointer Output %float
+          %b = OpVariable %_ptr_Output_float Output
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(text, SPV_ENV_VULKAN_1_2);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+}
+
+TEST_F(ValidateInterfacesTest, VulkanPatchOverlap) {
+  const std::string text = R"(
+               OpCapability Tessellation
+               OpMemoryModel Logical GLSL450
+               OpEntryPoint TessellationControl %main "main" %a %b %c
+               OpExecutionMode %main OutputVertices 4
+               OpDecorate %a Location 0
+               OpDecorate %b Patch
+               OpDecorate %b Location 6
+               OpDecorate %c Patch
+               OpDecorate %c Location 6
+       %void = OpTypeVoid
+          %3 = OpTypeFunction %void
+      %float = OpTypeFloat 32
+       %uint = OpTypeInt 32 0
+     %uint_4 = OpConstant %uint 4
+%_arr_float_uint_4 = OpTypeArray %float %uint_4
+%_ptr_Output__arr_float_uint_4 = OpTypePointer Output %_arr_float_uint_4
+          %a = OpVariable %_ptr_Output__arr_float_uint_4 Output
+%_ptr_Output_float = OpTypePointer Output %float
+          %b = OpVariable %_ptr_Output_float Output
+          %c = OpVariable %_ptr_Output_float Output
+       %main = OpFunction %void None %3
+          %5 = OpLabel
+               OpReturn
+               OpFunctionEnd
+    )";
+
+  CompileSuccessfully(text, SPV_ENV_VULKAN_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_VULKAN_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpEntryPoint-08722"));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Entry-point has conflicting output location "
+                        "assignment at location 6, component 0"));
+}
+
 TEST_F(ValidateInterfacesTest,
        VulkanLocationsSameLocationInputAndOutputNoConflict) {
   const std::string text = R"(
@@ -1157,9 +1225,10 @@ OpFunctionEnd
 )";
 
   CompileSuccessfully(text, SPV_ENV_VULKAN_1_0);
-  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_VULKAN_1_0));
-  EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Variable has conflicting component decorations"));
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("decorated with Component multiple times is not allowed"));
 }
 
 TEST_F(ValidateInterfacesTest,
@@ -1186,10 +1255,10 @@ OpFunctionEnd
 )";
 
   CompileSuccessfully(text, SPV_ENV_VULKAN_1_0);
-  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_0));
   EXPECT_THAT(
       getDiagnosticString(),
-      HasSubstr("Member index 0 has conflicting component assignments"));
+      HasSubstr("decorated with Component multiple times is not allowed"));
 }
 
 TEST_F(ValidateInterfacesTest, VulkanLocationsVariableConflictOutputIndex1) {
@@ -1622,6 +1691,122 @@ OpFunctionEnd
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
 }
 
+TEST_F(ValidateInterfacesTest, UntypedVariableInputMissing) {
+  const std::string text = R"(
+OpCapability Kernel
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical OpenCL
+OpEntryPoint Kernel %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpName %var "var"
+OpDecorate %var BuiltIn LocalInvocationId
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int3 = OpTypeVector %int 3
+%ptr = OpTypeUntypedPointerKHR Input
+%var = OpUntypedVariableKHR %ptr Input %int3
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%load = OpLoad %int3 %var
+OpReturn
+OpFunctionEnd
+)";
+  CompileSuccessfully(text);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Interface variable id <2> is used by entry point "
+                        "'main' id <1>, but is not listed as an interface"));
+}
+
+TEST_F(ValidateInterfacesTest, UntypedVariableWorkgroupMissingSpv1p4) {
+  const std::string text = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %var "var"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%load = OpLoad %int %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(text, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Interface variable id <2> is used by entry point "
+                        "'main' id <1>, but is not listed as an interface"));
+}
+
+TEST_F(ValidateInterfacesTest, UntypedIdMatchesInputVulkan1p3) {
+  const std::string text = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %var
+OpExecutionMode %main OriginUpperLeft
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %1 Block
+OpMemberDecorate %1 0 Offset 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%1 = OpTypeStruct %float ; this id matches Input storage class
+%ptr = OpTypeUntypedPointerKHR Uniform
+%var = OpUntypedVariableKHR %ptr Uniform %1
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  CompileSuccessfully(text, SPV_ENV_VULKAN_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
+}
+
+TEST_F(ValidateInterfacesTest, UntypedIdMatchesPushConstantVulkan1p3) {
+  const std::string text = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %var
+OpExecutionMode %main OriginUpperLeft
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %9 Block
+OpMemberDecorate %9 0 Offset 0
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%9 = OpTypeStruct %float ; this id matches PushConstant storage class
+%ptr = OpTypeUntypedPointerKHR Uniform
+%var = OpUntypedVariableKHR %ptr Uniform %9
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);
+  CompileSuccessfully(text, SPV_ENV_VULKAN_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_memory_test.cpp b/test/val/val_memory_test.cpp
index 8d0a94d2..0a918c98 100644
--- a/test/val/val_memory_test.cpp
+++ b/test/val/val_memory_test.cpp
@@ -352,12 +352,8 @@ OpFunctionEnd
 )";
   CompileSuccessfully(spirv.c_str());
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
-  EXPECT_THAT(
-      getDiagnosticString(),
-      HasSubstr(
-          "From SPIR-V spec, section 3.32.8 on OpVariable:\n"
-          "Its Storage Class operand must be the same as the Storage Class "
-          "operand of the result type."));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Storage class must match result type storage class"));
 }
 
 TEST_F(ValidateMemory, MatchingStorageClassesGood) {
@@ -788,7 +784,7 @@ TEST_F(ValidateMemory, ArrayLenIndexNotLastMember) {
   EXPECT_THAT(
       getDiagnosticString(),
       HasSubstr(
-          "The array member in OpArrayLength <id> '11[%11]' must be an the "
+          "The array member in OpArrayLength <id> '11[%11]' must be the "
           "last member of the struct.\n  %11 = OpArrayLength %uint %10 0\n"));
 }
 
@@ -1465,6 +1461,7 @@ OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical VulkanKHR
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
 %device = OpConstant %int 1
 %int_ptr_ssbo = OpTypePointer StorageBuffer %int
 %var1 = OpVariable %int_ptr_ssbo StorageBuffer
@@ -1472,7 +1469,7 @@ OpMemoryModel Logical VulkanKHR
 %voidfn = OpTypeFunction %void
 %func = OpFunction %void None %voidfn
 %entry = OpLabel
-OpCopyMemorySized %var1 %var2 %device MakePointerAvailableKHR|NonPrivatePointerKHR %device
+OpCopyMemorySized %var1 %var2 %int_4 MakePointerAvailableKHR|NonPrivatePointerKHR %device
 OpReturn
 OpFunctionEnd
 )";
@@ -1496,6 +1493,7 @@ OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical VulkanKHR
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
 %device = OpConstant %int 1
 %workgroup = OpConstant %int 1
 %int_ptr_ssbo = OpTypePointer StorageBuffer %int
@@ -1504,7 +1502,7 @@ OpMemoryModel Logical VulkanKHR
 %voidfn = OpTypeFunction %void
 %func = OpFunction %void None %voidfn
 %entry = OpLabel
-OpCopyMemorySized %var1 %var2 %device Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %device %workgroup
+OpCopyMemorySized %var1 %var2 %int_4 Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %device %workgroup
 OpReturn
 OpFunctionEnd
 )";
@@ -1528,6 +1526,7 @@ OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical VulkanKHR
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
 %device = OpConstant %int 1
 %workgroup = OpConstant %int 1
 %int_ptr_ssbo = OpTypePointer StorageBuffer %int
@@ -1536,7 +1535,7 @@ OpMemoryModel Logical VulkanKHR
 %voidfn = OpTypeFunction %void
 %func = OpFunction %void None %voidfn
 %entry = OpLabel
-OpCopyMemorySized %var1 %var2 %device Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %workgroup %device
+OpCopyMemorySized %var1 %var2 %int_4 Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %workgroup %device
 OpReturn
 OpFunctionEnd
 )";
@@ -1561,6 +1560,7 @@ OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical VulkanKHR
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
 %device = OpConstant %int 1
 %int_ptr_ssbo = OpTypePointer StorageBuffer %int
 %var1 = OpVariable %int_ptr_ssbo StorageBuffer
@@ -1568,7 +1568,7 @@ OpMemoryModel Logical VulkanKHR
 %voidfn = OpTypeFunction %void
 %func = OpFunction %void None %voidfn
 %entry = OpLabel
-OpCopyMemorySized %var1 %var2 %device MakePointerAvailableKHR|NonPrivatePointerKHR %device
+OpCopyMemorySized %var1 %var2 %int_4 MakePointerAvailableKHR|NonPrivatePointerKHR %device
 OpReturn
 OpFunctionEnd
 )";
@@ -1588,6 +1588,7 @@ OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical VulkanKHR
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
 %device = OpConstant %int 1
 %workgroup = OpConstant %int 2
 %int_ptr_ssbo = OpTypePointer StorageBuffer %int
@@ -1596,7 +1597,7 @@ OpMemoryModel Logical VulkanKHR
 %voidfn = OpTypeFunction %void
 %func = OpFunction %void None %voidfn
 %entry = OpLabel
-OpCopyMemorySized %var1 %var2 %device Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %device %workgroup
+OpCopyMemorySized %var1 %var2 %int_4 Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %device %workgroup
 OpReturn
 OpFunctionEnd
 )";
@@ -1616,6 +1617,7 @@ OpExtension "SPV_KHR_vulkan_memory_model"
 OpMemoryModel Logical VulkanKHR
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
 %device = OpConstant %int 1
 %workgroup = OpConstant %int 2
 %int_ptr_ssbo = OpTypePointer StorageBuffer %int
@@ -1624,7 +1626,7 @@ OpMemoryModel Logical VulkanKHR
 %voidfn = OpTypeFunction %void
 %func = OpFunction %void None %voidfn
 %entry = OpLabel
-OpCopyMemorySized %var1 %var2 %device Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %workgroup %device
+OpCopyMemorySized %var1 %var2 %int_4 Aligned|MakePointerVisibleKHR|MakePointerAvailableKHR|NonPrivatePointerKHR 4 %workgroup %device
 OpReturn
 OpFunctionEnd
 )";
@@ -2348,19 +2350,281 @@ OpFunctionEnd)";
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
+std::string GenCoopMatLoadStoreShaderKHR(const std::string& storeMemoryAccess,
+                                         const std::string& loadMemoryAccess,
+                                         unsigned layout = 0,
+                                         bool useSpecConstantLayout = false,
+                                         bool useStoreStride = true,
+                                         bool useLoadStride = true) {
+  std::string s = R"(
+OpCapability Shader
+OpCapability GroupNonUniform
+OpCapability VulkanMemoryModelKHR
+OpCapability CooperativeMatrixKHR
+OpExtension "SPV_KHR_vulkan_memory_model"
+OpExtension "SPV_KHR_cooperative_matrix"
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical VulkanKHR
+OpEntryPoint GLCompute %4 "main" %11 %21
+OpExecutionMode %4 LocalSize 1 1 1
+OpDecorate %11 BuiltIn SubgroupId
+OpDecorate %21 BuiltIn WorkgroupId
+OpDecorate %74 ArrayStride 4
+OpMemberDecorate %75 0 Offset 0
+OpDecorate %75 Block
+OpDecorate %77 DescriptorSet 0
+OpDecorate %77 Binding 0
+OpDecorate %92 ArrayStride 4
+OpMemberDecorate %93 0 Offset 0
+OpDecorate %93 Block
+OpDecorate %95 DescriptorSet 0
+OpDecorate %95 Binding 1
+OpDecorate %102 ArrayStride 4
+OpMemberDecorate %103 0 Offset 0
+OpDecorate %103 Block
+OpDecorate %105 DescriptorSet 0
+OpDecorate %105 Binding 2
+OpDecorate %117 ArrayStride 4
+OpMemberDecorate %118 0 Offset 0
+OpDecorate %118 Block
+OpDecorate %120 DescriptorSet 0
+OpDecorate %120 Binding 3
+OpDecorate %123 SpecId 2
+OpDecorate %124 SpecId 3
+OpDecorate %125 SpecId 4
+OpDecorate %126 SpecId 5
+OpDecorate %127 SpecId 0
+OpDecorate %128 SpecId 1
+OpDecorate %129 BuiltIn WorkgroupSize
+%2 = OpTypeVoid
+%3 = OpTypeFunction %2
+%6 = OpTypeInt 32 0
+%7 = OpTypeVector %6 2
+%8 = OpTypePointer Function %7
+%10 = OpTypePointer Input %6
+%11 = OpVariable %10 Input
+%13 = OpConstant %6 2
+%19 = OpTypeVector %6 3
+%20 = OpTypePointer Input %19
+%21 = OpVariable %20 Input
+%27 = OpConstantComposite %7 %13 %13
+%31 = OpTypePointer Function %6
+%33 = OpConstant %6 1024
+%34 = OpConstant %6 1
+%38 = OpConstant %6 8
+%uint_0 = OpConstant %6 0
+)";
+  if (useSpecConstantLayout) {
+    s += "%layout = OpSpecConstant %6 " + std::to_string(layout);
+  } else {
+    s += "%layout = OpConstant %6 " + std::to_string(layout);
+  }
+  s += R"(
+%68 = OpTypeFloat 32
+%69 = OpConstant %6 16
+%70 = OpConstant %6 3
+%71 = OpTypeCooperativeMatrixKHR %68 %70 %69 %38 %uint_0
+%72 = OpTypePointer Function %71
+%74 = OpTypeRuntimeArray %68
+%75 = OpTypeStruct %74
+%76 = OpTypePointer StorageBuffer %75
+%77 = OpVariable %76 StorageBuffer
+%78 = OpTypeInt 32 1
+%79 = OpConstant %78 0
+%81 = OpConstant %6 5
+%82 = OpTypePointer StorageBuffer %68
+%stride = OpConstant %6 64
+%88 = OpTypePointer Private %71
+%89 = OpVariable %88 Private
+%92 = OpTypeRuntimeArray %68
+%93 = OpTypeStruct %92
+%94 = OpTypePointer StorageBuffer %93
+%95 = OpVariable %94 StorageBuffer
+%99 = OpVariable %88 Private
+%102 = OpTypeRuntimeArray %68
+%103 = OpTypeStruct %102
+%104 = OpTypePointer StorageBuffer %103
+%105 = OpVariable %104 StorageBuffer
+%109 = OpVariable %88 Private
+%111 = OpVariable %88 Private
+%112 = OpSpecConstantOp %6 CooperativeMatrixLengthKHR %71
+%113 = OpSpecConstantOp %78 IAdd %112 %79
+%117 = OpTypeRuntimeArray %68
+%118 = OpTypeStruct %117
+%119 = OpTypePointer StorageBuffer %118
+%120 = OpVariable %119 StorageBuffer
+%123 = OpSpecConstant %78 1
+%124 = OpSpecConstant %78 1
+%125 = OpSpecConstant %78 1
+%126 = OpSpecConstant %78 1
+%127 = OpSpecConstant %6 1
+%128 = OpSpecConstant %6 1
+%129 = OpSpecConstantComposite %19 %127 %128 %34
+%4 = OpFunction %2 None %3
+%5 = OpLabel
+%9 = OpVariable %8 Function
+%18 = OpVariable %8 Function
+%32 = OpVariable %31 Function
+%44 = OpVariable %31 Function
+%52 = OpVariable %31 Function
+%60 = OpVariable %31 Function
+%73 = OpVariable %72 Function
+%91 = OpVariable %72 Function
+%101 = OpVariable %72 Function
+%12 = OpLoad %6 %11
+%14 = OpUMod %6 %12 %13
+%15 = OpLoad %6 %11
+%16 = OpUDiv %6 %15 %13
+%17 = OpCompositeConstruct %7 %14 %16
+OpStore %9 %17
+%22 = OpLoad %19 %21
+%23 = OpVectorShuffle %7 %22 %22 0 1
+%24 = OpCompositeExtract %6 %23 0
+%25 = OpCompositeExtract %6 %23 1
+%26 = OpCompositeConstruct %7 %24 %25
+%28 = OpIMul %7 %26 %27
+%29 = OpLoad %7 %9
+%30 = OpIAdd %7 %28 %29
+OpStore %18 %30
+%35 = OpAccessChain %31 %18 %34
+%36 = OpLoad %6 %35
+%37 = OpIMul %6 %33 %36
+%40 = OpAccessChain %31 %18 %uint_0
+%41 = OpLoad %6 %40
+%42 = OpIMul %6 %38 %41
+%43 = OpIAdd %6 %37 %42
+OpStore %32 %43
+%45 = OpAccessChain %31 %18 %34
+%46 = OpLoad %6 %45
+%47 = OpIMul %6 %33 %46
+%48 = OpAccessChain %31 %18 %uint_0
+%49 = OpLoad %6 %48
+%50 = OpIMul %6 %38 %49
+%51 = OpIAdd %6 %47 %50
+OpStore %44 %51
+%53 = OpAccessChain %31 %18 %34
+%54 = OpLoad %6 %53
+%55 = OpIMul %6 %33 %54
+%56 = OpAccessChain %31 %18 %uint_0
+%57 = OpLoad %6 %56
+%58 = OpIMul %6 %38 %57
+%59 = OpIAdd %6 %55 %58
+OpStore %52 %59
+%61 = OpAccessChain %31 %18 %34
+%62 = OpLoad %6 %61
+%63 = OpIMul %6 %33 %62
+%64 = OpAccessChain %31 %18 %uint_0
+%65 = OpLoad %6 %64
+%66 = OpIMul %6 %38 %65
+%67 = OpIAdd %6 %63 %66
+OpStore %60 %67
+%80 = OpLoad %6 %32
+%83 = OpAccessChain %82 %77 %79 %80
+)";
+  if (useLoadStride) {
+    s += "%87 = OpCooperativeMatrixLoadKHR %71 %83 %layout %stride " +
+         loadMemoryAccess + " %81";
+  } else {
+    s += "%87 = OpCooperativeMatrixLoadKHR %71 %83 %layout";
+  }
+  s += R"(
+OpStore %73 %87
+%90 = OpLoad %71 %73
+OpStore %89 %90
+%96 = OpLoad %6 %44
+%97 = OpAccessChain %82 %95 %79 %96
+%98 = OpCooperativeMatrixLoadKHR %71 %97 %layout %stride MakePointerVisibleKHR|NonPrivatePointerKHR %81
+OpStore %91 %98
+%100 = OpLoad %71 %91
+OpStore %99 %100
+%106 = OpLoad %6 %52
+%107 = OpAccessChain %82 %105 %79 %106
+%108 = OpCooperativeMatrixLoadKHR %71 %107 %layout %stride MakePointerVisibleKHR|NonPrivatePointerKHR %81
+OpStore %101 %108
+%110 = OpLoad %71 %101
+OpStore %109 %110
+%114 = OpConvertSToF %68 %113
+%115 = OpCompositeConstruct %71 %114
+OpStore %111 %115
+%116 = OpLoad %71 %111
+%121 = OpLoad %6 %60
+%122 = OpAccessChain %82 %120 %79 %121
+)";
+  if (useStoreStride) {
+    s += "OpCooperativeMatrixStoreKHR %122 %116 %layout %stride " +
+         storeMemoryAccess + " %81";
+  } else {
+    s += "OpCooperativeMatrixStoreKHR %122 %116 %layout";
+  }
+  s += R"(
+OpReturn
+OpFunctionEnd
+)";
+
+  return s;
+}
+
 TEST_F(ValidateMemory, CoopMatKHRLoadStoreSuccess) {
-  std::string spirv =
-      GenCoopMatLoadStoreShader("MakePointerAvailableKHR|NonPrivatePointerKHR",
-                                "MakePointerVisibleKHR|NonPrivatePointerKHR");
+  std::string spirv = GenCoopMatLoadStoreShaderKHR(
+      "MakePointerAvailableKHR|NonPrivatePointerKHR",
+      "MakePointerVisibleKHR|NonPrivatePointerKHR");
+
+  CompileSuccessfully(spirv.c_str(), SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+}
+
+struct StrideMissingCase {
+  unsigned layout;
+  bool useLoadStride;
+  bool useStoreStride;
+};
+
+using ValidateCoopMatrixStrideMissing =
+    spvtest::ValidateBase<StrideMissingCase>;
+
+INSTANTIATE_TEST_SUITE_P(
+    CoopMatrixStrideMissing, ValidateCoopMatrixStrideMissing,
+    Values(
+        StrideMissingCase{(unsigned)spv::CooperativeMatrixLayout::RowMajorKHR,
+                          false, true},
+        StrideMissingCase{(unsigned)spv::CooperativeMatrixLayout::RowMajorKHR,
+                          true, false},
+        StrideMissingCase{
+            (unsigned)spv::CooperativeMatrixLayout::ColumnMajorKHR, false,
+            true},
+        StrideMissingCase{
+            (unsigned)spv::CooperativeMatrixLayout::ColumnMajorKHR, true,
+            false}));
+
+TEST_P(ValidateCoopMatrixStrideMissing, CoopMatKHRLoadStrideMissingFail) {
+  const StrideMissingCase& param = GetParam();
+  std::string spirv = GenCoopMatLoadStoreShaderKHR(
+      "MakePointerAvailableKHR|NonPrivatePointerKHR",
+      "MakePointerVisibleKHR|NonPrivatePointerKHR", param.layout,
+      false /*useSpecConstantLayout*/, param.useStoreStride,
+      param.useLoadStride);
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("MemoryLayout " + std::to_string(param.layout) +
+                        " requires a Stride"));
+}
+
+TEST_F(ValidateMemory, CoopMatKHRMemoryLayoutFromSpecConstantSuccess) {
+  std::string spirv = GenCoopMatLoadStoreShaderKHR(
+      "MakePointerAvailableKHR|NonPrivatePointerKHR",
+      "MakePointerVisibleKHR|NonPrivatePointerKHR",
+      (unsigned)spv::CooperativeMatrixLayout::RowMajorKHR,
+      true /*useSpecConstantLayout*/);
 
   CompileSuccessfully(spirv.c_str(), SPV_ENV_VULKAN_1_1);
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_1));
 }
 
 TEST_F(ValidateMemory, CoopMatKHRStoreMemoryAccessFail) {
-  std::string spirv =
-      GenCoopMatLoadStoreShader("MakePointerVisibleKHR|NonPrivatePointerKHR",
-                                "MakePointerVisibleKHR|NonPrivatePointerKHR");
+  std::string spirv = GenCoopMatLoadStoreShaderKHR(
+      "MakePointerVisibleKHR|NonPrivatePointerKHR",
+      "MakePointerVisibleKHR|NonPrivatePointerKHR");
 
   CompileSuccessfully(spirv.c_str(), SPV_ENV_VULKAN_1_1);
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
@@ -2369,9 +2633,9 @@ TEST_F(ValidateMemory, CoopMatKHRStoreMemoryAccessFail) {
 }
 
 TEST_F(ValidateMemory, CoopMatKHRLoadMemoryAccessFail) {
-  std::string spirv =
-      GenCoopMatLoadStoreShader("MakePointerAvailableKHR|NonPrivatePointerKHR",
-                                "MakePointerAvailableKHR|NonPrivatePointerKHR");
+  std::string spirv = GenCoopMatLoadStoreShaderKHR(
+      "MakePointerAvailableKHR|NonPrivatePointerKHR",
+      "MakePointerAvailableKHR|NonPrivatePointerKHR");
 
   CompileSuccessfully(spirv.c_str(), SPV_ENV_VULKAN_1_1);
   ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
@@ -3667,76 +3931,227 @@ OpMemoryModel Logical GLSL450
   CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("Initializer type must match the type pointed to by "
-                        "the Result Type"));
+              HasSubstr("Initializer type must match the data type"));
 }
 
-TEST_F(ValidateMemory, StoreToUniformBlock) {
+TEST_F(ValidateMemory, StoreToImage) {
   const std::string spirv = R"(
 OpCapability Shader
 OpMemoryModel Logical GLSL450
 OpEntryPoint GLCompute %main "main"
 OpExecutionMode %main LocalSize 1 1 1
-OpDecorate %struct Block
-OpMemberDecorate %struct 0 Offset 0
-OpDecorate %var DescriptorSet 0
-OpDecorate %var Binding 0
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
-%int_0 = OpConstant %int 0
-%int4 = OpTypeVector %int 4
-%struct = OpTypeStruct %int4
-%ptr_uniform_struct = OpTypePointer Uniform %struct
-%ptr_uniform_int4 = OpTypePointer Uniform %int4
-%ptr_uniform_int = OpTypePointer Uniform %int
-%var = OpVariable %ptr_uniform_struct Uniform
+%img = OpTypeImage %int 2D 2 0 0 2 R32i
+%ptr_img = OpTypePointer Function %img
 %void_fn = OpTypeFunction %void
 %main = OpFunction %void None %void_fn
 %entry = OpLabel
-%gep1 = OpAccessChain %ptr_uniform_int4 %var %int_0
-%gep2 = OpAccessChain %ptr_uniform_int %gep1 %int_0
-OpStore %gep2 %int_0
+%var = OpVariable %ptr_img Function
+%value = OpLoad %img %var
+OpStore %var %value
 OpReturn
 OpFunctionEnd
 )";
-
-  CompileSuccessfully(spirv);
-  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpTypeImage-06924"));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Cannot store to OpTypeImage, OpTypeSampler, "
+                "OpTypeSampledImage, or OpTypeAccelerationStructureKHR"));
 }
 
-TEST_F(ValidateMemory, StoreToUniformBlockVulkan) {
+TEST_F(ValidateMemory, StoreToImageArray) {
   const std::string spirv = R"(
 OpCapability Shader
 OpMemoryModel Logical GLSL450
 OpEntryPoint GLCompute %main "main"
 OpExecutionMode %main LocalSize 1 1 1
-OpDecorate %struct Block
-OpMemberDecorate %struct 0 Offset 0
-OpDecorate %var DescriptorSet 0
-OpDecorate %var Binding 0
 %void = OpTypeVoid
 %int = OpTypeInt 32 0
-%int_0 = OpConstant %int 0
-%int4 = OpTypeVector %int 4
-%struct = OpTypeStruct %int4
-%ptr_uniform_struct = OpTypePointer Uniform %struct
-%ptr_uniform_int4 = OpTypePointer Uniform %int4
-%ptr_uniform_int = OpTypePointer Uniform %int
-%var = OpVariable %ptr_uniform_struct Uniform
+%img = OpTypeImage %int 2D 2 0 0 2 R32i
+%arr_size = OpConstant %int 5
+%i = OpConstant %int 2
+%arr_img = OpTypeArray %img %arr_size
+%ptr_img = OpTypePointer Function %img
+%ptr_arr_img = OpTypePointer Function %arr_img
 %void_fn = OpTypeFunction %void
 %main = OpFunction %void None %void_fn
 %entry = OpLabel
-%gep1 = OpAccessChain %ptr_uniform_int4 %var %int_0
-%gep2 = OpAccessChain %ptr_uniform_int %gep1 %int_0
-OpStore %gep2 %int_0
+%var = OpVariable %ptr_arr_img Function
+%value = OpLoad %arr_img %var
+OpStore %var %value
 OpReturn
 OpFunctionEnd
 )";
-
   CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
   EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
   EXPECT_THAT(getDiagnosticString(),
-              AnyVUID("VUID-StandaloneSpirv-Uniform-06925"));
+              AnyVUID("VUID-StandaloneSpirv-OpTypeImage-06924"));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Cannot store to OpTypeImage, OpTypeSampler, "
+                "OpTypeSampledImage, or OpTypeAccelerationStructureKHR"));
+}
+
+TEST_F(ValidateMemory, StoreToSampler) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%void = OpTypeVoid
+%smp = OpTypeSampler
+%ptr_smp = OpTypePointer Function %smp
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%var = OpVariable %ptr_smp Function
+%value = OpLoad %smp %var
+OpStore %var %value
+OpReturn
+OpFunctionEnd
+)";
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpTypeImage-06924"));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Cannot store to OpTypeImage, OpTypeSampler, "
+                "OpTypeSampledImage, or OpTypeAccelerationStructureKHR"));
+}
+
+TEST_F(ValidateMemory, StoreToSampledImage) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%img = OpTypeImage %int 2D 2 0 0 1 R32i
+%samp_img = OpTypeSampledImage %img
+%ptr_samp_img = OpTypePointer Function %samp_img
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%var = OpVariable %ptr_samp_img Function
+%value = OpLoad %samp_img %var
+OpStore %var %value
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpTypeImage-06924"));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Cannot store to OpTypeImage, OpTypeSampler, "
+                "OpTypeSampledImage, or OpTypeAccelerationStructureKHR"));
+}
+
+TEST_F(ValidateMemory, StoreToAccelarationStructureKHR) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability RayQueryKHR
+OpExtension "SPV_KHR_ray_query"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%void = OpTypeVoid
+%as = OpTypeAccelerationStructureKHR
+%ptr_as = OpTypePointer Function %as
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%var = OpVariable %ptr_as Function
+%value = OpLoad %as %var
+OpStore %var %value
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-OpTypeImage-06924"));
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("Cannot store to OpTypeImage, OpTypeSampler, "
+                "OpTypeSampledImage, or OpTypeAccelerationStructureKHR"));
+}
+
+TEST_F(ValidateMemory, StoreToUniformBlock) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int4 = OpTypeVector %int 4
+%struct = OpTypeStruct %int4
+%ptr_uniform_struct = OpTypePointer Uniform %struct
+%ptr_uniform_int4 = OpTypePointer Uniform %int4
+%ptr_uniform_int = OpTypePointer Uniform %int
+%var = OpVariable %ptr_uniform_struct Uniform
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep1 = OpAccessChain %ptr_uniform_int4 %var %int_0
+%gep2 = OpAccessChain %ptr_uniform_int %gep1 %int_0
+OpStore %gep2 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, StoreToUniformBlockVulkan) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%int4 = OpTypeVector %int 4
+%struct = OpTypeStruct %int4
+%ptr_uniform_struct = OpTypePointer Uniform %struct
+%ptr_uniform_int4 = OpTypePointer Uniform %int4
+%ptr_uniform_int = OpTypePointer Uniform %int
+%var = OpVariable %ptr_uniform_struct Uniform
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep1 = OpAccessChain %ptr_uniform_int4 %var %int_0
+%gep2 = OpAccessChain %ptr_uniform_int %gep1 %int_0
+OpStore %gep2 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              AnyVUID("VUID-StandaloneSpirv-Uniform-06925"));
   EXPECT_THAT(
       getDiagnosticString(),
       HasSubstr("In the Vulkan environment, cannot store to Uniform Blocks"));
@@ -4897,6 +5312,128 @@ OpFunctionEnd
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
 }
 
+TEST_F(ValidateMemory, UntypedVariableGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Private
+%var = OpUntypedVariableKHR %ptr Private %int %int_0
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, UntypedVariableNoDataType) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, UntypedVariableNoDataTypeFunction) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Function
+%var = OpUntypedVariableKHR %ptr Function
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Data type must be specified for Function, "
+                        "Private, and Workgroup storage classes"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableNoDataTypePrivate) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Private
+%var = OpUntypedVariableKHR %ptr Private
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Data type must be specified for Function, "
+                        "Private, and Workgroup storage classes"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableNoDataTypeWorkgroup) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Data type must be specified for Function, "
+                        "Private, and Workgroup storage classes"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableNoDataTypeVulkan) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_VULKAN_1_1));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Vulkan requires that data type be specified"));
+}
+
 TEST_F(ValidateMemory, PtrAccessChainArrayStrideBad) {
   const std::string spirv = R"(
                OpCapability Shader
@@ -5115,6 +5652,2158 @@ TEST_F(ValidateMemory, VulkanPtrAccessChainWorkgroupNoArrayStrideSuccess) {
   EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_2));
 }
 
+TEST_F(ValidateMemory, AccessChainNegativeStructIndex32) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpMemoryModel Logical GLSL450
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%int = OpTypeInt 32 1
+%_struct_4 = OpTypeStruct %int %int %int
+%_ptr_Function__struct_4 = OpTypePointer Function %_struct_4
+%_ptr_Function_int = OpTypePointer Function %int
+%int_n224 = OpConstant %int -224
+%fn = OpFunction %void Inline %void_fn
+%entry = OpLabel
+%var = OpVariable %_ptr_Function__struct_4 Function
+%gep = OpInBoundsAccessChain %_ptr_Function_int %var %int_n224
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("Index is out of bounds"));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("cannot find index -224"));
+}
+
+TEST_F(ValidateMemory, AccessChainNegativeStructIndex64) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability Int64
+OpMemoryModel Logical GLSL450
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%int = OpTypeInt 32 1
+%long = OpTypeInt 64 1
+%_struct_4 = OpTypeStruct %int %int %int
+%_ptr_Function__struct_4 = OpTypePointer Function %_struct_4
+%_ptr_Function_int = OpTypePointer Function %int
+%long_n224 = OpConstant %long -224
+%fn = OpFunction %void Inline %void_fn
+%entry = OpLabel
+%var = OpVariable %_ptr_Function__struct_4 Function
+%gep = OpInBoundsAccessChain %_ptr_Function_int %var %long_n224
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("Index is out of bounds"));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("cannot find index -224"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableFunctionOutsideFunction) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Function
+%var = OpUntypedVariableKHR %ptr Function %int
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_LAYOUT, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Variables can not have a function[7] storage class "
+                        "outside of a function"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableBadResultType) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %int Workgroup %int
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Result type must be an untyped pointer"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableBadDataType) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %int_0
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Data type must be a type instruction"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableBadStorageClass) {
+  const std::string spirv = R"(
+OpCapability Kernel
+OpCapability GenericPointer
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical OpenCL
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Generic
+%var = OpUntypedVariableKHR %ptr Generic %int
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_BINARY,
+            ValidateInstructions(SPV_ENV_UNIVERSAL_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Variable storage class cannot be Generic"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableMismatchedStorageClass) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Private %int
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Storage class must match result type storage class"));
+}
+
+TEST_F(ValidateMemory, UntypedVariableBadInitializer) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%int = OpTypeInt 32 0
+%float = OpTypeFloat 32
+%float_0 = OpConstant %float 0
+%ptr = OpTypeUntypedPointerKHR Private
+%var = OpUntypedVariableKHR %ptr Private %int %float_0
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Initializer type must match the data type"));
+}
+
+TEST_F(ValidateMemory, AccessChainBaseUntypedPointer) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %var "var"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%ptr_ssbo_int = OpTypePointer StorageBuffer %int
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = OpAccessChain %ptr_ssbo_int %var %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("The Base <id> '2[%var]' in OpAccessChain "
+                        "instruction must be a pointer"));
+}
+
+using ValidateMemoryUntypedAccessChain = spvtest::ValidateBase<std::string>;
+
+TEST_P(ValidateMemoryUntypedAccessChain, GoodTypedPointerBase) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_ssbo StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %block %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, GoodUntypedPointerBase) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %block %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, ResultTypedPointer) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %gep "gep"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_ssbo StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%ptr_int = OpTypePointer StorageBuffer %int
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr_int %block %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("The Result Type of " + opcode +
+                        " <id> '2[%gep]' must be OpTypeUntypedPointer"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, BaseTypeNotAType) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %gep "gep"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_ssbo StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %int_0 %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Base type must be a non-pointer type"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, BaseTypedPointer) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %gep "gep"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_ssbo StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %ptr_ssbo %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Base type must be a non-pointer type"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, BaseUntypedPointer) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %gep "gep"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_ssbo StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %ptr %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Base type must be a non-pointer type"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, BaseNotAPointer) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %int_0 "int_0"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_ssbo = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_ssbo StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %int %int_0 )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("The Base <id> '2[%int_0]' in " + opcode +
+                        " instruction must be a pointer"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, StorageClassMismatch) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %int_0 "int_0"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_wg = OpTypePointer Workgroup %block
+%var = OpVariable %ptr_wg Workgroup
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %block %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("The result pointer storage class and base pointer storage "
+                "class in " +
+                opcode + " do not match"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, NonCompositeBase) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %int_0 "int_0"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_wg = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_wg StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %int %var )" +
+                            extra_param + R"( %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr(opcode + " reached non-composite type while indexes "
+                                 "still remain to be traversed"));
+}
+
+TEST_P(ValidateMemoryUntypedAccessChain, TooManyIndices) {
+  const std::string opcode = GetParam();
+  const bool ptr = opcode == "OpUntypedPtrAccessChainKHR" ||
+                   opcode == "OpUntypedInBoundsPtrAccessChainKHR";
+  const std::string extra_param = ptr ? "%int_0" : "";
+
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability VariablePointers
+OpExtension "SPV_KHR_variable_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpName %int_0 "int_0"
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%block = OpTypeStruct %int
+%ptr_wg = OpTypePointer StorageBuffer %block
+%var = OpVariable %ptr_wg StorageBuffer
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = )" + opcode + R"( %ptr %block %var )" +
+                            extra_param + R"( %int_0 %int_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr(opcode + " reached non-composite type while indexes "
+                                 "still remain to be traversed"));
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ValidateUntypedAccessChains, ValidateMemoryUntypedAccessChain,
+    Values("OpUntypedAccessChainKHR", "OpUntypedInBoundsAccessChainKHR",
+           "OpUntypedPtrAccessChainKHR", "OpUntypedInBoundsPtrAccessChainKHR"));
+
+TEST_F(ValidateMemory, LoadUntypedPointerGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%float = OpTypeFloat 32
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%load = OpLoad %float %var
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, StoreUntypedPointerGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%float = OpTypeFloat 32
+%float_0 = OpConstant %float 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpStore %var %float_0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, CopyMemoryUntypedPointerSourceGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var1 %var2
+OpName %var1 "var1"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%ptr_wg = OpTypePointer Workgroup %int
+%var2 = OpVariable %ptr_wg Workgroup
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemory %var2 %var1
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, CopyMemoryUntypedPointerTargetGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var1 %var2
+OpName %var1 "var1"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%ptr_wg = OpTypePointer Workgroup %int
+%var2 = OpVariable %ptr_wg Workgroup
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemory %var1 %var2
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, CopyMemoryUntypedPointerTargetAndSourceBad) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var1 %var2
+OpName %var1 "var1"
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%var2 = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemory %var1 %var2
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("One of Source or Target must be a typed pointer"));
+}
+
+TEST_F(ValidateMemory, CopyMemorySizedUntypedPointersGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %v1 %v2
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%int_4 = OpConstant %int 4
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%v1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%v2 = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemorySized %v2 %v1 %int_4
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, CopyMemorySizedUntypedPointersSizeBad1) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability StorageBuffer16BitAccess
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var_wg %var_ssbo
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%short = OpTypeInt 16 0
+%int_2 = OpConstant %int 2
+%struct = OpTypeStruct %int
+%ptr_ssbo = OpTypeUntypedPointerKHR StorageBuffer
+%ptr_wg = OpTypeUntypedPointerKHR Workgroup
+%var_ssbo = OpUntypedVariableKHR %ptr_ssbo StorageBuffer %struct
+%var_wg = OpUntypedVariableKHR %ptr_wg Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemorySized %var_ssbo %var_wg %int_2
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("Size must be a multiple of 4"));
+}
+
+TEST_F(ValidateMemory, CopyMemorySizedUntypedPointersSizeBad2) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability StorageBuffer16BitAccess
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var_ssbo %var_wg
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%short = OpTypeInt 16 0
+%int_2 = OpConstant %int 2
+%struct = OpTypeStruct %int
+%ptr_ssbo = OpTypeUntypedPointerKHR StorageBuffer
+%ptr_wg = OpTypeUntypedPointerKHR Workgroup
+%var_ssbo = OpUntypedVariableKHR %ptr_ssbo StorageBuffer %struct
+%var_wg = OpUntypedVariableKHR %ptr_wg Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemorySized %var_wg %var_ssbo %int_2
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("Size must be a multiple of 4"));
+}
+
+TEST_F(ValidateMemory, CopyMemorySizedUntypedPointersSizeBad3) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Int16
+OpCapability UntypedPointersKHR
+OpCapability StorageBuffer8BitAccess
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_8bit_storage"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var_ssbo %var_wg
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%short = OpTypeInt 16 0
+%int_1 = OpConstant %int 1
+%struct = OpTypeStruct %int
+%ptr_ssbo = OpTypeUntypedPointerKHR StorageBuffer
+%ptr_wg = OpTypeUntypedPointerKHR Workgroup
+%var_ssbo = OpUntypedVariableKHR %ptr_ssbo StorageBuffer %struct
+%var_wg = OpUntypedVariableKHR %ptr_wg Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemorySized %var_ssbo %var_wg %int_1
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("Size must be a multiple of 2"));
+}
+
+TEST_F(ValidateMemory, CopyMemorySizedUntypedPointersSizeBad4) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Int16
+OpCapability UntypedPointersKHR
+OpCapability StorageBuffer8BitAccess
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_8bit_storage"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %var_ssbo %var_wg
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%short = OpTypeInt 16 0
+%int_1 = OpConstant %int 1
+%struct = OpTypeStruct %int
+%ptr_ssbo = OpTypeUntypedPointerKHR StorageBuffer
+%ptr_wg = OpTypeUntypedPointerKHR Workgroup
+%var_ssbo = OpUntypedVariableKHR %ptr_ssbo StorageBuffer %struct
+%var_wg = OpUntypedVariableKHR %ptr_wg Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpCopyMemorySized %var_wg %var_ssbo %int_1
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("Size must be a multiple of 2"));
+}
+
+TEST_F(ValidateMemory, PtrEqualUntypedPointersGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %v1 %v2
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%bool = OpTypeBool
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%v1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%v2 = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%res = OpPtrEqual %bool %v1 %v2
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, PtrNotEqualUntypedPointersGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %v1 %v2
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%bool = OpTypeBool
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%v1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%v2 = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%res = OpPtrNotEqual %bool %v1 %v2
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, PtrDiffUntypedPointersGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main" %v1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%v1 = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%res = OpPtrDiff %int %v1 %v1
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
+TEST_F(ValidateMemory, UntypedVariableVulkanPushConstantGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR PushConstant
+%var = OpUntypedVariableKHR %ptr PushConstant %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+}
+
+TEST_F(ValidateMemory, UntypedVariableVulkanStorageBufferGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+}
+
+TEST_F(ValidateMemory, UntypedVariableVulkanUniformGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Uniform
+%var = OpUntypedVariableKHR %ptr Uniform %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_0);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_0));
+}
+
+TEST_F(ValidateMemory, UntypedVariableVulkanWorkgroupGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %struct Block
+OpMemberDecorate %struct 0 Offset 0
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%struct = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR Workgroup
+%var = OpUntypedVariableKHR %ptr Workgroup %struct
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_1_SPIRV_1_4);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_1_SPIRV_1_4));
+}
+
+TEST_F(ValidateMemory, UntypedPointerAsVariableType) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability VariablePointers
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%priv_ptr = OpTypePointer Private %ptr
+%var = OpVariable %priv_ptr Private
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+}
+
+TEST_F(ValidateMemory, UntypedArrayLengthGood) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%array = OpTypeRuntimeArray %int
+%block = OpTypeStruct %array
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %block
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%length = OpUntypedArrayLengthKHR %int %block %var 0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+}
+
+TEST_F(ValidateMemory, UntypedArrayLengthBadResultType) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%float = OpTypeFloat 32
+%array = OpTypeRuntimeArray %int
+%block = OpTypeStruct %array
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %block
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%length = OpUntypedArrayLengthKHR %float %block %var 0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must be OpTypeInt with width 32 and signedness 0"));
+}
+
+TEST_F(ValidateMemory, UntypedArrayLengthBadPointer) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%array = OpTypeRuntimeArray %int
+%block = OpTypeStruct %array
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%typed_ptr = OpTypePointer StorageBuffer %block
+%var = OpVariable %typed_ptr StorageBuffer
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%length = OpUntypedArrayLengthKHR %int %block %var 0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Pointer must be an untyped pointer"));
+}
+
+TEST_F(ValidateMemory, UntypedArrayLengtBadStruct) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%array = OpTypeRuntimeArray %int
+%block = OpTypeStruct %array
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %block
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%length = OpUntypedArrayLengthKHR %int %int %var 0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("to an OpTypeStruct"));
+}
+
+TEST_F(ValidateMemory, UntypedArrayLengthLastMemberNotArray) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%array = OpTypeRuntimeArray %int
+%block = OpTypeStruct %int
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %block
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%length = OpUntypedArrayLengthKHR %int %block %var 0
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must be an OpTypeRuntimeArray"));
+}
+
+TEST_F(ValidateMemory, UntypedArrayLengthBadIndex) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%int = OpTypeInt 32 0
+%array = OpTypeRuntimeArray %int
+%block = OpTypeStruct %array
+%ptr = OpTypeUntypedPointerKHR StorageBuffer
+%var = OpUntypedVariableKHR %ptr StorageBuffer %block
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%length = OpUntypedArrayLengthKHR %int %block %var 1
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must be the last member of the struct"));
+}
+
+TEST_F(ValidateMemory, UntypedCooperativeMatrixLoad) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability CooperativeMatrixKHR
+OpCapability VulkanMemoryModel
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_cooperative_matrix"
+OpMemoryModel Logical Vulkan
+OpEntryPoint GLCompute %main "main" %var
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%untyped = OpTypeUntypedPointerKHR StorageBuffer
+%float = OpTypeFloat 32
+%array = OpTypeRuntimeArray %float
+%block = OpTypeStruct %array
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%subgroup = OpConstant %int 3
+%rows = OpSpecConstant %int 1
+%cols = OpSpecConstant %int 1
+%matrix_a = OpConstant %int 1
+%stride = OpConstant %int 42
+%matrix = OpTypeCooperativeMatrixKHR %float %subgroup %rows %cols %matrix_a
+%var = OpUntypedVariableKHR %untyped StorageBuffer %block
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%ld = OpCooperativeMatrixLoadKHR %matrix %var %int_0 %stride
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
+}
+
+TEST_F(ValidateMemory, UntypedCooperativeMatrixLoad2) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability CooperativeMatrixKHR
+OpCapability VulkanMemoryModel
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_cooperative_matrix"
+OpMemoryModel Logical Vulkan
+OpEntryPoint GLCompute %main "main" %var
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var DescriptorSet 0
+OpDecorate %var Binding 0
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%untyped = OpTypeUntypedPointerKHR StorageBuffer
+%float = OpTypeFloat 32
+%array = OpTypeRuntimeArray %float
+%block = OpTypeStruct %array
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%subgroup = OpConstant %int 3
+%rows = OpSpecConstant %int 1
+%cols = OpSpecConstant %int 1
+%matrix_a = OpConstant %int 1
+%stride = OpConstant %int 42
+%matrix = OpTypeCooperativeMatrixKHR %float %subgroup %rows %cols %matrix_a
+%var = OpUntypedVariableKHR %untyped StorageBuffer %block
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = OpUntypedAccessChainKHR %untyped %block %var %int_0 %int_0
+%ld = OpCooperativeMatrixLoadKHR %matrix %gep %int_0 %stride
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
+}
+
+TEST_F(ValidateMemory, UntypedCooperativeMatrixStore) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability CooperativeMatrixKHR
+OpCapability VulkanMemoryModel
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_cooperative_matrix"
+OpMemoryModel Logical Vulkan
+OpEntryPoint GLCompute %main "main" %var1 %var2
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var1 DescriptorSet 0
+OpDecorate %var1 Binding 0
+OpDecorate %var2 DescriptorSet 0
+OpDecorate %var2 Binding 1
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%untyped = OpTypeUntypedPointerKHR StorageBuffer
+%float = OpTypeFloat 32
+%array = OpTypeRuntimeArray %float
+%block = OpTypeStruct %array
+%ptr = OpTypePointer StorageBuffer %block
+%ptr_float = OpTypePointer StorageBuffer %float
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%subgroup = OpConstant %int 3
+%rows = OpSpecConstant %int 1
+%cols = OpSpecConstant %int 1
+%matrix_a = OpConstant %int 1
+%stride = OpConstant %int 42
+%matrix = OpTypeCooperativeMatrixKHR %float %subgroup %rows %cols %matrix_a
+%var1 = OpVariable %ptr StorageBuffer
+%var2 = OpUntypedVariableKHR %untyped StorageBuffer %block
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = OpAccessChain %ptr_float %var1 %int_0 %int_0
+%ld = OpCooperativeMatrixLoadKHR %matrix %gep %int_0 %stride
+OpCooperativeMatrixStoreKHR %var2 %ld %int_0 %stride
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
+}
+
+TEST_F(ValidateMemory, UntypedCooperativeMatrixStore2) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability UntypedPointersKHR
+OpCapability CooperativeMatrixKHR
+OpCapability VulkanMemoryModel
+OpExtension "SPV_KHR_untyped_pointers"
+OpExtension "SPV_KHR_cooperative_matrix"
+OpMemoryModel Logical Vulkan
+OpEntryPoint GLCompute %main "main" %var1 %var2
+OpExecutionMode %main LocalSize 1 1 1
+OpDecorate %var1 DescriptorSet 0
+OpDecorate %var1 Binding 0
+OpDecorate %var2 DescriptorSet 0
+OpDecorate %var2 Binding 1
+OpDecorate %block Block
+OpMemberDecorate %block 0 Offset 0
+OpDecorate %array ArrayStride 4
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%untyped = OpTypeUntypedPointerKHR StorageBuffer
+%float = OpTypeFloat 32
+%array = OpTypeRuntimeArray %float
+%block = OpTypeStruct %array
+%ptr = OpTypePointer StorageBuffer %block
+%ptr_float = OpTypePointer StorageBuffer %float
+%int = OpTypeInt 32 0
+%int_0 = OpConstant %int 0
+%subgroup = OpConstant %int 3
+%rows = OpSpecConstant %int 1
+%cols = OpSpecConstant %int 1
+%matrix_a = OpConstant %int 1
+%stride = OpConstant %int 42
+%matrix = OpTypeCooperativeMatrixKHR %float %subgroup %rows %cols %matrix_a
+%var1 = OpVariable %ptr StorageBuffer
+%var2 = OpUntypedVariableKHR %untyped StorageBuffer %block
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+%gep = OpAccessChain %ptr_float %var1 %int_0 %int_0
+%ld = OpCooperativeMatrixLoadKHR %matrix %gep %int_0 %stride
+%gep2 = OpUntypedAccessChainKHR %untyped %block %var2 %int_0 %int_0
+OpCooperativeMatrixStoreKHR %gep2 %ld %int_0 %stride
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_VULKAN_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_VULKAN_1_3));
+}
+
+std::string GenCoopMat2Shader(const std::string& extra_types,
+                              const std::string& main_body,
+                              const std::string& after_main = "",
+                              const std::string& extra_decorations = "") {
+  const std::string prefix = R"(
+OpCapability Shader
+OpCapability Float16
+OpCapability PhysicalStorageBufferAddresses
+OpCapability VulkanMemoryModel
+OpCapability CooperativeMatrixKHR
+OpCapability TensorAddressingNV
+OpCapability CooperativeMatrixTensorAddressingNV
+OpCapability CooperativeMatrixBlockLoadsNV
+OpExtension "SPV_KHR_physical_storage_buffer"
+OpExtension "SPV_KHR_storage_buffer_storage_class"
+OpExtension "SPV_NV_tensor_addressing"
+OpExtension "SPV_NV_cooperative_matrix2"
+OpExtension "SPV_KHR_cooperative_matrix"
+OpExtension "SPV_KHR_vulkan_memory_model"
+OpMemoryModel Logical VulkanKHR
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+
+OpDecorate %f16_arr ArrayStride 2
+OpDecorate %46 Block
+OpMemberDecorate %46 0 Offset 0
+OpDecorate %48 Binding 0
+OpDecorate %48 DescriptorSet 0
+OpDecorate %psb Restrict
+)" + extra_decorations + R"(
+%void = OpTypeVoid
+%bool = OpTypeBool
+%func = OpTypeFunction %void
+%f16 = OpTypeFloat 16
+%f32 = OpTypeFloat 32
+%u32 = OpTypeInt 32 0
+%s32 = OpTypeInt 32 1
+
+%s32_0 = OpConstant %s32 0
+%f16_0 = OpConstant %f16 0
+%u32_2 = OpConstant %u32 2
+%u32_8 = OpConstant %u32 8
+%use_A = OpConstant %u32 0
+%workgroup = OpConstant %u32 2
+%subgroup = OpConstant %u32 3
+
+%f16_arr = OpTypeRuntimeArray %f16
+%46 = OpTypeStruct %f16_arr
+%47 = OpTypePointer StorageBuffer %46
+%48 = OpVariable %47 StorageBuffer
+%51 = OpTypePointer StorageBuffer %f16_arr
+%psbptr = OpTypePointer PhysicalStorageBuffer %f16_arr
+
+%f16mat = OpTypeCooperativeMatrixKHR %f16 %workgroup %u32_8 %u32_8 %use_A
+%f32mat = OpTypeCooperativeMatrixKHR %f32 %subgroup %u32_8 %u32_8 %use_A
+
+%arr2 = OpTypeArray %u32 %u32_2
+%functy = OpTypeFunction %f16 %psbptr %arr2 %arr2
+)";
+
+  const std::string decode_func =
+      R"(
+%decodefunc = OpFunction %f16 None %functy
+%psb = OpFunctionParameter %psbptr
+%c0 =  OpFunctionParameter %arr2
+%c1 =  OpFunctionParameter %arr2
+%entry2 = OpLabel
+OpReturnValue %f16_0
+OpFunctionEnd
+)";
+
+  const std::string func_begin =
+      R"(
+%main = OpFunction %void None %func
+%main_entry = OpLabel
+
+%array_ptr = OpAccessChain %51 %48 %s32_0
+)";
+
+  const std::string suffix =
+      R"(
+OpReturn
+OpFunctionEnd)";
+
+  return prefix + extra_types + func_begin + main_body + suffix + decode_func +
+         after_main;
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutAndViewSuccess) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutInvalidDimFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 6
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("must be between 1 and 5"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutInvalidClampFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 6
+      %dim = OpConstant %u32 2
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("must be a valid TensorClampMode"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewInvalidDimFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 6
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(), HasSubstr("must be between 1 and 5"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewInvalidPermutationFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1 %p1
+      )",
+      R"(
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Permutation values don't form a valid permutation"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewInvalidPermutation2Fail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Incorrect number of permutation values."));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutBlockSizePass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetBlockSizeNV %layout %tl %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutBlockSizeFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetBlockSizeNV %layout %tl %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("unexpected number of operands"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutDimensionPass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetDimensionNV %layout %tl %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutDimensionFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetDimensionNV %layout %tl %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("unexpected number of operands"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutStridePass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetStrideNV %layout %tl %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutStrideFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetStrideNV %layout %tl %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("unexpected number of operands"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutSlicePass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSliceNV %layout %tl %b %b %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutSliceFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSliceNV %layout %tl %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("unexpected number of operands"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorLayoutSetClampValuePass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 3
+      %b = OpConstant %u32 1
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      )",
+      R"(
+      %tl = OpCreateTensorLayoutNV %layout
+      %tl2 = OpTensorLayoutSetClampValueNV %layout %tl %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewDimensionPass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %hasdim = OpConstantFalse %bool
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %p2 = OpConstant %u32 2
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1 %p2
+      %b = OpConstant %u32 1
+      )",
+      R"(
+      %tv = OpCreateTensorViewNV %view
+      %tv2 = OpTensorViewSetDimensionNV %view %tv %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewDimensionFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %hasdim = OpConstantFalse %bool
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %p2 = OpConstant %u32 2
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1 %p2
+      %b = OpConstant %u32 1
+      )",
+      R"(
+      %tv = OpCreateTensorViewNV %view
+      %tv2 = OpTensorViewSetDimensionNV %view %tv %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("unexpected number of operands"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewStridePass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %hasdim = OpConstantFalse %bool
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %p2 = OpConstant %u32 2
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1 %p2
+      %b = OpConstant %u32 1
+      )",
+      R"(
+      %tv = OpCreateTensorViewNV %view
+      %tv2 = OpTensorViewSetStrideNV %view %tv %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewStrideFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %hasdim = OpConstantFalse %bool
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %p2 = OpConstant %u32 2
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1 %p2
+      %b = OpConstant %u32 1
+      )",
+      R"(
+      %tv = OpCreateTensorViewNV %view
+      %tv2 = OpTensorViewSetStrideNV %view %tv %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("unexpected number of operands"));
+}
+
+TEST_F(ValidateMemory, CoopMat2TensorViewClipPass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %dim = OpConstant %u32 3
+      %hasdim = OpConstantFalse %bool
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %p2 = OpConstant %u32 2
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1 %p2
+      %b = OpConstant %u32 1
+      )",
+      R"(
+      %tv = OpCreateTensorViewNV %view
+      %tv2 = OpTensorViewSetClipNV %view %tv %b %b %b %b
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2LoadStoreTensorPass) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      %mat = OpUndef %f16mat
+      %tl = OpCreateTensorLayoutNV %layout
+      %tv = OpCreateTensorViewNV %view
+      %mat2 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None None
+      %mat3 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl Aligned 4 None
+      %mat4 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None TensorView %tv
+      %mat5 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None DecodeFunc %decodefunc
+      %mat6 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None TensorView|DecodeFunc %tv %decodefunc
+      %mat7 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl Aligned 4 TensorView|DecodeFunc %tv %decodefunc
+      OpCooperativeMatrixStoreTensorNV %array_ptr %mat %tl None None
+      OpCooperativeMatrixStoreTensorNV %array_ptr %mat %tl Aligned 4 None
+      OpCooperativeMatrixStoreTensorNV %array_ptr %mat %tl None TensorView %tv
+      OpCooperativeMatrixStoreTensorNV %array_ptr %mat %tl Aligned 4 TensorView %tv
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_F(ValidateMemory, CoopMat2LoadTensorWrongLayoutTypeFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      %mat = OpUndef %f16mat
+      %tl = OpCreateTensorLayoutNV %layout
+      %tv = OpCreateTensorViewNV %view
+      %mat2 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tv None None
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("does not have a tensor layout type"));
+}
+
+TEST_F(ValidateMemory, CoopMat2LoadTensorWrongObjectTypeFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      %mat = OpUndef %f32mat
+      %tl = OpCreateTensorLayoutNV %layout
+      %tv = OpCreateTensorViewNV %view
+      %mat2 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None None
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("type does not match Result Type"));
+}
+
+TEST_F(ValidateMemory, CoopMat2LoadTensorDecodeFuncTypeFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      )",
+      R"(
+      %mat = OpUndef %f32mat
+      %tl = OpCreateTensorLayoutNV %layout
+      %tv = OpCreateTensorViewNV %view
+      %mat2 = OpCooperativeMatrixLoadTensorNV %f32mat %array_ptr %mat %tl None DecodeFunc %decodefunc
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("return type must match matrix component type"));
+}
+
+TEST_F(ValidateMemory, CoopMat2LoadTensorDecodeFuncArrayTypeFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %u32_3 = OpConstant %u32 3
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      %arr3 = OpTypeArray %u32 %u32_3
+      %functy2 = OpTypeFunction %f16 %psbptr %arr3 %arr3
+      )",
+      R"(
+      %mat = OpUndef %f16mat
+      %tl = OpCreateTensorLayoutNV %layout
+      %tv = OpCreateTensorViewNV %view
+      %mat2 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None DecodeFunc %decodefunc2
+      )",
+      R"(
+      %decodefunc2 = OpFunction %f16 None %functy2
+      %psb2 = OpFunctionParameter %psbptr
+      %c02 =  OpFunctionParameter %arr3
+      %c12 =  OpFunctionParameter %arr3
+      %entry3 = OpLabel
+      OpReturnValue %f16_0
+      OpFunctionEnd
+      )",
+      R"(
+      OpDecorate %psb2 Restrict
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("dimension equal to the tensor dimension"));
+}
+
+TEST_F(ValidateMemory, CoopMat2LoadTensorDecodeFuncPointerTypeFail) {
+  std::string spirv = GenCoopMat2Shader(
+      R"(
+      %clamp = OpConstant %u32 0
+      %dim = OpConstant %u32 2
+      %p0 = OpConstant %u32 0
+      %p1 = OpConstant %u32 1
+      %hasdim = OpConstantFalse %bool
+      %layout = OpTypeTensorLayoutNV %dim %clamp
+      %view = OpTypeTensorViewNV %dim %hasdim %p0 %p1
+      %sbptr = OpTypePointer StorageBuffer %f16_arr
+      %functy2 = OpTypeFunction %f16 %sbptr %arr2 %arr2
+      )",
+      R"(
+      %mat = OpUndef %f16mat
+      %tl = OpCreateTensorLayoutNV %layout
+      %tv = OpCreateTensorViewNV %view
+      %mat2 = OpCooperativeMatrixLoadTensorNV %f16mat %array_ptr %mat %tl None DecodeFunc %decodefunc2
+      )",
+      R"(
+      %decodefunc2 = OpFunction %f16 None %functy2
+      %sb = OpFunctionParameter %sbptr
+      %c02 =  OpFunctionParameter %arr2
+      %c12 =  OpFunctionParameter %arr2
+      %entry3 = OpLabel
+      OpReturnValue %f16_0
+      OpFunctionEnd
+      )");
+
+  CompileSuccessfully(spirv.c_str());
+  ASSERT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(
+      getDiagnosticString(),
+      HasSubstr("first parameter must be pointer to PhysicalStorageBuffer"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_misc_test.cpp b/test/val/val_misc_test.cpp
index b0e46bf9..2188e037 100644
--- a/test/val/val_misc_test.cpp
+++ b/test/val/val_misc_test.cpp
@@ -84,7 +84,28 @@ OpMemoryModel Logical GLSL450
       HasSubstr("Cannot create undefined values with 8- or 16-bit types"));
 }
 
-const std::string ShaderClockSpriv = R"(
+TEST_F(ValidateMisc, SizeOfValid) {
+  const std::string spirv = R"(
+               OpCapability Addresses
+               OpCapability Kernel
+               OpMemoryModel Physical64 OpenCL
+               OpEntryPoint Kernel %f "f"
+       %void = OpTypeVoid
+        %i32 = OpTypeInt 32 0
+        %ptr = OpTypePointer CrossWorkgroup %i32
+       %fnTy = OpTypeFunction %void
+          %f = OpFunction %void None %fnTy
+      %entry = OpLabel
+          %s = OpSizeOf %i32 %ptr
+               OpReturn
+               OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_1);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_1));
+}
+
+const std::string ShaderClockSpirv = R"(
 OpCapability Shader
 OpCapability Int64
 OpCapability ShaderClockKHR
@@ -103,7 +124,7 @@ OpName %time1 "time1"
 )";
 
 TEST_F(ValidateMisc, ShaderClockInt64) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %uint = OpTypeInt 32 0
 %_ptr_Function_uint = OpTypePointer Function %uint
@@ -123,7 +144,7 @@ OpFunctionEnd)";
 }
 
 TEST_F(ValidateMisc, ShaderClockVec2) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %ulong = OpTypeInt 64 0
 %_ptr_Function_ulong = OpTypePointer Function %ulong
@@ -145,7 +166,7 @@ OpFunctionEnd)";
 }
 
 TEST_F(ValidateMisc, ShaderClockInvalidScopeValue) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %ulong = OpTypeInt 64 0
 %uint = OpTypeInt 32 0
@@ -166,7 +187,7 @@ OpFunctionEnd)";
 }
 
 TEST_F(ValidateMisc, ShaderClockSubgroupScope) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %ulong = OpTypeInt 64 0
 %uint = OpTypeInt 32 0
@@ -186,7 +207,7 @@ OpFunctionEnd)";
 }
 
 TEST_F(ValidateMisc, ShaderClockDeviceScope) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %ulong = OpTypeInt 64 0
 %uint = OpTypeInt 32 0
@@ -206,7 +227,7 @@ OpFunctionEnd)";
 }
 
 TEST_F(ValidateMisc, ShaderClockWorkgroupScope) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %ulong = OpTypeInt 64 0
 %uint = OpTypeInt 32 0
@@ -222,13 +243,13 @@ OpReturn
 OpFunctionEnd)";
 
   CompileSuccessfully(spirv);
-  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions());
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_VULKAN_1_0));
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Scope must be Subgroup or Device"));
 }
 
 TEST_F(ValidateMisc, VulkanShaderClockWorkgroupScope) {
-  const std::string spirv = ShaderClockSpriv + R"(
+  const std::string spirv = ShaderClockSpirv + R"(
 %3 = OpTypeFunction %void
 %ulong = OpTypeInt 64 0
 %uint = OpTypeInt 32 0
@@ -251,6 +272,59 @@ OpFunctionEnd)";
               HasSubstr("Scope must be Subgroup or Device"));
 }
 
+std::string GenKernelClockSpirv(const std::string& scope) {
+  const std::string s = R"(
+OpCapability Kernel
+OpCapability Addresses
+OpCapability Int64
+OpCapability ShaderClockKHR
+OpExtension "SPV_KHR_shader_clock"
+OpMemoryModel Physical32 OpenCL
+OpEntryPoint Kernel %main "main"
+OpExecutionMode %main ContractionOff
+OpSource OpenCL_C 200000
+OpName %main "main"
+OpName %time1 "time1"
+%void = OpTypeVoid
+%3 = OpTypeFunction %void
+%ulong = OpTypeInt 64 0
+%uint = OpTypeInt 32 0
+%_ptr_Function_ulong = OpTypePointer Function %ulong
+%scope = OpConstant %uint )" +
+                        scope + R"(
+%main = OpFunction %void None %3
+%5 = OpLabel
+%time1 = OpVariable %_ptr_Function_ulong Function
+%11 = OpReadClockKHR %ulong %scope
+OpStore %time1 %11
+OpReturn
+OpFunctionEnd
+)";
+  return s;
+}
+
+TEST_F(ValidateMisc, KernelClockScopeDevice) {
+  CompileSuccessfully(GenKernelClockSpirv("1"), SPV_ENV_OPENCL_1_2);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_OPENCL_1_2));
+}
+
+TEST_F(ValidateMisc, KernelClockScopeWorkgroup) {
+  CompileSuccessfully(GenKernelClockSpirv("2"), SPV_ENV_OPENCL_1_2);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_OPENCL_1_2));
+}
+
+TEST_F(ValidateMisc, KernelClockScopeSubgroup) {
+  CompileSuccessfully(GenKernelClockSpirv("3"), SPV_ENV_OPENCL_1_2);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_OPENCL_1_2));
+}
+
+TEST_F(ValidateMisc, KernelClockScopeInvalid) {
+  CompileSuccessfully(GenKernelClockSpirv("0"), SPV_ENV_OPENCL_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_DATA, ValidateInstructions(SPV_ENV_OPENCL_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("Scope must be Subgroup, Workgroup, or Device"));
+}
+
 TEST_F(ValidateMisc, UndefVoid) {
   const std::string spirv = R"(
                OpCapability Shader
@@ -297,6 +371,77 @@ OpEntryPoint Vertex %func "shader"
   EXPECT_THAT(getDiagnosticString(),
               HasSubstr("Invalid storage class for target environment"));
 }
+
+TEST_F(ValidateMisc, CoopMat2WorkgroupLocalSizeIdPass) {
+  const std::string body = R"(
+OpCapability Shader
+OpCapability Float16
+OpCapability Int16
+OpCapability CooperativeMatrixKHR
+OpExtension "SPV_KHR_cooperative_matrix"
+OpExtension "SPV_KHR_vulkan_memory_model"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionModeId %main LocalSizeId %u32_16 %u32_16 %u32_16
+%void = OpTypeVoid
+%func = OpTypeFunction %void
+%bool = OpTypeBool
+%f16 = OpTypeFloat 16
+%u32 = OpTypeInt 32 0
+
+%u32_16 = OpConstant %u32 16
+%use_Acc = OpConstant %u32 2
+%workgroup = OpConstant %u32 2
+
+%f16mat = OpTypeCooperativeMatrixKHR %f16 %workgroup %u32_16 %u32_16 %use_Acc
+
+%main = OpFunction %void None %func
+%main_entry = OpLabel
+
+OpReturn
+OpFunctionEnd)";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+}
+
+TEST_F(ValidateMisc, CoopMat2WorkgroupLocalSizeIdConstantNotDeclaredYetFail) {
+  const std::string body = R"(
+OpCapability Shader
+OpCapability Float16
+OpCapability Int16
+OpCapability CooperativeMatrixKHR
+OpExtension "SPV_KHR_cooperative_matrix"
+OpExtension "SPV_KHR_vulkan_memory_model"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionModeId %main LocalSizeId %u32_16 %u32_8 %u32_16
+%void = OpTypeVoid
+%func = OpTypeFunction %void
+%bool = OpTypeBool
+%f16 = OpTypeFloat 16
+%u32 = OpTypeInt 32 0
+
+%u32_16 = OpConstant %u32 16
+%use_Acc = OpConstant %u32 2
+%workgroup = OpConstant %u32 2
+
+%f16mat = OpTypeCooperativeMatrixKHR %f16 %workgroup %u32_16 %u32_16 %use_Acc
+%u32_8 = OpConstant %u32 8
+
+%main = OpFunction %void None %func
+%main_entry = OpLabel
+
+OpReturn
+OpFunctionEnd)";
+
+  CompileSuccessfully(body.c_str(), SPV_ENV_UNIVERSAL_1_3);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_3));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("OpTypeCooperativeMatrixKHR with ScopeWorkgroup used "
+                        "before LocalSizeId constant value"));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_modes_test.cpp b/test/val/val_modes_test.cpp
index a0ea4288..83a05037 100644
--- a/test/val/val_modes_test.cpp
+++ b/test/val/val_modes_test.cpp
@@ -1027,6 +1027,162 @@ OpExecutionModeId %main LocalSizeId %int_1 %int_1 %int_1
                         "constant instructions."));
 }
 
+using AllowMultipleExecutionModes = spvtest::ValidateBase<std::string>;
+
+TEST_P(AllowMultipleExecutionModes, DifferentOperand) {
+  const std::string mode = GetParam();
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability DenormPreserve
+OpCapability DenormFlushToZero
+OpCapability SignedZeroInfNanPreserve
+OpCapability RoundingModeRTE
+OpCapability RoundingModeRTZ
+OpExtension "SPV_KHR_float_controls"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpExecutionMode %main )" + mode +
+                            R"( 16
+OpExecutionMode %main )" + mode +
+                            R"( 32
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions());
+}
+
+TEST_P(AllowMultipleExecutionModes, SameOperand) {
+  const std::string mode = GetParam();
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability DenormPreserve
+OpCapability DenormFlushToZero
+OpCapability SignedZeroInfNanPreserve
+OpCapability RoundingModeRTE
+OpCapability RoundingModeRTZ
+OpExtension "SPV_KHR_float_controls"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpExecutionMode %main )" + mode +
+                            R"( 32
+OpExecutionMode %main )" + mode +
+                            R"( 32
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("execution mode must not be specified multiple times "
+                        "for the same entry point and operands"));
+}
+
+INSTANTIATE_TEST_SUITE_P(MultipleFloatControlsExecModes,
+                         AllowMultipleExecutionModes,
+                         Values("DenormPreserve", "DenormFlushToZero",
+                                "SignedZeroInfNanPreserve", "RoundingModeRTE",
+                                "RoundingModeRTZ"));
+
+using MultipleExecModes = spvtest::ValidateBase<std::string>;
+
+TEST_P(MultipleExecModes, DuplicateMode) {
+  const std::string mode = GetParam();
+  const std::string spirv = R"(
+OpCapability Shader
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main"
+OpExecutionMode %main OriginUpperLeft
+OpExecutionMode %main )" + mode +
+                            R"(
+OpExecutionMode %main )" + mode +
+                            R"(
+%void = OpTypeVoid
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions());
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("execution mode must not be specified multiple times "
+                        "per entry point"));
+}
+
+INSTANTIATE_TEST_SUITE_P(MultipleFragmentExecMode, MultipleExecModes,
+                         Values("DepthReplacing", "DepthGreater", "DepthLess",
+                                "DepthUnchanged"));
+
+TEST_F(ValidateMode, FloatControls2FPFastMathDefaultSameOperand) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability FloatControls2
+OpExtension "SPV_KHR_float_controls2"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpExecutionModeId %main FPFastMathDefault %float %none
+OpExecutionModeId %main FPFastMathDefault %float %none
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%none = OpConstant %int 0
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_2);
+  EXPECT_EQ(SPV_ERROR_INVALID_ID, ValidateInstructions(SPV_ENV_UNIVERSAL_1_2));
+  EXPECT_THAT(getDiagnosticString(),
+              HasSubstr("execution mode must not be specified multiple times "
+                        "for the same entry point and operands"));
+}
+
+TEST_F(ValidateMode, FloatControls2FPFastMathDefaultDifferentOperand) {
+  const std::string spirv = R"(
+OpCapability Shader
+OpCapability Float16
+OpCapability FloatControls2
+OpExtension "SPV_KHR_float_controls2"
+OpMemoryModel Logical GLSL450
+OpEntryPoint GLCompute %main "main"
+OpExecutionMode %main LocalSize 1 1 1
+OpExecutionModeId %main FPFastMathDefault %float %none
+OpExecutionModeId %main FPFastMathDefault %half %none
+%void = OpTypeVoid
+%float = OpTypeFloat 32
+%int = OpTypeInt 32 0
+%none = OpConstant %int 0
+%half = OpTypeFloat 16
+%void_fn = OpTypeFunction %void
+%main = OpFunction %void None %void_fn
+%entry = OpLabel
+OpReturn
+OpFunctionEnd
+)";
+
+  CompileSuccessfully(spirv, SPV_ENV_UNIVERSAL_1_2);
+  EXPECT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_2));
+}
+
 TEST_F(ValidateMode, FragmentShaderInterlockVertexBad) {
   const std::string spirv = R"(
 OpCapability Shader
diff --git a/test/val/val_storage_test.cpp b/test/val/val_storage_test.cpp
index 6a3e4bdb..d4170e6d 100644
--- a/test/val/val_storage_test.cpp
+++ b/test/val/val_storage_test.cpp
@@ -165,7 +165,7 @@ TEST_F(ValidateStorage, GenericVariableOutsideFunction) {
   CompileSuccessfully(str);
   ASSERT_EQ(SPV_ERROR_INVALID_BINARY, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("OpVariable storage class cannot be Generic"));
+              HasSubstr("Variable storage class cannot be Generic"));
 }
 
 TEST_F(ValidateStorage, GenericVariableInsideFunction) {
@@ -187,7 +187,7 @@ TEST_F(ValidateStorage, GenericVariableInsideFunction) {
   CompileSuccessfully(str);
   EXPECT_EQ(SPV_ERROR_INVALID_BINARY, ValidateInstructions());
   EXPECT_THAT(getDiagnosticString(),
-              HasSubstr("OpVariable storage class cannot be Generic"));
+              HasSubstr("Variable storage class cannot be Generic"));
 }
 
 TEST_F(ValidateStorage, RelaxedLogicalPointerFunctionParam) {
diff --git a/test/val/val_type_unique_test.cpp b/test/val/val_type_unique_test.cpp
index 31ad3a65..00e2e7f1 100644
--- a/test/val/val_type_unique_test.cpp
+++ b/test/val/val_type_unique_test.cpp
@@ -270,6 +270,24 @@ OpMemoryModel Logical GLSL450
               Not(HasSubstr(GetErrorString(spv::Op::OpTypePointer))));
 }
 
+TEST_F(ValidateTypeUnique, DuplicateUntypedPointer) {
+  std::string str = R"(
+OpCapability Shader
+OpCapability Linkage
+OpCapability UntypedPointersKHR
+OpCapability WorkgroupMemoryExplicitLayoutKHR
+OpExtension "SPV_KHR_workgroup_memory_explicit_layout"
+OpExtension "SPV_KHR_untyped_pointers"
+OpMemoryModel Logical GLSL450
+%u32 = OpTypeInt 32 0
+%ptr1 = OpTypeUntypedPointerKHR Workgroup
+%ptr2 = OpTypeUntypedPointerKHR Workgroup
+)";
+
+  CompileSuccessfully(str.c_str(), SPV_ENV_UNIVERSAL_1_4);
+  ASSERT_EQ(SPV_SUCCESS, ValidateInstructions(SPV_ENV_UNIVERSAL_1_4));
+}
+
 }  // namespace
 }  // namespace val
 }  // namespace spvtools
diff --git a/test/val/val_version_test.cpp b/test/val/val_version_test.cpp
index 6b7c4fe8..743567c3 100644
--- a/test/val/val_version_test.cpp
+++ b/test/val/val_version_test.cpp
@@ -79,6 +79,7 @@ std::string version(spv_target_env env) {
       return "1.5";
     case SPV_ENV_UNIVERSAL_1_6:
     case SPV_ENV_VULKAN_1_3:
+    case SPV_ENV_VULKAN_1_4:
       return "1.6";
     default:
       return "0";
@@ -117,6 +118,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_VULKAN_1_1_SPIRV_1_4,vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_OPENGL_4_0,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_OPENGL_4_1,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_0, SPV_ENV_OPENGL_4_2,    vulkan_spirv, true),
@@ -135,6 +137,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_1, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -153,6 +156,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_2, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -171,6 +175,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_3, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -189,6 +194,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_4, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -207,6 +213,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_5, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -225,6 +232,7 @@ INSTANTIATE_TEST_SUITE_P(Universal, ValidateVersion,
     std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_VULKAN_1_2,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_UNIVERSAL_1_6, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -248,6 +256,7 @@ INSTANTIATE_TEST_SUITE_P(Vulkan, ValidateVersion,
     std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_OPENGL_4_0,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_OPENGL_4_1,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_0, SPV_ENV_OPENGL_4_2,    vulkan_spirv, true),
@@ -266,6 +275,7 @@ INSTANTIATE_TEST_SUITE_P(Vulkan, ValidateVersion,
     std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_1, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -284,6 +294,7 @@ INSTANTIATE_TEST_SUITE_P(Vulkan, ValidateVersion,
     std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_1_SPIRV_1_4, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -302,6 +313,7 @@ INSTANTIATE_TEST_SUITE_P(Vulkan, ValidateVersion,
     std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_VULKAN_1_2,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_2, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
@@ -320,11 +332,33 @@ INSTANTIATE_TEST_SUITE_P(Vulkan, ValidateVersion,
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_VULKAN_1_2,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
     std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_OPENGL_4_3,    vulkan_spirv, false),
-    std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_OPENGL_4_5,    vulkan_spirv, false)
+    std::make_tuple(SPV_ENV_VULKAN_1_3, SPV_ENV_OPENGL_4_5,    vulkan_spirv, false),
+
+    // Assembling for Vulkan 1.4 produces SPIR-V 1.6
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_0, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_1, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_2, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_3, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_4, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_5, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_UNIVERSAL_1_6, vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_0,    vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_1,    vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_1_SPIRV_1_4, vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_2,    vulkan_spirv, false),
+    // Vulkan 1.3 accepts SPIR-V 1.6
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_3,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_VULKAN_1_4,    vulkan_spirv, true),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_OPENGL_4_0,    vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_OPENGL_4_1,    vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_OPENGL_4_2,    vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_OPENGL_4_3,    vulkan_spirv, false),
+    std::make_tuple(SPV_ENV_VULKAN_1_4, SPV_ENV_OPENGL_4_5,    vulkan_spirv, false)
   )
 );
 
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index a93f6404..a6736ca3 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -42,17 +42,18 @@ endfunction()
 set(COMMON_TOOLS_SRCS "${CMAKE_CURRENT_SOURCE_DIR}/util/flags.cpp")
 
 if (NOT ${SPIRV_SKIP_EXECUTABLES})
-  add_spvtools_tool(TARGET spirv-diff SRCS ${COMMON_TOOLS_SRCS} diff/diff.cpp util/cli_consumer.cpp LIBS SPIRV-Tools-diff SPIRV-Tools-opt ${SPIRV_TOOLS_FULL_VISIBILITY})
-  add_spvtools_tool(TARGET spirv-dis  SRCS ${COMMON_TOOLS_SRCS} dis/dis.cpp LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
-  add_spvtools_tool(TARGET spirv-val  SRCS ${COMMON_TOOLS_SRCS} val/val.cpp util/cli_consumer.cpp LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
-  add_spvtools_tool(TARGET spirv-opt  SRCS ${COMMON_TOOLS_SRCS} opt/opt.cpp util/cli_consumer.cpp LIBS SPIRV-Tools-opt ${SPIRV_TOOLS_FULL_VISIBILITY})
+  add_spvtools_tool(TARGET spirv-diff SRCS ${COMMON_TOOLS_SRCS} diff/diff.cpp util/cli_consumer.cpp io.cpp LIBS SPIRV-Tools-diff SPIRV-Tools-opt ${SPIRV_TOOLS_FULL_VISIBILITY})
+  add_spvtools_tool(TARGET spirv-dis  SRCS ${COMMON_TOOLS_SRCS} dis/dis.cpp io.cpp LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
+  add_spvtools_tool(TARGET spirv-val  SRCS ${COMMON_TOOLS_SRCS} val/val.cpp util/cli_consumer.cpp io.cpp LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
+  add_spvtools_tool(TARGET spirv-opt  SRCS ${COMMON_TOOLS_SRCS} opt/opt.cpp util/cli_consumer.cpp io.cpp LIBS SPIRV-Tools-opt ${SPIRV_TOOLS_FULL_VISIBILITY})
   if(NOT (${CMAKE_SYSTEM_NAME} STREQUAL "iOS")) # iOS does not allow std::system calls which spirv-reduce requires
-    add_spvtools_tool(TARGET spirv-reduce SRCS ${COMMON_TOOLS_SRCS} reduce/reduce.cpp util/cli_consumer.cpp LIBS SPIRV-Tools-reduce ${SPIRV_TOOLS_FULL_VISIBILITY})
+    add_spvtools_tool(TARGET spirv-reduce SRCS ${COMMON_TOOLS_SRCS} reduce/reduce.cpp util/cli_consumer.cpp io.cpp LIBS SPIRV-Tools-reduce ${SPIRV_TOOLS_FULL_VISIBILITY})
   endif()
-  add_spvtools_tool(TARGET spirv-link SRCS ${COMMON_TOOLS_SRCS} link/linker.cpp LIBS SPIRV-Tools-link ${SPIRV_TOOLS_FULL_VISIBILITY})
-  add_spvtools_tool(TARGET spirv-lint SRCS ${COMMON_TOOLS_SRCS} lint/lint.cpp util/cli_consumer.cpp LIBS SPIRV-Tools-lint SPIRV-Tools-opt ${SPIRV_TOOLS_FULL_VISIBILITY})
+  add_spvtools_tool(TARGET spirv-link SRCS ${COMMON_TOOLS_SRCS} link/linker.cpp io.cpp LIBS SPIRV-Tools-link ${SPIRV_TOOLS_FULL_VISIBILITY})
+  add_spvtools_tool(TARGET spirv-lint SRCS ${COMMON_TOOLS_SRCS} lint/lint.cpp util/cli_consumer.cpp io.cpp LIBS SPIRV-Tools-lint SPIRV-Tools-opt ${SPIRV_TOOLS_FULL_VISIBILITY})
   add_spvtools_tool(TARGET spirv-as
                     SRCS as/as.cpp
+                         io.cpp
                          ${COMMON_TOOLS_SRCS}
                     LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
   target_include_directories(spirv-as PRIVATE ${spirv-tools_SOURCE_DIR}
@@ -61,6 +62,7 @@ if (NOT ${SPIRV_SKIP_EXECUTABLES})
                     SRCS cfg/cfg.cpp
                          cfg/bin_to_dot.h
                          cfg/bin_to_dot.cpp
+                         io.cpp
                          ${COMMON_TOOLS_SRCS}
                     LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
   target_include_directories(spirv-cfg PRIVATE ${spirv-tools_SOURCE_DIR}
@@ -73,6 +75,7 @@ if (NOT ${SPIRV_SKIP_EXECUTABLES})
                       SRCS objdump/objdump.cpp
                            objdump/extract_source.cpp
                            util/cli_consumer.cpp
+                           io.cpp
                            ${COMMON_TOOLS_SRCS}
                       LIBS ${SPIRV_TOOLS_FULL_VISIBILITY})
     target_include_directories(spirv-objdump PRIVATE ${spirv-tools_SOURCE_DIR}
@@ -85,7 +88,7 @@ if (NOT ${SPIRV_SKIP_EXECUTABLES})
   endif()
 
   if(SPIRV_BUILD_FUZZER)
-    add_spvtools_tool(TARGET spirv-fuzz SRCS fuzz/fuzz.cpp util/cli_consumer.cpp LIBS SPIRV-Tools-fuzz ${SPIRV_TOOLS_FULL_VISIBILITY})
+    add_spvtools_tool(TARGET spirv-fuzz SRCS fuzz/fuzz.cpp util/cli_consumer.cpp io.cpp LIBS SPIRV-Tools-fuzz ${SPIRV_TOOLS_FULL_VISIBILITY})
     set(SPIRV_INSTALL_TARGETS ${SPIRV_INSTALL_TARGETS} spirv-fuzz)
   endif(SPIRV_BUILD_FUZZER)
 
diff --git a/tools/as/as.cpp b/tools/as/as.cpp
index 2a000cf0..8e821701 100644
--- a/tools/as/as.cpp
+++ b/tools/as/as.cpp
@@ -22,7 +22,7 @@
 #include "tools/io.h"
 #include "tools/util/flags.h"
 
-static const auto kDefaultEnvironment = "spv1.6";
+constexpr auto kDefaultTarget = SPV_ENV_UNIVERSAL_1_6;
 static const std::string kHelpText =
     R"(%s - Create a SPIR-V binary module from SPIR-V assembly text
 
@@ -48,12 +48,13 @@ Options:
 )";
 
 // clang-format off
-FLAG_SHORT_bool(  h,                    /* default_value= */ false,               /* required= */ false);
-FLAG_LONG_bool(   help,                 /* default_value= */ false,               /* required= */false);
-FLAG_LONG_bool(   version,              /* default_value= */ false,               /* required= */ false);
-FLAG_LONG_bool(   preserve_numeric_ids, /* default_value= */ false,               /* required= */ false);
-FLAG_SHORT_string(o,                    /* default_value= */ "",                  /* required= */ false);
-FLAG_LONG_string( target_env,           /* default_value= */ kDefaultEnvironment, /* required= */ false);
+//                flag name=            default_value=   required=
+FLAG_SHORT_bool(  h,                    false,           false);
+FLAG_LONG_bool(   help,                 false,           false);
+FLAG_LONG_bool(   version,              false,           false);
+FLAG_LONG_bool(   preserve_numeric_ids, false,           false);
+FLAG_SHORT_string(o,                    "",              false);
+FLAG_LONG_string( target_env,           "",              false);
 // clang-format on
 
 int main(int, const char** argv) {
@@ -68,17 +69,8 @@ int main(int, const char** argv) {
   }
 
   if (flags::version.value()) {
-    spv_target_env target_env;
-    bool success = spvParseTargetEnv(kDefaultEnvironment, &target_env);
-    assert(success && "Default environment should always parse.");
-    if (!success) {
-      fprintf(stderr,
-              "error: invalid default target environment. Please report this "
-              "issue.");
-      return 1;
-    }
     printf("%s\n", spvSoftwareVersionDetailsString());
-    printf("Target: %s\n", spvTargetEnvDescription(target_env));
+    printf("Target: %s\n", spvTargetEnvDescription(kDefaultTarget));
     return 0;
   }
 
@@ -92,13 +84,6 @@ int main(int, const char** argv) {
     options |= SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS;
   }
 
-  spv_target_env target_env;
-  if (!spvParseTargetEnv(flags::target_env.value().c_str(), &target_env)) {
-    fprintf(stderr, "error: Unrecognized target env: %s\n",
-            flags::target_env.value().c_str());
-    return 1;
-  }
-
   if (flags::positional_arguments.size() != 1) {
     fprintf(stderr, "error: exactly one input file must be specified.\n");
     return 1;
@@ -106,7 +91,21 @@ int main(int, const char** argv) {
   std::string inFile = flags::positional_arguments[0];
 
   std::vector<char> contents;
-  if (!ReadTextFile<char>(inFile.c_str(), &contents)) return 1;
+  if (!ReadTextFile(inFile.c_str(), &contents)) return 1;
+
+  // Can only deduce target after the file has been read
+  spv_target_env target_env;
+  if (flags::target_env.value().empty()) {
+    if (!spvReadEnvironmentFromText(contents, &target_env)) {
+      // Revert to default version since deduction failed
+      target_env = kDefaultTarget;
+    }
+  } else if (!spvParseTargetEnv(flags::target_env.value().c_str(),
+                                &target_env)) {
+    fprintf(stderr, "error: Unrecognized target env: %s\n",
+            flags::target_env.value().c_str());
+    return 1;
+  }
 
   spv_binary binary;
   spv_diagnostic diagnostic = nullptr;
diff --git a/tools/cfg/cfg.cpp b/tools/cfg/cfg.cpp
index 2d11e6fb..2c689042 100644
--- a/tools/cfg/cfg.cpp
+++ b/tools/cfg/cfg.cpp
@@ -75,7 +75,7 @@ int main(int, const char** argv) {
 
   // Read the input binary.
   std::vector<uint32_t> contents;
-  if (!ReadBinaryFile<uint32_t>(inFile.c_str(), &contents)) return 1;
+  if (!ReadBinaryFile(inFile.c_str(), &contents)) return 1;
   spv_context context = spvContextCreate(kDefaultEnvironment);
   spv_diagnostic diagnostic = nullptr;
 
diff --git a/tools/diff/diff.cpp b/tools/diff/diff.cpp
index 2217896c..d60edb2e 100644
--- a/tools/diff/diff.cpp
+++ b/tools/diff/diff.cpp
@@ -82,7 +82,7 @@ bool is_assembly(const char* path) {
 std::unique_ptr<spvtools::opt::IRContext> load_module(const char* path) {
   if (is_assembly(path)) {
     std::vector<char> contents;
-    if (!ReadTextFile<char>(path, &contents)) return {};
+    if (!ReadTextFile(path, &contents)) return {};
 
     return spvtools::BuildModule(
         kDefaultEnvironment, spvtools::utils::CLIMessageConsumer,
@@ -92,7 +92,7 @@ std::unique_ptr<spvtools::opt::IRContext> load_module(const char* path) {
   }
 
   std::vector<uint32_t> contents;
-  if (!ReadBinaryFile<uint32_t>(path, &contents)) return {};
+  if (!ReadBinaryFile(path, &contents)) return {};
 
   return spvtools::BuildModule(kDefaultEnvironment,
                                spvtools::utils::CLIMessageConsumer,
diff --git a/tools/dis/dis.cpp b/tools/dis/dis.cpp
index aacd37f0..c294d039 100644
--- a/tools/dis/dis.cpp
+++ b/tools/dis/dis.cpp
@@ -33,44 +33,57 @@ Usage: %s [options] [<filename>]
 The SPIR-V binary is read from <filename>. If no file is specified,
 or if the filename is "-", then the binary is read from standard input.
 
+A text-based hex stream is also accepted as binary input, which should either
+consist of 32-bit words or 8-bit bytes.  The 0x or x prefix is optional, but
+should be consistently present in the stream.
+
 Options:
 
-  -h, --help      Print this help.
-  --version       Display disassembler version information.
+  -h, --help        Print this help.
+  --version         Display disassembler version information.
+
+  -o <filename>     Set the output filename.
+                    Output goes to standard output if this option is
+                    not specified, or if the filename is "-".
+
+  --color           Force color output.  The default when printing to a terminal.
+                    Overrides a previous --no-color option.
+  --no-color        Don't print in color.  Overrides a previous --color option.
+                    The default when output goes to something other than a
+                    terminal (e.g. a file, a pipe, or a shell redirection).
 
-  -o <filename>   Set the output filename.
-                  Output goes to standard output if this option is
-                  not specified, or if the filename is "-".
+  --no-indent       Don't indent instructions.
 
-  --color         Force color output.  The default when printing to a terminal.
-                  Overrides a previous --no-color option.
-  --no-color      Don't print in color.  Overrides a previous --color option.
-                  The default when output goes to something other than a
-                  terminal (e.g. a file, a pipe, or a shell redirection).
+  --no-header       Don't output the header as leading comments.
 
-  --no-indent     Don't indent instructions.
+  --raw-id          Show raw Id values instead of friendly names.
 
-  --no-header     Don't output the header as leading comments.
+  --nested-indent   Indentation is adjusted to indicate nesting in structured
+                    control flow.
 
-  --raw-id        Show raw Id values instead of friendly names.
+  --reorder-blocks  Reorder blocks to match the structured control flow of SPIR-V.
+                    With this option, the order of instructions will no longer
+                    match the input binary, but the result will be more readable.
 
-  --offsets       Show byte offsets for each instruction.
+  --offsets         Show byte offsets for each instruction.
 
-  --comment       Add comments to make reading easier
+  --comment         Add comments to make reading easier
 )";
 
 // clang-format off
-FLAG_SHORT_bool  (h,         /* default_value= */ false, /* required= */ false);
-FLAG_SHORT_string(o,         /* default_value= */ "-",   /* required= */ false);
-FLAG_LONG_bool   (help,      /* default_value= */ false, /* required= */false);
-FLAG_LONG_bool   (version,   /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (color,     /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (no_color,  /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (no_indent, /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (no_header, /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (raw_id,    /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (offsets,   /* default_value= */ false, /* required= */ false);
-FLAG_LONG_bool   (comment,   /* default_value= */ false, /* required= */ false);
+FLAG_SHORT_bool  (h,              /* default_value= */ false, /* required= */ false);
+FLAG_SHORT_string(o,              /* default_value= */ "-",   /* required= */ false);
+FLAG_LONG_bool   (help,           /* default_value= */ false, /* required= */false);
+FLAG_LONG_bool   (version,        /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (color,          /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (no_color,       /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (no_indent,      /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (no_header,      /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (raw_id,         /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (nested_indent,  /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (reorder_blocks, /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (offsets,        /* default_value= */ false, /* required= */ false);
+FLAG_LONG_bool   (comment,        /* default_value= */ false, /* required= */ false);
 // clang-format on
 
 static const auto kDefaultEnvironment = SPV_ENV_UNIVERSAL_1_5;
@@ -120,6 +133,12 @@ int main(int, const char** argv) {
   if (!flags::raw_id.value())
     options |= SPV_BINARY_TO_TEXT_OPTION_FRIENDLY_NAMES;
 
+  if (flags::nested_indent.value())
+    options |= SPV_BINARY_TO_TEXT_OPTION_NESTED_INDENT;
+
+  if (flags::reorder_blocks.value())
+    options |= SPV_BINARY_TO_TEXT_OPTION_REORDER_BLOCKS;
+
   if (flags::comment.value()) options |= SPV_BINARY_TO_TEXT_OPTION_COMMENT;
 
   if (flags::o.value() == "-") {
@@ -138,7 +157,7 @@ int main(int, const char** argv) {
 
   // Read the input binary.
   std::vector<uint32_t> contents;
-  if (!ReadBinaryFile<uint32_t>(inFile.c_str(), &contents)) return 1;
+  if (!ReadBinaryFile(inFile.c_str(), &contents)) return 1;
 
   // If printing to standard output, then spvBinaryToText should
   // do the printing.  In particular, colour printing on Windows is
diff --git a/tools/fuzz/fuzz.cpp b/tools/fuzz/fuzz.cpp
index 5f2a0080..391d3389 100644
--- a/tools/fuzz/fuzz.cpp
+++ b/tools/fuzz/fuzz.cpp
@@ -584,8 +584,7 @@ bool Fuzz(const spv_target_env& target_env,
         [donor_filename, message_consumer,
          target_env]() -> std::unique_ptr<spvtools::opt::IRContext> {
           std::vector<uint32_t> donor_binary;
-          if (!ReadBinaryFile<uint32_t>(donor_filename.c_str(),
-                                        &donor_binary)) {
+          if (!ReadBinaryFile(donor_filename.c_str(), &donor_binary)) {
             return nullptr;
           }
           return spvtools::BuildModule(target_env, message_consumer,
@@ -673,7 +672,7 @@ void DumpTransformationsJson(
     const spvtools::fuzz::protobufs::TransformationSequence& transformations,
     const char* filename) {
   std::string json_string;
-  auto json_options = google::protobuf::util::JsonOptions();
+  auto json_options = google::protobuf::util::JsonPrintOptions();
   json_options.add_whitespace = true;
   auto json_generation_status = google::protobuf::util::MessageToJsonString(
       transformations, &json_string, json_options);
@@ -712,7 +711,7 @@ int main(int argc, const char** argv) {
   }
 
   std::vector<uint32_t> binary_in;
-  if (!ReadBinaryFile<uint32_t>(in_binary_file.c_str(), &binary_in)) {
+  if (!ReadBinaryFile(in_binary_file.c_str(), &binary_in)) {
     return 1;
   }
 
@@ -801,7 +800,7 @@ int main(int argc, const char** argv) {
     }
 
     std::string json_string;
-    auto json_options = google::protobuf::util::JsonOptions();
+    auto json_options = google::protobuf::util::JsonPrintOptions();
     json_options.add_whitespace = true;
     auto json_generation_status = google::protobuf::util::MessageToJsonString(
         transformations_applied, &json_string, json_options);
diff --git a/tools/io.cpp b/tools/io.cpp
new file mode 100644
index 00000000..9c7d21f7
--- /dev/null
+++ b/tools/io.cpp
@@ -0,0 +1,476 @@
+// Copyright (c) 2024 Google Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "io.h"
+
+#include <assert.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+#if defined(SPIRV_WINDOWS)
+#include <fcntl.h>
+#include <io.h>
+
+#define SET_STDIN_TO_BINARY_MODE() _setmode(_fileno(stdin), O_BINARY);
+#define SET_STDIN_TO_TEXT_MODE() _setmode(_fileno(stdin), O_TEXT);
+#define SET_STDOUT_TO_BINARY_MODE() _setmode(_fileno(stdout), O_BINARY);
+#define SET_STDOUT_TO_TEXT_MODE() _setmode(_fileno(stdout), O_TEXT);
+#define SET_STDOUT_MODE(mode) _setmode(_fileno(stdout), mode);
+#else
+#define SET_STDIN_TO_BINARY_MODE()
+#define SET_STDIN_TO_TEXT_MODE()
+#define SET_STDOUT_TO_BINARY_MODE() 0
+#define SET_STDOUT_TO_TEXT_MODE() 0
+#define SET_STDOUT_MODE(mode)
+#endif
+
+namespace {
+// Appends the contents of the |file| to |data|, assuming each element in the
+// file is of type |T|.
+template <typename T>
+void ReadFile(FILE* file, std::vector<T>* data) {
+  if (file == nullptr) return;
+
+  const int buf_size = 4096 / sizeof(T);
+  T buf[buf_size];
+  while (size_t len = fread(buf, sizeof(T), buf_size, file)) {
+    data->insert(data->end(), buf, buf + len);
+  }
+}
+
+// Returns true if |file| has encountered an error opening the file or reading
+// from it. If there was an error, writes an error message to standard error.
+bool WasFileCorrectlyRead(FILE* file, const char* filename) {
+  if (file == nullptr) {
+    fprintf(stderr, "error: file does not exist '%s'\n", filename);
+    return false;
+  }
+
+  if (ftell(file) == -1L) {
+    if (ferror(file)) {
+      fprintf(stderr, "error: error reading file '%s'\n", filename);
+      return false;
+    }
+  }
+  return true;
+}
+
+// Ensure the file contained an exact number of elements, whose size is given in
+// |alignment|.
+bool WasFileSizeAligned(const char* filename, size_t read_size,
+                        size_t alignment) {
+  assert(alignment != 1);
+  if ((read_size % alignment) != 0) {
+    fprintf(stderr,
+            "error: file size should be a multiple of %zd; file '%s' corrupt\n",
+            alignment, filename);
+    return false;
+  }
+  return true;
+}
+
+// Different formats the hex is expected to be in.
+enum class HexMode {
+  // 0x07230203, ...
+  Words,
+  // 0x07, 0x23, 0x02, 0x03, ...
+  BytesBigEndian,
+  // 0x03, 0x02, 0x23, 0x07, ...
+  BytesLittleEndian,
+  // 07 23 02 03 ...
+  StreamBigEndian,
+  // 03 02 23 07 ...
+  StreamLittleEndian,
+};
+
+// Whether a character should be skipped as whitespace / separator /
+// end-of-file.
+bool IsSpace(char c) { return isspace(c) || c == ',' || c == '\0'; }
+
+bool IsHexStream(const std::vector<char>& stream) {
+  for (char c : stream) {
+    if (IsSpace(c)) {
+      continue;
+    }
+
+    // Every possible case of a SPIR-V hex stream starts with either '0' or 'x'
+    // (see |HexMode| values).  Make a decision upon inspecting the first
+    // non-space character.
+    return c == '0' || c == 'x' || c == 'X';
+  }
+
+  return false;
+}
+
+bool MatchIgnoreCase(const char* token, const char* expect, size_t len) {
+  for (size_t i = 0; i < len; ++i) {
+    if (tolower(token[i]) != tolower(expect[i])) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+// Helper class to tokenize a hex stream
+class HexTokenizer {
+ public:
+  HexTokenizer(const char* filename, const std::vector<char>& stream,
+               std::vector<uint32_t>* data)
+      : filename_(filename), stream_(stream), data_(data) {
+    DetermineMode();
+  }
+
+  bool Parse() {
+    while (current_ < stream_.size() && !encountered_error_) {
+      data_->push_back(GetNextWord());
+
+      // Make sure trailing space does not lead to parse error by skipping it
+      // and exiting the loop.
+      SkipSpace();
+    }
+
+    return !encountered_error_;
+  }
+
+ private:
+  void ParseError(const char* reason) {
+    if (!encountered_error_) {
+      fprintf(stderr,
+              "error: hex stream parse error at character %zu: %s in '%s'\n",
+              current_, reason, filename_);
+      encountered_error_ = true;
+    }
+  }
+
+  // Skip whitespace until the next non-whitespace non-comma character.
+  void SkipSpace() {
+    while (current_ < stream_.size()) {
+      char c = stream_[current_];
+      if (!IsSpace(c)) {
+        return;
+      }
+
+      ++current_;
+    }
+  }
+
+  // Skip the 0x or x at the beginning of a hex value.
+  void Skip0x() {
+    // The first character must be 0 or x.
+    const char first = Next();
+    if (first != '0' && first != 'x' && first != 'X') {
+      ParseError("expected 0x or x");
+    } else if (first == '0') {
+      const char second = Next();
+      if (second != 'x' && second != 'X') {
+        ParseError("expected 0x");
+      }
+    }
+  }
+
+  // Consume the next character.
+  char Next() { return current_ < stream_.size() ? stream_[current_++] : '\0'; }
+
+  // Determine how to read the hex stream based on the first token.
+  void DetermineMode() {
+    SkipSpace();
+
+    // Read 11 bytes, that is the size of the biggest token (10) + one more.
+    char first_token[11];
+    for (uint32_t i = 0; i < 11; ++i) {
+      first_token[i] = Next();
+    }
+
+    // Table of how to match the first token with a mode.
+    struct {
+      const char* expect;
+      bool must_have_delimiter;
+      HexMode mode;
+    } parse_info[] = {
+        {"0x07230203", true, HexMode::Words},
+        {"0x7230203", true, HexMode::Words},
+        {"x07230203", true, HexMode::Words},
+        {"x7230203", true, HexMode::Words},
+
+        {"0x07", true, HexMode::BytesBigEndian},
+        {"0x7", true, HexMode::BytesBigEndian},
+        {"x07", true, HexMode::BytesBigEndian},
+        {"x7", true, HexMode::BytesBigEndian},
+
+        {"0x03", true, HexMode::BytesLittleEndian},
+        {"0x3", true, HexMode::BytesLittleEndian},
+        {"x03", true, HexMode::BytesLittleEndian},
+        {"x3", true, HexMode::BytesLittleEndian},
+
+        {"07", false, HexMode::StreamBigEndian},
+        {"03", false, HexMode::StreamLittleEndian},
+    };
+
+    // Check to see if any of the possible first tokens are matched.  If not,
+    // this is not a recognized hex stream.
+    encountered_error_ = true;
+    for (const auto& info : parse_info) {
+      const size_t expect_len = strlen(info.expect);
+      const bool matches_expect =
+          MatchIgnoreCase(first_token, info.expect, expect_len);
+      const bool satisfies_delimeter =
+          !info.must_have_delimiter || IsSpace(first_token[expect_len]);
+      if (matches_expect && satisfies_delimeter) {
+        mode_ = info.mode;
+        encountered_error_ = false;
+        break;
+      }
+    }
+
+    if (encountered_error_) {
+      fprintf(stderr,
+              "error: hex format detected, but pattern '%.11s' is not "
+              "recognized '%s'\n",
+              first_token, filename_);
+    }
+
+    // Reset the position to restart parsing with the determined mode.
+    current_ = 0;
+  }
+
+  // Consume up to |max_len| characters and put them in |token_chars|.  A
+  // delimiter is expected. The resulting string is NUL-terminated.
+  void NextN(char token_chars[9], size_t max_len) {
+    assert(max_len < 9);
+
+    for (size_t i = 0; i <= max_len; ++i) {
+      char c = Next();
+      if (IsSpace(c)) {
+        token_chars[i] = '\0';
+        return;
+      }
+
+      token_chars[i] = c;
+      if (!isxdigit(c)) {
+        ParseError("encountered non-hex character");
+      }
+    }
+
+    // If space is not reached before the maximum number of characters where
+    // consumed, that's an error.
+    ParseError("expected delimiter (space or comma)");
+    token_chars[max_len] = '\0';
+  }
+
+  // Consume one hex digit.
+  char NextHexDigit() {
+    char c = Next();
+    if (!isxdigit(c)) {
+      ParseError("encountered non-hex character");
+    }
+    return c;
+  }
+
+  // Extract a token out of the stream.  It could be either a word or a byte,
+  // based on |mode_|.
+  uint32_t GetNextToken() {
+    SkipSpace();
+
+    // The longest token can be 8 chars (for |HexMode::Words|), add one for
+    // '\0'.
+    char token_chars[9];
+
+    switch (mode_) {
+      case HexMode::Words:
+      case HexMode::BytesBigEndian:
+      case HexMode::BytesLittleEndian:
+        // Start with 0x, followed by up to 8 (for Word) or 2 (for Byte*)
+        // digits.
+        Skip0x();
+        NextN(token_chars, mode_ == HexMode::Words ? 8 : 2);
+        break;
+      case HexMode::StreamBigEndian:
+      case HexMode::StreamLittleEndian:
+        // Always expected to see two consecutive hex digits.
+        token_chars[0] = NextHexDigit();
+        token_chars[1] = NextHexDigit();
+        token_chars[2] = '\0';
+        break;
+    }
+
+    if (encountered_error_) {
+      return 0;
+    }
+
+    // Parse the hex value that was just read.
+    return static_cast<uint32_t>(strtol(token_chars, nullptr, 16));
+  }
+
+  // Construct a word out of tokens
+  uint32_t GetNextWord() {
+    if (mode_ == HexMode::Words) {
+      return GetNextToken();
+    }
+
+    uint32_t tokens[4] = {
+        GetNextToken(),
+        GetNextToken(),
+        GetNextToken(),
+        GetNextToken(),
+    };
+
+    switch (mode_) {
+      case HexMode::BytesBigEndian:
+      case HexMode::StreamBigEndian:
+        return tokens[0] << 24 | tokens[1] << 16 | tokens[2] << 8 | tokens[3];
+      case HexMode::BytesLittleEndian:
+      case HexMode::StreamLittleEndian:
+        return tokens[3] << 24 | tokens[2] << 16 | tokens[1] << 8 | tokens[0];
+      default:
+        assert(false);
+        return 0;
+    }
+  }
+
+  const char* filename_;
+  const std::vector<char>& stream_;
+  std::vector<uint32_t>* data_;
+
+  HexMode mode_ = HexMode::Words;
+  size_t current_ = 0;
+  bool encountered_error_ = false;
+};
+}  // namespace
+
+bool ReadBinaryFile(const char* filename, std::vector<uint32_t>* data) {
+  assert(data->empty());
+
+  const bool use_file = filename && strcmp("-", filename);
+  FILE* fp = nullptr;
+  if (use_file) {
+    fp = fopen(filename, "rb");
+  } else {
+    SET_STDIN_TO_BINARY_MODE();
+    fp = stdin;
+  }
+
+  // Read into a char vector first.  If this is a hex stream, it needs to be
+  // processed as such.
+  std::vector<char> data_raw;
+  ReadFile(fp, &data_raw);
+  bool succeeded = WasFileCorrectlyRead(fp, filename);
+  if (use_file && fp) fclose(fp);
+
+  if (!succeeded) {
+    return false;
+  }
+
+  if (IsHexStream(data_raw)) {
+    // If a hex stream, parse it and fill |data|.
+    HexTokenizer tokenizer(filename, data_raw, data);
+    succeeded = tokenizer.Parse();
+  } else {
+    // If not a hex stream, convert it to uint32_t via memcpy.
+    succeeded = WasFileSizeAligned(filename, data_raw.size(), sizeof(uint32_t));
+    if (succeeded) {
+      data->resize(data_raw.size() / sizeof(uint32_t), 0);
+      memcpy(data->data(), data_raw.data(), data_raw.size());
+    }
+  }
+
+  return succeeded;
+}
+
+bool ConvertHexToBinary(const std::vector<char>& stream,
+                        std::vector<uint32_t>* data) {
+  HexTokenizer tokenizer("<input string>", stream, data);
+  return tokenizer.Parse();
+}
+
+bool ReadTextFile(const char* filename, std::vector<char>* data) {
+  assert(data->empty());
+
+  const bool use_file = filename && strcmp("-", filename);
+  FILE* fp = nullptr;
+  if (use_file) {
+    fp = fopen(filename, "r");
+  } else {
+    SET_STDIN_TO_TEXT_MODE();
+    fp = stdin;
+  }
+
+  ReadFile(fp, data);
+  bool succeeded = WasFileCorrectlyRead(fp, filename);
+  if (use_file && fp) fclose(fp);
+  return succeeded;
+}
+
+namespace {
+// A class to create and manage a file for outputting data.
+class OutputFile {
+ public:
+  // Opens |filename| in the given mode.  If |filename| is nullptr, the empty
+  // string or "-", stdout will be set to the given mode.
+  OutputFile(const char* filename, const char* mode) : old_mode_(0) {
+    const bool use_stdout =
+        !filename || (filename[0] == '-' && filename[1] == '\0');
+    if (use_stdout) {
+      if (strchr(mode, 'b')) {
+        old_mode_ = SET_STDOUT_TO_BINARY_MODE();
+      } else {
+        old_mode_ = SET_STDOUT_TO_TEXT_MODE();
+      }
+      fp_ = stdout;
+    } else {
+      fp_ = fopen(filename, mode);
+    }
+  }
+
+  ~OutputFile() {
+    if (fp_ == stdout) {
+      fflush(stdout);
+      SET_STDOUT_MODE(old_mode_);
+    } else if (fp_ != nullptr) {
+      fclose(fp_);
+    }
+  }
+
+  // Returns a file handle to the file.
+  FILE* GetFileHandle() const { return fp_; }
+
+ private:
+  FILE* fp_;
+  int old_mode_;
+};
+}  // namespace
+
+template <typename T>
+bool WriteFile(const char* filename, const char* mode, const T* data,
+               size_t count) {
+  OutputFile file(filename, mode);
+  FILE* fp = file.GetFileHandle();
+  if (fp == nullptr) {
+    fprintf(stderr, "error: could not open file '%s'\n", filename);
+    return false;
+  }
+
+  size_t written = fwrite(data, sizeof(T), count, fp);
+  if (count != written) {
+    fprintf(stderr, "error: could not write to file '%s'\n", filename);
+    return false;
+  }
+
+  return true;
+}
+
+template bool WriteFile<uint32_t>(const char* filename, const char* mode,
+                                  const uint32_t* data, size_t count);
+template bool WriteFile<char>(const char* filename, const char* mode,
+                              const char* data, size_t count);
diff --git a/tools/io.h b/tools/io.h
index a48e3c32..536009d5 100644
--- a/tools/io.h
+++ b/tools/io.h
@@ -20,145 +20,39 @@
 #include <cstring>
 #include <vector>
 
-#if defined(SPIRV_WINDOWS)
-#include <fcntl.h>
-#include <io.h>
-
-#define SET_STDIN_TO_BINARY_MODE() _setmode(_fileno(stdin), O_BINARY);
-#define SET_STDIN_TO_TEXT_MODE() _setmode(_fileno(stdin), O_TEXT);
-#define SET_STDOUT_TO_BINARY_MODE() _setmode(_fileno(stdout), O_BINARY);
-#define SET_STDOUT_TO_TEXT_MODE() _setmode(_fileno(stdout), O_TEXT);
-#define SET_STDOUT_MODE(mode) _setmode(_fileno(stdout), mode);
-#else
-#define SET_STDIN_TO_BINARY_MODE()
-#define SET_STDIN_TO_TEXT_MODE()
-#define SET_STDOUT_TO_BINARY_MODE() 0
-#define SET_STDOUT_TO_TEXT_MODE() 0
-#define SET_STDOUT_MODE(mode)
-#endif
-
-// Appends the contents of the |file| to |data|, assuming each element in the
-// file is of type |T|.
-template <typename T>
-void ReadFile(FILE* file, std::vector<T>* data) {
-  if (file == nullptr) return;
-
-  const int buf_size = 1024;
-  T buf[buf_size];
-  while (size_t len = fread(buf, sizeof(T), buf_size, file)) {
-    data->insert(data->end(), buf, buf + len);
-  }
-}
-
-// Returns true if |file| has encountered an error opening the file or reading
-// the file as a series of element of type |T|. If there was an error, writes an
-// error message to standard error.
-template <class T>
-bool WasFileCorrectlyRead(FILE* file, const char* filename) {
-  if (file == nullptr) {
-    fprintf(stderr, "error: file does not exist '%s'\n", filename);
-    return false;
-  }
-
-  if (ftell(file) == -1L) {
-    if (ferror(file)) {
-      fprintf(stderr, "error: error reading file '%s'\n", filename);
-      return false;
-    }
-  } else {
-    if (sizeof(T) != 1 && (ftell(file) % sizeof(T))) {
-      fprintf(
-          stderr,
-          "error: file size should be a multiple of %zd; file '%s' corrupt\n",
-          sizeof(T), filename);
-      return false;
-    }
-  }
-  return true;
-}
-
-// Appends the contents of the file named |filename| to |data|, assuming
-// each element in the file is of type |T|. The file is opened as a binary file
-// If |filename| is nullptr or "-", reads from the standard input, but
+// Sets the contents of the file named |filename| in |data|, assuming each
+// element in the file is of type |uint32_t|. The file is opened as a binary
+// file. If |filename| is nullptr or "-", reads from the standard input, but
 // reopened as a binary file. If any error occurs, writes error messages to
 // standard error and returns false.
-template <typename T>
-bool ReadBinaryFile(const char* filename, std::vector<T>* data) {
-  const bool use_file = filename && strcmp("-", filename);
-  FILE* fp = nullptr;
-  if (use_file) {
-    fp = fopen(filename, "rb");
-  } else {
-    SET_STDIN_TO_BINARY_MODE();
-    fp = stdin;
-  }
-
-  ReadFile(fp, data);
-  bool succeeded = WasFileCorrectlyRead<T>(fp, filename);
-  if (use_file && fp) fclose(fp);
-  return succeeded;
-}
-
-// Appends the contents of the file named |filename| to |data|, assuming
-// each element in the file is of type |T|. The file is opened as a text file
-// If |filename| is nullptr or "-", reads from the standard input, but
-// reopened as a text file. If any error occurs, writes error messages to
-// standard error and returns false.
-template <typename T>
-bool ReadTextFile(const char* filename, std::vector<T>* data) {
-  const bool use_file = filename && strcmp("-", filename);
-  FILE* fp = nullptr;
-  if (use_file) {
-    fp = fopen(filename, "r");
-  } else {
-    SET_STDIN_TO_TEXT_MODE();
-    fp = stdin;
-  }
-
-  ReadFile(fp, data);
-  bool succeeded = WasFileCorrectlyRead<T>(fp, filename);
-  if (use_file && fp) fclose(fp);
-  return succeeded;
-}
-
-namespace {
-// A class to create and manage a file for outputting data.
-class OutputFile {
- public:
-  // Opens |filename| in the given mode.  If |filename| is nullptr, the empty
-  // string or "-", stdout will be set to the given mode.
-  OutputFile(const char* filename, const char* mode) : old_mode_(0) {
-    const bool use_stdout =
-        !filename || (filename[0] == '-' && filename[1] == '\0');
-    if (use_stdout) {
-      if (strchr(mode, 'b')) {
-        old_mode_ = SET_STDOUT_TO_BINARY_MODE();
-      } else {
-        old_mode_ = SET_STDOUT_TO_TEXT_MODE();
-      }
-      fp_ = stdout;
-    } else {
-      fp_ = fopen(filename, mode);
-    }
-  }
-
-  ~OutputFile() {
-    if (fp_ == stdout) {
-      fflush(stdout);
-      SET_STDOUT_MODE(old_mode_);
-    } else if (fp_ != nullptr) {
-      fclose(fp_);
-    }
-  }
-
-  // Returns a file handle to the file.
-  FILE* GetFileHandle() const { return fp_; }
-
- private:
-  FILE* fp_;
-  int old_mode_;
-};
-}  // namespace
+//
+// If the given input is detected to be in ascii hex, it is converted to binary
+// automatically.  In that case, the shape of the input data is determined based
+// on the representation of the magic number:
+//
+//  * "[0]x[0]7230203": Every following "0x..." represents a word.
+//  * "[0]x[0]7[,] [0]x23...": Every following "0x..." represents a byte, stored
+//    in big-endian order
+//  * "[0]x[0]3[,] [0]x[0]2...": Every following "0x..." represents a byte,
+//    stored in little-endian order
+//  * "07[, ]23...": Every following "XY" represents a byte, stored in
+//    big-endian order
+//  * "03[, ]02...": Every following "XY" represents a byte, stored in
+//    little-endian order
+bool ReadBinaryFile(const char* filename, std::vector<uint32_t>* data);
+
+// The hex->binary logic of |ReadBinaryFile| applied to a pre-loaded stream of
+// bytes.  Used by tests to avoid having to call |ReadBinaryFile| with temp
+// files.  Returns false in case of parse errors.
+bool ConvertHexToBinary(const std::vector<char>& stream,
+                        std::vector<uint32_t>* data);
+
+// Sets the contents of the file named |filename| in |data|, assuming each
+// element in the file is of type |char|. The file is opened as a text file.  If
+// |filename| is nullptr or "-", reads from the standard input, but reopened as
+// a text file. If any error occurs, writes error messages to standard error and
+// returns false.
+bool ReadTextFile(const char* filename, std::vector<char>* data);
 
 // Writes the given |data| into the file named as |filename| using the given
 // |mode|, assuming |data| is an array of |count| elements of type |T|. If
@@ -166,21 +60,6 @@ class OutputFile {
 // returns false and outputs error message to standard error.
 template <typename T>
 bool WriteFile(const char* filename, const char* mode, const T* data,
-               size_t count) {
-  OutputFile file(filename, mode);
-  FILE* fp = file.GetFileHandle();
-  if (fp == nullptr) {
-    fprintf(stderr, "error: could not open file '%s'\n", filename);
-    return false;
-  }
-
-  size_t written = fwrite(data, sizeof(T), count, fp);
-  if (count != written) {
-    fprintf(stderr, "error: could not write to file '%s'\n", filename);
-    return false;
-  }
-
-  return true;
-}
+               size_t count);
 
 #endif  // TOOLS_IO_H_
diff --git a/tools/link/linker.cpp b/tools/link/linker.cpp
index f3898aab..2f47dd4b 100644
--- a/tools/link/linker.cpp
+++ b/tools/link/linker.cpp
@@ -48,6 +48,10 @@ Options (in lexicographical order):
   --allow-partial-linkage
                Allow partial linkage by accepting imported symbols to be
                unresolved.
+  --allow-pointer-mismatch
+               Allow pointer function parameters to mismatch the target link
+               target. This is useful to workaround lost correct parameter type
+               information due to LLVM's opaque pointers.
   --create-library
                Link the binaries into a library, keeping all exported symbols.
   -h, --help
@@ -77,15 +81,16 @@ Options (in lexicographical order):
 }  // namespace
 
 // clang-format off
-FLAG_SHORT_bool(  h,                     /* default_value= */ false,               /* required= */ false);
-FLAG_LONG_bool(   help,                  /* default_value= */ false,               /* required= */false);
-FLAG_LONG_bool(   version,               /* default_value= */ false,               /* required= */ false);
-FLAG_LONG_bool(   verify_ids,            /* default_value= */ false,               /* required= */ false);
-FLAG_LONG_bool(   create_library,        /* default_value= */ false,               /* required= */ false);
-FLAG_LONG_bool(   allow_partial_linkage, /* default_value= */ false,               /* required= */ false);
-FLAG_SHORT_string(o,                     /* default_value= */ "",                  /* required= */ false);
-FLAG_LONG_string( target_env,            /* default_value= */ kDefaultEnvironment, /* required= */ false);
-FLAG_LONG_bool(   use_highest_version,   /* default_value= */ false,               /* required= */ false);
+FLAG_SHORT_bool(  h,                      /* default_value= */ false,               /* required= */ false);
+FLAG_LONG_bool(   help,                   /* default_value= */ false,               /* required= */ false);
+FLAG_LONG_bool(   version,                /* default_value= */ false,               /* required= */ false);
+FLAG_LONG_bool(   verify_ids,             /* default_value= */ false,               /* required= */ false);
+FLAG_LONG_bool(   create_library,         /* default_value= */ false,               /* required= */ false);
+FLAG_LONG_bool(   allow_partial_linkage,  /* default_value= */ false,               /* required= */ false);
+FLAG_LONG_bool(   allow_pointer_mismatch, /* default_value= */ false,               /* required= */ false);
+FLAG_SHORT_string(o,                      /* default_value= */ "",                  /* required= */ false);
+FLAG_LONG_string( target_env,             /* default_value= */ kDefaultEnvironment, /* required= */ false);
+FLAG_LONG_bool(   use_highest_version,    /* default_value= */ false,               /* required= */ false);
 // clang-format on
 
 int main(int, const char* argv[]) {
@@ -126,6 +131,7 @@ int main(int, const char* argv[]) {
 
   spvtools::LinkerOptions options;
   options.SetAllowPartialLinkage(flags::allow_partial_linkage.value());
+  options.SetAllowPtrTypeMismatch(flags::allow_pointer_mismatch.value());
   options.SetCreateLibrary(flags::create_library.value());
   options.SetVerifyIds(flags::verify_ids.value());
   options.SetUseHighestVersion(flags::use_highest_version.value());
@@ -137,7 +143,7 @@ int main(int, const char* argv[]) {
 
   std::vector<std::vector<uint32_t>> contents(inFiles.size());
   for (size_t i = 0u; i < inFiles.size(); ++i) {
-    if (!ReadBinaryFile<uint32_t>(inFiles[i].c_str(), &contents[i])) return 1;
+    if (!ReadBinaryFile(inFiles[i].c_str(), &contents[i])) return 1;
   }
 
   const spvtools::MessageConsumer consumer = [](spv_message_level_t level,
diff --git a/tools/opt/opt.cpp b/tools/opt/opt.cpp
index f8456d71..07a57252 100644
--- a/tools/opt/opt.cpp
+++ b/tools/opt/opt.cpp
@@ -181,6 +181,14 @@ Options (in lexicographical order):)",
                must be in OpAccessChain instructions with a literal index for
                the first index.)");
   printf(R"(
+  --descriptor-composite-scalar-replacement
+               Same as descriptor-scalar-replacement, but only impacts composite/structs.
+               For details, see --descriptor-scalar-replacement help.)");
+  printf(R"(
+  --descriptor-array-scalar-replacement
+               Same as descriptor-scalar-replacement, but only impacts arrays.
+               For details, see --descriptor-scalar-replacement help.)");
+  printf(R"(
   --eliminate-dead-branches
                Convert conditional branches with constant condition to the
                indicated unconditional branch. Delete all resulting dead
@@ -507,6 +515,10 @@ Options (in lexicographical order):)",
                covers reflection information defined by
                SPV_GOOGLE_hlsl_functionality1 and SPV_KHR_non_semantic_info)");
   printf(R"(
+  --struct-packing=name:rule
+               Re-assign layout offsets to a given struct according to
+               its packing rules.)");
+  printf(R"(
   --switch-descriptorset=<from>:<to>
                Switch any DescriptoSet decorations using the value <from> to
                the new value <to>.)");
@@ -864,7 +876,7 @@ int main(int argc, const char** argv) {
   }
 
   std::vector<uint32_t> binary;
-  if (!ReadBinaryFile<uint32_t>(in_file, &binary)) {
+  if (!ReadBinaryFile(in_file, &binary)) {
     return 1;
   }
 
diff --git a/tools/reduce/reduce.cpp b/tools/reduce/reduce.cpp
index 959f5a2f..14377998 100644
--- a/tools/reduce/reduce.cpp
+++ b/tools/reduce/reduce.cpp
@@ -307,7 +307,7 @@ int main(int argc, const char** argv) {
   reducer.SetMessageConsumer(spvtools::utils::CLIMessageConsumer);
 
   std::vector<uint32_t> binary_in;
-  if (!ReadBinaryFile<uint32_t>(in_binary_file.c_str(), &binary_in)) {
+  if (!ReadBinaryFile(in_binary_file.c_str(), &binary_in)) {
     return 1;
   }
 
diff --git a/tools/sva/package.json b/tools/sva/package.json
index 15feacae..cd6ea67b 100644
--- a/tools/sva/package.json
+++ b/tools/sva/package.json
@@ -19,7 +19,7 @@
     "eslint": "^8.41.0",
     "esm": "^3.2.25",
     "mocha": "^10.2.0",
-    "rollup": "^3.23.0",
+    "rollup": "^3.29.5",
     "serve": "^14.2.0"
   }
 }
diff --git a/tools/sva/yarn.lock b/tools/sva/yarn.lock
index eed94ced..38788e2b 100644
--- a/tools/sva/yarn.lock
+++ b/tools/sva/yarn.lock
@@ -219,11 +219,11 @@ brace-expansion@^2.0.1:
     balanced-match "^1.0.0"
 
 braces@~3.0.2:
-  version "3.0.2"
-  resolved "https://registry.yarnpkg.com/braces/-/braces-3.0.2.tgz#3454e1a462ee8d599e236df336cd9ea4f8afe107"
-  integrity sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==
+  version "3.0.3"
+  resolved "https://registry.yarnpkg.com/braces/-/braces-3.0.3.tgz#490332f40919452272d55a8480adc0c441358789"
+  integrity sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==
   dependencies:
-    fill-range "^7.0.1"
+    fill-range "^7.1.1"
 
 browser-stdout@1.3.1:
   version "1.3.1"
@@ -602,10 +602,10 @@ file-entry-cache@^6.0.1:
   dependencies:
     flat-cache "^3.0.4"
 
-fill-range@^7.0.1:
-  version "7.0.1"
-  resolved "https://registry.yarnpkg.com/fill-range/-/fill-range-7.0.1.tgz#1919a6a7c75fe38b2c7c77e5198535da9acdda40"
-  integrity sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==
+fill-range@^7.1.1:
+  version "7.1.1"
+  resolved "https://registry.yarnpkg.com/fill-range/-/fill-range-7.1.1.tgz#44265d3cac07e3ea7dc247516380643754a05292"
+  integrity sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==
   dependencies:
     to-regex-range "^5.0.1"
 
@@ -1083,10 +1083,10 @@ path-key@^3.0.0, path-key@^3.1.0:
   resolved "https://registry.yarnpkg.com/path-key/-/path-key-3.1.1.tgz#581f6ade658cbba65a0d3380de7753295054f375"
   integrity sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==
 
-path-to-regexp@2.2.1:
-  version "2.2.1"
-  resolved "https://registry.yarnpkg.com/path-to-regexp/-/path-to-regexp-2.2.1.tgz#90b617025a16381a879bc82a38d4e8bdeb2bcf45"
-  integrity sha512-gu9bD6Ta5bwGrrU8muHzVOBFFREpp2iRkVfhBJahwJ6p6Xw20SjT0MxLnwkjOibQmGSYhiUnf2FLe7k+jcFmGQ==
+path-to-regexp@3.3.0:
+  version "3.3.0"
+  resolved "https://registry.yarnpkg.com/path-to-regexp/-/path-to-regexp-3.3.0.tgz#f7f31d32e8518c2660862b644414b6d5c63a611b"
+  integrity sha512-qyCH421YQPS2WFDxDjftfc1ZR5WKQzVzqsp4n9M2kQhVOo/ByahFoUNJfl58kOcEGfQ//7weFTDhm+ss8Ecxgw==
 
 pathval@^1.1.1:
   version "1.1.1"
@@ -1189,10 +1189,10 @@ rimraf@^3.0.2:
   dependencies:
     glob "^7.1.3"
 
-rollup@^3.23.0:
-  version "3.23.0"
-  resolved "https://registry.yarnpkg.com/rollup/-/rollup-3.23.0.tgz#b8d6146dac4bf058ee817f92820988e9b358b564"
-  integrity sha512-h31UlwEi7FHihLe1zbk+3Q7z1k/84rb9BSwmBSr/XjOCEaBJ2YyedQDuM0t/kfOS0IxM+vk1/zI9XxYj9V+NJQ==
+rollup@^3.29.5:
+  version "3.29.5"
+  resolved "https://registry.yarnpkg.com/rollup/-/rollup-3.29.5.tgz#8a2e477a758b520fb78daf04bca4c522c1da8a54"
+  integrity sha512-GVsDdsbJzzy4S/v3dqWPJ7EfvZJfCHiDqe80IyrF59LYuP+e6U1LJoUqeuqRbwAWoMNoXivMNeNAOf5E22VA1w==
   optionalDependencies:
     fsevents "~2.3.2"
 
@@ -1231,7 +1231,7 @@ serve-handler@6.1.5:
     mime-types "2.1.18"
     minimatch "3.1.2"
     path-is-inside "1.0.2"
-    path-to-regexp "2.2.1"
+    path-to-regexp "3.3.0"
     range-parser "1.2.0"
 
 serve@^14.2.0:
diff --git a/tools/val/val.cpp b/tools/val/val.cpp
index 880ce46b..c75c6177 100644
--- a/tools/val/val.cpp
+++ b/tools/val/val.cpp
@@ -111,7 +111,7 @@ int main(int argc, char** argv) {
         printf("%s\n", spvSoftwareVersionDetailsString());
         printf(
             "Targets:\n  %s\n  %s\n  %s\n  %s\n  %s\n  %s\n  %s\n  %s\n  %s\n  "
-            "%s\n %s\n %s\n %s\n",
+            "%s\n  %s\n  %s\n  %s\n",
             spvTargetEnvDescription(SPV_ENV_UNIVERSAL_1_0),
             spvTargetEnvDescription(SPV_ENV_UNIVERSAL_1_1),
             spvTargetEnvDescription(SPV_ENV_UNIVERSAL_1_2),
@@ -193,7 +193,7 @@ int main(int argc, char** argv) {
   }
 
   std::vector<uint32_t> contents;
-  if (!ReadBinaryFile<uint32_t>(inFile, &contents)) return 1;
+  if (!ReadBinaryFile(inFile, &contents)) return 1;
 
   spvtools::SpirvTools tools(target_env);
   tools.SetMessageConsumer(spvtools::utils::CLIMessageConsumer);
diff --git a/utils/check_copyright.py b/utils/check_copyright.py
index a849d046..c477ece9 100755
--- a/utils/check_copyright.py
+++ b/utils/check_copyright.py
@@ -42,7 +42,9 @@ AUTHORS = ['The Khronos Group Inc.',
            'Mostafa Ashraf',
            'Shiyu Liu',
            'ZHOU He',
-           'Nintendo']
+           'Nintendo',
+           'Epic Games, Inc.',
+           'NVIDIA Corporation']
 CURRENT_YEAR = 2023
 
 FIRST_YEAR = 2014
diff --git a/utils/generate_grammar_tables.py b/utils/generate_grammar_tables.py
index 48f83c33..2b695b73 100755
--- a/utils/generate_grammar_tables.py
+++ b/utils/generate_grammar_tables.py
@@ -31,6 +31,7 @@ SPV_AMD_gpu_shader_half_float
 SPV_AMD_gpu_shader_int16
 SPV_AMD_shader_trinary_minmax
 SPV_KHR_non_semantic_info
+SPV_EXT_relaxed_printf_string_address_space
 """
 
 OUTPUT_LANGUAGE = 'c'
@@ -69,6 +70,39 @@ def convert_max_required_version(version):
         return '0xffffffffu'
     return 'SPV_SPIRV_VERSION_WORD({})'.format(version.replace('.', ','))
 
+def get_alias_array_name(aliases):
+    """Returns the name of the array containing all the given aliases.
+
+    Arguments:
+      - aliases: a sequence of alias names
+    """
+    if not aliases:
+        return 'nullptr';
+    return '{}_aliases_{}'.format(PYGEN_VARIABLE_PREFIX, ''.join(aliases))
+
+def compose_alias_list(aliases):
+    """Returns a string containing a braced list of aliases.
+
+    Arguments:
+      - aliases: a sequence of alias names
+
+    Returns:
+      a string containing the braced list of char* named by aliases.
+    """
+    return '{' + ', '.join([('"{}"').format(a) for a in aliases]) + '}'
+
+def generate_aliases_arrays(aliases):
+    """Returns the arrays of aliases
+
+    Arguments:
+      - aliases: a sequence of sequence of alias names
+    """
+    aliases = sorted(set([tuple(a) for a in aliases if a]))
+    arrays = [
+        'static const char* {}[] = {};'.format(
+            get_alias_array_name(a), compose_alias_list(a))
+        for a in aliases]
+    return '\n'.join(arrays)
 
 def compose_capability_list(caps):
     """Returns a string containing a braced list of capabilities as enums.
@@ -223,11 +257,12 @@ class InstInitializer(object):
     """Instances holds a SPIR-V instruction suitable for printing as the
     initializer for spv_opcode_desc_t."""
 
-    def __init__(self, opname, caps, exts, operands, version, lastVersion):
+    def __init__(self, opname, aliases, caps, exts, operands, version, lastVersion):
         """Initialization.
 
         Arguments:
           - opname: opcode name (with the 'Op' prefix)
+          - aliases: a sequence of aliases for the name of this opcode
           - caps: a sequence of capability names required by this opcode
           - exts: a sequence of names of extensions enabling this enumerant
           - operands: a sequence of (operand-kind, operand-quantifier) tuples
@@ -237,6 +272,8 @@ class InstInitializer(object):
 
         assert opname.startswith('Op')
         self.opname = opname[2:]  # Remove the "Op" prefix.
+        self.num_aliases = len(aliases);
+        self.aliases_mask = get_alias_array_name(aliases)
         self.num_caps = len(caps)
         self.caps_mask = get_capability_array_name(caps)
         self.num_exts = len(exts)
@@ -271,6 +308,7 @@ class InstInitializer(object):
             base_str = 'spv::Op::Op'
 
         template = ['{{"{opname}"', base_str + '{opname}',
+                    '{num_aliases}', '{aliases_mask}',
                     '{num_caps}', '{caps_mask}',
                     '{num_operands}', '{{{operands}}}',
                     '{def_result_id}', '{ref_type_id}',
@@ -278,6 +316,8 @@ class InstInitializer(object):
                     '{min_version}', '{max_version}}}']
         return ', '.join(template).format(
             opname=self.opname,
+            num_aliases=self.num_aliases,
+            aliases_mask=self.aliases_mask,
             num_caps=self.num_caps,
             caps_mask=self.caps_mask,
             num_operands=len(self.operands),
@@ -335,6 +375,7 @@ def generate_instruction(inst, is_ext_inst):
     """
     opname = inst.get('opname')
     opcode = inst.get('opcode')
+    aliases = inst.get('aliases', [])
     caps = inst.get('capabilities', [])
     exts = inst.get('extensions', [])
     operands = inst.get('operands', {})
@@ -347,7 +388,7 @@ def generate_instruction(inst, is_ext_inst):
     if is_ext_inst:
         return str(ExtInstInitializer(opname, opcode, caps, operands))
     else:
-        return str(InstInitializer(opname, caps, exts, operands, min_version, max_version))
+        return str(InstInitializer(opname, aliases, caps, exts, operands, min_version, max_version))
 
 
 def generate_instruction_table(inst_table):
@@ -363,6 +404,8 @@ def generate_instruction_table(inst_table):
     """
     inst_table = sorted(inst_table, key=lambda k: (k['opcode'], k['opname']))
 
+    aliases_arrays = generate_aliases_arrays(
+        [inst.get('aliases', []) for inst in inst_table])
     caps_arrays = generate_capability_arrays(
         [inst.get('capabilities', []) for inst in inst_table])
     exts_arrays = generate_extension_arrays(
@@ -372,7 +415,7 @@ def generate_instruction_table(inst_table):
     insts = ['static const spv_opcode_desc_t kOpcodeTableEntries[] = {{\n'
              '  {}\n}};'.format(',\n  '.join(insts))]
 
-    return '{}\n\n{}\n\n{}'.format(caps_arrays, exts_arrays, '\n'.join(insts))
+    return '{}\n\n{}\n\n{}\n\n{}'.format(aliases_arrays, caps_arrays, exts_arrays, '\n'.join(insts))
 
 
 def generate_extended_instruction_table(json_grammar, set_name, operand_kind_prefix=""):
@@ -404,12 +447,13 @@ def generate_extended_instruction_table(json_grammar, set_name, operand_kind_pre
 class EnumerantInitializer(object):
     """Prints an enumerant as the initializer for spv_operand_desc_t."""
 
-    def __init__(self, enumerant, value, caps, exts, parameters, version, lastVersion):
+    def __init__(self, enumerant, value, aliases, caps, exts, parameters, version, lastVersion):
         """Initialization.
 
         Arguments:
           - enumerant: enumerant name
           - value: enumerant value
+          - aliases: a sequence of aliased capability names
           - caps: a sequence of capability names required by this enumerant
           - exts: a sequence of names of extensions enabling this enumerant
           - parameters: a sequence of (operand-kind, operand-quantifier) tuples
@@ -418,6 +462,8 @@ class EnumerantInitializer(object):
         """
         self.enumerant = enumerant
         self.value = value
+        self.num_aliases = len(aliases)
+        self.aliases = get_alias_array_name(aliases)
         self.num_caps = len(caps)
         self.caps = get_capability_array_name(caps)
         self.num_exts = len(exts)
@@ -427,13 +473,17 @@ class EnumerantInitializer(object):
         self.lastVersion = convert_max_required_version(lastVersion)
 
     def __str__(self):
-        template = ['{{"{enumerant}"', '{value}', '{num_caps}',
-                    '{caps}', '{num_exts}', '{exts}',
+        template = ['{{"{enumerant}"', '{value}',
+                    '{num_aliases}', '{aliases}',
+                    '{num_caps}', '{caps}',
+                    '{num_exts}', '{exts}',
                     '{{{parameters}}}', '{min_version}',
                     '{max_version}}}']
         return ', '.join(template).format(
             enumerant=self.enumerant,
             value=self.value,
+            num_aliases=self.num_aliases,
+            aliases=self.aliases,
             num_caps=self.num_caps,
             caps=self.caps,
             num_exts=self.num_exts,
@@ -455,6 +505,7 @@ def generate_enum_operand_kind_entry(entry, extension_map):
     """
     enumerant = entry.get('enumerant')
     value = entry.get('value')
+    aliases = entry.get('aliases', [])
     caps = entry.get('capabilities', [])
     if value in extension_map:
         exts = extension_map[value]
@@ -470,7 +521,7 @@ def generate_enum_operand_kind_entry(entry, extension_map):
     assert value is not None
 
     return str(EnumerantInitializer(
-        enumerant, value, caps, exts, params, version, max_version))
+        enumerant, value, aliases, caps, exts, params, version, max_version))
 
 
 def generate_enum_operand_kind(enum, synthetic_exts_list):
@@ -512,6 +563,10 @@ def generate_enum_operand_kind(enum, synthetic_exts_list):
     name = '{}_{}Entries'.format(PYGEN_VARIABLE_PREFIX, kind)
     entries = ['  {}'.format(generate_enum_operand_kind_entry(e, extension_map))
                for e in entries]
+    if len(entries) == 0:
+        # Insert a dummy entry. Otherwise the array is empty and compilation
+        # will fail in MSVC.
+        entries = ['  {"place holder", 0, 0, nullptr, 0, nullptr, 0, nullptr, {}, SPV_SPIRV_VERSION_WORD(999,0), 0}']
 
     template = ['static const spv_operand_desc_t {name}[] = {{',
                 '{entries}', '}};']
@@ -527,6 +582,11 @@ def generate_operand_kind_table(enums):
     # We only need to output info tables for those operand kinds that are enums.
     enums = [e for e in enums if e.get('category') in ['ValueEnum', 'BitEnum']]
 
+    aliases = [entry.get('aliases', [])
+               for enum in enums
+               for entry in enum.get('enumerants', [])]
+    aliases_arrays = generate_aliases_arrays(aliases)
+
     caps = [entry.get('capabilities', [])
             for enum in enums
             for entry in enum.get('enumerants', [])]
@@ -540,7 +600,7 @@ def generate_operand_kind_table(enums):
 
     # We have a few operand kinds that require their optional counterpart to
     # exist in the operand info table.
-    optional_enums = ['ImageOperands', 'AccessQualifier', 'MemoryAccess', 'PackedVectorFormat', 'CooperativeMatrixOperands']
+    optional_enums = ['ImageOperands', 'AccessQualifier', 'MemoryAccess', 'PackedVectorFormat', 'CooperativeMatrixOperands', 'RawAccessChainOperands', 'FPEncoding']
     optional_enums = [e for e in enums if e[0] in optional_enums]
     enums.extend(optional_enums)
 
@@ -561,7 +621,7 @@ def generate_operand_kind_table(enums):
     table = '\n'.join(template).format(
         p=PYGEN_VARIABLE_PREFIX, enums=',\n'.join(table_entries))
 
-    return '\n\n'.join((caps_arrays,) + (exts_arrays,) + enum_entries + (table,))
+    return '\n\n'.join((aliases_arrays,) + (caps_arrays,) + (exts_arrays,) + enum_entries + (table,))
 
 
 def get_extension_list(instructions, operand_kinds):
diff --git a/utils/generate_registry_tables.py b/utils/generate_registry_tables.py
index 69628faa..2564f357 100755
--- a/utils/generate_registry_tables.py
+++ b/utils/generate_registry_tables.py
@@ -17,6 +17,7 @@
 import errno
 import io
 import os.path
+import platform
 from xml.etree.ElementTree import XML, XMLParser, TreeBuilder
 
 
@@ -80,8 +81,15 @@ def main():
     args = parser.parse_args()
 
     with io.open(args.xml, encoding='utf-8') as xml_in:
+      # Python3 default str to UTF-8. But Python2.7 (in case of NDK build,
+      # don't be fooled by the shebang) is returning a unicode string.
+      # So depending of the version, we need to make sure the correct
+      # encoding is used.
+      content = xml_in.read()
+      if platform.python_version_tuple()[0] == '2':
+        content = content.encode('utf-8')
       parser = XMLParser(target=TreeBuilder(), encoding='utf-8')
-      registry = XML(xml_in.read(), parser=parser)
+      registry = XML(content, parser=parser)
 
     mkdir_p(os.path.dirname(args.generator_output))
     with open(args.generator_output, 'w') as f:
diff --git a/utils/generate_vim_syntax.py b/utils/generate_vim_syntax.py
index 5c9c6b21..1d156a0c 100755
--- a/utils/generate_vim_syntax.py
+++ b/utils/generate_vim_syntax.py
@@ -161,11 +161,17 @@ def main():
     print('\n" Core instructions')
     for inst in core["instructions"]:
         EmitAsStatement(inst['opname'])
+        aliases = inst.get('aliases', [])
+        for alias in aliases:
+            EmitAsStatement(alias)
     print('\n" Core operand enums')
     for operand_kind in core["operand_kinds"]:
         if 'enumerants' in operand_kind:
             for e in operand_kind['enumerants']:
                 EmitAsEnumerant(e['enumerant'])
+                aliases = e.get('aliases', [])
+                for a in aliases:
+                    EmitAsEnumerant(a)
 
     if args.extinst_glsl_grammar is not None:
         print('\n" GLSL.std.450 extended instructions')
diff --git a/utils/git-sync-deps b/utils/git-sync-deps
index 6549afb1..21bf2bc7 100755
--- a/utils/git-sync-deps
+++ b/utils/git-sync-deps
@@ -78,7 +78,7 @@ def git_executable():
       minor=None
       try:
         version_info = subprocess.check_output([git, '--version']).decode('utf-8')
-        match = re.search("^git version (\d+)\.(\d+)",version_info)
+        match = re.search(r"^git version (\d+)\.(\d+)",version_info)
         print("Using {}".format(version_info))
         if match:
           major = int(match.group(1))
diff --git a/utils/roll_deps.sh b/utils/roll_deps.sh
index d19ee000..a62ebe9b 100755
--- a/utils/roll_deps.sh
+++ b/utils/roll_deps.sh
@@ -29,13 +29,12 @@ function ExitIfIsInterestingError() {
 }
 
 
-dependencies=("external/effcee/"
-              "external/googletest/"
-              "external/re2/"
-              "external/spirv-headers/")
-
-
-branch="origin/main"
+declare -A dependency_to_branch_map
+dependency_to_branch_map["external/abseil_cpp"]="origin/master"
+dependency_to_branch_map["external/effcee/"]="origin/main"
+dependency_to_branch_map["external/googletest/"]="origin/main"
+dependency_to_branch_map["external/re2/"]="origin/main"
+dependency_to_branch_map["external/spirv-headers/"]="origin/main"
 
 # This script assumes it's parent directory is the repo root.
 repo_path=$(dirname "$0")/..
@@ -53,7 +52,8 @@ old_head=$(git rev-parse HEAD)
 
 set +e
 
-for dep in ${dependencies[@]}; do
+for dep in ${!dependency_to_branch_map[@]}; do
+  branch=${dependency_to_branch_map[$dep]}
   echo "Rolling $dep"
   roll-dep --ignore-dirty-tree --roll-to="${branch}" "${dep}"
   ExitIfIsInterestingError $?
diff --git a/utils/update_build_version.py b/utils/update_build_version.py
index bb66e18a..9115cab1 100755
--- a/utils/update_build_version.py
+++ b/utils/update_build_version.py
@@ -24,9 +24,10 @@
 #  - The software version deduced from the given CHANGES file.
 #  - A longer string with the project name, the software version number, and
 #    git commit information for the CHANGES file's directory.  The commit
-#    information is the output of "git describe" if that succeeds, or "git
-#    rev-parse HEAD" if that succeeds, or otherwise a message containing the
-#    phrase "unknown hash".
+#    information is the content of the FORCED_BUILD_VERSION_DESCRIPTION
+#    environement variable is it exists, else the output of "git describe" if
+#    that succeeds, or "git rev-parse HEAD" if that succeeds, or otherwise a
+#    message containing the phrase "unknown hash".
 # The string contents are escaped as necessary.
 
 import datetime
@@ -150,7 +151,7 @@ def main():
       sys.exit(1)
 
     repo_path = os.path.dirname(changes_file_path)
-    description = describe(repo_path)
+    description = os.getenv("FORCED_BUILD_VERSION_DESCRIPTION", describe(repo_path))
     content = OUTPUT_FORMAT.format(version_tag=version, description=description)
 
     # Escape file content.
```

