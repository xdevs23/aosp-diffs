```diff
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index cc6c99d1b..bb6215f6b 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -1,53 +1,71 @@
-# Contributing to Robolectric
+# Contributor Guidelines
 
 ## Getting Started
 
-Dependencies:
+The first step to contributing is to ensure that you are able to build Robolectric. Please visit [building Robolectric](https://robolectric.org/building-robolectric/) for more details and instructions on setting up an environment to build Robolectric.
 
-1. Android SDK with Tools, Extras, and 'Google APIs' for APIs 22 and 23 installed
+Once you are able to build Robolectric, create a feature branch to make your changes:
 
-Set Android enviroment variables:
+```shell
+git checkout -b my-feature-name
+```
 
-    export ANDROID_HOME=/path-to-sdk-root
-    export PATH=${PATH}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
+Robolectric is built using [Gradle](https://gradle.com/). It is recommended to use Android Studio or IntelliJ to import the top-level `build.gradle.kts` file, which will automatically generate their project files from it.
 
-Fork and clone the repo:
+## Contribution Requirements
 
-    git clone git@github.com:username/robolectric.git
+### Code Style
 
-Create a feature branch to make your changes:
+#### Java code style
 
-    git checkout -b my-feature-name
+Essentially the Android Studio/IntelliJ default Java style, but with two-space indents and Google-style imports.
 
-Copy all required Android dependencies into your local Maven repository:
+1. Spaces, not tabs.
+2. Two spaces indent.
+3. Curly braces for everything: `if`, `else`, etc.
+4. One line of white space between methods.
+5. No `'m'` or `'s'` prefixes before instance or static variables.
+6. Import Google's [Java imports style](https://google.github.io/styleguide/javaguide.html#s3.3-import-statements) ([IntelliJ style file here](https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml)).
 
-    ./scripts/install-dependencies.rb
+If your changes break the code style, the CI will fail, and your PR will be blocked. You can use [`google-java-format`](https://github.com/google/google-java-format) to format your code locally before you push your changes for reviewing. The [wiki's `Running Google java format` section](https://github.com/robolectric/robolectric/wiki/Running-google-java-format) is a tutorial for it.
 
-Perform a full build of all shadows:
+#### Kotlin code style
 
-    ./gradlew clean assemble install compileTestJava
+Robolectric uses [Spotless](https://github.com/diffplug/spotless) + [ktfmt](https://github.com/facebookincubator/ktfmt) to apply Google's code style for Kotlin. Please follow [wiki's `Robolectric's code style` section](https://github.com/robolectric/robolectric/wiki/Robolectric's-code-style) to apply Kotlin format for Kotlin modules and code.
 
-## Building and Testing
+### Writing Tests
 
-Robolectric's tests run against the jars that are installed in your local Maven repo. This means that for the tests to pick up your code changes, you must run `mvn install` before running `mvn test`. Running `mvn install` will only build and install shadows for API 21. If your tests run against older versions of Android, you will need to activate a different profile (i.e. `mvn test -P android-19`).
+Robolectric is a unit testing framework, and it is important that Robolectric itself is very well tested. All classes should have unit test classes. All public methods should have unit tests. Those classes and methods should have their possible states well tested. Pull Requests without tests will be sent back to the submitter.
 
-To include the source jar in the build:
+If the change is related to third-party tool, e.g., [Mockito](https://site.mockito.org/) and [Mockk](https://mockk.io/), please consider creating a dedicated module in [Robolectric's `integration_tests` module](https://github.com/robolectric/robolectric/tree/master/integration_tests) to test third-party tool's regression.
 
-    export INCLUDE_SOURCE=1
+If tests need to check that an exception is thrown, use jUnit's `assertThrows` instead of `@Test(expected = SomeException.class)`. Using `assertThrows` allows more precision to check exactly which line throws a particular exception.
 
-Similarly with Javadocs:
+### Documentation
 
-    export INCLUDE_JAVADOC=1
+Robolectric uses javadoc to document API's behavior. There are special rules for javadoc on shadow classes:
 
-## Writing Tests
+* All `@Implementation` methods whose behavior varies from the standard Android behavior **MUST** have Javadoc describing the difference. Use `@see` or `{@link}` to indicate if the method's behavior can be changed or inspected by calling testing API methods. If the method's behavior is identical to the normal framework behavior, no javadoc is necessary.
+* All visible non-`@Implementation` methods **SHOULD** have descriptive Javadoc.
+* Don't write javadoc comments like "Shadow for (whatever).". The javadoc will appear in a section clearly related to testing, so make it make sense in context.
 
-Robolectric is a unit testing framework and it is important that Robolectric itself be very well tested. All classes should have unit test classes. All public methods should have unit tests. Those classes and methods should have their possible states well tested. Pull requests without tests will be sent back to the submitter.
+Robolectric will release javadoc at [https://robolectric.org/](https://robolectric.org/) after every main version released. For example, Robolectric's 4.13 javadoc is released at [https://robolectric.org/javadoc/4.13/](https://robolectric.org/javadoc/4.13/).
 
-## Code Style
+### Deprecations and Backwards Compatibility
 
-Essentially the IntelliJ default Java style, but with two-space indents.
+To provide an easy upgrade path, we aim to always mark methods or classes `@Deprecated` in at least a patch release before removing them in the next minor release. We realize that's not quite how [Semantic Versioning](https://semver.org/) is supposed to work, sorry. Be sure to include migration notes in the `/** @deprecated */` javadoc!
 
-1. Spaces, not tabs.
-2. Two space indent.
-3. Curly braces for everything: if, else, etc.
-4. One line of white space between methods.
+### Pull Request Requirements
+
+Once your changes are ready, tested, and documented, you can submit them in a Pull Request targeting the [`master`](https://github.com/robolectric/robolectric/tree/master) branch.
+Some automated checks will be executed against your PR to ensure that it adheres to Robolectric's quality requirements:
+
+- Your PR should contain only one commit. If you need to push additional changes, please squash all commits into one.
+- That commit should have a short title **and** a body describing your changes.
+- Each line of the commit message should be less than 120 characters (unless that line contains a link).
+- The code style, for both Java and Kotlin, is checked using the rules described above.
+- Both unit and instrumented tests are executed.
+
+## Discussion
+
+Robolectric welcome discussion in the entire contribution cycle. If you have any idea or question, you can post on [GitHub Discussion](https://github.com/robolectric/robolectric/discussions) or [Google Groups](https://groups.google.com/g/robolectric). The [GitHub Discussion](https://github.com/robolectric/robolectric/discussions) is the first choice for discussion if you have GitHub account, because it can help to accumulate community knowledge along with existing GitHub issues.   
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
index 52671c8ba..9cd302c72 100644
--- a/.github/dependabot.yml
+++ b/.github/dependabot.yml
@@ -11,6 +11,10 @@ updates:
     schedule:
       interval: "weekly"
     groups:
+      android-gradle-plugin:
+        patterns:
+          - "com.android.tools:common"
+          - "com.android.tools.build:gradle*"
       androidx-test:
         patterns:
           - "androidx.test*"
@@ -18,10 +22,6 @@ updates:
         patterns:
           - "androidx.*"
     ignore:
-      # don't auto update guava since it requires updating gradle
-      - dependency-name: "*guava*"
-      # don't auto update errorprone since it requires updating guava
-      - dependency-name: "*errorprone*"
       # don't auto update nativeruntime-dist-compat since it needs
       # to be updated with code changes together
       - dependency-name: "org.robolectric:nativeruntime-dist-compat"
diff --git a/.github/workflows/check_code_style.yml b/.github/workflows/check_code_style.yml
index fe2c542e8..5a00834c0 100644
--- a/.github/workflows/check_code_style.yml
+++ b/.github/workflows/check_code_style.yml
@@ -20,7 +20,7 @@ permissions:
 
 jobs:
   check_code_style:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -35,7 +35,7 @@ jobs:
 
       - name: Download google-java-format
         run: |
-          googleJavaFormatVersion="1.23.0"
+          googleJavaFormatVersion="1.25.0"
           curl -L -o $HOME/google-java-format.jar https://github.com/google/google-java-format/releases/download/v${googleJavaFormatVersion}/google-java-format-${googleJavaFormatVersion}-all-deps.jar
           curl -L -o $HOME/google-java-format-diff.py https://raw.githubusercontent.com/google/google-java-format/v${googleJavaFormatVersion}/scripts/google-java-format-diff.py
           chmod +x $HOME/google-java-format-diff.py
diff --git a/.github/workflows/copybara_build_and_test.yml b/.github/workflows/copybara_build_and_test.yml
index c25b8c089..367506bd2 100644
--- a/.github/workflows/copybara_build_and_test.yml
+++ b/.github/workflows/copybara_build_and_test.yml
@@ -13,7 +13,7 @@ permissions:
 
 jobs:
   copybara-tests:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -29,19 +29,19 @@ jobs:
       - name: Build
         run: |
           SKIP_ERRORPRONE=true SKIP_JAVADOC=true \
-          ./gradlew assemble testClasses --parallel --stacktrace --no-watch-fs
+          ./gradlew assemble testClasses --stacktrace
 
       - name: Integration tests
         run: |
           # Only run integration tests on Copybara PRs
           (cd integration_tests && \
             SKIP_ERRORPRONE=true SKIP_JAVADOC=true \
-            ../gradlew test --info --stacktrace --continue --parallel --no-watch-fs \
+            ../gradlew test --stacktrace --continue \
             -Drobolectric.alwaysIncludeVariantMarkersInTestName=true \
             -Drobolectric.enabledSdks=34 \
             -Dorg.gradle.workers.max=2 \
             -x :integration_tests:nativegraphics:test \
-            -x :integration_tests:sdkcompat:test \
+            -x :integration_tests:sdkcompat:test
           )
 
       - name: SdkCompat tests
@@ -49,5 +49,5 @@ jobs:
           # `SdkCompat tests` is run as a separate step because it has to run on all SDK levels, and
           # the `Integration tests` step only runs on a single SDK level.
           SKIP_ERRORPRONE=true SKIP_JAVADOC=true \
-          ./gradlew :integration_tests:sdkcompat:test --info --stacktrace --continue --no-watch-fs \
-          -Drobolectric.alwaysIncludeVariantMarkersInTestName=true \
+          ./gradlew :integration_tests:sdkcompat:test --stacktrace --continue \
+          -Drobolectric.alwaysIncludeVariantMarkersInTestName=true
diff --git a/.github/workflows/gradle_tasks_validation.yml b/.github/workflows/gradle_tasks_validation.yml
index 8d73b8089..d1ee11b14 100644
--- a/.github/workflows/gradle_tasks_validation.yml
+++ b/.github/workflows/gradle_tasks_validation.yml
@@ -20,7 +20,7 @@ permissions:
 
 jobs:
   run_aggregateDocs:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -43,7 +43,7 @@ jobs:
           path: build/docs
 
   run_javadocJar:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -61,7 +61,7 @@ jobs:
 
 
   run_instrumentAll:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -84,7 +84,7 @@ jobs:
         run: PREINSTRUMENTED_SDK_VERSIONS=33 PUBLISH_PREINSTRUMENTED_JARS=true ./gradlew :preinstrumented:publishToMavenLocal
 
   run_publishToMavenLocal:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -98,4 +98,4 @@ jobs:
       - uses: gradle/actions/setup-gradle@v4
 
       - name: Publish to Maven local
-        run: ./gradlew publishToMavenLocal --no-watch-fs
+        run: ./gradlew publishToMavenLocal
diff --git a/.github/workflows/graphics_tests.yml b/.github/workflows/graphics_tests.yml
index 3f23e9555..b0c77034c 100644
--- a/.github/workflows/graphics_tests.yml
+++ b/.github/workflows/graphics_tests.yml
@@ -25,7 +25,7 @@ jobs:
         device: [
           macos-13, # Tests Mac x86_64
           macos-14, # Tests Mac arm64
-          ubuntu-22.04, # Tests Linux x86_64
+          ubuntu-latest, # Tests Linux x86_64
           windows-2022, # Tests Windows x86_64
         ]
     runs-on: ${{ matrix.device }}
@@ -51,9 +51,7 @@ jobs:
         run: >
           ./gradlew
           :integration_tests:nativegraphics:testDebugUnitTest
-          --info --stacktrace --continue
-          --parallel
-          --no-watch-fs
+          --stacktrace --continue
           "-Drobolectric.alwaysIncludeVariantMarkersInTestName=true"
           "-Dorg.gradle.workers.max=2"
 
diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 58af08d6a..1f0a295ee 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -23,7 +23,7 @@ env:
 
 jobs:
   build:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -39,15 +39,15 @@ jobs:
       - name: Build
         run: |
           SKIP_ERRORPRONE=true SKIP_JAVADOC=true \
-          ./gradlew assemble testClasses --parallel --stacktrace --no-watch-fs
+          ./gradlew assemble testClasses --stacktrace
 
   unit-tests:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
     needs: build
     strategy:
       fail-fast: false
       matrix:
-        api-versions: [ '21,22,23', '24,25,26', '27,28,29', '30,31,32', '33,34' ]
+        api-versions: [ '21,22,23', '24,25,26', '27,28,29', '30,31,32', '33,34,35' ]
 
     steps:
       - uses: actions/checkout@v4
@@ -63,9 +63,7 @@ jobs:
       - name: Run unit tests
         run: |
           SKIP_ERRORPRONE=true SKIP_JAVADOC=true ./gradlew test \
-          --info --stacktrace --continue \
-          --parallel \
-          --no-watch-fs \
+          --stacktrace --continue \
           -Drobolectric.enabledSdks=${{ matrix.api-versions }} \
           -Drobolectric.alwaysIncludeVariantMarkersInTestName=true \
           -Dorg.gradle.workers.max=2 \
@@ -80,7 +78,7 @@ jobs:
           path: '**/build/test-results/**/TEST-*.xml'
 
   instrumentation-tests:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
     timeout-minutes: 60
     needs: build
 
@@ -157,7 +155,7 @@ jobs:
           profile: Nexus One
           script: |
             adb shell wm density 240
-            SKIP_ERRORPRONE=true SKIP_JAVADOC=true ./gradlew cAT --info --stacktrace --no-watch-fs -Dorg.gradle.workers.max=2
+            SKIP_ERRORPRONE=true SKIP_JAVADOC=true ./gradlew cAT --stacktrace -Dorg.gradle.workers.max=2
 
       - name: Upload test results
         if: always()
@@ -169,7 +167,7 @@ jobs:
             **/build/outputs/*/connected/*
 
   publish-to-snapshots:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
     env:
       SONATYPE_LOGIN: ${{ secrets.SONATYPE_LOGIN }}
       SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
@@ -187,4 +185,4 @@ jobs:
       - uses: gradle/actions/setup-gradle@v4
 
       - name: Publish
-        run: ./gradlew publish --stacktrace --no-watch-fs
+        run: ./gradlew publish --stacktrace
diff --git a/.github/workflows/validate_commit_message.yml b/.github/workflows/validate_commit_message.yml
index f90be1f69..43016a6ea 100644
--- a/.github/workflows/validate_commit_message.yml
+++ b/.github/workflows/validate_commit_message.yml
@@ -13,7 +13,7 @@ permissions:
 
 jobs:
   validate_commit_message:
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v4
@@ -37,6 +37,7 @@ jobs:
           fi
 
       - name: Validate commit body
+        if: github.actor != 'dependabot[bot]'
         run: |
           # Check that the commit has a body
           commit_body="$(git log -1 --pretty=format:'%b' | grep -v 'PiperOrigin-RevId')"
diff --git a/ARCHITECTURE.md b/ARCHITECTURE.md
index 1654ebbeb..a2f42d49e 100644
--- a/ARCHITECTURE.md
+++ b/ARCHITECTURE.md
@@ -1,213 +1 @@
-# Robolectric architecture
-
-Robolectric is a unit testing framework that allows Android code to be tested on
-the JVM without the need for an emulator or device. This allows tests to run
-very quickly in a more hermetic environment. Robolectric has a complex
-architecture and makes use of many advanced features of the JVM such as bytecode
-instrumentation and custom ClassLoaders. This document provides a high level
-overview of the architecture of Robolectric.
-
-# Android framework Jars and instrumentation
-
-At the heart of Robolectric are the Android framework Jars and the bytecode
-instrumentation. The Android framework Jars are a collection of Jar files that
-are built directly from Android platform sources. There is a single Jar file for
-each version of Android. These Jar files can be built by checking out an AOSP
-repo and building the
-[robolectric-host-android\_all](https://cs.android.com/android/platform/superproject/main/+/main:external/robolectric/Android.bp;l=99)
-target. Unlike the android.jar (stubs jar) files managed by Android Studio,
-which only contain public method signatures, the Robolectric android-all Jars
-contain the implementation of the Android Java framework. This gives Robolectric
-the ability to use as much real Android code as possible. A new android-all jar
-is uploaded to MavenCentral for each Android release. You can see the current
-android-all jars
-[here](https://repo1.maven.org/maven2/org/robolectric/android-all/).
-
-However, the pristine android-all jars are not the ones used during tests.
-Instead, Robolectric modifies the pristine android-all jars using bytecode
-instrumentation (see
-[ClassInstrumentor](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java)).
-It performs several modifications:
-
-1. All Android methods, including constructors and static initializers, are
-   modified to support `shadowing`. This allows any method call to the Android
-   framework to be intercepted by Robolectric and delegated to a shadow method.
-   At a high level, this is done by iterating over each Android method and
-   converting it into two methods: the original method (but renamed), and the
-   `invokedynamic delegator` which can optionally invoke shadow methods if they
-   are available.
-
-1. Android constructors are specially modified to create shadow objects, if a
-   shadow class is bound to the Android class being instantiated.
-
-1. Because the Android version of Java core classes (libcore) contain subtle
-   differences to the JDKs, certain problematic method calls have to be
-   intercepted and rewritten. See
-   [AndroidInterceptors](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java).
-
-1. Native methods undergo special instrumentation. Currently native methods are
-   converted to no-op non-native methods that are shadowable by default.
-   However, there is now a native variant of each method also created. There is
-   more details about native code in a section below.
-
-1. The `final` keyword is stripped from classes and methods.
-
-1. Some bespoke pieces of instrumentation, such as supporting
-   [SparseArray.set](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java#L201).
-
-This instrumentation is typically performed when a new release of Robolectric is
-made. These pre-instrumented Android-all jars are published on MavenCentral. See
-the
-[android-all-instrumented](https://repo1.maven.org/maven2/org/robolectric/android-all-instrumented/)
-path. They are lazily downloaded and during tests runtime using
-[MavenArtifactFetcher](https://github.com/robolectric/robolectric/blob/master/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenArtifactFetcher.java).
-
-Although Robolectric supports shadowing for Android framework classes, it is
-also possible for users to perform Robolectric instrumentation for any package
-(with the exception of built in Java packages). This enables shadowing of
-arbitrary third-party code.
-
-# Shadows
-
-By default when an Android method is invoked during a Robolectric test, the real
-Android framework code is invoked. This is because a lot of Android framework
-classes are pure Java code (e.g the
-[Intent](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/content/Intent.java)
-class or the
-[org.json](https://cs.android.com/android/platform/superproject/main/+/main:libcore/json/src/main/java/org/json/)
-package) and that code can run on the JVM without any modifications needed.
-
-However, there are cases where Robolectric needs to intercept and replace
-Android method calls. This most commonly occurs when Android system service or
-native methods are invoked. To do this, Robolectric uses a system called Shadow
-classes.
-
-Shadow classes are Java classes that contain the replacement code of Android
-methods when they are invoked. Each shadow class is bound to specific Android
-classes and methods through annotations. There are currently hundreds of shadow
-classes that can be found
-[here](https://github.com/robolectric/robolectric/tree/master/shadows/framework/src/main/java/org/robolectric/shadows).
-
-Shadow classes may optionally contain public apis APIs that can customize the
-behavior of the methods they are shadowing.
-
-Robolectric allows tests to specify custom shadows as well to provide user
-defined implementation for Android classes.
-
-## Shadow Packages and the Robolectric Annotation Processor 
-
-There are two categories of shadows: Robolectric’s built-in shadows that are
-aggregated using the [Robolectric Annotation Processor
-(RAP)](https://github.com/robolectric/robolectric/blob/master/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java),
-and custom shadows that are commonly specified using `@Config(shadows = …)`. RAP
-is configured to process all of the shadow files that exist in Robolectric’s
-code. The main shadow package is [framework
-shadows](https://github.com/robolectric/robolectric/tree/master/shadows/framework),
-which contain shadows for the Android framework. There are other shadow packages
-in Robolectric's code, such as [httpclient
-shadows](https://github.com/robolectric/robolectric/tree/master/shadows/httpclient),
-but all of them outside of framework shadows are deprecated. When Robolectric is
-built, each shadow package is processed by RAP and a
-[ShadowProvider](https://github.com/robolectric/robolectric/blob/master/shadowapi/src/main/java/org/robolectric/internal/ShadowProvider.java)
-file is generated. For example, to see the ShadowProvider for the framework
-shadows, you can run:
-
-```sh
-./gradlew :shadows:framework:assemble
-cat ./shadows/framework/build/generated/src/apt/main/org/robolectric/Shadows.java
-```
-
-In this file you will see the class `public class Shadows implements
-ShadowProvider`.
-
-During runtime, Robolectric will use ServiceLoader to detect all shadow packages
-that implement ShadowProvider and the shadow classes contained in them.
-
-# Sandbox and ClassLoader
-
-Before a Robolectric test is executed, a
-[Sandbox](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/Sandbox.java)
-must be initialized. A Sandbox consists of some high-level structures that are
-necessary to run a Robolectric test. It primarily contains a
-[SandboxClassLoader](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java),
-which is a custom ClassLoader that is bound to a specific instrumented
-Android-all jar. Sandboxes also contain the ExecutorService that serves as the
-main thread (UI thread) as well as high-level instrumentation configuration. The
-SandboxClassLoader is installed as the default ClassLoader for the test method.
-When any Android class is requested, SandboxClassLoader will attempt to load the
-Android class from the instrumented Android-all Jar first. The primary goal of
-SandboxClassLoader is to ensure that classes from the android.jar stubs jar are
-not inadvertently loaded. When classes from the android.jar stubs jar are
-loaded, attempting to invoke any method on them will result in a
-`RuntimeException(“Stub!”)` error. Typically the Android stubs jar is on the
-class path during a Robolectric test, but it is important not to load classes
-from the stubs jar.
-
-# Invokedynamic Delegators and ShadowWrangler
-
-This section provides more detail for `invokedynamic delegators` that were
-referenced in the instrumentation section. For an overview of the
-`invokedynamic` JVM instructions, you can search for articles or watch [YouTube
-videos such as this](https://www.youtube.com/watch?v=KhiECfzyVt0).
-
-To reiterate, for any Android method, Robolectric’s instrumentation adds an
-`invokedynamic delegator` that is responsible for determining at runtime to
-either invoke the real Android framework code or a shadow method. The first time
-an Android method is invoked in a Sandbox, it will result in a call to one of
-the bootstrap methods in
-[InvokeDynamicSupport](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicSupport.java).
-This will subsequently invoke the
-[ShadowWrangler.findShadowMethodHandle](https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java#L197)
-to determine if a shadow method exists for the method that is being invoked.  If
-a shadow method is available a MethodHandle to it will be returned. Otherwise a
-MethodHandle for the original framework code will be returned.
-
-# Test lifecycle
-
-There is a lot of work done by Robolectric before and after a test is run.
-Besides the Sandbox and ClassLoader initialization mentioned above, there is
-also extensive Android environment initialization that occurs before each test.
-The high-level class for this is
-[AndroidTestEnvironment](https://github.com/robolectric/robolectric/blob/master/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java).
-This involves:
-
-*   Initializing up the Looper mode (i.e. the scheduler)
-*   Initializing system and app resources
-*   Initializing the application context and system context
-*   Loading the Android manifest for the test
-*   Creating the Application object used for the test
-*   Initializing the [display configuration](https://robolectric.org/device-configuration/)
-*   Setting up the ActivityThread
-*   Creating app directories
-
-It is possible for users to extend the test environment setup using
-[TestEnvironmentLifecyclePlugin](https://github.com/robolectric/robolectric/blob/master/pluginapi/src/main/java/org/robolectric/pluginapi/TestEnvironmentLifecyclePlugin.java).
-
-Similarly, after each test, many Android classes are reset during
-[RobolectricTestRunner.finallyAfterTest](https://github.com/robolectric/robolectric/blob/master/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java#L301).
-This will iterate over all shadows and invoke their static `@Resetter` methods.
-
-# Plugin System
-
-Many parts of Robolectric can be customized using a plugin system based on
-Java’s
-[ServiceLoader](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html).
-This extensibility is useful when running Robolectric in more constrained
-environments. For example, by default, most of the Robolectric classes are
-designed to work in a Gradle/Android Studio environment. However, there are
-companies (such as Google) that use alternate build systems (such as Bazel), and
-it can be helpful to have the ability to customize the behavior of some core
-modules.
-
-The
-[pluginapi](https://github.com/robolectric/robolectric/tree/master/pluginapi/src)
-subproject contains many extension points of Robolectric. However, virtually any
-class that is loaded by Robolectric’s
-[Injector](https://github.com/robolectric/robolectric/blob/master/utils/src/main/java/org/robolectric/util/inject/Injector.java)
-has the ability to use
-[PluginFinder](https://github.com/robolectric/robolectric/blob/master/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java),
-which means it can be extended at runtime.
-
-Typically ServiceLoaders plugins can be easily written using the
-[AutoService](https://github.com/google/auto/tree/main/service) project.
-
+This documentation has moved to [robolectric.org](https://robolectric.org/architecture).
diff --git a/Android.bp b/Android.bp
index 4ae45d278..bf728d0dd 100644
--- a/Android.bp
+++ b/Android.bp
@@ -53,7 +53,7 @@ license {
 
 // Empty library. Should be removed
 java_library {
-    name: "robolectric_android-all-stub_upstream",
+    name: "robolectric_android-all-stub",
     visibility: ["//visibility:public"],
 }
 
@@ -117,6 +117,8 @@ java_library {
         "robolectric_tzdata",
         "robolectric_framework_res",
         "robolectric_props_jar",
+        "robolectric_nativeruntime_native_prebuilt_main",
+        "icu-data_host_robolectric",
     ],
     // WARNING: DO NOT ADD NEW DEPENDENCIES ON THIS MODULE OR ITS DIST JAR
     // This dist jar is an internal implementation detail. For external Gradle builds (outside
@@ -143,23 +145,24 @@ java_library {
 }
 
 java_library_host {
-    name: "Robolectric_all_upstream",
+    name: "Robolectric_all",
 
     static_libs: [
         "Robolectric-aosp-plugins",
-        "Robolectric_shadows_httpclient_upstream",
-        "Robolectric_shadows_framework_upstream",
-        "Robolectric_shadows_multidex_upstream",
-        "Robolectric_shadows_versioning_upstream",
-        "Robolectric_robolectric_upstream",
-        "Robolectric_annotations_upstream",
-        "Robolectric_resources_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_junit_upstream",
-        "Robolectric_utils_upstream",
-        "Robolectric_utils_reflector_upstream",
-        "Robolectric_nativeruntime_upstream",
+        "Robolectric_shadows_httpclient",
+        "Robolectric_shadows_framework",
+        "Robolectric_shadows_multidex",
+        "Robolectric_shadows_versioning",
+        "Robolectric_robolectric",
+        "Robolectric_annotations",
+        "Robolectric_resources",
+        "Robolectric_shadowapi",
+        "Robolectric_sandbox",
+        "Robolectric_junit",
+        "Robolectric_utils",
+        "Robolectric_utils_reflector",
+        "Robolectric_nativeruntime",
+        "TestParameterInjector",
         "asm-9.6",
         "junit",
         "asm-tree-9.6",
@@ -170,8 +173,8 @@ java_library_host {
         "robolectric-sqlite4java-0.282",
         "hamcrest",
         "hamcrest-library",
-        "robolectric-host-androidx-test-runner_upstream",
-        "robolectric-host-org_apache_http_legacy_upstream", //TODO: remove
+        "robolectric-host-androidx-test-runner",
+        "robolectric-host-org_apache_http_legacy", //TODO: remove
     ],
 
     java_resource_dirs: [
@@ -180,149 +183,108 @@ java_library_host {
     ],
 }
 
-// Using visibility as allow list for tests to bypass strict_mode
-java_library {
-    name: "robolectric_non_strict_mode_permission",
-    sdk_version: "current",
-    visibility: [
-        ":__subpackages__",
-        "//vendor:__subpackages__",
-        "//platform_testing/robolab/roboStandaloneProj/tests:__pkg__",
-        "//packages/modules/DeviceLock/DeviceLockController/tests/robolectric:__pkg__",
-        "//packages/apps/StorageManager/robotests:__pkg__",
-        "//packages/apps/KeyChain/robotests:__pkg__",
-        "//packages/apps/CertInstaller/robotests:__pkg__",
-        "//packages/services/Mms/tests/robotests:__pkg__",
-        "//packages/apps/Car/Cluster/DirectRenderingCluster/tests/robotests:__pkg__",
-        "//packages/apps/QuickAccessWallet/tests/robolectric:__pkg__",
-        "//packages/services/Car/tests/CarLibTests:__pkg__",
-        "//frameworks/libs/systemui:__subpackages__",
-        "//packages/apps/WallpaperPicker2/tests/robotests:__pkg__",
-        "//frameworks/opt/wear/signaldetector/robotests:__pkg__",
-        "//packages/apps/EmergencyInfo/tests/robolectric:__pkg__",
-        "//packages/modules/Bluetooth/service:__pkg__",
-        "//frameworks/opt/wear/robotests:__pkg__",
-        "//packages/apps/ThemePicker/tests/robotests:__pkg__",
-        "//packages/modules/DeviceLock/tests/unittests:__pkg__",
-        "//external/mobile-data-download/javatests:__pkg__",
-        "//frameworks/opt/car/setupwizard/library/main/tests/robotests:__pkg__",
-        "//packages/apps/Car/Notification/tests/robotests:__pkg__",
-        "//packages/apps/TvSettings/Settings/tests/robotests:__pkg__",
-        "//packages/apps/Car/Settings/tests/deviceless:__subpackages__",
-        "//packages/apps/Car/Settings/tests/multivalent:__subpackages__",
-        "//packages/apps/Car/Settings/tests/robotests:__pkg__",
-        "//packages/apps/Car/SystemUI:__pkg__",
-        "//packages/apps/Settings/tests/robotests:__pkg__",
-        "//frameworks/base/packages/SystemUI:__pkg__",
-        "//frameworks/base/services/robotests:__pkg__",
-        "//frameworks/base/services/robotests/backup:__pkg__",
-        "//frameworks/base/packages/CredentialManager/wear/robotests",
-        "//frameworks/base/tests/InputScreenshotTest:__subpackages__",
-        "//frameworks/base/packages/SettingsLib:__subpackages__",
-        "//packages/apps/TV/common/tests/robotests:__pkg__",
-        "//packages/apps/Launcher3/tests:__pkg__",
-        "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
-        "//cts/tests:__subpackages__",
-    ],
+java_host_for_device {
+    name: "ClearcutJunitListenerAar",
+    libs: ["ClearcutJunitListener"],
 }
 
 // Make Robolectric_all available as a target jar, but treated as an aar
+// When used for strict mode test visibility does not need to be added,
+// as it's added with visibility rules hidden, and only available at runtime,
+// not compile time when used via strict mode.
+//
+// Visibility rule additions have two use case, being added to an
+// android_robolectric_test as either a compile time dependency for "strict_mode: false"
+// robolectric tests, or a dependency of a library.
 java_host_for_device {
-    name: "Robolectric_all-target_upstream",
-    libs: ["Robolectric_all_upstream"],
+    name: "Robolectric_all-target",
+    libs: ["Robolectric_all"],
     visibility: [
         ":__subpackages__",
-        //java references
-        "//frameworks/opt/net/wifi/libs/WifiTrackerLib/tests:__pkg__",
-        "//prebuilts/sdk/current/androidx:__pkg__",
-        "//prebuilts/sdk/current/androidx/m2repository/androidx/car/app/app-testing/1.4.0-alpha01:__pkg__",
-        "//prebuilts/sdk/current/aaos-libs:__pkg__",
-        "//packages/apps/TV/tests/common:__pkg__",
-        "//external/android_onboarding:__subpackages__",
-        //robolectric tests
-        "//platform_testing/libraries/runner:__pkg__",
-        "//platform_testing/libraries/screenshot/material_components:__pkg__",
         "//vendor:__subpackages__",
-        "//platform_testing/robolab/roboStandaloneProj/tests:__pkg__",
+        "//cts/tests/location:__pkg__",
+        "//external/android_onboarding/java/com/android/onboarding/contracts/testing:__pkg__",
+        "//external/android_onboarding/java/com/android/onboarding/testing:__pkg__",
         "//external/mobile-data-download/javatests:__pkg__",
+        "//frameworks/base/packages/CredentialManager/wear/robotests:__pkg__",
+        "//frameworks/base/packages/SettingsLib/DataStore/tests:__pkg__",
+        "//frameworks/base/packages/SettingsLib/Ipc:__pkg__",
+        "//frameworks/base/packages/SettingsLib/Spa/screenshot/robotests:__pkg__",
+        "//frameworks/base/packages/SettingsLib/SpaPrivileged/tests/robotests:__pkg__",
+        "//frameworks/base/packages/SettingsLib/tests/robotests:__pkg__",
+        "//frameworks/base/packages/SettingsLib/tests/robotests/fragment:__pkg__",
+        "//frameworks/base/packages/SystemUI:__pkg__",
         "//frameworks/base/services/robotests:__pkg__",
         "//frameworks/base/services/robotests/backup:__pkg__",
-        "//frameworks/base/packages/CredentialManager:__subpackages__",
-        "//frameworks/base/packages/SettingsLib:__subpackages__",
-        "//frameworks/base/packages/SystemUI:__pkg__",
-        "//frameworks/libs/systemui:__subpackages__",
-        "//packages/apps/Launcher3/tests:__pkg__",
-        "//frameworks/base/tests/InputScreenshotTest:__subpackages__",
+        "//frameworks/base/tests/InputScreenshotTest/robotests:__pkg__",
+        "//frameworks/libs/systemui/animationlib:__pkg__",
+        "//frameworks/libs/systemui/tracinglib/robolectric:__pkg__",
         "//frameworks/opt/car/setupwizard/library/main/tests/robotests:__pkg__",
         "//frameworks/opt/localepicker/tests:__pkg__",
-        "//frameworks/opt/wear/signaldetector/robotests:__pkg__",
+        "//frameworks/opt/net/wifi/libs/WifiTrackerLib/tests:__pkg__",
+        "//frameworks/opt/net/wifi/libs/WifiTrackerLib/tests:__pkg__",
         "//frameworks/opt/wear/robotests:__pkg__",
-        "//packages/modules/Bluetooth/service:__pkg__",
-        "//packages/modules/Connectivity/nearby/tests/multidevices/clients/test_support/snippet_helper/tests:__pkg__",
-        "//packages/modules/Connectivity/nearby/tests/robotests:__pkg__",
-        "//packages/modules/DeviceLock/DeviceLockController/tests/robolectric:__pkg__",
-        "//packages/modules/DeviceLock/tests/unittests:__pkg__",
-        "//packages/services/Car/tests/CarLibTests:__pkg__",
-        "//packages/services/Mms/tests/robotests:__pkg__",
-        "//packages/apps/QuickAccessWallet/tests/robolectric:__pkg__",
-        "//packages/apps/ManagedProvisioning/tests/robotests:__pkg__",
-        "//packages/apps/Car/libs/car-media-common/tests/robotests",
-        "//packages/apps/Car/libs/car-ui-lib",
-        "//packages/apps/Car/Notification/tests/robotests:__pkg__",
-        "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
+        "//frameworks/opt/wear/signaldetector/robotests:__pkg__",
         "//packages/apps/Car/Cluster/DirectRenderingCluster/tests/robotests:__pkg__",
-        "//packages/apps/Car/Settings/tests/deviceless:__subpackages__",
-        "//packages/apps/Car/Settings/tests/multivalent:__subpackages__",
+        "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
+        "//packages/apps/Car/libs/car-ui-lib:__pkg__",
+        "//packages/apps/Car/Notification/tests/robotests:__pkg__",
+        "//packages/apps/Car/Settings/tests/deviceless:__pkg__",
+        "//packages/apps/Car/Settings/tests/multivalent:__pkg__",
         "//packages/apps/Car/Settings/tests/robotests:__pkg__",
         "//packages/apps/Car/SystemUI:__pkg__",
+        "//packages/apps/CertInstaller/robotests:__pkg__",
         "//packages/apps/EmergencyInfo/tests/robolectric:__pkg__",
-        "//packages/apps/StorageManager/robotests:__pkg__",
+        "//packages/apps/KeyChain/robotests:__pkg__",
+        "//packages/apps/Launcher3/tests:__pkg__",
+        "//packages/apps/QuickAccessWallet/tests/robolectric:__pkg__",
         "//packages/apps/Settings/tests/robotests:__pkg__",
+        "//packages/apps/StorageManager/robotests:__pkg__",
         "//packages/apps/ThemePicker/tests/robotests:__pkg__",
+        "//packages/apps/TV/common/tests/robotests:__pkg__",
+        "//packages/apps/TvSettings/Settings/tests/robotests:__pkg__",
+        "//packages/apps/TV/tests/common:__pkg__",
         "//packages/apps/WallpaperPicker2/tests/robotests:__pkg__",
         "//packages/apps/WallpaperPicker2/tests/robotests/common:__pkg__",
-        "//packages/apps/TvSettings/Settings/tests/robotests:__pkg__",
-        "//packages/apps/KeyChain/robotests:__pkg__",
-        "//packages/apps/CertInstaller/robotests:__pkg__",
-        "//packages/providers/MediaProvider:__subpackages__",
-        "//packages/apps/TV:__subpackages__",
-        "//frameworks/base/libs/WindowManager/Shell:__subpackages__",
-        //tm-dev additions
-        "//frameworks/base/packages/BackupEncryption/test/robolectric-integration:__pkg__",
-        "//frameworks/base/packages/BackupEncryption/test/robolectric:__pkg__",
-        "//packages/apps/Settings/tests/screenshot:__pkg__",
-        "//cts/tests:__subpackages__",
+        "//packages/modules/Bluetooth/service:__pkg__",
+        "//packages/modules/DeviceLock/DeviceLockController/tests/robolectric:__pkg__",
+        "//packages/modules/DeviceLock/tests/unittests:__pkg__",
+        "//packages/services/Car/tests/CarLibTests:__pkg__",
+        "//packages/services/Mms/tests/robotests:__pkg__",
+        "//platform_testing/libraries/runner:__pkg__",
+        "//platform_testing/robolab/roboStandaloneProj/tests:__pkg__",
+        "//prebuilts/sdk/current/aaos-libs:__pkg__",
     ],
 }
 
 // Make dependencies available as host jars
 java_device_for_host {
-    name: "robolectric-host-androidx-test-core_upstream",
+    name: "robolectric-host-androidx-test-core",
     libs: ["androidx.test.core"],
 }
 
 java_device_for_host {
-    name: "robolectric-host-androidx-test-ext-junit_upstream",
+    name: "robolectric-host-androidx-test-ext-junit",
     libs: ["androidx.test.ext.junit"],
 }
 
 java_device_for_host {
-    name: "robolectric-host-androidx-test-monitor_upstream",
+    name: "robolectric-host-androidx-test-monitor",
     libs: ["androidx.test.monitor"],
 }
 
 java_device_for_host {
-    name: "robolectric-host-androidx-test-ext-truth_upstream",
+    name: "robolectric-host-androidx-test-ext-truth",
     libs: ["androidx.test.ext.truth"],
 }
 
 java_device_for_host {
-    name: "robolectric-host-androidx-test-runner_upstream",
+    name: "robolectric-host-androidx-test-runner",
     libs: ["androidx.test.runner"],
 }
 
 java_device_for_host {
-    name: "robolectric-host-androidx_upstream",
+    name: "robolectric-host-androidx",
     libs: ["androidx.fragment_fragment"],
 }
 
@@ -332,7 +294,7 @@ java_device_for_host {
 }
 
 java_device_for_host {
-    name: "robolectric-host-android-support-multidex_upstream",
+    name: "robolectric-host-android-support-multidex",
     libs: [
         "android-support-multidex",
         "com.android.support.multidex_1.0.3",
@@ -340,6 +302,6 @@ java_device_for_host {
 }
 
 java_device_for_host {
-    name: "robolectric-host-org_apache_http_legacy_upstream",
+    name: "robolectric-host-org_apache_http_legacy",
     libs: ["org.apache.http.legacy.stubs"],
 }
diff --git a/METADATA b/METADATA
index 43c94c633..633b4a9fe 100644
--- a/METADATA
+++ b/METADATA
@@ -5,11 +5,11 @@ third_party {
     type: GIT
     value: "https://github.com/robolectric/robolectric"
   }
-  version: "68ec9953ea0ac7c47588db540145a728a1f00ba8"
+  version: "e20c1a2e0fa650910c04ac845d98f8046121cbd7"
   license_type: NOTICE
   last_upgrade_date {
-    year: 2023
-    month: 5
+    year: 2025
+    month: 1
     day: 24
   }
 }
diff --git a/OWNERS b/OWNERS
index 77fe20825..3bbebb19c 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,4 +1,5 @@
 rexhoffman@google.com
 congxiliu@google.com
-brettchabot@google.com
-hoisie@google.com
+brettchabot@google.com #{LAST_RESORT_SUGGESTION}
+hoisie@google.com #{LAST_RESORT_SUGGESTION}
+include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/README.md b/README.md
index 85de2738e..1b75f9851 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@
 
 Robolectric is the industry-standard unit testing framework for Android. With Robolectric, your tests run in a simulated Android environment inside a JVM, without the overhead and flakiness of an emulator. Robolectric tests routinely run 10x faster than those on cold-started emulators.
 
-Robolectric supports running unit tests for *14* different versions of Android, ranging from Lollipop (API level 21) to U (API level 34).
+Robolectric supports running unit tests for *15* different versions of Android, ranging from Lollipop (API level 21) to V (API level 35).
 
 ## Usage
 
@@ -40,7 +40,7 @@ If you'd like to start a new project with Robolectric tests, you can refer to `d
 
 ```groovy
 testImplementation "junit:junit:4.13.2"
-testImplementation "org.robolectric:robolectric:4.13"
+testImplementation "org.robolectric:robolectric:4.14.1"
 ```
 
 ## Building and Contributing
@@ -51,7 +51,34 @@ To get Robolectric up and running on your machine, check out
 [this guide](https://robolectric.org/building-robolectric/).
 
 To get a high-level overview of Robolectric's architecture, check out
-[ARCHITECTURE.md](ARCHITECTURE.md).
+[robolectric.org](https://robolectric.org/architecture).
+
+## Development model
+
+Robolectric is actively developed in several locations. The primary location is
+this GitHub repository, which is considered the *source-of-truth* for
+Robolectric code. It is where contributions from the broader Android developer
+community occur. There is also an active development tree of Robolectric
+internally at Google, where contributions from first-party Android developers
+occur. By having a development tree of Robolectric internally at Google, it
+enables first-party Android developers to more efficiently make contributions
+to Robolectric. This tree is synced directly to the [`google`
+branch](https://github.com/robolectric/robolectric/tree/google) every
+time a change occurs using the [`Copybara`](https://github.com/google/copybara)
+code sync tool. Bidirectional merges of this branch and the
+[`master`](https://github.com/robolectric/robolectric/tree/master) branch occur
+regularly.
+
+Robolectric also has usage in the Android platform via the
+[external/robolectric](https://cs.android.com/android/platform/superproject/main/+/main:external/robolectric/)
+repo project. Contributions to this source tree are typically related to new
+SDK support and evolving platform APIs. Changes from this branch are upstreamed
+to the internal Robolectric tree at Google, which eventually propagate to the
+GitHub branches.
+
+Although complex, this distributed development model enables Android developers
+in different environments to use and contribute to Robolectric, while allowing
+changes to eventually make their way to public Robolectric releases.
 
 ## Using Snapshots
 
@@ -65,6 +92,6 @@ repositories {
 }
 
 dependencies {
-    testImplementation "org.robolectric:robolectric:4.14-SNAPSHOT"
+    testImplementation "org.robolectric:robolectric:4.15-SNAPSHOT"
 }
 ```
diff --git a/annotations/Android.bp b/annotations/Android.bp
index fd17be03c..1500ae635 100644
--- a/annotations/Android.bp
+++ b/annotations/Android.bp
@@ -12,7 +12,7 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_annotations_upstream",
+    name: "Robolectric_annotations",
     static_libs: [
         "jsr305",
     ],
diff --git a/annotations/build.gradle.kts b/annotations/build.gradle.kts
index 5af87897f..568615035 100644
--- a/annotations/build.gradle.kts
+++ b/annotations/build.gradle.kts
@@ -9,6 +9,5 @@ dependencies {
   compileOnly(AndroidSdk.MAX_SDK.coordinates)
   testImplementation(libs.truth)
   testImplementation(libs.junit4)
-  testImplementation(libs.javax.annotation.api)
   testCompileOnly(AndroidSdk.MAX_SDK.coordinates) // compile against latest Android SDK
 }
diff --git a/annotations/src/main/java/org/robolectric/annotation/Config.java b/annotations/src/main/java/org/robolectric/annotation/Config.java
index 1553e6d96..b969792ed 100644
--- a/annotations/src/main/java/org/robolectric/annotation/Config.java
+++ b/annotations/src/main/java/org/robolectric/annotation/Config.java
@@ -111,7 +111,7 @@ public @interface Config {
   /**
    * Qualifiers specifying device configuration for this test, such as "fr-normal-port-hdpi".
    *
-   * <p>If the string is prefixed with '+', the qualifiers that follow are overlayed on any more
+   * <p>If the string is prefixed with '+', the qualifiers that follow are overlaid on any more
    * broadly-scoped qualifiers.
    *
    * @see <a href="http://robolectric.org/device-configuration">Device Configuration</a> for
@@ -186,7 +186,7 @@ public @interface Config {
     private final String[] libraries;
 
     public static Config fromProperties(Properties properties) {
-      if (properties == null || properties.size() == 0) return null;
+      if (properties == null || properties.isEmpty()) return null;
       return new Implementation(
           parseSdkArrayProperty(properties.getProperty("sdk", "")),
           parseSdkInt(properties.getProperty("minSdk", "-1")),
@@ -216,7 +216,7 @@ public @interface Config {
     private static Class<?>[] parseClasses(String input) {
       if (input.isEmpty()) return new Class[0];
       final String[] classNames = input.split("[, ]+", 0);
-      final Class[] classes = new Class[classNames.length];
+      final Class<?>[] classes = new Class[classNames.length];
       for (int i = 0; i < classNames.length; i++) {
         classes[i] = parseClass(classNames[i]);
       }
@@ -560,7 +560,7 @@ public @interface Config {
       this.fontScale = pick(this.fontScale, overlayFontScale, DEFAULT_FONT_SCALE);
 
       String qualifiersOverlayValue = overlayConfig.qualifiers();
-      if (qualifiersOverlayValue != null && !qualifiersOverlayValue.equals("")) {
+      if (qualifiersOverlayValue != null && !qualifiersOverlayValue.isEmpty()) {
         if (qualifiersOverlayValue.startsWith("+")) {
           this.qualifiers = this.qualifiers + " " + qualifiersOverlayValue;
         } else {
@@ -575,20 +575,18 @@ public @interface Config {
 
       List<Class<?>> shadows = new ArrayList<>(Arrays.asList(this.shadows));
       shadows.addAll(Arrays.asList(overlayConfig.shadows()));
-      this.shadows = shadows.toArray(new Class[shadows.size()]);
+      this.shadows = shadows.toArray(new Class[0]);
 
       Set<String> instrumentedPackages = new HashSet<>();
       instrumentedPackages.addAll(Arrays.asList(this.instrumentedPackages));
       instrumentedPackages.addAll(Arrays.asList(overlayConfig.instrumentedPackages()));
-      this.instrumentedPackages =
-          instrumentedPackages.toArray(new String[instrumentedPackages.size()]);
-
+      this.instrumentedPackages = instrumentedPackages.toArray(new String[0]);
       this.application = pick(this.application, overlayConfig.application(), DEFAULT_APPLICATION);
 
       Set<String> libraries = new HashSet<>();
       libraries.addAll(Arrays.asList(this.libraries));
       libraries.addAll(Arrays.asList(overlayConfig.libraries()));
-      this.libraries = libraries.toArray(new String[libraries.size()]);
+      this.libraries = libraries.toArray(new String[0]);
 
       return this;
     }
diff --git a/annotations/src/main/java/org/robolectric/annotation/Implements.java b/annotations/src/main/java/org/robolectric/annotation/Implements.java
index d9e63834a..ab0877c43 100644
--- a/annotations/src/main/java/org/robolectric/annotation/Implements.java
+++ b/annotations/src/main/java/org/robolectric/annotation/Implements.java
@@ -74,10 +74,9 @@ public @interface Implements {
    * If set to true, Robolectric will invoke the native method variant instead of the no-op variant.
    * This requires the native method to be bound, or an {@link UnsatisfiedLinkError} will occur.
    *
-   * <p>{@link Implements#callNativeMethodsByDefault()} has precedence over {@link
-   * Implements#callThroughByDefault()} For instance, if both {@link
-   * Implements#callNativeMethodsByDefault()} and {@link Implements#callThroughByDefault()} are
-   * true, the native method variant will be preferred over the no-op native variant.
+   * <p>This method has precedence over {@link Implements#callThroughByDefault()}. For instance, if
+   * both this method and {@link Implements#callThroughByDefault()} are true, the native method
+   * variant will be preferred over the no-op native variant.
    */
   boolean callNativeMethodsByDefault() default false;
 
diff --git a/annotations/src/main/java/org/robolectric/annotation/LooperMode.java b/annotations/src/main/java/org/robolectric/annotation/LooperMode.java
index 5849daab5..c6231aaa3 100644
--- a/annotations/src/main/java/org/robolectric/annotation/LooperMode.java
+++ b/annotations/src/main/java/org/robolectric/annotation/LooperMode.java
@@ -5,6 +5,7 @@ import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.time.Duration;
 
 /**
  * A {@link org.robolectric.pluginapi.config.Configurer} annotation for controlling Robolectric's
@@ -92,7 +93,7 @@ public @interface LooperMode {
      *       queue of pending tasks
      *   <li>There is only a single clock value, managed via {@link
      *       org.robolectric.shadows.ShadowSystemClock}. This can be explictly incremented via
-     *       {@link android.os.SystemClock#setCurrentTimeMillis(long)}, or {@link
+     *       {@link org.robolectric.shadows.ShadowSystemClock#advanceBy(Duration)}, or {@link
      *       org.robolectric.shadows.ShadowLooper#idleFor(Duration)}.
      * </ul>
      *
diff --git a/annotations/src/main/java/org/robolectric/annotation/experimental/LazyApplication.java b/annotations/src/main/java/org/robolectric/annotation/experimental/LazyApplication.java
index d51d9cc04..2a8952e3c 100644
--- a/annotations/src/main/java/org/robolectric/annotation/experimental/LazyApplication.java
+++ b/annotations/src/main/java/org/robolectric/annotation/experimental/LazyApplication.java
@@ -9,10 +9,10 @@ import java.lang.annotation.Target;
  * A {@link org.robolectric.pluginapi.config.Configurer} annotation that dictates whether or not
  * Robolectric should lazily instantiate the Application under test.
  *
- * <p>In particular, any test with {@link LazyLoad.ON} that does not need the Application will not
+ * <p>In particular, any test with {@link LazyLoad#ON} that does not need the Application will not
  * load it (and recoup the associated cost)
  *
- * <p>NOTE: This feature is currently still experimental, so any users of {@link LazyLoad.ON} do so
+ * <p>NOTE: This feature is currently still experimental, so any users of {@link LazyLoad#ON} do so
  * at their own risk
  */
 @Retention(RetentionPolicy.RUNTIME)
diff --git a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
index 34a467172..abb8abb0f 100644
--- a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
+++ b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
@@ -54,6 +54,7 @@ import javax.annotation.Nullable;
  */
 public final class AndroidVersions {
 
+  @SuppressWarnings("FieldMayBeFinal") // The value is changed via reflection in tests
   private static boolean warnOnly;
 
   private AndroidVersions() {}
@@ -89,17 +90,10 @@ public final class AndroidVersions {
      *
      * @param other the object to be compared.
      * @return 1 if this is greater than other, 0 if equal, -1 if less
-     * @throws IllegalStateException if other is not an instance of AndroidRelease.
+     * @throws NullPointerException if other is null.
      */
     @Override
     public int compareTo(AndroidRelease other) {
-      if (other == null) {
-        throw new IllegalStateException(
-            "Only "
-                + AndroidVersions.class.getName()
-                + " should define Releases, illegal class "
-                + other.getClass());
-      }
       return Integer.compare(this.getSdkInt(), other.getSdkInt());
     }
 
@@ -406,9 +400,9 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 7.1 <br>
+   * Version: 7.1 <br>
    * ShortCode: NMR1 <br>
-   * SDK Framework: 25 <br>
+   * SDK API Level: 25 <br>
    * release: true <br>
    */
   public static final class NMR1 extends AndroidReleased {
@@ -436,7 +430,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 8.0 <br>
+   * Version: 8.0 <br>
    * ShortCode: O <br>
    * SDK API Level: 26 <br>
    * release: true <br>
@@ -466,7 +460,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 8.1 <br>
+   * Version: 8.1 <br>
    * ShortCode: OMR1 <br>
    * SDK API Level: 27 <br>
    * release: true <br>
@@ -496,7 +490,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 9.0 <br>
+   * Version: 9 <br>
    * ShortCode: P <br>
    * SDK API Level: 28 <br>
    * release: true <br>
@@ -507,7 +501,7 @@ public final class AndroidVersions {
 
     public static final String SHORT_CODE = "P";
 
-    public static final String VERSION = "9.0";
+    public static final String VERSION = "9";
 
     @Override
     public int getSdkInt() {
@@ -526,7 +520,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 10.0 <br>
+   * Version: 10 <br>
    * ShortCode: Q <br>
    * SDK API Level: 29 <br>
    * release: true <br>
@@ -537,7 +531,7 @@ public final class AndroidVersions {
 
     public static final String SHORT_CODE = "Q";
 
-    public static final String VERSION = "10.0";
+    public static final String VERSION = "10";
 
     @Override
     public int getSdkInt() {
@@ -556,7 +550,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 11.0 <br>
+   * Version: 11 <br>
    * ShortCode: R <br>
    * SDK API Level: 30 <br>
    * release: true <br>
@@ -567,7 +561,7 @@ public final class AndroidVersions {
 
     public static final String SHORT_CODE = "R";
 
-    public static final String VERSION = "11.0";
+    public static final String VERSION = "11";
 
     @Override
     public int getSdkInt() {
@@ -586,7 +580,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 12.0 <br>
+   * Version: 12 <br>
    * ShortCode: S <br>
    * SDK API Level: 31 <br>
    * release: true <br>
@@ -597,7 +591,7 @@ public final class AndroidVersions {
 
     public static final String SHORT_CODE = "S";
 
-    public static final String VERSION = "12.0";
+    public static final String VERSION = "12";
 
     @Override
     public int getSdkInt() {
@@ -616,7 +610,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 12.1 <br>
+   * Version: 12.1 <br>
    * ShortCode: Sv2 <br>
    * SDK API Level: 32 <br>
    * release: true <br>
@@ -647,7 +641,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Release: 13.0 <br>
+   * Version: 13 <br>
    * ShortCode: T <br>
    * SDK API Level: 33 <br>
    * release: true <br>
@@ -658,7 +652,7 @@ public final class AndroidVersions {
 
     public static final String SHORT_CODE = "T";
 
-    public static final String VERSION = "13.0";
+    public static final String VERSION = "13";
 
     @Override
     public int getSdkInt() {
@@ -677,7 +671,7 @@ public final class AndroidVersions {
   }
 
   /**
-   * Potential Release: 14.0 <br>
+   * Version: 14 <br>
    * ShortCode: U <br>
    * SDK API Level: 34 <br>
    * release: false <br>
@@ -688,7 +682,7 @@ public final class AndroidVersions {
 
     public static final String SHORT_CODE = "U";
 
-    public static final String VERSION = "14.0";
+    public static final String VERSION = "14";
 
     @Override
     public int getSdkInt() {
@@ -707,10 +701,10 @@ public final class AndroidVersions {
   }
 
   /**
-   * Potential Release: 15.0 <br>
+   * Version: 15 <br>
    * ShortCode: V <br>
-   * SDK API Level: 34+ <br>
-   * release: false <br>
+   * SDK API Level: 35 <br>
+   * release: true <br>
    */
   public static final class V extends AndroidReleased {
 
@@ -952,7 +946,7 @@ public final class AndroidVersions {
             current = shortCodeToAllReleases.get(codename);
             // else, assume the fullname is the first letter is correct.
             if (current == null) {
-              current = shortCodeToAllReleases.get(String.valueOf(foundCode));
+              current = shortCodeToAllReleases.get(foundCode);
             }
           }
           if (current == null) {
@@ -1080,7 +1074,7 @@ public final class AndroidVersions {
 
   private static final SdkInformation information;
 
-  private static final void errorMessage(String errorMessage, @Nullable Exception ex) {
+  private static void errorMessage(String errorMessage, @Nullable Exception ex) {
     if (warnOnly) {
       System.err.println(errorMessage);
     } else {
diff --git a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java
index c9f6e825c..4594f897e 100644
--- a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java
+++ b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java
@@ -1,9 +1,11 @@
 package org.robolectric.versioning;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 
 import java.lang.reflect.Field;
 import java.util.Arrays;
+import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -36,7 +38,10 @@ public final class AndroidVersionsEdgeCaseTest {
       SdkInformation information = AndroidVersions.gatherStaticSdkInformationFromThisClass();
       earliestUnrelease = information.earliestUnreleased;
       information.computeCurrentSdk(
-          earliestUnrelease.getSdkInt(), earliestUnrelease.getVersion(), "REL", Arrays.asList());
+          earliestUnrelease.getSdkInt(),
+          earliestUnrelease.getVersion(),
+          "REL",
+          Collections.emptyList());
       assertThat(this).isNull();
     } catch (RuntimeException e) {
       assertThat(e)
@@ -69,7 +74,7 @@ public final class AndroidVersionsEdgeCaseTest {
           latestRelease.getSdkInt(),
           null,
           latestRelease.getShortCode(),
-          Arrays.asList(latestRelease.getShortCode()));
+          Collections.singletonList(latestRelease.getShortCode()));
       assertThat(this).isNull();
     } catch (RuntimeException e) {
       assertThat(e)
@@ -85,7 +90,7 @@ public final class AndroidVersionsEdgeCaseTest {
 
   @Test
   public void sdkIntReleasedButStillReportsCodeName_warningMode() {
-    AndroidRelease latestRelease = null;
+    AndroidRelease latestRelease;
     try {
       forceWarningMode(true);
       SdkInformation information = AndroidVersions.gatherStaticSdkInformationFromThisClass();
@@ -95,7 +100,7 @@ public final class AndroidVersionsEdgeCaseTest {
           latestRelease.getSdkInt(),
           null,
           information.latestRelease.getShortCode(),
-          Arrays.asList(latestRelease.getShortCode()));
+          Collections.singletonList(latestRelease.getShortCode()));
     } catch (Throwable t) {
       assertThat(t).isNull();
     }
@@ -115,7 +120,7 @@ public final class AndroidVersionsEdgeCaseTest {
         latestRelease.getSdkInt(),
         null,
         information.latestRelease.getShortCode(),
-        Arrays.asList(latestRelease.getShortCode()));
+        Collections.singletonList(latestRelease.getShortCode()));
     assertThat(this).isNotNull();
   }
 
@@ -132,4 +137,10 @@ public final class AndroidVersionsEdgeCaseTest {
       assertThat(t).isNull();
     }
   }
+
+  @Test
+  public void compareToNull_throwsNullPointerException() {
+    //noinspection DataFlowIssue Passing null to ensure that the right exception is thrown
+    assertThrows(NullPointerException.class, () -> new AndroidVersions.T().compareTo(null));
+  }
 }
diff --git a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
index 3dba1dc15..fd7723240 100644
--- a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
+++ b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
@@ -56,10 +56,10 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationU() {
     assertThat(AndroidVersions.U.SDK_INT).isEqualTo(34);
     assertThat(AndroidVersions.U.SHORT_CODE).isEqualTo("U");
-    assertThat(AndroidVersions.U.VERSION).isEqualTo("14.0");
+    assertThat(AndroidVersions.U.VERSION).isEqualTo("14");
     assertThat(new AndroidVersions.U().getSdkInt()).isEqualTo(34);
     assertThat(new AndroidVersions.U().getShortCode()).isEqualTo("U");
-    assertThat(new AndroidVersions.U().getVersion()).isEqualTo("14.0");
+    assertThat(new AndroidVersions.U().getVersion()).isEqualTo("14");
     assertThat(new AndroidVersions.U().isReleased()).isTrue();
   }
 
@@ -67,10 +67,10 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationT() {
     assertThat(AndroidVersions.T.SDK_INT).isEqualTo(33);
     assertThat(AndroidVersions.T.SHORT_CODE).isEqualTo("T");
-    assertThat(AndroidVersions.T.VERSION).isEqualTo("13.0");
+    assertThat(AndroidVersions.T.VERSION).isEqualTo("13");
     assertThat(new AndroidVersions.T().getSdkInt()).isEqualTo(33);
     assertThat(new AndroidVersions.T().getShortCode()).isEqualTo("T");
-    assertThat(new AndroidVersions.T().getVersion()).isEqualTo("13.0");
+    assertThat(new AndroidVersions.T().getVersion()).isEqualTo("13");
     assertThat(new AndroidVersions.T().isReleased()).isTrue();
   }
 
@@ -89,10 +89,10 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationS() {
     assertThat(AndroidVersions.S.SDK_INT).isEqualTo(31);
     assertThat(AndroidVersions.S.SHORT_CODE).isEqualTo("S");
-    assertThat(AndroidVersions.S.VERSION).isEqualTo("12.0");
+    assertThat(AndroidVersions.S.VERSION).isEqualTo("12");
     assertThat(new AndroidVersions.S().getSdkInt()).isEqualTo(31);
     assertThat(new AndroidVersions.S().getShortCode()).isEqualTo("S");
-    assertThat(new AndroidVersions.S().getVersion()).isEqualTo("12.0");
+    assertThat(new AndroidVersions.S().getVersion()).isEqualTo("12");
     assertThat(new AndroidVersions.S().isReleased()).isTrue();
   }
 
@@ -100,10 +100,10 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationR() {
     assertThat(AndroidVersions.R.SDK_INT).isEqualTo(30);
     assertThat(AndroidVersions.R.SHORT_CODE).isEqualTo("R");
-    assertThat(AndroidVersions.R.VERSION).isEqualTo("11.0");
+    assertThat(AndroidVersions.R.VERSION).isEqualTo("11");
     assertThat(new AndroidVersions.R().getSdkInt()).isEqualTo(30);
     assertThat(new AndroidVersions.R().getShortCode()).isEqualTo("R");
-    assertThat(new AndroidVersions.R().getVersion()).isEqualTo("11.0");
+    assertThat(new AndroidVersions.R().getVersion()).isEqualTo("11");
     assertThat(new AndroidVersions.R().isReleased()).isTrue();
   }
 
@@ -111,10 +111,10 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationQ() {
     assertThat(AndroidVersions.Q.SDK_INT).isEqualTo(29);
     assertThat(AndroidVersions.Q.SHORT_CODE).isEqualTo("Q");
-    assertThat(AndroidVersions.Q.VERSION).isEqualTo("10.0");
+    assertThat(AndroidVersions.Q.VERSION).isEqualTo("10");
     assertThat(new AndroidVersions.Q().getSdkInt()).isEqualTo(29);
     assertThat(new AndroidVersions.Q().getShortCode()).isEqualTo("Q");
-    assertThat(new AndroidVersions.Q().getVersion()).isEqualTo("10.0");
+    assertThat(new AndroidVersions.Q().getVersion()).isEqualTo("10");
     assertThat(new AndroidVersions.Q().isReleased()).isTrue();
   }
 
@@ -122,10 +122,10 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationP() {
     assertThat(AndroidVersions.P.SDK_INT).isEqualTo(28);
     assertThat(AndroidVersions.P.SHORT_CODE).isEqualTo("P");
-    assertThat(AndroidVersions.P.VERSION).isEqualTo("9.0");
+    assertThat(AndroidVersions.P.VERSION).isEqualTo("9");
     assertThat(new AndroidVersions.P().getSdkInt()).isEqualTo(28);
     assertThat(new AndroidVersions.P().getShortCode()).isEqualTo("P");
-    assertThat(new AndroidVersions.P().getVersion()).isEqualTo("9.0");
+    assertThat(new AndroidVersions.P().getVersion()).isEqualTo("9");
     assertThat(new AndroidVersions.P().isReleased()).isTrue();
   }
 
diff --git a/build.gradle.kts b/build.gradle.kts
index 12e1ab362..2ba7f59e9 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -26,6 +26,7 @@ plugins {
   alias(libs.plugins.robolectric.spotless)
   alias(libs.plugins.robolectric.javadoc)
   alias(libs.plugins.roborazzi) apply false
+  alias(libs.plugins.compose.compiler) apply false
 }
 
 allprojects {
@@ -184,13 +185,16 @@ fun prefetchSdk(
   println("Prefetching $coordinates...")
 
   // Prefetch into Maven local repo...
-  project.exec {
-    val mvnCommand =
-      "mvn -q dependency:get -DrepoUrl=https://maven.google.com " +
-        "-DgroupId=$groupId -DartifactId=$artifactId -Dversion=$version"
+  project.providers
+    .exec {
+      val mvnCommand =
+        "mvn -q dependency:get -DrepoUrl=https://maven.google.com " +
+          "-DgroupId=$groupId -DartifactId=$artifactId -Dversion=$version"
 
-    commandLine(mvnCommand.split(" "))
-  }
+      commandLine(mvnCommand.split(" "))
+    }
+    .result
+    .get()
 
   // Prefetch into Gradle local cache...
   val config = configurations.create("sdk$apiLevel")
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt
index d6f410c49..8467b8c04 100644
--- a/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt
+++ b/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt
@@ -65,6 +65,13 @@ class GradleManagedDevicePlugin : Plugin<Project> {
           systemImageSource = "aosp-atd"
         }
 
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi35DebugAndroidTest
+        localDevices.register(NAME_API_35) {
+          device = "Nexus One"
+          apiLevel = 35
+          systemImageSource = "aosp"
+        }
+
         // ./gradlew -Pandroid.sdk.channel=3 nexusOneIntegrationTestGroupDebugAndroidTest
         groups.register("nexusOneIntegrationTestGroup") {
           targetDevices.add(devices[NAME_API_29])
@@ -73,6 +80,7 @@ class GradleManagedDevicePlugin : Plugin<Project> {
           targetDevices.add(devices[NAME_API_32])
           targetDevices.add(devices[NAME_API_33])
           targetDevices.add(devices[NAME_API_34])
+          targetDevices.add(devices[NAME_API_35])
         }
       } // managedDevices
     } // testOptions
@@ -85,5 +93,6 @@ class GradleManagedDevicePlugin : Plugin<Project> {
     private const val NAME_API_32 = "nexusOneApi32"
     private const val NAME_API_33 = "nexusOneApi33"
     private const val NAME_API_34 = "nexusOneApi34"
+    private const val NAME_API_35 = "nexusOneApi35"
   }
 }
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt
index 33288df0a..d94394421 100644
--- a/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt
+++ b/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt
@@ -26,10 +26,6 @@ class RoboJavaModulePlugin : Plugin<Project> {
     if (!skipErrorProne) {
       project.pluginManager.apply("net.ltgt.errorprone")
       project.dependencies.add("errorprone", project.libs.findLibrary("error-prone-core").get())
-      project.dependencies.add(
-        "errorproneJavac",
-        project.libs.findLibrary("error-prone-javac").get(),
-      )
     }
 
     project.tasks.withType<JavaCompile>().configureEach {
diff --git a/errorprone/build.gradle.kts b/errorprone/build.gradle.kts
index ad3f3165f..6421663df 100644
--- a/errorprone/build.gradle.kts
+++ b/errorprone/build.gradle.kts
@@ -33,7 +33,6 @@ dependencies {
 
   // Testing dependencies
   testImplementation(libs.junit4)
-  testImplementation(libs.truth)
   testImplementation(libs.error.prone.test.helpers)
   testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
 }
diff --git a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheck.java b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheck.java
index 2784a7b95..a0bff17b3 100644
--- a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheck.java
+++ b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheck.java
@@ -17,9 +17,10 @@ import com.google.errorprone.bugpatterns.BugChecker.ClassTreeMatcher;
 import com.google.errorprone.fixes.Fix;
 import com.google.errorprone.fixes.SuggestedFix;
 import com.google.errorprone.matchers.Description;
-import com.google.errorprone.matchers.method.MethodMatchers.MethodNameMatcher;
+import com.google.errorprone.matchers.Matcher;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.source.tree.ClassTree;
+import com.sun.source.tree.ExpressionTree;
 import com.sun.source.tree.ImportTree;
 import com.sun.source.tree.MethodInvocationTree;
 import com.sun.source.tree.Tree;
@@ -31,6 +32,7 @@ import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import org.robolectric.annotation.Implements;
 
@@ -48,12 +50,12 @@ import org.robolectric.annotation.Implements;
     link = "http://robolectric.org/migrating/#deprecations",
     linkType = LinkType.CUSTOM)
 public class DeprecatedMethodsCheck extends BugChecker implements ClassTreeMatcher {
-  private final java.util.List<MethodInvocationMatcher> matchers =
+  private final List<MethodInvocationMatcher> matchers =
       Arrays.asList(
           // Matches calls to <code>ShadowApplication.getInstance()</code>.
           new MethodInvocationMatcher() {
             @Override
-            MethodNameMatcher matcher() {
+            Matcher<ExpressionTree> matcher() {
               return staticMethod()
                   .onClass(shadowName("org.robolectric.shadows.ShadowApplication"))
                   .named("getInstance");
@@ -102,7 +104,7 @@ public class DeprecatedMethodsCheck extends BugChecker implements ClassTreeMatch
               "org.robolectric.shadows.ShadowPopupMenu", "ShadowPopupMenu", "getLatestPopupMenu"));
 
   abstract static class MethodInvocationMatcher {
-    abstract MethodNameMatcher matcher();
+    abstract Matcher<ExpressionTree> matcher();
 
     abstract void replace(
         MethodInvocationTree tree,
@@ -227,7 +229,7 @@ public class DeprecatedMethodsCheck extends BugChecker implements ClassTreeMatch
     }
 
     @Override
-    MethodNameMatcher matcher() {
+    Matcher<ExpressionTree> matcher() {
       return instanceMethod()
           .onClass(isCastableTo(shadowName("org.robolectric.shadows.ShadowApplication")))
           .named(methodName);
diff --git a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java
index d467e0c58..37638890a 100644
--- a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java
+++ b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java
@@ -29,7 +29,7 @@ public class Helpers {
   public static boolean isInShadowClass(TreePath path, VisitorState state) {
     Tree leaf = path.getLeaf();
     JCClassDecl classDecl =
-        JCClassDecl.class.isInstance(leaf)
+        leaf instanceof JCClassDecl
             ? (JCClassDecl) leaf
             : findEnclosingNode(state.getPath(), JCClassDecl.class);
 
@@ -48,10 +48,6 @@ public class Helpers {
     @Override
     public boolean apply(Type type, VisitorState state) {
       Type bound = expected.get(state);
-      if (bound == null || type == null) {
-        // TODO(cushon): type suppliers are allowed to return null :(
-        return false;
-      }
       return ASTHelpers.isCastable(type, bound, state);
     }
   }
diff --git a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/RobolectricShadow.java b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/RobolectricShadow.java
index 7ec111108..0d2c8b8f9 100644
--- a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/RobolectricShadow.java
+++ b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/RobolectricShadow.java
@@ -59,7 +59,7 @@ public final class RobolectricShadow extends BugChecker implements ClassTreeMatc
   private static final Matcher<MethodTree> implementationMethodMatcher =
       hasAnnotation(Implementation.class);
 
-  private boolean doScanJavadoc = false;
+  private final boolean doScanJavadoc = false;
 
   @Override
   public Description matchClass(ClassTree classTree, VisitorState state) {
diff --git a/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheckTest.java b/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheckTest.java
index 490c5dbf8..c16139409 100644
--- a/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheckTest.java
+++ b/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/DeprecatedMethodsCheckTest.java
@@ -4,7 +4,6 @@ import static com.google.errorprone.BugPattern.SeverityLevel.WARNING;
 
 import com.google.errorprone.BugCheckerRefactoringTestHelper;
 import com.google.errorprone.BugPattern;
-import java.io.IOException;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -13,7 +12,7 @@ import org.junit.runners.JUnit4;
 
 /** Tests for {@link DeprecatedMethodsCheck} */
 @RunWith(JUnit4.class)
-@SuppressWarnings("LineLength")
+@SuppressWarnings("BugPatternNaming")
 public class DeprecatedMethodsCheckTest {
   private BugCheckerRefactoringTestHelper testHelper;
 
@@ -25,7 +24,7 @@ public class DeprecatedMethodsCheckTest {
   }
 
   @Test
-  public void replaceShadowApplicationGetInstance() throws IOException {
+  public void replaceShadowApplicationGetInstance() {
     testHelper
         .addInputLines(
             "in/SomeTest.java",
@@ -60,7 +59,7 @@ public class DeprecatedMethodsCheckTest {
   }
 
   @Test
-  public void replaceShadowApplicationGetLatestStuff() throws IOException {
+  public void replaceShadowApplicationGetLatestStuff() {
     testHelper
         .addInputLines(
             "in/SomeTest.java",
@@ -103,9 +102,9 @@ public class DeprecatedMethodsCheckTest {
         .doTest();
   }
 
+  @Ignore("This test fails in a bazel environment")
   @Test
-  @Ignore("multiple-step refactorings not currently supported")
-  public void inlineShadowVars() throws IOException {
+  public void inlineShadowVars() {
     testHelper
         .addInputLines(
             "in/SomeTest.java",
@@ -138,7 +137,7 @@ public class DeprecatedMethodsCheckTest {
   }
 
   @Test
-  public void useShadowsNonStaticIfAlreadyImported() throws IOException {
+  public void useShadowsNonStaticIfAlreadyImported() {
     testHelper
         .addInputLines(
             "in/SomeTest.java",
@@ -172,9 +171,9 @@ public class DeprecatedMethodsCheckTest {
         .doTest();
   }
 
+  @Ignore("This test fails in a bazel environment")
   @Test
-  @Ignore("multiple-step refactorings not currently supported")
-  public void useFrameworkMethodWhenAppropriateAfterApplicationSubstitution() throws IOException {
+  public void useFrameworkMethodWhenAppropriateAfterApplicationSubstitution() {
     testHelper
         .addInputLines(
             "in/SomeTest.java",
diff --git a/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java b/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java
index 430c195aa..445cee0a7 100644
--- a/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java
+++ b/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java
@@ -1,7 +1,6 @@
 package org.robolectric.errorprone.bugpatterns;
 
 import com.google.errorprone.BugCheckerRefactoringTestHelper;
-import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -21,7 +20,7 @@ public class RobolectricShadowTest {
   }
 
   @Test
-  public void implMethodsShouldBeProtected() throws IOException {
+  public void implMethodsShouldBeProtected() {
     testHelper
         .addInputLines(
             "in/SomeShadow.java",
@@ -55,7 +54,7 @@ public class RobolectricShadowTest {
   }
 
   @Test
-  public void implMethodsNotProtectedForClassesNotInAndroidSdk() throws IOException {
+  public void implMethodsNotProtectedForClassesNotInAndroidSdk() {
     testHelper
         .addInputLines(
             "in/SomeShadow.java",
@@ -89,7 +88,7 @@ public class RobolectricShadowTest {
   }
 
   @Test
-  public void implMethodJavadocShouldBeMarkdown() throws Exception {
+  public void implMethodJavadocShouldBeMarkdown() {
     testHelper
         .addInputLines(
             "in/SomeShadow.java",
diff --git a/errorprone/src/test/java/xxx/XShadowDrawable.java b/errorprone/src/test/java/xxx/XShadowDrawable.java
index 01af57362..ba6586c9e 100644
--- a/errorprone/src/test/java/xxx/XShadowDrawable.java
+++ b/errorprone/src/test/java/xxx/XShadowDrawable.java
@@ -3,7 +3,7 @@ package xxx;
 import android.graphics.drawable.Drawable;
 import org.robolectric.annotation.Implements;
 
-/** Fake shadow for testing {@link org.robolectric.errorprone.bugpatterns.ShadowUsageCheck}. */
+/** Fake shadow for testing {@link org.robolectric.errorprone.bugpatterns.RobolectricShadow}. */
 @Implements(Drawable.class)
 public class XShadowDrawable {
   public int getCreatedFromResId() {
diff --git a/errorprone/src/test/java/xxx/XShadowLinearLayout.java b/errorprone/src/test/java/xxx/XShadowLinearLayout.java
index 9b52fff25..c7d9f3e94 100644
--- a/errorprone/src/test/java/xxx/XShadowLinearLayout.java
+++ b/errorprone/src/test/java/xxx/XShadowLinearLayout.java
@@ -3,7 +3,7 @@ package xxx;
 import android.widget.LinearLayout;
 import org.robolectric.annotation.Implements;
 
-/** Fake shadow for testing {@link org.robolectric.errorprone.bugpatterns.ShadowUsageCheck}. */
+/** Fake shadow for testing {@link org.robolectric.errorprone.bugpatterns.RobolectricShadow}. */
 @Implements(LinearLayout.class)
 public class XShadowLinearLayout extends XShadowViewGroup {
   public int getGravity() {
diff --git a/errorprone/src/test/java/xxx/XShadowViewGroup.java b/errorprone/src/test/java/xxx/XShadowViewGroup.java
index 3c81e19a3..5e7ebee72 100644
--- a/errorprone/src/test/java/xxx/XShadowViewGroup.java
+++ b/errorprone/src/test/java/xxx/XShadowViewGroup.java
@@ -6,7 +6,7 @@ import android.view.animation.LayoutAnimationController;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-/** Fake shadow for testing {@link org.robolectric.errorprone.bugpatterns.ShadowUsageCheck}. */
+/** Fake shadow for testing {@link org.robolectric.errorprone.bugpatterns.RobolectricShadow}. */
 @Implements(ViewGroup.class)
 public class XShadowViewGroup {
   @Implementation
diff --git a/errorprone/src/test/java/xxx/XShadows.java b/errorprone/src/test/java/xxx/XShadows.java
index a62745ae7..6cdfaaaf6 100644
--- a/errorprone/src/test/java/xxx/XShadows.java
+++ b/errorprone/src/test/java/xxx/XShadows.java
@@ -15,7 +15,7 @@ import java.util.Map;
 
 /**
  * Fake {@link org.robolectric.internal.ShadowProvider} for testing {@link
- * org.robolectric.errorprone.bugpatterns.ShadowUsageCheck}.
+ * org.robolectric.errorprone.bugpatterns.RobolectricShadow}.
  */
 public class XShadows implements org.robolectric.internal.ShadowProvider {
   public static XShadowAlertDialog shadowOf(AlertDialog actual) {
diff --git a/gradle.properties b/gradle.properties
index 124dca9e4..336adaec1 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,4 +1,4 @@
-thisVersion=4.14-SNAPSHOT
+thisVersion=4.15-SNAPSHOT
 
 # This project uses AndroidX instead of Support Libraries
 # https://developer.android.com/jetpack/androidx/migrate#migrate_an_existing_project_using_android_studio
@@ -13,7 +13,13 @@ kotlin.stdlib.default.dependency=false
 org.gradle.caching=true
 
 # Increase Gradle's max memory due to OutOfMemoryException during compilation
+# https://docs.gradle.org/current/userguide/performance.html#increase_the_heap_size
 org.gradle.jvmargs=-Xmx2g
 
+# Enable Gradle's parallel execution
+# https://docs.gradle.org/current/userguide/performance.html#parallel_execution
+org.gradle.parallel=true
+
 # Give Kotlin's daemon 2g of memory
+# https://kotlinlang.org/docs/gradle-compilation-and-caches.html#kotlin-daemon-jvmargs-property
 kotlin.daemon.jvmargs=-Xmx2g
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 511e5ca26..e47f5a9bd 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -2,9 +2,9 @@
 robolectric-nativeruntime-dist-compat = "1.0.16"
 
 # https://developer.android.com/studio/releases
-android-gradle = "8.6.0"
+android-gradle = "8.7.2"
 
-android-tools-common = "31.6.0"
+android-tools-common = "31.7.2"
 
 # The runtime dependency for Android classes when Robolectric tests are run
 androidstubs = "34"
@@ -13,7 +13,7 @@ androidstubs = "34"
 conscrypt = "2.5.2"
 
 # https://github.com/bcgit/bc-java/tags
-bouncycastle = "1.78.1"
+bouncycastle = "1.79"
 
 # https://github.com/findbugsproject/findbugs/tags
 findbugs-jsr305 = "3.0.2"
@@ -22,20 +22,19 @@ findbugs-jsr305 = "3.0.2"
 hamcrest = "2.0.0.0"
 
 # https://github.com/google/error-prone/releases
-error-prone = "2.19.1"
-error-prone-javac = "9+181-r4173-1"
+error-prone = "2.36.0"
 
 # https://github.com/tbroyer/gradle-errorprone-plugin/releases
-error-prone-gradle = "3.1.0"
+error-prone-gradle = "4.1.0"
 
 # https://kotlinlang.org/docs/releases.html#release-details
-kotlin = "2.0.20"
+kotlin = "2.1.0"
 
 # https://github.com/Kotlin/kotlinx.coroutines/releases/
 kotlinx-coroutines = '1.9.0'
 
 # https://github.com/diffplug/spotless/blob/main/plugin-gradle/CHANGES.md
-spotless-gradle = "6.25.0"
+spotless-gradle = "7.0.0.BETA4"
 
 # https://detekt.dev/changelog
 detekt-gradle = "1.23.7"
@@ -45,7 +44,7 @@ apache-http-core = "4.0.1"
 apache-http-client = "4.0.3"
 
 # https://asm.ow2.io/versions.html
-asm = "9.7"
+asm = "9.7.1"
 
 # https://github.com/google/auto/releases
 auto-common = "1.2.2"
@@ -56,7 +55,7 @@ auto-value = "1.11.0"
 compile-testing = "0.21.0"
 
 # https://github.com/google/guava/releases
-guava-jre = "31.1-jre"
+guava-jre = "33.3.1-jre"
 
 # https://github.com/google/gson/releases
 gson = "2.11.0"
@@ -65,7 +64,7 @@ gson = "2.11.0"
 truth = "1.4.2"
 
 # https://github.com/unicode-org/icu/releases
-icu4j = "75.1"
+icu4j = "76.1"
 
 # https://www.eclemma.org/jacoco/
 jacoco = "0.8.11"
@@ -79,7 +78,7 @@ javax-inject = "1"
 junit4 = "4.13.2"
 
 # https://github.com/google/libphonenumber/releases
-libphonenumber = "8.13.46"
+libphonenumber = "8.13.51"
 
 # https://github.com/mockito/mockito/releases
 mockito = "4.11.0"
@@ -88,7 +87,7 @@ mockito = "4.11.0"
 mockk = "1.13.7"
 
 # https://github.com/takahirom/roborazzi/releases
-roborazzi = "1.26.0"
+roborazzi = "1.34.0"
 
 # https://square.github.io/okhttp/changelogs/changelog/
 okhttp = "4.12.0"
@@ -101,18 +100,15 @@ snakeyaml = "2.3"
 sqlite4java = "1.0.392"
 
 # https://developer.android.com/jetpack/androidx/versions
-androidx-annotation = "1.8.2"
+androidx-annotation = "1.9.1"
 androidx-appcompat = "1.7.0"
 androidx-biometric = "1.1.0"
-androidx-constraintlayout = "2.1.4"
-androidx-core = "1.13.1"
-androidx-fragment = "1.8.3"
-androidx-multidex = "2.0.1"
+androidx-constraintlayout = "2.2.0"
+androidx-core = "1.15.0"
+androidx-fragment = "1.8.5"
 androidx-window = "1.3.0"
 androidx-room = "2.6.1"
-
-# https://maven.google.com/web/index.html?q=multidex#com.android.support:multidex
-android-multidex = "1.0.3"
+androidx-recyclerview = "1.3.2"
 
 # https://github.com/android/android-test/tags
 androidx-test-core = "1.6.1"
@@ -123,6 +119,9 @@ androidx-test-monitor = "1.7.2"
 androidx-test-runner = "1.6.2"
 androidx-test-services = "1.5.0"
 
+# https://developer.android.com/jetpack/androidx/releases/compose
+androidx-compose-bom = "2024.11.00"
+
 # for shadows/playservices/build.gradle
 androidx-fragment-for-shadows = "1.2.0"
 play-services-for-shadows = "17.0.0"
@@ -159,7 +158,6 @@ error-prone-annotations = { module = "com.google.errorprone:error_prone_annotati
 error-prone-refaster = { module = "com.google.errorprone:error_prone_refaster", version.ref = "error-prone" }
 error-prone-check-api = { module = "com.google.errorprone:error_prone_check_api", version.ref = "error-prone" }
 error-prone-test-helpers = { module = "com.google.errorprone:error_prone_test_helpers", version.ref = "error-prone" }
-error-prone-javac = { module = "com.google.errorprone:javac", version.ref = "error-prone-javac" }
 
 conscrypt-openjdk-uber = { module = "org.conscrypt:conscrypt-openjdk-uber", version.ref = "conscrypt" }
 bcprov-jdk18on = { module = "org.bouncycastle:bcprov-jdk18on", version.ref = "bouncycastle" }
@@ -183,14 +181,13 @@ libphonenumber = { module = "com.googlecode.libphonenumber:libphonenumber", vers
 okhttp = { module = "com.squareup.okhttp3:okhttp" }
 okhttp-bom = { module = "com.squareup.okhttp3:okhttp-bom", version.ref = "okhttp" }
 
-powermock-module-junit4 = { module = "org.powermock:powermock-module-junit4", version.ref = "powermock" }
 powermock-module-junit4-rule = { module = "org.powermock:powermock-module-junit4-rule", version.ref = "powermock" }
 powermock-api-mockito2 = { module = "org.powermock:powermock-api-mockito2", version.ref = "powermock" }
 powermock-classloading-xstream = { module = "org.powermock:powermock-classloading-xstream", version.ref = "powermock" }
 
 robolectric-nativeruntime-dist-compat = { module = "org.robolectric:nativeruntime-dist-compat", version.ref = "robolectric-nativeruntime-dist-compat" }
 
-snakeyaml = {module = "org.yaml:snakeyaml", version.ref="snakeyaml" }
+snakeyaml = { module = "org.yaml:snakeyaml", version.ref = "snakeyaml" }
 
 sqlite4java = { module = "com.almworks.sqlite4java:sqlite4java", version.ref = "sqlite4java" }
 sqlite4java-osx = { module = "com.almworks.sqlite4java:libsqlite4java-osx", version.ref = "sqlite4java" }
@@ -215,10 +212,10 @@ androidx-constraintlayout = { module = "androidx.constraintlayout:constraintlayo
 androidx-core = { module = "androidx.core:core", version.ref = "androidx-core" }
 androidx-fragment = { module = "androidx.fragment:fragment", version.ref = "androidx-fragment" }
 androidx-fragment-testing = { module = "androidx.fragment:fragment-testing", version.ref = "androidx-fragment" }
-androidx-multidex = { module = "androidx.multidex:multidex", version.ref = "androidx-multidex" }
 androidx-window = { module = "androidx.window:window", version.ref = "androidx-window" }
 androidx-room-runtime = { module = "androidx.room:room-runtime", version.ref = "androidx-room" }
 androidx-room-compiler = { module = "androidx.room:room-compiler", version.ref = "androidx-room" }
+androidx-recyclerview = { module = "androidx.recyclerview:recyclerview", version.ref = "androidx-recyclerview" }
 
 androidx-test-core = { module = "androidx.test:core", version.ref = "androidx-test-core" }
 androidx-test-monitor = { module = "androidx.test:monitor", version.ref = "androidx-test-monitor" }
@@ -232,6 +229,13 @@ androidx-test-espresso-intents = { module = "androidx.test.espresso:espresso-int
 androidx-test-ext-junit = { module = "androidx.test.ext:junit", version.ref = "androidx-test-ext-junit" }
 androidx-test-ext-truth = { module = "androidx.test.ext:truth", version.ref = "androidx-test-ext-truth" }
 
+androidx-compose-bom = { module = "androidx.compose:compose-bom", version.ref = "androidx-compose-bom" }
+androidx-compose-ui = { module = "androidx.compose.ui:ui" }
+androidx-compose-ui-test-junit4 = { module = "androidx.compose.ui:ui-test-junit4" }
+androidx-compose-ui-test-manifest = { module = "androidx.compose.ui:ui-test-manifest" }
+androidx-compose-ui-tooling = { module = "androidx.compose.ui:ui-tooling" }
+androidx-compose-material3 = { module = "androidx.compose.material3:material3" }
+
 androidx-fragment-for-shadows = { module = "androidx.fragment:fragment", version.ref = "androidx-fragment-for-shadows" }
 play-services-auth-for-shadows = { module = "com.google.android.gms:play-services-auth", version.ref = "play-services-for-shadows" }
 play-services-base-for-shadows = { module = "com.google.android.gms:play-services-base", version.ref = "play-services-for-shadows" }
@@ -239,13 +243,11 @@ play-services-basement-for-shadows = { module = "com.google.android.gms:play-ser
 
 play-services-basement = { module = "com.google.android.gms:play-services-basement", version.ref = "play-services-basement" }
 
-android-multidex = { module = "com.android.support:multidex", version.ref = "android-multidex" }
-
 spotless = { module = "com.diffplug.spotless:spotless-plugin-gradle", version.ref = "spotless-gradle" }
 
 [bundles]
 play-services-for-shadows = ["androidx-fragment-for-shadows", "play-services-auth-for-shadows", "play-services-base-for-shadows", "play-services-basement-for-shadows"]
-powermock = ["powermock-module-junit4", "powermock-module-junit4-rule", "powermock-api-mockito2", "powermock-classloading-xstream"]
+powermock = ["powermock-module-junit4-rule", "powermock-api-mockito2", "powermock-classloading-xstream"]
 sqlite4java-native = ["sqlite4java-osx", "sqlite4java-linux-amd64", "sqlite4java-win32-x64", "sqlite4java-linux-i386", "sqlite4java-win32-x86"]
 
 [plugins]
@@ -258,6 +260,7 @@ jacoco = { id = "jacoco" }
 java = { id = "java" }
 kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
 kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
+compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
 robolectric-android-project = { id = "org.robolectric.gradle.AndroidProjectConfigPlugin" }
 robolectric-deployed-java-module = { id = "org.robolectric.gradle.DeployedRoboJavaModulePlugin" }
 robolectric-gradle-managed-device = { id = "org.robolectric.gradle.GradleManagedDevicePlugin" }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 0aaefbcaf..94113f200 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.1-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.11-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/integration_tests/agp/build.gradle.kts b/integration_tests/agp/build.gradle.kts
deleted file mode 100644
index 173340558..000000000
--- a/integration_tests/agp/build.gradle.kts
+++ /dev/null
@@ -1,33 +0,0 @@
-plugins {
-  alias(libs.plugins.android.library)
-  alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-  compileSdk = 34
-  namespace = "org.robolectric.integrationtests.agp"
-
-  defaultConfig { minSdk = 21 }
-
-  compileOptions {
-    sourceCompatibility = JavaVersion.VERSION_1_8
-    targetCompatibility = JavaVersion.VERSION_1_8
-  }
-
-  testOptions {
-    targetSdk = 34
-    unitTests.isIncludeAndroidResources = true
-  }
-}
-
-dependencies {
-  // Testing dependencies
-  testImplementation(project(":testapp"))
-  testImplementation(project(":robolectric"))
-  testImplementation(project(":integration_tests:agp:testsupport"))
-
-  testImplementation(libs.junit4)
-  testImplementation(libs.androidx.test.core)
-  testImplementation(libs.androidx.test.runner)
-  testImplementation(libs.androidx.test.ext.junit)
-}
diff --git a/integration_tests/agp/src/main/AndroidManifest.xml b/integration_tests/agp/src/main/AndroidManifest.xml
deleted file mode 100644
index e37688119..000000000
--- a/integration_tests/agp/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest>
-  <application />
-</manifest>
diff --git a/integration_tests/agp/src/test/java/org/robolectric/integrationtests/agp/TestActivityTest.java b/integration_tests/agp/src/test/java/org/robolectric/integrationtests/agp/TestActivityTest.java
deleted file mode 100644
index 16a33fcf8..000000000
--- a/integration_tests/agp/src/test/java/org/robolectric/integrationtests/agp/TestActivityTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.robolectric.integrationtests.agp;
-
-import androidx.test.core.app.ActivityScenario;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.integrationtests.agp.testsupport.TestActivity;
-
-/**
- * Test asserting that test-only activities can be declared in a dependency project's manifest as a
- * workaround for the fact that Android Gradle Plugin doesn't merge the test manifest (as of 3.4).
- *
- * <p>When http://issuetracker.google.com/issues/127986458 is fixed, we can collapse {@code
- * :integration_tests:agp:testsupport} back into {@code :integration_tests:agp}.
- */
-@RunWith(AndroidJUnit4.class)
-public class TestActivityTest {
-
-  @Test
-  public void testActivitiesCanBeDeclaredInADependencyLibrary() throws Exception {
-    ActivityScenario.launch(TestActivity.class);
-  }
-}
diff --git a/integration_tests/agp/testsupport/build.gradle.kts b/integration_tests/agp/testsupport/build.gradle.kts
deleted file mode 100644
index ff9790564..000000000
--- a/integration_tests/agp/testsupport/build.gradle.kts
+++ /dev/null
@@ -1,17 +0,0 @@
-plugins { alias(libs.plugins.android.library) }
-
-android {
-  compileSdk = 34
-  namespace = "org.robolectric.integrationtests.agp.testsupport"
-
-  defaultConfig { minSdk = 21 }
-
-  compileOptions {
-    sourceCompatibility = JavaVersion.VERSION_1_8
-    targetCompatibility = JavaVersion.VERSION_1_8
-  }
-
-  testOptions.targetSdk = 34
-}
-
-dependencies { api(project(":integration_tests:agp")) }
diff --git a/integration_tests/agp/testsupport/src/main/AndroidManifest.xml b/integration_tests/agp/testsupport/src/main/AndroidManifest.xml
deleted file mode 100644
index ec0ff6152..000000000
--- a/integration_tests/agp/testsupport/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android">
-  <application>
-    <activity android:name="TestActivity"/>
-  </application>
-</manifest>
diff --git a/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java b/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java
deleted file mode 100644
index 6a01201bc..000000000
--- a/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.robolectric.integrationtests.agp.testsupport;
-
-import android.app.Activity;
-
-/** Activity for use in unit tests. */
-public class TestActivity extends Activity {}
diff --git a/integration_tests/androidx/AndroidManifest.xml b/integration_tests/androidx/AndroidManifest.xml
index 2ea38fc5c..131436901 100644
--- a/integration_tests/androidx/AndroidManifest.xml
+++ b/integration_tests/androidx/AndroidManifest.xml
@@ -5,7 +5,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="org.robolectric.integrationtests.androidx">
   <uses-sdk
-      android:targetSdkVersion="34" />
+      android:targetSdkVersion="35" />
 
   <application />
 
diff --git a/integration_tests/androidx/build.gradle.kts b/integration_tests/androidx/build.gradle.kts
index 138dab3a5..7dade8722 100644
--- a/integration_tests/androidx/build.gradle.kts
+++ b/integration_tests/androidx/build.gradle.kts
@@ -4,7 +4,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integrationtests.androidx"
 
   defaultConfig { minSdk = 21 }
@@ -15,26 +15,23 @@ android {
   }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 }
 
 dependencies {
   implementation(libs.kotlinx.coroutines.android)
-  implementation(libs.androidx.appcompat)
   implementation(libs.androidx.window)
 
   // Testing dependencies
   testImplementation(project(":testapp"))
   testImplementation(project(":robolectric"))
   testImplementation(libs.junit4)
-  testImplementation(libs.androidx.test.core)
   testImplementation(libs.androidx.core)
-  testImplementation(libs.androidx.test.runner)
-  testImplementation(libs.androidx.test.rules)
-  testImplementation(libs.androidx.test.espresso.intents)
-  testImplementation(libs.androidx.test.ext.truth)
+  testImplementation(libs.androidx.recyclerview)
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.androidx.test.espresso.core)
   testImplementation(libs.androidx.test.ext.junit)
   testImplementation(libs.truth)
 }
diff --git a/integration_tests/androidx/src/main/AndroidManifest.xml b/integration_tests/androidx/src/main/AndroidManifest.xml
index 88f8432f2..4b219fbc6 100644
--- a/integration_tests/androidx/src/main/AndroidManifest.xml
+++ b/integration_tests/androidx/src/main/AndroidManifest.xml
@@ -2,9 +2,7 @@
 <!--
   Manifest for androidx integration test module
 -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+<manifest>
 
-    <application>
-    </application>
+    <application />
 </manifest>
-
diff --git a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java
index c998184a9..af2311637 100644
--- a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java
+++ b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java
@@ -49,6 +49,18 @@ public class BuildCompatTest {
     assertThat(BuildCompat.isAtLeastO()).isFalse();
   }
 
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.O_MR1)
+  public void isAtLeastOMR1() {
+    assertThat(BuildCompat.isAtLeastOMR1()).isTrue();
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.O)
+  public void isAtLeastOMR1_preOMR1() {
+    assertThat(BuildCompat.isAtLeastOMR1()).isFalse();
+  }
+
   @Test
   @Config(minSdk = Build.VERSION_CODES.P)
   public void isAtLeastP() {
@@ -78,4 +90,70 @@ public class BuildCompatTest {
   public void isAtLeastR() {
     assertThat(BuildCompat.isAtLeastR()).isTrue();
   }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.Q)
+  public void isAtLeastR_preR() {
+    assertThat(BuildCompat.isAtLeastR()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.S)
+  public void isAtLeastS() {
+    assertThat(BuildCompat.isAtLeastS()).isTrue();
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.R)
+  public void isAtLeastS_preS() {
+    assertThat(BuildCompat.isAtLeastS()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.S_V2)
+  public void isAtLeastSv2() {
+    assertThat(BuildCompat.isAtLeastSv2()).isTrue();
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.S)
+  public void isAtLeastSv2_preSv2() {
+    assertThat(BuildCompat.isAtLeastSv2()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.TIRAMISU)
+  public void isAtLeastT() {
+    assertThat(BuildCompat.isAtLeastT()).isTrue();
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.S_V2)
+  public void isAtLeastT_preT() {
+    assertThat(BuildCompat.isAtLeastT()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void isAtLeastU() {
+    assertThat(BuildCompat.isAtLeastU()).isTrue();
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.TIRAMISU)
+  public void isAtLeastU_preU() {
+    assertThat(BuildCompat.isAtLeastU()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.VANILLA_ICE_CREAM)
+  public void isAtLeastV() {
+    assertThat(BuildCompat.isAtLeastV()).isTrue();
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void isAtLeastV_preV() {
+    assertThat(BuildCompat.isAtLeastV()).isFalse();
+  }
 }
diff --git a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/RecyclerViewTest.java b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/RecyclerViewTest.java
new file mode 100644
index 000000000..8996a78c4
--- /dev/null
+++ b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/RecyclerViewTest.java
@@ -0,0 +1,77 @@
+package org.robolectric.integrationtests.androidx;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.Activity;
+import android.view.View;
+import android.view.ViewGroup;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+import androidx.recyclerview.widget.RecyclerView.LayoutManager;
+import androidx.test.espresso.Espresso;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public final class RecyclerViewTest {
+
+  @Test
+  public void smoothScrollBy() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+    RecyclerView recyclerView = new RecyclerView(activity);
+    LayoutManager layoutManager = new LinearLayoutManager(activity);
+    recyclerView.setLayoutManager(layoutManager);
+    ((ViewGroup) activity.findViewById(android.R.id.content)).addView(recyclerView);
+
+    // Set adapter with enough items to allow scrolling
+    recyclerView.setAdapter(new TestAdapter(50));
+
+    // Important: Measure and layout the RecyclerView
+    recyclerView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
+    recyclerView.layout(0, 0, 1000, 1000);
+
+    // Run_scrollBy
+    recyclerView.scrollBy(0, 10);
+    assertThat(recyclerView.computeVerticalScrollOffset()).isEqualTo(10);
+
+    // Run_smoothScrollBy
+    recyclerView.smoothScrollBy(0, 100);
+    Espresso.onIdle();
+    assertThat(recyclerView.computeVerticalScrollOffset()).isEqualTo(110);
+  }
+
+  private static class TestAdapter extends RecyclerView.Adapter<TestAdapter.ViewHolder> {
+    private final int itemCount;
+
+    TestAdapter(int itemCount) {
+      this.itemCount = itemCount;
+    }
+
+    @Override
+    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = new View(parent.getContext());
+      view.setLayoutParams(
+          new ViewGroup.LayoutParams(
+              ViewGroup.LayoutParams.MATCH_PARENT, 200)); // Fixed item height
+      return new ViewHolder(view);
+    }
+
+    @Override
+    public void onBindViewHolder(ViewHolder holder, int position) {
+      // No-op for this test
+    }
+
+    @Override
+    public int getItemCount() {
+      return itemCount;
+    }
+
+    static class ViewHolder extends RecyclerView.ViewHolder {
+      ViewHolder(View itemView) {
+        super(itemView);
+      }
+    }
+  }
+}
diff --git a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/WindowMetricsCalculatorTest.java b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/WindowMetricsCalculatorTest.java
index 03a7f02a3..612b08a61 100644
--- a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/WindowMetricsCalculatorTest.java
+++ b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/WindowMetricsCalculatorTest.java
@@ -2,12 +2,13 @@ package org.robolectric.integrationtests.androidx;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.graphics.Rect;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import androidx.window.layout.WindowMetrics;
 import androidx.window.layout.WindowMetricsCalculator;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.testapp.TestActivity;
 
@@ -17,11 +18,14 @@ public class WindowMetricsCalculatorTest {
   @Test
   @Config(qualifiers = "w400dp-h600dp")
   public void computeCurrentWindowMetrics() {
-    TestActivity activity = Robolectric.buildActivity(TestActivity.class).setup().get();
-    WindowMetrics windowMetrics =
-        WindowMetricsCalculator.getOrCreate().computeCurrentWindowMetrics(activity);
+    try (ActivityController<TestActivity> activityController =
+        Robolectric.buildActivity(TestActivity.class)) {
+      TestActivity activity = activityController.setup().get();
+      Rect bounds =
+          WindowMetricsCalculator.getOrCreate().computeCurrentWindowMetrics(activity).getBounds();
 
-    assertThat(windowMetrics.getBounds().width()).isEqualTo(400);
-    assertThat(windowMetrics.getBounds().height()).isEqualTo(600);
+      assertThat(bounds.width()).isEqualTo(400);
+      assertThat(bounds.height()).isEqualTo(600);
+    }
   }
 }
diff --git a/integration_tests/androidx_test/build.gradle.kts b/integration_tests/androidx_test/build.gradle.kts
index a9e52232e..e471955b0 100644
--- a/integration_tests/androidx_test/build.gradle.kts
+++ b/integration_tests/androidx_test/build.gradle.kts
@@ -5,7 +5,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integration.axt"
 
   defaultConfig {
@@ -21,7 +21,7 @@ android {
   }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 
@@ -49,7 +49,6 @@ dependencies {
 
   // Testing dependencies
   testImplementation(project(":robolectric"))
-  testImplementation(libs.androidx.test.runner)
   testImplementation(libs.junit4)
   testImplementation(libs.androidx.test.rules)
   testImplementation(libs.androidx.test.espresso.intents)
@@ -63,12 +62,9 @@ dependencies {
   testImplementation(libs.truth)
 
   androidTestImplementation(project(":annotations"))
-  androidTestImplementation(libs.androidx.test.runner)
   androidTestImplementation(libs.junit4)
   androidTestImplementation(libs.androidx.test.rules)
-  androidTestImplementation(libs.androidx.test.espresso.intents)
   androidTestImplementation(libs.androidx.test.espresso.core)
-  androidTestImplementation(libs.androidx.test.ext.truth)
   androidTestImplementation(libs.androidx.test.core)
   androidTestImplementation(libs.androidx.test.ext.junit)
   androidTestImplementation(platform(libs.kotlin.bom))
diff --git a/integration_tests/androidx_test/src/main/AndroidManifest-NoTestPackageActivities.xml b/integration_tests/androidx_test/src/main/AndroidManifest-NoTestPackageActivities.xml
index 0eb17b2cf..4fcd77d02 100644
--- a/integration_tests/androidx_test/src/main/AndroidManifest-NoTestPackageActivities.xml
+++ b/integration_tests/androidx_test/src/main/AndroidManifest-NoTestPackageActivities.xml
@@ -4,7 +4,7 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="org.robolectric.integration.axt">
-    <uses-sdk android:targetSdkVersion="34"/>
+    <uses-sdk android:targetSdkVersion="35"/>
 
     <uses-permission android:name="android.permission.READ_CONTACTS"/>
 
@@ -12,7 +12,12 @@
         <activity android:name="org.robolectric.integrationtests.axt.EspressoActivity"
                   android:label="Activity Label"
                   android:exported="true" />
+        <activity android:name="org.robolectric.integrationtests.axt.NoActionBarEspressoActivity"
+            android:label="Activity Label"
+            android:theme="@style/Theme.AppCompat.NoActionBar"
+            android:exported="true" />
         <activity android:name="org.robolectric.integrationtests.axt.EspressoScrollingActivity"
+            android:theme="@style/Theme.AppCompat.NoActionBar"
             android:exported="true" />
         <activity android:name="org.robolectric.integrationtests.axt.ActivityWithPlatformMenu"
             android:exported="true">
diff --git a/integration_tests/androidx_test/src/main/AndroidManifest.xml b/integration_tests/androidx_test/src/main/AndroidManifest.xml
index 6aac983cf..f1681a961 100644
--- a/integration_tests/androidx_test/src/main/AndroidManifest.xml
+++ b/integration_tests/androidx_test/src/main/AndroidManifest.xml
@@ -15,7 +15,17 @@
                 <category android:name="android.intent.category.DEFAULT" />
             </intent-filter>
         </activity>
+        <activity android:name="org.robolectric.integrationtests.axt.NoActionBarEspressoActivity"
+            android:label="Activity Label"
+            android:theme="@style/Theme.AppCompat.NoActionBar"
+            android:exported="true" >
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
         <activity android:name="org.robolectric.integrationtests.axt.EspressoScrollingActivity"
+            android:theme="@style/Theme.AppCompat.NoActionBar"
             android:exported="true" />
         <activity android:name="org.robolectric.integrationtests.axt.ActivityWithPlatformMenu"
             android:exported="true">
diff --git a/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithAppCompatMenu.java b/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithAppCompatMenu.java
index 8f17a77b5..2b623652c 100644
--- a/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithAppCompatMenu.java
+++ b/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithAppCompatMenu.java
@@ -4,6 +4,7 @@ import android.os.Bundle;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
+import androidx.annotation.NonNull;
 import androidx.appcompat.app.AppCompatActivity;
 import org.robolectric.integration.axt.R;
 
@@ -26,7 +27,7 @@ public class ActivityWithAppCompatMenu extends AppCompatActivity {
   }
 
   @Override
-  public boolean onOptionsItemSelected(MenuItem item) {
+  public boolean onOptionsItemSelected(@NonNull MenuItem item) {
     menuClicked = true;
     return true;
   }
diff --git a/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithPlatformMenu.java b/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithPlatformMenu.java
index b869d9e2c..3754bb2ef 100644
--- a/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithPlatformMenu.java
+++ b/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/ActivityWithPlatformMenu.java
@@ -5,6 +5,7 @@ import android.os.Bundle;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
+import androidx.annotation.NonNull;
 import org.robolectric.integration.axt.R;
 
 /** {@link EspressoWithMenuTest} fixture activity that uses Android platform menu's */
@@ -26,7 +27,7 @@ public class ActivityWithPlatformMenu extends Activity {
   }
 
   @Override
-  public boolean onOptionsItemSelected(MenuItem item) {
+  public boolean onOptionsItemSelected(@NonNull MenuItem item) {
     menuClicked = true;
     return true;
   }
diff --git a/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/NoActionBarEspressoActivity.java b/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/NoActionBarEspressoActivity.java
new file mode 100644
index 000000000..e61becd44
--- /dev/null
+++ b/integration_tests/androidx_test/src/main/java/org/robolectric/integrationtests/axt/NoActionBarEspressoActivity.java
@@ -0,0 +1,8 @@
+package org.robolectric.integrationtests.axt;
+
+/**
+ * The test {@link android.app.Activity} for Espresso testing but without action bar.
+ *
+ * <p>It is used for Espresso tests that don't want action bar affect its content.
+ */
+public class NoActionBarEspressoActivity extends EspressoActivity {}
diff --git a/integration_tests/androidx_test/src/main/res/layout/appcompat_activity_with_toolbar_menu.xml b/integration_tests/androidx_test/src/main/res/layout/appcompat_activity_with_toolbar_menu.xml
index c30507330..ffe983d13 100644
--- a/integration_tests/androidx_test/src/main/res/layout/appcompat_activity_with_toolbar_menu.xml
+++ b/integration_tests/androidx_test/src/main/res/layout/appcompat_activity_with_toolbar_menu.xml
@@ -1,5 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
-
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/layout"
     android:layout_width="match_parent"
diff --git a/integration_tests/androidx_test/src/main/res/layout/espresso_activity.xml b/integration_tests/androidx_test/src/main/res/layout/espresso_activity.xml
index 639ac1b11..4a73ee95b 100644
--- a/integration_tests/androidx_test/src/main/res/layout/espresso_activity.xml
+++ b/integration_tests/androidx_test/src/main/res/layout/espresso_activity.xml
@@ -1,5 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
-
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/layout"
     android:layout_width="wrap_content"
diff --git a/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml b/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml
index 43cf9617b..32d900b2a 100644
--- a/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml
+++ b/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml
@@ -5,7 +5,7 @@
 
   <uses-sdk
       android:minSdkVersion="21"
-      android:targetSdkVersion="34"/>
+      android:targetSdkVersion="35"/>
 
   <application>
     <activity android:name=".EspressoActivity" android:exported="true"/>
diff --git a/integration_tests/androidx_test/src/sharedTest/AndroidManifest.xml b/integration_tests/androidx_test/src/sharedTest/AndroidManifest.xml
index 5ba96949d..96730a9ae 100644
--- a/integration_tests/androidx_test/src/sharedTest/AndroidManifest.xml
+++ b/integration_tests/androidx_test/src/sharedTest/AndroidManifest.xml
@@ -11,8 +11,12 @@
     <activity
         android:name="org.robolectric.integrationtests.axt.EspressoActivity"
         android:exported="true"/>
+    <activity
+        android:name="org.robolectric.integrationtests.axt.NoActionBarEspressoActivity"
+        android:exported="true"/>
     <activity
         android:name="org.robolectric.integrationtests.axt.EspressoScrollingActivity"
+        android:theme="@style/Theme.AppCompat.NoActionBar"
         android:exported="true"/>
 
     <activity
@@ -34,6 +38,6 @@
 
   <instrumentation
       android:name="androidx.test.runner.AndroidJUnitRunner"
-      android:targetPackage="org.robolectric.integration.axt"/>
+      android:targetPackage="org.robolectric.integrationtests.axt"/>
 
 </manifest>
diff --git a/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoLabelTest.java b/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoLabelTest.java
new file mode 100644
index 000000000..6c2049dc0
--- /dev/null
+++ b/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoLabelTest.java
@@ -0,0 +1,25 @@
+package org.robolectric.integrationtests.axt;
+
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.ViewMatchers.isCompletelyDisplayed;
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
+
+import androidx.test.ext.junit.rules.ActivityScenarioRule;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test file for Espresso related to label. */
+@RunWith(AndroidJUnit4.class)
+public class EspressoLabelTest {
+  @Rule
+  public ActivityScenarioRule<EspressoActivity> activityRule =
+      new ActivityScenarioRule<>(EspressoActivity.class);
+
+  @Test
+  public void customActivityLabel() {
+    onView(withText("Activity Label")).check(matches(isCompletelyDisplayed()));
+  }
+}
diff --git a/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoScrollingTest.java b/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoScrollingTest.java
new file mode 100644
index 000000000..8d4dd2d76
--- /dev/null
+++ b/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoScrollingTest.java
@@ -0,0 +1,29 @@
+package org.robolectric.integrationtests.axt;
+
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.swipeUp;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.rules.ActivityScenarioRule;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.integration.axt.R;
+
+/** Test file for Espresso with scrolling logic. */
+@RunWith(AndroidJUnit4.class)
+public class EspressoScrollingTest {
+  @Rule
+  public ActivityScenarioRule<EspressoScrollingActivity> activityRule =
+      new ActivityScenarioRule<>(EspressoScrollingActivity.class);
+
+  @Test
+  public void clickButton_after_swipeUp() {
+    onView(withId(R.id.scroll_view)).perform(swipeUp());
+    onView(withId(R.id.button)).perform(click());
+    activityRule.getScenario().onActivity(action -> assertThat(action.buttonClicked).isTrue());
+  }
+}
diff --git a/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoTest.java b/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoTest.java
index 830e1ca66..c28780e68 100644
--- a/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoTest.java
+++ b/integration_tests/androidx_test/src/sharedTest/java/org/robolectric/integrationtests/axt/EspressoTest.java
@@ -4,7 +4,6 @@ import static androidx.test.espresso.Espresso.onView;
 import static androidx.test.espresso.action.ViewActions.click;
 import static androidx.test.espresso.action.ViewActions.closeSoftKeyboard;
 import static androidx.test.espresso.action.ViewActions.pressKey;
-import static androidx.test.espresso.action.ViewActions.swipeUp;
 import static androidx.test.espresso.action.ViewActions.typeText;
 import static androidx.test.espresso.action.ViewActions.typeTextIntoFocusedView;
 import static androidx.test.espresso.assertion.ViewAssertions.matches;
@@ -21,7 +20,6 @@ import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
 import androidx.test.annotation.UiThreadTest;
-import androidx.test.core.app.ActivityScenario;
 import androidx.test.espresso.Espresso;
 import androidx.test.ext.junit.rules.ActivityScenarioRule;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -39,8 +37,8 @@ import org.robolectric.integration.axt.R;
 public final class EspressoTest {
 
   @Rule
-  public ActivityScenarioRule<EspressoActivity> activityRule =
-      new ActivityScenarioRule<>(EspressoActivity.class);
+  public ActivityScenarioRule<NoActionBarEspressoActivity> activityRule =
+      new ActivityScenarioRule<>(NoActionBarEspressoActivity.class);
 
   @Test
   public void onIdle_doesnt_block() {
@@ -191,11 +189,6 @@ public final class EspressoTest {
             });
   }
 
-  @Test
-  public void customActivityLabel() {
-    onView(withText("Activity Label")).check(matches(isCompletelyDisplayed()));
-  }
-
   @Test
   public void changeText_withCloseSoftKeyboard() {
     // Type text and then press the button.
@@ -214,16 +207,6 @@ public final class EspressoTest {
     onView(withId(R.id.edit_text)).check(matches(withText("Some text.\nOther text.")));
   }
 
-  @Test
-  public void clickButton_after_swipeUp() {
-    try (ActivityScenario<EspressoScrollingActivity> activityScenario =
-        ActivityScenario.launch(EspressoScrollingActivity.class)) {
-      onView(withId(R.id.scroll_view)).perform(swipeUp());
-      onView(withId(R.id.button)).perform(click());
-      activityScenario.onActivity(action -> assertThat(action.buttonClicked).isTrue());
-    }
-  }
-
   @Test
   @LooperMode(Mode.INSTRUMENTATION_TEST) // only instrumentation test mode has the correct behavior
   public void onView_mainThread() {
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml
index a08c46165..a9478e41c 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml
@@ -5,7 +5,7 @@
 
   <uses-sdk
       android:minSdkVersion="21"
-      android:targetSdkVersion="34"/>
+      android:targetSdkVersion="35"/>
 
   <application
         android:appComponentFactory="org.robolectric.integrationtests.axt.ActivityScenarioTest$CustomAppComponentFactory">
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml
index 334fe3b2a..9e2b6adbc 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml
@@ -5,7 +5,7 @@
 
   <uses-sdk
       android:minSdkVersion="21"
-      android:targetSdkVersion="34"/>
+      android:targetSdkVersion="35"/>
 
   <application>
     <activity
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml b/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml
index 0f59ec4a8..084ddb8b1 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml
@@ -5,7 +5,7 @@
 
   <uses-sdk
       android:minSdkVersion="21"
-      android:targetSdkVersion="34"/>
+      android:targetSdkVersion="35"/>
 
   <application>
     <activity
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml b/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml
index 43cf9617b..5841edbff 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml
@@ -5,10 +5,11 @@
 
   <uses-sdk
       android:minSdkVersion="21"
-      android:targetSdkVersion="34"/>
+      android:targetSdkVersion="35"/>
 
   <application>
     <activity android:name=".EspressoActivity" android:exported="true"/>
+    <activity android:name=".NoActionBarEspressoActivity" android:exported="true"/>
   </application>
 
   <instrumentation
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java
index b4ddf9939..a3cabdf34 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java
@@ -12,8 +12,6 @@ import android.content.Intent;
 import android.content.res.Configuration;
 import android.os.Bundle;
 import android.os.Looper;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
 import androidx.appcompat.R;
 import androidx.appcompat.app.AppCompatActivity;
 import androidx.fragment.app.Fragment;
@@ -25,6 +23,8 @@ import androidx.test.platform.app.InstrumentationRegistry;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,6 +39,9 @@ public class ActivityScenarioTest {
 
   private static final List<String> callbacks = new ArrayList<>();
 
+  /**
+   * @noinspection NewClassNamingConvention
+   */
   public static class TranscriptActivity extends Activity {
 
     @Override
@@ -96,6 +99,9 @@ public class ActivityScenarioTest {
     }
   }
 
+  /**
+   * @noinspection NewClassNamingConvention
+   */
   public static class LifecycleOwnerActivity extends AppCompatActivity {
     @Override
     protected void onCreate(Bundle bundle) {
@@ -109,6 +115,9 @@ public class ActivityScenarioTest {
     callbacks.clear();
   }
 
+  /**
+   * @noinspection NewClassNamingConvention
+   */
   public static class ActivityWithCustomConstructor extends Activity {
     private final int intValue;
 
@@ -121,12 +130,15 @@ public class ActivityScenarioTest {
     }
   }
 
+  /**
+   * @noinspection NewClassNamingConvention
+   */
   public static class CustomAppComponentFactory extends AppComponentFactory {
 
-    @NonNull
+    @Nonnull
     @Override
     public Activity instantiateActivity(
-        @NonNull ClassLoader cl, @NonNull String className, @Nullable Intent intent)
+        @Nonnull ClassLoader cl, @Nonnull String className, @Nullable Intent intent)
         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
       if (className.contains(ActivityWithCustomConstructor.class.getName())) {
         return new ActivityWithCustomConstructor(100);
@@ -324,9 +336,8 @@ public class ActivityScenarioTest {
     try (ActivityScenario<TranscriptActivity> activityScenario =
         ActivityScenario.launch(TranscriptActivity.class)) {
       activityScenario.onActivity(
-          activity -> {
-            assertThat(Looper.getMainLooper().getThread()).isEqualTo(Thread.currentThread());
-          });
+          activity ->
+              assertThat(Looper.getMainLooper().getThread()).isEqualTo(Thread.currentThread()));
     }
   }
 
@@ -334,10 +345,7 @@ public class ActivityScenarioTest {
   public void getCallingActivity_empty() {
     try (ActivityScenario<TranscriptActivity> activityScenario =
         ActivityScenario.launch(TranscriptActivity.class)) {
-      activityScenario.onActivity(
-          activity -> {
-            assertThat(activity.getCallingActivity()).isNull();
-          });
+      activityScenario.onActivity(activity -> assertThat(activity.getCallingActivity()).isNull());
     }
   }
 
@@ -346,10 +354,9 @@ public class ActivityScenarioTest {
     try (ActivityScenario<TranscriptActivity> activityScenario =
         ActivityScenario.launchActivityForResult(TranscriptActivity.class)) {
       activityScenario.onActivity(
-          activity -> {
-            assertThat(activity.getCallingActivity().getPackageName())
-                .isEqualTo("org.robolectric.integrationtests.axt");
-          });
+          activity ->
+              assertThat(activity.getCallingActivity().getPackageName())
+                  .isEqualTo("org.robolectric.integrationtests.axt"));
     }
   }
 
@@ -359,10 +366,7 @@ public class ActivityScenarioTest {
     try (ActivityScenario<ActivityWithCustomConstructor> activityScenario =
         ActivityScenario.launch(ActivityWithCustomConstructor.class)) {
       assertThat(activityScenario.getState()).isEqualTo(State.RESUMED);
-      activityScenario.onActivity(
-          activity -> {
-            assertThat(activity.getIntValue()).isEqualTo(100);
-          });
+      activityScenario.onActivity(activity -> assertThat(activity.getIntValue()).isEqualTo(100));
     }
   }
 }
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java
index 736729775..268fc96ea 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java
@@ -47,6 +47,9 @@ public class ActivityTestRuleTest {
         }
       };
 
+  /**
+   * @noinspection NewClassNamingConvention
+   */
   public static class TranscriptActivity extends Activity {
     Bundle receivedBundle;
 
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/CryptoObjectTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/CryptoObjectTest.java
index 2ece12427..bd2eda628 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/CryptoObjectTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/CryptoObjectTest.java
@@ -2,13 +2,11 @@ package org.robolectric.integrationtests.axt;
 
 import static org.junit.Assert.fail;
 
-import androidx.annotation.NonNull;
 import androidx.biometric.BiometricPrompt;
 import androidx.biometric.BiometricPrompt.PromptInfo;
 import androidx.fragment.app.FragmentActivity;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.security.NoSuchAlgorithmException;
-import java.util.concurrent.Executor;
 import javax.crypto.Cipher;
 import javax.crypto.NoSuchPaddingException;
 import org.junit.Before;
@@ -33,22 +31,7 @@ public class CryptoObjectTest {
       throws NoSuchPaddingException, NoSuchAlgorithmException {
     BiometricPrompt biometricPrompt =
         new BiometricPrompt(
-            fragmentActivity,
-            new Executor() {
-              @Override
-              public void execute(Runnable command) {}
-            },
-            new BiometricPrompt.AuthenticationCallback() {
-              @Override
-              public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {}
-
-              @Override
-              public void onAuthenticationSucceeded(
-                  @NonNull BiometricPrompt.AuthenticationResult result) {}
-
-              @Override
-              public void onAuthenticationFailed() {}
-            });
+            fragmentActivity, command -> {}, new BiometricPrompt.AuthenticationCallback() {});
 
     PromptInfo promptInfo =
         new PromptInfo.Builder()
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoIdlingResourceTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoIdlingResourceTest.java
index 9e5428bf3..a6e97a23a 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoIdlingResourceTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoIdlingResourceTest.java
@@ -42,7 +42,7 @@ public final class EspressoIdlingResourceTest {
   }
 
   @Test
-  public void onIdle_idlingResourceIsIdle_doesntBlock() {
+  public void onIdle_idlingResourceIsIdle_doesNotBlock() {
     AtomicBoolean didCheckIdle = new AtomicBoolean();
     idlingRegistry.register(
         new NamedIdleResource("Test", /* isIdle= */ true) {
@@ -179,6 +179,9 @@ public final class EspressoIdlingResourceTest {
     }
   }
 
+  /**
+   * @noinspection NewClassNamingConvention
+   */
   private static class NamedIdleResource implements IdlingResource {
     final String name;
     final AtomicBoolean isIdle;
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithPausedLooperTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithPausedLooperTest.java
index 1a1bd0f31..613f251cd 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithPausedLooperTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithPausedLooperTest.java
@@ -28,7 +28,7 @@ public final class EspressoWithPausedLooperTest {
   public void launchActivity() {}
 
   @Test
-  public void onIdle_doesnt_block() {
+  public void onIdle_does_not_block() {
     Espresso.onIdle();
   }
 
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java
index a7606ce51..c4882920c 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java
@@ -19,7 +19,7 @@ import org.robolectric.integration.axt.R;
 public class EspressoWithSwitchCompatTest {
   @Test
   public void switchCompatTest() {
-    try (ActivityScenario<ActivityWithSwitchCompat> scenario =
+    try (ActivityScenario<ActivityWithSwitchCompat> ignored =
         ActivityScenario.launch(ActivityWithSwitchCompat.class)) {
       onView(withId(R.id.switch_compat_2)).check(matches(isCompletelyDisplayed())).perform(click());
     }
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/FragmentScenarioTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/FragmentScenarioTest.java
index 64c8fe001..1c7ca4eff 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/FragmentScenarioTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/FragmentScenarioTest.java
@@ -17,8 +17,10 @@ public class FragmentScenarioTest {
   @Test
   public void launchFragment() {
     final AtomicReference<Fragment> loadedFragment = new AtomicReference<>();
-    FragmentScenario.launch(Fragment.class).onFragment(loadedFragment::set);
-    assertThat(loadedFragment.get()).isNotNull();
+    try (FragmentScenario<Fragment> scenario = FragmentScenario.launch(Fragment.class)) {
+      scenario.onFragment(loadedFragment::set);
+      assertThat(loadedFragment.get()).isNotNull();
+    }
   }
 
   /**
@@ -30,7 +32,9 @@ public class FragmentScenarioTest {
   @Config(instrumentedPackages = "androidx.")
   public void launchFragmentInstrumented() {
     final AtomicReference<Fragment> loadedFragment = new AtomicReference<>();
-    FragmentScenario.launch(Fragment.class).onFragment(loadedFragment::set);
-    assertThat(loadedFragment.get()).isNotNull();
+    try (FragmentScenario<Fragment> scenario = FragmentScenario.launch(Fragment.class)) {
+      scenario.onFragment(loadedFragment::set);
+      assertThat(loadedFragment.get()).isNotNull();
+    }
   }
 }
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/IntentsTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/IntentsTest.java
index dd425dc89..09673d1d0 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/IntentsTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/IntentsTest.java
@@ -128,7 +128,11 @@ public class IntentsTest {
     assertThat(getIntents()).comparingElementsUsing(all(action(), data())).contains(expectedIntent);
   }
 
-  /** Activity that captures calls to {#onActivityResult() } */
+  /**
+   * Activity that captures calls to {@link Activity#onActivityResult(int, int, Intent)}
+   *
+   * @noinspection NewClassNamingConvention
+   */
   public static class ResultCapturingActivity extends Activity {
 
     private ActivityResult activityResult;
@@ -165,7 +169,11 @@ public class IntentsTest {
     }
   }
 
-  /** Dummy activity whose calls we intent to we're stubbing out. */
+  /**
+   * Dummy activity whose calls we intent to we're stubbing out.
+   *
+   * @noinspection NewClassNamingConvention
+   */
   public static class DummyActivity extends Activity {}
 
   @Test
@@ -173,17 +181,18 @@ public class IntentsTest {
     intending(hasComponent(hasClassName(DummyActivity.class.getName())))
         .respondWith(new ActivityResult(Activity.RESULT_OK, new Intent().putExtra("key", 123)));
 
-    ActivityScenario<ResultCapturingActivity> activityScenario =
-        ActivityScenario.launch(ResultCapturingActivity.class);
-
-    activityScenario.onActivity(
-        activity -> activity.startActivityForResult(new Intent(activity, DummyActivity.class), 0));
-
-    activityScenario.onActivity(
-        activity -> {
-          assertThat(activity.activityResult.getResultCode()).isEqualTo(Activity.RESULT_OK);
-          assertThat(activity.activityResult.getResultData()).extras().containsKey("key");
-        });
+    try (ActivityScenario<ResultCapturingActivity> activityScenario =
+        ActivityScenario.launch(ResultCapturingActivity.class)) {
+      activityScenario.onActivity(
+          activity ->
+              activity.startActivityForResult(new Intent(activity, DummyActivity.class), 0));
+
+      activityScenario.onActivity(
+          activity -> {
+            assertThat(activity.activityResult.getResultCode()).isEqualTo(Activity.RESULT_OK);
+            assertThat(activity.activityResult.getResultData()).extras().containsKey("key");
+          });
+    }
   }
 
   @Test
diff --git a/integration_tests/composeui/build.gradle.kts b/integration_tests/composeui/build.gradle.kts
new file mode 100644
index 000000000..e731f43d7
--- /dev/null
+++ b/integration_tests/composeui/build.gradle.kts
@@ -0,0 +1,49 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.compose.compiler)
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.android)
+  alias(libs.plugins.robolectric.android.project)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+android {
+  namespace = "org.robolectric.integrationtests.composeui"
+  compileSdk = 35
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_11
+    targetCompatibility = JavaVersion.VERSION_11
+  }
+
+  kotlinOptions { jvmTarget = "11" }
+
+  buildFeatures { compose = true }
+
+  testOptions {
+    targetSdk = 35
+    unitTests { isIncludeAndroidResources = true }
+  }
+
+  androidComponents {
+    beforeVariants(selector().all()) { variantBuilder ->
+      // composeui does not support AndroidTest now.
+      variantBuilder.enableAndroidTest = false
+    }
+  }
+}
+
+dependencies {
+  implementation(platform(libs.androidx.compose.bom))
+  implementation(libs.androidx.compose.ui)
+  implementation(libs.androidx.compose.material3)
+
+  debugImplementation(libs.androidx.compose.ui.tooling)
+  debugImplementation(libs.androidx.compose.ui.test.manifest)
+
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.androidx.compose.ui.test.junit4)
+}
diff --git a/integration_tests/composeui/src/main/AndroidManifest.xml b/integration_tests/composeui/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..568741e54
--- /dev/null
+++ b/integration_tests/composeui/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest />
\ No newline at end of file
diff --git a/integration_tests/composeui/src/main/res/font/my_font.ttf b/integration_tests/composeui/src/main/res/font/my_font.ttf
new file mode 100644
index 000000000..05c4d7ed3
--- /dev/null
+++ b/integration_tests/composeui/src/main/res/font/my_font.ttf
@@ -0,0 +1 @@
+myFontData
\ No newline at end of file
diff --git a/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt b/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt
new file mode 100644
index 000000000..1034332e4
--- /dev/null
+++ b/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt
@@ -0,0 +1,34 @@
+package org.robolectric.integrationtests.composeui
+
+import androidx.compose.material3.TextField
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.focus.FocusRequester
+import androidx.compose.ui.focus.focusRequester
+import androidx.compose.ui.test.junit4.createComposeRule
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class FocusRequesterTest {
+  @get:Rule val composeTestRule = createComposeRule()
+
+  /** Test for https://github.com/robolectric/robolectric/issues/9703 */
+  @Test
+  fun `check FocusRequester is initialized`() {
+    composeTestRule.setContent {
+      val focusRequester = rememberFocusRequester()
+
+      TextField(value = "", onValueChange = {}, modifier = Modifier.focusRequester(focusRequester))
+    }
+  }
+
+  @Composable
+  private fun rememberFocusRequester(): FocusRequester {
+    return remember { FocusRequester() }.apply { LaunchedEffect(this) { requestFocus() } }
+  }
+}
diff --git a/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FontTest.kt b/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FontTest.kt
new file mode 100644
index 000000000..f68567509
--- /dev/null
+++ b/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FontTest.kt
@@ -0,0 +1,24 @@
+package org.robolectric.integrationtests.composeui
+
+import androidx.compose.material3.Text
+import androidx.compose.ui.test.junit4.createComposeRule
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.Font
+import androidx.compose.ui.text.font.FontFamily
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+/** The test file for ComposeUI's Font compatibility with Robolectric. */
+@RunWith(RobolectricTestRunner::class)
+class FontTest {
+  @get:Rule val rule = createComposeRule()
+
+  @Test
+  fun `Set text with custom font and it works without crash`() {
+    rule.setContent {
+      Text(text = "Foo", style = TextStyle(fontFamily = FontFamily(Font(R.font.my_font))))
+    }
+  }
+}
diff --git a/integration_tests/ctesque/Android.bp b/integration_tests/ctesque/Android.bp
index 099286628..8c024ea54 100644
--- a/integration_tests/ctesque/Android.bp
+++ b/integration_tests/ctesque/Android.bp
@@ -28,7 +28,6 @@ android_robolectric_test {
         "truth",
         "guava",
     ],
-    upstream: true,
     java_resource_dirs: ["src/sharedTest/resources/android"],
     instrumentation_for: "GlobalRobolectricTestStub",
 
diff --git a/integration_tests/ctesque/AndroidManifest.xml b/integration_tests/ctesque/AndroidManifest.xml
index 846c6ad43..c9d196317 100644
--- a/integration_tests/ctesque/AndroidManifest.xml
+++ b/integration_tests/ctesque/AndroidManifest.xml
@@ -6,7 +6,7 @@
     package="org.robolectric.integrationtests.ctesque">
   <uses-sdk
       android:minSdkVersion="21"
-      android:targetSdkVersion="34" />
+      android:targetSdkVersion="35" />
 
   <application />
 
diff --git a/integration_tests/ctesque/build.gradle.kts b/integration_tests/ctesque/build.gradle.kts
index 7ef425532..88d885a44 100644
--- a/integration_tests/ctesque/build.gradle.kts
+++ b/integration_tests/ctesque/build.gradle.kts
@@ -5,7 +5,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integrationtests.ctesque"
 
   defaultConfig {
@@ -16,7 +16,7 @@ android {
   lint { abortOnError = false }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
index b903c6841..37f8a4193 100644
--- a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
@@ -1,6 +1,7 @@
 package android.app;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
 
 import android.Manifest;
 import android.accounts.Account;
@@ -883,6 +884,7 @@ public class ContextTest {
     EuiccManager applicationEuiccManager =
         (EuiccManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+    assumeTrue(applicationEuiccManager != null);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -912,6 +914,7 @@ public class ContextTest {
     EuiccManager applicationEuiccManager =
         (EuiccManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+    assumeTrue(applicationEuiccManager != null);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/DisplayManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/DisplayManagerTest.java
new file mode 100644
index 000000000..bfc1fbded
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/DisplayManagerTest.java
@@ -0,0 +1,76 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.hardware.display.DisplayManager;
+import android.view.Display;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Tests for {@link DisplayManager}. */
+@RunWith(AndroidJUnit4.class)
+public class DisplayManagerTest {
+
+  @Test
+  public void displayManager_applicationInstance_isNotSameAsActivityInstance() {
+    DisplayManager applicationDisplayManager =
+        (DisplayManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.DISPLAY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DisplayManager activityDisplayManager =
+                (DisplayManager) activity.getSystemService(Context.DISPLAY_SERVICE);
+            assertThat(applicationDisplayManager).isNotSameInstanceAs(activityDisplayManager);
+          });
+    }
+  }
+
+  @Test
+  public void displayManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DisplayManager activityDisplayManager =
+                (DisplayManager) activity.getSystemService(Context.DISPLAY_SERVICE);
+            DisplayManager anotherActivityDisplayManager =
+                (DisplayManager) activity.getSystemService(Context.DISPLAY_SERVICE);
+            assertThat(anotherActivityDisplayManager).isSameInstanceAs(activityDisplayManager);
+          });
+    }
+  }
+
+  @Test
+  public void displayManager_instance_retrievesSameDisplays() {
+    DisplayManager applicationDisplayManager =
+        (DisplayManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.DISPLAY_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DisplayManager activityDisplayManager =
+                (DisplayManager) activity.getSystemService(Context.DISPLAY_SERVICE);
+
+            Display[] applicationDisplays = applicationDisplayManager.getDisplays();
+            Display[] activityDisplays = activityDisplayManager.getDisplays();
+
+            assertThat(activityDisplays.length).isEqualTo(applicationDisplays.length);
+
+            for (int i = 0; i < applicationDisplays.length; i++) {
+              Display appDisplay = applicationDisplays[i];
+              Display actDisplay = activityDisplays[i];
+
+              assertThat(actDisplay.getDisplayId()).isEqualTo(appDisplay.getDisplayId());
+              assertThat(actDisplay.getWidth()).isEqualTo(appDisplay.getWidth());
+              assertThat(actDisplay.getHeight()).isEqualTo(appDisplay.getHeight());
+            }
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java b/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java
index feb40051a..2bf9dd62a 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java
@@ -3,11 +3,13 @@ package android.app;
 import static com.google.common.truth.Truth.assertThat;
 
 import android.content.res.Configuration;
+import android.os.SystemClock;
 import android.view.Display;
 import android.view.Surface;
 import androidx.test.core.app.ActivityScenario;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.platform.app.InstrumentationRegistry;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.internal.DoNotInstrument;
@@ -17,17 +19,26 @@ import org.robolectric.testapp.TestActivity;
 @DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class UiAutomationTest {
+  private static final long WAIT_TIMEOUT_MS = 20000;
+  private UiAutomation uiAutomation;
+
+  @Before
+  public void setUp() {
+    Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
+    uiAutomation = instrumentation.getUiAutomation();
+    // Unfreeze rotation before any test.
+    uiAutomation.setRotation(UiAutomation.ROTATION_UNFREEZE);
+  }
+
   @Test
   public void setRotation_freeze90_isLandscape() {
-    UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
-
     uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_90);
-
     try (ActivityScenario<? extends TestActivity> scenario =
         ActivityScenario.launch(TestActivity.class)) {
 
       scenario.onActivity(
           activity -> {
+            waitDisplayRotation(activity, Surface.ROTATION_90);
             Display display = activity.getWindowManager().getDefaultDisplay();
             Configuration configuration = activity.getResources().getConfiguration();
             assertThat(display.getRotation()).isEqualTo(Surface.ROTATION_90);
@@ -40,12 +51,12 @@ public class UiAutomationTest {
 
   @Test
   public void setRotation_freeze180_isPortrait() {
-    UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
     uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_180);
     try (ActivityScenario<? extends TestActivity> scenario =
         ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
+            waitDisplayRotation(activity, Surface.ROTATION_180);
             Display display = activity.getWindowManager().getDefaultDisplay();
             Configuration configuration = activity.getResources().getConfiguration();
             assertThat(display.getRotation()).isEqualTo(Surface.ROTATION_180);
@@ -55,4 +66,20 @@ public class UiAutomationTest {
           });
     }
   }
+
+  private static void waitDisplayRotation(Activity activity, int expectedRotation) {
+    long startMs = SystemClock.uptimeMillis();
+    Display display = activity.getWindowManager().getDefaultDisplay();
+    do {
+      if (display.getRotation() == expectedRotation) {
+        break;
+      }
+      try {
+        // Sleep 100ms to avoid unnecessary checking.
+        Thread.sleep(100);
+      } catch (InterruptedException e) {
+        // Do nothing
+      }
+    } while (SystemClock.uptimeMillis() - startMs <= UiAutomationTest.WAIT_TIMEOUT_MS);
+  }
 }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/drawable/DrawableTestUtils.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/drawable/DrawableTestUtils.java
new file mode 100644
index 000000000..4821fc9f4
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/drawable/DrawableTestUtils.java
@@ -0,0 +1,32 @@
+package android.graphics.drawable;
+
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.XmlResourceParser;
+import java.io.IOException;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+/**
+ * Partially copied from <a
+ * href="https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/src/android/graphics/drawable/cts/DrawableTestUtils.java">DrawableTestUtils</a>
+ */
+public class DrawableTestUtils {
+  public static XmlResourceParser getResourceParser(Resources res, int resId)
+      throws XmlPullParserException, IOException {
+    final XmlResourceParser parser = res.getXml(resId);
+    int type;
+    while ((type = parser.next()) != XmlPullParser.START_TAG
+        && type != XmlPullParser.END_DOCUMENT) {
+      // Empty loop
+    }
+    return parser;
+  }
+
+  public static void setResourcesDensity(Resources res, int densityDpi) {
+    final Configuration config = new Configuration();
+    config.setTo(res.getConfiguration());
+    config.densityDpi = densityDpi;
+    res.updateConfiguration(config, null);
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/drawable/GradientDrawableTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/drawable/GradientDrawableTest.java
new file mode 100644
index 000000000..9c0542732
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/drawable/GradientDrawableTest.java
@@ -0,0 +1,1143 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.drawable;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.content.res.Resources.Theme;
+import android.content.res.XmlResourceParser;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Insets;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable.ConstantState;
+import android.graphics.drawable.GradientDrawable.Orientation;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.util.Xml;
+import android.view.ContextThemeWrapper;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import androidx.test.filters.SmallTest;
+import androidx.test.platform.app.InstrumentationRegistry;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.testapp.R;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+/**
+ * Compatibility test for {@link GradientDrawable}.
+ *
+ * <p>Copied from <a
+ * href="https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/src/android/graphics/drawable/cts/GradientDrawableTest.java">GradientDrawableTest</a>
+ */
+@SmallTest
+@RunWith(AndroidJUnit4.class)
+public class GradientDrawableTest {
+  private Resources mResources;
+
+  @Before
+  public void setup() {
+    mResources = InstrumentationRegistry.getInstrumentation().getTargetContext().getResources();
+  }
+
+  @SuppressWarnings("CheckReturnValue")
+  @Test
+  public void testConstructor() {
+    int[] color = new int[] {1, 2, 3};
+
+    new GradientDrawable();
+    new GradientDrawable(GradientDrawable.Orientation.BL_TR, color);
+    new GradientDrawable(null, null);
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.M)
+  @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.M)
+  public void testGetOpacityPreO() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    assertEquals(
+        "Default opacity is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(Color.TRANSPARENT);
+    assertEquals(
+        "Color.TRANSPARENT is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(0x80FFFFFF);
+    assertEquals(
+        "0x80FFFFFF is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.TRANSPARENT});
+    assertEquals(
+        "{ RED, TRANSPARENT } is TRANSLUCENT",
+        PixelFormat.TRANSLUCENT,
+        gradientDrawable.getOpacity());
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.BLUE});
+    assertEquals(
+        "{ RED, BLUE } is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(Color.RED);
+    assertEquals("RED is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadius(10);
+    assertEquals(
+        "RED with corner radius is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadius(0);
+    assertEquals(
+        "RED with no corner radius is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadii(new float[] {2, 2, 0, 0, 0, 0, 0, 0});
+    assertEquals(
+        "RED with corner radii is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadii(null);
+    assertEquals(
+        "RED with no corner radii is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.O, maxSdk = Build.VERSION_CODES.O_MR1)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.O, maxSdkVersion = Build.VERSION_CODES.O_MR1)
+  public void testGetOpacityFromOToOMR1() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    assertEquals(
+        "Default opacity is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(Color.TRANSPARENT);
+    assertEquals(
+        "Color.TRANSPARENT is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(0x80FFFFFF);
+    assertEquals(
+        "0x80FFFFFF is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.TRANSPARENT});
+    assertEquals(
+        "{ RED, TRANSPARENT } is TRANSLUCENT",
+        PixelFormat.TRANSLUCENT,
+        gradientDrawable.getOpacity());
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.BLUE});
+    assertEquals("{ RED, BLUE } is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(Color.RED);
+    assertEquals("RED is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadius(10);
+    assertEquals(
+        "RED with corner radius is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadius(0);
+    assertEquals(
+        "RED with no corner radius is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadii(new float[] {2, 2, 0, 0, 0, 0, 0, 0});
+    assertEquals(
+        "RED with corner radii is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadii(null);
+    assertEquals(
+        "RED with no corner radii is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.P)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
+  public void testGetOpacityFromP() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    assertEquals(
+        "Default opacity is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(Color.TRANSPARENT);
+    assertEquals(
+        "Color.TRANSPARENT is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(0x80FFFFFF);
+    assertEquals(
+        "0x80FFFFFF is TRANSLUCENT", PixelFormat.TRANSLUCENT, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.TRANSPARENT});
+    assertEquals(
+        "{ RED, TRANSPARENT } is TRANSLUCENT",
+        PixelFormat.TRANSLUCENT,
+        gradientDrawable.getOpacity());
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.BLUE});
+    assertEquals("{ RED, BLUE } is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setColor(Color.RED);
+    assertEquals("RED is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadius(10);
+    assertEquals(
+        "RED with corner radius is TRANSLUCENT",
+        PixelFormat.TRANSLUCENT,
+        gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadius(0);
+    assertEquals(
+        "RED with no corner radius is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadii(new float[] {2, 2, 0, 0, 0, 0, 0, 0});
+    assertEquals(
+        "RED with corner radii is TRANSLUCENT",
+        PixelFormat.TRANSLUCENT,
+        gradientDrawable.getOpacity());
+
+    gradientDrawable.setCornerRadii(null);
+    assertEquals(
+        "RED with no corner radii is OPAQUE", PixelFormat.OPAQUE, gradientDrawable.getOpacity());
+  }
+
+  @Test
+  public void testSetOrientation() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    Orientation orientation;
+
+    orientation = Orientation.BL_TR;
+    gradientDrawable.setOrientation(orientation);
+    assertEquals(
+        "Orientation set/get are symmetric", orientation, gradientDrawable.getOrientation());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetCornerRadii() {
+    float[] radii = new float[] {1.0f, 2.0f, 3.0f};
+
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setCornerRadii(radii);
+
+    float[] radiiActual = gradientDrawable.getCornerRadii();
+    assertArrayEquals("Gradient radius set/get are symmetric", radii, radiiActual, 0);
+
+    ConstantState constantState = gradientDrawable.getConstantState();
+    assertNotNull(constantState);
+
+    // input null as param
+    gradientDrawable.setCornerRadii(null);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+      assertNull("Gradient radii is not null", gradientDrawable.getCornerRadii());
+    } else {
+      assertThrows(NullPointerException.class, gradientDrawable::getCornerRadii);
+    }
+  }
+
+  @Test
+  public void testSetCornerRadius() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+
+    gradientDrawable.setCornerRadius(2.5f);
+    gradientDrawable.setCornerRadius(-2.5f);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testGetCornerRadius() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setCornerRadius(5.5f);
+    assertEquals(5.5f, gradientDrawable.getCornerRadius(), 0);
+    float[] radii = new float[] {1.0f, 2.0f, 3.0f};
+    gradientDrawable.setCornerRadii(radii);
+    assertEquals(5.5f, gradientDrawable.getCornerRadius(), 0);
+    gradientDrawable.setShape(GradientDrawable.OVAL);
+    assertEquals(5.5f, gradientDrawable.getCornerRadius(), 0);
+    gradientDrawable.setCornerRadii(null);
+    assertEquals(0, gradientDrawable.getCornerRadius(), 0);
+  }
+
+  @Test
+  public void testSetStroke() {
+    helpTestSetStroke(2, Color.RED);
+    helpTestSetStroke(-2, Color.TRANSPARENT);
+    helpTestSetStroke(0, 0);
+  }
+
+  private void helpTestSetStroke(int width, int color) {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setStroke(width, color);
+    // TODO: Verify stroke properties.
+  }
+
+  @Test
+  public void testSetStroke_WidthGap() {
+    verifySetStroke_WidthGap(2, Color.RED, 3.4f, 5.5f);
+    verifySetStroke_WidthGap(-2, Color.TRANSPARENT, -3.4f, -5.5f);
+    verifySetStroke_WidthGap(0, 0, 0, 0.0f);
+  }
+
+  private void verifySetStroke_WidthGap(int width, int color, float dashWidth, float dashGap) {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setStroke(width, color, dashWidth, dashGap);
+    // TODO: Verify stroke properties.
+  }
+
+  @Test
+  public void testSetStrokeList() {
+    verifySetStrokeList(2, ColorStateList.valueOf(Color.RED));
+    verifySetStrokeList(-2, ColorStateList.valueOf(Color.TRANSPARENT));
+    verifySetStrokeList(0, null);
+  }
+
+  private void verifySetStrokeList(int width, ColorStateList colorList) {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setStroke(width, colorList);
+    // TODO: Verify stroke properties.
+  }
+
+  @Test
+  public void testSetStrokeList_WidthGap() {
+    verifySetStrokeList_WidthGap(2, ColorStateList.valueOf(Color.RED), 3.4f, 5.5f);
+    verifySetStrokeList_WidthGap(-2, ColorStateList.valueOf(Color.TRANSPARENT), -3.4f, -5.5f);
+    verifySetStrokeList_WidthGap(0, null, 0.0f, 0.0f);
+  }
+
+  private void verifySetStrokeList_WidthGap(
+      int width, ColorStateList colorList, float dashWidth, float dashGap) {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setStroke(width, colorList, dashWidth, dashGap);
+    // TODO: Verify stroke properties.
+  }
+
+  @Test
+  public void testSetSize() {
+    verifySetSize(6, 4);
+    verifySetSize(-30, -40);
+    verifySetSize(0, 0);
+    verifySetSize(Integer.MAX_VALUE, Integer.MIN_VALUE);
+  }
+
+  private void verifySetSize(int width, int height) {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setSize(width, height);
+    assertEquals(width, gradientDrawable.getIntrinsicWidth());
+    assertEquals(height, gradientDrawable.getIntrinsicHeight());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetShape() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    int shape;
+
+    shape = GradientDrawable.OVAL;
+    gradientDrawable.setShape(shape);
+    assertEquals("Gradient shape set/get are symmetric", shape, gradientDrawable.getShape());
+
+    shape = -1;
+    gradientDrawable.setShape(shape);
+    assertEquals(
+        "Invalid gradient shape set/get are symmetric", shape, gradientDrawable.getShape());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetGradientType() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    int gradientType;
+
+    gradientType = GradientDrawable.LINEAR_GRADIENT;
+    gradientDrawable.setGradientType(gradientType);
+    assertEquals(
+        "Gradient type set/get are symmetric", gradientType, gradientDrawable.getGradientType());
+
+    gradientType = -1;
+    gradientDrawable.setGradientType(gradientType);
+    assertEquals(
+        "Invalid gradient type set/get are symmetric",
+        gradientType,
+        gradientDrawable.getGradientType());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetGradientCenter() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    float centerX;
+    float centerY;
+
+    centerX = 0.5f;
+    centerY = 0.5f;
+    assertEquals(centerX, gradientDrawable.getGradientCenterX(), 0.01f);
+    assertEquals(centerY, gradientDrawable.getGradientCenterY(), 0.01f);
+
+    centerX = -0.5f;
+    centerY = -0.5f;
+    gradientDrawable.setGradientCenter(centerX, centerY);
+    assertEquals(centerX, gradientDrawable.getGradientCenterX(), 0.01f);
+    assertEquals(centerY, gradientDrawable.getGradientCenterY(), 0.01f);
+
+    centerX = 0.0f;
+    centerY = 0.0f;
+    gradientDrawable.setGradientCenter(centerX, centerY);
+    assertEquals(centerX, gradientDrawable.getGradientCenterX(), 0.01f);
+    assertEquals(centerY, gradientDrawable.getGradientCenterY(), 0.01f);
+  }
+
+  @Test
+  public void testSetGradientRadius() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+
+    gradientDrawable.setGradientRadius(3.6f);
+    gradientDrawable.setGradientRadius(-3.6f);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetUseLevel() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    boolean useLevel;
+
+    assertFalse("Default useLevel is false", gradientDrawable.getUseLevel());
+
+    useLevel = true;
+    gradientDrawable.setUseLevel(useLevel);
+    assertEquals(
+        "Gradient set/get useLevel is symmetric", useLevel, gradientDrawable.getUseLevel());
+
+    useLevel = false;
+    gradientDrawable.setUseLevel(useLevel);
+    assertEquals(
+        "Gradient set/get useLevel is symmetric", useLevel, gradientDrawable.getUseLevel());
+  }
+
+  @Test
+  public void testDraw() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    Canvas c = new Canvas();
+    gradientDrawable.draw(c);
+
+    // input null as param
+    gradientDrawable.draw(null);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetColor() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    int color;
+
+    color = Color.RED;
+    gradientDrawable.setColor(color);
+    assertEquals("Color was set to " + color, color, gradientDrawable.getColor().getDefaultColor());
+
+    color = Color.TRANSPARENT;
+    gradientDrawable.setColor(color);
+    assertEquals("Color was set to " + color, color, gradientDrawable.getColor().getDefaultColor());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetColors() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    int[] colors;
+
+    colors = new int[] {Color.RED};
+    gradientDrawable.setColors(colors);
+    assertArrayEquals(
+        "Color was set to " + Arrays.toString(colors), colors, gradientDrawable.getColors());
+
+    colors = null;
+    gradientDrawable.setColors(colors);
+    assertArrayEquals(
+        "Color was set to " + Arrays.toString(colors), colors, gradientDrawable.getColors());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testSetColorList() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    ColorStateList color;
+
+    color = ColorStateList.valueOf(Color.RED);
+    gradientDrawable.setColor(color);
+    assertEquals("Color was set to RED", color, gradientDrawable.getColor());
+
+    gradientDrawable.setColor(null);
+
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+      assertEquals(
+          "Color was set to null (TRANSPARENT)",
+          ColorStateList.valueOf(Color.TRANSPARENT),
+          gradientDrawable.getColor());
+    } else {
+      assertNull("Color was set to null", gradientDrawable.getColor());
+    }
+  }
+
+  @Test
+  public void testGetChangingConfigurations() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    assertEquals(0, gradientDrawable.getChangingConfigurations());
+
+    gradientDrawable.setChangingConfigurations(10);
+    assertEquals(10, gradientDrawable.getChangingConfigurations());
+
+    gradientDrawable.setChangingConfigurations(-20);
+    assertEquals(-20, gradientDrawable.getChangingConfigurations());
+  }
+
+  @Test
+  public void testSetAlpha() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+
+    gradientDrawable.setAlpha(1);
+    gradientDrawable.setAlpha(-1);
+  }
+
+  @Test
+  public void testSetDither() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+
+    gradientDrawable.setDither(true);
+    gradientDrawable.setDither(false);
+  }
+
+  @Test
+  public void testSetColorFilter() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    ColorFilter cf = new ColorFilter();
+    gradientDrawable.setColorFilter(cf);
+
+    // input null as param
+    gradientDrawable.setColorFilter(null);
+  }
+
+  @Test
+  public void testInflate() throws XmlPullParserException, IOException {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    Rect rect = new Rect();
+    assertFalse(gradientDrawable.getPadding(rect));
+    assertEquals(0, rect.left);
+    assertEquals(0, rect.top);
+    assertEquals(0, rect.right);
+    assertEquals(0, rect.bottom);
+
+    XmlPullParser parser = mResources.getXml(R.drawable.gradientdrawable);
+    AttributeSet attrs = Xml.asAttributeSet(parser);
+
+    // find the START_TAG
+    int type;
+    while ((type = parser.next()) != XmlPullParser.START_TAG
+        && type != XmlPullParser.END_DOCUMENT) {
+      // Empty loop
+    }
+    assertEquals(XmlPullParser.START_TAG, type);
+
+    // padding is set in gradientdrawable.xml
+    gradientDrawable.inflate(mResources, parser, attrs);
+    assertTrue(gradientDrawable.getPadding(rect));
+    assertEquals(4, rect.left);
+    assertEquals(2, rect.top);
+    assertEquals(6, rect.right);
+    assertEquals(10, rect.bottom);
+
+    try {
+      gradientDrawable.getPadding(null);
+      fail("did not throw NullPointerException when rect is null.");
+    } catch (NullPointerException e) {
+      // expected, test success
+    }
+
+    try {
+      gradientDrawable.inflate(null, null, null);
+      fail("did not throw NullPointerException when parameters are null.");
+    } catch (NullPointerException e) {
+      // expected, test success
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testGradientPadding() {
+    GradientDrawable drawable = new GradientDrawable();
+    drawable.setPadding(1, 2, 3, 4);
+
+    Rect padding = new Rect();
+    drawable.getPadding(padding);
+
+    assertEquals(1, padding.left);
+    assertEquals(2, padding.top);
+    assertEquals(3, padding.right);
+    assertEquals(4, padding.bottom);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testGradientThickness() {
+    GradientDrawable drawable = new GradientDrawable();
+    int thickness = 17;
+
+    drawable.setThickness(thickness);
+    assertEquals(thickness, drawable.getThickness());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testNegativeGradientThickness() {
+    try {
+      new GradientDrawable().setThicknessRatio(-1);
+      fail("Did not throw IllegalArgumentException with negative thickness ratio");
+    } catch (IllegalArgumentException e) {
+      // expected, test success
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testZeroGradientThickness() {
+    try {
+      new GradientDrawable().setThicknessRatio(0);
+      fail("Did not throw IllegalArgumentException with zero thickness ratio");
+    } catch (IllegalArgumentException e) {
+      // expected, test success
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testGradientThicknessRatio() {
+    GradientDrawable drawable = new GradientDrawable();
+
+    float thicknessRatio = 3.9f;
+
+    drawable.setThicknessRatio(thicknessRatio);
+    assertEquals(0, Float.compare(thicknessRatio, drawable.getThicknessRatio()));
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testGradientInnerRadius() {
+    GradientDrawable drawable = new GradientDrawable();
+    int innerRadius = 12;
+    drawable.setInnerRadius(innerRadius);
+
+    assertEquals(innerRadius, drawable.getInnerRadius());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testNegativeInnerRadiusRatio() {
+    try {
+      new GradientDrawable().setInnerRadiusRatio(-1);
+      fail("Did not throw IllegalArgumentException with negative thickness ratio");
+    } catch (IllegalArgumentException e) {
+      // expected, test success
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testZeroInnerRadiusRatio() {
+    try {
+      new GradientDrawable().setInnerRadiusRatio(0);
+      fail("Did not throw IllegalArgumentException with zero thickness ratio");
+    } catch (IllegalArgumentException e) {
+      // expected, test success
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testGradientInnerRadiusRatio() {
+    GradientDrawable drawable = new GradientDrawable();
+    float innerRadiusRatio = 3.8f;
+    drawable.setInnerRadiusRatio(innerRadiusRatio);
+
+    assertEquals(0, Float.compare(innerRadiusRatio, drawable.getInnerRadiusRatio()));
+  }
+
+  @Test
+  public void testGradientPositions() throws XmlPullParserException, IOException {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    XmlPullParser parser = mResources.getXml(R.drawable.gradientdrawable);
+    AttributeSet attrs = Xml.asAttributeSet(parser);
+
+    // find the START_TAG
+    int type;
+    while ((type = parser.next()) != XmlPullParser.START_TAG
+        && type != XmlPullParser.END_DOCUMENT) {
+      // Empty loop
+    }
+    assertEquals(XmlPullParser.START_TAG, type);
+
+    // padding is set in gradientdrawable.xml
+    gradientDrawable.inflate(mResources, parser, attrs);
+
+    gradientDrawable.setColors(new int[] {Color.RED, Color.BLUE});
+
+    Canvas canvas = new Canvas(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+
+    gradientDrawable.setBounds(0, 0, 100, 100);
+    // Verify that calling draw does not crash
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+      gradientDrawable.draw(canvas);
+    } else {
+      assertThrows(IllegalArgumentException.class, () -> gradientDrawable.draw(canvas));
+    }
+  }
+
+  @Test
+  public void testInflateGradientRadius() {
+    Rect parentBounds = new Rect(0, 0, 100, 100);
+
+    GradientDrawable gradientDrawable;
+    float radius;
+
+    gradientDrawable =
+        (GradientDrawable) mResources.getDrawable(R.drawable.gradientdrawable_radius_base);
+    gradientDrawable.setBounds(parentBounds);
+    radius = gradientDrawable.getGradientRadius();
+    assertEquals(25.0f, radius, 0.0f);
+
+    gradientDrawable =
+        (GradientDrawable) mResources.getDrawable(R.drawable.gradientdrawable_radius_parent);
+    gradientDrawable.setBounds(parentBounds);
+    radius = gradientDrawable.getGradientRadius();
+    assertEquals(50.0f, radius, 0.0f);
+  }
+
+  @Test
+  public void testGetIntrinsicWidth() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setSize(6, 4);
+    assertEquals(6, gradientDrawable.getIntrinsicWidth());
+
+    gradientDrawable.setSize(-10, -20);
+    assertEquals(-10, gradientDrawable.getIntrinsicWidth());
+  }
+
+  @Test
+  public void testGetIntrinsicHeight() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    gradientDrawable.setSize(5, 3);
+    assertEquals(3, gradientDrawable.getIntrinsicHeight());
+
+    gradientDrawable.setSize(-5, -15);
+    assertEquals(-15, gradientDrawable.getIntrinsicHeight());
+  }
+
+  @Test
+  public void testGetConstantState() {
+    GradientDrawable gradientDrawable = new GradientDrawable();
+    assertNotNull(gradientDrawable.getConstantState());
+  }
+
+  @Test
+  public void testMutate() {
+    GradientDrawable d1 = (GradientDrawable) mResources.getDrawable(R.drawable.gradientdrawable);
+    GradientDrawable d2 = (GradientDrawable) mResources.getDrawable(R.drawable.gradientdrawable);
+    GradientDrawable d3 = (GradientDrawable) mResources.getDrawable(R.drawable.gradientdrawable);
+
+    d1.setSize(10, 10);
+    assertEquals(10, d1.getIntrinsicHeight());
+    assertEquals(10, d1.getIntrinsicWidth());
+    assertEquals(10, d2.getIntrinsicHeight());
+    assertEquals(10, d2.getIntrinsicWidth());
+    assertEquals(10, d3.getIntrinsicHeight());
+    assertEquals(10, d3.getIntrinsicWidth());
+
+    d1.mutate();
+    d1.setSize(20, 30);
+    assertEquals(30, d1.getIntrinsicHeight());
+    assertEquals(20, d1.getIntrinsicWidth());
+    assertEquals(10, d2.getIntrinsicHeight());
+    assertEquals(10, d2.getIntrinsicWidth());
+    assertEquals(10, d3.getIntrinsicHeight());
+    assertEquals(10, d3.getIntrinsicWidth());
+
+    d2.setSize(40, 50);
+    assertEquals(30, d1.getIntrinsicHeight());
+    assertEquals(20, d1.getIntrinsicWidth());
+    assertEquals(50, d2.getIntrinsicHeight());
+    assertEquals(40, d2.getIntrinsicWidth());
+    assertEquals(50, d3.getIntrinsicHeight());
+    assertEquals(40, d3.getIntrinsicWidth());
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testPreloadDensity() throws XmlPullParserException, IOException {
+    final int densityDpi = mResources.getConfiguration().densityDpi;
+    try {
+      DrawableTestUtils.setResourcesDensity(mResources, densityDpi);
+      verifyPreloadDensityInner(mResources, densityDpi);
+    } finally {
+      DrawableTestUtils.setResourcesDensity(mResources, densityDpi);
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testPreloadDensity_tvdpi() throws XmlPullParserException, IOException {
+    final int densityDpi = mResources.getConfiguration().densityDpi;
+    try {
+      DrawableTestUtils.setResourcesDensity(mResources, 213);
+      verifyPreloadDensityInner(mResources, 213);
+    } finally {
+      DrawableTestUtils.setResourcesDensity(mResources, densityDpi);
+    }
+  }
+
+  @Test
+  public void testOpticalInsetsPreQ() {
+    GradientDrawable drawable =
+        (GradientDrawable) mResources.getDrawable(R.drawable.gradientdrawable);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+      assertEquals(Insets.of(1, 2, 3, 4), drawable.getOpticalInsets());
+    } else {
+      assertEquals(Insets.of(0, 0, 0, 0), drawable.getOpticalInsets());
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testInflationWithThemeAndNonThemeResources() {
+    final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    final Theme theme = context.getResources().newTheme();
+    theme.applyStyle(R.style.Theme_MixedGradientTheme, true);
+    final Theme ctxTheme = context.getTheme();
+    ctxTheme.setTo(theme);
+
+    GradientDrawable drawable =
+        (GradientDrawable) ctxTheme.getDrawable(R.drawable.gradientdrawable_mix_theme);
+
+    Bitmap bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bitmap);
+    drawable.setBounds(0, 0, 10, 10);
+    drawable.draw(canvas);
+    int[] colors = drawable.getColors();
+    assertEquals(3, colors.length);
+    assertEquals(0, colors[0]);
+    assertEquals(context.getColor(R.color.colorPrimary), colors[1]);
+    assertEquals(context.getColor(R.color.colorPrimaryDark), colors[2]);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testGradientColorInflationWithThemeAndNonThemeResources() {
+    final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    final Theme theme = context.getResources().newTheme();
+    theme.applyStyle(R.style.Theme_MixedGradientTheme, true);
+    final Theme ctxTheme = context.getTheme();
+    ctxTheme.setTo(theme);
+
+    GradientDrawable drawable =
+        (GradientDrawable) ctxTheme.getDrawable(R.drawable.gradientdrawable_color_mix_theme);
+
+    int[] colors = drawable.getColors();
+    drawable.setColors(colors);
+
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      assertEquals(3, colors.length);
+      assertEquals(context.getColor(R.color.colorAccent), colors[0]);
+      assertEquals(context.getColor(R.color.colorPrimary), colors[1]);
+      assertEquals(context.getColor(R.color.colorPrimaryDark), colors[2]);
+    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+      assertEquals(3, colors.length);
+      assertEquals(context.getColor(R.color.colorAccent), colors[0]);
+      assertEquals(-65281, colors[1]);
+      assertEquals(context.getColor(R.color.colorPrimaryDark), colors[2]);
+    } else {
+      assertEquals(2, colors.length);
+      assertEquals(context.getColor(R.color.colorAccent), colors[0]);
+      assertEquals(context.getColor(R.color.colorPrimaryDark), colors[1]);
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testGradientColorInflationWithAllThemeResources() {
+    final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    final Theme theme = context.getResources().newTheme();
+    theme.applyStyle(R.style.Theme_MixedGradientTheme, true);
+    final Theme ctxTheme = context.getTheme();
+    ctxTheme.setTo(theme);
+
+    GradientDrawable drawable =
+        (GradientDrawable) ctxTheme.getDrawable(R.drawable.gradientdrawable_color_all_theme);
+
+    int[] colors = drawable.getColors();
+    drawable.setColors(colors);
+    assertEquals(3, colors.length);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      assertEquals(context.getColor(R.color.colorPrimary), colors[0]);
+      assertEquals(context.getColor(R.color.colorPrimaryDark), colors[1]);
+      assertEquals(context.getColor(R.color.colorPrimaryDark), colors[2]);
+    } else {
+      assertEquals(3, colors.length);
+      assertEquals(-65281, colors[0]);
+      assertEquals(-65281, colors[1]);
+      assertEquals(-65281, colors[2]);
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.N)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  public void testGradientColorNoCenterColorInflationWithThemeAndNonThemeResources() {
+    final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    final Theme theme = context.getResources().newTheme();
+    theme.applyStyle(R.style.Theme_MixedGradientTheme, true);
+    final Theme ctxTheme = context.getTheme();
+    ctxTheme.setTo(theme);
+
+    GradientDrawable drawable =
+        (GradientDrawable)
+            ctxTheme.getDrawable(R.drawable.gradientdrawable_no_center_color_all_theme);
+
+    int[] colors = drawable.getColors();
+    drawable.setColors(colors);
+    assertEquals(2, colors.length);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      assertEquals(context.getColor(R.color.colorPrimary), colors[0]);
+      assertEquals(context.getColor(R.color.colorPrimaryDark), colors[1]);
+    } else {
+      assertEquals(-65281, colors[0]);
+      assertEquals(-65281, colors[1]);
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testRadialInflationWithThemeAndNonThemeResources() {
+    final Context context =
+        new ContextThemeWrapper(
+            InstrumentationRegistry.getInstrumentation().getTargetContext(),
+            R.style.Theme_MixedGradientTheme);
+
+    GradientDrawable drawable =
+        (GradientDrawable) context.getDrawable(R.drawable.gradientdrawable_mix_theme);
+
+    // Verify that despite multiple inflation passes are done to inflate both
+    // the non-theme attributes as well as the themed attributes
+    assertEquals(GradientDrawable.RADIAL_GRADIENT, drawable.getGradientType());
+    assertEquals(87.0f, drawable.getGradientRadius(), 0.0f);
+  }
+
+  @Test
+  public void testRadialGradientWithInvalidRadius() {
+    final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    GradientDrawable radiusDrawable =
+        (GradientDrawable) context.getDrawable(R.drawable.gradientdrawable_invalid_radius);
+
+    Bitmap bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bitmap);
+
+    try {
+      radiusDrawable.setBounds(0, 0, 10, 10);
+      radiusDrawable.draw(canvas);
+    } catch (Exception e) {
+      if (Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP) {
+        assertTrue(e instanceof IllegalArgumentException);
+        assertEquals("radius must be > 0", e.getMessage());
+      } else {
+        fail("Threw exception: " + e + " with negative radius");
+      }
+    }
+  }
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.P)
+  @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.P)
+  public void testGradientNegativeAnglePreQ() {
+    verifyGradientOrientation(R.drawable.gradientdrawable_negative_angle, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_45, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_90, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_135, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_180, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_225, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_270, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_315, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_360, Orientation.LEFT_RIGHT);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.Q)
+  public void testGradientNegativeAngleFromQ() {
+    verifyGradientOrientation(R.drawable.gradientdrawable_negative_angle, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(R.drawable.gradientdrawable_negative_angle_45, Orientation.TL_BR);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_90, Orientation.TOP_BOTTOM);
+    verifyGradientOrientation(R.drawable.gradientdrawable_negative_angle_135, Orientation.TR_BL);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_180, Orientation.RIGHT_LEFT);
+    verifyGradientOrientation(R.drawable.gradientdrawable_negative_angle_225, Orientation.BR_TL);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_270, Orientation.BOTTOM_TOP);
+    verifyGradientOrientation(R.drawable.gradientdrawable_negative_angle_315, Orientation.BL_TR);
+    verifyGradientOrientation(
+        R.drawable.gradientdrawable_negative_angle_360, Orientation.LEFT_RIGHT);
+  }
+
+  private void verifyGradientOrientation(int resId, Orientation expected) {
+    final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    assertEquals(expected, ((GradientDrawable) context.getDrawable(resId)).getOrientation());
+  }
+
+  @Test
+  public void testDynamicGradientDefaultOrientation() {
+    // Verify that the default orientation for a programmatically defined GradientDrawable is
+    // TOP_BOTTOM. This differs from the default behavior of xml inflated GradientDrawables
+    // that default to LEFT_RIGHT
+    assertEquals(Orientation.TOP_BOTTOM, new GradientDrawable().getOrientation());
+  }
+
+  @Test
+  public void testGradientDrawableOrientationConstructor() {
+    GradientDrawable drawable = new GradientDrawable(Orientation.TOP_BOTTOM, null);
+    assertEquals(Orientation.TOP_BOTTOM, drawable.getOrientation());
+  }
+
+  @Test
+  public void testInflatedGradientOrientationUpdated() {
+    final Context context =
+        new ContextThemeWrapper(
+            InstrumentationRegistry.getInstrumentation().getTargetContext(),
+            R.style.Theme_MixedGradientTheme);
+
+    GradientDrawable drawable = (GradientDrawable) context.getDrawable(R.drawable.gradientdrawable);
+
+    assertEquals(Orientation.BL_TR, drawable.getOrientation());
+
+    drawable.setOrientation(Orientation.BOTTOM_TOP);
+    assertEquals(Orientation.BOTTOM_TOP, drawable.getOrientation());
+  }
+
+  private void verifyPreloadDensityInner(Resources res, int densityDpi)
+      throws XmlPullParserException, IOException {
+    final Rect tempPadding = new Rect();
+
+    // Capture initial state at default density.
+    final XmlResourceParser parser =
+        DrawableTestUtils.getResourceParser(res, R.drawable.gradient_drawable_density);
+    final GradientDrawable preloadedDrawable = new GradientDrawable();
+    preloadedDrawable.inflate(res, parser, Xml.asAttributeSet(parser));
+    final ConstantState preloadedConstantState = preloadedDrawable.getConstantState();
+    final int origWidth = preloadedDrawable.getIntrinsicWidth();
+    final int origHeight = preloadedDrawable.getIntrinsicHeight();
+    final Rect origPadding = new Rect();
+    preloadedDrawable.getPadding(origPadding);
+
+    // Set density to approximately half of original. Unlike offsets, which are
+    // truncated, dimensions are rounded to the nearest pixel.
+    DrawableTestUtils.setResourcesDensity(res, densityDpi / 2);
+    final GradientDrawable halfDrawable =
+        (GradientDrawable) preloadedConstantState.newDrawable(res);
+    // NOTE: densityDpi may not be an even number, so account for *actual* scaling in asserts
+    final float approxHalf = (float) (densityDpi / 2) / densityDpi;
+    assertEquals(Math.round(origWidth * approxHalf), halfDrawable.getIntrinsicWidth());
+    assertEquals(Math.round(origHeight * approxHalf), halfDrawable.getIntrinsicHeight());
+    assertTrue(halfDrawable.getPadding(tempPadding));
+    assertEquals((int) (origPadding.left * approxHalf), tempPadding.left);
+
+    // Set density to double original.
+    DrawableTestUtils.setResourcesDensity(res, densityDpi * 2);
+    final GradientDrawable doubleDrawable =
+        (GradientDrawable) preloadedConstantState.newDrawable(res);
+    assertEquals(origWidth * 2, doubleDrawable.getIntrinsicWidth());
+    assertEquals(origHeight * 2, doubleDrawable.getIntrinsicHeight());
+    assertTrue(doubleDrawable.getPadding(tempPadding));
+    assertEquals(origPadding.left * 2, tempPadding.left);
+
+    // Restore original density.
+    DrawableTestUtils.setResourcesDensity(res, densityDpi);
+    final GradientDrawable origDrawable = (GradientDrawable) preloadedConstantState.newDrawable();
+    assertEquals(origWidth, origDrawable.getIntrinsicWidth());
+    assertEquals(origHeight, origDrawable.getIntrinsicHeight());
+    assertTrue(origDrawable.getPadding(tempPadding));
+    assertEquals(origPadding, tempPadding);
+
+    // Reproduce imprecise truncated scale down, and back up. Note these aren't rounded.
+    final float approxDouble = 1 / approxHalf;
+    final Rect sloppyOrigPadding = new Rect();
+    sloppyOrigPadding.left = (int) (approxDouble * ((int) (origPadding.left * approxHalf)));
+    sloppyOrigPadding.top = (int) (approxDouble * ((int) (origPadding.top * approxHalf)));
+    sloppyOrigPadding.right = (int) (approxDouble * ((int) (origPadding.right * approxHalf)));
+    sloppyOrigPadding.bottom = (int) (approxDouble * ((int) (origPadding.bottom * approxHalf)));
+
+    // Ensure theme density is applied correctly.
+    final Theme t = res.newTheme();
+    halfDrawable.applyTheme(t);
+    assertEquals(
+        Math.round(approxDouble * Math.round(origWidth * approxHalf)),
+        halfDrawable.getIntrinsicWidth());
+    assertEquals(
+        Math.round(approxDouble * Math.round(origHeight * approxHalf)),
+        halfDrawable.getIntrinsicHeight());
+    assertTrue(halfDrawable.getPadding(tempPadding));
+    assertEquals(sloppyOrigPadding, tempPadding);
+    doubleDrawable.applyTheme(t);
+    assertEquals(origWidth, doubleDrawable.getIntrinsicWidth());
+    assertEquals(origHeight, doubleDrawable.getIntrinsicHeight());
+    assertTrue(doubleDrawable.getPadding(tempPadding));
+    assertEquals(origPadding, tempPadding);
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java b/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java
index e81fda489..d4b95bd7b 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java
@@ -34,7 +34,31 @@ public final class OsConstantsTest {
           "SEEK_SET",
           "SHUT_RD",
           "STDIN_FILENO",
-          "_SC_ARG_MAX");
+          "_SC_ARG_MAX",
+          "MADV_NORMAL",
+          "MADV_RANDOM",
+          "MADV_SEQUENTIAL",
+          "MADV_WILLNEED",
+          "MADV_DONTNEED",
+          "MADV_REMOVE",
+          "MADV_DONTFORK",
+          "MADV_DOFORK",
+          "MADV_HWPOISON",
+          "MADV_MERGEABLE",
+          "MADV_UNMERGEABLE",
+          "MADV_SOFT_OFFLINE",
+          "MADV_HUGEPAGE",
+          "MADV_NOHUGEPAGE",
+          "MADV_COLLAPSE",
+          "MADV_DONTDUMP",
+          "MADV_DODUMP",
+          "MADV_FREE",
+          "MADV_WIPEONFORK",
+          "MADV_KEEPONFORK",
+          "MADV_COLD",
+          "MADV_PAGEOUT",
+          "MADV_POPULATE_READ",
+          "MADV_POPULATE_WRITE");
 
   @Test
   public void valuesAreDistinct() throws Exception {
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java
index 06eba43ae..d4fd351a9 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java
@@ -6,6 +6,7 @@ import static androidx.test.ext.truth.view.PointerCoordsSubject.assertThat;
 import static androidx.test.ext.truth.view.PointerPropertiesSubject.assertThat;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 
 import android.graphics.Matrix;
 import android.os.Build;
@@ -427,6 +428,25 @@ public class MotionEventTest {
     assertThat(motionEvent2).y().isWithin(TOLERANCE).of(Y_4F + offsetY);
   }
 
+  @Test
+  public void testNoLocationOffsetForNonPointerSource() {
+    assumeTrue(
+        "NoLocationOffset for non PointerSource only work from API 32",
+        Build.VERSION.SDK_INT >= VERSION_CODES.S_V2);
+    assertThat(motionEvent2).x().isWithin(TOLERANCE).of(X_3F);
+    assertThat(motionEvent2).y().isWithin(TOLERANCE).of(Y_4F);
+    motionEvent2.setSource(InputDevice.SOURCE_TOUCHPAD);
+
+    float offsetX = 1.0f;
+    float offsetY = 1.0f;
+    motionEvent2.offsetLocation(offsetX, offsetY);
+
+    assertThat(motionEvent2).x().isWithin(TOLERANCE).of(X_3F);
+    assertThat(motionEvent2).y().isWithin(TOLERANCE).of(Y_4F);
+    assertThat(motionEvent2).pressure().isWithin(TOLERANCE).of(PRESSURE_1F);
+    assertThat(motionEvent2).size().isWithin(TOLERANCE).of(SIZE_1F);
+  }
+
   @Test
   public void testSetLocationForPointerSource() {
     assertThat(motionEvent2).x().isWithin(TOLERANCE).of(X_3F);
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
index 1629210e9..c9dfdf5b7 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
@@ -41,6 +41,7 @@ import org.robolectric.util.ReflectionHelpers;
  */
 @RunWith(AndroidJUnit4.class)
 public class AccessibilityNodeInfoTest {
+
   @Test
   @Config(minSdk = Build.VERSION_CODES.R)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
@@ -96,6 +97,17 @@ public class AccessibilityNodeInfoTest {
         .isEqualTo(node2.getContentDescription().toString());
   }
 
+  @Test
+  public void obtain_equalsTo() {
+    String originalProperty = System.getProperty("robolectric.useRealAni", "");
+    try {
+      System.setProperty("robolectric.useRealAni", "true");
+      assertThat(AccessibilityNodeInfo.obtain()).isEqualTo(AccessibilityNodeInfo.obtain());
+    } finally {
+      System.setProperty("robolectric.useRealAni", originalProperty);
+    }
+  }
+
   @Test
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
   @Config(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -110,7 +122,11 @@ public class AccessibilityNodeInfoTest {
             node.setQueryFromAppProcessEnabled(rootView, true);
             assertThat(node.getChildCount()).isEqualTo(1);
             assertThat(node.getChild(0)).isNotNull();
-            assertThat(node.getWindowId()).isEqualTo(-1);
+            // Only expect getWindowId() is -1 in Robolectric environment.
+            // TODO remove Robolectric checking after fixing Robolectric's implementation.
+            if (Build.FINGERPRINT.equals("robolectric")) {
+              assertThat(node.getWindowId()).isEqualTo(-1);
+            }
           });
     }
   }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/webkit/MimeTypeMapTest.java b/integration_tests/ctesque/src/sharedTest/java/android/webkit/MimeTypeMapTest.java
new file mode 100644
index 000000000..61a96a5d3
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/webkit/MimeTypeMapTest.java
@@ -0,0 +1,115 @@
+/* Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Fork of CTS's MimeTypeMapTest */
+@RunWith(AndroidJUnit4.class)
+public class MimeTypeMapTest {
+
+  private MimeTypeMap mimeTypeMap;
+
+  @Before
+  public void setUp() throws Exception {
+    mimeTypeMap = MimeTypeMap.getSingleton();
+  }
+
+  @Test
+  public void testGetFileExtensionFromUrl() {
+    assertThat(MimeTypeMap.getFileExtensionFromUrl("http://localhost/index.html"))
+        .isEqualTo("html");
+    assertThat(MimeTypeMap.getFileExtensionFromUrl("http://host/x.html?x=y")).isEqualTo("html");
+    assertThat(MimeTypeMap.getFileExtensionFromUrl("http://www.example.com/")).isEmpty();
+    assertThat(MimeTypeMap.getFileExtensionFromUrl("https://example.com/foo")).isEmpty();
+    assertThat(MimeTypeMap.getFileExtensionFromUrl(null)).isEmpty();
+    assertThat(MimeTypeMap.getFileExtensionFromUrl("")).isEmpty();
+    assertThat(MimeTypeMap.getFileExtensionFromUrl("http://abc/&%$.()*")).isEmpty();
+  }
+
+  @Test
+  public void testHasMimeType() {
+    assertThat(mimeTypeMap.hasMimeType("audio/mpeg")).isTrue();
+    assertThat(mimeTypeMap.hasMimeType("text/plain")).isTrue();
+
+    assertThat(mimeTypeMap.hasMimeType("some_random_string")).isFalse();
+
+    assertThat(mimeTypeMap.hasMimeType("")).isFalse();
+    assertThat(mimeTypeMap.hasMimeType(null)).isFalse();
+  }
+
+  @Test
+  public void testGetMimeTypeFromExtension() {
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("mp3")).isEqualTo("audio/mpeg");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("zip")).isEqualTo("application/zip");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("jpg")).isEqualTo("image/jpeg");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("jpeg")).isEqualTo("image/jpeg");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("m4a")).isEqualTo("audio/mpeg");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("gif")).isEqualTo("image/gif");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("pdf")).isEqualTo("application/pdf");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("apk"))
+        .isEqualTo("application/vnd.android.package-archive");
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("3gp")).isEqualTo("video/3gpp");
+    // Android <= 24 maps 3gpp to audio/3gpp
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("3gpp")).isAnyOf("video/3gpp", "audio/3gpp");
+
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("some_random_string")).isNull();
+
+    assertThat(mimeTypeMap.getMimeTypeFromExtension(null)).isNull();
+    assertThat(mimeTypeMap.getMimeTypeFromExtension("")).isNull();
+  }
+
+  @Test
+  public void testHasExtension() {
+    assertThat(mimeTypeMap.hasExtension("mp3")).isTrue();
+    assertThat(mimeTypeMap.hasExtension("zip")).isTrue();
+
+    assertThat(mimeTypeMap.hasExtension("some_random_string")).isFalse();
+
+    assertThat(mimeTypeMap.hasExtension("")).isFalse();
+    assertThat(mimeTypeMap.hasExtension(null)).isFalse();
+  }
+
+  @Test
+  public void testGetExtensionFromMimeType() {
+    assertThat(mimeTypeMap.getExtensionFromMimeType("audio/mpeg")).isEqualTo("mp3");
+    assertThat(mimeTypeMap.getExtensionFromMimeType("image/png")).isEqualTo("png");
+    assertThat(mimeTypeMap.getExtensionFromMimeType("application/zip")).isEqualTo("zip");
+    assertThat(mimeTypeMap.getExtensionFromMimeType("video/mp4")).isEqualTo("mp4");
+    assertThat(mimeTypeMap.getExtensionFromMimeType("image/jpeg")).isAnyOf("jpg", "jpeg");
+    assertThat(mimeTypeMap.getExtensionFromMimeType("text/plain")).isEqualTo("txt");
+
+    assertThat(mimeTypeMap.getExtensionFromMimeType("video/3gp")).isNull();
+    assertThat(mimeTypeMap.getExtensionFromMimeType("some_random_string")).isNull();
+    assertThat(mimeTypeMap.getExtensionFromMimeType("application/text")).isNull();
+
+    assertThat(mimeTypeMap.getExtensionFromMimeType(null)).isNull();
+    assertThat(mimeTypeMap.getExtensionFromMimeType("")).isNull();
+  }
+
+  @Test
+  public void testGetSingleton() {
+    MimeTypeMap firstMimeTypeMap = MimeTypeMap.getSingleton();
+    MimeTypeMap secondMimeTypeMap = MimeTypeMap.getSingleton();
+
+    assertThat(secondMimeTypeMap).isSameInstanceAs(firstMimeTypeMap);
+  }
+}
diff --git a/integration_tests/dependency-on-stubs/build.gradle.kts b/integration_tests/dependency-on-stubs/build.gradle.kts
index 743cec6ce..c6ffb852c 100644
--- a/integration_tests/dependency-on-stubs/build.gradle.kts
+++ b/integration_tests/dependency-on-stubs/build.gradle.kts
@@ -6,7 +6,7 @@ plugins {
 // test with a project that depends on the stubs jar, not org.robolectric:android-all
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric"
 
   defaultConfig { minSdk = 21 }
@@ -17,7 +17,7 @@ android {
   }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 }
@@ -25,5 +25,4 @@ android {
 dependencies {
   testImplementation(project(":robolectric"))
   testImplementation(libs.junit4)
-  testImplementation(libs.truth)
 }
diff --git a/integration_tests/kotlin/build.gradle.kts b/integration_tests/kotlin/build.gradle.kts
index 339f8dd1f..647751977 100644
--- a/integration_tests/kotlin/build.gradle.kts
+++ b/integration_tests/kotlin/build.gradle.kts
@@ -11,12 +11,9 @@ tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
 
 tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
 
-val axtCoreVersion: String by rootProject.extra
-
 dependencies {
   api(project(":robolectric"))
   compileOnly(AndroidSdk.MAX_SDK.coordinates)
-  implementation(libs.androidx.annotation)
 
   testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
   testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
@@ -24,5 +21,4 @@ dependencies {
   testImplementation(libs.kotlinx.coroutines.android)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation("androidx.test:core:$axtCoreVersion@aar")
 }
diff --git a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt
index ccc8d740a..ed6b7158e 100644
--- a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt
+++ b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt
@@ -19,11 +19,7 @@ import kotlinx.coroutines.flow.flow
 /** A class that invokes Android Bluetooth LE APIs. */
 class BluetoothProvisioner(applicationContext: Context) {
 
-  val context: Context
-
-  init {
-    context = applicationContext
-  }
+  val context = applicationContext
 
   fun startScan(): Flow<BluetoothDevice> = callbackFlow {
     val scanCallback =
diff --git a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt
index e57b6badc..3e94149eb 100644
--- a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt
+++ b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt
@@ -1,5 +1,6 @@
 package org.robolectric.integrationtests.kotlin.flow
 
+import android.app.Application
 import android.bluetooth.BluetoothGattService
 import android.bluetooth.BluetoothManager
 import android.bluetooth.le.ScanResult
@@ -30,7 +31,7 @@ import org.robolectric.shadows.ShadowBluetoothLeScanner
 @Config(sdk = [S])
 class BluetoothProvisionerTest {
 
-  val context = RuntimeEnvironment.getApplication()
+  val context: Application = RuntimeEnvironment.getApplication()
 
   val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
 
diff --git a/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java b/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java
index c2bd47911..35bb5c479 100644
--- a/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java
+++ b/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java
@@ -15,7 +15,7 @@ public class ClassloadingTest {
 
   /** <a href="https://github.com/robolectric/robolectric/issues/2773">Issue</a> */
   @Test
-  public void getResourceAsStream() throws Exception {
+  public void getResourceAsStream() {
     Phonenumber.PhoneNumber phoneNumber = new Phonenumber.PhoneNumber();
     phoneNumber.setCountryCode(7);
     phoneNumber.setNationalNumber(4956360636L);
diff --git a/integration_tests/memoryleaks/build.gradle.kts b/integration_tests/memoryleaks/build.gradle.kts
index f282286fa..92c3deaa1 100644
--- a/integration_tests/memoryleaks/build.gradle.kts
+++ b/integration_tests/memoryleaks/build.gradle.kts
@@ -4,7 +4,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integrationtests.memoryleaks"
 
   defaultConfig { minSdk = 21 }
@@ -15,7 +15,7 @@ android {
   }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 }
diff --git a/integration_tests/memoryleaks/src/test/java/org/robolectric/integrationtests/memoryleaks/BaseMemoryLeaksTest.java b/integration_tests/memoryleaks/src/test/java/org/robolectric/integrationtests/memoryleaks/BaseMemoryLeaksTest.java
index bd6c5366a..852abeb82 100644
--- a/integration_tests/memoryleaks/src/test/java/org/robolectric/integrationtests/memoryleaks/BaseMemoryLeaksTest.java
+++ b/integration_tests/memoryleaks/src/test/java/org/robolectric/integrationtests/memoryleaks/BaseMemoryLeaksTest.java
@@ -72,8 +72,10 @@ public abstract class BaseMemoryLeaksTest {
   // that run.
   public void aaa_activityCanBeGcdBetweenTest_1() {
     assertThat(awr).isNull();
-    ActivityController<Activity> ac = Robolectric.buildActivity(Activity.class).setup();
-    awr = new WeakReference<>(ac.get());
+    try (ActivityController<Activity> ac = Robolectric.buildActivity(Activity.class)) {
+      ac.setup();
+      awr = new WeakReference<>(ac.get());
+    }
   }
 
   @Test
diff --git a/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockFinalsTest.java b/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockFinalsTest.java
index 21bac8211..3ec09b25e 100644
--- a/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockFinalsTest.java
+++ b/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockFinalsTest.java
@@ -36,7 +36,7 @@ public class MockitoMockFinalsTest {
   }
 
   static final class User {
-    final int getId() {
+    int getId() {
       return -1;
     }
   }
diff --git a/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockJavaFrameworkTest.java b/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockJavaFrameworkTest.java
index 5034507f7..ed5d82d14 100644
--- a/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockJavaFrameworkTest.java
+++ b/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoMockJavaFrameworkTest.java
@@ -15,7 +15,7 @@ import org.robolectric.RobolectricTestRunner;
 @RunWith(RobolectricTestRunner.class)
 public class MockitoMockJavaFrameworkTest {
   @Test
-  public void file_getAbsolutePath_isMockable() throws Exception {
+  public void file_getAbsolutePath_isMockable() {
     File file = mock(File.class);
     doReturn("absolute/path").when(file).getAbsolutePath();
     assertThat(file.getAbsolutePath()).isEqualTo("absolute/path");
diff --git a/integration_tests/mockk/src/test/java/org/robolectric/integrationtests/mockk/MockkInitTestCase.kt b/integration_tests/mockk/src/test/java/org/robolectric/integrationtests/mockk/MockkInitTestCase.kt
index 778a418ca..2ac228adc 100644
--- a/integration_tests/mockk/src/test/java/org/robolectric/integrationtests/mockk/MockkInitTestCase.kt
+++ b/integration_tests/mockk/src/test/java/org/robolectric/integrationtests/mockk/MockkInitTestCase.kt
@@ -24,7 +24,7 @@ class MockkInitTestCase {
   @Before fun setUp() = MockKAnnotations.init(this)
 
   @Test
-  fun `Mockk1`() {
+  fun mockk1() {
     every { returner.returnNumber() } returns 1
     assert(returner.returnNumber() == 1)
   }
diff --git a/integration_tests/multidex/build.gradle.kts b/integration_tests/multidex/build.gradle.kts
deleted file mode 100644
index 9f5792bb2..000000000
--- a/integration_tests/multidex/build.gradle.kts
+++ /dev/null
@@ -1,40 +0,0 @@
-plugins {
-  alias(libs.plugins.android.library)
-  alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-  compileSdk = 34
-  namespace = "android.support.multidex"
-
-  defaultConfig {
-    minSdk = 21
-    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
-  }
-
-  lint { abortOnError = false }
-
-  testOptions {
-    targetSdk = 34
-    unitTests.isIncludeAndroidResources = true
-  }
-
-  compileOptions {
-    sourceCompatibility = JavaVersion.VERSION_1_8
-    targetCompatibility = JavaVersion.VERSION_1_8
-  }
-}
-
-dependencies {
-  api(project(":robolectric"))
-  compileOnly(AndroidSdk.MAX_SDK.coordinates)
-
-  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
-  testImplementation(libs.androidx.test.core)
-  testImplementation(libs.androidx.test.ext.junit)
-  testImplementation(libs.androidx.test.runner)
-  testImplementation(libs.junit4)
-  testImplementation(libs.truth)
-  testImplementation(libs.androidx.multidex)
-  testImplementation(libs.android.multidex)
-}
diff --git a/integration_tests/multidex/src/test/AndroidManifest.xml b/integration_tests/multidex/src/test/AndroidManifest.xml
deleted file mode 100644
index ced50f900..000000000
--- a/integration_tests/multidex/src/test/AndroidManifest.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android">
-
-  <uses-sdk
-      android:minSdkVersion="21"
-      android:targetSdkVersion="34"/>
-
-  <application />
-
-  <instrumentation
-      android:name="androidx.test.runner.AndroidJUnitRunner"
-      android:targetPackage="android.support.multidex" />
-
-</manifest>
diff --git a/integration_tests/multidex/src/test/java/android/support/multidex/MultiDexTest.java b/integration_tests/multidex/src/test/java/android/support/multidex/MultiDexTest.java
deleted file mode 100644
index df355e36d..000000000
--- a/integration_tests/multidex/src/test/java/android/support/multidex/MultiDexTest.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package android.support.multidex;
-
-import static android.support.multidex.MultiDex.install;
-import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Integration tests for android.support.multidex.MultiDex Robolectric. */
-@RunWith(AndroidJUnit4.class)
-public class MultiDexTest {
-  @Test
-  public void testIntendedFailEmpty() {
-    install(getApplicationContext());
-  }
-}
diff --git a/integration_tests/multidex/src/test/java/androidx/multidex/MultiDexTest.java b/integration_tests/multidex/src/test/java/androidx/multidex/MultiDexTest.java
deleted file mode 100644
index 5e3e982e6..000000000
--- a/integration_tests/multidex/src/test/java/androidx/multidex/MultiDexTest.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package androidx.multidex;
-
-import static androidx.multidex.MultiDex.install;
-import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Integration tests for androidx.multidex.MultiDex Robolectric. */
-@RunWith(AndroidJUnit4.class)
-public class MultiDexTest {
-  @Test
-  public void testIntendedFailEmpty() {
-    install(getApplicationContext());
-  }
-}
diff --git a/integration_tests/nativegraphics/Android.bp b/integration_tests/nativegraphics/Android.bp
index 6d552fea5..13de38cbc 100644
--- a/integration_tests/nativegraphics/Android.bp
+++ b/integration_tests/nativegraphics/Android.bp
@@ -62,7 +62,6 @@ android_robolectric_test {
         "truth",
         "guava-android-testlib",
     ],
-    upstream: true,
     java_resource_dirs: ["config"],
     instrumentation_for: "NativeGraphicsPseudoApp",
 
diff --git a/integration_tests/nativegraphics/AndroidManifest.xml b/integration_tests/nativegraphics/AndroidManifest.xml
index 19bc0e5e1..1bb986498 100644
--- a/integration_tests/nativegraphics/AndroidManifest.xml
+++ b/integration_tests/nativegraphics/AndroidManifest.xml
@@ -4,6 +4,6 @@
     package="org.robolectric.shadows">
   <uses-sdk
       android:minSdkVersion="26"
-      android:targetSdkVersion="34" />
+      android:targetSdkVersion="35" />
   <application />
 </manifest>
diff --git a/integration_tests/nativegraphics/build.gradle.kts b/integration_tests/nativegraphics/build.gradle.kts
index c49126a43..ec7fb6e31 100644
--- a/integration_tests/nativegraphics/build.gradle.kts
+++ b/integration_tests/nativegraphics/build.gradle.kts
@@ -4,13 +4,13 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.shadows"
 
   defaultConfig { minSdk = 26 }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests {
       isIncludeAndroidResources = true
       all { it.systemProperty("robolectric.graphicsMode", "NATIVE") }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/BitmapUtils.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/BitmapUtils.java
index 0370f64d9..1419b8630 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/BitmapUtils.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/BitmapUtils.java
@@ -85,7 +85,7 @@ public class BitmapUtils {
   public static boolean compareBitmaps(Bitmap bmp1, Bitmap bmp2) {
     final Boolean basicComparison = compareBasicBitmapsInfo(bmp1, bmp2);
     if (basicComparison != null) {
-      return basicComparison.booleanValue();
+      return basicComparison;
     }
 
     for (int i = 0; i < bmp1.getWidth(); i++) {
@@ -107,7 +107,7 @@ public class BitmapUtils {
   public static boolean compareBitmaps(Bitmap bmp1, Bitmap bmp2, double minimumPrecision) {
     final Boolean basicComparison = compareBasicBitmapsInfo(bmp1, bmp2);
     if (basicComparison != null) {
-      return basicComparison.booleanValue();
+      return basicComparison;
     }
 
     final int width = bmp1.getWidth();
@@ -210,7 +210,7 @@ public class BitmapUtils {
       boolean isPremultiplied) {
     final Boolean basicComparison = compareBasicBitmapsInfo(expected, actual);
     if (basicComparison != null) {
-      return basicComparison.booleanValue();
+      return basicComparison;
     }
 
     double mse = 0;
@@ -238,14 +238,13 @@ public class BitmapUtils {
         Log.d(TAG, "MSE too large for normal case: " + mse);
         return false;
       }
-      return true;
     } else {
       if (mse <= mseMargin) {
         Log.d(TAG, "MSE too small for abnormal case: " + mse);
         return false;
       }
-      return true;
     }
+    return true;
   }
 
   // Same as above, but asserts compareBitmapsMse's return value.
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ColorUtils.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ColorUtils.java
index f5f40db48..b0c88d07b 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ColorUtils.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ColorUtils.java
@@ -19,10 +19,10 @@ package org.robolectric.shadows;
 import static org.junit.Assert.fail;
 
 import android.graphics.Color;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
 import java.util.function.Function;
 import java.util.function.IntUnaryOperator;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 
 public final class ColorUtils {
   public static void verifyColor(int expected, int observed) {
@@ -41,7 +41,7 @@ public final class ColorUtils {
    * @param observed Observed color.
    * @param tolerance Per-channel tolerance by which the color can mismatch.
    */
-  public static void verifyColor(@NonNull String s, int expected, int observed, int tolerance) {
+  public static void verifyColor(@Nonnull String s, int expected, int observed, int tolerance) {
     s +=
         " expected 0x"
             + Integer.toHexString(expected)
@@ -49,10 +49,10 @@ public final class ColorUtils {
             + Integer.toHexString(observed)
             + ", tolerated channel error 0x"
             + tolerance;
-    String red = verifyChannel("red", expected, observed, tolerance, (i) -> Color.red(i));
-    String green = verifyChannel("green", expected, observed, tolerance, (i) -> Color.green(i));
-    String blue = verifyChannel("blue", expected, observed, tolerance, (i) -> Color.blue(i));
-    String alpha = verifyChannel("alpha", expected, observed, tolerance, (i) -> Color.alpha(i));
+    String red = verifyChannel("red", expected, observed, tolerance, Color::red);
+    String green = verifyChannel("green", expected, observed, tolerance, Color::green);
+    String blue = verifyChannel("blue", expected, observed, tolerance, Color::blue);
+    String alpha = verifyChannel("alpha", expected, observed, tolerance, Color::alpha);
 
     buildErrorString(s, red, green, blue, alpha);
   }
@@ -66,7 +66,7 @@ public final class ColorUtils {
    * @param tolerance Per-channel tolerance by which the color can mismatch.
    */
   public static void verifyColor(
-      @NonNull String msg, Color expected, Color observed, float tolerance) {
+      @Nonnull String msg, Color expected, Color observed, float tolerance) {
     if (!expected.getColorSpace().equals(observed.getColorSpace())) {
       fail(
           "Cannot compare Colors with different color spaces! expected: "
@@ -81,32 +81,32 @@ public final class ColorUtils {
             + observed
             + ", tolerated channel error "
             + tolerance;
-    String red = verifyChannel("red", expected, observed, tolerance, (c) -> c.red());
-    String green = verifyChannel("green", expected, observed, tolerance, (c) -> c.green());
-    String blue = verifyChannel("blue", expected, observed, tolerance, (c) -> c.blue());
-    String alpha = verifyChannel("alpha", expected, observed, tolerance, (c) -> c.alpha());
+    String red = verifyChannel("red", expected, observed, tolerance, Color::red);
+    String green = verifyChannel("green", expected, observed, tolerance, Color::green);
+    String blue = verifyChannel("blue", expected, observed, tolerance, Color::blue);
+    String alpha = verifyChannel("alpha", expected, observed, tolerance, Color::alpha);
 
     buildErrorString(msg, red, green, blue, alpha);
   }
 
   private static void buildErrorString(
-      @NonNull String s,
+      @Nonnull String s,
       @Nullable String red,
       @Nullable String green,
       @Nullable String blue,
       @Nullable String alpha) {
-    String err = null;
+    StringBuilder error = null;
     for (String channel : new String[] {red, green, blue, alpha}) {
       if (channel == null) {
         continue;
       }
-      if (err == null) {
-        err = s;
+      if (error == null) {
+        error = new StringBuilder(s);
       }
-      err += "\n\t\t" + channel;
+      error.append("\n\t\t").append(channel);
     }
-    if (err != null) {
-      fail(err);
+    if (error != null) {
+      fail(error.toString());
     }
   }
 
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/DrawableTestUtils.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/DrawableTestUtils.java
index 6ab46e433..0cff93aa4 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/DrawableTestUtils.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/DrawableTestUtils.java
@@ -32,12 +32,12 @@ import android.util.AttributeSet;
 import android.util.Log;
 import android.util.Xml;
 import androidx.annotation.IntegerRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
 import com.google.common.base.MoreObjects;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.junit.Assert;
 import org.robolectric.RuntimeEnvironment;
 import org.xmlpull.v1.XmlPullParser;
@@ -256,8 +256,8 @@ public final class DrawableTestUtils {
    * referred from the resource id, plus optionally {@code extras}, and "_golden"
    */
   static void saveAutoNamedVectorDrawableIntoPNG(
-      @NonNull Context context,
-      @NonNull Bitmap bitmap,
+      @Nonnull Context context,
+      @Nonnull Bitmap bitmap,
       @IntegerRes int resId,
       @Nullable String extras)
       throws IOException {
@@ -274,7 +274,7 @@ public final class DrawableTestUtils {
 
   /** Save a {@code bitmap} to the {@code fileFullName} plus "_golden". */
   static void saveVectorDrawableIntoPNG(
-      @NonNull Bitmap bitmap, @NonNull String outputFolder, @NonNull String fileFullName)
+      @Nonnull Bitmap bitmap, @Nonnull String outputFolder, @Nonnull String fileFullName)
       throws IOException {
     // Save the image to the disk.
     FileOutputStream out = null;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/HardwareAcceleratedActivityRenderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/HardwareAcceleratedActivityRenderTest.java
index e09713686..1fad0b6b0 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/HardwareAcceleratedActivityRenderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/HardwareAcceleratedActivityRenderTest.java
@@ -26,7 +26,7 @@ import org.robolectric.annotation.Config;
 @Config(minSdk = Q)
 public class HardwareAcceleratedActivityRenderTest {
   @Test
-  public void hardwareAcceleratedActivity_setup() throws Exception {
+  public void hardwareAcceleratedActivity_setup() {
     // Setting up an Activity is a smoke test that exercises much of the HardwareRenderer /
     // RenderNode / RecordingCanvas native code.
     Robolectric.setupActivity(HardwareAcceleratedActivity.class);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAllocationRegistryTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAllocationRegistryTest.java
index 7fdc554ae..474a313aa 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAllocationRegistryTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAllocationRegistryTest.java
@@ -25,7 +25,7 @@ public final class ShadowNativeAllocationRegistryTest {
   // TODO(hoisie): choose a different free function to test in V and above.
   @Config(maxSdk = U.SDK_INT)
   @Test
-  public void applyFreeFunction_matrix() throws Exception {
+  public void applyFreeFunction_matrix() {
     WeakReference<Matrix> weakMatrix = new WeakReference<>(newMatrix());
     // Invokes 'applyFreeFunction' when the matrix is GC'd.
     GcFinalization.awaitClear(weakMatrix);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java
index d1f47a6cf..cc992a41b 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java
@@ -28,7 +28,7 @@ public class ShadowNativeAnimatedImageDrawableTest {
   }
 
   @Test
-  public void testInflate() throws Exception {
+  public void testInflate() {
     AnimatedImageDrawable aid = (AnimatedImageDrawable) resources.getDrawable(R.drawable.animated);
     assertThat(aid).isNotNull();
   }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java
index 03a949259..87d439ba5 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java
@@ -2,6 +2,8 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
 
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -92,7 +94,7 @@ public class ShadowNativeAnimatedVectorDrawableTest {
 
     drawable.start();
 
-    assertEquals(true, Shadows.shadowOf(drawable).isStartInitiated());
+    assertTrue(Shadows.shadowOf(drawable).isStartInitiated());
   }
 
   @Test
@@ -116,6 +118,6 @@ public class ShadowNativeAnimatedVectorDrawableTest {
     drawable.start();
     drawable.stop();
 
-    assertEquals(false, Shadows.shadowOf(drawable).isStartInitiated());
+    assertFalse(Shadows.shadowOf(drawable).isStartInitiated());
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapFactoryTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapFactoryTest.java
index a028529b6..b7e547e4a 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapFactoryTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapFactoryTest.java
@@ -48,6 +48,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -278,9 +279,7 @@ public class ShadowNativeBitmapFactoryTest {
 
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          BitmapFactory.decodeResource(res, R.drawable.pass, options);
-        });
+        () -> BitmapFactory.decodeResource(res, R.drawable.pass, options));
   }
 
   /** Create bitmap sized to load unscaled resources: start, pass, and alpha */
@@ -345,9 +344,7 @@ public class ShadowNativeBitmapFactoryTest {
     options.inMutable = true;
     options.inScaled = false;
     options.inSampleSize = 4;
-    Bitmap reduced = BitmapFactory.decodeResource(res, R.drawable.robot, options);
-
-    options.inBitmap = reduced;
+    options.inBitmap = BitmapFactory.decodeResource(res, R.drawable.robot, options);
     options.inSampleSize = 1;
     assertThrows(
         "should throw exception due to lack of space",
@@ -410,8 +407,8 @@ public class ShadowNativeBitmapFactoryTest {
     options.inSampleSize = 2;
     Bitmap scaleReduced = BitmapFactory.decodeResource(res, R.drawable.robot, options);
     // verify that density isn't incorrectly carried over during bitmap reuse
-    assertFalse(densityReduced.getDensity() == 2);
-    assertFalse(densityReduced.getDensity() == 0);
+    assertNotEquals(2, densityReduced.getDensity());
+    assertNotEquals(0, densityReduced.getDensity());
     assertSame(densityReduced, scaleReduced);
   }
 
@@ -430,17 +427,19 @@ public class ShadowNativeBitmapFactoryTest {
     options.inInputShareable = false;
     byte[] array = obtainArray();
     Bitmap purgeableBitmap = BitmapFactory.decodeByteArray(array, 0, array.length, options);
-    assertFalse(purgeableBitmap.getAllocationByteCount() == 0);
+    assertNotEquals(0, purgeableBitmap.getAllocationByteCount());
   }
 
   private int defaultCreationDensity;
 
-  private void verifyScaled(Bitmap b) {
+  private void verifyScaled(@Nullable Bitmap b) {
+    assertNotNull(b);
     assertEquals(START_WIDTH * 2, b.getWidth());
     assertEquals(2, b.getDensity());
   }
 
-  private void verifyUnscaled(Bitmap b) {
+  private void verifyUnscaled(@Nullable Bitmap b) {
+    assertNotNull(b);
     assertEquals(START_WIDTH, b.getWidth());
     assertEquals(b.getDensity(), defaultCreationDensity);
   }
@@ -478,28 +477,30 @@ public class ShadowNativeBitmapFactoryTest {
 
   @Test
   public void testDecodeFileDescriptor1() throws IOException {
-    ParcelFileDescriptor pfd = obtainParcelDescriptor(obtainPath());
-    FileDescriptor input = pfd.getFileDescriptor();
-    Rect r = new Rect(1, 1, 1, 1);
-    Bitmap b = BitmapFactory.decodeFileDescriptor(input, r, opt1);
-    assertNotNull(b);
-    // Test the bitmap size
-    assertEquals(START_HEIGHT, b.getHeight());
-    assertEquals(START_WIDTH, b.getWidth());
-    // Test if no bitmap
-    assertNull(BitmapFactory.decodeFileDescriptor(input, r, opt2));
+    try (ParcelFileDescriptor pfd = obtainParcelDescriptor(obtainPath())) {
+      FileDescriptor input = pfd.getFileDescriptor();
+      Rect r = new Rect(1, 1, 1, 1);
+      Bitmap b = BitmapFactory.decodeFileDescriptor(input, r, opt1);
+      assertNotNull(b);
+      // Test the bitmap size
+      assertEquals(START_HEIGHT, b.getHeight());
+      assertEquals(START_WIDTH, b.getWidth());
+      // Test if no bitmap
+      assertNull(BitmapFactory.decodeFileDescriptor(input, r, opt2));
+    }
   }
 
   @Test
   public void testDecodeFileDescriptor2() throws IOException {
-    ParcelFileDescriptor pfd = obtainParcelDescriptor(obtainPath());
-    FileDescriptor input = pfd.getFileDescriptor();
-    Bitmap b = BitmapFactory.decodeFileDescriptor(input);
+    try (ParcelFileDescriptor pfd = obtainParcelDescriptor(obtainPath())) {
+      FileDescriptor input = pfd.getFileDescriptor();
+      Bitmap b = BitmapFactory.decodeFileDescriptor(input);
 
-    assertNotNull(b);
-    // Test the bitmap size
-    assertEquals(START_HEIGHT, b.getHeight());
-    assertEquals(START_WIDTH, b.getWidth());
+      assertNotNull(b);
+      // Test the bitmap size
+      assertEquals(START_HEIGHT, b.getHeight());
+      assertEquals(START_WIDTH, b.getWidth());
+    }
   }
 
   @Test
@@ -511,30 +512,32 @@ public class ShadowNativeBitmapFactoryTest {
       for (int j = 0; j < actualOffsets.length; ++j) {
         long actualOffset = actualOffsets[j];
         String path = obtainPath(testImage.id, actualOffset);
-        RandomAccessFile file = new RandomAccessFile(path, "r");
-        FileDescriptor fd = file.getFD();
-        assertTrue(fd.valid());
-
-        // Set the offset to ACTUAL_OFFSET
-        file.seek(actualOffset);
-        assertEquals(file.getFilePointer(), actualOffset);
-
-        // Now decode. This should be successful and leave the offset
-        // unchanged.
-        Bitmap b = BitmapFactory.decodeFileDescriptor(fd);
-        assertNotNull(b);
-        assertEquals(file.getFilePointer(), actualOffset);
-
-        // Now use the other offset. It should fail to decode, and
-        // the offset should remain unchanged.
-        long otherOffset = actualOffsets[(j + 1) % actualOffsets.length];
-        assertFalse(otherOffset == actualOffset);
-        file.seek(otherOffset);
-        assertEquals(file.getFilePointer(), otherOffset);
-
-        b = BitmapFactory.decodeFileDescriptor(fd);
-        assertNull(b);
-        assertEquals(file.getFilePointer(), otherOffset);
+
+        try (RandomAccessFile file = new RandomAccessFile(path, "r")) {
+          FileDescriptor fd = file.getFD();
+          assertTrue(fd.valid());
+
+          // Set the offset to ACTUAL_OFFSET
+          file.seek(actualOffset);
+          assertEquals(file.getFilePointer(), actualOffset);
+
+          // Now decode. This should be successful and leave the offset
+          // unchanged.
+          Bitmap b = BitmapFactory.decodeFileDescriptor(fd);
+          assertNotNull(b);
+          assertEquals(file.getFilePointer(), actualOffset);
+
+          // Now use the other offset. It should fail to decode, and
+          // the offset should remain unchanged.
+          long otherOffset = actualOffsets[(j + 1) % actualOffsets.length];
+          assertNotEquals(otherOffset, actualOffset);
+          file.seek(otherOffset);
+          assertEquals(file.getFilePointer(), otherOffset);
+
+          b = BitmapFactory.decodeFileDescriptor(fd);
+          assertNull(b);
+          assertEquals(file.getFilePointer(), otherOffset);
+        }
       }
     }
   }
@@ -604,10 +607,9 @@ public class ShadowNativeBitmapFactoryTest {
     File dir = RuntimeEnvironment.getApplication().getFilesDir();
     dir.mkdirs();
 
-    String name =
-        RuntimeEnvironment.getApplication().getResources().getResourceEntryName(resId).toString();
+    String name = RuntimeEnvironment.getApplication().getResources().getResourceEntryName(resId);
     if (offset > 0) {
-      name = name + "_" + String.valueOf(offset);
+      name = name + "_" + offset;
     }
 
     File file = new File(dir, name);
@@ -624,7 +626,7 @@ public class ShadowNativeBitmapFactoryTest {
     // Write a bunch of zeroes before the image.
     assertThat(offset).isAtMost(1024);
     fOutput.write(dataBuffer, 0, (int) offset);
-    int readLength = 0;
+    int readLength;
     while ((readLength = is.read(dataBuffer)) != -1) {
       fOutput.write(dataBuffer, 0, readLength);
     }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
index bf0170a91..280a3ad0e 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
@@ -77,7 +77,7 @@ public class ShadowNativeBitmapTest {
   private BitmapFactory.Options options;
 
   public static List<ColorSpace> getRgbColorSpaces() {
-    List<ColorSpace> rgbColorSpaces = new ArrayList<ColorSpace>();
+    List<ColorSpace> rgbColorSpaces = new ArrayList<>();
     for (ColorSpace.Named e : ColorSpace.Named.values()) {
       ColorSpace cs = ColorSpace.get(e);
       if (cs.getModel() != ColorSpace.Model.RGB) {
@@ -437,7 +437,7 @@ public class ShadowNativeBitmapTest {
           try (HardwareBuffer hwBuffer =
               HardwareBuffer.create(
                   512, 512, HardwareBuffer.RGBA_8888, 1, HardwareBuffer.USAGE_CPU_WRITE_RARELY)) {
-            Bitmap bitmap = Bitmap.wrapHardwareBuffer(hwBuffer, ColorSpace.get(Named.SRGB));
+            Bitmap.wrapHardwareBuffer(hwBuffer, ColorSpace.get(Named.SRGB));
           }
         });
   }
@@ -452,7 +452,7 @@ public class ShadowNativeBitmapTest {
           try (HardwareBuffer hwBuffer =
               HardwareBuffer.create(
                   512, 512, HardwareBuffer.RGBA_8888, 1, HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE)) {
-            Bitmap bitmap = Bitmap.wrapHardwareBuffer(hwBuffer, ColorSpace.get(Named.CIE_LAB));
+            Bitmap.wrapHardwareBuffer(hwBuffer, ColorSpace.get(Named.CIE_LAB));
           }
         });
   }
@@ -587,7 +587,7 @@ public class ShadowNativeBitmapTest {
             bitmap.eraseColor(wideGamutLong);
 
             Color result = bitmap.getColor(0, 0);
-            if (bitmap.getColorSpace().equals(sRGB)) {
+            if (sRGB.equals(bitmap.getColorSpace())) {
               assertEquals(bitmap.getPixel(0, 0), result.toArgb());
             }
             if (eraseColorSpace.equals(bitmapColorSpace)) {
@@ -979,7 +979,7 @@ public class ShadowNativeBitmapTest {
       case ARGB_4444:
         // This shouldn't happen, since we don't allow creating or converting
         // to 4444.
-        assertFalse(true);
+        fail();
         break;
       case RGB_565:
         assertFalse(bitmap.hasAlpha());
@@ -1366,7 +1366,7 @@ public class ShadowNativeBitmapTest {
     Bitmap bitmap = Bitmap.createBitmap(1, 1, config);
     bitmap.setPremultiplied(true);
     bitmap.setPixel(0, 0, Color.TRANSPARENT);
-    assertTrue(bitmap.isPremultiplied() == expectedPremul);
+    assertEquals(bitmap.isPremultiplied(), expectedPremul);
 
     bitmap.setHasAlpha(false);
     assertFalse(bitmap.isPremultiplied());
@@ -1385,21 +1385,21 @@ public class ShadowNativeBitmapTest {
     // with premul, will store 2,2,2,2, so it doesn't get value correct
     Bitmap bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
     bitmap.setPixel(0, 0, PREMUL_COLOR);
-    assertEquals(bitmap.getPixel(0, 0), PREMUL_ROUNDED_COLOR);
+    assertEquals(PREMUL_ROUNDED_COLOR, bitmap.getPixel(0, 0));
 
     // read premultiplied value directly
     bitmap.setPremultiplied(false);
-    assertEquals(bitmap.getPixel(0, 0), PREMUL_STORED_COLOR);
+    assertEquals(PREMUL_STORED_COLOR, bitmap.getPixel(0, 0));
 
     // value can now be stored/read correctly
     bitmap.setPixel(0, 0, PREMUL_COLOR);
-    assertEquals(bitmap.getPixel(0, 0), PREMUL_COLOR);
+    assertEquals(PREMUL_COLOR, bitmap.getPixel(0, 0));
 
     // verify with array methods
     int[] testArray = new int[] {PREMUL_COLOR};
     bitmap.setPixels(testArray, 0, 1, 0, 0, 1, 1);
     bitmap.getPixels(testArray, 0, 1, 0, 0, 1, 1);
-    assertEquals(bitmap.getPixel(0, 0), PREMUL_COLOR);
+    assertEquals(PREMUL_COLOR, bitmap.getPixel(0, 0));
   }
 
   @Test
@@ -1832,8 +1832,6 @@ public class ShadowNativeBitmapTest {
     }
   }
 
-  static final int ANDROID_BITMAP_FORMAT_RGBA_8888 = 1;
-
   private static int scaleFromDensity(int size, int sdensity, int tdensity) {
     if (sdensity == Bitmap.DENSITY_NONE || sdensity == tdensity) {
       return size;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBlendModeColorFilterTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBlendModeColorFilterTest.java
index 574b52145..35d714b0f 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBlendModeColorFilterTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBlendModeColorFilterTest.java
@@ -19,8 +19,6 @@ import org.robolectric.annotation.Config;
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = Q) // Added in API 29
 public class ShadowNativeBlendModeColorFilterTest {
-  private static final int TOLERANCE = 5;
-
   private static final int TEST_WIDTH = 90;
   private static final int TEST_HEIGHT = 90;
   private static final int LEFT_X = TEST_WIDTH / 4;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
index 9aac3a05f..fb01a61ca 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
@@ -881,7 +881,7 @@ public class ShadowNativeColorSpaceTest {
     }
   }
 
-  private static float[] identityMatrix =
+  private static final float[] identityMatrix =
       new float[] {
         1.0f, 0.0f, 0.0f,
         0.0f, 1.0f, 0.0f,
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererObserverTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererObserverTest.java
index e67a2f70a..c4e241ab6 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererObserverTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererObserverTest.java
@@ -18,19 +18,18 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 @RunWith(RobolectricTestRunner.class)
 public class ShadowNativeHardwareRendererObserverTest {
 
+  @SuppressWarnings("CheckReturnValue")
   @Test
   public void test_hardwareRenderer() {
     OnFrameMetricsAvailableListener listener = i -> {};
     if (RuntimeEnvironment.getApiLevel() >= S) {
-      HardwareRendererObserver unused =
-          new HardwareRendererObserver(listener, new long[0], new Handler(), false);
+      new HardwareRendererObserver(listener, new long[0], new Handler(), false);
     } else {
-      HardwareRendererObserver unused =
-          ReflectionHelpers.callConstructor(
-              HardwareRendererObserver.class,
-              ClassParameter.from(OnFrameMetricsAvailableListener.class, listener),
-              ClassParameter.from(long[].class, new long[0]),
-              ClassParameter.from(Handler.class, new Handler()));
+      ReflectionHelpers.callConstructor(
+          HardwareRendererObserver.class,
+          ClassParameter.from(OnFrameMetricsAvailableListener.class, listener),
+          ClassParameter.from(long[].class, new long[0]),
+          ClassParameter.from(Handler.class, new Handler()));
     }
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java
index 94da9cc26..020e5d554 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java
@@ -33,9 +33,10 @@ import org.robolectric.versioning.AndroidVersions.V;
 @RunWith(RobolectricTestRunner.class)
 public class ShadowNativeHardwareRendererTest {
 
+  @SuppressWarnings("CheckReturnValue")
   @Test
   public void test_hardwareRenderer() {
-    HardwareRenderer unused = new HardwareRenderer();
+    new HardwareRenderer();
   }
 
   @Config(maxSdk = R)
@@ -50,7 +51,7 @@ public class ShadowNativeHardwareRendererTest {
   public void choreographer_firstCalled() {
     // In some SDK levels, the Choreographer constructor ends up calling
     // HardwareRenderer.nHackySetRTAnimationsEnabled. Ensure that RNG is loaded if this happens.
-    var unused = Choreographer.getInstance();
+    Choreographer.getInstance();
   }
 
   @Test
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java
index ed9cded3b..6c04d87ad 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java
@@ -96,33 +96,35 @@ public class ShadowNativeImageReaderTest {
 
   @Test
   public void imageReader_lockHardwareCanvas_drawColor() {
-    ImageReader reader = ImageReader.newInstance(100, 100, PixelFormat.RGBA_8888, 1);
-    Surface surface = reader.getSurface();
-    Canvas canvas = surface.lockHardwareCanvas();
-    canvas.drawColor(Color.RED);
-    surface.unlockCanvasAndPost(canvas);
-    Image image = reader.acquireNextImage();
-    assertThat(image).isNotNull();
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Plane[] planes = image.getPlanes();
-    bitmap.copyPixelsFromBuffer(planes[0].getBuffer());
-    surface.release();
-    assertThat(Integer.toHexString(bitmap.getPixel(50, 50)))
-        .isEqualTo(Integer.toHexString(Color.RED));
+    try (ImageReader reader = ImageReader.newInstance(100, 100, PixelFormat.RGBA_8888, 1)) {
+      Surface surface = reader.getSurface();
+      Canvas canvas = surface.lockHardwareCanvas();
+      canvas.drawColor(Color.RED);
+      surface.unlockCanvasAndPost(canvas);
+      Image image = reader.acquireNextImage();
+      assertThat(image).isNotNull();
+      Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+      Plane[] planes = image.getPlanes();
+      bitmap.copyPixelsFromBuffer(planes[0].getBuffer());
+      surface.release();
+      assertThat(Integer.toHexString(bitmap.getPixel(50, 50)))
+          .isEqualTo(Integer.toHexString(Color.RED));
+    }
   }
 
   @Test
-  public void testGetHardwareBuffer() throws Exception {
-    ImageReader reader = ImageReader.newInstance(1, 1, PixelFormat.RGBA_8888, 1);
-    Surface surface = reader.getSurface();
-    Canvas canvas = surface.lockHardwareCanvas();
-    canvas.drawColor(Color.RED);
-    surface.unlockCanvasAndPost(canvas);
-    Image image = reader.acquireNextImage();
-    assertThat(image).isNotNull();
-    HardwareBuffer buffer = image.getHardwareBuffer();
-    // TODO(hoisie): buffer should not be null, but fixing it will require an implementation of
-    // HardwareBuffer on host libandroid_runtime.
-    assertThat(buffer).isNull();
+  public void testGetHardwareBuffer() {
+    try (ImageReader reader = ImageReader.newInstance(1, 1, PixelFormat.RGBA_8888, 1)) {
+      Surface surface = reader.getSurface();
+      Canvas canvas = surface.lockHardwareCanvas();
+      canvas.drawColor(Color.RED);
+      surface.unlockCanvasAndPost(canvas);
+      Image image = reader.acquireNextImage();
+      assertThat(image).isNotNull();
+      HardwareBuffer buffer = image.getHardwareBuffer();
+      // TODO(hoisie): buffer should not be null, but fixing it will require an implementation of
+      // HardwareBuffer on host libandroid_runtime.
+      assertThat(buffer).isNull();
+    }
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLineBreakerTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLineBreakerTest.java
index a318ce90a..5a42ec74e 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLineBreakerTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLineBreakerTest.java
@@ -30,13 +30,9 @@ import org.robolectric.annotation.Config;
 @RunWith(RobolectricTestRunner.class)
 public class ShadowNativeLineBreakerTest {
 
-  private static final String TAG = "LineBreakerTest";
-
-  private static Paint paint;
-
   @Before
   public void setup() {
-    paint = new Paint();
+    Paint paint = new Paint();
     Context context = RuntimeEnvironment.getApplication();
     AssetManager am = context.getAssets();
     Typeface tf = new Typeface.Builder(am, "fonts/layout/linebreak.ttf").build();
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLinearGradientTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLinearGradientTest.java
index 76ea26e76..4e4c475cf 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLinearGradientTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeLinearGradientTest.java
@@ -67,15 +67,11 @@ public class ShadowNativeLinearGradientTest {
     long green = Color.pack(0, 1, 0, 1, p3);
     long blue = Color.pack(0, 0, 1, 1, p3);
     long[] colors = new long[] {blue, green, red};
-    float[] positions = null;
 
-    LinearGradient lg = new LinearGradient(0, 0, 0, 40, colors, positions, TileMode.CLAMP);
+    LinearGradient lg = new LinearGradient(0, 0, 0, 40, colors, null, TileMode.CLAMP);
     Bitmap b = drawLinearGradient(lg, Bitmap.Config.RGBA_F16);
     final ColorSpace bitmapColorSpace = b.getColorSpace();
-    Function<Long, Color> convert =
-        (l) -> {
-          return Color.valueOf(Color.convert(l, bitmapColorSpace));
-        };
+    Function<Long, Color> convert = (l) -> Color.valueOf(Color.convert(l, bitmapColorSpace));
 
     ColorUtils.verifyColor(
         "Top-most color should be mostly blue!", convert.apply(blue), b.getColor(0, 0), 0.09f);
@@ -152,10 +148,7 @@ public class ShadowNativeLinearGradientTest {
     int[] colors = null;
     assertThrows(
         NullPointerException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -164,10 +157,7 @@ public class ShadowNativeLinearGradientTest {
     long[] colors = null;
     assertThrows(
         NullPointerException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -175,10 +165,7 @@ public class ShadowNativeLinearGradientTest {
   public void testNoColorInts() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, new int[0], null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, new int[0], null, TileMode.CLAMP));
   }
 
   @Test
@@ -186,10 +173,7 @@ public class ShadowNativeLinearGradientTest {
   public void testNoColorLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, new long[0], null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, new long[0], null, TileMode.CLAMP));
   }
 
   @Test
@@ -197,10 +181,7 @@ public class ShadowNativeLinearGradientTest {
   public void testOneColorInts() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, new int[1], null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, new int[1], null, TileMode.CLAMP));
   }
 
   @Test
@@ -208,10 +189,7 @@ public class ShadowNativeLinearGradientTest {
   public void testOneColorLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, new long[1], null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, new long[1], null, TileMode.CLAMP));
   }
 
   @Test
@@ -222,10 +200,7 @@ public class ShadowNativeLinearGradientTest {
     colors[1] = Color.pack(.5f, .5f, .5f, 1.0f, ColorSpace.get(ColorSpace.Named.DISPLAY_P3));
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -235,10 +210,7 @@ public class ShadowNativeLinearGradientTest {
     long color1 = Color.pack(.5f, .5f, .5f, 1.0f, ColorSpace.get(ColorSpace.Named.DISPLAY_P3));
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, color0, color1, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, color0, color1, TileMode.CLAMP));
   }
 
   @Test
@@ -246,10 +218,7 @@ public class ShadowNativeLinearGradientTest {
   public void testMismatchPositionsInts() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, new int[2], new float[3], TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, new int[2], new float[3], TileMode.CLAMP));
   }
 
   @Test
@@ -257,24 +226,16 @@ public class ShadowNativeLinearGradientTest {
   public void testMismatchPositionsLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, new long[2], new float[3], TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, new long[2], new float[3], TileMode.CLAMP));
   }
 
   @Test
   @Config(minSdk = Q)
   public void testInvalidColorLongs() {
-    long[] colors = new long[2];
-    colors[0] = -1L;
-    colors[0] = -2L;
+    long[] colors = new long[] {-1L, -2L};
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -282,10 +243,7 @@ public class ShadowNativeLinearGradientTest {
   public void testInvalidColorLong() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, -1L, Color.pack(Color.RED), TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, -1L, Color.pack(Color.RED), TileMode.CLAMP));
   }
 
   @Test
@@ -293,9 +251,6 @@ public class ShadowNativeLinearGradientTest {
   public void testInvalidColorLong2() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          LinearGradient unused =
-              new LinearGradient(0.5f, 0, 1.5f, 0, Color.pack(Color.RED), -1L, TileMode.CLAMP);
-        });
+        () -> new LinearGradient(0.5f, 0, 1.5f, 0, Color.pack(Color.RED), -1L, TileMode.CLAMP));
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMaskFilterTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMaskFilterTest.java
index 34e48b991..f484beaa8 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMaskFilterTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMaskFilterTest.java
@@ -11,8 +11,9 @@ import org.robolectric.annotation.Config;
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = O)
 public class ShadowNativeMaskFilterTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test
   public void testConstructor() {
-    var unused = new MaskFilter();
+    new MaskFilter();
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMeasuredParagraphTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMeasuredParagraphTest.java
index cba45b374..c02eafc16 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMeasuredParagraphTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeMeasuredParagraphTest.java
@@ -140,9 +140,8 @@ public class ShadowNativeMeasuredParagraphTest {
   public void buildForStaticLayout() {
 
     MeasuredParagraph mt =
-        (MeasuredParagraph)
-            reflector(MeasuredParagraphReflector.class)
-                .buildForStaticLayout(paint, "XXX", 0, 3, LTR, false, false, null);
+        reflector(MeasuredParagraphReflector.class)
+            .buildForStaticLayout(paint, "XXX", 0, 3, LTR, false, false, null);
     assertNotNull(mt);
     assertNotNull(mt.getChars());
     assertEquals("XXX", charsToString(mt.getChars()));
@@ -157,9 +156,8 @@ public class ShadowNativeMeasuredParagraphTest {
 
     // Recycle it
     MeasuredParagraph mt2 =
-        (MeasuredParagraph)
-            reflector(MeasuredParagraphReflector.class)
-                .buildForStaticLayout(paint, "_VVV_", 1, 4, RTL, false, false, mt);
+        reflector(MeasuredParagraphReflector.class)
+            .buildForStaticLayout(paint, "_VVV_", 1, 4, RTL, false, false, mt);
     assertEquals(mt2, mt);
     assertNotNull(mt2.getChars());
     assertEquals("VVV", charsToString(mt.getChars()));
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
index aa62c359f..37297c0f9 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
@@ -13,6 +13,7 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
@@ -890,7 +891,7 @@ public class ShadowNativePaintTest {
   }
 
   @Test
-  public void testGetTextWidths() throws Exception {
+  public void testGetTextWidths() {
     String text = "HIJKLMN";
     char[] textChars = text.toCharArray();
     SpannedString textSpan = new SpannedString(text);
@@ -1383,8 +1384,8 @@ public class ShadowNativePaintTest {
     }
 
     float totalWidth = 0;
-    for (int i = 0; i < widths.length; i++) {
-      totalWidth += widths[i];
+    for (float width : widths) {
+      totalWidth += width;
     }
 
     // Test measuring the widths of the entire text
@@ -1579,10 +1580,9 @@ public class ShadowNativePaintTest {
 
     // We don't require gender-neutral emoji, but if present, results must be consistent
     // whether VS is present or not.
-    assertTrue(
-        p.hasGlyph("\uD83D\uDC69\u200D\u2695")
-            == // WOMAN, ZWJ, STAFF OF AESCULAPIUS
-            p.hasGlyph("\uD83D\uDC69\u200D\u2695\uFE0F")); // above + VS16
+    assertEquals(
+        p.hasGlyph("\uD83D\uDC69\u200D\u2695"), // WOMAN, ZWJ, STAFF OF AESCULAPIUS
+        p.hasGlyph("\uD83D\uDC69\u200D\u2695\uFE0F")); // above + VS16
   }
 
   @Test
@@ -1940,7 +1940,7 @@ public class ShadowNativePaintTest {
         final int offset =
             p.getOffsetForAdvance(
                 string, 0, string.length(), 0, string.length(), false, widthToOffset);
-        assertFalse(1 == offset);
+        assertNotEquals(1, offset);
         assertTrue(0 == offset || string.length() == offset);
       }
     }
@@ -1952,7 +1952,7 @@ public class ShadowNativePaintTest {
         final int offset =
             p.getOffsetForAdvance(
                 string, 0, string.length(), 0, string.length(), false, widthToOffset);
-        assertFalse(2 == offset);
+        assertNotEquals(2, offset);
         assertTrue(0 == offset || string.length() == offset);
       }
       {
@@ -2104,7 +2104,7 @@ public class ShadowNativePaintTest {
   }
 
   @Test
-  public void testGetRunCursor_currsor_at() {
+  public void testGetRunCursor_cursor_at() {
     assertEquals(0, getTextRunCursor("abc", 0, CURSOR_AT));
     assertEquals(1, getTextRunCursor("abc", 1, CURSOR_AT));
     assertEquals(2, getTextRunCursor("abc", 2, CURSOR_AT));
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathEffectTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathEffectTest.java
index 551150988..64309f8ce 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathEffectTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathEffectTest.java
@@ -12,8 +12,9 @@ import org.robolectric.annotation.Config;
 @Config(minSdk = O)
 public class ShadowNativePathEffectTest {
 
+  @SuppressWarnings("CheckReturnValue")
   @Test
   public void testConstructor() {
-    var unused = new PathEffect();
+    new PathEffect();
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
index 12ec2b0ef..9d83519e8 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
@@ -383,7 +383,7 @@ public class ShadowNativePathIteratorTest {
       PathIterator iterator = mPath.getPathIterator();
       assertEquals(PathIterator.VERB_MOVE, iterator.next(pointsArray, offset));
       assertEquals(PathIterator.VERB_LINE, iterator.next(pointsArray, offset));
-      assertEquals(0f, pointsArray[offset + 0], 0f);
+      assertEquals(0f, pointsArray[offset], 0f);
       assertEquals(0f, pointsArray[offset + 1], 0f);
       assertEquals(100f, pointsArray[offset + 2], 0f);
       assertEquals(200f, pointsArray[offset + 3], 0f);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathMeasureTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathMeasureTest.java
index 0780bb30a..2096ae340 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathMeasureTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathMeasureTest.java
@@ -67,10 +67,7 @@ public class ShadowNativePathMeasureTest {
     float[] tan = {1f};
 
     assertThrows(
-        ArrayIndexOutOfBoundsException.class,
-        () -> {
-          pathMeasure.getPosTan(distance, pos, tan);
-        });
+        ArrayIndexOutOfBoundsException.class, () -> pathMeasure.getPosTan(distance, pos, tan));
   }
 
   @Test
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathTest.java
index cc47cb54a..c3edc1797 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathTest.java
@@ -439,10 +439,7 @@ public class ShadowNativePathTest {
   public void legacyShadowPathAPIs_notSupported() {
     Path path = new Path();
     assertThrows(
-        UnsupportedOperationException.class,
-        () -> {
-          ((ShadowPath) Shadow.extract(path)).getPoints();
-        });
+        UnsupportedOperationException.class, () -> ((ShadowPath) Shadow.extract(path)).getPoints());
   }
 
   private void addRectToPath(Path path) {
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePictureTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePictureTest.java
index 695ff374a..cf02dc6b1 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePictureTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePictureTest.java
@@ -78,7 +78,7 @@ public class ShadowNativePictureTest {
 
     assertEquals(beforeSaveCount, canvas.getSaveCount());
 
-    assertTrue(beforeMatrix.equals(canvas.getMatrix()));
+    assertEquals(beforeMatrix, canvas.getMatrix());
 
     Rect afterClip = new Rect();
 
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePropertyValuesHolderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePropertyValuesHolderTest.java
index 2bb95a68b..999977e8f 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePropertyValuesHolderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePropertyValuesHolderTest.java
@@ -4,7 +4,6 @@ import static android.os.Build.VERSION_CODES.O;
 import static org.junit.Assert.assertEquals;
 
 import android.animation.PropertyValuesHolder;
-import android.app.Instrumentation;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.platform.app.InstrumentationRegistry;
 import org.junit.Before;
@@ -16,15 +15,13 @@ import org.robolectric.annotation.Config;
 @Config(minSdk = O)
 public class ShadowNativePropertyValuesHolderTest {
 
-  private Instrumentation instrumentation;
   private float startY;
   private float endY;
   private String property;
 
   @Before
   public void setup() {
-    instrumentation = InstrumentationRegistry.getInstrumentation();
-    instrumentation.setInTouchMode(false);
+    InstrumentationRegistry.getInstrumentation().setInTouchMode(false);
     property = "y";
     startY = 0;
     endY = 10;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRadialGradientTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRadialGradientTest.java
index ab47b9ad7..997d747e1 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRadialGradientTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRadialGradientTest.java
@@ -62,10 +62,7 @@ public class ShadowNativeRadialGradientTest {
     canvas.drawPaint(paint);
 
     final ColorSpace bitmapColorSpace = bitmap.getColorSpace();
-    Function<Long, Color> convert =
-        (l) -> {
-          return Color.valueOf(Color.convert(l, bitmapColorSpace));
-        };
+    Function<Long, Color> convert = (l) -> Color.valueOf(Color.convert(l, bitmapColorSpace));
 
     final Color centerColor = bitmap.getColor(50, 50);
     ColorUtils.verifyColor("Center color should be red!", convert.apply(red), centerColor, 0.034f);
@@ -147,9 +144,7 @@ public class ShadowNativeRadialGradientTest {
     int[] colors = null;
     assertThrows(
         NullPointerException.class,
-        () -> {
-          RadialGradient unused = new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -158,19 +153,14 @@ public class ShadowNativeRadialGradientTest {
     long[] colors = null;
     assertThrows(
         NullPointerException.class,
-        () -> {
-          RadialGradient unused = new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP));
   }
 
   @Test
   public void testNoColorInts() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, new int[0], null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, new int[0], null, TileMode.CLAMP));
   }
 
   @Test
@@ -178,20 +168,14 @@ public class ShadowNativeRadialGradientTest {
   public void testNoColorLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, new long[0], null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, new long[0], null, TileMode.CLAMP));
   }
 
   @Test
   public void testOneColorInts() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, new int[1], null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, new int[1], null, TileMode.CLAMP));
   }
 
   @Test
@@ -199,10 +183,7 @@ public class ShadowNativeRadialGradientTest {
   public void testOneColorLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, new long[1], null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, new long[1], null, TileMode.CLAMP));
   }
 
   @Test
@@ -213,9 +194,7 @@ public class ShadowNativeRadialGradientTest {
     colors[1] = Color.pack(.5f, .5f, .5f, 1.0f, ColorSpace.get(ColorSpace.Named.DISPLAY_P3));
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused = new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -225,9 +204,7 @@ public class ShadowNativeRadialGradientTest {
     long color1 = Color.pack(.5f, .5f, .5f, 1.0f, ColorSpace.get(ColorSpace.Named.DISPLAY_P3));
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused = new RadialGradient(0.5f, 0.5f, 1, color0, color1, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, color0, color1, TileMode.CLAMP));
   }
 
   @Test
@@ -235,10 +212,7 @@ public class ShadowNativeRadialGradientTest {
   public void testMismatchPositionsInts() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, new int[2], new float[3], TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, new int[2], new float[3], TileMode.CLAMP));
   }
 
   @Test
@@ -246,23 +220,16 @@ public class ShadowNativeRadialGradientTest {
   public void testMismatchPositionsLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, new long[2], new float[3], TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, new long[2], new float[3], TileMode.CLAMP));
   }
 
   @Test
   @Config(minSdk = Q)
   public void testInvalidColorLongs() {
-    long[] colors = new long[2];
-    colors[0] = -1L;
-    colors[0] = -2L;
+    long[] colors = new long[] {-1L, -2L};
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused = new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, colors, null, TileMode.CLAMP));
   }
 
   @Test
@@ -270,10 +237,7 @@ public class ShadowNativeRadialGradientTest {
   public void testInvalidColorLong() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, -1L, Color.pack(Color.RED), TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, -1L, Color.pack(Color.RED), TileMode.CLAMP));
   }
 
   @Test
@@ -281,10 +245,7 @@ public class ShadowNativeRadialGradientTest {
   public void testInvalidColorLong2() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 1, Color.pack(Color.RED), -1L, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 1, Color.pack(Color.RED), -1L, TileMode.CLAMP));
   }
 
   @Test
@@ -292,10 +253,7 @@ public class ShadowNativeRadialGradientTest {
   public void testZeroRadius() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(0.5f, 0.5f, 0, Color.RED, Color.BLUE, TileMode.CLAMP);
-        });
+        () -> new RadialGradient(0.5f, 0.5f, 0, Color.RED, Color.BLUE, TileMode.CLAMP));
   }
 
   @Test
@@ -303,11 +261,9 @@ public class ShadowNativeRadialGradientTest {
   public void testZeroRadiusArray() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(
-                  0.5f, 0.5f, 0, new int[] {Color.RED, Color.BLUE}, null, TileMode.CLAMP);
-        });
+        () ->
+            new RadialGradient(
+                0.5f, 0.5f, 0, new int[] {Color.RED, Color.BLUE}, null, TileMode.CLAMP));
   }
 
   @Test
@@ -315,11 +271,9 @@ public class ShadowNativeRadialGradientTest {
   public void testZeroRadiusLong() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(
-                  0.5f, 0.5f, 0, Color.pack(Color.RED), Color.pack(Color.BLUE), TileMode.CLAMP);
-        });
+        () ->
+            new RadialGradient(
+                0.5f, 0.5f, 0, Color.pack(Color.RED), Color.pack(Color.BLUE), TileMode.CLAMP));
   }
 
   @Test
@@ -327,15 +281,13 @@ public class ShadowNativeRadialGradientTest {
   public void testZeroRadiusLongArray() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          RadialGradient unused =
-              new RadialGradient(
-                  0.5f,
-                  0.5f,
-                  0,
-                  new long[] {Color.pack(Color.RED), Color.pack(Color.BLUE)},
-                  null,
-                  TileMode.CLAMP);
-        });
+        () ->
+            new RadialGradient(
+                0.5f,
+                0.5f,
+                0,
+                new long[] {Color.pack(Color.RED), Color.pack(Color.BLUE)},
+                null,
+                TileMode.CLAMP));
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRegionTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRegionTest.java
index 11c7d83e4..3b7e53443 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRegionTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRegionTest.java
@@ -123,14 +123,14 @@ public class ShadowNativeRegionTest {
   private Region region;
 
   private void verifyPointsInsideRegion(int[][] area) {
-    for (int i = 0; i < area.length; i++) {
-      assertTrue(region.contains(area[i][0], area[i][1]));
+    for (int[] ints : area) {
+      assertTrue(region.contains(ints[0], ints[1]));
     }
   }
 
   private void verifyPointsOutsideRegion(int[][] area) {
-    for (int i = 0; i < area.length; i++) {
-      assertFalse(region.contains(area[i][0], area[i][1]));
+    for (int[] ints : area) {
+      assertFalse(region.contains(ints[0], ints[1]));
     }
   }
 
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRenderNodeTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRenderNodeTest.java
index 5b4853804..f6d9cc138 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRenderNodeTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRenderNodeTest.java
@@ -254,7 +254,7 @@ public class ShadowNativeRenderNodeTest {
 
   @Test
   @Config(minSdk = O, maxSdk = P)
-  public void testIsValid() throws Exception {
+  public void testIsValid() {
     Object renderNode = reflector(RenderNodeOpReflector.class).create("name", null);
     RenderNodeOpReflector renderNodeOpReflector =
         reflector(RenderNodeOpReflector.class, renderNode);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java
index 807ef97d7..c8b203c22 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java
@@ -61,18 +61,18 @@ public class ShadowNativeRuntimeShaderTest {
   @Config(minSdk = S, maxSdk = S_V2)
   @Test
   public void testConstructor() {
-    var unused =
-        ReflectionHelpers.callConstructor(
-            RuntimeShader.class,
-            ClassParameter.from(String.class, SKSL),
-            ClassParameter.from(boolean.class, false));
+    ReflectionHelpers.callConstructor(
+        RuntimeShader.class,
+        ClassParameter.from(String.class, SKSL),
+        ClassParameter.from(boolean.class, false));
   }
 
   /** {@link #SKSL} does not compile on V and above. */
+  @SuppressWarnings("CheckReturnValue")
   @Config(minSdk = TIRAMISU, maxSdk = U.SDK_INT)
   @Test
   public void testConstructorT() {
-    var unused = new RuntimeShader(SKSL);
+    new RuntimeShader(SKSL);
   }
 
   @Test
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeShaderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeShaderTest.java
index fd6e428d5..ff9d0cbb7 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeShaderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeShaderTest.java
@@ -20,9 +20,10 @@ import org.robolectric.annotation.Config;
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = O)
 public class ShadowNativeShaderTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test
   public void testConstructor() {
-    var unused = new Shader();
+    new Shader();
   }
 
   @Test
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeStaticLayoutTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeStaticLayoutTest.java
index bac4f09e8..112998995 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeStaticLayoutTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeStaticLayoutTest.java
@@ -62,6 +62,7 @@ import java.text.Normalizer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -99,7 +100,7 @@ public class ShadowNativeStaticLayoutTest {
   /* the first line must have one tab. the others not. totally 6 lines
    */
   private static final CharSequence LAYOUT_TEXT =
-      "CharSe\tq\nChar" + "Sequence\nCharSequence\nHelllo\n, world\nLongLongLong";
+      "CharSe\tq\nChar" + "Sequence\nCharSequence\nHello\n, world\nLongLongLong";
 
   private static final CharSequence LAYOUT_TEXT_SINGLE_LINE = "CharSequence";
 
@@ -269,7 +270,7 @@ public class ShadowNativeStaticLayoutTest {
       StaticLayout layout = builder.build();
       assertEquals(ELLIPSIZE_WIDTH, layout.getEllipsizedWidth());
       assertEquals(DEFAULT_OUTER_WIDTH, layout.getWidth());
-      assertTrue(layout.getEllipsisCount(0) == 0);
+      assertEquals(0, layout.getEllipsisCount(0));
       assertTrue(layout.getEllipsisCount(5) > 0);
     }
     {
@@ -480,7 +481,7 @@ public class ShadowNativeStaticLayoutTest {
   /**
    * Returns an array of directionalities for the specified line. The array alternates counts of
    * characters in left-to-right and right-to-left segments of the line. We can not check the return
-   * value, for Directions's field is package private So only check it not null
+   * value, for Directions' field is package private So only check it not null
    */
   @Test
   public void testGetLineDirections() {
@@ -523,12 +524,12 @@ public class ShadowNativeStaticLayoutTest {
     // Multilines (6 lines) and TruncateAt.START so no ellipsis at all
     defaultLayout = createEllipsizeStaticLayout(LAYOUT_TEXT, TextUtils.TruncateAt.MIDDLE);
 
-    assertTrue(defaultLayout.getEllipsisCount(0) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(1) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(2) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(3) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(4) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(5) == 0);
+    assertEquals(0, defaultLayout.getEllipsisCount(0));
+    assertEquals(0, defaultLayout.getEllipsisCount(1));
+    assertEquals(0, defaultLayout.getEllipsisCount(2));
+    assertEquals(0, defaultLayout.getEllipsisCount(3));
+    assertEquals(0, defaultLayout.getEllipsisCount(4));
+    assertEquals(0, defaultLayout.getEllipsisCount(5));
 
     assertThrows(ArrayIndexOutOfBoundsException.class, () -> defaultLayout.getEllipsisCount(-1));
 
@@ -539,31 +540,31 @@ public class ShadowNativeStaticLayoutTest {
     // Multilines (6 lines) and TruncateAt.MIDDLE so no ellipsis at all
     defaultLayout = createEllipsizeStaticLayout(LAYOUT_TEXT, TextUtils.TruncateAt.MIDDLE);
 
-    assertTrue(defaultLayout.getEllipsisCount(0) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(1) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(2) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(3) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(4) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(5) == 0);
+    assertEquals(0, defaultLayout.getEllipsisCount(0));
+    assertEquals(0, defaultLayout.getEllipsisCount(1));
+    assertEquals(0, defaultLayout.getEllipsisCount(2));
+    assertEquals(0, defaultLayout.getEllipsisCount(3));
+    assertEquals(0, defaultLayout.getEllipsisCount(4));
+    assertEquals(0, defaultLayout.getEllipsisCount(5));
 
     // Multilines (6 lines) and TruncateAt.END so ellipsis only on the last line
     defaultLayout = createEllipsizeStaticLayout(LAYOUT_TEXT, TextUtils.TruncateAt.END);
 
-    assertTrue(defaultLayout.getEllipsisCount(0) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(1) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(2) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(3) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(4) == 0);
+    assertEquals(0, defaultLayout.getEllipsisCount(0));
+    assertEquals(0, defaultLayout.getEllipsisCount(1));
+    assertEquals(0, defaultLayout.getEllipsisCount(2));
+    assertEquals(0, defaultLayout.getEllipsisCount(3));
+    assertEquals(0, defaultLayout.getEllipsisCount(4));
     assertTrue(defaultLayout.getEllipsisCount(5) > 0);
 
     // Multilines (6 lines) and TruncateAt.MARQUEE so ellipsis only on the last line
     defaultLayout = createEllipsizeStaticLayout(LAYOUT_TEXT, TextUtils.TruncateAt.END);
 
-    assertTrue(defaultLayout.getEllipsisCount(0) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(1) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(2) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(3) == 0);
-    assertTrue(defaultLayout.getEllipsisCount(4) == 0);
+    assertEquals(0, defaultLayout.getEllipsisCount(0));
+    assertEquals(0, defaultLayout.getEllipsisCount(1));
+    assertEquals(0, defaultLayout.getEllipsisCount(2));
+    assertEquals(0, defaultLayout.getEllipsisCount(3));
+    assertEquals(0, defaultLayout.getEllipsisCount(4));
     assertTrue(defaultLayout.getEllipsisCount(5) > 0);
   }
 
@@ -655,7 +656,7 @@ public class ShadowNativeStaticLayoutTest {
 
   // String wrapper for testing not well known implementation of CharSequence.
   private static class FakeCharSequence implements CharSequence {
-    private String str;
+    private final String str;
 
     public FakeCharSequence(String str) {
       this.str = str;
@@ -672,11 +673,13 @@ public class ShadowNativeStaticLayoutTest {
     }
 
     @Override
+    @Nonnull
     public CharSequence subSequence(int start, int end) {
       return str.subSequence(start, end);
     }
 
     @Override
+    @Nonnull
     public String toString() {
       return str;
     }
@@ -716,13 +719,13 @@ public class ShadowNativeStaticLayoutTest {
 
     StringBuilder builder = new StringBuilder();
     for (int i = 0; i < seq.length(); ++i) {
-      builder.append(String.format("0x%04X ", Integer.valueOf(seq.charAt(i))));
+      builder.append(String.format("0x%04X ", (int) seq.charAt(i)));
     }
 
     return "testString: \""
-        + seq.toString()
+        + seq
         + "\"["
-        + builder.toString()
+        + builder
         + "]"
         + ", class: "
         + seq.getClass().getName()
@@ -1527,6 +1530,7 @@ public class ShadowNativeStaticLayoutTest {
     }
 
     @Override
+    @Nonnull
     public String toString() {
       return "{"
           + "mStrategy="
@@ -1820,19 +1824,19 @@ public class ShadowNativeStaticLayoutTest {
     private final List<int[]> history;
 
     FakeLineBackgroundSpan() {
-      history = new ArrayList<int[]>();
+      history = new ArrayList<>();
     }
 
     @Override
     public void drawBackground(
-        Canvas c,
-        Paint p,
+        @Nonnull Canvas c,
+        @Nonnull Paint p,
         int left,
         int right,
         int top,
         int baseline,
         int bottom,
-        CharSequence text,
+        @Nonnull CharSequence text,
         int start,
         int end,
         int lnum) {
@@ -1934,7 +1938,7 @@ public class ShadowNativeStaticLayoutTest {
         Bitmap.createBitmap(layout.getWidth(), layout.getHeight(), Bitmap.Config.RGB_565);
     final Canvas c = new Canvas(bmp);
     // Make sure draw won't cause crashes.
-    // draw eventualy calls TextLine.draw which was the problematic method.
+    // draw eventually calls TextLine.draw which was the problematic method.
     layout.draw(c);
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeSweepGradientTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeSweepGradientTest.java
index 8438eaa34..a0e5be563 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeSweepGradientTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeSweepGradientTest.java
@@ -163,60 +163,40 @@ public class ShadowNativeSweepGradientTest {
   @Test
   public void testNullColorInts() {
     int[] colors = null;
-    assertThrows(
-        NullPointerException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, colors, null);
-        });
+    assertThrows(NullPointerException.class, () -> new SweepGradient(1, 0.5f, colors, null));
   }
 
   @Test
   @Config(minSdk = Q)
   public void testNullColorLongs() {
     long[] colors = null;
-    assertThrows(
-        NullPointerException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, colors, null);
-        });
+    assertThrows(NullPointerException.class, () -> new SweepGradient(1, 0.5f, colors, null));
   }
 
   @Test
   public void testNoColorInts() {
     assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, new int[0], null);
-        });
+        IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, new int[0], null));
   }
 
   @Test
   @Config(minSdk = Q)
   public void testNoColorLongs() {
     assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, new long[0], null);
-        });
+        IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, new long[0], null));
   }
 
   @Test
   public void testOneColorInts() {
     assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, new int[1], null);
-        });
+        IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, new int[1], null));
   }
 
   @Test
   @Config(minSdk = Q)
   public void testOneColorLongs() {
     assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, new long[1], null);
-        });
+        IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, new long[1], null));
   }
 
   @Test
@@ -225,11 +205,7 @@ public class ShadowNativeSweepGradientTest {
     long[] colors = new long[2];
     colors[0] = Color.pack(Color.BLUE);
     colors[1] = Color.pack(.5f, .5f, .5f, 1.0f, ColorSpace.get(ColorSpace.Named.DISPLAY_P3));
-    assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, colors, null);
-        });
+    assertThrows(IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, colors, null));
   }
 
   @Test
@@ -237,20 +213,13 @@ public class ShadowNativeSweepGradientTest {
   public void testMismatchColorLongs2() {
     long color0 = Color.pack(Color.BLUE);
     long color1 = Color.pack(.5f, .5f, .5f, 1.0f, ColorSpace.get(ColorSpace.Named.DISPLAY_P3));
-    assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, color0, color1);
-        });
+    assertThrows(IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, color0, color1));
   }
 
   @Test
   public void testMismatchPositionsInts() {
     assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, new int[2], new float[3]);
-        });
+        IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, new int[2], new float[3]));
   }
 
   @Test
@@ -258,22 +227,14 @@ public class ShadowNativeSweepGradientTest {
   public void testMismatchPositionsLongs() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, new long[2], new float[3]);
-        });
+        () -> new SweepGradient(1, 0.5f, new long[2], new float[3]));
   }
 
   @Test
   @Config(minSdk = Q)
   public void testInvalidColorLongs() {
-    long[] colors = new long[2];
-    colors[0] = -1L;
-    colors[0] = -2L;
-    assertThrows(
-        IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, colors, null);
-        });
+    long[] colors = new long[] {-1L, -2L};
+    assertThrows(IllegalArgumentException.class, () -> new SweepGradient(1, 0.5f, colors, null));
   }
 
   @Test
@@ -281,9 +242,7 @@ public class ShadowNativeSweepGradientTest {
   public void testInvalidColorLong() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, -1L, Color.pack(Color.RED));
-        });
+        () -> new SweepGradient(1, 0.5f, -1L, Color.pack(Color.RED)));
   }
 
   @Test
@@ -291,9 +250,7 @@ public class ShadowNativeSweepGradientTest {
   public void testInvalidColorLong2() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> {
-          SweepGradient unused = new SweepGradient(1, 0.5f, Color.pack(Color.RED), -1L);
-        });
+        () -> new SweepGradient(1, 0.5f, Color.pack(Color.RED), -1L));
   }
 
   private String toString(double angle) {
@@ -317,10 +274,7 @@ public class ShadowNativeSweepGradientTest {
     canvas.drawPaint(paint);
 
     final ColorSpace bitmapColorSpace = bitmap.getColorSpace();
-    Function<Long, Color> convert =
-        (l) -> {
-          return Color.valueOf(Color.convert(l, bitmapColorSpace));
-        };
+    Function<Long, Color> convert = (l) -> Color.valueOf(Color.convert(l, bitmapColorSpace));
 
     Color lastColor = null;
     double lastAngle = 0;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeThreadedRendererTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeThreadedRendererTest.java
index 9cc85f741..61f2dcdca 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeThreadedRendererTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeThreadedRendererTest.java
@@ -15,7 +15,6 @@ import org.robolectric.annotation.Config;
 public class ShadowNativeThreadedRendererTest {
   @Test
   public void testInitialization() {
-    ThreadedRenderer unused =
-        ThreadedRenderer.create(ApplicationProvider.getApplicationContext(), false, "Name");
+    ThreadedRenderer.create(ApplicationProvider.getApplicationContext(), false, "Name");
   }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTypefaceTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTypefaceTest.java
index 0c9a6128c..717b2876c 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTypefaceTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTypefaceTest.java
@@ -183,19 +183,19 @@ public class ShadowNativeTypefaceTest {
   }
 
   @Test
-  public void testCreateFromFileWithInvalidPath() throws IOException {
+  public void testCreateFromFileWithInvalidPath() {
     File file = new File("/invalid/path");
     assertThrows(RuntimeException.class, () -> Typeface.createFromFile(file));
   }
 
   @Test
-  public void testCreateFromFileByFileNameNull() throws IOException {
+  public void testCreateFromFileByFileNameNull() {
     // input abnormal params.
     assertThrows(NullPointerException.class, () -> Typeface.createFromFile((String) null));
   }
 
   @Test
-  public void testCreateFromFileByInvalidFileName() throws IOException {
+  public void testCreateFromFileByInvalidFileName() {
     // input abnormal params.
     assertThrows(RuntimeException.class, () -> Typeface.createFromFile("/invalid/path"));
   }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java
index 1184f6164..5a6cc5171 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java
@@ -41,10 +41,10 @@ import android.graphics.drawable.Drawable.ConstantState;
 import android.graphics.drawable.VectorDrawable;
 import android.util.AttributeSet;
 import android.util.Xml;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.IOException;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -317,13 +317,13 @@ public class ShadowNativeVectorDrawableTest {
     }
 
     final StringBuilder builder = new StringBuilder();
-    for (int i = 0; i < stateSet.length; i++) {
-      final String state = resources.getResourceName(stateSet[i]);
+    for (int i : stateSet) {
+      final String state = resources.getResourceName(i);
       final int stateIndex = state.indexOf("state_");
       if (stateIndex >= 0) {
         builder.append(state.substring(stateIndex + 6));
       } else {
-        builder.append(stateSet[i]);
+        builder.append(i);
       }
     }
 
@@ -414,7 +414,7 @@ public class ShadowNativeVectorDrawableTest {
   }
 
   @Test
-  public void testGetOpacity() throws XmlPullParserException, IOException {
+  public void testGetOpacity() {
     VectorDrawable vectorDrawable = new VectorDrawable();
 
     assertEquals("Default alpha should be 255", 255, vectorDrawable.getAlpha());
@@ -466,7 +466,7 @@ public class ShadowNativeVectorDrawableTest {
   }
 
   @Test
-  public void testTint() throws IOException {
+  public void testTint() {
     Drawable drawable = resources.getDrawable(R.drawable.vector_icon_delete);
     drawable = drawable.mutate();
     drawable.setTint(Color.BLUE);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapcomparers/MSSIMComparer.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapcomparers/MSSIMComparer.java
index e9fcdd3ad..e9ef6d8d8 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapcomparers/MSSIMComparer.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapcomparers/MSSIMComparer.java
@@ -34,7 +34,7 @@ public class MSSIMComparer extends BitmapComparer {
   public static final double CONSTANT_C2 = Math.pow(CONSTANT_L * CONSTANT_K2, 2);
   public static final int WINDOW_SIZE = 10;
 
-  private double threshold;
+  private final double threshold;
 
   public MSSIMComparer(double threshold) {
     this.threshold = threshold;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorCountVerifier.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorCountVerifier.java
index 14b2e0300..934ee87f5 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorCountVerifier.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorCountVerifier.java
@@ -19,9 +19,9 @@ import android.util.Log;
 import org.robolectric.shadows.testing.util.CompareUtils;
 
 public class ColorCountVerifier extends BitmapVerifier {
-  private int color;
-  private int count;
-  private int threshold;
+  private final int color;
+  private final int count;
+  private final int threshold;
 
   public ColorCountVerifier(int color, int count, int threshold) {
     this.color = color;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorVerifier.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorVerifier.java
index c9aede31f..8990a7502 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorVerifier.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/ColorVerifier.java
@@ -19,7 +19,7 @@ import androidx.annotation.ColorInt;
 
 /** Checks to see if a bitmap is entirely a single color */
 public class ColorVerifier extends PerPixelBitmapVerifier {
-  @ColorInt private int color;
+  @ColorInt private final int color;
 
   public ColorVerifier(@ColorInt int color) {
     this(color, DEFAULT_THRESHOLD);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/PerPixelBitmapVerifier.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/PerPixelBitmapVerifier.java
index 7179cb6da..3bdebc45b 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/PerPixelBitmapVerifier.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/PerPixelBitmapVerifier.java
@@ -23,14 +23,14 @@ import org.robolectric.shadows.testing.util.CompareUtils;
 
 /** This class looks at every pixel in a given bitmap and verifies that it is correct. */
 public abstract class PerPixelBitmapVerifier extends BitmapVerifier {
-  private static final String TAG = "PerPixelBitmapVerifer";
+  private static final String TAG = "PerPixelBitmapVerifier";
   public static final int DEFAULT_THRESHOLD = 48;
 
   // total color difference tolerated without the pixel failing
-  private int colorTolerance;
+  private final int colorTolerance;
 
   // portion of bitmap allowed to fail pixel check
-  private float spatialTolerance;
+  private final float spatialTolerance;
 
   public PerPixelBitmapVerifier() {
     this(DEFAULT_THRESHOLD, 0);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RectVerifier.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RectVerifier.java
index 5fcf5e18f..152bb5a63 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RectVerifier.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RectVerifier.java
@@ -19,9 +19,9 @@ import android.graphics.Rect;
 
 /** Tests to see if there is rectangle of a certain color, with a background given */
 public class RectVerifier extends PerPixelBitmapVerifier {
-  private int outerColor;
-  private int innerColor;
-  private Rect innerRect;
+  private final int outerColor;
+  private final int innerColor;
+  private final Rect innerRect;
 
   public RectVerifier(int outerColor, int innerColor, Rect innerRect) {
     this(outerColor, innerColor, innerRect, DEFAULT_THRESHOLD);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RegionVerifier.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RegionVerifier.java
index 625d87516..0d88cd4d3 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RegionVerifier.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/RegionVerifier.java
@@ -36,7 +36,7 @@ public class RegionVerifier extends BitmapVerifier {
     }
   }
 
-  private List<SubRegionVerifiers> regionVerifiers = new ArrayList<>();
+  private final List<SubRegionVerifiers> regionVerifiers = new ArrayList<>();
 
   @Override
   public boolean verify(int[] bitmap, int offset, int stride, int width, int height) {
@@ -47,9 +47,9 @@ public class RegionVerifier extends BitmapVerifier {
         Rect area = subRegionVerifier.region.getBounds();
         isVerified &= verifySubRect(bitmap, offset, stride, subRegionVerifier.verifier, area);
       } else {
-        RegionIterator iter = new RegionIterator(subRegionVerifier.region);
+        RegionIterator iterator = new RegionIterator(subRegionVerifier.region);
         Rect area = new Rect();
-        while (iter.next(area)) {
+        while (iterator.next(area)) {
           isVerified &= verifySubRect(bitmap, offset, stride, subRegionVerifier.verifier, area);
         }
       }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/SamplePointWideGamutVerifier.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/SamplePointWideGamutVerifier.java
index 236ab1e52..896887849 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/SamplePointWideGamutVerifier.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/bitmapverifiers/SamplePointWideGamutVerifier.java
@@ -50,10 +50,7 @@ public class SamplePointWideGamutVerifier extends BitmapVerifier {
 
       Color actual = bitmap.getColor(p.x, p.y).convert(expected.getColorSpace());
 
-      boolean localSuccess = true;
-      if (!floatCompare(expected.red(), actual.red(), eps)) {
-        localSuccess = false;
-      }
+      boolean localSuccess = floatCompare(expected.red(), actual.red(), eps);
       if (!floatCompare(expected.green(), actual.green(), eps)) {
         localSuccess = false;
       }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/text/EditorState.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/text/EditorState.java
index 8805ab6de..fecbf619f 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/text/EditorState.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/testing/text/EditorState.java
@@ -23,7 +23,8 @@ import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.style.ReplacementSpan;
 import com.google.common.base.Splitter;
-import junit.framework.Assert;
+import javax.annotation.Nonnull;
+import org.junit.Assert;
 
 /**
  * Represents an editor state.
@@ -57,13 +58,13 @@ public class EditorState {
   private static class MockReplacementSpan extends ReplacementSpan {
     @Override
     public int getSize(
-        Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) {
+        @Nonnull Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) {
       return 0;
     }
 
     @Override
     public void draw(
-        Canvas canvas,
+        @Nonnull Canvas canvas,
         CharSequence text,
         int start,
         int end,
@@ -71,7 +72,7 @@ public class EditorState {
         int top,
         int y,
         int bottom,
-        Paint paint) {}
+        @Nonnull Paint paint) {}
   }
 
   // Returns true if the code point is ASCII and graph.
diff --git a/integration_tests/roborazzi/build.gradle.kts b/integration_tests/roborazzi/build.gradle.kts
index b49fcad85..3d046c314 100644
--- a/integration_tests/roborazzi/build.gradle.kts
+++ b/integration_tests/roborazzi/build.gradle.kts
@@ -8,7 +8,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integration.roborazzi"
 
   defaultConfig { minSdk = 21 }
@@ -21,7 +21,7 @@ android {
   kotlinOptions { jvmTarget = "1.8" }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests {
       isIncludeAndroidResources = true
       all {
@@ -54,7 +54,6 @@ dependencies {
   api(project(":robolectric"))
   testImplementation(libs.androidx.test.core)
   testImplementation(libs.junit4)
-  testImplementation(libs.truth)
   testImplementation(libs.roborazzi)
   testImplementation(libs.roborazzi.rule)
 }
diff --git a/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt b/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt
index 5995d7f92..21b2cffa5 100644
--- a/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt
+++ b/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt
@@ -100,9 +100,6 @@ class RoborazziCaptureTest {
   }
 
   companion object {
-    // TODO(hoisie): `robolectric.screenshot.hwrdr.native` is obsolete, remove it after the next
-    // Robolectric point release.
-    const val USE_HARDWARE_RENDERER_NATIVE_ENV = "robolectric.screenshot.hwrdr.native"
     const val PIXEL_COPY_RENDER_MODE = "robolectric.pixelCopyRenderMode"
   }
 }
@@ -114,24 +111,15 @@ private fun registerActivityToPackageManager(activity: String) {
     .addActivityIfNotPresent(ComponentName(appContext.packageName, activity))
 }
 
-@Suppress("ForbiddenComment")
 private fun hardwareRendererEnvironment(block: () -> Unit) {
-  val originalHwrdrOption =
-    System.getProperty(RoborazziCaptureTest.USE_HARDWARE_RENDERER_NATIVE_ENV, null)
   val originalPixelCopyOption =
     System.getProperty(RoborazziCaptureTest.PIXEL_COPY_RENDER_MODE, null)
-  // This cause ClassNotFoundException: java.nio.NioUtils
-  // TODO: Remove comment out after fix this issue
-  // https://github.com/robolectric/robolectric/issues/8081#issuecomment-1858726896
-  // System.setProperty(USE_HARDWARE_RENDERER_NATIVE_ENV, "true")
   try {
     block()
   } finally {
-    if (originalHwrdrOption == null) {
-      System.clearProperty(RoborazziCaptureTest.USE_HARDWARE_RENDERER_NATIVE_ENV)
+    if (originalPixelCopyOption == null) {
       System.clearProperty(RoborazziCaptureTest.PIXEL_COPY_RENDER_MODE)
     } else {
-      System.setProperty(RoborazziCaptureTest.USE_HARDWARE_RENDERER_NATIVE_ENV, originalHwrdrOption)
       System.setProperty(RoborazziCaptureTest.PIXEL_COPY_RENDER_MODE, originalPixelCopyOption)
     }
   }
diff --git a/integration_tests/room/build.gradle.kts b/integration_tests/room/build.gradle.kts
index 21b977dbd..93bc2884f 100644
--- a/integration_tests/room/build.gradle.kts
+++ b/integration_tests/room/build.gradle.kts
@@ -4,7 +4,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integrationtests.room"
 
   defaultConfig { minSdk = 21 }
@@ -15,7 +15,7 @@ android {
   }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 }
@@ -25,7 +25,6 @@ dependencies {
   testImplementation(project(":testapp"))
   testImplementation(project(":robolectric"))
   testImplementation(libs.junit4)
-  testImplementation(libs.guava.testlib)
   testImplementation(libs.truth)
   implementation(libs.androidx.room.runtime)
   annotationProcessor(libs.androidx.room.compiler)
diff --git a/integration_tests/room/src/test/java/org/robolectric/integrationtests/room/UserDatabaseTest.java b/integration_tests/room/src/test/java/org/robolectric/integrationtests/room/UserDatabaseTest.java
index 273568c4a..3a65fedbc 100644
--- a/integration_tests/room/src/test/java/org/robolectric/integrationtests/room/UserDatabaseTest.java
+++ b/integration_tests/room/src/test/java/org/robolectric/integrationtests/room/UserDatabaseTest.java
@@ -12,7 +12,7 @@ import org.robolectric.annotation.SQLiteMode;
 public final class UserDatabaseTest {
 
   /**
-   * There was an issue using Room with {@link SQLiteMode.Mode.LEGACY}. The {@link
+   * There was an issue using Room with {@link SQLiteMode.Mode#LEGACY}. The {@link
    * android.database.sqlite.SQLiteException} exceptions were wrapped in a way that was not
    * compatible with Room.
    */
diff --git a/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
index 1a775ed6a..ef1e66c11 100644
--- a/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
+++ b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
@@ -13,13 +13,13 @@ import android.view.PixelCopy
 import com.google.common.truth.Truth.assertThat
 import org.junit.Test
 import org.junit.runner.RunWith
-import org.robolectric.Robolectric
 import org.robolectric.Robolectric.buildActivity
 import org.robolectric.RobolectricTestRunner
 import org.robolectric.RuntimeEnvironment
 import org.robolectric.Shadows
 import org.robolectric.annotation.Config
 import org.robolectric.integrationtests.sdkcompat.MainActivity.CreationSource
+import org.robolectric.shadows.ShadowApplication
 import org.robolectric.testapp.TestActivity
 
 @RunWith(RobolectricTestRunner::class)
@@ -31,6 +31,12 @@ class NormalCompatibilityTest {
     assertThat(Build.VERSION.SDK_INT).isEqualTo(Build.VERSION_CODES.Q)
   }
 
+  @Test
+  fun `Retrieve ShadowApplication from Application succeed`() {
+    val shadowApplication: ShadowApplication = Shadows.shadowOf(application)
+    assertThat(shadowApplication).isNotNull()
+  }
+
   @Test
   fun `Initialize LocationManager succeed`() {
     val locationManager = application.getSystemService(Context.LOCATION_SERVICE)
@@ -69,29 +75,41 @@ class NormalCompatibilityTest {
 
   @Test
   fun `PixelCopy request`() {
-    val testActivity = Robolectric.setupActivity(TestActivity::class.java)
-    val bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888)
-    val listener = PixelCopy.OnPixelCopyFinishedListener {}
-    val srcRect = Rect(0, 0, 100, 100)
-    PixelCopy.request(
-      testActivity.window,
-      srcRect,
-      bitmap,
-      listener,
-      Handler(Looper.getMainLooper()),
-    )
+    buildActivity(TestActivity::class.java).use { controller ->
+      val testActivity = controller.setup().get()
+      val bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888)
+      val listener = PixelCopy.OnPixelCopyFinishedListener {}
+      val srcRect = Rect(0, 0, 100, 100)
+      PixelCopy.request(
+        testActivity.window,
+        srcRect,
+        bitmap,
+        listener,
+        Handler(Looper.getMainLooper()),
+      )
+    }
   }
 
   @Test
   fun `MainActivity created correctly using AppComponentFactory`() {
-    val activity = Robolectric.setupActivity(MainActivity::class.java)
-    assertThat(activity.creationSource).isEqualTo(CreationSource.CUSTOM_CONSTRUCTOR)
+    buildActivity(MainActivity::class.java).use { controller ->
+      val activity = controller.setup().get()
+      assertThat(activity.creationSource).isEqualTo(CreationSource.CUSTOM_CONSTRUCTOR)
+    }
   }
 
   @Test
   @Config(minSdk = 19, maxSdk = 27)
   fun `MainActivity created correctly using default constructor on api lower than 28`() {
-    val activity = Robolectric.setupActivity(MainActivity::class.java)
-    assertThat(activity.creationSource).isEqualTo(CreationSource.DEFAULT_CONSTRUCTOR)
+    buildActivity(MainActivity::class.java).use { controller ->
+      val activity = controller.setup().get()
+      assertThat(activity.creationSource).isEqualTo(CreationSource.DEFAULT_CONSTRUCTOR)
+    }
+  }
+
+  @Test
+  fun `Retrieve PackageInstaller succeed`() {
+    val packageInstaller = application.packageManager.packageInstaller
+    assertThat(packageInstaller).isNotNull()
   }
 }
diff --git a/integration_tests/security-providers/build.gradle.kts b/integration_tests/security-providers/build.gradle.kts
index e0001bf4a..874c31e0d 100644
--- a/integration_tests/security-providers/build.gradle.kts
+++ b/integration_tests/security-providers/build.gradle.kts
@@ -2,12 +2,11 @@ plugins { alias(libs.plugins.robolectric.java.module) }
 
 dependencies {
   api(project(":robolectric"))
-  api(libs.junit4)
   compileOnly(AndroidSdk.MAX_SDK.coordinates)
 
   testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
-  testImplementation(libs.truth)
   testImplementation(libs.conscrypt.openjdk.uber)
+  testImplementation(libs.junit4)
   testImplementation(libs.okhttp)
   testImplementation(platform(libs.okhttp.bom))
 }
diff --git a/integration_tests/security-providers/src/test/java/org/robolectric/integrationtests/securityproviders/SecurityProvidersTest.java b/integration_tests/security-providers/src/test/java/org/robolectric/integrationtests/securityproviders/SecurityProvidersTest.java
index 6e00269c4..eff13e1f6 100644
--- a/integration_tests/security-providers/src/test/java/org/robolectric/integrationtests/securityproviders/SecurityProvidersTest.java
+++ b/integration_tests/security-providers/src/test/java/org/robolectric/integrationtests/securityproviders/SecurityProvidersTest.java
@@ -1,5 +1,6 @@
 package org.robolectric.integrationtests.securityproviders;
 
+import java.net.URI;
 import java.net.URL;
 import java.security.Provider;
 import java.security.Security;
@@ -22,7 +23,7 @@ public class SecurityProvidersTest {
 
   @Test
   public void jsseProvider_isFunctioning() throws Exception {
-    URL url = new URL("https://www.google.com");
+    URL url = new URI("https://www.google.com").toURL();
     url.openConnection().getInputStream();
   }
 
@@ -33,6 +34,6 @@ public class SecurityProvidersTest {
     }
     OkHttpClient client = new OkHttpClient.Builder().build();
     Request request = new Request.Builder().url("https://www.google.com").build();
-    client.newCall(request).execute();
+    client.newCall(request).execute().close();
   }
 }
diff --git a/integration_tests/sparsearray/build.gradle.kts b/integration_tests/sparsearray/build.gradle.kts
index 18479c8b9..e9ec78dbc 100644
--- a/integration_tests/sparsearray/build.gradle.kts
+++ b/integration_tests/sparsearray/build.gradle.kts
@@ -7,7 +7,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.sparsearray"
 
   defaultConfig { minSdk = 21 }
@@ -20,14 +20,13 @@ android {
   kotlinOptions { jvmTarget = "1.8" }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 }
 
 dependencies {
   compileOnly(AndroidSdk.MAX_SDK.coordinates)
-  implementation(project(path = ":shadowapi", configuration = "default"))
 
   testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
   testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
diff --git a/integration_tests/testparameterinjector/build.gradle.kts b/integration_tests/testparameterinjector/build.gradle.kts
index d3a8371ed..a664b5918 100644
--- a/integration_tests/testparameterinjector/build.gradle.kts
+++ b/integration_tests/testparameterinjector/build.gradle.kts
@@ -4,7 +4,7 @@ plugins {
 }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.integrationtests.testparameterinjector"
 
   defaultConfig { minSdk = 21 }
@@ -15,7 +15,7 @@ android {
   }
 
   testOptions {
-    targetSdk = 34
+    targetSdk = 35
     unitTests.isIncludeAndroidResources = true
   }
 }
diff --git a/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java b/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java
index aef0a6b64..8fdef9a74 100644
--- a/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java
+++ b/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java
@@ -1,11 +1,14 @@
 package org.robolectric.integrationtests.testparameterinjector;
 
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.S;
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Build.VERSION;
 import com.google.testing.junit.testparameterinjector.TestParameter;
 import java.util.ArrayList;
+import javax.annotation.Nonnull;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -19,22 +22,47 @@ import org.junit.runners.JUnit4;
 import org.robolectric.RobolectricTestParameterInjector;
 import org.robolectric.annotation.Config;
 
-@SuppressWarnings({"TestMethodWithIncorrectSignature", "UnconstructableJUnitTestCase"})
+@SuppressWarnings({
+  "IgnoreWithoutReason",
+  "NewClassNamingConvention",
+  "TestMethodWithIncorrectSignature",
+  "UnconstructableJUnitTestCase"
+})
 @RunWith(JUnit4.class)
 public class RobolectricTestParameterInjectorTest {
-  private final RunNotifier runNotifier = new RunNotifier();
+  private String priorAlwaysInclude;
+  private String priorEnabledSdks;
+  private RunNotifier runNotifier;
 
   @Before
   public void setup() {
+    priorAlwaysInclude = System.getProperty("robolectric.alwaysIncludeVariantMarkersInTestName");
+    System.clearProperty("robolectric.alwaysIncludeVariantMarkersInTestName");
+
+    priorEnabledSdks = System.getProperty("robolectric.enabledSdks");
+    System.clearProperty("robolectric.enabledSdks");
+
+    runNotifier = new RunNotifier();
     runNotifier.addListener(
         new RunListener() {
           @Override
-          public void testFailure(Failure failure) throws Exception {
+          public void testFailure(Failure failure) {
             throw new AssertionError("Unexpected test failure: " + failure, failure.getException());
           }
         });
   }
 
+  @After
+  public void tearDown() {
+    if (priorAlwaysInclude != null) {
+      System.setProperty("robolectric.alwaysIncludeVariantMarkersInTestName", priorAlwaysInclude);
+    }
+
+    if (priorEnabledSdks != null) {
+      System.setProperty("robolectric.enabledSdks", priorEnabledSdks);
+    }
+  }
+
   @Ignore
   public static class NoInjection {
     @Config(sdk = S)
@@ -70,9 +98,9 @@ public class RobolectricTestParameterInjectorTest {
 
     assertThat(runner.testCount()).isEqualTo(2);
     ArrayList<Description> descriptions = runner.getDescription().getChildren();
-    // In gradle it's test[false], in bazel it's test[param=false].
-    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?false\\]");
-    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?true\\]");
+    // In Gradle it's test[false], in Bazel it's test[param=false].
+    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?false]");
+    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?true]");
   }
 
   @Ignore
@@ -123,15 +151,15 @@ public class RobolectricTestParameterInjectorTest {
     runner.run(runNotifier);
     assertThat(runner.testCount()).isEqualTo(2);
     ArrayList<Description> descriptions = runner.getDescription().getChildren();
-    // In gradle it's test[1], in bazel it's test[param=1].
-    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?1\\]");
-    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?2\\]");
+    // In Gradle it's test[1], in Bazel it's test[param=1].
+    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?1]");
+    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?2]");
   }
 
   @Ignore
   @Config(sdk = Config.NEWEST_SDK)
   public static class InjectedEnum {
-    enum Value {
+    public enum Value {
       ONE,
       TWO
     }
@@ -158,10 +186,10 @@ public class RobolectricTestParameterInjectorTest {
   @Ignore
   public static class MultiSdk {
     @Test
-    @Config(sdk = {28, 31})
+    @Config(sdk = {P, S})
     public void test(@TestParameter boolean param) {
       assertThat(param).isAnyOf(true, false);
-      assertThat(VERSION.SDK_INT).isAnyOf(28, 31);
+      assertThat(VERSION.SDK_INT).isAnyOf(P, S);
     }
   }
 
@@ -174,23 +202,24 @@ public class RobolectricTestParameterInjectorTest {
     assertThat(runner.testCount()).isEqualTo(4);
 
     ArrayList<Description> descriptions = runner.getDescription().getChildren();
-    // In gradle it's test[false][28], in bazel it's test[param=false][28].
-    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?false\\]\\[28\\]");
-    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?true\\]\\[28\\]");
-    assertThat(descriptions.get(2).getMethodName()).matches("test\\[(param=)?false\\]");
-    assertThat(descriptions.get(3).getMethodName()).matches("test\\[(param=)?true\\]");
+    // In Gradle it's test[false][28], in Bazel it's test[param=false][28].
+    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?false]\\[28]");
+    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?true]\\[28]");
+    assertThat(descriptions.get(2).getMethodName()).matches("test\\[(param=)?false]");
+    assertThat(descriptions.get(3).getMethodName()).matches("test\\[(param=)?true]");
   }
 
-  // Simulate behavior of proto lite enum toString which includes the object hashcode (proto lite
-  // toString tries to avoid dep on enum name so that the name can be stripped by appreduce).
+  // Simulate the behavior of proto lite enum toString which includes the object hashcode (proto
+  // lite toString tries to avoid dep on enum name so that the name can be stripped by appreduce).
   @Ignore
   @Config(sdk = Config.NEWEST_SDK)
   public static class HashCodeToString {
-    enum HashCodeToStringValue {
+    public enum HashCodeToStringValue {
       ONE,
       TWO;
 
       @Override
+      @Nonnull
       public String toString() {
         return "" + super.hashCode();
       }
diff --git a/integration_tests/versioning/build.gradle.kts b/integration_tests/versioning/build.gradle.kts
index 160d4dd95..3c3833e0f 100644
--- a/integration_tests/versioning/build.gradle.kts
+++ b/integration_tests/versioning/build.gradle.kts
@@ -1,14 +1,10 @@
 plugins { alias(libs.plugins.robolectric.java.module) }
 
-val earlyRuntime by configurations.registering
-val axtJunitVersion: String by rootProject.extra
-
 dependencies {
   // compile against latest Android SDK (AndroidSdk.s.coordinates) { force = true }
   compileOnly(AndroidSdk.MAX_SDK.coordinates)
   testImplementation(project(":robolectric"))
   testImplementation(libs.truth)
-  testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
   testCompileOnly(AndroidSdk.MAX_SDK.coordinates) // compile against latest Android SDK
   testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates) // run against whatever this JDK supports
 }
diff --git a/integration_tests/versioning/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java b/integration_tests/versioning/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
index 89bdc6717..027107cf6 100644
--- a/integration_tests/versioning/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
+++ b/integration_tests/versioning/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
@@ -23,12 +23,30 @@ public final class AndroidVersionsTest {
     assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("T");
   }
 
+  @Test
+  @Config(sdk = 35)
+  public void testStandardInitializationV() {
+    assertThat(AndroidVersions.V.SDK_INT).isEqualTo(35);
+    assertThat(AndroidVersions.V.SHORT_CODE).isEqualTo("V");
+    assertThat(new AndroidVersions.V().getVersion()).isEqualTo("15");
+    assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("V");
+  }
+
+  @Test
+  @Config(sdk = 34)
+  public void testStandardInitializationU() {
+    assertThat(AndroidVersions.U.SDK_INT).isEqualTo(34);
+    assertThat(AndroidVersions.U.SHORT_CODE).isEqualTo("U");
+    assertThat(new AndroidVersions.U().getVersion()).isEqualTo("14");
+    assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("U");
+  }
+
   @Test
   @Config(sdk = 33)
   public void testStandardInitializationT() {
     assertThat(AndroidVersions.T.SDK_INT).isEqualTo(33);
     assertThat(AndroidVersions.T.SHORT_CODE).isEqualTo("T");
-    assertThat(new AndroidVersions.T().getVersion()).isEqualTo("13.0");
+    assertThat(new AndroidVersions.T().getVersion()).isEqualTo("13");
     assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("T");
   }
 
@@ -46,7 +64,7 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationS() {
     assertThat(AndroidVersions.S.SDK_INT).isEqualTo(31);
     assertThat(AndroidVersions.S.SHORT_CODE).isEqualTo("S");
-    assertThat(new AndroidVersions.S().getVersion()).isEqualTo("12.0");
+    assertThat(new AndroidVersions.S().getVersion()).isEqualTo("12");
     assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("S");
   }
 
@@ -55,7 +73,7 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationR() {
     assertThat(AndroidVersions.R.SDK_INT).isEqualTo(30);
     assertThat(AndroidVersions.R.SHORT_CODE).isEqualTo("R");
-    assertThat(new AndroidVersions.R().getVersion()).isEqualTo("11.0");
+    assertThat(new AndroidVersions.R().getVersion()).isEqualTo("11");
     assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("R");
   }
 
@@ -64,7 +82,7 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationQ() {
     assertThat(AndroidVersions.Q.SDK_INT).isEqualTo(29);
     assertThat(AndroidVersions.Q.SHORT_CODE).isEqualTo("Q");
-    assertThat(new AndroidVersions.Q().getVersion()).isEqualTo("10.0");
+    assertThat(new AndroidVersions.Q().getVersion()).isEqualTo("10");
     assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("Q");
   }
 
@@ -73,7 +91,7 @@ public final class AndroidVersionsTest {
   public void testStandardInitializationP() {
     assertThat(AndroidVersions.P.SDK_INT).isEqualTo(28);
     assertThat(AndroidVersions.P.SHORT_CODE).isEqualTo("P");
-    assertThat(new AndroidVersions.P().getVersion()).isEqualTo("9.0");
+    assertThat(new AndroidVersions.P().getVersion()).isEqualTo("9");
     assertThat(AndroidVersions.CURRENT.getShortCode()).isEqualTo("P");
   }
 
diff --git a/integration_tests/versioning/src/test/resources/AndroidManifest.xml b/integration_tests/versioning/src/test/resources/AndroidManifest.xml
index 65383ac0b..2c7876de2 100644
--- a/integration_tests/versioning/src/test/resources/AndroidManifest.xml
+++ b/integration_tests/versioning/src/test/resources/AndroidManifest.xml
@@ -2,6 +2,4 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="org.robolectric">
     <uses-sdk android:targetSdkVersion="33" android:minSdkVersion="33"/>
-    <application android:name="android.app.Application">
-    </application>
 </manifest>
diff --git a/junit/Android.bp b/junit/Android.bp
index 4224afa35..34607f1c1 100644
--- a/junit/Android.bp
+++ b/junit/Android.bp
@@ -12,12 +12,12 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_junit_upstream",
+    name: "Robolectric_junit",
     libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_sandbox",
+        "Robolectric_utils",
         "asm-commons-9.6",
         "guava",
         "asm-tree-9.6",
diff --git a/junit/build.gradle.kts b/junit/build.gradle.kts
index ba9e960e8..b50399f6c 100644
--- a/junit/build.gradle.kts
+++ b/junit/build.gradle.kts
@@ -4,11 +4,8 @@ plugins {
 }
 
 dependencies {
-  api(project(":annotations"))
   api(project(":sandbox"))
   api(project(":pluginapi"))
-  api(project(":shadowapi"))
-  api(project(":utils:reflector"))
 
   compileOnly(libs.findbugs.jsr305)
   compileOnly(libs.junit4)
diff --git a/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java b/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java
index 5d960ba0b..6514ceec6 100644
--- a/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java
+++ b/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java
@@ -4,13 +4,17 @@ import static java.util.Arrays.asList;
 import static java.util.Arrays.stream;
 
 import com.google.common.base.Splitter;
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -19,8 +23,13 @@ import java.util.WeakHashMap;
 import javax.annotation.Nonnull;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.internal.runners.statements.FailOnTimeout;
+import org.junit.rules.RunRules;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
 import org.junit.runners.BlockJUnit4ClassRunner;
 import org.junit.runners.model.FrameworkMethod;
@@ -45,6 +54,7 @@ import org.robolectric.pluginapi.perf.PerfStatsReporter;
 import org.robolectric.sandbox.ShadowMatcher;
 import org.robolectric.util.PerfStatsCollector;
 import org.robolectric.util.PerfStatsCollector.Event;
+import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.Util;
 import org.robolectric.util.inject.Injector;
 
@@ -69,9 +79,14 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
 
   private final List<PerfStatsReporter> perfStatsReporters;
   private final HashMap<Class<?>, Sandbox> loadedTestClasses = new HashMap<>();
+  private final HashSet<Class<?>> invokedBeforeClasses = new HashSet<>();
+
   private final HashMap<Class<?>, HelperTestRunner> helperRunners = new HashMap<>();
   private final WeakHashMap<Sandbox, LinkageError> firstLinkageErrors = new WeakHashMap<>();
 
+  private static final boolean USE_LEGACY_SANDBOX_FLOW =
+      Boolean.getBoolean("robolectric.useLegacySandboxFlow");
+
   public SandboxTestRunner(Class<?> klass) throws InitializationError {
     this(klass, DEFAULT_INJECTOR);
   }
@@ -98,12 +113,87 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
 
   @Override
   protected Statement classBlock(RunNotifier notifier) {
-    final Statement statement = childrenInvoker(notifier);
+    if (USE_LEGACY_SANDBOX_FLOW) {
+      return legacyClassBlock(notifier);
+    }
+    return sandboxGroupingClassBlock(notifier);
+  }
+
+  private Statement legacyClassBlock(RunNotifier notifier) {
+    Statement statement = childrenInvoker(notifier);
+    statement = withAfterClassesInSandbox(statement);
+    if (hasClassRules(getTestClass().getJavaClass())) {
+      statement = withClassRulesInSandbox(statement);
+    }
+    return statement;
+  }
+
+  private Statement sandboxGroupingClassBlock(RunNotifier notifier) {
+    List<FrameworkMethod> children =
+        ReflectionHelpers.callInstanceMethod(this, "getFilteredChildren");
+    // Use a linked hashmap as a slight improvement to run tests in the order of getChildren.
+    Map<Sandbox, List<FrameworkMethod>> methodsBySandbox = new LinkedHashMap<>();
+    for (FrameworkMethod method : children) {
+      Description description = describeChild(method);
+      if (!isIgnored(method)) {
+        try {
+          Sandbox sandbox = getSandbox(method);
+          methodsBySandbox.computeIfAbsent(sandbox, k -> new ArrayList<>()).add(method);
+        } catch (IllegalArgumentException e) {
+          notifier.fireTestStarted(description);
+          notifier.fireTestFailure(new Failure(description, e));
+          notifier.fireTestFinished(description);
+        }
+      } else {
+        // send ignored tests to the notifier listeners
+        notifier.fireTestIgnored(description);
+      }
+    }
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        // generating nested statement for all the tests in each sandboxes
+        for (Map.Entry<Sandbox, List<FrameworkMethod>> entry : methodsBySandbox.entrySet()) {
+          Sandbox sandbox = entry.getKey();
+          FrameworkMethod firstMethod = entry.getValue().get(0);
+
+          // Recreate the sandbox if the stored sandbox is removed from the cache
+          if (sandbox.isShutdown()) {
+            sandbox = getSandbox(firstMethod);
+          }
+          Statement statement = childrenInvoker(entry.getValue(), notifier);
+
+          Class<?> bootstrappedTestClass = sandbox.bootstrappedClass(getTestClass().getJavaClass());
+
+          HelperTestRunner helperTestRunner = getCachedHelperTestRunner(bootstrappedTestClass);
+          statement = helperTestRunner.withBeforeClasses(statement);
+          statement = helperTestRunner.withAfterClasses(statement);
+
+          statement = withClassRules(statement, bootstrappedTestClass);
+
+          // Use the first method to setup a sandbox and invoke everything in that sandbox
+          Statement statementsOfTestGroup = inSandboxThread(sandbox, firstMethod, statement);
+          statementsOfTestGroup.evaluate();
+        }
+      }
+    };
+  }
+
+  private static boolean hasClassRules(Class<?> testClass) {
+    for (Field field : testClass.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(ClassRule.class)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private Statement withAfterClassesInSandbox(Statement base) {
     return new Statement() {
       @Override
       public void evaluate() throws Throwable {
         try {
-          statement.evaluate();
+          base.evaluate();
           for (Map.Entry<Class<?>, Sandbox> entry : loadedTestClasses.entrySet()) {
             Sandbox sandbox = entry.getValue();
             sandbox.runOnMainThread(
@@ -128,9 +218,68 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
     };
   }
 
-  private void invokeBeforeClass(final Class<?> clazz, final Sandbox sandbox) throws Throwable {
-    if (!loadedTestClasses.containsKey(clazz)) {
-      loadedTestClasses.put(clazz, sandbox);
+  private Statement withClassRules(Statement statement, Class<?> bootstrappedTestClass) {
+    HelperTestRunner helperTestRunner = getCachedHelperTestRunner(bootstrappedTestClass);
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        List<TestRule> classRules = helperTestRunner.classRules();
+        // Create a RunRules instance with the classRules to retain the default ordering of
+        // rules.
+        if (!classRules.isEmpty()) {
+          RunRules runRules = new RunRules(statement, classRules, getDescription());
+          runRules.evaluate();
+        } else {
+          statement.evaluate();
+        }
+      }
+    };
+  }
+
+  private Statement withClassRulesInSandbox(Statement statement) {
+    for (FrameworkMethod frameworkMethod : getChildren()) {
+      Sandbox sandbox = getSandbox(frameworkMethod);
+      Class<?> bootstrappedTestClass = sandbox.bootstrappedClass(getTestClass().getJavaClass());
+
+      if (!loadedTestClasses.containsKey(bootstrappedTestClass)) {
+        loadedTestClasses.put(bootstrappedTestClass, sandbox);
+
+        // Configure sandbox *BEFORE* setting the ClassLoader. This is necessary because
+        // creating the ShadowMap loads all ShadowProviders via ServiceLoader and this is
+        // not available once we install the Robolectric class loader.
+        configureSandbox(sandbox, frameworkMethod);
+
+        HelperTestRunner helperTestRunner = getCachedHelperTestRunner(bootstrappedTestClass);
+        List<TestRule> classRules = helperTestRunner.classRules();
+        for (TestRule classRule : classRules) {
+          statement = applyRuleInSandbox(classRule, sandbox, statement, getDescription());
+        }
+      }
+    }
+    return statement;
+  }
+
+  private Statement applyRuleInSandbox(
+      TestRule rule, Sandbox sandbox, Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        ClassLoader priorContextClassLoader = Thread.currentThread().getContextClassLoader();
+        Thread.currentThread().setContextClassLoader(sandbox.getRobolectricClassLoader());
+        try {
+          rule.apply(base, description).evaluate();
+        } catch (Throwable throwable) {
+          throw Util.sneakyThrow(throwable);
+        } finally {
+          Thread.currentThread().setContextClassLoader(priorContextClassLoader);
+        }
+      }
+    };
+  }
+
+  private void invokeBeforeClass(final Class<?> clazz) throws Throwable {
+    if (!invokedBeforeClasses.contains(clazz)) {
+      invokedBeforeClasses.add(clazz);
 
       final TestClass testClass = new TestClass(clazz);
       final List<FrameworkMethod> befores = testClass.getAnnotatedMethods(BeforeClass.class);
@@ -148,6 +297,45 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
     }
   }
 
+  // As the sandbox for all methods are the same, we can just use the first method to get the
+  // extra shadows
+  private Statement inSandboxThread(Sandbox sandbox, FrameworkMethod firstMethod, Statement base) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        // Configure shadows *BEFORE* setting the ClassLoader. This is necessary because
+        // creating the ShadowMap loads all ShadowProviders via ServiceLoader and this is
+        // not available once we install the Robolectric class loader.
+        configureSandbox(sandbox, firstMethod);
+
+        sandbox.runOnMainThread(
+            () -> {
+              ClassLoader priorContextClassLoader = Thread.currentThread().getContextClassLoader();
+              Thread.currentThread().setContextClassLoader(sandbox.getRobolectricClassLoader());
+
+              try {
+                base.evaluate();
+              } catch (Throwable throwable) {
+                throw Util.sneakyThrow(throwable);
+              } finally {
+                Thread.currentThread().setContextClassLoader(priorContextClassLoader);
+              }
+            });
+      }
+    };
+  }
+
+  private Statement childrenInvoker(List<FrameworkMethod> children, RunNotifier notifier) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        for (FrameworkMethod method : children) {
+          runChild(method, notifier);
+        }
+      }
+    };
+  }
+
   protected void afterClass() {}
 
   @Nonnull
@@ -244,79 +432,99 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
         // not available once we install the Robolectric class loader.
         configureSandbox(sandbox, method);
 
-        sandbox.runOnMainThread(
-            () -> {
-              ClassLoader priorContextClassLoader = Thread.currentThread().getContextClassLoader();
-              Thread.currentThread().setContextClassLoader(sandbox.getRobolectricClassLoader());
+        if (USE_LEGACY_SANDBOX_FLOW) {
+          final PerfStatsCollector finalPerfStatsCollector = perfStatsCollector;
+          final Event finalInitialization = initialization;
+          sandbox.runOnMainThread(
+              () ->
+                  executeInSandbox(sandbox, method, finalPerfStatsCollector, finalInitialization));
+        } else {
+          executeInSandbox(sandbox, method, perfStatsCollector, initialization);
+        }
+      }
+    };
+  }
 
-              Class<?> bootstrappedTestClass =
-                  sandbox.bootstrappedClass(getTestClass().getJavaClass());
-              HelperTestRunner helperTestRunner = getCachedHelperTestRunner(bootstrappedTestClass);
-              helperTestRunner.frameworkMethod = method;
+  private void executeInSandbox(
+      final Sandbox sandbox,
+      final FrameworkMethod method,
+      PerfStatsCollector perfStatsCollector,
+      Event initialization) {
+    ClassLoader priorContextClassLoader = null;
+    if (USE_LEGACY_SANDBOX_FLOW) {
+      priorContextClassLoader = Thread.currentThread().getContextClassLoader();
+      Thread.currentThread().setContextClassLoader(sandbox.getRobolectricClassLoader());
+    }
 
-              // The method class may be different than the test class if the method annotated @Test
-              // is declared on a superclass of the test.
-              Class<?> bootstrappedMethodClass =
-                  sandbox.bootstrappedClass(method.getMethod().getDeclaringClass());
-              final Method bootstrappedMethod;
-              try {
-                Class<?>[] parameterTypes =
-                    stream(method.getMethod().getParameterTypes())
-                        .map(type -> type.isPrimitive() ? type : sandbox.bootstrappedClass(type))
-                        .toArray(Class[]::new);
-                bootstrappedMethod =
-                    bootstrappedMethodClass.getMethod(method.getMethod().getName(), parameterTypes);
-              } catch (NoSuchMethodException e) {
-                throw new RuntimeException(e);
-              }
+    Class<?> bootstrappedTestClass = sandbox.bootstrappedClass(getTestClass().getJavaClass());
+    HelperTestRunner helperTestRunner = getCachedHelperTestRunner(bootstrappedTestClass);
+    helperTestRunner.frameworkMethod = method;
+
+    // The method class may be different than the test class if the method annotated @Test
+    // is declared on a superclass of the test.
+    Class<?> bootstrappedMethodClass =
+        sandbox.bootstrappedClass(method.getMethod().getDeclaringClass());
+    final Method bootstrappedMethod;
+    try {
+      Class<?>[] parameterTypes =
+          stream(method.getMethod().getParameterTypes())
+              .map(type -> type.isPrimitive() ? type : sandbox.bootstrappedClass(type))
+              .toArray(Class[]::new);
+      bootstrappedMethod =
+          bootstrappedMethodClass.getMethod(method.getMethod().getName(), parameterTypes);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(e);
+    }
 
-              Queue<Throwable> thrown = new ArrayDeque<>();
+    Queue<Throwable> thrown = new ArrayDeque<>();
 
-              try {
-                // Only invoke @BeforeClass once per class
-                invokeBeforeClass(bootstrappedTestClass, sandbox);
+    try {
+      if (USE_LEGACY_SANDBOX_FLOW) {
+        // Only invoke @BeforeClass once per class
+        invokeBeforeClass(bootstrappedTestClass);
 
-                beforeTest(sandbox, method, bootstrappedMethod);
+        // When there is no class rules in the test class, loadedTestClasses should be updated here.
+        loadedTestClasses.putIfAbsent(bootstrappedTestClass, sandbox);
+      }
+      beforeTest(sandbox, method, bootstrappedMethod);
 
-                initialization.finished();
+      initialization.finished();
 
-                Statement statement =
-                    helperTestRunner.methodBlock(new FrameworkMethod(bootstrappedMethod));
-                statement.evaluate();
-              } catch (Throwable throwable) {
-                thrown.add(throwable);
-              }
+      Statement statement = helperTestRunner.methodBlock(new FrameworkMethod(bootstrappedMethod));
+      statement.evaluate();
+    } catch (Throwable throwable) {
+      thrown.add(throwable);
+    }
 
-              try {
-                afterTest(method, bootstrappedMethod);
-              } catch (Throwable throwable) {
-                thrown.add(throwable);
-              }
+    try {
+      afterTest(method, bootstrappedMethod);
+    } catch (Throwable throwable) {
+      thrown.add(throwable);
+    }
 
-              try {
-                Thread.currentThread().setContextClassLoader(priorContextClassLoader);
-                finallyAfterTest(method);
-                reportPerfStats(perfStatsCollector);
-                perfStatsCollector.reset();
-              } catch (Throwable throwable) {
-                thrown.add(throwable);
-              }
+    try {
+      if (USE_LEGACY_SANDBOX_FLOW) {
+        Thread.currentThread().setContextClassLoader(priorContextClassLoader);
+      }
+      finallyAfterTest(method);
+      reportPerfStats(perfStatsCollector);
+      perfStatsCollector.reset();
+    } catch (Throwable throwable) {
+      thrown.add(throwable);
+    }
 
-              Throwable first = thrown.poll();
-              if (first != null) {
-                if (first instanceof LinkageError) {
-                  // Potentially upgrade the LinkageError with a potentially more complete
-                  // descriptive exception.
-                  first = handleLinkageError(first, sandbox);
-                }
-                while (!thrown.isEmpty()) {
-                  first.addSuppressed(thrown.remove());
-                }
-                throw Util.sneakyThrow(first);
-              }
-            });
+    Throwable first = thrown.poll();
+    if (first != null) {
+      if (first instanceof LinkageError) {
+        // Potentially upgrade the LinkageError with a potentially more complete
+        // descriptive exception.
+        first = handleLinkageError(first, sandbox);
       }
-    };
+      while (!thrown.isEmpty()) {
+        first.addSuppressed(thrown.remove());
+      }
+      throw Util.sneakyThrow(first);
+    }
   }
 
   /**
@@ -396,6 +604,17 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
         });
   }
 
+  /**
+   * The goal of {@link HelperTestRunner} is to have {@link BlockJUnit4ClassRunner} instances that
+   * encapsulate bootstrapped test classes. When SandboxTestRunner is initially constructed, the
+   * test class is from the main app class loader. This test class can't be used to run tests
+   * because it can't load Android classes.
+   *
+   * <p>Because we need load a separate test class per sandbox, we need to create a new Runner that
+   * encapsulates the bootstrapped test class. This is primarily used to invoke the {@link
+   * ParentRunner#methodBlock(FrameworkMethod)}, which uses reflection to invoke before/after
+   * methods and test rules.
+   */
   protected static class HelperTestRunner extends BlockJUnit4ClassRunner {
     public FrameworkMethod frameworkMethod;
 
@@ -409,6 +628,22 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
       return super.methodBlock(method);
     }
 
+    // for visibility from SandboxTestRunner.methodBlock()
+    @Override
+    public List<TestRule> classRules() {
+      return super.classRules();
+    }
+
+    @Override
+    protected Statement withAfterClasses(Statement statement) {
+      return super.withAfterClasses(statement);
+    }
+
+    @Override
+    protected Statement withBeforeClasses(Statement statement) {
+      return super.withBeforeClasses(statement);
+    }
+
     /**
      * For tests with a timeout, we need to wrap the test method execution (but not {@code @Before}s
      * or {@code @After}s in a {@link TimeLimitedStatement}. JUnit's built-in {@link FailOnTimeout}
@@ -457,7 +692,7 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
     List<Class<?>> shadowClasses = new ArrayList<>();
     addShadows(shadowClasses, getTestClass().getJavaClass().getAnnotation(SandboxConfig.class));
     addShadows(shadowClasses, method.getAnnotation(SandboxConfig.class));
-    return shadowClasses.toArray(new Class[shadowClasses.size()]);
+    return shadowClasses.toArray(new Class[0]);
   }
 
   private void addShadows(List<Class<?>> shadowClasses, SandboxConfig annotation) {
diff --git a/nativeruntime/Android.bp b/nativeruntime/Android.bp
index 76c177eaf..5aa785a0b 100644
--- a/nativeruntime/Android.bp
+++ b/nativeruntime/Android.bp
@@ -12,15 +12,15 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_nativeruntime_upstream",
+    name: "Robolectric_nativeruntime",
     libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_resources_upstream",
-        "Robolectric_pluginapi_upstream",
-        "Robolectric_utils_upstream",
-        "Robolectric_utils_reflector_upstream",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_sandbox",
+        "Robolectric_resources",
+        "Robolectric_pluginapi",
+        "Robolectric_utils",
+        "Robolectric_utils_reflector",
         "robolectric-accessibility-test-framework-2.1",
         "robolectric-javax.annotation-api-1.2",
         "hamcrest-library",
diff --git a/nativeruntime/build.gradle.kts b/nativeruntime/build.gradle.kts
index 249d5ebd3..35eb78884 100644
--- a/nativeruntime/build.gradle.kts
+++ b/nativeruntime/build.gradle.kts
@@ -63,7 +63,6 @@ if (System.getenv("PUBLISH_NATIVERUNTIME_DIST_COMPAT") == "true") {
 dependencies {
   api(project(":shadowapi"))
   api(project(":utils"))
-  api(project(":utils:reflector"))
   api(libs.guava)
 
   implementation(libs.robolectric.nativeruntime.dist.compat)
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/ColorSpaceRgbNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/ColorSpaceRgbNatives.java
index 24f70a34c..f05aa30f4 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/ColorSpaceRgbNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/ColorSpaceRgbNatives.java
@@ -17,7 +17,7 @@
 package org.robolectric.nativeruntime;
 
 /**
- * Native methods for BitmapFactory JNI registration.
+ * Native methods for ColorSpace JNI registration.
  *
  * <p>Native method signatures are derived from
  * https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:frameworks/base/graphics/java/android/graphics/ColorSpace.java
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
index ab79e8803..077335766 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
@@ -1,12 +1,10 @@
 package org.robolectric.nativeruntime;
 
-import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.base.StandardSystemProperty.OS_ARCH;
 import static com.google.common.base.StandardSystemProperty.OS_NAME;
 
 import android.database.CursorWindow;
 import android.graphics.Typeface;
-import android.os.Build;
 import com.google.auto.service.AutoService;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
@@ -22,20 +20,27 @@ import java.nio.file.FileSystem;
 import java.nio.file.FileSystems;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Enumeration;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
 import java.util.stream.Stream;
 import javax.annotation.Priority;
 import org.robolectric.pluginapi.NativeRuntimeLoader;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.Logger;
 import org.robolectric.util.OsUtil;
 import org.robolectric.util.PerfStatsCollector;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.TempDirectory;
 import org.robolectric.util.inject.Injector;
+import org.robolectric.versioning.AndroidVersions;
 
 /** Loads the Robolectric native runtime. */
 @AutoService(NativeRuntimeLoader.class)
@@ -114,7 +119,7 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
           });
 
   /**
-   * {@link #DEFERRED_STATIC_INITIALIZERS} that invoke their own native methods in static
+   * {@code DEFERRED_STATIC_INITIALIZERS} that invoke their own native methods in static
    * initializers. Unlike libcore, registering JNI on the JVM causes static initialization to be
    * performed on the class. Because of this, static initializers cannot invoke the native methods
    * of the class under registration. Executing these static initializers must be deferred until
@@ -145,6 +150,34 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
     nativeRuntimeLoader.get().ensureLoaded();
   }
 
+  /**
+   * Overridable in Android, due to private resources.
+   */
+  protected void maybeCopyExtraResources(TempDirectory dir) {
+    //default to no-op
+  }
+
+  /**
+   * Overridable in Android, due to changing shadows in private branches.
+   */
+  protected List<String> getCoreClassNatives(){
+    return CORE_CLASS_NATIVES;
+  }
+
+  /**
+   * Overridable in Android, due to changing shadows in private branches.
+   */
+  protected  List<String> getDeferredStaticInitializers(){
+    return DEFERRED_STATIC_INITIALIZERS;
+  }
+
+  /**
+   * Overridable in Android, due to changing shadows in private branches.
+   */
+  protected List<String> getGraphicsNatives(){
+    return GRAPHICS_CLASS_NATIVES;
+  }
+
   @Override
   public synchronized void ensureLoaded() {
     if (loaded.get()) {
@@ -166,15 +199,16 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
               "loadNativeRuntime",
               () -> {
                 extractDirectory = new TempDirectory("nativeruntime");
-                if (Build.VERSION.SDK_INT >= O) {
+                if (AndroidVersions.CURRENT.getSdkInt() >= AndroidVersions.O.SDK_INT) {
                   // Only copy fonts if graphics is supported, not just SQLite.
                   maybeCopyFonts(extractDirectory);
                 }
                 maybeCopyIcuData(extractDirectory);
+                maybeCopyExtraResources(extractDirectory);
                 if (isAndroidVOrGreater()) {
-                  System.setProperty("core_native_classes", String.join(",", CORE_CLASS_NATIVES));
+                  System.setProperty("core_native_classes", String.join(",", getCoreClassNatives()));
                   System.setProperty(
-                      "graphics_native_classes", String.join(",", GRAPHICS_CLASS_NATIVES));
+                      "graphics_native_classes", String.join(",", getGraphicsNatives()));
                   System.setProperty("method_binding_format", METHOD_BINDING_FORMAT);
                 }
                 loadLibrary(extractDirectory);
@@ -188,17 +222,53 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
     }
   }
 
+
+  private static List<String> getResourcesInAndroidAll(String prefix) throws IOException {
+    try {
+      String jarPath = Resources.getResource("build.prop").toURI().toString().split("!")[0].substring("jar:file:".length());
+      List<String> resources = new ArrayList<>();
+      try (JarFile jarFile = new JarFile(jarPath)) {
+        Enumeration<JarEntry> entries = jarFile.entries();
+        while (entries.hasMoreElements()) {
+          JarEntry entry = entries.nextElement();
+          if (entry.getName().startsWith(prefix) && !entry.isDirectory()) {
+            resources.add(entry.getName());
+          }
+        }
+      }
+      return resources;
+    } catch (URISyntaxException syntaxException) {
+      throw new IOException(syntaxException);
+    }
+  }
+
   /** Attempts to load the ICU dat file. This is only relevant for native graphics. */
   private void maybeCopyIcuData(TempDirectory tempDirectory) throws IOException {
     URL icuDatUrl;
     try {
-      icuDatUrl =
-          Resources.getResource(isAndroidVOrGreater() ? "icu/icudt75l.dat" : "icu/icudt68l.dat");
+      if ( AndroidVersions.CURRENT.getSdkInt() <= AndroidVersions.U.SDK_INT ) {
+        icuDatUrl = Resources.getResource("icu/icudt68l.dat");
+      } else {
+        List<String> resources = getResourcesInAndroidAll("icu/icudt");
+        if (resources.size() != 1) {
+          throw new RuntimeException("More than one icudt file in android-all jar: " + resources);
+        } else {
+          icuDatUrl = Resources.getResource(resources.get(0));
+        }
+
+      }
     } catch (IllegalArgumentException e) {
-      return;
+      System.out.println("Could not load icu data file ");
+      throw new RuntimeException(e);
     }
     Path icuPath = tempDirectory.create("icu");
-    Path icuDatPath = icuPath.resolve(isAndroidVOrGreater() ? "icudt75l.dat" : "icudt68l.dat");
+    Path icuDatPath;
+    if ( AndroidVersions.CURRENT.getSdkInt() <= AndroidVersions.U.SDK_INT ) {
+      icuDatPath = icuPath.resolve("icudt68l.dat");
+    } else {
+      String[] parts = icuDatUrl.toString().split("/");
+      icuDatPath = icuPath.resolve(parts[parts.length-1]);
+    }
     Resources.asByteSource(icuDatUrl).copyTo(Files.asByteSink(icuDatPath.toFile()));
     System.setProperty("icu.data.path", icuDatPath.toAbsolutePath().toString());
     System.setProperty("icu.locale.default", Locale.getDefault().toLanguageTag());
@@ -209,7 +279,7 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
    * graphics.
    */
   private void maybeCopyFonts(TempDirectory tempDirectory) throws IOException {
-    URI fontsUri = null;
+    URI fontsUri;
     try {
       fontsUri = Resources.getResource("fonts/").toURI();
     } catch (IllegalArgumentException | URISyntaxException e) {
@@ -251,6 +321,7 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   private void loadLibrary(TempDirectory tempDirectory) throws IOException {
     Path libraryPath = tempDirectory.getBasePath().resolve(libraryName());
     URL libraryResource = Resources.getResource(nativeLibraryPath());
+    Logger.info("Reading android native library from: " + libraryResource);
     Resources.asByteSource(libraryResource).copyTo(Files.asByteSink(libraryPath.toFile()));
     System.load(libraryPath.toAbsolutePath().toString());
   }
@@ -318,6 +389,6 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   }
 
   private static boolean isAndroidVOrGreater() {
-    return Build.VERSION.SDK_INT >= /* VANILLA_ICE_CREAM */ 35;
+    return AndroidVersions.CURRENT.getSdkInt() >= AndroidVersions.V.SDK_INT;
   }
 }
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java
index 140751417..d9ceefe09 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java
@@ -26,7 +26,7 @@ import android.view.Surface;
 import java.io.FileDescriptor;
 
 /**
- * Native methods for {@link HardwareRenderer} JNI registration.
+ * Native methods for {@link android.graphics.HardwareRenderer} JNI registration.
  *
  * <p>Native method signatures are derived from
  * https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:frameworks/base/graphics/java/android/graphics/HardwareRenderer.java
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererObserverNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererObserverNatives.java
index 4de5d34d3..e3b667255 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererObserverNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererObserverNatives.java
@@ -17,7 +17,7 @@
 package org.robolectric.nativeruntime;
 
 /**
- * Native methods for {@link ImageDecoder} JNI registration.
+ * Native methods for {@link android.graphics.HardwareRendererObserver} JNI registration.
  *
  * <p>Native method signatures are derived from
  * https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:frameworks/base/graphics/java/android/graphics/HardwareRendererObserver.java
diff --git a/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf b/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf
index 95243cde8..5a5df64aa 100644
Binary files a/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf and b/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf differ
diff --git a/nativeruntime/src/main/resources/icu/icudt.dat b/nativeruntime/src/main/resources/icu/icudt.dat
deleted file mode 100644
index 9e1ba17e9..000000000
Binary files a/nativeruntime/src/main/resources/icu/icudt.dat and /dev/null differ
diff --git a/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLazyLoadTest.java b/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLazyLoadTest.java
index 164ee6e01..0f13d398d 100644
--- a/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLazyLoadTest.java
+++ b/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLazyLoadTest.java
@@ -2,7 +2,6 @@ package org.robolectric.nativeruntime;
 
 import static com.google.common.truth.Truth.assertThat;
 
-import android.app.Application;
 import android.database.CursorWindow;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,10 +21,9 @@ public final class DefaultNativeRuntimeLazyLoadTest {
    *
    * <p>Note that lazy loading is disabled for V and above.
    */
-  @SuppressWarnings("UnusedVariable")
   @Test
-  public void lazyLoad() throws Exception {
-    Application application = RuntimeEnvironment.getApplication();
+  public void lazyLoad() {
+    RuntimeEnvironment.getApplication();
     assertThat(DefaultNativeRuntimeLoader.isLoaded()).isFalse();
     CursorWindow cursorWindow = new CursorWindow("hi");
     cursorWindow.close();
diff --git a/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoaderTest.java b/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoaderTest.java
index e5d395f2e..00122bdde 100644
--- a/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoaderTest.java
+++ b/nativeruntime/src/test/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoaderTest.java
@@ -25,7 +25,8 @@ public final class DefaultNativeRuntimeLoaderTest {
   }
 
   @Test
-  public void concurrentLoad() throws Exception {
+  public void concurrentLoad() {
+    //noinspection resource
     executor.execute(() -> SQLiteDatabase.create(null));
     CursorWindow cursorWindow = new CursorWindow("sdfsdf");
     cursorWindow.close();
diff --git a/nativeruntime/src/test/resources/AndroidManifest.xml b/nativeruntime/src/test/resources/AndroidManifest.xml
index 217b06533..31ba363be 100644
--- a/nativeruntime/src/test/resources/AndroidManifest.xml
+++ b/nativeruntime/src/test/resources/AndroidManifest.xml
@@ -1,8 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
   package="org.robolectric.nativeruntime">
 
-  <uses-sdk android:minSdkVersion="19" android:targetSdkVersion="33"/>
+  <uses-sdk android:minSdkVersion="21" android:targetSdkVersion="33"/>
   <application />
 </manifest>
diff --git a/pluginapi/Android.bp b/pluginapi/Android.bp
index 29e46f990..bfe52de83 100644
--- a/pluginapi/Android.bp
+++ b/pluginapi/Android.bp
@@ -12,11 +12,11 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_pluginapi_upstream",
+    name: "Robolectric_pluginapi",
     srcs: ["src/main/java/**/*.java"],
     static_libs: [
         "robolectric-javax.annotation-api-1.2",
-        "Robolectric_annotations_upstream",
+        "Robolectric_annotations",
         "guava",
         "jsr330",
         "jsr305",
@@ -28,10 +28,10 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_pluginapi_tests_upstream",
+    name: "Robolectric_pluginapi_tests",
     srcs: ["src/test/java/**/*.java"],
     static_libs: [
-        "Robolectric_pluginapi_upstream",
+        "Robolectric_pluginapi",
         "hamcrest",
         "guava",
         "junit",
diff --git a/preinstrumented/build.gradle.kts b/preinstrumented/build.gradle.kts
index 7587fd668..60cfa578a 100644
--- a/preinstrumented/build.gradle.kts
+++ b/preinstrumented/build.gradle.kts
@@ -36,11 +36,14 @@ val instrumentAll by
         val outputPath =
           layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
 
-        javaexec {
-          classpath = sourceSets.getByName("main").runtimeClasspath
-          mainClass.set(javaMainClass)
-          args = listOf(inputPath, outputPath)
-        }
+        providers
+          .javaexec {
+            classpath = sourceSets.getByName("main").runtimeClasspath
+            mainClass.set(javaMainClass)
+            args = listOf(inputPath, outputPath)
+          }
+          .result
+          .get()
       }
     }
   }
diff --git a/processor/Android.bp b/processor/Android.bp
index 12f88fefb..bf2e68c23 100644
--- a/processor/Android.bp
+++ b/processor/Android.bp
@@ -13,7 +13,7 @@ package {
 }
 
 java_library {
-    name: "libRobolectric_processor_upstream",
+    name: "libRobolectric_processor",
     host_supported: true,
     device_supported: false,
     srcs: ["src/main/java/**/*.java"],
@@ -24,9 +24,9 @@ java_library {
         "auto_service_plugin",
     ],
     static_libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_shadows_versioning_upstream",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_shadows_versioning",
         "asm-9.6",
         "asm-commons-9.6",
         "asm-tree-9.6",
@@ -48,23 +48,23 @@ java_library {
 }
 
 java_plugin {
-    name: "Robolectric_processor_upstream",
+    name: "Robolectric_processor",
     processor_class: "org.robolectric.annotation.processing.RobolectricProcessor",
-    static_libs: ["libRobolectric_processor_upstream"],
+    static_libs: ["libRobolectric_processor"],
 }
 
 //#############################################
 // Compile Robolectric processor tests
 //#############################################
 java_test_host {
-    name: "Robolectric_processor_tests_upstream",
+    name: "Robolectric_processor_tests",
     srcs: ["src/test/java/**/*.java"],
     java_resource_dirs: ["src/test/resources"],
-    java_resources: [":Robolectric_processor_tests_resources_upstream"],
+    java_resources: [":Robolectric_processor_tests_resources"],
     static_libs: [
-        "Robolectric_annotations_upstream",
-        "libRobolectric_processor_upstream",
-        "Robolectric_shadowapi_upstream",
+        "Robolectric_annotations",
+        "libRobolectric_processor",
+        "Robolectric_shadowapi",
         "robolectric-javax.annotation-api-1.2",
         "robolectric-compile-testing-0.19",
         "mockito",
@@ -85,7 +85,7 @@ java_test_host {
 
 // Workaround: java_resource_dirs ignores *.java files
 filegroup {
-    name: "Robolectric_processor_tests_resources_upstream",
+    name: "Robolectric_processor_tests_resources",
     path: "src/test/resources",
     srcs: ["src/test/resources/**/*.java"],
 }
diff --git a/processor/sdks.txt b/processor/sdks.txt
deleted file mode 100644
index a8732906c..000000000
--- a/processor/sdks.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-prebuilts/misc/common/robolectric/android-all/android-all-4.1.2_r1-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-4.2.2_r1.2-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-4.3_r2-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-4.4_r1-robolectric-r2.jar
-prebuilts/misc/common/robolectric/android-all/android-all-5.0.2_r3-robolectric-r0.jar
-prebuilts/misc/common/robolectric/android-all/android-all-5.1.1_r9-robolectric-r2.jar
-prebuilts/misc/common/robolectric/android-all/android-all-6.0.1_r3-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-7.0.0_r1-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-7.1.0_r7-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-8.0.0_r4-robolectric-r1.jar
-prebuilts/misc/common/robolectric/android-all/android-all-8.1.0-robolectric-4611349.jar
-prebuilts/misc/common/robolectric/android-all/android-all-9-robolectric-4913185-2.jar
-prebuilts/misc/common/robolectric/android-all/android-all-10-robolectric-5803371.jar
-prebuilts/misc/common/robolectric/android-all/android-all-11-robolectric-6757853.jar
-prebuilts/misc/common/robolectric/android-all/android-all-12-robolectric-7732740.jar
-prebuilts/misc/common/robolectric/android-all/android-all-12.1-robolectric-8229987.jar
-prebuilts/misc/common/robolectric/android-all/android-all-13-robolectric-9030017.jar
-prebuilts/misc/common/robolectric/android-all/android-all-14-robolectric-10818077.jar
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
index 31ed3481c..43b2c0c8a 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
@@ -56,7 +56,7 @@ import org.robolectric.versioning.AndroidVersions;
 /** Encapsulates a collection of Android framework jars. */
 public class SdkStore {
 
-  private static final String VALID_CLASS_NAME_ANNOTATION_CHARS = "^[a-zA-Z0-9_$.;\\[\\]]+$";
+  private static final String VALID_CLASS_NAME_ANNOTATION_CHARS = "^\\[?[a-zA-Z0-9_$.]+;?$";
 
   private final Set<Sdk> sdks = new TreeSet<>();
   private boolean loaded = false;
@@ -606,7 +606,13 @@ public class SdkStore {
                     + "."
                     + methodElement.getSimpleName());
           }
-          paramType = className.value().replace('$', '.');
+          paramType = className.value();
+          if (paramType.startsWith("[")) {
+            // Convert an array type descriptor to a Java class name.
+            // e.g. '[java.lang.String;'-> 'java.lang.String[]'
+            paramType = Type.getType(paramType).getClassName();
+          }
+          paramType = paramType.replace('$', '.');
         }
 
         String paramTypeWithoutGenerics = typeWithoutGenerics(paramType);
diff --git a/resources/Android.bp b/resources/Android.bp
index 9e7575adc..52c9f5e60 100644
--- a/resources/Android.bp
+++ b/resources/Android.bp
@@ -12,11 +12,11 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_resources_upstream",
+    name: "Robolectric_resources",
     srcs: ["src/main/java/**/*.java"],
     libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_annotations",
+        "Robolectric_utils",
         "guava",
         "jsr305",
         "auto_value_annotations",
@@ -32,12 +32,12 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_resources_tests_upstream",
+    name: "Robolectric_resources_tests",
     srcs: ["src/test/java/**/*.java"],
     static_libs: [
-        "Robolectric_resources_upstream",
-        "Robolectric_annotations_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_resources",
+        "Robolectric_annotations",
+        "Robolectric_utils",
         "mockito",
         "hamcrest",
         "guava",
diff --git a/resources/src/main/java/org/robolectric/res/Plural.java b/resources/src/main/java/org/robolectric/res/Plural.java
index f77e7376d..0181480c1 100644
--- a/resources/src/main/java/org/robolectric/res/Plural.java
+++ b/resources/src/main/java/org/robolectric/res/Plural.java
@@ -17,9 +17,6 @@ public class Plural {
     } else if ("two".equals(quantity)) {
       num = 2;
       usedInEnglish = false;
-    } else if ("other".equals(quantity)) {
-      num = -1;
-      usedInEnglish = true;
     } else {
       num = -1;
       usedInEnglish = true;
diff --git a/resources/src/main/java/org/robolectric/res/android/Chunk.java b/resources/src/main/java/org/robolectric/res/android/Chunk.java
index 05e3aafe0..00fb56854 100644
--- a/resources/src/main/java/org/robolectric/res/android/Chunk.java
+++ b/resources/src/main/java/org/robolectric/res/android/Chunk.java
@@ -114,8 +114,9 @@ class Chunk {
   }
 
   public ResTable_lib_entry asResTable_lib_entry() {
-    if (header_size() >= ResTable_lib_entry.SIZEOF) {
-      return new ResTable_lib_entry(device_chunk_.myBuf(), device_chunk_.myOffset());
+    if (data_size() >= ResTable_lib_entry.SIZEOF) {
+      return new ResTable_lib_entry(
+          device_chunk_.myBuf(), device_chunk_.myOffset() + header_size());
     } else {
       return null;
     }
diff --git a/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java b/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
index a524b3151..47266325a 100644
--- a/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
+++ b/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
@@ -797,11 +797,8 @@ public class LoadedArsc {
               ResTable_lib_entry entryBegin = child_chunk.asResTable_lib_entry();
               // ResTable_lib_entry entry_end = entryBegin + dtohl(lib.count);
               // for (auto entryIter = entryBegin; entryIter != entry_end; ++entryIter) {
-              for (ResTable_lib_entry entryIter = entryBegin;
-                  entryIter.myOffset() != entryBegin.myOffset() + dtohl(lib.count);
-                  entryIter =
-                      new ResTable_lib_entry(
-                          entryIter.myBuf(), entryIter.myOffset() + ResTable_lib_entry.SIZEOF)) {
+              ResTable_lib_entry entryIter = entryBegin;
+              do {
                 String package_name =
                     Util.ReadUtf16StringFromDevice(
                         entryIter.packageName, entryIter.packageName.length);
@@ -818,7 +815,16 @@ public class LoadedArsc {
                 //     dtohl(entryIter.packageId));
                 loaded_package.dynamic_package_map_.add(
                     new DynamicPackageEntry(package_name, dtohl(entryIter.packageId)));
-              }
+
+                if (entryIter.myOffset() + ResTable_lib_entry.SIZEOF
+                    != entryBegin.myOffset() + dtohl(lib.count) * ResTable_lib_entry.SIZEOF) {
+                  entryIter =
+                      new ResTable_lib_entry(
+                          entryIter.myBuf(), entryIter.myOffset() + ResTable_lib_entry.SIZEOF);
+                } else {
+                  break;
+                }
+              } while (true);
             }
             break;
 
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java b/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
index 2ee74e965..6bfac637c 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
@@ -286,6 +286,7 @@ public class ResTableTheme {
 
   private void dumpToLog() {}
 
+  @SuppressWarnings("DuplicateBranches") // The 'else' clause contains TODOs to remove duplication
   public int setTo(ResTableTheme other) {
     styles.clear();
     styles.addAll(other.styles);
diff --git a/robolectric/Android.bp b/robolectric/Android.bp
index 906896b7a..78c77486a 100644
--- a/robolectric/Android.bp
+++ b/robolectric/Android.bp
@@ -12,20 +12,20 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_robolectric_upstream",
+    name: "Robolectric_robolectric",
     libs: [
-        "Robolectric_shadows_framework_upstream",
-        "Robolectric_shadows_versioning_upstream",
-        "Robolectric_annotations_upstream",
-        "Robolectric_nativeruntime_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_resources_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_junit_upstream",
-        "Robolectric_utils_upstream",
-        "Robolectric_utils_reflector_upstream",
-        "robolectric-host-androidx-test-ext-junit_upstream",
-        "robolectric-host-androidx-test-monitor_upstream",
+        "Robolectric_shadows_framework",
+        "Robolectric_shadows_versioning",
+        "Robolectric_annotations",
+        "Robolectric_nativeruntime",
+        "Robolectric_shadowapi",
+        "Robolectric_resources",
+        "Robolectric_sandbox",
+        "Robolectric_junit",
+        "Robolectric_utils",
+        "Robolectric_utils_reflector",
+        "robolectric-host-androidx-test-ext-junit",
+        "robolectric-host-androidx-test-monitor",
         "robolectric-maven-ant-tasks-2.1.3",
         "bouncycastle-unbundled",
         "asm-commons-9.6",
@@ -57,23 +57,23 @@ genrule {
 // Compile Robolectric robolectric tests
 //#############################################
 java_test_host {
-    name: "Robolectric_robolectric_tests_upstream",
+    name: "Robolectric_robolectric_tests",
     srcs: ["src/test/java/**/*.java"],
     java_resource_dirs: ["src/test/resources"],
     static_libs: [
-        "Robolectric_robolectric_upstream",
-        "Robolectric_shadows_framework_upstream",
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_shadows_versioning_upstream",
-        "Robolectric_resources_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_junit_upstream",
-        "Robolectric_utils_upstream",
-        "Robolectric_utils_reflector_upstream",
-        "robolectric-host-androidx-test-ext-junit_upstream",
-        "robolectric-host-androidx-test-monitor_upstream",
-        "robolectric-host-androidx-test-core_upstream",
+        "Robolectric_robolectric",
+        "Robolectric_shadows_framework",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_shadows_versioning",
+        "Robolectric_resources",
+        "Robolectric_sandbox",
+        "Robolectric_junit",
+        "Robolectric_utils",
+        "Robolectric_utils_reflector",
+        "robolectric-host-androidx-test-ext-junit",
+        "robolectric-host-androidx-test-monitor",
+        "robolectric-host-androidx-test-core",
         "robolectric-maven-ant-tasks-2.1.3",
         "mockito",
         "bouncycastle-unbundled",
@@ -88,13 +88,14 @@ java_test_host {
         "asm-tree-9.6",
         "junit",
         "icu4j",
-        "truth-1.4.0-prebuilt",
+        "guava-testlib",
+        "truth",
         "robolectric-ant-1.8.0",
         "asm-9.6",
         "jsr305",
         "TestParameterInjector",
         "robolectric-host-androidx_test_espresso",
-        "robolectric-host-androidx-test-ext-truth_upstream",
+        "robolectric-host-androidx-test-ext-truth",
     ],
     libs: ["robolectric-host-android_all"],
     // Robolectric tests do not work well with unit tests setup yet
diff --git a/robolectric/build.gradle.kts b/robolectric/build.gradle.kts
index 8b0a2ab6d..843ff8df9 100644
--- a/robolectric/build.gradle.kts
+++ b/robolectric/build.gradle.kts
@@ -54,6 +54,7 @@ dependencies {
   testImplementation("androidx.test.ext:truth:$axtTruthVersion@aar")
   testImplementation("androidx.test:runner:$axtRunnerVersion@aar")
   testImplementation(libs.guava)
+  testImplementation(libs.guava.testlib)
   testCompileOnly(AndroidSdk.MAX_SDK.coordinates) // compile against latest Android SDK
   testRuntimeOnly(androidStubsJar())
 }
diff --git a/robolectric/src/main/java/org/robolectric/ConfigMerger.java b/robolectric/src/main/java/org/robolectric/ConfigMerger.java
index 0e47fed4d..053f0e1d4 100644
--- a/robolectric/src/main/java/org/robolectric/ConfigMerger.java
+++ b/robolectric/src/main/java/org/robolectric/ConfigMerger.java
@@ -15,7 +15,6 @@ import java.util.Properties;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.Join;
 
 /**
  * Computes the effective Robolectric configuration for a given test method.
@@ -96,7 +95,7 @@ public class ConfigMerger {
   protected Properties getConfigProperties(String packageName) {
     List<String> packageParts = new ArrayList<>(Arrays.asList(packageName.split("\\.")));
     packageParts.add(RobolectricTestRunner.CONFIG_PROPERTIES);
-    final String resourceName = Join.join("/", packageParts);
+    final String resourceName = String.join("/", packageParts);
     try (InputStream resourceAsStream = getResourceAsStream(resourceName)) {
       if (resourceAsStream == null) return null;
       Properties properties = new Properties();
diff --git a/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java b/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java
index 2b5e0f634..028d6d258 100644
--- a/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java
+++ b/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java
@@ -13,6 +13,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.stream.IntStream;
+import javax.annotation.Nonnull;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
@@ -52,6 +53,7 @@ public final class RobolectricTestParameterInjector extends RobolectricTestRunne
   }
 
   @Override
+  @Nonnull
   protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
     return new InstrumentationConfiguration.Builder(super.createClassLoaderConfig(method))
         .doNotAcquireClass(DelegateTestRunner.class)
@@ -133,15 +135,23 @@ public final class RobolectricTestParameterInjector extends RobolectricTestRunne
    * the SDK sandbox.
    */
   private static final class DelegateHelperTestRunner extends HelperTestRunner {
-    private final DelegateTestRunner testParameterInjector;
-    private final Map<Method, List<FrameworkMethod>> injectedMethods;
+    private DelegateTestRunner testParameterInjector;
+    private Map<Method, List<FrameworkMethod>> injectedMethods;
 
     public DelegateHelperTestRunner(Class<?> bootstrappedTestClass) throws InitializationError {
       super(bootstrappedTestClass);
-      testParameterInjector = createSandboxedDelegateTestParameterInjector(bootstrappedTestClass);
-      injectedMethods =
-          testParameterInjector.computeTestMethods().stream()
-              .collect(groupingBy(FrameworkMethod::getMethod));
+    }
+
+    // This is currently called from a single thread so no need to synchronize.
+    private DelegateTestRunner getTestParameterInjector() {
+      if (testParameterInjector == null) {
+        testParameterInjector =
+            createSandboxedDelegateTestParameterInjector(getTestClass().getJavaClass());
+        injectedMethods =
+            testParameterInjector.computeTestMethods().stream()
+                .collect(groupingBy(FrameworkMethod::getMethod));
+      }
+      return testParameterInjector;
     }
 
     @Override
@@ -159,14 +169,15 @@ public final class RobolectricTestParameterInjector extends RobolectricTestRunne
       RobolectricInjectedFrameworkMethod robolectricInjectedFrameworkMethod =
           (RobolectricInjectedFrameworkMethod) frameworkMethod;
       // Map the method to one that has been class loaded in ths SDK sandbox.
-      return testParameterInjector.methodBlock(
-          Objects.requireNonNull(injectedMethods.get(method.getMethod()))
-              .get(robolectricInjectedFrameworkMethod.getInjectedMethodIndex()));
+      return getTestParameterInjector()
+          .methodBlock(
+              Objects.requireNonNull(injectedMethods.get(method.getMethod()))
+                  .get(robolectricInjectedFrameworkMethod.getInjectedMethodIndex()));
     }
 
     @Override
     protected Statement methodInvoker(FrameworkMethod method, Object test) {
-      return testParameterInjector.methodInvoker(method, test);
+      return getTestParameterInjector().methodInvoker(method, test);
     }
 
     private static DelegateTestRunner createSandboxedDelegateTestParameterInjector(
diff --git a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
index 920a0a6a9..f2d69ff1d 100644
--- a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
+++ b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
@@ -2,6 +2,7 @@ package org.robolectric;
 
 import com.google.auto.service.AutoService;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import java.io.IOException;
 import java.io.InputStream;
@@ -68,6 +69,7 @@ public class RobolectricTestRunner extends SandboxTestRunner {
   private static final int MAX_DATA_DIR_NAME_LENGTH = 120;
   private static final Injector DEFAULT_INJECTOR = defaultInjector().build();
   private static final Map<ManifestIdentifier, AndroidManifest> appManifestsCache = new HashMap<>();
+  private static final ImmutableList<RunListener> RUN_LISTENERS = loadRunListeners();
 
   static {
     // This starts up the Poller SunPKCS11-Darwin thread early, outside of any Robolectric
@@ -81,6 +83,22 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     System.setProperty("org.bouncycastle.rsa.max_mr_tests", "0");
   }
 
+  protected static ImmutableList<RunListener> loadRunListeners() {
+    ServiceLoader<RunListener> sl =
+        ServiceLoader.load(RunListener.class, Thread.currentThread().getContextClassLoader());
+    List<RunListener> runListeners = sl.stream().map(ServiceLoader.Provider::get).toList();
+    for (RunListener listener : runListeners) {
+      if (!listener.getClass().getPackageName().startsWith("org.robolectric")) {
+        Logger.warn(
+            "Adding a non-robolectric maintained RunListener"
+                + " (via Plugins/ServiceLoader) can lead to instability, use at your own risk.\n"
+                + "Listener is question : "
+                + listener.getClass().getName());
+      }
+    }
+    return ImmutableList.copyOf(runListeners);
+  }
+
   protected static Injector.Builder defaultInjector() {
     return SandboxTestRunner.defaultInjector().bind(Properties.class, System.getProperties());
   }
@@ -120,16 +138,7 @@ public class RobolectricTestRunner extends SandboxTestRunner {
 
   @Override
   public void run(RunNotifier notifier) {
-    ServiceLoader<RunListener> sl =
-        ServiceLoader.load(RunListener.class, Thread.currentThread().getContextClassLoader());
-    for (RunListener listener : sl) {
-      if (!listener.getClass().getPackageName().startsWith("org.robolectric")) {
-        Logger.warn(
-            "Adding a non-robolectric maintained RunListener"
-                + " (via Plugins/ServiceLoader) can lead to instability, use at your own risk.\n"
-                + "Listener is question : "
-                + listener.getClass().getName());
-      }
+    for (RunListener listener : RobolectricTestRunner.RUN_LISTENERS) {
       notifier.addListener(listener);
     }
     super.run(notifier);
@@ -273,6 +282,20 @@ public class RobolectricTestRunner extends SandboxTestRunner {
         classLoaderConfig, sdk, resourcesMode, looperMode, sqliteMode, graphicsMode);
   }
 
+  @Override
+  protected void configureSandbox(Sandbox sandbox, FrameworkMethod method) {
+    RobolectricFrameworkMethod roboMethod = (RobolectricFrameworkMethod) method;
+
+    SQLiteMode.Mode sqliteMode =
+        roboMethod.configuration == null
+            ? SQLiteMode.Mode.LEGACY
+            : roboMethod.configuration.get(SQLiteMode.Mode.class);
+
+    AndroidSandbox androidSandbox = (AndroidSandbox) sandbox;
+    androidSandbox.updateModes(sqliteMode);
+    super.configureSandbox(sandbox, method);
+  }
+
   @Override
   protected void beforeTest(Sandbox sandbox, FrameworkMethod method, Method bootstrappedMethod)
       throws Throwable {
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
index 7c08982b2..e38a41df6 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
@@ -2,6 +2,7 @@ package org.robolectric.android.internal;
 
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.shadow.api.Shadow.newInstanceOf;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -19,6 +20,7 @@ import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageParser;
 import android.content.pm.PackageParser.Package;
 import android.content.res.Resources;
+import android.content.type.DefaultMimeMapFactory;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
@@ -26,6 +28,7 @@ import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
 import android.provider.FontsContract;
+import android.provider.MediaStore;
 import android.util.DisplayMetrics;
 import androidx.test.platform.app.InstrumentationRegistry;
 import com.google.common.annotations.VisibleForTesting;
@@ -48,6 +51,7 @@ import javax.net.ssl.SSLSession;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.conscrypt.OkHostnameVerifier;
 import org.conscrypt.OpenSSLProvider;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.Bootstrap;
 import org.robolectric.annotation.Config;
@@ -57,6 +61,7 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
 import org.robolectric.config.ConfigurationRegistry;
+import org.robolectric.fakes.FakeMediaProvider;
 import org.robolectric.internal.ShadowProvider;
 import org.robolectric.internal.TestEnvironment;
 import org.robolectric.manifest.AndroidManifest;
@@ -217,6 +222,11 @@ public class AndroidTestEnvironment implements TestEnvironment {
     RuntimeEnvironment.setAndroidFrameworkJarPath(sdkJarPath);
     Bootstrap.setDisplayConfiguration(androidConfiguration, displayMetrics);
 
+    // mime resources only available on S and above
+    if (RuntimeEnvironment.getApiLevel() >= S) {
+      libcore.content.type.MimeMap.setDefaultSupplier(DefaultMimeMapFactory::create);
+    }
+
     Instrumentation instrumentation = createInstrumentation();
     InstrumentationRegistry.registerInstance(instrumentation, new Bundle());
     Supplier<Application> applicationSupplier = createApplicationSupplier(appManifest, config);
@@ -379,6 +389,12 @@ public class AndroidTestEnvironment implements TestEnvironment {
             AppCompatCallbacks.class, "install", ClassParameter.from(long[].class, new long[0]));
       }
 
+      if (RuntimeEnvironment.getApiLevel() >= Q
+          && Boolean.parseBoolean(
+              System.getProperty("robolectric.installFakeMediaProvider", "true"))) {
+        Robolectric.setupContentProvider(FakeMediaProvider.class, MediaStore.AUTHORITY);
+      }
+
       PerfStatsCollector.getInstance()
           .measure(
               "application onCreate()",
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/LocalControlledLooper.java b/robolectric/src/main/java/org/robolectric/android/internal/LocalControlledLooper.java
index 195aa13ab..7c9f6048c 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/LocalControlledLooper.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/LocalControlledLooper.java
@@ -15,7 +15,9 @@ public class LocalControlledLooper implements ControlledLooper {
 
   @Override
   public void drainMainThreadUntilIdle() {
-    shadowMainLooper().idle();
+    if (shadowMainLooper().isPaused()) {
+      shadowMainLooper().idle();
+    }
   }
 
   @Override
diff --git a/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java b/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java
index 297dba525..3a77cc7ec 100644
--- a/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java
+++ b/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java
@@ -68,7 +68,6 @@ public class SandboxManager {
           sandboxBuilder.build(instrumentationConfig, sdk, compileSdk, resourcesMode, sqliteMode);
       sandboxesByKey.put(key, androidSandbox);
     }
-    androidSandbox.updateModes(sqliteMode);
     return androidSandbox;
   }
 
diff --git a/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java b/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java
index 775823c76..0e39f78e0 100644
--- a/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java
+++ b/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java
@@ -76,6 +76,10 @@ public final class ExpectedLogMessagesRule implements TestRule {
       ImmutableSet.of(
           "Typeface",
           "RingtoneManager",
+          // When Robolectric's shadow of PowerManager.WakeLock.acquire() was updated to set some
+          // bits on the underlying WakeLock object, it started logging a wtf when a WakeLock was
+          // still held when it was finalized.
+          "PowerManager",
           // Fails when attempting to preload classes by name
           "PhonePolicy",
           // Ignore MultiDex log messages
@@ -83,7 +87,10 @@ public final class ExpectedLogMessagesRule implements TestRule {
           // Logged starting with Android 33 as:
           // E/RippleDrawable: The RippleDrawable.STYLE_PATTERNED animation is not supported for a
           // non-hardware accelerated Canvas. Skipping animation.
-          "RippleDrawable");
+          "RippleDrawable",
+          // Logged in in-development versions of android with AconfigStorageException
+          "FeatureFlagsImpl",
+          "FeatureFlagsImplExport");
 
   private final Set<ExpectedLogItem> expectedLogs = new HashSet<>();
   private final Set<LogItem> observedLogs = new HashSet<>();
diff --git a/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java b/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java
new file mode 100644
index 000000000..bfa0dc93f
--- /dev/null
+++ b/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java
@@ -0,0 +1,54 @@
+package org.robolectric.junit.rules;
+
+import com.google.common.base.Preconditions;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * A rule that lets you override system properties for tests. All properties are restored after each
+ * test.
+ */
+public class SetSystemPropertyRule implements TestRule {
+
+  private Map<String, String> originalProperties = new HashMap<>();
+
+  public SetSystemPropertyRule() {}
+
+  public void set(String key, String value) {
+    Preconditions.checkNotNull(key);
+    if (!originalProperties.containsKey(key)) {
+      originalProperties.put(key, System.getProperty(key));
+    }
+    System.setProperty(key, value);
+  }
+
+  @Override
+  public Statement apply(Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          restoreProperties();
+        }
+      }
+    };
+  }
+
+  private void restoreProperties() {
+    for (Map.Entry<String, String> entry : originalProperties.entrySet()) {
+      String key = entry.getKey();
+      String value = entry.getValue();
+      if (value != null) {
+        System.setProperty(key, value);
+      } else {
+        System.clearProperty(key);
+      }
+    }
+    originalProperties.clear();
+  }
+}
diff --git a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
index ccd2e07d3..8a420ad3e 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
@@ -1,6 +1,5 @@
 package org.robolectric.plugins;
 
-
 import com.google.auto.service.AutoService;
 import java.util.Properties;
 import javax.annotation.Nonnull;
diff --git a/robolectric/src/test/java/org/robolectric/BeforeAfterClassInvocationTest.java b/robolectric/src/test/java/org/robolectric/BeforeAfterClassInvocationTest.java
new file mode 100644
index 000000000..df2fdf696
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/BeforeAfterClassInvocationTest.java
@@ -0,0 +1,127 @@
+package org.robolectric;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.junit.runner.RunWith;
+import org.junit.runner.notification.Failure;
+import org.junit.runners.JUnit4;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+import org.robolectric.annotation.experimental.LazyApplication;
+import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
+import org.robolectric.internal.bytecode.InstrumentationConfiguration;
+
+@RunWith(JUnit4.class)
+public final class BeforeAfterClassInvocationTest {
+  public static final class StateHolder {
+
+    public static final AtomicBoolean beforeClassCalled = new AtomicBoolean(false);
+    public static final AtomicBoolean afterClassCalled = new AtomicBoolean(false);
+    public static final AtomicInteger testCounter = new AtomicInteger(0);
+    public static final AtomicInteger beforeClassCounter = new AtomicInteger(0);
+    public static final AtomicInteger afterClassCounter = new AtomicInteger(0);
+
+    public static void reset() {
+      beforeClassCalled.set(false);
+      afterClassCalled.set(false);
+      testCounter.set(0);
+      beforeClassCounter.set(0);
+      afterClassCounter.set(0);
+    }
+
+    private StateHolder() {}
+  }
+
+  @Before
+  public void setup() {
+    StateHolder.reset();
+  }
+
+  @Test
+  public void testBeforeAfterClassCalled() throws Exception {
+    assertThat(StateHolder.beforeClassCalled.get()).isFalse();
+    assertThat(StateHolder.afterClassCalled.get()).isFalse();
+    // run SimpleTest
+    assertNoFailures(run(new Runner(SimpleTest.class)));
+
+    assertThat(StateHolder.beforeClassCalled.get()).isTrue();
+    assertThat(StateHolder.afterClassCalled.get()).isTrue();
+  }
+
+  @Test
+  public void testInvocationCount() throws Exception {
+    assertThat(StateHolder.beforeClassCounter.get()).isEqualTo(0);
+    assertThat(StateHolder.afterClassCounter.get()).isEqualTo(0);
+    assertThat(StateHolder.testCounter.get()).isEqualTo(0);
+    // run SimpleTest
+    assertNoFailures(run(new Runner(SimpleTest.class)));
+
+    assertThat(StateHolder.beforeClassCounter.get()).isEqualTo(1);
+    assertThat(StateHolder.afterClassCounter.get()).isEqualTo(1);
+    assertThat(StateHolder.testCounter.get()).isEqualTo(2);
+  }
+
+  private Result run(RobolectricTestRunner runner) {
+    JUnitCore runnerCore = new JUnitCore();
+    return runnerCore.run(runner);
+  }
+
+  private void assertNoFailures(Result result) {
+    if (!result.wasSuccessful()) {
+      for (Failure failure : result.getFailures()) {
+        fail(failure.getMessage() + failure.getException());
+      }
+    }
+  }
+
+  // This is a test that only has @BeforeClass and @AfterClass to avoid any tanglement with
+  // @ClassRule
+  @LazyApplication(LazyLoad.OFF)
+  public static class SimpleTest {
+    @BeforeClass
+    public static void beforeClass() {
+      StateHolder.beforeClassCalled.set(true);
+      StateHolder.beforeClassCounter.incrementAndGet();
+    }
+
+    @AfterClass
+    public static void afterClass() throws Exception {
+      StateHolder.afterClassCalled.set(true);
+      StateHolder.afterClassCounter.incrementAndGet();
+    }
+
+    @Test
+    public void shouldDoNothingMuch() throws Exception {
+      StateHolder.testCounter.incrementAndGet();
+    }
+
+    @Test
+    public void shouldDoNothingMuchMore() throws Exception {
+      StateHolder.testCounter.incrementAndGet();
+    }
+  }
+
+  public static class Runner extends SingleSdkRobolectricTestRunner {
+    public Runner(Class<?> testClass) throws InitializationError {
+      super(testClass);
+    }
+
+    @Override
+    protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
+      InstrumentationConfiguration.Builder builder =
+          new InstrumentationConfiguration.Builder(super.createClassLoaderConfig(method));
+      // This is to make sure that the StateHolder class is not acquired in the sandbox.
+      builder.doNotAcquireClass(StateHolder.class);
+      return builder.build();
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/ClassRuleInvocationTest.java b/robolectric/src/test/java/org/robolectric/ClassRuleInvocationTest.java
new file mode 100644
index 000000000..025d70609
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/ClassRuleInvocationTest.java
@@ -0,0 +1,89 @@
+package org.robolectric;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNotNull;
+
+import android.os.Build;
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runner.RunWith;
+import org.junit.runners.model.Statement;
+import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions;
+
+@RunWith(RobolectricTestRunner.class)
+public final class ClassRuleInvocationTest {
+  private static final AtomicReference<TemporaryFolder> tempFolder = new AtomicReference<>();
+  private static final int CUR_SDK = Build.VERSION.SDK_INT;
+  private static final AtomicInteger counter = new AtomicInteger(0);
+
+  @ClassRule
+  public static final TestRule TEMP_FOLDER_RULE =
+      new TestRule() {
+        @Override
+        public Statement apply(Statement base, Description description) {
+          return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+              // Set the tempFolder
+              tempFolder.set(new TemporaryFolder());
+              base.evaluate();
+            }
+          };
+        }
+      };
+
+  @ClassRule public static final SdkCheckClassRule sdkCheckClassRule = new SdkCheckClassRule();
+
+  public static class SdkCheckClassRule implements TestRule {
+    public SdkCheckClassRule() {
+      // Check that Android code can be executed when the rule is constructed.
+      assertThat(Build.VERSION.SDK_INT).isEqualTo(CUR_SDK);
+      assertThat(counter.incrementAndGet()).isEqualTo(1);
+    }
+
+    @Override
+    public Statement apply(Statement base, Description description) {
+      assertThat(Build.VERSION.SDK_INT).isEqualTo(CUR_SDK);
+      assertThat(counter.incrementAndGet()).isEqualTo(2);
+
+      return new Statement() {
+        @Override
+        public void evaluate() throws Throwable {
+          assertThat(Build.VERSION.SDK_INT).isEqualTo(CUR_SDK);
+          assertThat(counter.incrementAndGet()).isEqualTo(3);
+          base.evaluate();
+        }
+      };
+    }
+  }
+
+  @Test
+  public void comparisonCount() {
+    assertThat(counter.get()).isEqualTo(3);
+  }
+
+  @Test
+  public void testUsingTempFolder() throws IOException {
+    assertNotNull(tempFolder.get());
+  }
+
+  // Make sure that the ClassRule is setup for other sandboxes.
+  @Test
+  @Config(sdk = AndroidVersions.S.SDK_INT)
+  public void anotherSandboxTempFolder() throws IOException {
+    assertNotNull(tempFolder.get());
+  }
+
+  @Test
+  @Config(sdk = AndroidVersions.S.SDK_INT)
+  public void anotherSandboxComparisonCount() throws IOException {
+    assertThat(counter.get()).isEqualTo(3);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java b/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java
index 98dfc1cd8..63190216e 100644
--- a/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java
+++ b/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java
@@ -11,6 +11,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.internal.Instrument;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 @RunWith(AndroidJUnit4.class)
 @Config(sdk = Config.NEWEST_SDK)
@@ -35,7 +36,7 @@ public class InvokeDynamicTest {
     assertThat(real.x).isEqualTo(-5);
     assertThat(shadow.x).isEqualTo(5);
 
-    Shadow.directlyOn(real, Real.class).setX(42);
+    Shadow.directlyOn(real, Real.class, "setX", ClassParameter.from(int.class, 42));
     assertThat(real.x).isEqualTo(42);
     assertThat(shadow.x).isEqualTo(5);
   }
diff --git a/robolectric/src/test/java/org/robolectric/LegacyTestRunnerSequenceTest.java b/robolectric/src/test/java/org/robolectric/LegacyTestRunnerSequenceTest.java
new file mode 100644
index 000000000..7cb1aa65b
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/LegacyTestRunnerSequenceTest.java
@@ -0,0 +1,175 @@
+package org.robolectric;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
+import static org.junit.Assert.fail;
+
+import android.app.Application;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Nonnull;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.Result;
+import org.junit.runner.RunWith;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.JUnit4;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+import org.robolectric.annotation.Config;
+import org.robolectric.internal.bytecode.InstrumentationConfiguration;
+import org.robolectric.internal.bytecode.Sandbox;
+
+@RunWith(JUnit4.class)
+public class LegacyTestRunnerSequenceTest {
+
+  public static class StateHolder {
+    public static List<String> transcript;
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    assume().that(Boolean.getBoolean("robolectric.useLegacySandboxFlow")).isTrue();
+    StateHolder.transcript = new ArrayList<>();
+  }
+
+  @Test
+  public void shouldRunThingsInTheRightOrder() throws Exception {
+    assertNoFailures(run(new Runner(SimpleTest.class)));
+    assertThat(StateHolder.transcript)
+        .containsExactly(
+            "configureSandbox",
+            "application.onCreate",
+            "beforeTest",
+            "application.beforeTest",
+            "prepareTest",
+            "application.prepareTest",
+            "TEST!",
+            "application.onTerminate",
+            "afterTest",
+            "application.afterTest");
+    StateHolder.transcript.clear();
+  }
+
+  @Test
+  public void whenNoAppManifest_shouldRunThingsInTheRightOrder() throws Exception {
+    assertNoFailures(run(new Runner(SimpleTest.class) {}));
+    assertThat(StateHolder.transcript)
+        .containsExactly(
+            "configureSandbox",
+            "application.onCreate",
+            "beforeTest",
+            "application.beforeTest",
+            "prepareTest",
+            "application.prepareTest",
+            "TEST!",
+            "application.onTerminate",
+            "afterTest",
+            "application.afterTest");
+    StateHolder.transcript.clear();
+  }
+
+  @Ignore
+  @Config(application = LegacyTestRunnerSequenceTest.MyApplication.class)
+  public static class SimpleTest {
+    @Test
+    public void shouldDoNothingMuch() throws Exception {
+      StateHolder.transcript.add("TEST!");
+    }
+  }
+
+  private Result run(Runner runner) throws InitializationError {
+    RunNotifier notifier = new RunNotifier();
+    Result result = new Result();
+    notifier.addListener(result.createListener());
+    runner.run(notifier);
+    return result;
+  }
+
+  private void assertNoFailures(Result result) {
+    if (!result.wasSuccessful()) {
+      for (Failure failure : result.getFailures()) {
+        fail(failure.getMessage());
+      }
+    }
+  }
+
+  public static class Runner extends SingleSdkRobolectricTestRunner {
+
+    Runner(Class<?> testClass) throws InitializationError {
+      super(testClass);
+    }
+
+    @Nonnull
+    @Override
+    protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
+      InstrumentationConfiguration.Builder builder =
+          new InstrumentationConfiguration.Builder(super.createClassLoaderConfig(method));
+      builder.doNotAcquireClass(StateHolder.class);
+      return builder.build();
+    }
+
+    @Nonnull
+    @Override
+    protected Class<? extends TestLifecycle> getTestLifecycleClass() {
+      return MyTestLifecycle.class;
+    }
+
+    @Override
+    protected void configureSandbox(Sandbox sandbox, FrameworkMethod frameworkMethod) {
+      StateHolder.transcript.add("configureSandbox");
+      super.configureSandbox(sandbox, frameworkMethod);
+    }
+  }
+
+  public static class MyTestLifecycle extends DefaultTestLifecycle {
+
+    @Override
+    public void beforeTest(Method method) {
+      StateHolder.transcript.add("beforeTest");
+      super.beforeTest(method);
+    }
+
+    @Override
+    public void prepareTest(Object test) {
+      StateHolder.transcript.add("prepareTest");
+      super.prepareTest(test);
+    }
+
+    @Override
+    public void afterTest(Method method) {
+      StateHolder.transcript.add("afterTest");
+      super.afterTest(method);
+    }
+  }
+
+  public static class MyApplication extends Application implements TestLifecycleApplication {
+    @Override
+    public void onCreate() {
+      StateHolder.transcript.add("application.onCreate");
+    }
+
+    @Override
+    public void beforeTest(Method method) {
+      StateHolder.transcript.add("application.beforeTest");
+    }
+
+    @Override
+    public void prepareTest(Object test) {
+      StateHolder.transcript.add("application.prepareTest");
+    }
+
+    @Override
+    public void afterTest(Method method) {
+      StateHolder.transcript.add("application.afterTest");
+    }
+
+    @Override
+    public void onTerminate() {
+      StateHolder.transcript.add("application.onTerminate");
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
index f24405ead..4a539dcfc 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
@@ -4,7 +4,6 @@ import static com.google.common.truth.Truth.assertThat;
 import static java.util.stream.Collectors.toSet;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
-import static org.robolectric.RobolectricTestRunner.defaultInjector;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
 import android.annotation.SuppressLint;
@@ -19,7 +18,6 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.spi.FileSystemProvider;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
@@ -29,11 +27,13 @@ import javax.annotation.Nonnull;
 import javax.inject.Inject;
 import javax.inject.Named;
 import org.junit.After;
+import org.junit.AfterClass;
 import org.junit.AssumptionViolatedException;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.FixMethodOrder;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
@@ -51,16 +51,15 @@ import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
 import org.robolectric.config.ConfigurationRegistry;
 import org.robolectric.internal.AndroidSandbox.TestEnvironmentSpec;
 import org.robolectric.internal.ShadowProvider;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.pluginapi.Sdk;
-import org.robolectric.pluginapi.SdkProvider;
 import org.robolectric.pluginapi.TestEnvironmentLifecyclePlugin;
 import org.robolectric.pluginapi.config.ConfigurationStrategy.Configuration;
 import org.robolectric.pluginapi.perf.Metric;
 import org.robolectric.pluginapi.perf.PerfStatsReporter;
 import org.robolectric.plugins.DefaultSdkPicker;
 import org.robolectric.plugins.SdkCollection;
-import org.robolectric.plugins.StubSdk;
 import org.robolectric.util.TempDirectory;
 import org.robolectric.util.TestUtil;
 
@@ -74,6 +73,8 @@ public class RobolectricTestRunnerTest {
   private String priorAlwaysInclude;
   private SdkCollection sdkCollection;
 
+  @Rule public SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
+
   @Before
   public void setUp() throws Exception {
     notifier = new RunNotifier();
@@ -110,36 +111,7 @@ public class RobolectricTestRunnerTest {
             "started: oldSdkMethod",
             "failure: API level 11 is not available",
             "finished: oldSdkMethod",
-            "ignored: ignoredOldSdkMethod")
-        .inOrder();
-  }
-
-  @Test
-  public void testsWithUnsupportedSdkShouldBeIgnored() throws Exception {
-    RobolectricTestRunner runner =
-        new RobolectricTestRunner(
-            TestWithTwoMethods.class,
-            defaultInjector()
-                .bind(
-                    SdkProvider.class,
-                    () ->
-                        Arrays.asList(
-                            TestUtil.getSdkCollection().getSdk(33), new StubSdk(34, false)))
-                .build());
-    runner.run(notifier);
-    assertThat(events)
-        .containsExactly(
-            "started: first[33]",
-            "finished: first[33]",
-            "started: first",
-            "ignored: first: Failed to create a Robolectric sandbox: unsupported",
-            "finished: first",
-            "started: second[33]",
-            "finished: second[33]",
-            "started: second",
-            "ignored: second: Failed to create a Robolectric sandbox: unsupported",
-            "finished: second")
-        .inOrder();
+            "ignored: ignoredOldSdkMethod");
   }
 
   @Test
@@ -578,7 +550,11 @@ public class RobolectricTestRunnerTest {
     RobolectricTestRunner runner =
         new SingleSdkRobolectricTestRunner(TestWithBeforeClassThatThrowsRuntimeException.class);
     runner.run(notifier);
-    assertThat(events.get(1)).startsWith("failure: fail");
+    if (Boolean.getBoolean("robolectric.useLegacySandboxFlow")) {
+      assertThat(events.get(1)).startsWith("failure: fail");
+    } else {
+      assertThat(events.get(0)).isEqualTo("failure: fail");
+    }
   }
 
   @Ignore
@@ -591,4 +567,46 @@ public class RobolectricTestRunnerTest {
     @Test
     public void test() {}
   }
+
+  @Test
+  public void shouldInvokeAfterClass() throws Exception {
+    RobolectricTestRunner runner =
+        new SingleSdkRobolectricTestRunner(TestClassWithAfterClass.class);
+    setSystemPropertyRule.set("RobolectricTestRunnerTest.wasAfterClassCalled", "false");
+    runner.run(notifier);
+    assertThat(System.getProperty("RobolectricTestRunnerTest.wasAfterClassCalled"))
+        .isEqualTo("true");
+  }
+
+  @Ignore
+  public static class TestClassWithAfterClass {
+    @AfterClass
+    public static void afterClass() {
+      System.setProperty("RobolectricTestRunnerTest.wasAfterClassCalled", "true");
+    }
+
+    @Test
+    public void test() {}
+  }
+
+  @Ignore
+  @FixMethodOrder(MethodSorters.NAME_ASCENDING)
+  public static class TestWithIgnore {
+    @Test
+    public void test() {}
+
+    // to verify @Ignore behavior
+    @Ignore
+    @Test
+    public void ignoredTest() {}
+  }
+
+  @Test
+  public void shouldNotifyIgnoredTests() throws Exception {
+    RobolectricTestRunner runner = new SingleSdkRobolectricTestRunner(TestWithIgnore.class);
+    runner.run(notifier);
+    assertThat(events)
+        .containsExactly("ignored: ignoredTest", "started: test", "finished: test")
+        .inOrder();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java
index f571f89de..d1f85466a 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java
@@ -23,31 +23,31 @@ public class RobolectricTestRunnerThreadTest {
 
   @Before
   public void setUp() throws Exception {
-    assertThat(Thread.currentThread() == sThread).isTrue();
-    assertThat(Thread.currentThread().getContextClassLoader() == sClassLoader).isTrue();
+    assertThat(Thread.currentThread()).isEqualTo(sThread);
+    assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(sClassLoader);
   }
 
   @After
   public void tearDown() throws Exception {
-    assertThat(Thread.currentThread() == sThread).isTrue();
-    assertThat(Thread.currentThread().getContextClassLoader() == sClassLoader).isTrue();
+    assertThat(Thread.currentThread()).isEqualTo(sThread);
+    assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(sClassLoader);
   }
 
   @Test
   public void firstTest() {
-    assertThat(Thread.currentThread() == sThread).isTrue();
-    assertThat(Thread.currentThread().getContextClassLoader() == sClassLoader).isTrue();
+    assertThat(Thread.currentThread()).isEqualTo(sThread);
+    assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(sClassLoader);
   }
 
   @Test
   public void secondTest() {
-    assertThat(Thread.currentThread() == sThread).isTrue();
-    assertThat(Thread.currentThread().getContextClassLoader() == sClassLoader).isTrue();
+    assertThat(Thread.currentThread()).isEqualTo(sThread);
+    assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(sClassLoader);
   }
 
   @AfterClass
   public static void afterClass() throws Exception {
-    assertThat(Thread.currentThread() == sThread).isTrue();
-    assertThat(Thread.currentThread().getContextClassLoader() == sClassLoader).isTrue();
+    assertThat(Thread.currentThread()).isEqualTo(sThread);
+    assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(sClassLoader);
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java b/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java
index 00b285526..116aa137a 100644
--- a/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java
+++ b/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java
@@ -34,6 +34,7 @@ public class SingleSdkRobolectricTestRunner extends RobolectricTestRunner {
   }
 
   @Override
+  @Nonnull
   protected AndroidSandbox getSandbox(FrameworkMethod method) {
     AndroidSandbox sandbox = super.getSandbox(method);
     latestSandbox = sandbox;
diff --git a/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java b/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java
index 10f96618d..0b8a13ad1 100644
--- a/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java
+++ b/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java
@@ -8,16 +8,27 @@ import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nonnull;
+import org.junit.After;
+import org.junit.AfterClass;
 import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.MethodRule;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
 import org.junit.runner.RunWith;
 import org.junit.runner.notification.Failure;
-import org.junit.runner.notification.RunNotifier;
 import org.junit.runners.JUnit4;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.Statement;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.experimental.LazyApplication;
+import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
 import org.robolectric.internal.bytecode.InstrumentationConfiguration;
 import org.robolectric.internal.bytecode.Sandbox;
 
@@ -25,83 +36,324 @@ import org.robolectric.internal.bytecode.Sandbox;
 public class TestRunnerSequenceTest {
 
   public static class StateHolder {
-    public static List<String> transcript;
-  }
+    public static final List<String> transcript = new ArrayList<>();
+
+    public static void add(String s) {
+      transcript.add(s);
+    }
 
-  private String priorResourcesMode;
+    public static void reset() {
+      transcript.clear();
+    }
+  }
 
   @Before
   public void setUp() throws Exception {
-    StateHolder.transcript = new ArrayList<>();
+    StateHolder.reset();
   }
 
   @Test
-  public void shouldRunThingsInTheRightOrder() throws Exception {
+  public void shouldRunThingsInTheRightOrder_simpleTest() throws Exception {
     assertNoFailures(run(new Runner(SimpleTest.class)));
     assertThat(StateHolder.transcript)
         .containsExactly(
             "configureSandbox",
-            "application.onCreate",
-            "beforeTest",
-            "application.beforeTest",
-            "prepareTest",
-            "application.prepareTest",
+            "@ClassRule apply",
+            "@ClassRule before",
+            "@BeforeClass",
+            "configureSandbox",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
             "TEST!",
-            "application.onTerminate",
-            "afterTest",
-            "application.afterTest");
-    StateHolder.transcript.clear();
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "@AfterClass",
+            "@ClassRule after");
   }
 
   @Test
-  public void whenNoAppManifest_shouldRunThingsInTheRightOrder() throws Exception {
-    assertNoFailures(run(new Runner(SimpleTest.class) {}));
+  public void shouldRunMultiConfigTestInTheRightOrder() throws Exception {
+    assertNoFailures(run(new Runner(MultiConfigTest.class)));
+    // As the order is not deterministic, we just check that the expected sequence is a substring
+    // of the actual one.
     assertThat(StateHolder.transcript)
-        .containsExactly(
+        // using containsAtLeast due to the test order being non-deterministic
+        .containsAtLeast(
+            "configureSandbox",
+            "@ClassRule apply",
+            "@ClassRule before",
+            "@BeforeClass",
+            "configureSandbox",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
+            "TEST!",
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
+            "TEST!",
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "@AfterClass",
+            "@ClassRule after");
+    assertThat(StateHolder.transcript)
+        // using containsAtLeast due to the test order being non-deterministic
+        .containsAtLeast(
+            "configureSandbox",
+            "@ClassRule apply",
+            "@ClassRule before",
+            "@BeforeClass",
+            "configureSandbox",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
+            "TEST!",
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "@AfterClass",
+            "@ClassRule after");
+  }
+
+  @Test
+  public void whenNoAppManifest_shouldRunMultiConfigTestInTheRightOrder() throws Exception {
+    assertNoFailures(run(new Runner(MultiConfigTest.class) {}));
+    // Default SDK = 30 Sandbox
+    assertThat(StateHolder.transcript)
+        // using containsAtLeast due to the test order being non-deterministic
+        .containsAtLeast(
             "configureSandbox",
-            "application.onCreate",
-            "beforeTest",
-            "application.beforeTest",
-            "prepareTest",
-            "application.prepareTest",
+            "@ClassRule apply",
+            "@ClassRule before",
+            "@BeforeClass",
+            "configureSandbox",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
+            "TEST!",
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "configureSandbox",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
             "TEST!",
-            "application.onTerminate",
-            "afterTest",
-            "application.afterTest");
-    StateHolder.transcript.clear();
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "@AfterClass",
+            "@ClassRule after");
+
+    assertThat(StateHolder.transcript)
+        // using containsAtLeast due to the test order being non-deterministic
+        .containsAtLeast(
+            "configureSandbox",
+            "@ClassRule apply",
+            "@ClassRule before",
+            "@BeforeClass",
+            "configureSandbox",
+            "Android environment set up",
+            "application.onCreate()",
+            "TestLifecycle.beforeTest()",
+            "application.beforeTest()",
+            "TestLifecycle.prepareTest()",
+            "application.prepareTest()",
+            "@Rule apply",
+            "@Rule before",
+            "@Before",
+            "TEST!",
+            "@After",
+            "@Rule after",
+            "application.onTerminate()",
+            "TestLifecycle.afterTest()",
+            "application.afterTest()",
+            "Android environment resetState",
+            "@AfterClass",
+            "@ClassRule after");
   }
 
+  @RunWith(Runner.class)
   @Config(application = TestRunnerSequenceTest.MyApplication.class)
+  @LazyApplication(LazyLoad.OFF)
   public static class SimpleTest {
+    @ClassRule
+    public static TestRule rule =
+        new TestRule() {
+          @Override
+          public Statement apply(final Statement base, Description description) {
+            add("@ClassRule apply");
+            return new Statement() {
+              @Override
+              public void evaluate() throws Throwable {
+                try {
+                  add("@ClassRule before");
+                  base.evaluate();
+                } finally {
+                  add("@ClassRule after");
+                }
+              }
+            };
+          }
+        };
+
+    @Rule
+    public MethodRule junitRule =
+        new MethodRule() {
+          @Override
+          public Statement apply(final Statement base, FrameworkMethod method, Object target) {
+            add("@Rule apply");
+            return new Statement() {
+              @Override
+              public void evaluate() throws Throwable {
+                add("@Rule before");
+                base.evaluate();
+                add("@Rule after");
+              }
+            };
+          }
+        };
+
+    @BeforeClass
+    public static void beforeClass() throws Exception {
+      add("@BeforeClass");
+    }
+
+    @Before
+    public void setUp() throws Exception {
+      add("@Before");
+    }
+
     @Test
     public void shouldDoNothingMuch() throws Exception {
-      StateHolder.transcript.add("TEST!");
+      add("TEST!");
+    }
+
+    @After
+    public void tearDown() throws Exception {
+      add("@After");
+    }
+
+    @AfterClass
+    public static void afterClass() throws Exception {
+      add("@AfterClass");
+    }
+
+    private static void add(String s) {
+      StateHolder.add(s + extraInfo());
+    }
+
+    private static String extraInfo() {
+      return "";
     }
   }
 
-  private Result run(Runner runner) throws InitializationError {
-    RunNotifier notifier = new RunNotifier();
-    Result result = new Result();
-    notifier.addListener(result.createListener());
-    runner.run(notifier);
-    return result;
+  @Config(application = TestRunnerSequenceTest.MyApplication.class)
+  @LazyApplication(LazyLoad.OFF)
+  public static class MultiConfigTest extends SimpleTest {
+    @Test
+    public void shouldDoNothingMuch2() throws Exception {
+      StateHolder.add("TEST!");
+    }
+
+    @Config(instrumentedPackages = "some.package.b" /* creates a new sandbox */)
+    @Test
+    public void shouldDoEvenLess() throws Exception {
+      StateHolder.add("TEST!");
+    }
+  }
+
+  private Result run(Runner runner) {
+    JUnitCore runnerCore = new JUnitCore();
+    return runnerCore.run(runner);
   }
 
   private void assertNoFailures(Result result) {
     if (!result.wasSuccessful()) {
       for (Failure failure : result.getFailures()) {
-        fail(failure.getMessage());
+        fail(failure.getMessage() + failure.getException());
       }
     }
   }
 
   public static class Runner extends SingleSdkRobolectricTestRunner {
-
-    Runner(Class<?> testClass) throws InitializationError {
+    public Runner(Class<?> testClass) throws InitializationError {
       super(testClass);
     }
 
-    @Nonnull
+    @Override
+    protected void beforeTest(Sandbox sandbox, FrameworkMethod method, Method bootstrappedMethod)
+        throws Throwable {
+      StateHolder.add("Android environment set up" + extraInfo());
+      super.beforeTest(sandbox, method, bootstrappedMethod);
+    }
+
+    @Override
+    protected void finallyAfterTest(FrameworkMethod method) {
+      StateHolder.add("Android environment resetState" + extraInfo());
+      super.finallyAfterTest(method);
+    }
+
     @Override
     protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
       InstrumentationConfiguration.Builder builder =
@@ -118,28 +370,32 @@ public class TestRunnerSequenceTest {
 
     @Override
     protected void configureSandbox(Sandbox sandbox, FrameworkMethod frameworkMethod) {
-      StateHolder.transcript.add("configureSandbox");
+      StateHolder.add("configureSandbox");
       super.configureSandbox(sandbox, frameworkMethod);
     }
+
+    private static String extraInfo() {
+      return "";
+    }
   }
 
   public static class MyTestLifecycle extends DefaultTestLifecycle {
 
     @Override
     public void beforeTest(Method method) {
-      StateHolder.transcript.add("beforeTest");
+      StateHolder.add("TestLifecycle.beforeTest()");
       super.beforeTest(method);
     }
 
     @Override
     public void prepareTest(Object test) {
-      StateHolder.transcript.add("prepareTest");
+      StateHolder.add("TestLifecycle.prepareTest()");
       super.prepareTest(test);
     }
 
     @Override
     public void afterTest(Method method) {
-      StateHolder.transcript.add("afterTest");
+      StateHolder.add("TestLifecycle.afterTest()");
       super.afterTest(method);
     }
   }
@@ -147,27 +403,27 @@ public class TestRunnerSequenceTest {
   public static class MyApplication extends Application implements TestLifecycleApplication {
     @Override
     public void onCreate() {
-      StateHolder.transcript.add("application.onCreate");
+      StateHolder.add("application.onCreate()");
     }
 
     @Override
     public void beforeTest(Method method) {
-      StateHolder.transcript.add("application.beforeTest");
+      StateHolder.add("application.beforeTest()");
     }
 
     @Override
     public void prepareTest(Object test) {
-      StateHolder.transcript.add("application.prepareTest");
+      StateHolder.add("application.prepareTest()");
     }
 
     @Override
     public void afterTest(Method method) {
-      StateHolder.transcript.add("application.afterTest");
+      StateHolder.add("application.afterTest()");
     }
 
     @Override
     public void onTerminate() {
-      StateHolder.transcript.add("application.onTerminate");
+      StateHolder.add("application.onTerminate()");
     }
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java b/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java
index 7644f95a9..abfb5a15a 100644
--- a/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java
@@ -1,7 +1,6 @@
 package org.robolectric.android;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
 import android.util.Log;
@@ -9,6 +8,7 @@ import android.view.View;
 import android.widget.Toast;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.common.testing.EqualsTester;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -34,6 +34,6 @@ public class ShadowingTest {
   @Test
   public void shouldDelegateToObjectEqualsIfShadowHasNone() throws Exception {
     View view = new View(ApplicationProvider.getApplicationContext());
-    assertEquals(view, view);
+    new EqualsTester().addEqualityGroup(view).testEquals();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java
index 81739c55d..c31ab6252 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java
@@ -3,93 +3,110 @@ package org.robolectric.fakes;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.view.MenuItem;
 import android.view.View;
 import androidx.test.core.app.ApplicationProvider;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Arrays;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.ParameterizedRobolectricTestRunner;
 import org.robolectric.R;
+import org.robolectric.RuntimeEnvironment;
 
-@RunWith(AndroidJUnit4.class)
+@RunWith(ParameterizedRobolectricTestRunner.class)
 public class RoboMenuItemTest {
-  private MenuItem item;
+  private Context context;
+  @Nonnull private MenuItem item;
   private TestOnActionExpandListener listener;
 
+  public RoboMenuItemTest(@Nonnull RoboMenuItem roboMenuItem) {
+    item = roboMenuItem;
+  }
+
   @Before
   public void setUp() throws Exception {
-    item = new RoboMenuItem(ApplicationProvider.getApplicationContext());
+    context = ApplicationProvider.getApplicationContext();
     listener = new TestOnActionExpandListener();
     item.setOnActionExpandListener(listener);
   }
 
   @Test
-  public void shouldCheckTheMenuItem() throws Exception {
+  public void shouldCheckTheMenuItem() {
     assertThat(item.isChecked()).isFalse();
     item.setChecked(true);
     assertThat(item.isChecked()).isTrue();
   }
 
   @Test
-  public void shouldAllowSettingCheckable() throws Exception {
+  public void shouldAllowSettingCheckable() {
     assertThat(item.isCheckable()).isFalse();
     item.setCheckable(true);
     assertThat(item.isCheckable()).isTrue();
   }
 
   @Test
-  public void shouldAllowSettingVisible() throws Exception {
+  public void shouldAllowSettingVisible() {
     assertThat(item.isVisible()).isTrue();
     item.setVisible(false);
     assertThat(item.isVisible()).isFalse();
   }
 
   @Test
-  public void expandActionView_shouldReturnFalseIfActionViewIsNull() throws Exception {
+  public void expandActionView_shouldReturnFalseIfActionViewIsNull() {
     item.setActionView(null);
     assertThat(item.expandActionView()).isFalse();
   }
 
   @Test
-  public void expandActionView_shouldSetExpandedTrue() throws Exception {
-    item.setActionView(new View(ApplicationProvider.getApplicationContext()));
+  public void expandActionView_shouldSetExpandedTrue() {
+    View actionView = new View(context);
+    item.setActionView(actionView);
+    assertThat(item.getActionView()).isEqualTo(actionView);
     assertThat(item.expandActionView()).isTrue();
     assertThat(item.isActionViewExpanded()).isTrue();
   }
 
   @Test
-  public void expandActionView_shouldInvokeListener() throws Exception {
-    item.setActionView(new View(ApplicationProvider.getApplicationContext()));
-    item.expandActionView();
+  public void expandActionView_shouldInvokeListener() {
+    View actionView = new View(context);
+    item.setActionView(actionView);
+    assertThat(item.getActionView()).isEqualTo(actionView);
+    assertThat(item.expandActionView()).isTrue();
     assertThat(listener.expanded).isTrue();
   }
 
   @Test
-  public void collapseActionView_shouldReturnFalseIfActionViewIsNull() throws Exception {
+  public void collapseActionView_shouldReturnFalseIfActionViewIsNull() {
     item.setActionView(null);
     assertThat(item.collapseActionView()).isFalse();
   }
 
   @Test
-  public void collapseActionView_shouldSetExpandedFalse() throws Exception {
-    item.setActionView(new View(ApplicationProvider.getApplicationContext()));
+  public void collapseActionView_shouldSetExpandedFalse() {
+    View actionView = new View(context);
+    item.setActionView(actionView);
+    assertThat(item.getActionView()).isEqualTo(actionView);
     item.expandActionView();
     assertThat(item.collapseActionView()).isTrue();
     assertThat(item.isActionViewExpanded()).isFalse();
   }
 
   @Test
-  public void collapseActionView_shouldInvokeListener() throws Exception {
-    item.setActionView(new View(ApplicationProvider.getApplicationContext()));
+  public void collapseActionView_shouldInvokeListener() {
+    View actionView = new View(context);
+    item.setActionView(actionView);
+    assertThat(item.getActionView()).isEqualTo(actionView);
     listener.expanded = true;
-    item.collapseActionView();
+    assertThat(item.collapseActionView()).isTrue();
     assertThat(listener.expanded).isFalse();
   }
 
   @Test
-  public void methodsShouldReturnThis() throws Exception {
+  public void methodsShouldReturnThis() {
     item = item.setEnabled(true);
     assertThat(item).isNotNull();
     item = item.setOnMenuItemClickListener(null);
@@ -131,7 +148,7 @@ public class RoboMenuItemTest {
   }
 
   @Test
-  public void setIcon_shouldNullifyOnZero() throws Exception {
+  public void setIcon_shouldNullifyOnZero() {
     assertThat(item.getIcon()).isNull();
     item.setIcon(R.drawable.an_image);
     assertThat(shadowOf(item.getIcon()).getCreatedFromResId()).isEqualTo(R.drawable.an_image);
@@ -140,9 +157,8 @@ public class RoboMenuItemTest {
   }
 
   @Test
-  public void getIcon_shouldReturnDrawableFromSetIconDrawable() throws Exception {
-    Drawable testDrawable =
-        ApplicationProvider.getApplicationContext().getResources().getDrawable(R.drawable.an_image);
+  public void getIcon_shouldReturnDrawableFromSetIconDrawable() {
+    Drawable testDrawable = context.getDrawable(R.drawable.an_image);
     assertThat(testDrawable).isNotNull();
     assertThat(item.getIcon()).isNull();
     item.setIcon(testDrawable);
@@ -150,30 +166,53 @@ public class RoboMenuItemTest {
   }
 
   @Test
-  public void getIcon_shouldReturnDrawableFromSetIconResourceId() throws Exception {
+  public void getIcon_shouldReturnDrawableFromSetIconResourceId() {
     assertThat(item.getIcon()).isNull();
     item.setIcon(R.drawable.an_other_image);
     assertThat(shadowOf(item.getIcon()).getCreatedFromResId()).isEqualTo(R.drawable.an_other_image);
   }
 
   @Test
-  public void setOnActionExpandListener_shouldReturnMenuItem() throws Exception {
+  public void setOnActionExpandListener_shouldReturnMenuItem() {
     assertThat(item.setOnActionExpandListener(listener)).isSameInstanceAs(item);
   }
 
+  @Test
+  public void setTitle_shouldNullifyOnZero() {
+    item.setTitle("title");
+    assertThat(item.getTitle()).isNotNull();
+    item.setTitle(0);
+    assertThat(item.getTitle()).isNull();
+  }
+
+  @Test
+  public void setTitle_shouldSetTitleFromResourceId() {
+    assertThat(item.getTitle()).isNull();
+    item.setTitle(R.string.app_name);
+    assertThat(item.getTitle()).isEqualTo(context.getString(R.string.app_name));
+  }
+
   static class TestOnActionExpandListener implements MenuItem.OnActionExpandListener {
     private boolean expanded = false;
 
     @Override
-    public boolean onMenuItemActionExpand(MenuItem menuItem) {
+    public boolean onMenuItemActionExpand(@Nonnull MenuItem menuItem) {
       expanded = true;
       return true;
     }
 
     @Override
-    public boolean onMenuItemActionCollapse(MenuItem menuItem) {
+    public boolean onMenuItemActionCollapse(@Nonnull MenuItem menuItem) {
       expanded = false;
       return true;
     }
   }
+
+  @ParameterizedRobolectricTestRunner.Parameters
+  public static Iterable<?> data() {
+    return Arrays.asList(
+        new RoboMenuItem(),
+        new RoboMenuItem(R.id.text1),
+        new RoboMenuItem(RuntimeEnvironment.getApplication()));
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
index 7112b59a2..10e7a70f9 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
@@ -32,6 +32,8 @@ public class RoboWebSettingsTest {
     assertThat(webSettings.getTextZoom()).isEqualTo(100);
     assertThat(webSettings.getDefaultTextEncodingName()).isEqualTo("UTF-8");
     assertThat(webSettings.getDefaultFontSize()).isEqualTo(16);
+    assertThat(webSettings.getUserAgentString()).isNotEmpty();
+    assertThat(RoboWebSettings.getDefaultUserAgent()).isNotEmpty();
 
     // deprecated methods
     assertThat(webSettings.getPluginsEnabled()).isFalse();
@@ -98,6 +100,23 @@ public class RoboWebSettingsTest {
     }
   }
 
+  @Test
+  public void testSetUserAgentString() {
+    String newUserAgentString = "Chrome/71.0.143.1";
+    webSettings.setUserAgentString(newUserAgentString);
+
+    assertThat(webSettings.getUserAgentString()).isEqualTo(newUserAgentString);
+  }
+
+  @Test
+  public void testSetUserAgentString_updateThenClear() {
+    webSettings.setUserAgentString("Chrome/71.0.143.1");
+
+    webSettings.setUserAgentString(null);
+
+    assertThat(webSettings.getUserAgentString()).isEqualTo(RoboWebSettings.getDefaultUserAgent());
+  }
+
   @Test
   public void testDatabaseEnabled() {
     for (boolean value : TRUE_AND_FALSE) {
@@ -290,4 +309,26 @@ public class RoboWebSettingsTest {
     webSettings.setForceDark(WebSettings.FORCE_DARK_AUTO);
     assertThat(webSettings.getForceDark()).isEqualTo(WebSettings.FORCE_DARK_AUTO);
   }
+
+  @Test
+  public void testSetDefaultUserAgentOverride() {
+    String defaultUserAgent = "Chrome/71.0.143.1";
+    RoboWebSettings.setDefaultUserAgentOverride(defaultUserAgent);
+
+    webSettings.setUserAgentString(null);
+
+    assertThat(webSettings.getUserAgentString()).isEqualTo(defaultUserAgent);
+    assertThat(RoboWebSettings.getDefaultUserAgent()).isEqualTo(defaultUserAgent);
+  }
+
+  @Test
+  public void testSetDefaultUserAgentOverride_reset() {
+    RoboWebSettings.setDefaultUserAgentOverride("Chrome/71.0.143.1");
+
+    RoboWebSettings.setDefaultUserAgentOverride(null);
+    webSettings.setUserAgentString(null);
+
+    assertThat(webSettings.getUserAgentString()).isNotEmpty();
+    assertThat(RoboWebSettings.getDefaultUserAgent()).isNotEmpty();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/junit/rules/SetSystemPropertyRuleTest.java b/robolectric/src/test/java/org/robolectric/junit/rules/SetSystemPropertyRuleTest.java
new file mode 100644
index 000000000..e10e7a717
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/junit/rules/SetSystemPropertyRuleTest.java
@@ -0,0 +1,46 @@
+package org.robolectric.junit.rules;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.FixMethodOrder;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.junit.runners.MethodSorters;
+
+/** Tests for {@link SetSystemPropertyRule}. */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+@RunWith(JUnit4.class)
+public final class SetSystemPropertyRuleTest {
+
+  @Rule public final SetSystemPropertyRule rule = new SetSystemPropertyRule();
+
+  /** Creates a system property with an initial state. */
+  @BeforeClass
+  public static void beforeClass() {
+    System.setProperty("robolectric.test.property", "false");
+  }
+
+  /** Overrides the system property. */
+  @Test
+  public void test1_set_overridesSystemProperties() {
+    rule.set("robolectric.test.property", "true");
+    assertThat(System.getProperty("robolectric.test.property")).isEqualTo("true");
+  }
+
+  /** Checks that the rule has restored the original value after the test completed. */
+  @Test
+  public void test2_systemProperties_areRestored_afterTest() {
+    assertThat(System.getProperty("robolectric.test.property")).isEqualTo("false");
+  }
+
+  /** Clears the system property. */
+  @AfterClass
+  public static void afterClass() {
+    assertThat(System.getProperty("robolectric.test.property")).isEqualTo("false");
+    System.clearProperty("robolectric.test.property");
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
index 1ebb258fb..5eff850b0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
@@ -44,7 +44,6 @@ public final class AssociationInfoBuilderTest {
             .setId(ID)
             .setUserId(USER_ID)
             .setPackageName(PACKAGE_NAME)
-            .setTag(TAG_NAME)
             .setDeviceMacAddress(DEVICE_MAC_ADDRESS)
             .setDisplayName(DISPLAY_NAME)
             .setAssociatedDevice(associatedDeviceValue)
@@ -77,11 +76,6 @@ public final class AssociationInfoBuilderTest {
       assertThat(systemDataSyncFlags).isEqualTo(SYSTEM_DATA_SYNC_FALGS);
     }
 
-    if (ReflectionHelpers.hasField(AssociationInfo.class, "mTag")) {
-      String tag = ReflectionHelpers.callInstanceMethod(info, "getTag");
-      assertThat(tag).isEqualTo(TAG_NAME);
-    }
-
     if (ReflectionHelpers.hasField(AssociationInfo.class, "mRevoked")) {
       boolean isRevoked = ReflectionHelpers.callInstanceMethod(info, "isRevoked");
       assertThat(isRevoked).isEqualTo(REVOKED);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java b/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java
index a9da2908d..dd9e0939d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java
@@ -1,12 +1,16 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O_MR1;
+import static android.os.Build.VERSION_CODES.P;
 import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteDatabase.OpenParams;
 import android.database.sqlite.SQLiteOpenHelper;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -14,6 +18,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public class SQLiteOpenHelperTest {
@@ -223,6 +228,49 @@ public class SQLiteOpenHelperTest {
     assertThat(db1.isOpen()).isTrue();
   }
 
+  @Test
+  public void testGetIdleConnectionTimeout() {
+    assertThat(shadowOf(helper).getIdleConnectionTimeout())
+        .isEqualTo(ShadowSQLiteOpenHelper.IDLE_CONNECTION_TIMEOUT_DISABLED);
+  }
+
+  @Test
+  @Config(minSdk = O_MR1)
+  public void testSetIdleConnectionTimeout() {
+    helper.setIdleConnectionTimeout(1000L);
+    assertThat(shadowOf(helper).getIdleConnectionTimeout()).isEqualTo(1000L);
+  }
+
+  @Test
+  @Config(minSdk = P)
+  public void testGetOpenParams() {
+    OpenParams openParams = shadowOf(helper).getOpenParams();
+    assertThat(openParams).isNotNull();
+    assertThat(openParams.getOpenFlags() & SQLiteDatabase.CREATE_IF_NECESSARY)
+        .isEqualTo(SQLiteDatabase.CREATE_IF_NECESSARY);
+  }
+
+  @Test
+  @Config(minSdk = P)
+  public void testGetOpenParams_setIdleConnectionTimeout() {
+    assertThat(shadowOf(helper).getOpenParams().getIdleConnectionTimeout())
+        .isEqualTo(ShadowSQLiteOpenHelper.IDLE_CONNECTION_TIMEOUT_DISABLED);
+    helper.setIdleConnectionTimeout(1000L);
+    assertThat(shadowOf(helper).getOpenParams().getIdleConnectionTimeout()).isEqualTo(1000L);
+  }
+
+  @Test
+  @Config(minSdk = P)
+  public void testSetOpenParams() {
+    OpenParams newOpenParams = new OpenParams.Builder().setIdleConnectionTimeout(1000L).build();
+    helper.setOpenParams(newOpenParams);
+    OpenParams openParams = shadowOf(helper).getOpenParams();
+    assertThat(openParams).isNotNull();
+    assertThat(openParams.getOpenFlags() & SQLiteDatabase.CREATE_IF_NECESSARY)
+        .isEqualTo(SQLiteDatabase.CREATE_IF_NECESSARY);
+    assertThat(openParams.getIdleConnectionTimeout()).isEqualTo(1000L);
+  }
+
   private static void assertInitialDB(SQLiteDatabase database, TestOpenHelper helper) {
     assertDatabaseOpened(database, helper);
     assertThat(helper.onCreateCalled).isTrue();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
index e3d8f7299..115882b37 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
@@ -23,6 +23,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ReflectionHelpers;
 
@@ -274,13 +275,13 @@ public class ShadowAccessibilityManagerTest {
   public void accessibilityManager_activityContextEnabled_differentInstancesHaveSameServices() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       AccessibilityManager applicationAccessibilityManager =
           (AccessibilityManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.ACCESSIBILITY_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AccessibilityManager activityAccessibilityManager =
           (AccessibilityManager) activity.getSystemService(Context.ACCESSIBILITY_SERVICE);
 
@@ -293,9 +294,6 @@ public class ShadowAccessibilityManagerTest {
 
       assertThat(activityServices).isEqualTo(applicationServices);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java
index 289a2e4b8..4b8643447 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java
@@ -17,12 +17,12 @@ import android.view.Display;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityNodeInfo;
 import android.view.accessibility.AccessibilityWindowInfo;
-import androidx.annotation.NonNull;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -139,7 +139,7 @@ public class ShadowAccessibilityServiceTest {
     TakeScreenshotCallback takeScreenshotCallback =
         new TakeScreenshotCallback() {
           @Override
-          public void onSuccess(@NonNull ScreenshotResult screenshotResult) {
+          public void onSuccess(@Nonnull ScreenshotResult screenshotResult) {
             screenshotResultAtomicReference.set(screenshotResult);
           }
 
@@ -164,7 +164,7 @@ public class ShadowAccessibilityServiceTest {
     TakeScreenshotCallback takeScreenshotCallback =
         new TakeScreenshotCallback() {
           @Override
-          public void onSuccess(@NonNull ScreenshotResult screenshotResult) {}
+          public void onSuccess(@Nonnull ScreenshotResult screenshotResult) {}
 
           @Override
           public void onFailure(int errorCode) {
@@ -188,7 +188,7 @@ public class ShadowAccessibilityServiceTest {
     TakeScreenshotCallback takeScreenshotCallback =
         new TakeScreenshotCallback() {
           @Override
-          public void onSuccess(@NonNull ScreenshotResult screenshotResult) {
+          public void onSuccess(@Nonnull ScreenshotResult screenshotResult) {
             screenshotResultAtomicReference.set(screenshotResult);
           }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
index 6538f1382..3f6583c66 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
@@ -28,6 +28,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -1078,7 +1079,7 @@ public class ShadowAccountManagerTest {
   @Config(minSdk = LOLLIPOP_MR1)
   public void removeAccountExplicitly() {
     assertThat(
-            am.removeAccountExplicitly(new Account("non_existant_account@gmail.com", "gmail.com")))
+            am.removeAccountExplicitly(new Account("non_existent_account@gmail.com", "gmail.com")))
         .isFalse();
     assertThat(am.removeAccountExplicitly(null)).isFalse();
 
@@ -1139,10 +1140,10 @@ public class ShadowAccountManagerTest {
   public void accountManager_activityContextEnabled_differentInstancesRetrieveAccounts() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       AccountManager applicationAccountManager = appContext.getSystemService(AccountManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AccountManager activityAccountManager = activity.getSystemService(AccountManager.class);
 
       assertThat(applicationAccountManager).isNotSameInstanceAs(activityAccountManager);
@@ -1154,9 +1155,6 @@ public class ShadowAccountManagerTest {
 
       assertThat(activityAccounts).isEqualTo(applicationAccounts);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
index 73c8eb831..45902ef43 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
@@ -22,6 +22,8 @@ import android.app.ApplicationExitInfo;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.ConfigurationInfo;
+import android.os.Build.VERSION_CODES;
+import android.os.LocaleList;
 import android.os.Process;
 import android.os.UserHandle;
 import android.os.UserManager;
@@ -31,14 +33,15 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.collect.Lists;
 import com.google.common.collect.ImmutableList;
 import java.util.List;
+import java.util.Locale;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowActivityManagerTest {
@@ -224,7 +227,7 @@ public class ShadowActivityManagerTest {
   }
 
   @Test
-  @Config(minSdk = android.os.Build.VERSION_CODES.Q)
+  @Config(minSdk = VERSION_CODES.Q)
   public void switchUser_withUserHandle_shouldAbleToSwitchUser() {
     UserHandle userHandle = shadowOf(userManager).addUser(10, "secondary_user", 0);
     activityManager.switchUser(userHandle);
@@ -450,6 +453,20 @@ public class ShadowActivityManagerTest {
     assertThat(shadowActivityManager.isApplicationUserDataCleared()).isTrue();
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.Q)
+  public void testSetDeviceLocales() {
+    assertThat(shadowActivityManager.getDeviceLocales()).isNull();
+
+    shadowActivityManager.setDeviceLocales(null);
+    assertThat(shadowActivityManager.getDeviceLocales().get(0)).isEqualTo(Locale.ENGLISH);
+
+    shadowActivityManager.setDeviceLocales(
+        LocaleList.forLanguageTags(Locale.CANADA.toLanguageTag()));
+
+    assertThat(shadowActivityManager.getDeviceLocales().get(0)).isEqualTo(Locale.CANADA);
+  }
+
   private void addApplicationExitInfo(int pid) {
     addApplicationExitInfo(
         /* pid= */ pid, ApplicationExitInfo.REASON_SIGNALED, /* status= */ OsConstants.SIGKILL);
@@ -488,14 +505,14 @@ public class ShadowActivityManagerTest {
   public void activityManager_activityContextEnabled_retrievesConsistentLowRamDeviceStatus() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       ActivityManager applicationActivityManager =
           (ActivityManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.ACTIVITY_SERVICE);
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       ActivityManager activityActivityManager =
           (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
 
@@ -504,9 +521,6 @@ public class ShadowActivityManagerTest {
 
       assertThat(activityLowRamStatus).isEqualTo(applicationLowRamStatus);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java
index 069453b58..538111cc0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java
@@ -32,6 +32,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm;
 
@@ -670,14 +671,14 @@ public class ShadowAlarmManagerTest {
   public void alarmManager_instance_retrievesSameAlarmClockInfo() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
 
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       AlarmManager applicationAlarmManager =
           (AlarmManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AlarmManager activityAlarmManager =
           (AlarmManager) activity.getSystemService(Context.ALARM_SERVICE);
 
@@ -687,9 +688,6 @@ public class ShadowAlarmManagerTest {
 
       assertThat(activityAlarmClock).isEqualTo(applicationAlarmClock);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
index 35c43920a..9a8e280f6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
@@ -15,6 +15,7 @@ import androidx.test.core.app.ApplicationProvider;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
+import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -26,6 +27,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -194,11 +196,11 @@ public class ShadowAmbientContextManagerTest {
   public void ambientContextManager_activityContextEnabled_differentInstancesQueryStatus() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       AmbientContextManager applicationAmbientContextManager =
           RuntimeEnvironment.getApplication().getSystemService(AmbientContextManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AmbientContextManager activityAmbientContextManager =
           activity.getSystemService(AmbientContextManager.class);
 
@@ -211,8 +213,9 @@ public class ShadowAmbientContextManagerTest {
 
       Executor executor = Executors.newSingleThreadExecutor();
 
-      Set<Integer> eventTypes =
-          Set.of(AmbientContextEvent.EVENT_COUGH, AmbientContextEvent.EVENT_SNORE);
+      Set<Integer> eventTypes = new HashSet<>();
+      eventTypes.add(AmbientContextEvent.EVENT_COUGH);
+      eventTypes.add(AmbientContextEvent.EVENT_SNORE);
 
       applicationAmbientContextManager.queryAmbientContextServiceStatus(
           eventTypes,
@@ -236,9 +239,6 @@ public class ShadowAmbientContextManagerTest {
     } catch (Exception e) {
       fail("Test failed due to exception: " + e.getMessage());
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
index ce7c0dd98..78212cd1e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
@@ -49,6 +49,7 @@ import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.robolectric.Robolectric;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowAppOpsManager.ModeAndException;
 import org.robolectric.util.ReflectionHelpers;
@@ -774,15 +775,15 @@ public class ShadowAppOpsManagerTest {
   public void appOpsManager_activityContextEnabled_differentInstancesRetrieveOps() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       // Get the AppOpsManager instances
       AppOpsManager applicationAppOpsManager =
           ApplicationProvider.getApplicationContext().getSystemService(AppOpsManager.class);
       ShadowAppOpsManager shadowApplicationAppOpsManager =
           Shadows.shadowOf(applicationAppOpsManager);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AppOpsManager activityAppOpsManager = activity.getSystemService(AppOpsManager.class);
       ShadowAppOpsManager shadowActivityAppOpsManager = Shadows.shadowOf(activityAppOpsManager);
 
@@ -796,9 +797,6 @@ public class ShadowAppOpsManagerTest {
 
       assertThat(activityPackageOpsList).isEqualTo(applicationPackageOpsList);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
index 3f62ecdeb..4a8f7e07f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.L;
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
 import static android.os.Looper.getMainLooper;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertArrayEquals;
@@ -43,6 +44,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -532,6 +534,47 @@ public class ShadowAppWidgetManagerTest {
     assertEquals(2, callbackAppWidgetId.get());
   }
 
+  @Test
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void widgetPreview_getWidgetPreview_noWidgetSet_returnsNull() {
+    RemoteViews result =
+        shadowAppWidgetManager.getWidgetPreview(new ComponentName("A", "B"), UserHandle.CURRENT, 0);
+    assertThat(result).isNull();
+  }
+
+  @Test
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void widgetPreview_setWidgetPreview_onlyReturnsWidgetForSetCategory() {
+    RemoteViews widgetPreview = new RemoteViews(context.getPackageName(), R.layout.remote_views);
+
+    shadowAppWidgetManager.setWidgetPreview(new ComponentName("A", "B"), 0, widgetPreview);
+
+    RemoteViews result =
+        shadowAppWidgetManager.getWidgetPreview(new ComponentName("A", "B"), UserHandle.CURRENT, 0);
+    assertThat(result).isNotNull();
+    assertThat(result).isEqualTo(widgetPreview);
+    result =
+        shadowAppWidgetManager.getWidgetPreview(new ComponentName("A", "B"), UserHandle.CURRENT, 1);
+    assertThat(result).isNull();
+  }
+
+  @Test
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void widgetPreview_setWidgetPreview_removeWidgetPreview_returnsNull() {
+    RemoteViews widgetPreview = new RemoteViews(context.getPackageName(), R.layout.remote_views);
+
+    shadowAppWidgetManager.setWidgetPreview(new ComponentName("A", "B"), 0, widgetPreview);
+
+    RemoteViews result =
+        shadowAppWidgetManager.getWidgetPreview(new ComponentName("A", "B"), UserHandle.CURRENT, 0);
+    assertThat(result).isNotNull();
+    assertThat(result).isEqualTo(widgetPreview);
+    shadowAppWidgetManager.removeWidgetPreview(new ComponentName("A", "B"), 0);
+    result =
+        shadowAppWidgetManager.getWidgetPreview(new ComponentName("A", "B"), UserHandle.CURRENT, 0);
+    assertThat(result).isNull();
+  }
+
   /**
    * Asserts that the id of {@code view} matches {@code id}. Asserts on the string name, which
    * provides a more useful error message than the int value.
@@ -553,11 +596,11 @@ public class ShadowAppWidgetManagerTest {
   public void appWidgetManager_activityContextEnabled_sharedState() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       AppWidgetManager applicationAppWidgetManager =
           context.getSystemService(AppWidgetManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AppWidgetManager activityAppWidgetManager = activity.getSystemService(AppWidgetManager.class);
 
       assertThat(applicationAppWidgetManager).isNotSameInstanceAs(activityAppWidgetManager);
@@ -566,9 +609,6 @@ public class ShadowAppWidgetManagerTest {
 
       assertThat(activityAppWidgetManager.getAppWidgetOptions(1)).isNotNull();
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAsyncQueryHandlerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAsyncQueryHandlerTest.java
index 4440ef955..6285593e2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAsyncQueryHandlerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAsyncQueryHandlerTest.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
@@ -21,6 +20,9 @@ import org.robolectric.fakes.RoboCursor;
 @RunWith(AndroidJUnit4.class)
 public final class ShadowAsyncQueryHandlerTest {
 
+  private static final Uri FAKE_URI =
+      Uri.parse("content://robolectric").buildUpon().appendPath("fakepath").build();
+
   private static final int TOKEN = 22;
   private static final Object COOKIE = new Object();
   private static final RoboCursor CURSOR = new RoboCursor();
@@ -35,12 +37,12 @@ public final class ShadowAsyncQueryHandlerTest {
   @Test
   public void startQuery_callbackIsCalled() {
     FakeAsyncQueryHandler asyncQueryHandler = new FakeAsyncQueryHandler(contentResolver);
-    shadowOf(contentResolver).setCursor(EXTERNAL_CONTENT_URI, CURSOR);
+    shadowOf(contentResolver).setCursor(FAKE_URI, CURSOR);
 
     asyncQueryHandler.startQuery(
         TOKEN,
         COOKIE,
-        EXTERNAL_CONTENT_URI,
+        FAKE_URI,
         null /* projection */,
         null /* selection */,
         null /* selectionArgs */,
@@ -55,26 +57,20 @@ public final class ShadowAsyncQueryHandlerTest {
   public void startInsert_callbackIsCalled() {
     FakeAsyncQueryHandler asyncQueryHandler = new FakeAsyncQueryHandler(contentResolver);
 
-    asyncQueryHandler.startInsert(TOKEN, COOKIE, EXTERNAL_CONTENT_URI, null /* initialValues */);
+    asyncQueryHandler.startInsert(TOKEN, COOKIE, FAKE_URI, null /* initialValues */);
 
     assertThat(asyncQueryHandler.token).isEqualTo(TOKEN);
     assertThat(asyncQueryHandler.cookie).isEqualTo(COOKIE);
-    assertThat(asyncQueryHandler.uri)
-        .isEqualTo(ContentUris.withAppendedId(EXTERNAL_CONTENT_URI, 1));
+    assertThat(asyncQueryHandler.uri).isEqualTo(ContentUris.withAppendedId(FAKE_URI, 1));
   }
 
   @Test
   public void startUpdate_callbackIsCalled() {
     FakeAsyncQueryHandler asyncQueryHandler = new FakeAsyncQueryHandler(contentResolver);
-    contentResolver.insert(EXTERNAL_CONTENT_URI, new ContentValues());
+    contentResolver.insert(FAKE_URI, new ContentValues());
 
     asyncQueryHandler.startUpdate(
-        TOKEN,
-        COOKIE,
-        EXTERNAL_CONTENT_URI,
-        null /* values */,
-        null /* selection */,
-        null /* selectionArgs */);
+        TOKEN, COOKIE, FAKE_URI, null /* values */, null /* selection */, null /* selectionArgs */);
 
     assertThat(asyncQueryHandler.token).isEqualTo(TOKEN);
     assertThat(asyncQueryHandler.cookie).isEqualTo(COOKIE);
@@ -84,10 +80,10 @@ public final class ShadowAsyncQueryHandlerTest {
   @Test
   public void startDelete_callbackIsCalled() {
     FakeAsyncQueryHandler asyncQueryHandler = new FakeAsyncQueryHandler(contentResolver);
-    contentResolver.insert(EXTERNAL_CONTENT_URI, new ContentValues());
+    contentResolver.insert(FAKE_URI, new ContentValues());
 
     asyncQueryHandler.startDelete(
-        TOKEN, COOKIE, EXTERNAL_CONTENT_URI, null /* selection */, null /* selectionArgs */);
+        TOKEN, COOKIE, FAKE_URI, null /* selection */, null /* selectionArgs */);
 
     assertThat(asyncQueryHandler.token).isEqualTo(TOKEN);
     assertThat(asyncQueryHandler.cookie).isEqualTo(COOKIE);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
index 7d2368f12..04bba7e42 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
@@ -1,8 +1,10 @@
 package org.robolectric.shadows;
 
+import static android.media.AudioAttributes.USAGE_MEDIA;
 import static android.media.AudioTrack.ERROR_BAD_VALUE;
 import static android.media.AudioTrack.WRITE_BLOCKING;
 import static android.media.AudioTrack.WRITE_NON_BLOCKING;
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.Q;
@@ -11,6 +13,7 @@ import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.media.AudioAttributes;
 import android.media.AudioDeviceInfo;
@@ -21,6 +24,7 @@ import android.media.AudioRouting.OnRoutingChangedListener;
 import android.media.AudioSystem;
 import android.media.AudioTrack;
 import android.media.PlaybackParams;
+import android.os.Build.VERSION;
 import android.os.Handler;
 import android.os.Looper;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -30,6 +34,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.ReflectionHelpers;
 
 /** Tests for {@link ShadowAudioTrack}. */
 @RunWith(AndroidJUnit4.class)
@@ -83,7 +88,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeByteArray_blocking() {
     AudioTrack audioTrack = getSampleAudioTrack();
 
@@ -93,7 +98,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeByteArray_nonBlocking() {
     AudioTrack audioTrack = getSampleAudioTrack();
 
@@ -103,7 +108,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeByteBuffer_blocking() {
     AudioTrack audioTrack = getSampleAudioTrack();
     ByteBuffer byteBuffer = ByteBuffer.allocate(4);
@@ -114,7 +119,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeByteBuffer_nonBlocking() {
     AudioTrack audioTrack = getSampleAudioTrack();
     ByteBuffer byteBuffer = ByteBuffer.allocate(4);
@@ -125,7 +130,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeByteBuffer_correctBytesWritten() {
     ShadowAudioTrack.addAudioDataListener(this);
     AudioTrack audioTrack = getSampleAudioTrack();
@@ -142,7 +147,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeDirectByteBuffer_blocking() {
     AudioTrack audioTrack = getSampleAudioTrack();
     ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4);
@@ -153,7 +158,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeDirectByteBuffer_nonBlocking() {
     AudioTrack audioTrack = getSampleAudioTrack();
     ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4);
@@ -164,7 +169,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeDirectByteBuffer_invalidWriteMode() {
     AudioTrack audioTrack = getSampleAudioTrack();
     ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4);
@@ -175,7 +180,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = Q)
+  @Config(minSdk = M)
   public void writeDirectByteBuffer_invalidSize() {
     AudioTrack audioTrack = getSampleAudioTrack();
     ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4);
@@ -676,28 +681,141 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
     audioTrack.play();
   }
 
+  @Test
+  @Config(minSdk = LOLLIPOP)
+  public void getLatency_withoutSetLatencyMs_returnsZero() throws Exception {
+    AudioTrack audioTrack = getSampleAudioTrack();
+
+    assertThat((Integer) ReflectionHelpers.callInstanceMethod(audioTrack, "getLatency"))
+        .isEqualTo(0);
+  }
+
+  @Test
+  @Config(minSdk = LOLLIPOP)
+  public void getLatency_afterSetLatencyMs_returnsSetLatency() throws Exception {
+    AudioTrack audioTrack = getSampleAudioTrack();
+    shadowOf(audioTrack).setLatency(200);
+
+    assertThat((Integer) ReflectionHelpers.callInstanceMethod(audioTrack, "getLatency"))
+        .isEqualTo(200);
+  }
+
+  @Test
+  @Config(minSdk = M)
+  public void getBufferSizeInFrames_withPcm_returnsBufferSizeInFrames() throws Exception {
+    AudioTrack audioTrack = getSampleAudioTrack();
+
+    assertThat(audioTrack.getBufferSizeInFrames()).isEqualTo(1);
+  }
+
+  @Test
+  @Config(minSdk = Q, maxSdk = R)
+  public void getBufferSizeInFrames_withOffloadUntilApi30_returnsBufferSizeInBytes()
+      throws Exception {
+    AudioFormat audioFormat =
+        new AudioFormat.Builder()
+            .setEncoding(AudioFormat.ENCODING_AC3)
+            .setSampleRate(48000)
+            .setChannelMask(AudioFormat.CHANNEL_OUT_5POINT1)
+            .build();
+    AudioAttributes attributes = new AudioAttributes.Builder().setUsage(USAGE_MEDIA).build();
+    ShadowAudioSystem.setOffloadSupported(audioFormat, attributes, /* supported= */ true);
+
+    AudioTrack audioTrack =
+        new AudioTrack.Builder()
+            .setAudioFormat(audioFormat)
+            .setAudioAttributes(attributes)
+            .setBufferSizeInBytes(65536)
+            .setOffloadedPlayback(true)
+            .build();
+
+    assertThat(audioTrack.getBufferSizeInFrames()).isEqualTo(65536);
+  }
+
+  @Test
+  @Config(sdk = S)
+  public void getBufferSizeInFrames_withOffloadApi31_returnsBufferSizeInBytes() throws Exception {
+    ShadowAudioTrack.addAllowedNonPcmEncoding(AudioFormat.ENCODING_AC3);
+    AudioFormat audioFormat =
+        new AudioFormat.Builder()
+            .setEncoding(AudioFormat.ENCODING_AC3)
+            .setSampleRate(48000)
+            .setChannelMask(AudioFormat.CHANNEL_OUT_5POINT1)
+            .build();
+    AudioAttributes attributes = new AudioAttributes.Builder().build();
+    ShadowAudioSystem.setOffloadPlaybackSupport(
+        audioFormat, attributes, AudioSystem.OFFLOAD_SUPPORTED);
+
+    AudioTrack audioTrack =
+        new AudioTrack.Builder()
+            .setAudioFormat(audioFormat)
+            .setAudioAttributes(attributes)
+            .setBufferSizeInBytes(65536)
+            .setOffloadedPlayback(true)
+            .build();
+
+    assertThat(audioTrack.getBufferSizeInFrames()).isEqualTo(65536);
+  }
+
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void getBufferSizeInFrames_withOffloadPostApi31_returnsBufferSizeInBytes()
+      throws Exception {
+    ShadowAudioTrack.addAllowedNonPcmEncoding(AudioFormat.ENCODING_AC3);
+    AudioFormat audioFormat =
+        new AudioFormat.Builder()
+            .setEncoding(AudioFormat.ENCODING_AC3)
+            .setSampleRate(48000)
+            .setChannelMask(AudioFormat.CHANNEL_OUT_5POINT1)
+            .build();
+    AudioAttributes attributes = new AudioAttributes.Builder().build();
+    ShadowAudioSystem.setDirectPlaybackSupport(
+        audioFormat, attributes, AudioSystem.OFFLOAD_SUPPORTED);
+
+    AudioTrack audioTrack =
+        new AudioTrack.Builder()
+            .setAudioFormat(audioFormat)
+            .setAudioAttributes(attributes)
+            .setBufferSizeInBytes(65536)
+            .setOffloadedPlayback(true)
+            .build();
+
+    assertThat(audioTrack.getBufferSizeInFrames()).isEqualTo(65536);
+  }
+
   @Override
   @Config(minSdk = Q)
-  public void onAudioDataWritten(
-      ShadowAudioTrack audioTrack, byte[] audioData, AudioFormat format) {
-    shadowAudioTrack = audioTrack;
+  public void onAudioDataWritten(AudioTrack audioTrack, byte[] audioData, AudioFormat format) {
+    shadowAudioTrack = shadowOf(audioTrack);
     dataWrittenToShadowAudioTrack = audioData;
   }
 
   private static AudioTrack getSampleAudioTrack() {
-    return new AudioTrack.Builder()
-        .setAudioAttributes(
-            new AudioAttributes.Builder()
-                .setUsage(AudioAttributes.USAGE_ALARM)
-                .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
-                .build())
-        .setAudioFormat(
-            new AudioFormat.Builder()
-                .setEncoding(AUDIO_ENCODING_FORMAT)
-                .setSampleRate(SAMPLE_RATE_IN_HZ)
-                .setChannelMask(CHANNEL_CONFIG)
-                .build())
-        .build();
+    AudioFormat format =
+        new AudioFormat.Builder()
+            .setChannelMask(CHANNEL_CONFIG)
+            .setEncoding(AUDIO_ENCODING_FORMAT)
+            .setSampleRate(SAMPLE_RATE_IN_HZ)
+            .build();
+    AudioAttributes audioAttributes =
+        new AudioAttributes.Builder()
+            .setUsage(AudioAttributes.USAGE_ALARM)
+            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
+            .build();
+
+    if (VERSION.SDK_INT >= M) {
+      return new AudioTrack.Builder()
+          .setAudioAttributes(audioAttributes)
+          .setAudioFormat(format)
+          .build();
+    }
+    int bufferSizeBytes = 2 * AudioFormat.getBytesPerSample(AUDIO_ENCODING_FORMAT);
+    return new AudioTrack(
+        audioAttributes,
+        format,
+        bufferSizeBytes,
+        AudioTrack.MODE_STREAM,
+        AudioManager.AUDIO_SESSION_ID_GENERATE);
   }
 
   private AudioFormat getAudioFormat(int encoding) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java
index b946f6c2c..39380d6c3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java
@@ -16,6 +16,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Unit test for {@link ShadowAutofillManager}. */
@@ -65,11 +66,11 @@ public class ShadowAutofillManagerTest {
   public void autofillManager_activityContextEnabled_differentInstancesRetrieveSameInfo() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       AutofillManager applicationAutofillManager = context.getSystemService(AutofillManager.class);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       AutofillManager activityAutofillManager = activity.getSystemService(AutofillManager.class);
 
       assertNotSame(applicationAutofillManager, activityAutofillManager);
@@ -80,9 +81,6 @@ public class ShadowAutofillManagerTest {
       assertEquals(applicationAutofillManager.isEnabled(), activityAutofillManager.isEnabled());
 
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java
index 7d1d91665..5335f9cd2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java
@@ -13,7 +13,6 @@ import android.app.backup.BackupTransport;
 import android.app.backup.RestoreObserver;
 import android.app.backup.RestoreSession;
 import android.app.backup.RestoreSet;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
@@ -22,6 +21,7 @@ import com.google.common.truth.Correspondence;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java
index 45a4383c1..707b5249b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java
@@ -15,6 +15,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -100,11 +101,11 @@ public class ShadowBatteryManagerTest {
   public void batteryManager_activityContextEnabled_sharedState() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       Context context = ApplicationProvider.getApplicationContext();
       BatteryManager applicationBatteryManager = context.getSystemService(BatteryManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       BatteryManager activityBatteryManager = activity.getSystemService(BatteryManager.class);
 
       assertThat(applicationBatteryManager).isNotSameInstanceAs(activityBatteryManager);
@@ -114,9 +115,6 @@ public class ShadowBatteryManagerTest {
 
       assertThat(activityBatteryManager.isCharging()).isTrue();
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java
index 0acc2b87a..8ff9dc789 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java
@@ -9,6 +9,7 @@ import static org.robolectric.Shadows.shadowOf;
 
 import android.content.Context;
 import android.os.Binder;
+import android.os.IBinder.DeathRecipient;
 import android.os.Parcel;
 import android.os.UserHandle;
 import android.os.UserManager;
@@ -45,6 +46,52 @@ public class ShadowBinderTest {
     assertThat(reply.readString()).isEqualTo("Hello Robolectric");
   }
 
+  @Test
+  public void testLinkToDeath() throws Exception {
+    Binder binder = new Binder();
+    DeathRecipient recipient = () -> {};
+    binder.linkToDeath(recipient, 0);
+    assertThat(shadowOf(binder).getDeathRecipients()).containsExactly(recipient);
+  }
+
+  @Test
+  public void testLinkToDeath_unlink() throws Exception {
+    Binder binder = new Binder();
+    DeathRecipient recipient = () -> {};
+    // recipient doesn't exist, returns false.
+    assertThat(binder.unlinkToDeath(recipient, 0)).isFalse();
+
+    binder.linkToDeath(recipient, 0);
+    // recipient exists, return true.
+    assertThat(binder.unlinkToDeath(recipient, 0)).isTrue();
+    assertThat(shadowOf(binder).getDeathRecipients()).isEmpty();
+  }
+
+  @Test
+  public void testLinkToDeath_twice() throws Exception {
+    Binder binder = new Binder();
+    DeathRecipient recipient = () -> {};
+    binder.linkToDeath(recipient, 0);
+    binder.linkToDeath(recipient, 0);
+    assertThat(shadowOf(binder).getDeathRecipients()).containsExactly(recipient, recipient);
+
+    binder.unlinkToDeath(recipient, 0);
+    assertThat(shadowOf(binder).getDeathRecipients()).containsExactly(recipient);
+  }
+
+  @Test
+  public void testLinkToDeath_weakReference() throws Exception {
+    Binder binder = new Binder();
+    binder.linkToDeath(
+        new DeathRecipient() {
+          @Override
+          public void binderDied() {}
+        },
+        0);
+    System.gc();
+    assertThat(shadowOf(binder).getDeathRecipients()).isEmpty();
+  }
+
   static class TestBinder extends Binder {
     int code;
     Parcel data;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
index 191166284..aa121e1f1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
@@ -17,6 +17,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -108,12 +109,12 @@ public class ShadowBiometricManagerTest {
   public void biometricManager_activityContextEnabled_differentInstancesRetrieveSameResult() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       BiometricManager applicationBiometricManager =
           ApplicationProvider.getApplicationContext().getSystemService(BiometricManager.class);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       BiometricManager activityBiometricManager = activity.getSystemService(BiometricManager.class);
 
       assertThat(applicationBiometricManager).isNotSameInstanceAs(activityBiometricManager);
@@ -123,9 +124,6 @@ public class ShadowBiometricManagerTest {
 
       assertThat(activityCanAuthenticate).isEqualTo(applicationCanAuthenticate);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
index 2df0f1f9d..e1fed6c70 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
@@ -23,7 +23,6 @@ import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowBitmapDrawableTest {
   private final Resources resources = ApplicationProvider.getApplicationContext().getResources();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
index 18fce06c0..57c44d959 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
@@ -100,7 +100,7 @@ public class ShadowBitmapFactoryTest {
     Resources resources = context.getResources();
     BitmapFactory.Options opts = new BitmapFactory.Options();
     Bitmap bitmap = BitmapFactory.decodeResource(resources, R.drawable.an_image, opts);
-    assertThat(bitmap.getPixel(0, 0) != 0).isTrue();
+    assertThat(bitmap.getPixel(0, 0)).isNotEqualTo(0);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java
index 2fc4ee73d..1f2644e3b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java
@@ -24,6 +24,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -165,25 +166,22 @@ public class ShadowBluetoothManagerTest {
   public void bluetoothManager_activityContextEnabled_retrievesSameAdapter() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
 
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       BluetoothManager applicationBluetoothManager =
           (BluetoothManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.BLUETOOTH_SERVICE);
 
       BluetoothAdapter applicationAdapter = applicationBluetoothManager.getAdapter();
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       BluetoothManager activityBluetoothManager = activity.getSystemService(BluetoothManager.class);
 
       BluetoothAdapter activityAdapter = activityBluetoothManager.getAdapter();
 
       assertThat(applicationAdapter).isEqualTo(activityAdapter);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothPanTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothPanTest.java
new file mode 100644
index 000000000..0a2da84e8
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothPanTest.java
@@ -0,0 +1,96 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(AndroidJUnit4.class)
+public final class ShadowBluetoothPanTest {
+  private BluetoothAdapter bluetoothAdapter;
+  private BluetoothDevice bluetoothDeviceOne;
+  private BluetoothDevice bluetoothDeviceTwo;
+
+  @Before
+  public void setUp() {
+    bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+    bluetoothDeviceOne = bluetoothAdapter.getRemoteDevice("00:11:22:33:AA:BB");
+    bluetoothDeviceTwo = bluetoothAdapter.getRemoteDevice("11:22:33:AA:BB:00");
+  }
+
+  @Test
+  public void getConnectedDevices_returnsConnectedDevices() {
+    // TODO: Use BluetoothPan instance to replace Shadow.newInstanceOf
+    BluetoothPan bluetoothPan = Shadow.newInstanceOf(BluetoothPan.class);
+    ShadowBluetoothPan shadowBluetoothPan = Shadow.extract(bluetoothPan);
+
+    shadowBluetoothPan.addDevice(bluetoothDeviceOne, BluetoothProfile.STATE_CONNECTED);
+    shadowBluetoothPan.addDevice(bluetoothDeviceTwo, BluetoothProfile.STATE_CONNECTED);
+
+    assertThat(bluetoothPan.getConnectedDevices())
+        .containsExactly(bluetoothDeviceOne, bluetoothDeviceTwo);
+  }
+
+  @Test
+  public void getConnectedDevices_reutnrsEmptyList() {
+    // TODO: Use BluetoothPan instance to replace Shadow.newInstanceOf
+    BluetoothPan bluetoothPan = Shadow.newInstanceOf(BluetoothPan.class);
+    ShadowBluetoothPan shadowBluetoothPan = Shadow.extract(bluetoothPan);
+
+    shadowBluetoothPan.addDevice(bluetoothDeviceOne, BluetoothProfile.STATE_CONNECTED);
+    shadowBluetoothPan.removeDevice(bluetoothDeviceOne);
+
+    assertThat(bluetoothPan.getConnectedDevices()).isEmpty();
+  }
+
+  @Test
+  public void getDevicesMatchingConnectionStates_returnsConnectedDevices() {
+    // TODO: Use BluetoothPan instance to replace Shadow.newInstanceOf
+    BluetoothPan bluetoothPan = Shadow.newInstanceOf(BluetoothPan.class);
+    ShadowBluetoothPan shadowBluetoothPan = Shadow.extract(bluetoothPan);
+
+    shadowBluetoothPan.addDevice(bluetoothDeviceOne, BluetoothProfile.STATE_CONNECTED);
+    shadowBluetoothPan.addDevice(bluetoothDeviceTwo, BluetoothProfile.STATE_DISCONNECTED);
+
+    assertThat(
+            bluetoothPan.getDevicesMatchingConnectionStates(
+                new int[] {BluetoothProfile.STATE_CONNECTED}))
+        .containsExactly(bluetoothDeviceOne);
+  }
+
+  @Test
+  public void getDevicesMatchingConnectionStates_returnsDisconnectedDevices() {
+    // TODO: Use BluetoothPan instance to replace Shadow.newInstanceOf
+    BluetoothPan bluetoothPan = Shadow.newInstanceOf(BluetoothPan.class);
+    ShadowBluetoothPan shadowBluetoothPan = Shadow.extract(bluetoothPan);
+
+    shadowBluetoothPan.addDevice(bluetoothDeviceOne, BluetoothProfile.STATE_CONNECTED);
+    shadowBluetoothPan.addDevice(bluetoothDeviceTwo, BluetoothProfile.STATE_DISCONNECTED);
+
+    assertThat(
+            bluetoothPan.getDevicesMatchingConnectionStates(
+                new int[] {BluetoothProfile.STATE_DISCONNECTED}))
+        .containsExactly(bluetoothDeviceTwo);
+  }
+
+  @Test
+  public void getDevicesMatchingConnectionStates_returnsEmptyList() {
+    // TODO: Use BluetoothPan instance to replace Shadow.newInstanceOf
+    BluetoothPan bluetoothPan = Shadow.newInstanceOf(BluetoothPan.class);
+    ShadowBluetoothPan shadowBluetoothPan = Shadow.extract(bluetoothPan);
+
+    shadowBluetoothPan.addDevice(bluetoothDeviceOne, BluetoothProfile.STATE_DISCONNECTED);
+
+    assertThat(
+            bluetoothPan.getDevicesMatchingConnectionStates(
+                new int[] {BluetoothProfile.STATE_CONNECTED}))
+        .isEmpty();
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
index d4a2522aa..df0687015 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
@@ -23,6 +23,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCameraManager}. */
@@ -415,12 +416,12 @@ public class ShadowCameraManagerTest {
       throws Exception {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       CameraManager applicationCameraManager =
           (CameraManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.CAMERA_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       CameraManager activityCameraManager =
           (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);
 
@@ -440,9 +441,6 @@ public class ShadowCameraManagerTest {
 
       assertThat(activityCameraIdList).isEqualTo(applicationCameraIdList);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
index e8d34942d..778f96c35 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
@@ -13,10 +13,10 @@ import android.provider.Settings.Secure;
 import android.view.accessibility.CaptioningManager;
 import android.view.accessibility.CaptioningManager.CaptionStyle;
 import android.view.accessibility.CaptioningManager.CaptioningChangeListener;
-import androidx.annotation.NonNull;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Locale;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
@@ -24,6 +24,7 @@ import org.junit.runner.RunWith;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for the ShadowCaptioningManager. */
@@ -54,7 +55,7 @@ public final class ShadowCaptioningManagerTest {
     }
 
     @Override
-    public void onUserStyleChanged(@NonNull CaptionStyle userStyle) {
+    public void onUserStyleChanged(@Nonnull CaptionStyle userStyle) {
       captionStyle = userStyle;
     }
 
@@ -90,7 +91,7 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setEnabled_true() {
+  public void isEnabled_enabledKeyTrue_returnsTrue() {
     Settings.Secure.putInt(
         context.getContentResolver(), Secure.ACCESSIBILITY_CAPTIONING_ENABLED, ENABLED);
 
@@ -98,7 +99,7 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setEnabled_false() {
+  public void isEnabled_enabledKeyFalse_returnsFalse() {
     Settings.Secure.putInt(
         context.getContentResolver(), Secure.ACCESSIBILITY_CAPTIONING_ENABLED, DISABLED);
 
@@ -106,7 +107,21 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setEnabled_callsCallback() {
+  public void isEnabled_afterSetEnabledFalse_returnsFalse() {
+    shadowOf(captioningManager).setEnabled(false);
+
+    assertThat(captioningManager.isEnabled()).isFalse();
+  }
+
+  @Test
+  public void isEnabled_afterSetEnabledTrue_returnsTrue() {
+    shadowOf(captioningManager).setEnabled(true);
+
+    assertThat(captioningManager.isEnabled()).isTrue();
+  }
+
+  @Test
+  public void addCaptioningChangeListener_enabledKeyValueChange_callsCallback() {
     captioningManager.addCaptioningChangeListener(captioningChangeListener);
     Settings.Secure.putInt(
         context.getContentResolver(), Secure.ACCESSIBILITY_CAPTIONING_ENABLED, ENABLED);
@@ -116,7 +131,16 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setFontScale_updatesValue() {
+  public void addCaptioningChangeListener_setEnabledChange_callsCallback() {
+    captioningManager.addCaptioningChangeListener(captioningChangeListener);
+    shadowOf(captioningManager).setEnabled(true);
+
+    shadowOf(Looper.getMainLooper()).idle();
+    assertThat(captioningChangeListener.isEnabled).isTrue();
+  }
+
+  @Test
+  public void getFontScale_returnFontScaleKeyValue() {
     Settings.Secure.putFloat(
         context.getContentResolver(), Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE, 2.0f);
 
@@ -124,7 +148,7 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setFontScale_callsCallback() {
+  public void addCaptioningChangeListener_fontScaleKeyValueChange_callsCallback() {
     captioningManager.addCaptioningChangeListener(captioningChangeListener);
     Settings.Secure.putFloat(
         context.getContentResolver(), Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE, 3.0f);
@@ -134,7 +158,7 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setLocale_updatesValue() {
+  public void getLocale_returnsLocaleKeyValue() {
     Settings.Secure.putString(
         context.getContentResolver(),
         Secure.ACCESSIBILITY_CAPTIONING_LOCALE,
@@ -144,7 +168,14 @@ public final class ShadowCaptioningManagerTest {
   }
 
   @Test
-  public void setLocale_callsCallback() {
+  public void getLocale_afterSetLocale_returnsLocale() {
+    shadowOf(captioningManager).setLocale(Locale.JAPANESE);
+
+    assertThat(captioningManager.getLocale()).isEqualTo(Locale.JAPANESE);
+  }
+
+  @Test
+  public void getLocale_localKeyValueChanged_callsCallback() {
     captioningManager.addCaptioningChangeListener(captioningChangeListener);
     Settings.Secure.putString(
         context.getContentResolver(),
@@ -155,6 +186,15 @@ public final class ShadowCaptioningManagerTest {
     assertThat(captioningChangeListener.locale).isEqualTo(Locale.FRENCH);
   }
 
+  @Test
+  public void getLocale_setLocaleChange_callsCallback() {
+    captioningManager.addCaptioningChangeListener(captioningChangeListener);
+    shadowOf(captioningManager).setLocale(Locale.FRENCH);
+
+    shadowOf(Looper.getMainLooper()).idle();
+    assertThat(captioningChangeListener.locale).isEqualTo(Locale.FRENCH);
+  }
+
   @Test
   @Config(minSdk = TIRAMISU)
   public void setSystemAudioCaptioningEnabled_updatesValue() {
@@ -194,13 +234,13 @@ public final class ShadowCaptioningManagerTest {
   public void captioningManager_activityContextEnabled_differentInstancesRetrieveValues() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       CaptioningManager applicationCaptioningManager =
           (CaptioningManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.CAPTIONING_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       CaptioningManager activityCaptioningManager =
           (CaptioningManager) activity.getSystemService(Context.CAPTIONING_SERVICE);
 
@@ -217,9 +257,6 @@ public final class ShadowCaptioningManagerTest {
       assertThat(applicationCaptioningEnabled).isEqualTo(activityCaptioningEnabled);
       assertThat(applicationCaptioningUiEnabled).isEqualTo(activityCaptioningUiEnabled);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
index a78289fad..1fe47edb0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
-import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.Activity;
 import android.app.Application;
@@ -12,6 +11,7 @@ import android.nfc.NfcAdapter;
 import android.nfc.cardemulation.CardEmulation;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,6 +29,7 @@ public final class ShadowCardEmulationTest {
   private Activity activity;
   private CardEmulation cardEmulation;
   private ComponentName service;
+  private ShadowCardEmulation shadowCardEmulation;
 
   @Before
   public void setUp() throws Exception {
@@ -41,6 +42,7 @@ public final class ShadowCardEmulationTest {
     cardEmulation = CardEmulation.getInstance(adapter);
     service = new ComponentName(context, "my_service");
     activity = Robolectric.buildActivity(Activity.class).setup().get();
+    shadowCardEmulation = shadowOf(cardEmulation);
   }
 
   @Test
@@ -54,11 +56,11 @@ public final class ShadowCardEmulationTest {
 
   @Test
   public void setPreferredService_canCapture() {
-    assertThat(ShadowCardEmulation.getPreferredService() == null).isTrue();
+    assertThat(ShadowCardEmulation.getPreferredService()).isNull();
     cardEmulation.setPreferredService(activity, service);
-    assertThat(ShadowCardEmulation.getPreferredService().equals(service)).isTrue();
+    assertThat(ShadowCardEmulation.getPreferredService()).isEqualTo(service);
     cardEmulation.unsetPreferredService(activity);
-    assertThat(ShadowCardEmulation.getPreferredService() == null).isTrue();
+    assertThat(ShadowCardEmulation.getPreferredService()).isNull();
   }
 
   @Test
@@ -75,16 +77,96 @@ public final class ShadowCardEmulationTest {
 
   @Test
   @Config(minSdk = V.SDK_INT)
-  public void getShouldDefaultToObserveModeForService_shouldReturnDefaultToObserveMode() {
-    final CardEmulationVReflector cardEmulationVReflector =
-        reflector(CardEmulationVReflector.class, cardEmulation);
-    assertThat(ShadowCardEmulation.getShouldDefaultToObserveModeForService(service)).isFalse();
+  public void registerPollingLoopPatternFilterForService_shouldRegisterPollingLoopFilter() {
+    String pollingLoopFilter = "6A02..01.*";
+    shadowCardEmulation.registerPollingLoopPatternFilterForService(
+        service, pollingLoopFilter, true);
 
-    cardEmulationVReflector.setShouldDefaultToObserveModeForService(service, true);
-    assertThat(ShadowCardEmulation.getShouldDefaultToObserveModeForService(service)).isTrue();
+    Map<String, Boolean> result =
+        ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service);
+    assertThat(result.keySet().size()).isEqualTo(1);
+    assertThat(result.containsKey(pollingLoopFilter)).isTrue();
+    assertThat(result.get(pollingLoopFilter)).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void registerPollingLoopPatternFilterForService_shouldOverrideSamePollingLoopFilter() {
+    // Register a polling loop filter with auto-transact enabled.
+    String pollingLoopFilter = "6A02..01.*";
+    cardEmulation.registerPollingLoopPatternFilterForService(service, pollingLoopFilter, true);
+
+    Map<String, Boolean> result =
+        ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service);
+    assertThat(result.keySet().size()).isEqualTo(1);
+    assertThat(result.containsKey(pollingLoopFilter)).isTrue();
+    assertThat(result.get(pollingLoopFilter)).isTrue();
+
+    // Register the same polling loop filter with auto-transact disabled.
+    cardEmulation.registerPollingLoopPatternFilterForService(service, pollingLoopFilter, false);
+    result = ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service);
+    assertThat(result.keySet().size()).isEqualTo(1);
+    assertThat(result.containsKey(pollingLoopFilter)).isTrue();
+    assertThat(result.get(pollingLoopFilter)).isFalse();
+  }
 
-    cardEmulationVReflector.setShouldDefaultToObserveModeForService(service, false);
-    assertThat(ShadowCardEmulation.getShouldDefaultToObserveModeForService(service)).isFalse();
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void
+      registerPollingLoopPatternFilterForService_shouldRegisterMultiplePollingLoopFilters() {
+    // Register multiple polling loop filter with auto-transact enabled.
+    String pollingLoopFilter1 = "6A02..01.*";
+    String pollingLoopFilter2 = "6A03..02.*";
+    cardEmulation.registerPollingLoopPatternFilterForService(service, pollingLoopFilter1, true);
+    cardEmulation.registerPollingLoopPatternFilterForService(service, pollingLoopFilter2, false);
+
+    Map<String, Boolean> result =
+        ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service);
+    assertThat(result.keySet().size()).isEqualTo(2);
+    assertThat(result.containsKey(pollingLoopFilter1)).isTrue();
+    assertThat(result.containsKey(pollingLoopFilter2)).isTrue();
+    assertThat(result.get(pollingLoopFilter1)).isTrue();
+    assertThat(result.get(pollingLoopFilter2)).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void registerPollingLoopPatternFilterForService_returnsFalseForInvalidPollingLoopFilter() {
+    String invalidPollingLoopFilter = "6Z02!.01.*";
+    assertThat(
+            cardEmulation.registerPollingLoopPatternFilterForService(
+                service, invalidPollingLoopFilter, true))
+        .isFalse();
+
+    assertThat(ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service))
+        .isNull();
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void removePollingLoopPatternFilterForService_shouldRemovePollingLoopFilter() {
+    String pollingLoopFilter = "6A02..01.*";
+    cardEmulation.registerPollingLoopPatternFilterForService(service, pollingLoopFilter, true);
+    Map<String, Boolean> result =
+        ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service);
+    assertThat(result.keySet().size()).isEqualTo(1);
+    assertThat(result.containsKey(pollingLoopFilter)).isTrue();
+    assertThat(result.get(pollingLoopFilter)).isTrue();
+
+    cardEmulation.removePollingLoopPatternFilterForService(service, pollingLoopFilter);
+    assertThat(ShadowCardEmulation.getRegisteredPollingLoopPatternFiltersForService(service))
+        .isEmpty();
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void removePollingLoopPatternFilterForService_returnsFalseForInvalidPollingLoopFilter() {
+    String invalidPollingLoopFilter = "6Z02!.01.*";
+
+    assertThat(
+            cardEmulation.removePollingLoopPatternFilterForService(
+                service, invalidPollingLoopFilter))
+        .isFalse();
   }
 
   // TODO: delete when this test compiles against V sdk
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
index a60ed5212..c5d778a95 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
@@ -18,6 +18,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Junit test for {@link ShadowCarrierConfigManager}. */
@@ -164,14 +165,14 @@ public class ShadowCarrierConfigManagerTest {
   public void carrierConfigManager_activityContextEnabled_retrievesSameConfigs() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       CarrierConfigManager applicationCarrierConfigManager =
           (CarrierConfigManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.CARRIER_CONFIG_SERVICE);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       CarrierConfigManager activityCarrierConfigManager =
           (CarrierConfigManager) activity.getSystemService(Context.CARRIER_CONFIG_SERVICE);
 
@@ -197,9 +198,6 @@ public class ShadowCarrierConfigManagerTest {
       applicationParcel.recycle();
       activityParcel.recycle();
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
index f793b5139..20f2f9db2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
@@ -1,20 +1,27 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.Shadows.shadowOf;
 
+import android.animation.ObjectAnimator;
+import android.os.Looper;
 import android.view.Choreographer;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.shadow.api.Shadow;
 
 /** Unit tests for {@link ShadowChoreographer}. */
 @RunWith(AndroidJUnit4.class)
 public class ShadowChoreographerTest {
 
+  @Rule public final SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
+
   @Test
   public void isValid() {
     ShadowPausedChoreographer shadowPausedChoreographer =
@@ -62,6 +69,24 @@ public class ShadowChoreographerTest {
     assertThat(frameTimeNanos.get()).isEqualTo(startTime + Duration.ofMillis(15).toNanos());
   }
 
+  /** Verify Choreographer + SystemClock use nano precision */
+  @Test
+  public void setPaused_isPaused_runsWhenClockAdvanced_nanos() {
+    ShadowChoreographer.setPaused(true);
+    ShadowChoreographer.setFrameDelay(Duration.ofNanos(15_100_000));
+    long startTime = ShadowSystem.nanoTime();
+    AtomicLong frameTimeNanos = new AtomicLong(-1);
+
+    Choreographer.getInstance().postFrameCallback(frameTimeNanos::set);
+    ShadowSystemClock.advanceBy(Duration.ofMillis(15));
+    ShadowLooper.idleMainLooper();
+
+    assertThat(frameTimeNanos.get()).isEqualTo(-1);
+    ShadowSystemClock.advanceBy(Duration.ofNanos(100_000));
+    ShadowLooper.idleMainLooper();
+    assertThat(frameTimeNanos.get()).isEqualTo(startTime + 15_100_000);
+  }
+
   @Test
   public void setPaused_isNotPaused_advancesClockAndRuns() {
     ShadowChoreographer.setPaused(false);
@@ -89,4 +114,35 @@ public class ShadowChoreographerTest {
     assertThat(ShadowSystem.nanoTime()).isEqualTo(startTime + Duration.ofMillis(30).toNanos());
     assertThat(didRun.get()).isTrue();
   }
+
+  @Test
+  public void defaultFrameDelay() {
+    setSystemPropertyRule.set("robolectric.defaultFrameDelayMs", "15");
+    // Reset the shadow to pick up the new default frame delay.
+    ShadowChoreographer.reset();
+    ThingToAnimate thing = new ThingToAnimate();
+    ObjectAnimator animator = ObjectAnimator.ofFloat(thing, "value", 0f, 1f);
+    animator.setDuration(1000);
+    animator.start();
+    shadowOf(Looper.getMainLooper()).runToEndOfTasks();
+    assertThat(thing.getSetCount()).isWithin(5).of(67); // Should be ~ (1000 / 15) ~ 67
+  }
+
+  public static class ThingToAnimate {
+    private float value = 0f;
+    private int setCount = 0;
+
+    public void setValue(float value) {
+      this.value = value;
+      this.setCount++;
+    }
+
+    public float getValue() {
+      return value;
+    }
+
+    public int getSetCount() {
+      return setCount;
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
index c9b5be115..0119bb11c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
@@ -8,6 +8,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
+import android.app.Activity;
 import android.content.ClipData;
 import android.content.ClipboardManager;
 import android.content.Context;
@@ -19,8 +20,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowClipboardManagerTest {
@@ -161,8 +162,8 @@ public class ShadowClipboardManagerTest {
   public void clipboardManager_instance_retrievesSamePrimaryClip() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    TestActivity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       ClipboardManager applicationClipboardManager =
           (ClipboardManager)
               ApplicationProvider.getApplicationContext()
@@ -170,7 +171,7 @@ public class ShadowClipboardManagerTest {
       ClipData clipData = ClipData.newPlainText("label", "text");
       applicationClipboardManager.setPrimaryClip(clipData);
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       ClipboardManager activityClipboardManager =
           (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
 
@@ -179,9 +180,6 @@ public class ShadowClipboardManagerTest {
 
       assertThat(activityClipData.toString()).isEqualTo(applicationClipData.toString());
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
index 305a33f39..96e5df550 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
@@ -15,6 +15,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.MethodSorters;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for ShadowColorDisplayManager. */
@@ -159,11 +160,11 @@ public class ShadowColorDisplayManagerTest {
   public void colorDisplayManager_activityContextEnabled_differentInstancesRetrieveSettings() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       ColorDisplayManager appColorDisplayManager =
           ApplicationProvider.getApplicationContext().getSystemService(ColorDisplayManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       ColorDisplayManager activityColorDisplayManager =
           activity.getSystemService(ColorDisplayManager.class);
 
@@ -178,9 +179,6 @@ public class ShadowColorDisplayManagerTest {
       assertThat(activityNightDisplayActivated).isEqualTo(appNightDisplayActivated);
 
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
index 2f9b24b8c..49a6215b3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
@@ -40,8 +40,8 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 import org.robolectric.util.ReflectionHelpers;
 
 @RunWith(AndroidJUnit4.class)
@@ -736,9 +736,9 @@ public class ShadowConnectivityManagerTest {
   public void connectivityManager_instanceBasedOnSdkVersion() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
-      activity = Robolectric.setupActivity(TestActivity.class);
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
+      Activity activity = controller.get();
       ConnectivityManager activityConnectivityManager =
           (ConnectivityManager) activity.getSystemService(Context.CONNECTIVITY_SERVICE);
 
@@ -752,9 +752,6 @@ public class ShadowConnectivityManagerTest {
 
       assertThat(activityActiveNetwork).isEqualTo(applicationActiveNetwork);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
index 6f0f5f77e..e0ad9cb4a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
@@ -5,7 +5,6 @@ import static android.content.ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS;
 import static android.content.ContentResolver.QUERY_ARG_SQL_SORT_ORDER;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
-import static android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertThrows;
@@ -76,6 +75,9 @@ import org.robolectric.util.NamedStream;
 public class ShadowContentResolverTest {
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
 
+  private static final Uri FAKE_URI =
+      Uri.parse("content://robolectric").buildUpon().appendPath("fakepath").build();
+
   private static final String AUTHORITY = "org.robolectric";
 
   private ContentResolver contentResolver;
@@ -88,8 +90,8 @@ public class ShadowContentResolverTest {
   public void setUp() {
     contentResolver = ApplicationProvider.getApplicationContext().getContentResolver();
     shadowContentResolver = shadowOf(contentResolver);
-    uri21 = Uri.parse(EXTERNAL_CONTENT_URI.toString() + "/21");
-    uri22 = Uri.parse(EXTERNAL_CONTENT_URI.toString() + "/22");
+    uri21 = Uri.parse(FAKE_URI.toString() + "/21");
+    uri22 = Uri.parse(FAKE_URI.toString() + "/22");
 
     a = new Account("a", "type");
     b = new Account("b", "type");
@@ -99,8 +101,8 @@ public class ShadowContentResolverTest {
   public void insert_shouldReturnIncreasingUris() {
     shadowContentResolver.setNextDatabaseIdForInserts(20);
 
-    assertThat(contentResolver.insert(EXTERNAL_CONTENT_URI, new ContentValues())).isEqualTo(uri21);
-    assertThat(contentResolver.insert(EXTERNAL_CONTENT_URI, new ContentValues())).isEqualTo(uri22);
+    assertThat(contentResolver.insert(FAKE_URI, new ContentValues())).isEqualTo(uri21);
+    assertThat(contentResolver.insert(FAKE_URI, new ContentValues())).isEqualTo(uri22);
   }
 
   @Test
@@ -157,10 +159,9 @@ public class ShadowContentResolverTest {
   public void insert_shouldTrackInsertStatements() {
     ContentValues contentValues = new ContentValues();
     contentValues.put("foo", "bar");
-    contentResolver.insert(EXTERNAL_CONTENT_URI, contentValues);
+    contentResolver.insert(FAKE_URI, contentValues);
     assertThat(shadowContentResolver.getInsertStatements().size()).isEqualTo(1);
-    assertThat(shadowContentResolver.getInsertStatements().get(0).getUri())
-        .isEqualTo(EXTERNAL_CONTENT_URI);
+    assertThat(shadowContentResolver.getInsertStatements().get(0).getUri()).isEqualTo(FAKE_URI);
     assertThat(
             shadowContentResolver
                 .getInsertStatements()
@@ -171,7 +172,7 @@ public class ShadowContentResolverTest {
 
     contentValues = new ContentValues();
     contentValues.put("hello", "world");
-    contentResolver.insert(EXTERNAL_CONTENT_URI, contentValues);
+    contentResolver.insert(FAKE_URI, contentValues);
     assertThat(shadowContentResolver.getInsertStatements().size()).isEqualTo(2);
     assertThat(
             shadowContentResolver
@@ -186,11 +187,9 @@ public class ShadowContentResolverTest {
   public void insert_shouldTrackUpdateStatements() {
     ContentValues contentValues = new ContentValues();
     contentValues.put("foo", "bar");
-    contentResolver.update(
-        EXTERNAL_CONTENT_URI, contentValues, "robolectric", new String[] {"awesome"});
+    contentResolver.update(FAKE_URI, contentValues, "robolectric", new String[] {"awesome"});
     assertThat(shadowContentResolver.getUpdateStatements().size()).isEqualTo(1);
-    assertThat(shadowContentResolver.getUpdateStatements().get(0).getUri())
-        .isEqualTo(EXTERNAL_CONTENT_URI);
+    assertThat(shadowContentResolver.getUpdateStatements().get(0).getUri()).isEqualTo(FAKE_URI);
     assertThat(
             shadowContentResolver
                 .getUpdateStatements()
@@ -205,10 +204,9 @@ public class ShadowContentResolverTest {
 
     contentValues = new ContentValues();
     contentValues.put("hello", "world");
-    contentResolver.update(EXTERNAL_CONTENT_URI, contentValues, null, null);
+    contentResolver.update(FAKE_URI, contentValues, null, null);
     assertThat(shadowContentResolver.getUpdateStatements().size()).isEqualTo(2);
-    assertThat(shadowContentResolver.getUpdateStatements().get(1).getUri())
-        .isEqualTo(EXTERNAL_CONTENT_URI);
+    assertThat(shadowContentResolver.getUpdateStatements().get(1).getUri()).isEqualTo(FAKE_URI);
     assertThat(
             shadowContentResolver
                 .getUpdateStatements()
@@ -222,13 +220,13 @@ public class ShadowContentResolverTest {
 
   @Test
   public void insert_supportsNullContentValues() {
-    contentResolver.insert(EXTERNAL_CONTENT_URI, null);
+    contentResolver.insert(FAKE_URI, null);
     assertThat(shadowContentResolver.getInsertStatements().get(0).getContentValues()).isNull();
   }
 
   @Test
   public void update_supportsNullContentValues() {
-    contentResolver.update(EXTERNAL_CONTENT_URI, null, null, null);
+    contentResolver.update(FAKE_URI, null, null, null);
     assertThat(shadowContentResolver.getUpdateStatements().get(0).getContentValues()).isNull();
   }
 
@@ -1062,10 +1060,9 @@ public class ShadowContentResolverTest {
   @Test
   public void shouldThrowConfiguredExceptionWhenRegisteringContentObservers() {
     ShadowContentResolver scr = shadowOf(contentResolver);
-    scr.setRegisterContentProviderException(EXTERNAL_CONTENT_URI, new SecurityException());
+    scr.setRegisterContentProviderException(FAKE_URI, new SecurityException());
     try {
-      contentResolver.registerContentObserver(
-          EXTERNAL_CONTENT_URI, true, new TestContentObserver(null));
+      contentResolver.registerContentObserver(FAKE_URI, true, new TestContentObserver(null));
       fail();
     } catch (SecurityException expected) {
     }
@@ -1074,11 +1071,10 @@ public class ShadowContentResolverTest {
   @Test
   public void shouldClearConfiguredExceptionForRegisteringContentObservers() {
     ShadowContentResolver scr = shadowOf(contentResolver);
-    scr.setRegisterContentProviderException(EXTERNAL_CONTENT_URI, new SecurityException());
-    scr.clearRegisterContentProviderException(EXTERNAL_CONTENT_URI);
+    scr.setRegisterContentProviderException(FAKE_URI, new SecurityException());
+    scr.clearRegisterContentProviderException(FAKE_URI);
     // Should not throw the SecurityException.
-    contentResolver.registerContentObserver(
-        EXTERNAL_CONTENT_URI, true, new TestContentObserver(null));
+    contentResolver.registerContentObserver(FAKE_URI, true, new TestContentObserver(null));
   }
 
   @Test
@@ -1086,32 +1082,32 @@ public class ShadowContentResolverTest {
     TestContentObserver co = new TestContentObserver(null);
     ShadowContentResolver scr = shadowOf(contentResolver);
 
-    assertThat(scr.getContentObservers(EXTERNAL_CONTENT_URI)).isEmpty();
+    assertThat(scr.getContentObservers(FAKE_URI)).isEmpty();
 
-    contentResolver.registerContentObserver(EXTERNAL_CONTENT_URI, true, co);
+    contentResolver.registerContentObserver(FAKE_URI, true, co);
 
-    assertThat(scr.getContentObservers(EXTERNAL_CONTENT_URI)).containsExactly((ContentObserver) co);
+    assertThat(scr.getContentObservers(FAKE_URI)).containsExactly((ContentObserver) co);
 
     assertThat(co.changed).isFalse();
-    contentResolver.notifyChange(EXTERNAL_CONTENT_URI, null);
+    contentResolver.notifyChange(FAKE_URI, null);
     assertThat(co.changed).isTrue();
 
     contentResolver.unregisterContentObserver(co);
-    assertThat(scr.getContentObservers(EXTERNAL_CONTENT_URI)).isEmpty();
+    assertThat(scr.getContentObservers(FAKE_URI)).isEmpty();
   }
 
   @Test
   public void shouldUnregisterContentObservers() {
     TestContentObserver co = new TestContentObserver(null);
     ShadowContentResolver scr = shadowOf(contentResolver);
-    contentResolver.registerContentObserver(EXTERNAL_CONTENT_URI, true, co);
-    assertThat(scr.getContentObservers(EXTERNAL_CONTENT_URI)).contains(co);
+    contentResolver.registerContentObserver(FAKE_URI, true, co);
+    assertThat(scr.getContentObservers(FAKE_URI)).contains(co);
 
     contentResolver.unregisterContentObserver(co);
-    assertThat(scr.getContentObservers(EXTERNAL_CONTENT_URI)).isEmpty();
+    assertThat(scr.getContentObservers(FAKE_URI)).isEmpty();
 
     assertThat(co.changed).isFalse();
-    contentResolver.notifyChange(EXTERNAL_CONTENT_URI, null);
+    contentResolver.notifyChange(FAKE_URI, null);
     assertThat(co.changed).isFalse();
   }
 
@@ -1120,9 +1116,9 @@ public class ShadowContentResolverTest {
     TestContentObserver co1 = new TestContentObserver(null);
     TestContentObserver co2 = new TestContentObserver(null);
 
-    Uri childUri = EXTERNAL_CONTENT_URI.buildUpon().appendPath("path").build();
+    Uri childUri = FAKE_URI.buildUpon().appendPath("path").build();
 
-    contentResolver.registerContentObserver(EXTERNAL_CONTENT_URI, true, co1);
+    contentResolver.registerContentObserver(FAKE_URI, true, co1);
     contentResolver.registerContentObserver(childUri, false, co2);
 
     co1.changed = co2.changed = false;
@@ -1131,7 +1127,7 @@ public class ShadowContentResolverTest {
     assertThat(co2.changed).isTrue();
 
     co1.changed = co2.changed = false;
-    contentResolver.notifyChange(EXTERNAL_CONTENT_URI, null);
+    contentResolver.notifyChange(FAKE_URI, null);
     assertThat(co1.changed).isTrue();
     assertThat(co2.changed).isFalse();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
index 70ac9d737..e2faaeb43 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
@@ -28,6 +28,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -172,13 +173,13 @@ public class ShadowContextHubManagerTest {
   public void contextHubManager_instance_retrievesSameContextHubInfo() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
 
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       ContextHubManager applicationContextHubManager =
           context.getSystemService(ContextHubManager.class);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       ContextHubManager activityContextHubManager =
           activity.getSystemService(ContextHubManager.class);
 
@@ -192,9 +193,6 @@ public class ShadowContextHubManagerTest {
 
       assertThat(activityContextHubs).isEqualTo(applicationContextHubs);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
index 0637239a0..ded004594 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
@@ -1,53 +1,76 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.shadows.ShadowCountDownTimer.PROPERTY_USE_REAL_IMPL;
 
 import android.os.CountDownTimer;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Arrays;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.ParameterizedRobolectricTestRunner;
 import org.robolectric.Shadows;
 
-@RunWith(AndroidJUnit4.class)
+@RunWith(ParameterizedRobolectricTestRunner.class)
 public class ShadowCountDownTimerTest {
+  private static final String MESSAGE_TICK = "onTick() is called";
+  private static final String MESSAGE_FINISH = "onFinish() is called";
 
   private ShadowCountDownTimer shadowCountDownTimer;
   private final long millisInFuture = 2000;
   private final long countDownInterval = 1000;
-  private String msg = null;
+  private final boolean useRealCountDownTimer;
+  private String message;
+  private String originalUseRealCountDownTimer;
+
+  public ShadowCountDownTimerTest(boolean useRealCountDownTimer) {
+    this.useRealCountDownTimer = useRealCountDownTimer;
+  }
 
   @Before
   public void setUp() throws Exception {
+    originalUseRealCountDownTimer = System.getProperty(PROPERTY_USE_REAL_IMPL);
+
+    System.setProperty(PROPERTY_USE_REAL_IMPL, Boolean.toString(useRealCountDownTimer));
 
     CountDownTimer countDownTimer =
         new CountDownTimer(millisInFuture, countDownInterval) {
 
           @Override
           public void onFinish() {
-            msg = "onFinish() is called";
+            message = MESSAGE_FINISH;
           }
 
           @Override
           public void onTick(long millisUnitilFinished) {
-            msg = "onTick() is called";
+            message = MESSAGE_TICK;
           }
         };
     shadowCountDownTimer = Shadows.shadowOf(countDownTimer);
   }
 
+  @After
+  public void tearDown() {
+    if (originalUseRealCountDownTimer != null) {
+      System.setProperty(PROPERTY_USE_REAL_IMPL, originalUseRealCountDownTimer);
+    } else {
+      System.clearProperty(PROPERTY_USE_REAL_IMPL);
+    }
+  }
+
   @Test
   public void testInvokeOnTick() {
-    assertThat(msg).isNotEqualTo("onTick() is called");
+    assertThat(message).isNull();
     shadowCountDownTimer.invokeTick(countDownInterval);
-    assertThat(msg).isEqualTo("onTick() is called");
+    assertThat(message).isEqualTo(MESSAGE_TICK);
   }
 
   @Test
   public void testInvokeOnFinish() {
-    assertThat(msg).isNotEqualTo("onFinish() is called");
+    assertThat(message).isNull();
     shadowCountDownTimer.invokeFinish();
-    assertThat(msg).isEqualTo("onFinish() is called");
+    assertThat(message).isEqualTo(MESSAGE_FINISH);
   }
 
   @Test
@@ -60,10 +83,14 @@ public class ShadowCountDownTimerTest {
 
   @Test
   public void testCancel() {
+    assertThat(shadowCountDownTimer.isCancelled()).isFalse();
+    assertThat(shadowCountDownTimer.hasStarted()).isFalse();
     CountDownTimer timer = shadowCountDownTimer.start();
     assertThat(timer).isNotNull();
+    assertThat(shadowCountDownTimer.isCancelled()).isFalse();
     assertThat(shadowCountDownTimer.hasStarted()).isTrue();
     shadowCountDownTimer.cancel();
+    assertThat(shadowCountDownTimer.isCancelled()).isTrue();
     assertThat(shadowCountDownTimer.hasStarted()).isFalse();
   }
 
@@ -72,4 +99,9 @@ public class ShadowCountDownTimerTest {
     assertThat(shadowCountDownTimer.getCountDownInterval()).isEqualTo(countDownInterval);
     assertThat(shadowCountDownTimer.getMillisInFuture()).isEqualTo(millisInFuture);
   }
+
+  @ParameterizedRobolectricTestRunner.Parameters(name = "useRealCountDownTimer = {0}")
+  public static Iterable<?> data() {
+    return Arrays.asList(true, false);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java
index 59011e083..7f1432045 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java
@@ -34,6 +34,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowCrossProfileApps.StartedActivity;
@@ -693,13 +694,13 @@ public class ShadowCrossProfileAppsTest {
       crossProfileApps_activityContextEnabled_differentInstancesRetrieveTargetUserProfiles() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       CrossProfileApps applicationCrossProfileApps =
           (CrossProfileApps)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       CrossProfileApps activityCrossProfileApps =
           (CrossProfileApps) activity.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
 
@@ -712,9 +713,6 @@ public class ShadowCrossProfileAppsTest {
 
       assertThat(activityTargetUserProfiles).isEqualTo(applicationTargetUserProfiles);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
index 4d9e156a5..f6c1bd9f0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
@@ -69,6 +69,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -2739,14 +2740,14 @@ public final class ShadowDevicePolicyManagerTest {
   public void devicePolicyManager_instance_retrievesSameAdminStatus() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       DevicePolicyManager applicationDpm =
           (DevicePolicyManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.DEVICE_POLICY_SERVICE);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
 
       DevicePolicyManager activityDpm =
           (DevicePolicyManager) activity.getSystemService(Context.DEVICE_POLICY_SERVICE);
@@ -2759,9 +2760,6 @@ public final class ShadowDevicePolicyManagerTest {
 
       assertThat(activityAdminActive).isEqualTo(applicationAdminActive);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
index f044f1a33..44913ae0f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
@@ -7,6 +8,7 @@ import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowDisplayManagerTest.HideFromJB.getGlobal;
 
+import android.app.Activity;
 import android.content.Context;
 import android.graphics.Point;
 import android.hardware.display.BrightnessChangeEvent;
@@ -21,13 +23,17 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
+/** Tests for {@link ShadowDisplayManager}. */
 @RunWith(AndroidJUnit4.class)
 public class ShadowDisplayManagerTest {
 
@@ -513,6 +519,39 @@ public class ShadowDisplayManagerTest {
         .contains("configureDefaultDisplay was called a second time");
   }
 
+  @Test
+  @Config(minSdk = O)
+  public void displayManager_activityContextEnabled_differentInstancesRetrieveDisplays() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
+      DisplayManager applicationDisplayManager =
+          ApplicationProvider.getApplicationContext().getSystemService(DisplayManager.class);
+      Activity activity = controller.get();
+      DisplayManager activityDisplayManager = activity.getSystemService(DisplayManager.class);
+
+      assertThat(applicationDisplayManager).isNotSameInstanceAs(activityDisplayManager);
+
+      Display[] applicationDisplays =
+          Objects.requireNonNull(applicationDisplayManager).getDisplays();
+      Display[] activityDisplays = Objects.requireNonNull(activityDisplayManager).getDisplays();
+
+      assertThat(activityDisplays.length).isEqualTo(applicationDisplays.length);
+
+      for (int i = 0; i < applicationDisplays.length; i++) {
+        Display appDisplay = applicationDisplays[i];
+        Display actDisplay = activityDisplays[i];
+
+        assertThat(actDisplay.getDisplayId()).isEqualTo(appDisplay.getDisplayId());
+        assertThat(actDisplay.getWidth()).isEqualTo(appDisplay.getWidth());
+        assertThat(actDisplay.getHeight()).isEqualTo(appDisplay.getHeight());
+      }
+    } finally {
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   // because we don't want DisplayManagerGlobal resolved as part of the test class.
   static class HideFromJB {
     public static DisplayManagerGlobal getGlobal() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java
index d8772eca4..48b735df3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
@@ -14,6 +15,8 @@ import android.graphics.Insets;
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.hardware.display.DisplayManagerGlobal;
+import android.os.StrictMode;
+import android.os.StrictMode.VmPolicy;
 import android.util.DisplayMetrics;
 import android.view.Display;
 import android.view.Display.HdrCapabilities;
@@ -273,4 +276,18 @@ public class ShadowDisplayTest {
 
     assertEquals(cutout, display.getCutout());
   }
+
+  @Config(minSdk = R)
+  @Test
+  public void getDefaultDisplay_strictModeEnabled_doesNotThrow() {
+    VmPolicy oldPolicy = StrictMode.getVmPolicy();
+    try {
+      ShadowLog.clear();
+      StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll().penaltyLog().build());
+      assertThat(ShadowDisplay.getDefaultDisplay()).isNotNull();
+      assertThat(ShadowLog.getLogsForTag("StrictMode")).isEmpty();
+    } finally {
+      StrictMode.setVmPolicy(oldPolicy);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDistanceMeasurementManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDistanceMeasurementManagerTest.java
index 74459fda3..d4d81155c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDistanceMeasurementManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDistanceMeasurementManagerTest.java
@@ -14,13 +14,13 @@ import android.bluetooth.le.DistanceMeasurementParams;
 import android.bluetooth.le.DistanceMeasurementResult;
 import android.bluetooth.le.DistanceMeasurementSession;
 import android.content.Context;
-import androidx.annotation.NonNull;
 import androidx.test.core.app.ApplicationProvider;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,7 +53,7 @@ public class ShadowDistanceMeasurementManagerTest {
   private final Object distanceMeasurementSessionCallback =
       new DistanceMeasurementSession.Callback() {
         @Override
-        public void onStarted(@NonNull DistanceMeasurementSession session) {
+        public void onStarted(@Nonnull DistanceMeasurementSession session) {
           startedDistanceMeasurementSession = session;
         }
 
@@ -63,13 +63,13 @@ public class ShadowDistanceMeasurementManagerTest {
         }
 
         @Override
-        public void onStopped(@NonNull DistanceMeasurementSession session, int reason) {
+        public void onStopped(@Nonnull DistanceMeasurementSession session, int reason) {
           onStoppedReason = reason;
         }
 
         @Override
         public void onResult(
-            @NonNull BluetoothDevice device, @NonNull DistanceMeasurementResult result) {
+            @Nonnull BluetoothDevice device, @Nonnull DistanceMeasurementResult result) {
           distanceMeasurementResults.add(result);
         }
       };
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java
index 938891f4e..7628478c5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java
@@ -20,10 +20,10 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowDownloadManager.CompletedDownload;
 import org.robolectric.shadows.ShadowDownloadManager.ShadowRequest;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowDownloadManagerTest {
@@ -424,13 +424,13 @@ public class ShadowDownloadManagerTest {
   public void downloadManager_activityContextEnabled_retrievesSameMimeTypeForDownloadedFile() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       DownloadManager applicationDownloadManager =
           (DownloadManager)
               RuntimeEnvironment.getApplication().getSystemService(Context.DOWNLOAD_SERVICE);
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       DownloadManager activityDownloadManager =
           (DownloadManager) activity.getSystemService(Context.DOWNLOAD_SERVICE);
 
@@ -442,9 +442,6 @@ public class ShadowDownloadManagerTest {
 
       assertThat(activityMimeType).isEqualTo(applicationMimeType);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java
index 61784b4c7..d2339b5f3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java
@@ -14,10 +14,12 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
+import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Unit tests for {@see ShadowDropboxManager}. */
@@ -102,9 +104,9 @@ public class ShadowDropBoxManagerTest {
   @Test
   public void testAddText() {
     long baseTimestamp = 55000L;
-    SystemClock.setCurrentTimeMillis(baseTimestamp);
+    ShadowSystemClock.advanceBy(55000 - SystemClock.uptimeMillis(), TimeUnit.MILLISECONDS);
     manager.addText(TAG, "HELLO WORLD");
-    SystemClock.setCurrentTimeMillis(baseTimestamp + 100);
+    ShadowSystemClock.advanceBy(100, TimeUnit.MILLISECONDS);
     manager.addText(TAG, "GOODBYE WORLD");
 
     Entry entry = manager.getNextEntry(null, 0);
@@ -125,8 +127,8 @@ public class ShadowDropBoxManagerTest {
   public void dropBoxManager_activityContextEnabled_differentInstancesVerifyTagEnabled() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       DropBoxManager applicationDropBoxManager =
           (DropBoxManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.DROPBOX_SERVICE);
@@ -135,7 +137,7 @@ public class ShadowDropBoxManagerTest {
       String data = "testData";
       applicationDropBoxManager.addText(tag, data);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       DropBoxManager activityDropBoxManager =
           (DropBoxManager) activity.getSystemService(Context.DROPBOX_SERVICE);
 
@@ -144,9 +146,6 @@ public class ShadowDropBoxManagerTest {
 
       assertThat(activityTagEnabled).isEqualTo(applicationTagEnabled);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java
index e07c300f0..7604a5cbe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java
@@ -15,6 +15,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Junit test for {@link ShadowEuiccManager}. */
@@ -65,12 +66,12 @@ public class ShadowEuiccManagerTest {
   public void euiccManager_activityContextEnabled_differentInstancesRetrieveEids() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       EuiccManager applicationEuiccManager =
           (EuiccManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       EuiccManager activityEuiccManager =
           (EuiccManager) activity.getSystemService(Context.EUICC_SERVICE);
 
@@ -81,9 +82,6 @@ public class ShadowEuiccManagerTest {
 
       assertThat(activityEid).isEqualTo(applicationEid);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
index 168a4ce29..b9b770099 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
@@ -8,13 +8,14 @@ import android.content.Context;
 import android.security.FileIntegrityManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Objects;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = R)
@@ -45,28 +46,26 @@ public final class ShadowFileIntegrityManagerTest {
   public void fileIntegrityManager_activityContextEnabled_retrievesSameValues() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       FileIntegrityManager applicationFileIntegrityManager =
           (FileIntegrityManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.FILE_INTEGRITY_SERVICE);
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       FileIntegrityManager activityFileIntegrityManager =
           (FileIntegrityManager) activity.getSystemService(Context.FILE_INTEGRITY_SERVICE);
 
       assertThat(applicationFileIntegrityManager).isNotSameInstanceAs(activityFileIntegrityManager);
 
       boolean applicationApkVeritySupported =
-          applicationFileIntegrityManager.isApkVeritySupported();
-      boolean activityApkVeritySupported = activityFileIntegrityManager.isApkVeritySupported();
+          Objects.requireNonNull(applicationFileIntegrityManager).isApkVeritySupported();
+      boolean activityApkVeritySupported =
+          Objects.requireNonNull(activityFileIntegrityManager).isApkVeritySupported();
 
       assertThat(activityApkVeritySupported).isEqualTo(applicationApkVeritySupported);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
index 5af94004d..decfab99a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
@@ -21,8 +21,8 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = M)
@@ -130,14 +130,14 @@ public class ShadowFingerprintManagerTest {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
 
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       FingerprintManager applicationFingerprintManager =
           (FingerprintManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.FINGERPRINT_SERVICE);
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       FingerprintManager activityFingerprintManager =
           (FingerprintManager) activity.getSystemService(Context.FINGERPRINT_SERVICE);
 
@@ -153,9 +153,6 @@ public class ShadowFingerprintManagerTest {
       assertThat(hasActivityEnrolledFingerprints).isEqualTo(hasApplicationEnrolledFingerprints);
 
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGradientDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGradientDrawableTest.java
index 667e301c1..42b855f00 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGradientDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGradientDrawableTest.java
@@ -12,13 +12,26 @@ import org.junit.runner.RunWith;
 public class ShadowGradientDrawableTest {
   @Test
   public void testGetLastSetColor_returnsColor() {
-    GradientDrawable gradientDrawable = new GradientDrawable();
-    ShadowGradientDrawable shadowGradientDrawable = shadowOf(gradientDrawable);
     int color = 123;
+    GradientDrawable gradientDrawable = new GradientDrawable();
+
     gradientDrawable.setColor(color);
+
+    ShadowGradientDrawable shadowGradientDrawable = shadowOf(gradientDrawable);
     assertThat(shadowGradientDrawable.getLastSetColor()).isEqualTo(color);
   }
 
+  @Test
+  public void testGetShape_returnsShape() {
+    int shape = GradientDrawable.OVAL;
+    GradientDrawable gradientDrawable = new GradientDrawable();
+
+    gradientDrawable.setShape(shape);
+
+    ShadowGradientDrawable shadowGradientDrawable = shadowOf(gradientDrawable);
+    assertThat(shadowGradientDrawable.getShape()).isEqualTo(shape);
+  }
+
   @Test
   public void testGetStrokeWidth_returnsStrokeWidth() {
     int strokeWidth = 123;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowIconTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowIconTest.java
index f670d372d..477262637 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowIconTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowIconTest.java
@@ -13,9 +13,9 @@ import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
index 9ec083ab7..f83188e3b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
@@ -20,7 +20,6 @@ import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowImageViewTest {
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
index 0e60524bf..76fc35358 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
@@ -24,6 +24,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -161,13 +162,13 @@ public class ShadowInputMethodManagerTest {
       inputMethodManager_activityContextEnabled_differentInstancesRetrieveInputMethodList() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       InputMethodManager applicationInputMethodManager =
           (InputMethodManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.INPUT_METHOD_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       InputMethodManager activityInputMethodManager =
           (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
 
@@ -179,9 +180,6 @@ public class ShadowInputMethodManagerTest {
       assertThat(activityIsAcceptingText).isEqualTo(applicationIsAcceptingText);
 
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
index ebb5a3b29..3b2e465f3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
@@ -21,8 +21,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowKeyguardManagerTest {
@@ -198,13 +198,13 @@ public class ShadowKeyguardManagerTest {
   public void keyguardManager_activityContextEnabled_retrievesSameState() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       KeyguardManager applicationKeyguardManager =
           (KeyguardManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.KEYGUARD_SERVICE);
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       KeyguardManager activityKeyguardManager =
           (KeyguardManager) activity.getSystemService(Context.KEYGUARD_SERVICE);
 
@@ -213,9 +213,6 @@ public class ShadowKeyguardManagerTest {
 
       assertThat(activityIsKeyguardLocked).isEqualTo(applicationIsKeyguardLocked);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
index e84a340ce..aa578bc98 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
@@ -47,12 +47,14 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions;
 
 /** Robolectric test for {@link ShadowLauncherApps}. */
 @RunWith(AndroidJUnit4.class)
@@ -435,6 +437,29 @@ public class ShadowLauncherAppsTest {
           ClassParameter.from(Context.class, ApplicationProvider.getApplicationContext()),
           ClassParameter.from(UserHandle.class, userHandle),
           ClassParameter.from(LauncherActivityInfoInternal.class, launcherActivityInfoInternal));
+    } else if (RuntimeEnvironment.getApiLevel() >= AndroidVersions.Baklava.SDK_INT) {
+      boolean supportsMultiInstanceSystemUi = false;
+      try {
+        supportsMultiInstanceSystemUi =
+            RuntimeEnvironment.getApplication()
+                .getPackageManager()
+                .getProperty(
+                    "android.window.PROPERTY_SUPPORTS_MULTI_INSTANCE_SYSTEM_UI", packageName)
+                .getBoolean();
+      } catch (NameNotFoundException e) {
+        supportsMultiInstanceSystemUi = false;
+      }
+      LauncherActivityInfoInternal launcherActivityInfoInternal =
+          ReflectionHelpers.callConstructor(
+              LauncherActivityInfoInternal.class,
+              ClassParameter.from(ActivityInfo.class, info),
+              ClassParameter.from(IncrementalStatesInfo.class, null),
+              ClassParameter.from(UserHandle.class, userHandle),
+              ClassParameter.from(boolean.class, supportsMultiInstanceSystemUi));
+      return ReflectionHelpers.callConstructor(
+          LauncherActivityInfo.class,
+          ClassParameter.from(Context.class, ApplicationProvider.getApplicationContext()),
+          ClassParameter.from(LauncherActivityInfoInternal.class, launcherActivityInfoInternal));
     } else {
 
       LauncherActivityInfoInternal launcherActivityInfoInternal =
@@ -456,12 +481,12 @@ public class ShadowLauncherAppsTest {
   public void launcherApps_activityContextEnabled_differentInstancesRetrieveProfiles() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
 
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       LauncherApps applicationLauncherApps =
           ApplicationProvider.getApplicationContext().getSystemService(LauncherApps.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       LauncherApps activityLauncherApps = activity.getSystemService(LauncherApps.class);
 
       assertThat(applicationLauncherApps).isNotSameInstanceAs(activityLauncherApps);
@@ -474,9 +499,6 @@ public class ShadowLauncherAppsTest {
 
       assertThat(activityProfiles).isEqualTo(applicationProfiles);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
index 67c3dbf94..eecf070ec 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
@@ -18,7 +18,6 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.LooperMode;
-import org.robolectric.util.Join;
 
 /** Unit tests for {@link ShadowLegacyAsyncTask}. */
 @RunWith(AndroidJUnit4.class)
@@ -193,13 +192,13 @@ public class ShadowLegacyAsyncTaskTest {
 
     @Override
     protected String doInBackground(String... strings) {
-      transcript.add("doInBackground " + Join.join(", ", (Object[]) strings));
+      transcript.add("doInBackground " + String.join(", ", strings));
       return "c";
     }
 
     @Override
     protected void onProgressUpdate(String... values) {
-      transcript.add("onProgressUpdate " + Join.join(", ", (Object[]) values));
+      transcript.add("onProgressUpdate " + String.join(", ", values));
     }
 
     @Override
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
index ed2e34e5b..bbd2985d1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
@@ -14,6 +14,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -98,12 +99,12 @@ public final class ShadowLocaleManagerTest {
   public void localeManager_activityContextEnabled_differentInstancesRetrieveLocales() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       LocaleManager applicationLocaleManager =
           (LocaleManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.LOCALE_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       LocaleManager activityLocaleManager =
           (LocaleManager) activity.getSystemService(Context.LOCALE_SERVICE);
 
@@ -114,9 +115,6 @@ public final class ShadowLocaleManagerTest {
 
       assertThat(activityLocales).isEqualTo(applicationLocales);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
index 840bbb4ae..26b187928 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
@@ -1,12 +1,13 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.N;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.accessibilityservice.AccessibilityService;
 import android.accessibilityservice.AccessibilityService.MagnificationController;
+import android.accessibilityservice.MagnificationConfig;
 import android.graphics.Region;
+import android.os.Build.VERSION_CODES;
 import android.os.Looper;
 import android.view.accessibility.AccessibilityEvent;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -18,7 +19,7 @@ import org.robolectric.annotation.Config;
 
 /** Test for ShadowMagnificationController. */
 @RunWith(AndroidJUnit4.class)
-@Config(minSdk = N)
+@Config(minSdk = VERSION_CODES.N)
 public final class ShadowMagnificationControllerTest {
 
   private MagnificationController magnificationController;
@@ -29,6 +30,22 @@ public final class ShadowMagnificationControllerTest {
     magnificationController = myService.getMagnificationController();
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  public void getMagnificationConfig_setMagnificationConfig() {
+    MagnificationConfig config =
+        new MagnificationConfig.Builder()
+            .setMode(MagnificationConfig.MAGNIFICATION_MODE_FULLSCREEN)
+            .setScale(2)
+            .setCenterX(2)
+            .setCenterY(2)
+            .build();
+
+    magnificationController.setMagnificationConfig(config, false);
+
+    assertThat(magnificationController.getMagnificationConfig()).isEqualTo(config);
+  }
+
   @Test
   public void getCenterX_byDefault_returns0() {
     assertThat(magnificationController.getCenterX()).isEqualTo(0.0f);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
index 70d495214..442aa8608 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
@@ -7,9 +7,11 @@ import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.nullable;
 import static org.mockito.ArgumentMatchers.refEq;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.same;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -33,6 +35,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.verification.VerificationMode;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowMediaCodec.CodecConfig;
 import org.robolectric.shadows.ShadowMediaCodec.CodecConfig.Codec;
 
@@ -258,6 +261,47 @@ public final class ShadowMediaCodecTest {
     asyncVerify(callback).onOutputBufferAvailable(same(codec), anyInt(), any());
   }
 
+  @Test
+  public void presentsInputBufferAfterFlushingThenStarting() throws IOException {
+    MediaCodec codec = createAsyncEncoder();
+    ArgumentCaptor<Integer> indexCaptor = ArgumentCaptor.forClass(Integer.class);
+    verify(callback).onInputBufferAvailable(same(codec), indexCaptor.capture());
+
+    codec.flush();
+    codec.start();
+
+    shadowMainLooper().idle();
+
+    verify(callback, times(2)).onInputBufferAvailable(same(codec), eq(indexCaptor.getValue()));
+  }
+
+  @Config(minSdk = 34)
+  @Test
+  public void presentsInputBufferAfterQueuingInputBufferWithDecodeOnlyFlag() throws IOException {
+    MediaCodec codec = createAsyncEncoder();
+    ArgumentCaptor<Integer> indexCaptor = ArgumentCaptor.forClass(Integer.class);
+    verify(callback).onInputBufferAvailable(same(codec), indexCaptor.capture());
+
+    int inputBufferIndex = indexCaptor.getValue();
+    ByteBuffer buffer = codec.getInputBuffer(inputBufferIndex);
+
+    int start = buffer.position();
+    // "Write" to the buffer.
+    buffer.position(buffer.limit());
+
+    codec.queueInputBuffer(
+        inputBufferIndex,
+        /* offset= */ start,
+        /* size= */ buffer.position() - start,
+        /* presentationTimeUs= */ 0,
+        /* flags= */ MediaCodec.BUFFER_FLAG_DECODE_ONLY);
+
+    shadowMainLooper().idle();
+
+    verify(callback, never()).onOutputBufferAvailable(any(), anyInt(), any());
+    verify(callback, times(2)).onInputBufferAvailable(same(codec), eq(inputBufferIndex));
+  }
+
   @Test
   public void providesValidOutputBuffer() throws IOException {
     MediaCodec codec = createAsyncEncoder();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
index 15252bc16..89fd14d65 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
@@ -17,6 +17,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowMediaRouter}. */
@@ -135,14 +136,14 @@ public final class ShadowMediaRouterTest {
   public void mediaRouter_activityContextEnabled_differentInstancesRetrieveDefaultRoute() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       MediaRouter applicationMediaRouter =
           (MediaRouter)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.MEDIA_ROUTER_SERVICE);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       MediaRouter activityMediaRouter =
           (MediaRouter) activity.getSystemService(Context.MEDIA_ROUTER_SERVICE);
 
@@ -153,9 +154,6 @@ public final class ShadowMediaRouterTest {
 
       assertThat(activityDefaultRoute).isEqualTo(applicationDefaultRoute);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
index 85de8c537..8d1588eba 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
@@ -18,6 +18,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowMediaSessionManager} */
@@ -69,11 +70,11 @@ public class ShadowMediaSessionManagerTest {
   public void mediaSessionManager_activityContextEnabled_differentInstancesRetrieveSessions() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       MediaSessionManager applicationMediaSessionManager =
           RuntimeEnvironment.getApplication().getSystemService(MediaSessionManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       MediaSessionManager activityMediaSessionManager =
           activity.getSystemService(MediaSessionManager.class);
 
@@ -86,9 +87,6 @@ public class ShadowMediaSessionManagerTest {
 
       assertThat(activityControllers).isEqualTo(applicationControllers);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java
index 11f4440bd..c33373105 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java
@@ -1,19 +1,21 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.R;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.webkit.MimeTypeMap;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
+@Config(maxSdk = R)
 public class ShadowMimeTypeMapTest {
 
   private static final String IMAGE_EXTENSION = "jpg";
@@ -21,20 +23,6 @@ public class ShadowMimeTypeMapTest {
   private static final String VIDEO_MIMETYPE = "video/mp4";
   private static final String IMAGE_MIMETYPE = "image/jpeg";
 
-  @Test
-  public void shouldResetStaticStateBetweenTests() {
-    assertFalse(MimeTypeMap.getSingleton().hasExtension(VIDEO_EXTENSION));
-    shadowOf(MimeTypeMap.getSingleton())
-        .addExtensionMimeTypeMapping(VIDEO_EXTENSION, VIDEO_MIMETYPE);
-  }
-
-  @Test
-  public void shouldResetStaticStateBetweenTests_anotherTime() {
-    assertFalse(MimeTypeMap.getSingleton().hasExtension(VIDEO_EXTENSION));
-    shadowOf(MimeTypeMap.getSingleton())
-        .addExtensionMimeTypeMapping(VIDEO_EXTENSION, VIDEO_MIMETYPE);
-  }
-
   @Test
   public void getSingletonShouldAlwaysReturnSameInstance() {
     MimeTypeMap firstInstance = MimeTypeMap.getSingleton();
@@ -43,12 +31,6 @@ public class ShadowMimeTypeMapTest {
     assertSame(firstInstance, secondInstance);
   }
 
-  @Test
-  public void byDefaultThereShouldBeNoMapping() {
-    assertFalse(MimeTypeMap.getSingleton().hasExtension(VIDEO_EXTENSION));
-    assertFalse(MimeTypeMap.getSingleton().hasExtension(IMAGE_EXTENSION));
-  }
-
   @Test
   public void addingMappingShouldWorkCorrectly() {
     ShadowMimeTypeMap shadowMimeTypeMap = Shadows.shadowOf(MimeTypeMap.getSingleton());
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java
index a703469b3..82c519825 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java
@@ -12,6 +12,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -46,11 +47,11 @@ public final class ShadowNetworkScoreManagerTest {
       networkScoreManager_activityContextEnabled_differentInstancesRetrieveActiveScorerPackage() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       NetworkScoreManager applicationNetworkScoreManager =
           RuntimeEnvironment.getApplication().getSystemService(NetworkScoreManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       NetworkScoreManager activityNetworkScoreManager =
           activity.getSystemService(NetworkScoreManager.class);
 
@@ -61,9 +62,6 @@ public final class ShadowNetworkScoreManagerTest {
 
       assertThat(activityScorerPackage).isEqualTo(applicationScorerPackage);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
index 864d9c258..83536007c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
@@ -34,6 +34,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -828,8 +829,8 @@ public class ShadowNotificationManagerTest {
   public void notificationManager_activityContext_enabled_differentInstancesRetrieveChannels() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       NotificationManager applicationNotificationManager =
           (NotificationManager)
               ApplicationProvider.getApplicationContext()
@@ -840,7 +841,7 @@ public class ShadowNotificationManagerTest {
               "test_channel_id", "Test Channel", NotificationManager.IMPORTANCE_DEFAULT);
       applicationNotificationManager.createNotificationChannel(testChannel);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       NotificationManager activityNotificationManager =
           (NotificationManager) activity.getSystemService(Context.NOTIFICATION_SERVICE);
 
@@ -851,9 +852,6 @@ public class ShadowNotificationManagerTest {
 
       assertThat(activityChannel).isEqualTo(applicationChannel);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
index 4886be128..9dfb69203 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
@@ -21,7 +21,6 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.android.util.concurrent.PausedExecutorService;
-import org.robolectric.util.Join;
 
 /** Unit tests for {@link ShadowPausedAsyncTask}. */
 @RunWith(AndroidJUnit4.class)
@@ -215,13 +214,13 @@ public class ShadowPausedAsyncTaskTest {
 
     @Override
     protected String doInBackground(String... strings) {
-      transcript.add("doInBackground " + Join.join(", ", (Object[]) strings));
+      transcript.add("doInBackground " + String.join(", ", strings));
       return "c";
     }
 
     @Override
     protected void onProgressUpdate(String... values) {
-      transcript.add("onProgressUpdate " + Join.join(", ", (Object[]) values));
+      transcript.add("onProgressUpdate " + String.join(", ", values));
     }
 
     @Override
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java
index ebb9e02d8..7123b696c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java
@@ -162,7 +162,7 @@ public class ShadowPausedLooperTest {
     ShadowPausedLooper shadowLooper = Shadow.extract(handlerThread.getLooper());
     shadowLooper.idle();
     verify(mockRunnable, times(0)).run();
-    SystemClock.setCurrentTimeMillis(SystemClock.uptimeMillis() + 100);
+    ShadowSystemClock.advanceBy(Duration.ofMillis(100));
     shadowLooper.idle();
     verify(mockRunnable, times(1)).run();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java
index 6152d5472..e96851f0f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.S;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -167,9 +168,25 @@ public class ShadowPausedSystemClockTest {
     assertThat(SystemClock.currentThreadTimeMillis()).isEqualTo(1100);
   }
 
+  @Test
+  @Config(minSdk = S)
+  public void advanceTimeBy_shouldAdvanceNanoTime() {
+    long startUptimeNanos = SystemClock.uptimeNanos();
+    long startUptimeMs = SystemClock.uptimeMillis();
+    ShadowSystemClock.advanceBy(Duration.ofNanos(100));
+
+    assertThat(SystemClock.uptimeNanos()).isEqualTo(startUptimeNanos + 100);
+    assertThat(SystemClock.uptimeMillis()).isEqualTo(startUptimeMs);
+
+    ShadowSystemClock.advanceBy(Duration.ofMillis(1));
+    assertThat(SystemClock.uptimeMillis()).isEqualTo(startUptimeMs + 1);
+    assertThat(SystemClock.uptimeNanos())
+        .isEqualTo(startUptimeNanos + 100 + ShadowPausedSystemClock.MILLIS_PER_NANO);
+  }
+
   @Test
   public void simulateDeepSleep_shouldOnlyAdvanceElapsedRealtime() {
-    SystemClock.setCurrentTimeMillis(1000);
+    ShadowSystemClock.advanceBy(1000 - SystemClock.uptimeMillis(), TimeUnit.MILLISECONDS);
 
     ShadowPausedSystemClock.simulateDeepSleep(Duration.ofMillis(100));
 
@@ -180,13 +197,13 @@ public class ShadowPausedSystemClockTest {
 
   @Test
   public void testElapsedRealtime() {
-    SystemClock.setCurrentTimeMillis(1000);
+    ShadowSystemClock.advanceBy(1000 - SystemClock.uptimeMillis(), TimeUnit.MILLISECONDS);
     assertThat(SystemClock.elapsedRealtime()).isEqualTo(1000);
   }
 
   @Test
   public void testElapsedRealtimeNanos() {
-    SystemClock.setCurrentTimeMillis(1000);
+    ShadowSystemClock.advanceBy(1000 - SystemClock.uptimeMillis(), TimeUnit.MILLISECONDS);
     assertThat(SystemClock.elapsedRealtimeNanos()).isEqualTo(1000000000);
   }
 
@@ -245,4 +262,11 @@ public class ShadowPausedSystemClockTest {
       // pass
     }
   }
+
+  @Test
+  public void advanceBy_shouldIgnoreNegativeTime() {
+    long currentTime = SystemClock.uptimeMillis();
+    ShadowPausedSystemClock.advanceBy(Duration.ofMillis(-1));
+    assertThat(SystemClock.uptimeMillis()).isEqualTo(currentTime);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
index 1b838672a..345b62431 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
@@ -36,6 +36,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowPowerManager.ShadowLowPowerStandbyPortsLock;
@@ -749,12 +750,12 @@ public class ShadowPowerManagerTest {
   public void powerManager_activityContextEnabled_checkIsInteractive() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       PowerManager applicationPowerManager =
           (PowerManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.POWER_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       PowerManager activityPowerManager =
           (PowerManager) activity.getSystemService(Context.POWER_SERVICE);
 
@@ -765,10 +766,17 @@ public class ShadowPowerManagerTest {
 
       assertThat(activityIsInteractive).isEqualTo(applicationIsInteractive);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
+
+  @Test
+  public void toString_shouldWork() {
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
+    assertThat(lock.toString()).contains("held=false");
+    lock.acquire();
+    assertThat(lock.toString()).contains("held=true");
+    lock.release();
+    assertThat(lock.toString()).contains("held=false");
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
index 114ecfab6..963f67d11 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
@@ -16,6 +16,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -58,11 +59,11 @@ public final class ShadowRestrictionsManagerTest {
   public void restrictionsManager_activityContextEnabled_hasConsistentRestrictionsProvider() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       RestrictionsManager applicationRestrictionsManager =
           ApplicationProvider.getApplicationContext().getSystemService(RestrictionsManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       RestrictionsManager activityRestrictionsManager =
           activity.getSystemService(RestrictionsManager.class);
 
@@ -73,9 +74,6 @@ public final class ShadowRestrictionsManagerTest {
 
       assertThat(activityHasProvider).isEqualTo(applicationHasProvider);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
index 7e9fbd63f..c0c2fd210 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
@@ -17,8 +17,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 
 /** Unit tests for {@link org.robolectric.shadows.ShadowRoleManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -135,11 +135,11 @@ public final class ShadowRoleManagerTest {
   public void roleManager_activityContextEnabled_differentInstancesRetrieveRoles() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       RoleManager applicationRoleManager = roleManager;
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       RoleManager activityRoleManager =
           (RoleManager) activity.getSystemService(Context.ROLE_SERVICE);
 
@@ -150,9 +150,6 @@ public final class ShadowRoleManagerTest {
 
       assertThat(activityRoleHeld).isEqualTo(applicationRoleHeld);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java
index 73ea33044..c178132ab 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java
@@ -17,6 +17,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Test for {@link ShadowRollbackManager}. */
@@ -78,12 +79,12 @@ public final class ShadowRollbackManagerTest {
   public void rollbackManager_reloadPersistedData_differentInstancesRetrieveRollbacks() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       RollbackManager applicationRollbackManager =
           (RollbackManager)
               RuntimeEnvironment.getApplication().getSystemService(Context.ROLLBACK_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       RollbackManager activityRollbackManager =
           (RollbackManager) activity.getSystemService(Context.ROLLBACK_SERVICE);
 
@@ -99,9 +100,6 @@ public final class ShadowRollbackManagerTest {
 
       assertThat(activityAvailableRollbacks).isEqualTo(applicationAvailableRollbacks);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSQLiteConnectionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSQLiteConnectionTest.java
index 9c2eab273..45ed41a5d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSQLiteConnectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSQLiteConnectionTest.java
@@ -123,7 +123,7 @@ public class ShadowSQLiteConnectionTest {
   @Test
   public void nativeClose_closesConnection() {
     assume().that(SQLiteLibraryLoader.isOsSupported()).isTrue();
-    ShadowLegacySQLiteConnection.nativeClose(ptr);
+    ShadowLegacySQLiteConnection.nativeClose(ptr, false);
     assertWithMessage("open").that(conn.isOpen()).isFalse();
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
index 3a5c837d9..72feaded8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
@@ -18,6 +18,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -499,12 +500,12 @@ public final class ShadowSafetyCenterManagerTest {
   public void safetyCenterManager_activityContextEnabled_differentInstancesCheckEnabled() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       SafetyCenterManager applicationSafetyCenterManager =
           (SafetyCenterManager)
               RuntimeEnvironment.getApplication().getSystemService(Context.SAFETY_CENTER_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       SafetyCenterManager activitySafetyCenterManager =
           (SafetyCenterManager) activity.getSystemService(Context.SAFETY_CENTER_SERVICE);
 
@@ -515,9 +516,6 @@ public final class ShadowSafetyCenterManagerTest {
 
       assertThat(activityEnabled).isEqualTo(applicationEnabled);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java
index 7a2cb28b9..9411b7918 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java
@@ -16,7 +16,6 @@ import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowScrollViewTest {
   @Test
   public void shouldSmoothScrollTo() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java
index 7bea08531..55082e7ed 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java
@@ -11,6 +11,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -22,11 +23,11 @@ public class ShadowSearchManagerTest {
       searchManager_activityContextEnabled_differentInstancesRetrieveGlobalSearchActivity() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       SearchManager applicationSearchManager =
           RuntimeEnvironment.getApplication().getSystemService(SearchManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       SearchManager activitySearchManager = activity.getSystemService(SearchManager.class);
 
       assertThat(applicationSearchManager).isNotSameInstanceAs(activitySearchManager);
@@ -37,9 +38,6 @@ public class ShadowSearchManagerTest {
 
       assertThat(activityGlobalSearchActivity).isEqualTo(applicationGlobalSearchActivity);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java
index b12997a73..ffb6a040d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java
@@ -111,4 +111,45 @@ public final class ShadowSecureElementServiceTest {
     assertThat(barChannel).isNotNull();
     assertThat(barSession.openBasicChannel("foo".getBytes(UTF_8))).isNull();
   }
+
+  @Test
+  @Config(minSdk = R)
+  public void closeChannel_thenTransmit_throws() throws Exception {
+    MockApplet mockApplet = new MockApplet("eSE", "aid".getBytes(UTF_8));
+    mockApplet.setSelectResponse("selected".getBytes(UTF_8));
+    mockApplet.addApduResponse("firstResponse".getBytes(UTF_8));
+    mockApplet.addApduResponse("secondResponse".getBytes(UTF_8));
+    ShadowSecureElementService.addMockApplet(mockApplet);
+
+    Reader[] readers = seService.getReaders();
+    assertThat(readers).hasLength(1);
+    assertThrows(IllegalArgumentException.class, () -> seService.getUiccReader(1));
+
+    Reader reader = readers[0];
+    assertThat(reader.getName()).isEqualTo("eSE");
+    assertThat(reader.getSEService()).isEqualTo(seService);
+    assertThat(reader.isSecureElementPresent()).isTrue();
+
+    Session session = reader.openSession();
+    assertThat(session).isNotNull();
+    assertThat(session.isClosed()).isFalse();
+
+    Channel channel = session.openLogicalChannel("aid".getBytes(UTF_8));
+    assertThat(channel).isNotNull();
+
+    assertThat(channel.getSelectResponse()).isEqualTo("selected".getBytes(UTF_8));
+    assertThat(channel.isBasicChannel()).isFalse();
+    assertThat(channel.isOpen()).isTrue();
+    assertThat(channel.getSession()).isEqualTo(session);
+
+    channel.close();
+    assertThat(channel.isOpen()).isFalse();
+
+    assertThrows(
+        IllegalStateException.class, () -> channel.transmit("illegalCommand".getBytes(UTF_8)));
+
+    seService.shutdown();
+    assertThat(seService.isConnected()).isFalse();
+    assertThat(session.isClosed()).isTrue();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
index e698662c7..a65f7294a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
@@ -29,8 +29,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowSensorManagerTest {
@@ -340,12 +340,12 @@ public class ShadowSensorManagerTest {
   public void sensorManager_activityContextEnabled_retrievesSameSensors() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       SensorManager applicationSensorManager =
           (SensorManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       SensorManager activitySensorManager =
           (SensorManager) activity.getSystemService(Context.SENSOR_SERVICE);
 
@@ -368,9 +368,6 @@ public class ShadowSensorManagerTest {
         assertThat(appSensor.getMinDelay()).isEqualTo(actSensor.getMinDelay());
       }
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSettingsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSettingsTest.java
index 43fcb8194..fae4c9423 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSettingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSettingsTest.java
@@ -236,6 +236,17 @@ public class ShadowSettingsTest {
     assertThat(Secure.isLocationProviderEnabled(contentResolver, NETWORK_PROVIDER)).isTrue();
   }
 
+  @Test
+  public void settingsSecure_remove_removes() {
+    String mySetting = "mysetting";
+    Secure.putInt(contentResolver, mySetting, 1337);
+    assertThat(Secure.getInt(contentResolver, mySetting, -1)).isEqualTo(1337);
+
+    ShadowSettings.ShadowSecure.remove(mySetting);
+
+    assertThat(Secure.getInt(contentResolver, mySetting, -1)).isEqualTo(-1);
+  }
+
   @Test
   public void testGlobalGetFloat() {
     float durationScale =
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
index 3e496a901..c78a44729 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
@@ -25,6 +25,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -395,14 +396,14 @@ public final class ShadowShortcutManagerTest {
   public void shortcutManager_activityContextEnabled_differentInstancesCheckRateLimiting() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       ShortcutManager applicationShortcutManager =
           (ShortcutManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.SHORTCUT_SERVICE);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       ShortcutManager activityShortcutManager =
           (ShortcutManager) activity.getSystemService(Context.SHORTCUT_SERVICE);
 
@@ -413,9 +414,6 @@ public final class ShadowShortcutManagerTest {
 
       assertThat(activityRateLimiting).isEqualTo(applicationRateLimiting);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java
index d94063c71..337cec451 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java
@@ -21,6 +21,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowSliceManager}. */
@@ -102,11 +103,11 @@ public final class ShadowSliceManagerTest {
   public void sliceManager_activityContextEnabled_differentInstancesRetrieveSlices() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       SliceManager applicationSliceManager =
           ApplicationProvider.getApplicationContext().getSystemService(SliceManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       SliceManager activitySliceManager = activity.getSystemService(SliceManager.class);
 
       assertThat(applicationSliceManager).isNotSameInstanceAs(activitySliceManager);
@@ -128,9 +129,6 @@ public final class ShadowSliceManagerTest {
       assertThat(applicationPinnedSlices).isEqualTo(activityPinnedSlices);
 
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
index 50ada18f9..69d40fe85 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
@@ -2,7 +2,9 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.PendingIntent;
 import android.app.StatsManager;
+import android.content.Intent;
 import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import org.junit.Test;
@@ -130,4 +132,60 @@ public final class ShadowStatsManagerTest {
 
     assertThat(ShadowStatsManager.getConfigData(config1Id)).isEqualTo(new byte[] {});
   }
+
+  @Test
+  public void reset_clearsBroadcastSubscriberMap_mapIsEmpty() throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long configId = 1L;
+    long subscriberId = 1L;
+    PendingIntent pendingIntent =
+        PendingIntent.getBroadcast(
+            ApplicationProvider.getApplicationContext(),
+            /* requestCode= */ 0,
+            new Intent("action"),
+            /* flags= */ 0);
+
+    statsManager.setBroadcastSubscriber(pendingIntent, configId, subscriberId);
+
+    ShadowStatsManager.reset();
+
+    assertThat(ShadowStatsManager.getBroadcastSubscriberMap()).isEmpty();
+  }
+
+  @Test
+  public void setBroadcastSubscriber_pendintIntentNotNull_addsToBroadcastSubscriberMap()
+      throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long configId = 1L;
+    long subscriberId = 1L;
+    PendingIntent pendingIntent =
+        PendingIntent.getBroadcast(
+            ApplicationProvider.getApplicationContext(),
+            /* requestCode= */ 0,
+            new Intent("action"),
+            /* flags= */ 0);
+
+    statsManager.setBroadcastSubscriber(pendingIntent, configId, subscriberId);
+
+    ShadowStatsManager.BroadcastSubscriberKey key =
+        ShadowStatsManager.BroadcastSubscriberKey.create(configId, subscriberId);
+    assertThat(ShadowStatsManager.getBroadcastSubscriberMap()).containsExactly(key, pendingIntent);
+  }
+
+  @Test
+  public void setBroadcastSubscriber_pendintIntentIsNull_removesFromBroadcastSubscriberMap()
+      throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long configId = 1L;
+    long subscriberId = 1L;
+
+    statsManager.setBroadcastSubscriber(null, configId, subscriberId);
+
+    ShadowStatsManager.BroadcastSubscriberKey key =
+        ShadowStatsManager.BroadcastSubscriberKey.create(configId, subscriberId);
+    assertThat(ShadowStatsManager.getBroadcastSubscriberMap().get(key)).isNull();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java
index 7aa82d259..cb98f3b0d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java
@@ -16,6 +16,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -95,11 +96,11 @@ public final class ShadowStatusBarManagerTest {
   public void statusBarManager_activityContextEnabled_performOperations() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       StatusBarManager applicationStatusBarManager =
           RuntimeEnvironment.getApplication().getSystemService(StatusBarManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       StatusBarManager activityStatusBarManager = activity.getSystemService(StatusBarManager.class);
 
       assertThat(applicationStatusBarManager).isNotSameInstanceAs(activityStatusBarManager);
@@ -121,9 +122,6 @@ public final class ShadowStatusBarManagerTest {
       assertThat(activityShadowStatusBarManager.getDisable2Flags())
           .isEqualTo(StatusBarManager.DISABLE2_GLOBAL_ACTIONS);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
index bf26b777e..3d047e38c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
@@ -23,6 +23,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ReflectionHelpers;
 
@@ -143,12 +144,12 @@ public class ShadowStorageManagerTest {
   public void storageManager_activityContextEnabled_differentInstancesRetrieveVolumes() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       StorageManager applicationStorageManager =
           RuntimeEnvironment.getApplication().getSystemService(StorageManager.class);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       StorageManager activityStorageManager = activity.getSystemService(StorageManager.class);
 
       assertThat(applicationStorageManager).isNotSameInstanceAs(activityStorageManager);
@@ -158,9 +159,6 @@ public class ShadowStorageManagerTest {
 
       assertThat(activityVolumes).isEqualTo(applicationVolumes);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
index 92dc8fb14..3d9f36ba0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
@@ -9,6 +9,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static android.telephony.SubscriptionManager.INVALID_SIM_SLOT_INDEX;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
@@ -26,9 +27,9 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowSubscriptionManager.SubscriptionInfoBuilder;
-import org.robolectric.shadows.testing.TestActivity;
 
 /** Test for {@link ShadowSubscriptionManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -590,6 +591,40 @@ public class ShadowSubscriptionManagerTest {
         .isTrue();
   }
 
+  @Test
+  @Config(minSdk = O)
+  public void getSlotIndex_nullSubscriptionList_returnsInvalidSlotIndex() {
+    assertThat(SubscriptionManager.getSlotIndex(/* subscriptionId= */ 2))
+        .isEqualTo(INVALID_SIM_SLOT_INDEX);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getSlotIndex_unknownSubscriptionId_returnsInvalidSlotIndex() {
+    new ShadowSubscriptionManager()
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(2)
+                .setSimSlotIndex(0)
+                .buildSubscriptionInfo());
+
+    assertThat(SubscriptionManager.getSlotIndex(/* subscriptionId= */ 3))
+        .isEqualTo(INVALID_SIM_SLOT_INDEX);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getSlotIndex_knownSubscriptionId_returnsMatchingSlotIndex() {
+    new ShadowSubscriptionManager()
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(2)
+                .setSimSlotIndex(1)
+                .buildSubscriptionInfo());
+
+    assertThat(SubscriptionManager.getSlotIndex(/* subscriptionId= */ 2)).isEqualTo(1);
+  }
+
   private static class DummySubscriptionsChangedListener
       extends SubscriptionManager.OnSubscriptionsChangedListener {
     private int subscriptionChangedCount;
@@ -606,13 +641,13 @@ public class ShadowSubscriptionManagerTest {
       subscriptionManager_activityContextEnabled_differentInstancesRetrieveDefaultSubscriptionInfo() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       SubscriptionManager applicationSubscriptionManager =
           (SubscriptionManager)
               RuntimeEnvironment.getApplication()
                   .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       SubscriptionManager activitySubscriptionManager =
           (SubscriptionManager) activity.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
 
@@ -626,9 +661,6 @@ public class ShadowSubscriptionManagerTest {
 
       assertThat(applicationDefaultSubscriptionInfo).isEqualTo(activityDefaultSubscriptionInfo);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
index 79bd67c6b..2a3410353 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
@@ -15,6 +15,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -82,11 +83,11 @@ public final class ShadowSystemHealthManagerTest {
       systemHealthManager_activityContextEnabled_differentInstancesRetrieveSameUidSnapshot() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       SystemHealthManager applicationSystemHealthManager =
           ApplicationProvider.getApplicationContext().getSystemService(SystemHealthManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       SystemHealthManager activitySystemHealthManager =
           activity.getSystemService(SystemHealthManager.class);
 
@@ -97,9 +98,6 @@ public final class ShadowSystemHealthManagerTest {
 
       assertThat(activityHealthStats).isEqualTo(applicationHealthStats);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
index f00e06f56..17ff1b259 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
@@ -41,10 +41,10 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.android.controller.ServiceController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowTelecomManager.CallRequestMode;
-import org.robolectric.shadows.testing.TestActivity;
 import org.robolectric.shadows.testing.TestConnectionService;
 
 @RunWith(AndroidJUnit4.class)
@@ -758,13 +758,13 @@ public class ShadowTelecomManagerTest {
   public void telecomManager_activityContextEnabled_differentInstancesRetrieveDefaultDialer() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       TelecomManager applicationTelecomManager =
           (TelecomManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.TELECOM_SERVICE);
 
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       TelecomManager activityTelecomManager =
           (TelecomManager) activity.getSystemService(Context.TELECOM_SERVICE);
 
@@ -773,9 +773,6 @@ public class ShadowTelecomManagerTest {
 
       assertThat(activityDefaultDialer).isEqualTo(applicationDefaultDialer);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
index cc4cdce9b..ae84b65c5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
@@ -9,6 +9,7 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static android.telephony.PhoneStateListener.LISTEN_CALL_STATE;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_INFO;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_LOCATION;
@@ -87,12 +88,15 @@ import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowSubscriptionManager.SubscriptionInfoBuilder;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
@@ -102,6 +106,7 @@ public class ShadowTelephonyManagerTest {
   private TelephonyManager telephonyManager;
   private ShadowTelephonyManager shadowTelephonyManager;
   private TelephonyManager tmForSub5;
+  private String defaultNetworkCountryIso;
 
   @Before
   public void setUp() throws Exception {
@@ -110,6 +115,12 @@ public class ShadowTelephonyManagerTest {
     shadowOf((Application) ApplicationProvider.getApplicationContext())
         .grantPermissions(permission.READ_PRIVILEGED_PHONE_STATE);
     tmForSub5 = newTelephonyManager(5);
+    defaultNetworkCountryIso = shadowOf(telephonyManager).getNetworkCountryIso();
+  }
+
+  @After
+  public void tearDown() {
+    shadowOf(telephonyManager).setNetworkCountryIso(defaultNetworkCountryIso);
   }
 
   private TelephonyManager newTelephonyManager(Integer subId) {
@@ -353,6 +364,11 @@ public class ShadowTelephonyManagerTest {
     assertEquals("someiso", telephonyManager.getNetworkCountryIso());
   }
 
+  @Test
+  public void shouldGiveEmptyStringForNetworkCountryIsoWhenNotSet() {
+    assertThat(telephonyManager.getNetworkCountryIso()).isEmpty();
+  }
+
   @Test
   @Config(minSdk = Q)
   public void shouldGiveSimLocale() {
@@ -810,6 +826,68 @@ public class ShadowTelephonyManagerTest {
     assertThat(telephonyManager.getSimState()).isEqualTo(TelephonyManager.SIM_STATE_READY);
   }
 
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getSimApplicationState_defaultUnknown() {
+    assertThat(telephonyManager.getSimApplicationState())
+        .isEqualTo(TelephonyManager.SIM_STATE_UNKNOWN);
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getSimApplicationState_simStateAbsent_simApplicationStateUnknown() {
+    ShadowSubscriptionManager.setDefaultSubscriptionId(0);
+    // Don't use slot index 0 to ensure the value is remapped instead of getting default
+    // SIM_STATE_UNKNOWN from an unknown slot index.
+    new ShadowSubscriptionManager()
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(0)
+                .setSimSlotIndex(3)
+                .buildSubscriptionInfo());
+
+    shadowOf(telephonyManager).setSimState(/* slotIndex= */ 3, TelephonyManager.SIM_STATE_ABSENT);
+
+    assertThat(telephonyManager.getSimApplicationState())
+        .isEqualTo(TelephonyManager.SIM_STATE_UNKNOWN);
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getSimApplicationState_simStateReady_returnsSimApplicationStateNotReady() {
+    // TODO: make this the default configuration
+    ShadowSubscriptionManager.setDefaultSubscriptionId(0);
+    new ShadowSubscriptionManager()
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(0)
+                .setSimSlotIndex(0)
+                .buildSubscriptionInfo());
+
+    shadowOf(telephonyManager).setSimState(/* slotIndex= */ 0, TelephonyManager.SIM_STATE_READY);
+
+    assertThat(telephonyManager.getSimApplicationState())
+        .isEqualTo(TelephonyManager.SIM_STATE_NOT_READY);
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getSimApplicationState_simStateLoaded_returnsSimApplicationStateLoaded() {
+    // TODO: make this the default configuration
+    ShadowSubscriptionManager.setDefaultSubscriptionId(0);
+    new ShadowSubscriptionManager()
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(0)
+                .setSimSlotIndex(0)
+                .buildSubscriptionInfo());
+
+    shadowOf(telephonyManager).setSimState(/* slotIndex= */ 0, TelephonyManager.SIM_STATE_LOADED);
+
+    assertThat(telephonyManager.getSimApplicationState())
+        .isEqualTo(TelephonyManager.SIM_STATE_LOADED);
+  }
+
   @Test
   public void shouldGetSimIso() {
     assertThat(telephonyManager.getSimCountryIso()).isEmpty();
@@ -1547,13 +1625,13 @@ public class ShadowTelephonyManagerTest {
   public void telephonyManager_activityContextEnabled_differentInstancesRetrievePhoneCount() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       TelephonyManager applicationTelephonyManager =
           (TelephonyManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.TELEPHONY_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       TelephonyManager activityTelephonyManager =
           (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
 
@@ -1564,9 +1642,6 @@ public class ShadowTelephonyManagerTest {
 
       assertThat(activityPhoneCount).isEqualTo(applicationPhoneCount);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java
index 65990ace7..07f6fbf0f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java
@@ -9,6 +9,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowTextUtilsTest {
@@ -80,6 +81,7 @@ public class ShadowTextUtilsTest {
     assertThat(TextUtils.equals("ab", "a")).isFalse();
   }
 
+  @GraphicsMode(GraphicsMode.Mode.LEGACY)
   @Test
   public void testEllipsize() {
     TextPaint p = new TextPaint();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
index e54d01ad1..2a261076d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
@@ -53,7 +53,6 @@ import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowTextViewTest {
 
   private static final String INITIAL_TEXT = "initial text";
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java
index 57c743e84..f2b8d2aa3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java
@@ -13,6 +13,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowTimeManager} */
@@ -64,11 +65,11 @@ public final class ShadowTimeManagerTest {
   public void timeManager_activityContextEnabled_differentInstancesRetrieveTimeZoneCapabilities() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       TimeManager applicationTimeManager =
           ApplicationProvider.getApplicationContext().getSystemService(TimeManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       TimeManager activityTimeManager = activity.getSystemService(TimeManager.class);
 
       TimeZoneConfiguration timeZoneConfiguration = new TimeZoneConfiguration.Builder().build();
@@ -83,9 +84,6 @@ public final class ShadowTimeManagerTest {
 
       assertThat(activityCapabilities).isEqualTo(applicationCapabilities);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java
index 05046fc2e..b58a1e826 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java
@@ -15,6 +15,7 @@ import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -63,12 +64,12 @@ public class ShadowTranslationManagerTest {
   public void translationManager_activityContextEnabled_differentInstancesRetrieveCapabilities() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       TranslationManager applicationTranslationManager =
           ApplicationProvider.getApplicationContext().getSystemService(TranslationManager.class);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       TranslationManager activityTranslationManager =
           activity.getSystemService(TranslationManager.class);
 
@@ -81,9 +82,6 @@ public class ShadowTranslationManagerTest {
 
       assertThat(activityCapabilities).isEqualTo(applicationCapabilities);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java
index 0eaf7e037..0f5192902 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java
@@ -166,8 +166,6 @@ public class ShadowTypefaceTest {
     FontFamily family = new FontFamily.Builder(font).build();
     // This invokes the Typeface static initializer, which creates some default typefaces.
     Typeface.create("roboto", Typeface.BOLD);
-    // Call the resetter to clear the FONTS map in Typeface
-    ShadowLegacyTypeface.reset();
     Typeface typeface =
         new Typeface.CustomFallbackBuilder(family).setStyle(font.getStyle()).build();
     assertThat(typeface).isNotNull();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
index 11326af57..14ed09a07 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
@@ -4,6 +4,7 @@ import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
@@ -300,6 +301,35 @@ public class ShadowUIModeManagerTest {
         .contains(RuntimeEnvironment.getApplication().getPackageName());
   }
 
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getContrast_whenNotSet_returnsDefaultValueOfZero() {
+    assertThat(uiModeManager.getContrast()).isEqualTo(0.0f);
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void setContrast_whenSet_valueIsReturnedByGetContrast() {
+    float expectedContrast = -0.16f;
+
+    shadowOf(uiModeManager).setContrast(expectedContrast);
+
+    float actualContrast = uiModeManager.getContrast();
+    assertThat(actualContrast).isEqualTo(expectedContrast);
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void setContrast_whenCalledWithValueAboveOne_throws() {
+    assertThrows(IllegalArgumentException.class, () -> shadowOf(uiModeManager).setContrast(1.1f));
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void setContrast_whenCalledWithValueBelowMinusOne_throws() {
+    assertThrows(IllegalArgumentException.class, () -> shadowOf(uiModeManager).setContrast(-1.1f));
+  }
+
   private void setPermissions(String... permissions) {
     PackageInfo pi = new PackageInfo();
     pi.packageName = context.getPackageName();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
index 41be49195..5a7622756 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
@@ -8,7 +8,6 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.HOURS;
 import static org.robolectric.Shadows.shadowOf;
-import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.Activity;
 import android.app.Application;
@@ -16,6 +15,7 @@ import android.app.PendingIntent;
 import android.app.usage.BroadcastResponseStats;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageEvents.Event;
+import android.app.usage.UsageEventsQuery;
 import android.app.usage.UsageStats;
 import android.app.usage.UsageStatsManager;
 import android.content.Context;
@@ -34,15 +34,12 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowUsageStatsManager.AppUsageLimitObserver;
 import org.robolectric.shadows.ShadowUsageStatsManager.AppUsageObserver;
-import org.robolectric.shadows.ShadowUsageStatsManager.EventReflector;
 import org.robolectric.shadows.ShadowUsageStatsManager.UsageSessionObserver;
 import org.robolectric.shadows.ShadowUsageStatsManager.UsageStatsBuilder;
-import org.robolectric.util.reflector.Constructor;
-import org.robolectric.util.reflector.ForType;
-import org.robolectric.util.reflector.WithType;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Test for {@link ShadowUsageStatsManager}. */
@@ -1046,14 +1043,14 @@ public class ShadowUsageStatsManagerTest {
   public void usageStatsManager_activityContextEnabled_differentInstancesRetrieveBuckets() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       UsageStatsManager applicationUsageStatsManager =
           (UsageStatsManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.USAGE_STATS_SERVICE);
 
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       UsageStatsManager activityUsageStatsManager =
           (UsageStatsManager) activity.getSystemService(Context.USAGE_STATS_SERVICE);
 
@@ -1064,9 +1061,6 @@ public class ShadowUsageStatsManagerTest {
 
       assertThat(applicationBucket).isEqualTo(activityBucket);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
@@ -1117,15 +1111,10 @@ public class ShadowUsageStatsManagerTest {
                 .setEventType(Event.SYSTEM_INTERACTION)
                 .build());
 
-    Object queryBuilder =
-        reflector(UsageEventsQueryBuilderReflector.class).newBuilder(1000L, 2000L);
-    UsageEventsQueryBuilderReflector queryBuilderReflector =
-        reflector(UsageEventsQueryBuilderReflector.class, queryBuilder);
-    queryBuilderReflector.setEventTypes(
+    UsageEventsQuery.Builder queryBuilder = new UsageEventsQuery.Builder(1000L, 2000L);
+    queryBuilder.setEventTypes(
         Event.MOVE_TO_BACKGROUND, Event.MOVE_TO_FOREGROUND, Event.USER_INTERACTION);
-    UsageEvents events =
-        reflector(UsageStatsManagerReflector.class, usageStatsManager)
-            .queryEvents(queryBuilderReflector.build());
+    UsageEvents events = usageStatsManager.queryEvents(queryBuilder.build());
 
     Event event = new Event();
 
@@ -1146,26 +1135,9 @@ public class ShadowUsageStatsManagerTest {
     assertThat(event.getPackageName()).isEqualTo(TEST_PACKAGE_NAME2);
     assertThat(event.getTimeStamp()).isEqualTo(1500L);
     assertThat(event.getEventType()).isEqualTo(Event.USER_INTERACTION);
-    EventReflector eventReflector = reflector(EventReflector.class, event);
-    extras = eventReflector.getExtras();
+    extras = event.getExtras();
     assertThat(extras.getString("fakekey")).isEqualTo("fakevalue");
 
     assertThat(events.hasNextEvent()).isFalse();
   }
-
-  // TODO: remove reflection calls once Android V is fully supported.
-  @ForType(UsageStatsManager.class)
-  interface UsageStatsManagerReflector {
-    UsageEvents queryEvents(@WithType("android.app.usage.UsageEventsQuery") Object query);
-  }
-
-  @ForType(className = "android.app.usage.UsageEventsQuery$Builder")
-  interface UsageEventsQueryBuilderReflector {
-    @Constructor
-    Object newBuilder(long beginTimeMillis, long endTimeMillis);
-
-    Object setEventTypes(int... eventTypes);
-
-    Object build();
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java
index 301b3709c..00f30bfd9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java
@@ -14,12 +14,12 @@ import android.hardware.usb.UsbDeviceConnection;
 import android.hardware.usb.UsbEndpoint;
 import android.hardware.usb.UsbInterface;
 import android.hardware.usb.UsbManager;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
index 97668305d..6fc08b390 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
@@ -35,6 +35,7 @@ import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowUsbManager._UsbManagerQ_;
 import org.robolectric.shadows.ShadowUsbManager._UsbManager_;
@@ -252,11 +253,11 @@ public class ShadowUsbManagerTest {
   public void usbManager_activityContextEnabled_differentInstancesRetrieveSameUsbDevices() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       UsbManager applicationUsbManager =
           ApplicationProvider.getApplicationContext().getSystemService(UsbManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       UsbManager activityUsbManager = activity.getSystemService(UsbManager.class);
 
       assertThat(applicationUsbManager).isNotSameInstanceAs(activityUsbManager);
@@ -266,9 +267,6 @@ public class ShadowUsbManagerTest {
 
       assertThat(activityDevices).isEqualTo(applicationDevices);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
index ab2e4c220..48ceba327 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
@@ -15,10 +15,10 @@ import android.hardware.usb.UsbEndpoint;
 import android.hardware.usb.UsbInterface;
 import android.hardware.usb.UsbManager;
 import android.hardware.usb.UsbRequest;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.nio.ByteBuffer;
+import javax.annotation.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
index 2acbdbae0..22600b67f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
@@ -39,6 +39,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowUserManager.UserState;
@@ -1187,12 +1188,12 @@ public class ShadowUserManagerTest {
   public void userManager_activityContextEnabled_consistentAcrossContexts() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       UserManager applicationUserManager =
           (UserManager)
               ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       UserManager activityUserManager =
           (UserManager) activity.getSystemService(Context.USER_SERVICE);
 
@@ -1203,9 +1204,6 @@ public class ShadowUserManagerTest {
 
       assertThat(isAdminActivity).isEqualTo(isAdminApplication);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
index b4488aa00..8d79dde0a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
@@ -27,9 +27,9 @@ import org.mockito.ArgumentMatcher;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.shadows.testing.TestActivity;
 
 /** Unit tests for {@link ShadowUwbManager}. */
 @RunWith(RobolectricTestRunner.class)
@@ -226,11 +226,11 @@ public class ShadowUwbManagerTest {
   public void uwbManager_activityContextEnabled_differentInstancesRetrieveSpecificationInfo() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       UwbManager applicationUwbManager =
           RuntimeEnvironment.getApplication().getSystemService(UwbManager.class);
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       UwbManager activityUwbManager = activity.getSystemService(UwbManager.class);
 
       assertThat(applicationUwbManager).isNotSameInstanceAs(activityUwbManager);
@@ -240,9 +240,6 @@ public class ShadowUwbManagerTest {
 
       assertThat(activitySpecificationInfo).isEqualTo(applicationSpecificationInfo);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java
index 6f9b86b9e..cd9ac07d5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java
@@ -23,6 +23,7 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Test for {@link ShadowVcnManager}. */
@@ -97,11 +98,11 @@ public final class ShadowVcnManagerTest {
   public void vcnManager_activityContextEnabled_differentInstancesRetrieveSubscriptionGroups() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       VcnManager applicationVcnManager =
           ApplicationProvider.getApplicationContext().getSystemService(VcnManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       VcnManager activityVcnManager = activity.getSystemService(VcnManager.class);
 
       assertThat(applicationVcnManager).isNotSameInstanceAs(activityVcnManager);
@@ -116,9 +117,6 @@ public final class ShadowVcnManagerTest {
       assertThat(activityConfiguredSubscriptionGroups)
           .isEqualTo(applicationConfiguredSubscriptionGroups);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
index de8411d5d..a0654813c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
@@ -24,11 +24,11 @@ import android.view.animation.Animation.AnimationListener;
 import android.view.animation.LayoutAnimationController;
 import android.widget.FrameLayout;
 import android.widget.TextView;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
+import javax.annotation.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -41,7 +41,6 @@ import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowViewGroupTest {
   private String defaultLineSeparator;
   private ViewGroup root;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
index 5104e9a9e..780b3cd4b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
@@ -25,7 +25,6 @@ import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.os.Looper;
-import android.os.SystemClock;
 import android.util.AttributeSet;
 import android.view.ContextMenu;
 import android.view.HapticFeedbackConstants;
@@ -67,7 +66,6 @@ import org.robolectric.util.TestRunnable;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowViewTest {
   private View view;
   private List<String> transcript;
@@ -536,7 +534,7 @@ public class ShadowViewTest {
 
     verifyNoMoreInteractions(listener);
 
-    SystemClock.setCurrentTimeMillis(1000);
+    ShadowSystemClock.advanceBy(Duration.ofMillis(1000));
     shadowMainLooper().idle();
 
     verify(listener).onAnimationStart(animation);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java
index bfbc202fe..dadc98aac 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java
@@ -53,10 +53,10 @@ import org.mockito.junit.MockitoRule;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowVirtualDeviceManager.ShadowVirtualDevice;
-import org.robolectric.shadows.testing.TestActivity;
 
 /** Unit test for ShadowVirtualDeviceManager and ShadowVirtualDevice. */
 @Config(minSdk = UPSIDE_DOWN_CAKE)
@@ -365,12 +365,12 @@ public class ShadowVirtualDeviceManagerTest {
   public void virtualDeviceManager_activityContextEnabled_retrievesSameVirtualDevices() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       VirtualDeviceManager applicationVirtualDeviceManager =
           (VirtualDeviceManager)
               RuntimeEnvironment.getApplication().getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
-      activity = Robolectric.setupActivity(TestActivity.class);
+      Activity activity = controller.get();
       VirtualDeviceManager activityVirtualDeviceManager =
           (VirtualDeviceManager) activity.getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
 
@@ -383,9 +383,6 @@ public class ShadowVirtualDeviceManagerTest {
       assertThat(activityVirtualDevices).isNotNull();
       assertThat(activityVirtualDevices).isEqualTo(applicationVirtualDevices);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
index 731827b62..2468a2a49 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
@@ -15,6 +15,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -100,11 +101,11 @@ public class ShadowVpnManagerTest {
   public void vpnManager_activityContextEnabled_differentInstancesInteract() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       VpnManager applicationVpnManager =
           RuntimeEnvironment.getApplication().getSystemService(VpnManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       VpnManager activityVpnManager = activity.getSystemService(VpnManager.class);
 
       assertThat(applicationVpnManager).isNotSameInstanceAs(activityVpnManager);
@@ -115,9 +116,6 @@ public class ShadowVpnManagerTest {
 
       assertThat(activityProfileState).isEqualTo(applicationProfileState);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
index 97bebbbfe..77a83444d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
@@ -15,6 +15,7 @@ import android.app.WallpaperManager;
 import android.content.ComponentName;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.graphics.Rect;
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.IBinder;
@@ -33,6 +34,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.annotation.GraphicsMode.Mode;
@@ -40,7 +42,6 @@ import org.robolectric.shadows.ShadowWallpaperManager.WallpaperCommandRecord;
 
 @RunWith(AndroidJUnit4.class)
 @GraphicsMode(Mode.LEGACY)
-
 public class ShadowWallpaperManagerTest {
 
   private static final Bitmap TEST_IMAGE_1 = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
@@ -49,6 +50,10 @@ public class ShadowWallpaperManagerTest {
 
   private static final Bitmap TEST_IMAGE_3 = Bitmap.createBitmap(1, 5, Bitmap.Config.ARGB_8888);
 
+  private static final Rect TEST_VISIBLE_CROP_HINT_1 = new Rect(1, 2, 3, 4);
+
+  private static final Rect TEST_VISIBLE_CROP_HINT_2 = new Rect(5, 6, 7, 8);
+
   private static final int UNSUPPORTED_FLAG = 0x100; // neither FLAG_SYSTEM nor FLAG_LOCK
 
   private static final String SET_WALLPAPER_COMPONENT =
@@ -282,6 +287,58 @@ public class ShadowWallpaperManagerTest {
     assertThat(manager.getWallpaperInfo().getComponent()).isEqualTo(TEST_WALLPAPER_SERVICE);
   }
 
+  @Test
+  @Config(minSdk = N)
+  public void setBitmap_flagLock_shouldCacheVisibleCropHintInMemory() throws Exception {
+    int returnCode =
+        manager.setBitmap(
+            TEST_IMAGE_2,
+            /* visibleCropHint= */ TEST_VISIBLE_CROP_HINT_1,
+            /* allowBackup= */ false,
+            WallpaperManager.FLAG_LOCK);
+
+    assertThat(returnCode).isEqualTo(1);
+    assertThat(shadowOf(manager).getVisibleCropHint(WallpaperManager.FLAG_LOCK))
+        .isEqualTo(TEST_VISIBLE_CROP_HINT_1);
+    assertThat(shadowOf(manager).getVisibleCropHint(WallpaperManager.FLAG_SYSTEM)).isNull();
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void setBitmap_flagSystem_shouldCacheVisibleCropHintInMemory() throws Exception {
+    int returnCode =
+        manager.setBitmap(
+            TEST_IMAGE_2,
+            /* visibleCropHint= */ TEST_VISIBLE_CROP_HINT_2,
+            /* allowBackup= */ false,
+            WallpaperManager.FLAG_SYSTEM);
+
+    assertThat(returnCode).isEqualTo(1);
+    assertThat(shadowOf(manager).getVisibleCropHint(WallpaperManager.FLAG_SYSTEM))
+        .isEqualTo(TEST_VISIBLE_CROP_HINT_2);
+    assertThat(shadowOf(manager).getVisibleCropHint(WallpaperManager.FLAG_LOCK)).isNull();
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void setBitmap_multipleCallsWithFlagLock_shouldCacheLastVisibleCropHintInMemory()
+      throws Exception {
+    manager.setBitmap(
+        TEST_IMAGE_1,
+        /* visibleCropHint= */ TEST_VISIBLE_CROP_HINT_1,
+        /* allowBackup= */ false,
+        WallpaperManager.FLAG_LOCK);
+    manager.setBitmap(
+        TEST_IMAGE_2,
+        /* visibleCropHint= */ TEST_VISIBLE_CROP_HINT_2,
+        /* allowBackup= */ false,
+        WallpaperManager.FLAG_LOCK);
+
+    assertThat(shadowOf(manager).getVisibleCropHint(WallpaperManager.FLAG_LOCK))
+        .isEqualTo(TEST_VISIBLE_CROP_HINT_2);
+    assertThat(shadowOf(manager).getVisibleCropHint(WallpaperManager.FLAG_SYSTEM)).isNull();
+  }
+
   @Test
   @Config(minSdk = N)
   public void getWallpaperFile_flagSystem_nothingCached_shouldReturnNull() throws Exception {
@@ -334,6 +391,50 @@ public class ShadowWallpaperManagerTest {
     assertThat(manager.getWallpaperFile(UNSUPPORTED_FLAG)).isNull();
   }
 
+  @Test
+  @Config(minSdk = N)
+  public void getWallpaperId_lockScreenBitmapNotConfigured_shouldReturnNegativeNumber()
+      throws Exception {
+    manager.setBitmap(
+        TEST_IMAGE_1, null, false, WallpaperManager.FLAG_SYSTEM | WallpaperManager.FLAG_LOCK);
+
+    assertThat(manager.getWallpaperId(WallpaperManager.FLAG_LOCK)).isEqualTo(-1);
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void getWallpaperId_setHomeScreenAndLockScreenBimap_shouldReturnIncreasingId()
+      throws Exception {
+    manager.setBitmap(TEST_IMAGE_1, null, false, WallpaperManager.FLAG_SYSTEM);
+    manager.setBitmap(TEST_IMAGE_2, null, false, WallpaperManager.FLAG_LOCK);
+
+    assertThat(manager.getWallpaperId(WallpaperManager.FLAG_SYSTEM)).isEqualTo(1);
+    assertThat(manager.getWallpaperId(WallpaperManager.FLAG_LOCK)).isEqualTo(2);
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void getWallpaperId_lockScreenResourceNotConfigured_shouldReturnNegativeNumber()
+      throws Exception {
+    int resourceId = 12345;
+    manager.setResource(resourceId, WallpaperManager.FLAG_SYSTEM | WallpaperManager.FLAG_LOCK);
+
+    assertThat(manager.getWallpaperId(WallpaperManager.FLAG_LOCK)).isEqualTo(-1);
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void getWallpaperId_setHomeScreenAndLockScreenResource_shouldReturnIncreasingId()
+      throws Exception {
+    int resourceId1 = 5;
+    int resourceId2 = 6;
+    manager.setResource(resourceId1, WallpaperManager.FLAG_SYSTEM);
+    manager.setResource(resourceId2, WallpaperManager.FLAG_LOCK);
+
+    assertThat(manager.getWallpaperId(WallpaperManager.FLAG_SYSTEM)).isEqualTo(1);
+    assertThat(manager.getWallpaperId(WallpaperManager.FLAG_LOCK)).isEqualTo(2);
+  }
+
   @Test
   @Config(minSdk = N)
   public void isSetWallpaperAllowed_allowed_shouldReturnTrue() {
@@ -591,9 +692,9 @@ public class ShadowWallpaperManagerTest {
   public void wallpaperManager_activityContextEnabled_retrievesSameWallpaper() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
-      activity = Robolectric.setupActivity(Activity.class);
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
+      Activity activity = controller.get();
       WallpaperManager applicationWallpaperManager =
           (WallpaperManager) application.getSystemService(Context.WALLPAPER_SERVICE);
       WallpaperManager activityWallpaperManager =
@@ -607,9 +708,6 @@ public class ShadowWallpaperManagerTest {
 
       assertThat(activityWallpaper).isEqualTo(applicationWallpaper);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
index 628a1e7de..c50cda771 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.times;
@@ -24,11 +23,14 @@ import org.mockito.junit.MockitoRule;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Unit test for ShadowWearableSensingManager. */
-@Config(minSdk = UPSIDE_DOWN_CAKE)
+@Config(minSdk = U.SDK_INT)
 @RunWith(RobolectricTestRunner.class)
 public class ShadowWearableSensingManagerTest {
 
@@ -85,6 +87,31 @@ public class ShadowWearableSensingManagerTest {
         .containsExactly(sharedMemory1, sharedMemory2);
   }
 
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void startHotwordRecognition() throws Exception {
+    WearableSensingManager wearableSensingManager =
+        (WearableSensingManager)
+            getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
+
+    wearableSensingManager.startHotwordRecognition(null, MoreExecutors.directExecutor(), callback);
+
+    verify(callback).accept(WearableSensingManager.STATUS_SUCCESS);
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void stopHotwordRecognition() throws Exception {
+    WearableSensingManager wearableSensingManager =
+        (WearableSensingManager)
+            getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
+    wearableSensingManager.startHotwordRecognition(null, MoreExecutors.directExecutor(), callback);
+
+    wearableSensingManager.stopHotwordRecognition(MoreExecutors.directExecutor(), callback);
+
+    verify(callback, times(2)).accept(WearableSensingManager.STATUS_SUCCESS);
+  }
+
   @Test
   public void getLastDataBundle_noDataProvided_doesNotThrow() throws Exception {
     WearableSensingManager wearableSensingManager =
@@ -107,15 +134,47 @@ public class ShadowWearableSensingManagerTest {
     shadowWearableSensingManager.getLastSharedMemory();
   }
 
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void setStartHotwordRecognitionResult() throws Exception {
+    WearableSensingManager wearableSensingManager =
+        (WearableSensingManager)
+            getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
+    ShadowWearableSensingManager shadowWearableSensingManager =
+        Shadow.extract(wearableSensingManager);
+    shadowWearableSensingManager.setStartHotwordRecognitionResult(
+        WearableSensingManager.STATUS_ACCESS_DENIED);
+
+    wearableSensingManager.startHotwordRecognition(null, MoreExecutors.directExecutor(), callback);
+
+    verify(callback).accept(WearableSensingManager.STATUS_ACCESS_DENIED);
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void setStopHotwordRecognitionResult() throws Exception {
+    WearableSensingManager wearableSensingManager =
+        (WearableSensingManager)
+            getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
+    ShadowWearableSensingManager shadowWearableSensingManager =
+        Shadow.extract(wearableSensingManager);
+    shadowWearableSensingManager.setStopHotwordRecognitionResult(
+        WearableSensingManager.STATUS_ACCESS_DENIED);
+
+    wearableSensingManager.stopHotwordRecognition(MoreExecutors.directExecutor(), callback);
+
+    verify(callback).accept(WearableSensingManager.STATUS_ACCESS_DENIED);
+  }
+
   @Test
   public void wearableSensingManager_activityContextEnabled_differentInstancesProvideDataStream() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       WearableSensingManager applicationWearableSensingManager =
           RuntimeEnvironment.getApplication().getSystemService(WearableSensingManager.class);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       WearableSensingManager activityWearableSensingManager =
           activity.getSystemService(WearableSensingManager.class);
 
@@ -139,11 +198,7 @@ public class ShadowWearableSensingManagerTest {
           activityPfd, executor, activityStatusConsumer);
 
       assertThat(activityStatus[0]).isEqualTo(applicationStatus[0]);
-
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWebSettingsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWebSettingsTest.java
index aeda81d2b..bd57d7398 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWebSettingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWebSettingsTest.java
@@ -27,4 +27,11 @@ public final class ShadowWebSettingsTest {
 
     assertThat(WebSettings.getDefaultUserAgent(context)).isEqualTo("Chrome/71.0.143.1");
   }
+
+  @Test
+  public void setDefaultUserAgent_nullArgument() {
+    ShadowWebSettings.setDefaultUserAgent(null);
+
+    assertThat(WebSettings.getDefaultUserAgent(context)).isNotEmpty();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
index 8e07b6e98..bcd29984e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
@@ -25,6 +25,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 /** Test for {@link ShadowWifiAwareManager} */
@@ -201,13 +202,13 @@ public final class ShadowWifiAwareManagerTest {
   public void wifiAwareManager_activityContextEnabled_differentInstancesIsAvailable() {
     String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
     System.setProperty("robolectric.createActivityContexts", "true");
-    Activity activity = null;
-    try {
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
       WifiAwareManager applicationWifiAwareManager =
           (WifiAwareManager)
               ApplicationProvider.getApplicationContext()
                   .getSystemService(Context.WIFI_AWARE_SERVICE);
-      activity = Robolectric.setupActivity(Activity.class);
+      Activity activity = controller.get();
       WifiAwareManager activityWifiAwareManager =
           (WifiAwareManager) activity.getSystemService(Context.WIFI_AWARE_SERVICE);
 
@@ -218,9 +219,6 @@ public final class ShadowWifiAwareManagerTest {
 
       assertThat(activityIsAvailable).isEqualTo(applicationIsAvailable);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
index 88743c1f7..a5314d724 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
@@ -14,6 +13,7 @@ import android.os.Build;
 import android.os.Looper;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import org.junit.Before;
@@ -22,8 +22,8 @@ import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.Robolectric;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowWifiP2pManagerTest {
@@ -191,9 +191,9 @@ public class ShadowWifiP2pManagerTest {
           latch.countDown();
         });
 
-    Activity activity = null;
-    try {
-      activity = Robolectric.setupActivity(TestActivity.class);
+    try (ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class).setup()) {
+      Activity activity = controller.get();
       WifiP2pManager activityWifiP2pManager =
           (WifiP2pManager) activity.getSystemService(Context.WIFI_P2P_SERVICE);
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
@@ -203,7 +203,8 @@ public class ShadowWifiP2pManagerTest {
       }
 
       WifiP2pManager.Channel activityChannel =
-          activityWifiP2pManager.initialize(activity, activity.getMainLooper(), null);
+          Objects.requireNonNull(activityWifiP2pManager)
+              .initialize(activity, activity.getMainLooper(), null);
 
       activityWifiP2pManager.requestGroupInfo(
           activityChannel,
@@ -218,11 +219,8 @@ public class ShadowWifiP2pManagerTest {
 
       assertThat(applicationGroupNameHolder[0]).isEqualTo(activityGroupNameHolder[0]);
     } catch (InterruptedException e) {
-      fail("Failed because of latch interrupt");
+      throw new AssertionError("Failed because of latch interrupt", e);
     } finally {
-      if (activity != null) {
-        activity.finish();
-      }
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
index 1409453fe..97d7a8a4b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
@@ -31,14 +31,14 @@ import android.view.WindowManager;
 import android.window.BackEvent;
 import android.window.OnBackAnimationCallback;
 import android.window.OnBackInvokedDispatcher;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -268,12 +268,12 @@ public class ShadowWindowManagerGlobalTest {
     public boolean onBackCancelledCalled = false;
 
     @Override
-    public void onBackStarted(@NonNull BackEvent backEvent) {
+    public void onBackStarted(@Nonnull BackEvent backEvent) {
       onBackStarted = backEvent;
     }
 
     @Override
-    public void onBackProgressed(@NonNull BackEvent backEvent) {
+    public void onBackProgressed(@Nonnull BackEvent backEvent) {
       onBackProgressed.add(backEvent);
     }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java
index da614ac41..c394f5d6d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java
@@ -115,4 +115,16 @@ public class StreamConfigurationMapBuilderTest {
     assertThat(Arrays.asList(map.getInputSizes(PixelFormat.RGBA_8888)))
         .containsExactly(size1, size2);
   }
+
+  @Test
+  public void testGetOutputMinFrameDuration() {
+    Size size = new Size(1920, 1080);
+    StreamConfigurationMap map =
+        StreamConfigurationMapBuilder.newBuilder()
+            .addOutputSize(PixelFormat.RGBA_8888, size)
+            .build();
+    long duration = map.getOutputMinFrameDuration(PixelFormat.RGBA_8888, size);
+
+    assertThat(duration).isEqualTo(0);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java b/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
index 8a98071dd..60ea9b409 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
@@ -20,7 +20,6 @@ import org.robolectric.Robolectric;
 import org.robolectric.annotation.ResourcesMode;
 
 @RunWith(AndroidJUnit4.class)
-
 public class ViewStubTest {
   private Context ctxt;
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/WifiScanResultBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/WifiScanResultBuilderTest.java
new file mode 100644
index 000000000..389deb717
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/WifiScanResultBuilderTest.java
@@ -0,0 +1,214 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiSsid;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.time.Duration;
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+@RunWith(AndroidJUnit4.class)
+public final class WifiScanResultBuilderTest {
+  @Test
+  @Config(maxSdk = VERSION_CODES.S_V2)
+  public void setSsid_withQuotedUtf8String_setsQuotedSsidField() {
+    ScanResult scanResult = new WifiScanResultBuilder().setSsid("\"My Network\"").build();
+
+    assertThat(scanResult.SSID).isEqualTo("\"My Network\"");
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  public void setSsid_withQuotedUtf8String_tiramisuPlus_setsUnquotedSsidField() {
+    ScanResult scanResult = new WifiScanResultBuilder().setSsid("\"My Network\"").build();
+
+    // https://cs.android.com/android/_/android/platform/packages/modules/Wifi/+/767deb99f14455262d364da2291cd93cc70db2a1
+    // The behavior of the deprecated SSID field was changed such that it does not assign the
+    // quoted UTF-8 string.
+    assertThat(scanResult.SSID).isEqualTo("My Network");
+  }
+
+  @Test
+  @Config(maxSdk = VERSION_CODES.S_V2)
+  public void setSsid_withUnquotedHexString_setsSsidField() {
+    ScanResult scanResult = new WifiScanResultBuilder().setSsid("0abcdef1").build();
+
+    assertThat(scanResult.SSID).isEqualTo("0abcdef1");
+  }
+
+  @Test
+  @Config(maxSdk = VERSION_CODES.S_V2)
+  public void setSsid_toNull_setsNullSsidField() {
+    ScanResult scanResult = new WifiScanResultBuilder().setSsid(null).build();
+
+    assertThat(scanResult.SSID).isNull();
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  public void setSsid_toNull_tiramisuPlus_setsUnknownSsidField() {
+    ScanResult scanResult = new WifiScanResultBuilder().setSsid(null).build();
+
+    assertThat(scanResult.SSID).isEqualTo("<unknown ssid>");
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  public void setWifiSsid_withQuotedUtf8String_setsBothSsidFields() {
+    WifiSsid wifiSsid = WifiSsid.fromString("\"My Network\"");
+    ScanResult scanResult = new WifiScanResultBuilder().setWifiSsid(wifiSsid).build();
+
+    assertThat(scanResult.SSID).isEqualTo("My Network");
+    assertThat(scanResult.getWifiSsid()).isEqualTo(wifiSsid);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  public void setWifiSsid_withUnquotedHexString_setsWifiSsidFields() {
+    WifiSsid wifiSsid = WifiSsid.fromString("0abcdef1");
+
+    ScanResult scanResult = new WifiScanResultBuilder().setWifiSsid(wifiSsid).build();
+
+    // https://cs.android.com/android/_/android/platform/packages/modules/Wifi/+/767deb99f14455262d364da2291cd93cc70db2a1
+    // The behavior of the deprecated SSID field was changed such that it only assigns the SSID
+    // field for UTF-8.
+    assertThat(scanResult.SSID).isEqualTo("<unknown ssid>");
+    assertThat(scanResult.getWifiSsid()).isEqualTo(wifiSsid);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.LOLLIPOP)
+  public void setCapabilities_setsCapabilitiesField() {
+    String capabilities = "wpa2";
+    ScanResult scanResult = new WifiScanResultBuilder().setCapabilities(capabilities).build();
+
+    assertThat(scanResult.capabilities).isEqualTo(capabilities);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.LOLLIPOP)
+  public void setBssid_setsBssidField() {
+    String bssid = "01:AB:CD:EF:12";
+    ScanResult scanResult = new WifiScanResultBuilder().setBssid(bssid).build();
+
+    assertThat(scanResult.BSSID).isEqualTo(bssid);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.LOLLIPOP)
+  public void setRssi_setsLevelField() {
+    int rssi = -80;
+    ScanResult scanResult = new WifiScanResultBuilder().setRssi(rssi).build();
+
+    assertThat(scanResult.level).isEqualTo(rssi);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.LOLLIPOP)
+  public void setFrequency_setsFrequencyField() {
+    int frequency = 2412;
+    ScanResult scanResult = new WifiScanResultBuilder().setFrequency(frequency).build();
+
+    assertThat(scanResult.frequency).isEqualTo(frequency);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.LOLLIPOP)
+  public void setTimestamp_setsTimestampField() {
+    int durationMicros = 500000000;
+    Duration timeSinceSeen = Duration.ofSeconds(TimeUnit.MICROSECONDS.toSeconds(durationMicros));
+    ScanResult scanResult = new WifiScanResultBuilder().setTimeSinceSeen(timeSinceSeen).build();
+
+    assertThat(scanResult.timestamp).isEqualTo(durationMicros);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void setChannelWidth_setsChannelWidthField() {
+    ScanResult scanResult =
+        new WifiScanResultBuilder().setChannelWidth(ScanResult.CHANNEL_WIDTH_80MHZ).build();
+
+    assertThat(scanResult.channelWidth).isEqualTo(ScanResult.CHANNEL_WIDTH_80MHZ);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void setCenterFreq0_setsCenterFreq0Field() {
+    int centerFreq0 = 2412;
+    ScanResult scanResult = new WifiScanResultBuilder().setCenterFreq0(centerFreq0).build();
+
+    assertThat(scanResult.centerFreq0).isEqualTo(centerFreq0);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void setCenterFreq1_setsCenterFreq1Field() {
+    int centerFreq1 = 2412;
+    ScanResult scanResult = new WifiScanResultBuilder().setCenterFreq1(centerFreq1).build();
+
+    assertThat(scanResult.centerFreq1).isEqualTo(centerFreq1);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void setIs80211McRttResponder_returnsCorrectValue() {
+    ScanResult scanResult = new WifiScanResultBuilder().setIs80211McRttResponder(true).build();
+
+    assertThat(scanResult.is80211mcResponder()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.VANILLA_ICE_CREAM)
+  public void setIs80211azNtbRttResponder_returnsCorrectValue() {
+    ScanResult scanResult = new WifiScanResultBuilder().setIs80211azNtbRttResponder(true).build();
+
+    assertThat(scanResult.is80211azNtbResponder()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.VANILLA_ICE_CREAM)
+  public void setIsTwtResponder_returnsCorrectValue() {
+    ScanResult scanResult = new WifiScanResultBuilder().setIsTwtResponder(true).build();
+
+    assertThat(scanResult.isTwtResponder()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.LOLLIPOP)
+  public void buildFromEmpty_checkCommonDefaultValues() {
+    ScanResult scanResult = new WifiScanResultBuilder().build();
+
+    // In API 33, the constructor with WifiSsid treats a missing SSID with a
+    // special <unknown ssid> string rather than null.
+    if (VERSION.SDK_INT >= VERSION_CODES.TIRAMISU) {
+      assertThat(scanResult.SSID).isEqualTo("<unknown ssid>");
+    } else {
+      assertThat(scanResult.SSID).isNull();
+    }
+
+    assertThat(scanResult.BSSID).isNull();
+    assertThat(scanResult.capabilities).isNull();
+    assertThat(scanResult.level).isEqualTo(-1);
+    assertThat(scanResult.frequency).isEqualTo(-1);
+    assertThat(scanResult.timestamp).isEqualTo(0);
+
+    if (VERSION.SDK_INT >= VERSION_CODES.VANILLA_ICE_CREAM) {
+      // In API 35, ScanResult.Builder defaults to CHANNEL_WIDTH_20MHZ, while the previous
+      // constructors default to UNSPECIFIED (-1).
+      assertThat(scanResult.channelWidth).isEqualTo(ScanResult.CHANNEL_WIDTH_20MHZ);
+    } else if (VERSION.SDK_INT >= VERSION_CODES.M) {
+      assertThat(scanResult.channelWidth).isEqualTo(0);
+    }
+
+    if (VERSION.SDK_INT >= VERSION_CODES.M) {
+      assertThat(scanResult.centerFreq0).isEqualTo(-1);
+      assertThat(scanResult.centerFreq1).isEqualTo(-1);
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java b/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
index 76cdfeb97..861d4e7e9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
@@ -20,7 +20,6 @@ import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
 @RunWith(AndroidJUnit4.class)
-
 public class XmlPullParserTest {
 
   // emulator output:
diff --git a/sandbox/Android.bp b/sandbox/Android.bp
index 357af66f6..07bcfc33d 100644
--- a/sandbox/Android.bp
+++ b/sandbox/Android.bp
@@ -12,13 +12,13 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_sandbox_upstream",
+    name: "Robolectric_sandbox",
     srcs: ["src/main/java/**/*.java"],
     libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_utils_reflector_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_utils_reflector",
+        "Robolectric_utils",
         "asm-commons-9.6",
         "guava",
         "asm-tree-9.6",
@@ -41,16 +41,16 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_sandbox_tests_upstream",
+    name: "Robolectric_sandbox_tests",
     srcs: ["src/test/java/**/*.java"],
     static_libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_utils_reflector_upstream",
-        "Robolectric_utils_upstream",
-        "Robolectric_junit_upstream",
-        "mockito",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_sandbox",
+        "Robolectric_utils_reflector",
+        "Robolectric_utils",
+        "Robolectric_junit",
+        "mockito-robolectric-prebuilt",
         "hamcrest",
         "asm-commons-9.6",
         "guava",
diff --git a/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java b/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
index 4d1ea859b..f561fc587 100644
--- a/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
+++ b/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
@@ -74,17 +74,16 @@ public class AndroidConfigurer {
         // Needed for android.net.Uri in older SDK versions
         .addClassNameTranslation("java.nio.charset.Charsets", StandardCharsets.class.getName())
         .addClassNameTranslation("java.lang.UnsafeByteSequence", Object.class.getName())
-        .addClassNameTranslation("java.util.jar.StrictJarFile", Object.class.getName());
-
-    builder.addClassNameTranslation("sun.misc.Cleaner", "java.lang.ref.Cleaner$Cleanable");
+        .addClassNameTranslation("java.util.jar.StrictJarFile", Object.class.getName())
+        .addClassNameTranslation("sun.misc.Cleaner", "java.lang.ref.Cleaner$Cleanable");
 
     // Don't acquire legacy support packages.
     builder
         .doNotInstrumentPackage("android.support.constraint.")
-        .doNotInstrumentPackage("android.support.v7.view.");
-
-    // Instrumenting these classes causes a weird failure.
-    builder.doNotInstrumentClass("android.R").doNotInstrumentClass("android.R$styleable");
+        .doNotInstrumentPackage("android.support.v7.view.")
+        .doNotInstrumentPackage("android.arch")
+        .doNotInstrumentPackage("android.support.test")
+        .doNotInstrumentPackage("android.R"); // android.R* are pure data classes.
 
     // Instrumenting this Exceptions causes "java.lang.NegativeArraySizeException: -2" and
     // leads to java.lang.NoClassDefFoundError.
@@ -95,12 +94,9 @@ public class AndroidConfigurer {
         .addInstrumentedPackage("libcore.")
         .addInstrumentedPackage("android.")
         .addInstrumentedPackage("com.android.internal.")
-        .addInstrumentedPackage("org.apache.http.")
-        .addInstrumentedPackage("org.ccil.cowan.tagsoup")
-        .addInstrumentedPackage("org.kxml2.");
-
-    builder.doNotInstrumentPackage("android.arch");
-    builder.doNotInstrumentPackage("android.support.test");
+        .addInstrumentedPackage("org.apache.http.") // For httpclient shadows.
+        .addInstrumentedPackage("org.ccil.cowan.tagsoup.") // For the System.arraycopy interceptor.
+        .addInstrumentedPackage("org.kxml2."); // For the System.arraycopy interceptor.
 
     // Mockito's MockMethodDispatcher must only exist in the Bootstrap class loader.
     builder.doNotAcquireClass(
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
index b1f8bdb28..59597001f 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
@@ -33,16 +33,17 @@ public class InstrumentationConfiguration {
 
   static final ImmutableSet<String> PACKAGES_TO_NEVER_ACQUIRE =
       ImmutableSet.of(
-          "com.sun",
-          "java",
-          "javax",
-          "jdk.internal",
-          "org.junit",
+          "com.sun.",
+          "java.",
+          "javax.",
+          "jdk.internal.",
+          "org.junit.",
           "org.robolectric.annotation.",
           "org.robolectric.internal.",
           "org.robolectric.pluginapi.",
+          "org.robolectric.simulator.pluginapi.",
           "org.robolectric.util.",
-          "sun");
+          "sun.");
 
   // Must always acquire these as they change from API level to API level
   static final ImmutableSet<String> RESOURCES_TO_ALWAYS_ACQUIRE =
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java
index e3835ea8b..9b67cf2a7 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java
@@ -1,7 +1,6 @@
 package org.robolectric.internal.bytecode;
 
 import org.objectweb.asm.Type;
-import org.robolectric.util.Join;
 
 public class MethodSignature {
   public final String className;
@@ -34,7 +33,7 @@ public class MethodSignature {
 
   @Override
   public String toString() {
-    return className + "." + methodName + "(" + Join.join(", ", (Object[]) paramTypes) + ")";
+    return className + "." + methodName + "(" + String.join(", ", paramTypes) + ")";
   }
 
   boolean matches(String className, String methodName) {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java
deleted file mode 100644
index 5b09aaaa2..000000000
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java
+++ /dev/null
@@ -1,223 +0,0 @@
-package org.robolectric.internal.bytecode;
-
-import static org.objectweb.asm.Opcodes.ACC_FINAL;
-import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static org.objectweb.asm.Opcodes.ACC_SUPER;
-import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
-import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
-import static org.objectweb.asm.Opcodes.V1_7;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.lang.invoke.MethodHandles;
-import java.lang.reflect.Array;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.Type;
-import org.objectweb.asm.commons.GeneratorAdapter;
-import org.objectweb.asm.commons.Method;
-import org.robolectric.util.PerfStatsCollector;
-import sun.misc.Unsafe;
-
-/**
- * Defines proxy classes that can invoke methods names transformed with a {@link MethodMapper}. It
- * is primarily used to invoke the original $$robo$$-prefixed methods, but it can technically
- * support arbitrary naming schemes.
- *
- * @deprecated This is incompatible with JDK17+. Use a {@link
- *     org.robolectric.util.reflector.Reflector} interface with {@link
- *     org.robolectric.util.reflector.Direct}.
- */
-@Deprecated
-public class ProxyMaker {
-  private static final String TARGET_FIELD = "__proxy__";
-  private static final Class UNSAFE_CLASS = Unsafe.class;
-  private static final Class LOOKUP_CLASS = MethodHandles.Lookup.class;
-  private static final Unsafe UNSAFE;
-  private static final java.lang.reflect.Method DEFINE_ANONYMOUS_CLASS;
-
-  private static final MethodHandles.Lookup LOOKUP;
-  private static final java.lang.reflect.Method HIDDEN_DEFINE_METHOD;
-  private static final Object HIDDEN_CLASS_OPTIONS;
-
-  private static final boolean DEBUG = false;
-
-  static {
-    try {
-      Field unsafeField = UNSAFE_CLASS.getDeclaredField("theUnsafe");
-      unsafeField.setAccessible(true);
-      UNSAFE = (Unsafe) unsafeField.get(null);
-
-      // Unsafe.defineAnonymousClass() has been deprecated in Java 15 and removed in Java 17. Its
-      // usage should be replace by MethodHandles.Lookup.defineHiddenClass() which was introduced in
-      // Java 15. For now, try and support both older and newer Java versions.
-      DEFINE_ANONYMOUS_CLASS = getDefineAnonymousClass();
-      if (DEFINE_ANONYMOUS_CLASS == null) {
-        LOOKUP = getTrustedLookup();
-
-        Class classOptionClass = Class.forName(LOOKUP_CLASS.getName() + "$ClassOption");
-        HIDDEN_CLASS_OPTIONS = Array.newInstance(classOptionClass, 1);
-        Array.set(HIDDEN_CLASS_OPTIONS, 0, Enum.valueOf(classOptionClass, "NESTMATE"));
-        HIDDEN_DEFINE_METHOD =
-            LOOKUP_CLASS.getMethod(
-                "defineHiddenClass", byte[].class, boolean.class, HIDDEN_CLASS_OPTIONS.getClass());
-      } else {
-        LOOKUP = null;
-        HIDDEN_DEFINE_METHOD = null;
-        HIDDEN_CLASS_OPTIONS = null;
-      }
-    } catch (ReflectiveOperationException e) {
-      throw new LinkageError(e.getMessage(), e);
-    }
-  }
-
-  private static java.lang.reflect.Method getDefineAnonymousClass() {
-    try {
-      return UNSAFE_CLASS.getMethod(
-          "defineAnonymousClass", Class.class, byte[].class, Object[].class);
-    } catch (NoSuchMethodException e) {
-      return null;
-    }
-  }
-
-  private static MethodHandles.Lookup getTrustedLookup() throws ReflectiveOperationException {
-    Field trustedLookupField = LOOKUP_CLASS.getDeclaredField("IMPL_LOOKUP");
-    java.lang.reflect.Method baseMethod = UNSAFE_CLASS.getMethod("staticFieldBase", Field.class);
-    Object lookupBase = baseMethod.invoke(UNSAFE, trustedLookupField);
-    java.lang.reflect.Method offsetMethod =
-        UNSAFE_CLASS.getMethod("staticFieldOffset", Field.class);
-    Object lookupOffset = offsetMethod.invoke(UNSAFE, trustedLookupField);
-
-    java.lang.reflect.Method getObjectMethod =
-        UNSAFE_CLASS.getMethod("getObject", Object.class, long.class);
-    return (MethodHandles.Lookup) getObjectMethod.invoke(UNSAFE, lookupBase, lookupOffset);
-  }
-
-  private final MethodMapper methodMapper;
-  private final ClassValueMap<Factory> factories;
-
-  public ProxyMaker(MethodMapper methodMapper) {
-    this.methodMapper = methodMapper;
-    factories =
-        new ClassValueMap<Factory>() {
-          @Override
-          protected Factory computeValue(Class<?> type) {
-            return PerfStatsCollector.getInstance()
-                .measure("createProxyFactory", () -> createProxyFactory(type));
-          }
-        };
-  }
-
-  public <T> T createProxy(Class<T> targetClass, T target) {
-    return PerfStatsCollector.getInstance()
-        .measure(
-            "createProxyInstance",
-            () -> factories.get(targetClass).createProxy(targetClass, target));
-  }
-
-  <T> Factory createProxyFactory(Class<T> targetClass) {
-    Type targetType = Type.getType(targetClass);
-    String targetName = targetType.getInternalName();
-    String proxyName = targetName + "$GeneratedProxy";
-    Type proxyType = Type.getType("L" + proxyName.replace('.', '/') + ";");
-    ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-    writer.visit(
-        V1_7,
-        ACC_PUBLIC | ACC_SYNTHETIC | ACC_SUPER | ACC_FINAL,
-        proxyName,
-        null,
-        targetName,
-        null);
-
-    writer.visitField(
-        ACC_PUBLIC | ACC_SYNTHETIC, TARGET_FIELD, targetType.getDescriptor(), null, null);
-
-    for (java.lang.reflect.Method method : targetClass.getMethods()) {
-      if (!shouldProxy(method)) continue;
-
-      Method proxyMethod = Method.getMethod(method);
-      GeneratorAdapter m =
-          new GeneratorAdapter(
-              ACC_PUBLIC | ACC_SYNTHETIC, Method.getMethod(method), null, null, writer);
-      m.loadThis();
-      m.getField(proxyType, TARGET_FIELD, targetType);
-      m.loadArgs();
-      String targetMethod = methodMapper.getName(targetClass.getName(), method.getName());
-      // In Java 8 we could use invokespecial here but not in 7, from jvm spec:
-      // If an invokespecial instruction names a method which is not an instance
-      // initialization method, then the type of the target reference on the operand
-      // stack must be assignment compatible with the current class (JLS §5.2).
-      m.visitMethodInsn(
-          INVOKEVIRTUAL, targetName, targetMethod, proxyMethod.getDescriptor(), false);
-      m.returnValue();
-      m.endMethod();
-    }
-
-    writer.visitEnd();
-
-    byte[] bytecode = writer.toByteArray();
-
-    if (DEBUG) {
-      File file = new File("/tmp", targetClass.getCanonicalName() + "-DirectProxy.class");
-      System.out.println("Generated Direct Proxy: " + file.getAbsolutePath());
-      try (OutputStream out = new FileOutputStream(file)) {
-        out.write(bytecode);
-      } catch (IOException e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    try {
-      final Class<?> proxyClass = defineHiddenClass(targetClass, bytecode);
-      final Field field = proxyClass.getDeclaredField(TARGET_FIELD);
-      return new Factory() {
-        @Override
-        public <E> E createProxy(Class<E> targetClass, E target) {
-          try {
-            Object proxy = UNSAFE.allocateInstance(proxyClass);
-
-            field.set(proxy, target);
-
-            return targetClass.cast(proxy);
-          } catch (Throwable t) {
-            throw new AssertionError(t);
-          }
-        }
-      };
-    } catch (ReflectiveOperationException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static Class<?> defineHiddenClass(Class<?> targetClass, byte[] bytes)
-      throws ReflectiveOperationException {
-    if (DEFINE_ANONYMOUS_CLASS != null) {
-      return (Class<?>) DEFINE_ANONYMOUS_CLASS.invoke(UNSAFE, targetClass, bytes, (Object[]) null);
-    } else {
-      MethodHandles.Lookup lookup = (MethodHandles.Lookup) LOOKUP.in(targetClass);
-      MethodHandles.Lookup definedLookup =
-          (MethodHandles.Lookup)
-              HIDDEN_DEFINE_METHOD.invoke(lookup, bytes, false, HIDDEN_CLASS_OPTIONS);
-      return definedLookup.lookupClass();
-    }
-  }
-
-  private static boolean shouldProxy(java.lang.reflect.Method method) {
-    int modifiers = method.getModifiers();
-    return !Modifier.isAbstract(modifiers)
-        && !Modifier.isFinal(modifiers)
-        && !Modifier.isPrivate(modifiers)
-        && !Modifier.isNative(modifiers);
-  }
-
-  interface MethodMapper {
-    String getName(String className, String methodName);
-  }
-
-  interface Factory {
-    <T> T createProxy(Class<T> targetClass, T target);
-  }
-}
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/Sandbox.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/Sandbox.java
index 92f897f8b..69e4ac022 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/Sandbox.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/Sandbox.java
@@ -106,6 +106,11 @@ public class Sandbox {
         });
   }
 
+  // check if the sandbox is shutdown
+  public boolean isShutdown() {
+    return executorService.isShutdown();
+  }
+
   /** Cleans up resources that have been opened by this Sandbox. */
   public void shutdown() {
     executorService.shutdown();
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
index 35deebccf..7f359d0b0 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
@@ -28,6 +28,10 @@ import org.robolectric.util.Util;
 public class SandboxClassLoader extends URLClassLoader {
   // The directory where instrumented class files will be dumped
   private static final String DUMP_CLASSES_PROPERTY = "robolectric.dumpClassesDirectory";
+
+  // Whether to log resources abd classes loaded from android-all jars.
+  private static final boolean LOG_RESOURCE_USAGE = false;
+
   private static final AtomicInteger DUMP_CLASSES_COUNTER = new AtomicInteger();
 
   private final InstrumentationConfiguration config;
@@ -103,18 +107,31 @@ public class SandboxClassLoader extends URLClassLoader {
   @Override
   public URL getResource(String name) {
     if (config.shouldAcquireResource(name)) {
-      return resourceProvider.getResource(name);
+      return getResourceUrl(name);
     }
     URL fromParent = super.getResource(name);
     if (fromParent != null) {
       return fromParent;
     }
-    return resourceProvider.getResource(name);
+    return getResourceUrl(name);
+  }
+
+  private URL getResourceUrl(String name) {
+    URL result = resourceProvider.getResource(name);
+    if (LOG_RESOURCE_USAGE && result != null) {
+      PerfStatsCollector.getInstance().incrementCount("SandboxClassLoader.getResource " + name);
+    }
+    return result;
   }
 
-  private InputStream getClassBytesAsStreamPreferringLocalUrls(String resName) {
+  private InputStream getClassBytesAsStreamPreferringLocalUrls(String className) {
+    String resName = className.replace('.', '/') + ".class";
     InputStream fromUrlsClassLoader = resourceProvider.getResourceAsStream(resName);
     if (fromUrlsClassLoader != null) {
+      if (LOG_RESOURCE_USAGE) {
+        PerfStatsCollector.getInstance()
+            .incrementCount("SandboxClassLoader.classResourceLoaded " + className);
+      }
       return fromUrlsClassLoader;
     }
     return super.getResourceAsStream(resName);
@@ -171,8 +188,7 @@ public class SandboxClassLoader extends URLClassLoader {
   }
 
   protected byte[] getByteCode(String className) throws ClassNotFoundException {
-    String classFilename = className.replace('.', '/') + ".class";
-    try (InputStream classBytesStream = getClassBytesAsStreamPreferringLocalUrls(classFilename)) {
+    try (InputStream classBytesStream = getClassBytesAsStreamPreferringLocalUrls(className)) {
       if (classBytesStream == null) {
         throw new ClassNotFoundException(className);
       }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
index 4f3de9e9f..62c75635b 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
@@ -6,8 +6,6 @@ import org.robolectric.util.ReflectionHelpers;
 
 public class ShadowImpl implements IShadow {
 
-  private final ProxyMaker proxyMaker = new ProxyMaker(this::directMethodName);
-
   @Override
   @SuppressWarnings("TypeParameterUnusedInFormals")
   public <T> T extract(Object instance) {
@@ -25,20 +23,6 @@ public class ShadowImpl implements IShadow {
         clazz, ReflectionHelpers.ClassParameter.fromComponentLists(parameterTypes, params));
   }
 
-  /**
-   * Returns a proxy object that invokes the original $$robo$$-prefixed methods for {@code
-   * shadowedObject}.
-   *
-   * @deprecated This is incompatible with JDK17+. Use a {@link
-   *     org.robolectric.util.reflector.Reflector} interface with {@link
-   *     org.robolectric.util.reflector.Direct}.
-   */
-  @Deprecated
-  @Override
-  public <T> T directlyOn(T shadowedObject, Class<T> clazz) {
-    return createProxy(shadowedObject, clazz);
-  }
-
   @Override
   @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
   public <R> R directlyOn(
@@ -75,10 +59,6 @@ public class ShadowImpl implements IShadow {
     return (R) ReflectionHelpers.callStaticMethod(clazz, directMethodName, paramValues);
   }
 
-  private <T> T createProxy(T shadowedObject, Class<T> clazz) {
-    return proxyMaker.createProxy(clazz, shadowedObject);
-  }
-
   @Override
   @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
   public <R> R invokeConstructor(
diff --git a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
index 24fcc74ee..c5e499318 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
@@ -348,6 +348,10 @@ public class ShadowWranglerIntegrationTest {
     public CharSequence aMethod(CharSequence s) {
       return s;
     }
+
+    public CharSequence aMethodWithArrayParam(CharSequence[] s) {
+      return String.join(",", s);
+    }
   }
 
   @Instrument
@@ -379,6 +383,8 @@ public class ShadowWranglerIntegrationTest {
   @Test
   public void methodMatch_shouldAllowClassNameAnnotatedMatches() {
     assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("ClassNameAnnotated-bc");
+    assertThat(new AClassWithDifficultArgs().aMethodWithArrayParam(new CharSequence[] {"bc", "de"}))
+        .isEqualTo("ClassNameAnnotated-bc,de");
   }
 
   @SandboxConfig(shadows = ShadowAClassWithDifficultArgsUseClassNameButUnmatchedReturn.class)
@@ -443,6 +449,11 @@ public class ShadowWranglerIntegrationTest {
         @ClassName("java.lang.CharSequence") Object s) {
       return "ClassNameAnnotated-" + s;
     }
+
+    protected @ClassName("java.lang.CharSequence") Object aMethodWithArrayParam(
+        @ClassName("[Ljava.lang.CharSequence;") Object s) {
+      return "ClassNameAnnotated-" + String.join(",", (CharSequence[]) s);
+    }
   }
 
   @Implements(value = AClassWithDifficultArgs.class)
diff --git a/sandbox/src/test/java/org/robolectric/ShadowingTest.java b/sandbox/src/test/java/org/robolectric/ShadowingTest.java
index a9a1ec48e..5d6c5c84b 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowingTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowingTest.java
@@ -20,6 +20,7 @@ import org.robolectric.internal.bytecode.ShadowConstants;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.testing.AnUninstrumentedClass;
 import org.robolectric.testing.Pony;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 @RunWith(SandboxTestRunner.class)
 public class ShadowingTest {
@@ -133,7 +134,9 @@ public class ShadowingTest {
     Pony pony = new Pony();
 
     assertEquals("Fake whinny! You're on my neck!", pony.ride("neck"));
-    assertEquals("Whinny! You're on my neck!", Shadow.directlyOn(pony, Pony.class).ride("neck"));
+    assertEquals(
+        "Whinny! You're on my neck!",
+        Shadow.directlyOn(pony, Pony.class, "ride", ClassParameter.from(String.class, "neck")));
 
     assertEquals("Fake whinny! You're on my haunches!", pony.ride("haunches"));
   }
diff --git a/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java b/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java
deleted file mode 100644
index 38c7f9d93..000000000
--- a/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.robolectric.internal.bytecode;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ProxyMakerTest {
-  private static final ProxyMaker.MethodMapper IDENTITY_NAME =
-      new ProxyMaker.MethodMapper() {
-        @Override
-        public String getName(String className, String methodName) {
-          return methodName;
-        }
-      };
-
-  @Test
-  public void proxyCall() {
-    ProxyMaker maker = new ProxyMaker(IDENTITY_NAME);
-
-    Thing mock = mock(Thing.class);
-    Thing proxy = maker.createProxyFactory(Thing.class).createProxy(Thing.class, mock);
-    assertThat(proxy.getClass()).isNotSameInstanceAs(Thing.class);
-
-    proxy.returnNothing();
-    verify(mock).returnNothing();
-
-    when(mock.returnInt()).thenReturn(42);
-    assertThat(proxy.returnInt()).isEqualTo(42);
-    verify(mock).returnInt();
-
-    proxy.argument("hello");
-    verify(mock).argument("hello");
-  }
-
-  @Test
-  public void cachesProxyClass() {
-    ProxyMaker maker = new ProxyMaker(IDENTITY_NAME);
-    Thing thing1 = mock(Thing.class);
-    Thing thing2 = mock(Thing.class);
-
-    Thing proxy1 = maker.createProxy(Thing.class, thing1);
-    Thing proxy2 = maker.createProxy(Thing.class, thing2);
-
-    assertThat(proxy1.getClass()).isSameInstanceAs(proxy2.getClass());
-  }
-
-  public static class Thing {
-    public Thing() {
-      throw new UnsupportedOperationException();
-    }
-
-    public void returnNothing() {
-      throw new UnsupportedOperationException();
-    }
-
-    public int returnInt() {
-      throw new UnsupportedOperationException();
-    }
-
-    public void argument(String arg) {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java b/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
index af93777e8..0188f7bad 100644
--- a/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
+++ b/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
@@ -480,6 +480,7 @@ public class SandboxClassLoaderTest {
             "aMethod", int.class, loadClass(AClassToRemember.class), String.class));
   }
 
+  @SuppressWarnings("unchecked")
   @Test
   public void shouldInterceptFilteredMethodInvocations() throws Exception {
     setClassLoader(
@@ -491,12 +492,11 @@ public class SandboxClassLoaderTest {
     Class<?> theClass = loadClass(AClassThatRefersToAForgettableClass.class);
     Object instance = theClass.getDeclaredConstructor().newInstance();
     Object output =
-        theClass
-            .getMethod("interactWithForgettableClass")
-            .invoke(shadow.directlyOn(instance, (Class<Object>) theClass));
+        shadow.directlyOn(instance, (Class<Object>) theClass, "interactWithForgettableClass");
     assertEquals("null, get this!", output);
   }
 
+  @SuppressWarnings("unchecked")
   @Test
   public void shouldInterceptFilteredStaticMethodInvocations() throws Exception {
     setClassLoader(
@@ -509,9 +509,9 @@ public class SandboxClassLoaderTest {
     Class<?> theClass = loadClass(AClassThatRefersToAForgettableClass.class);
     Object instance = theClass.getDeclaredConstructor().newInstance();
     Object output =
-        theClass
-            .getMethod("interactWithForgettableStaticMethod")
-            .invoke(shadow.directlyOn(instance, (Class<Object>) theClass));
+        shadow.directlyOn(
+            instance, (Class<Object>) theClass, "interactWithForgettableStaticMethod");
+
     assertEquals("yess? forget this: null", output);
   }
 
@@ -520,6 +520,7 @@ public class SandboxClassLoaderTest {
     return InstrumentationConfiguration.newBuilder();
   }
 
+  @SuppressWarnings("unchecked")
   @Test
   public void shouldRemapClassesWhileInterceptingMethods() throws Exception {
     InstrumentationConfiguration config =
@@ -533,11 +534,10 @@ public class SandboxClassLoaderTest {
 
     setClassLoader(new SandboxClassLoader(config));
     Class<?> theClass = loadClass(AClassThatCallsAMethodReturningAForgettableClass.class);
-    theClass
-        .getMethod("callSomeMethod")
-        .invoke(
-            shadow.directlyOn(
-                theClass.getDeclaredConstructor().newInstance(), (Class<Object>) theClass));
+    shadow.directlyOn(
+        theClass.getDeclaredConstructor().newInstance(),
+        (Class<Object>) theClass,
+        "callSomeMethod");
   }
 
   @Test
diff --git a/settings.gradle.kts b/settings.gradle.kts
index ca5e97855..812cc3b2a 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -18,47 +18,45 @@ dependencyResolutionManagement {
 rootProject.name = "robolectric"
 
 include(
-  ":robolectric",
-  ":sandbox",
-  ":junit",
-  ":utils",
-  ":utils:reflector",
-  ":pluginapi",
-  ":plugins:maven-dependency-resolver",
-  ":preinstrumented",
-  ":processor",
-  ":resources",
   ":annotations",
-  ":shadows:framework",
-  ":shadows:httpclient",
-  ":shadows:multidex",
-  ":shadows:playservices",
-  ":shadowapi",
   ":errorprone",
-  ":nativeruntime",
-  ":integration_tests:agp",
-  ":integration_tests:agp:testsupport",
+  ":integration_tests:androidx",
+  ":integration_tests:androidx_test",
+  ":integration_tests:composeui",
+  ":integration_tests:ctesque",
   ":integration_tests:dependency-on-stubs",
+  ":integration_tests:jacoco-offline",
   ":integration_tests:kotlin",
   ":integration_tests:libphonenumber",
   ":integration_tests:memoryleaks",
   ":integration_tests:mockito",
-  ":integration_tests:mockito-kotlin",
   ":integration_tests:mockito-experimental",
+  ":integration_tests:mockito-kotlin",
+  ":integration_tests:mockk",
+  ":integration_tests:nativegraphics",
+  ":integration_tests:play_services",
   ":integration_tests:powermock",
   ":integration_tests:roborazzi",
-  ":integration_tests:androidx",
-  ":integration_tests:androidx_test",
-  ":integration_tests:ctesque",
-  ":integration_tests:security-providers",
-  ":integration_tests:mockk",
-  ":integration_tests:jacoco-offline",
+  ":integration_tests:room",
   ":integration_tests:sdkcompat",
-  ":integration_tests:multidex",
-  ":integration_tests:play_services",
+  ":integration_tests:security-providers",
   ":integration_tests:sparsearray",
-  ":integration_tests:nativegraphics",
-  ":integration_tests:room",
+  ":integration_tests:testparameterinjector",
   ":integration_tests:versioning",
+  ":junit",
+  ":nativeruntime",
+  ":pluginapi",
+  ":plugins:maven-dependency-resolver",
+  ":preinstrumented",
+  ":processor",
+  ":resources",
+  ":robolectric",
+  ":sandbox",
+  ":shadowapi",
+  ":shadows:framework",
+  ":shadows:httpclient",
+  ":shadows:playservices",
   ":testapp",
+  ":utils",
+  ":utils:reflector",
 )
diff --git a/shadowapi/Android.bp b/shadowapi/Android.bp
index 49ba20faa..a9de730ac 100644
--- a/shadowapi/Android.bp
+++ b/shadowapi/Android.bp
@@ -12,13 +12,13 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_shadowapi_upstream",
+    name: "Robolectric_shadowapi",
     libs: [
         "jsr305",
     ],
     static_libs: [
-        "Robolectric_utils_upstream",
-        "Robolectric_annotations_upstream",
+        "Robolectric_utils",
+        "Robolectric_annotations",
     ],
     srcs: ["src/main/java/**/*.java"],
     openjdk9: {
@@ -32,10 +32,10 @@ java_library_host {
 // Compile Robolectric shadowapi tests
 //#############################################
 java_test_host {
-    name: "Robolectric_shadowapi_tests_upstream",
+    name: "Robolectric_shadowapi_tests",
     srcs: ["src/test/java/**/*.java"],
     static_libs: [
-        "Robolectric_shadowapi_upstream",
+        "Robolectric_shadowapi",
         "hamcrest",
         "guava",
         "junit",
diff --git a/shadowapi/src/main/java/org/robolectric/internal/IShadow.java b/shadowapi/src/main/java/org/robolectric/internal/IShadow.java
index 3783164c0..1e23a261c 100644
--- a/shadowapi/src/main/java/org/robolectric/internal/IShadow.java
+++ b/shadowapi/src/main/java/org/robolectric/internal/IShadow.java
@@ -10,17 +10,6 @@ public interface IShadow {
 
   <T> T newInstance(Class<T> clazz, Class<?>[] parameterTypes, Object[] params);
 
-  /**
-   * Returns a proxy object that invokes the original $$robo$$-prefixed methods for {@code
-   * shadowedObject}.
-   *
-   * @deprecated This is incompatible with JDK17+. Use a {@link
-   *     org.robolectric.util.reflector.Reflector} interface with {@link
-   *     org.robolectric.util.reflector.Direct}.
-   */
-  @Deprecated
-  <T> T directlyOn(T shadowedObject, Class<T> clazz);
-
   <R> R directlyOn(
       Object shadowedObject,
       String clazzName,
diff --git a/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java b/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
index fb2b28e68..f57228411 100644
--- a/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
+++ b/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
@@ -46,21 +46,7 @@ public class Shadow {
     return SHADOW_IMPL.newInstance(clazz, parameterTypes, params);
   }
 
-  /**
-   * Returns a proxy object that invokes the original $$robo$$-prefixed methods whenever a method on
-   * the proxy is invoked. This is primarily used to invoke original methods in shadow
-   * implementations.
-   *
-   * @deprecated This is incompatible with JDK17+. Use a {@link
-   *     org.robolectric.util.reflector.Reflector} interface with {@link
-   *     org.robolectric.util.reflector.Direct}.
-   */
-  @Deprecated
-  public static <T> T directlyOn(T shadowedObject, Class<T> clazz) {
-    return SHADOW_IMPL.directlyOn(shadowedObject, clazz);
-  }
-
-  @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
+  @SuppressWarnings("TypeParameterUnusedInFormals")
   public static <R> R directlyOn(
       Object shadowedObject, String clazzName, String methodName, ClassParameter... paramValues) {
     return SHADOW_IMPL.directlyOn(shadowedObject, clazzName, methodName, paramValues);
diff --git a/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java b/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
index 73141f13d..a4a9b1cb1 100644
--- a/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
+++ b/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
@@ -573,6 +573,35 @@ public class ReflectionHelpers {
     return false;
   }
 
+  /**
+   * Reflectively check if a class has a given method.
+   *
+   * @param parameterTypes in order parameters of the method.
+   * @param clazz Target class.
+   * @param methodName Target method name.
+   * @return boolean to indicate whether the constructor exists or not on the clazz.
+   */
+  public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
+    for (Method method : clazz.getDeclaredMethods()) {
+      Class<?>[] paramTypes = method.getParameterTypes();
+      if (method.getName().equals(methodName)) {
+        if (paramTypes.length == parameterTypes.length) {
+          boolean match = true;
+          for (int i = 0; i < paramTypes.length; i++) {
+            if (!paramTypes[i].isAssignableFrom(parameterTypes[i])) {
+              match = false;
+              break;
+            }
+          }
+          if (match) {
+            return true;
+          }
+        }
+      }
+    }
+    return false;
+  }
+
   private static <R, E extends Exception> R traverseClassHierarchy(
       Class<?> targetClass, Class<? extends E> exceptionClass, InsideTraversal<R> insideTraversal)
       throws Exception {
diff --git a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
index cc6c43952..e678051ed 100644
--- a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
+++ b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
@@ -26,6 +26,15 @@ public class ReflectionHelpersTest {
     assertThat(ReflectionHelpers.hasConstructor(ExampleClass.class, Object.class)).isFalse();
   }
 
+  @Test
+  public void hasMethod() {
+    assertThat(ReflectionHelpers.hasMethod(ExampleClass.class, "setName", String.class)).isTrue();
+    assertThat(ReflectionHelpers.hasMethod(ExampleClass.class, "setName", Integer.class)).isFalse();
+    assertThat(ReflectionHelpers.hasMethod(ExampleClass.class, "setFoo", String.class)).isFalse();
+    assertThat(ReflectionHelpers.hasMethod(ExampleClass.class, "getName")).isTrue();
+    assertThat(ReflectionHelpers.hasMethod(ExampleClass.class, "getName", Integer.class)).isFalse();
+  }
+
   @Test
   public void getFieldReflectively_getsPrivateFields() {
     ExampleDescendant example = new ExampleDescendant();
@@ -480,6 +489,14 @@ public class ReflectionHelpersTest {
     private ExampleClass(int index) {
       this.index = index;
     }
+
+    public String getName() {
+      return name;
+    }
+
+    public void setName(String name) {
+      this.name = name;
+    }
   }
 
   private static class FieldTestClass {
diff --git a/shadows/framework/Android.bp b/shadows/framework/Android.bp
index 1b4ec63b8..39b573a13 100644
--- a/shadows/framework/Android.bp
+++ b/shadows/framework/Android.bp
@@ -12,7 +12,7 @@ package {
 }
 
 java_library {
-    name: "Robolectric_shadows_framework_upstream",
+    name: "Robolectric_shadows_framework",
     host_supported: true,
     device_supported: false,
     srcs: [
@@ -32,15 +32,15 @@ java_library {
         //"-J-verbose",
     ],
     libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_nativeruntime_upstream",
-        "Robolectric_resources_upstream",
-        "Robolectric_pluginapi_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_shadows_versioning_upstream",
-        "Robolectric_utils_upstream",
-        "Robolectric_utils_reflector_upstream",
+        "Robolectric_annotations",
+        "Robolectric_nativeruntime",
+        "Robolectric_resources",
+        "Robolectric_pluginapi",
+        "Robolectric_sandbox",
+        "Robolectric_shadowapi",
+        "Robolectric_shadows_versioning",
+        "Robolectric_utils",
+        "Robolectric_utils_reflector",
         "auto_value_annotations",
         "jsr305",
         "icu4j",
@@ -55,13 +55,13 @@ java_library {
         "error_prone_annotations",
         // aar files that make up android and jetpack
         "robolectric-host-android_all",
-        "robolectric-host-androidx-test-core_upstream",
-        "robolectric-host-androidx-test-monitor_upstream",
+        "robolectric-host-androidx-test-core",
+        "robolectric-host-androidx-test-monitor",
     ],
     plugins: [
         "auto_value_plugin_1.9",
         "auto_value_builder_plugin_1.9",
-        "Robolectric_processor_upstream",
+        "Robolectric_processor",
     ],
     errorprone: {
         javacflags: [
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
index 3d092cc3b..439ff76e8 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
@@ -1,6 +1,5 @@
 package org.robolectric.android.util.concurrent;
 
-import android.annotation.NonNull;
 import com.google.common.annotations.Beta;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.util.Collection;
@@ -11,6 +10,7 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.LooperMode;
 
 /**
@@ -62,25 +62,25 @@ public class InlineExecutorService implements ExecutorService {
     return delegateService.awaitTermination(l, timeUnit);
   }
 
-  @NonNull
+  @Nonnull
   @Override
-  public <T> Future<T> submit(@NonNull Callable<T> task) {
+  public <T> Future<T> submit(@Nonnull Callable<T> task) {
     Future<T> future = delegateService.submit(task);
     delegateService.runAll();
     return future;
   }
 
-  @NonNull
+  @Nonnull
   @Override
-  public <T> Future<T> submit(@NonNull Runnable task, T result) {
+  public <T> Future<T> submit(@Nonnull Runnable task, T result) {
     Future<T> future = delegateService.submit(task, result);
     delegateService.runAll();
     return future;
   }
 
-  @NonNull
+  @Nonnull
   @Override
-  public Future<?> submit(@NonNull Runnable task) {
+  public Future<?> submit(@Nonnull Runnable task) {
     Future<?> future = delegateService.submit(task);
     delegateService.runAll();
     return future;
@@ -88,36 +88,36 @@ public class InlineExecutorService implements ExecutorService {
 
   @Override
   @SuppressWarnings("FutureReturnValueIgnored")
-  public void execute(@NonNull Runnable command) {
+  public void execute(@Nonnull Runnable command) {
     delegateService.execute(command);
     delegateService.runAll();
   }
 
-  @NonNull
+  @Nonnull
   @Override
-  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks)
+  public <T> List<Future<T>> invokeAll(@Nonnull Collection<? extends Callable<T>> tasks)
       throws InterruptedException {
     return delegateService.invokeAll(tasks);
   }
 
-  @NonNull
+  @Nonnull
   @Override
   public <T> List<Future<T>> invokeAll(
-      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      @Nonnull Collection<? extends Callable<T>> tasks, long timeout, @Nonnull TimeUnit unit)
       throws InterruptedException {
     return delegateService.invokeAll(tasks, timeout, unit);
   }
 
-  @NonNull
+  @Nonnull
   @Override
-  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)
+  public <T> T invokeAny(@Nonnull Collection<? extends Callable<T>> tasks)
       throws ExecutionException, InterruptedException {
     return delegateService.invokeAny(tasks);
   }
 
   @Override
   public <T> T invokeAny(
-      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      @Nonnull Collection<? extends Callable<T>> tasks, long timeout, @Nonnull TimeUnit unit)
       throws ExecutionException, InterruptedException, TimeoutException {
     return delegateService.invokeAny(tasks, timeout, unit);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
index 910899ebd..9a96c9a93 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
@@ -1,6 +1,5 @@
 package org.robolectric.android.util.concurrent;
 
-import android.annotation.NonNull;
 import com.google.common.annotations.Beta;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.AbstractFuture;
@@ -15,6 +14,7 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.RunnableFuture;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.util.Logger;
 
@@ -159,7 +159,7 @@ public class PausedExecutorService extends AbstractExecutorService {
   }
 
   @Override
-  public void execute(@NonNull Runnable command) {
+  public void execute(@Nonnull Runnable command) {
     if (command instanceof DeferredTask) {
       deferredTasks.add(command);
     } else {
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java b/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java
new file mode 100644
index 000000000..9b0be8ffd
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java
@@ -0,0 +1,587 @@
+package org.robolectric.fakes;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_ALBUMART;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_ALBUMART_FILE_ID;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_ALBUMART_ID;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_GENRES;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_GENRES_ID;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_GENRES_ID_MEMBERS;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_MEDIA;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_MEDIA_ID;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_MEDIA_ID_GENRES;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_MEDIA_ID_GENRES_ID;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_PLAYLISTS;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_PLAYLISTS_ID;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_PLAYLISTS_ID_MEMBERS;
+import static org.robolectric.fakes.MediaUriMatcher.AUDIO_PLAYLISTS_ID_MEMBERS_ID;
+import static org.robolectric.fakes.MediaUriMatcher.DOWNLOADS;
+import static org.robolectric.fakes.MediaUriMatcher.DOWNLOADS_ID;
+import static org.robolectric.fakes.MediaUriMatcher.FILES_ID;
+import static org.robolectric.fakes.MediaUriMatcher.IMAGES_MEDIA;
+import static org.robolectric.fakes.MediaUriMatcher.IMAGES_MEDIA_ID;
+import static org.robolectric.fakes.MediaUriMatcher.IMAGES_THUMBNAILS;
+import static org.robolectric.fakes.MediaUriMatcher.IMAGES_THUMBNAILS_ID;
+import static org.robolectric.fakes.MediaUriMatcher.VIDEO_MEDIA;
+import static org.robolectric.fakes.MediaUriMatcher.VIDEO_MEDIA_ID;
+import static org.robolectric.fakes.MediaUriMatcher.VIDEO_THUMBNAILS;
+import static org.robolectric.fakes.MediaUriMatcher.VIDEO_THUMBNAILS_ID;
+
+import android.content.ClipDescription;
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.os.Build.VERSION_CODES;
+import android.os.CancellationSignal;
+import android.os.Environment;
+import android.os.ParcelFileDescriptor;
+import android.os.UserHandle;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio;
+import android.provider.MediaStore.Downloads;
+import android.provider.MediaStore.Files.FileColumns;
+import android.provider.MediaStore.Images;
+import android.provider.MediaStore.MediaColumns;
+import android.provider.MediaStore.Video;
+import android.text.TextUtils;
+import android.util.Log;
+import android.webkit.MimeTypeMap;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
+import com.google.common.io.Files;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Random;
+import java.util.Set;
+import org.robolectric.RuntimeEnvironment;
+
+/**
+ * A fake implementation of the content provider in MediaStore. The provider is functional and can
+ * be used to populate the android media store in tests.
+ *
+ * <p>It currently is a very simplistic implementation compared to the real <a
+ * href="https://cs.android.com/android/platform/superproject/main/+/main:packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java">MediaProvider</a>
+ *
+ * <p>Among other limitations, it:
+ *
+ * <ul>
+ *   <li>Only supports media content queries
+ *   <li>Only supports single external storage volume
+ *   <li>Does not support monitoring for file system changes
+ *   <li>Only supports single user
+ * </ul>
+ */
+public final class FakeMediaProvider extends ContentProvider {
+
+  private static final String TABLE_NAME = "files";
+
+  private Supplier<SQLiteDatabase> dbSupplier;
+
+  private final Random displayNameRandom = new Random();
+  private final MediaUriMatcher uriMatcher = new MediaUriMatcher(MediaStore.AUTHORITY);
+  private static final String TAG = "FakeMediaProvider";
+
+  @Override
+  public boolean onCreate() {
+    // currently only Q and above is supported
+    Preconditions.checkArgument(RuntimeEnvironment.getApiLevel() >= VERSION_CODES.Q);
+    // lazily create the database to avoid the performance hit of loading native sqlite for tests
+    // that do not need it
+    dbSupplier =
+        Suppliers.memoize(
+            () -> {
+              SQLiteDatabase db = SQLiteDatabase.create(null);
+              db.execSQL(createTableStatement());
+              return db;
+            });
+
+    return true;
+  }
+
+  @Override
+  public Cursor query(
+      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+    return query(uri, projection, selection, selectionArgs, sortOrder, null);
+  }
+
+  @Override
+  public Cursor query(
+      Uri uri,
+      String[] projection,
+      String selection,
+      String[] selectionArgs,
+      String sortOrder,
+      CancellationSignal cancellationSignal) {
+    checkNotNull(uri);
+    final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+
+    qb.setTables(TABLE_NAME);
+
+    int uriType = uriMatcher.matchUri(uri);
+    switch (uriType) {
+      case AUDIO_MEDIA_ID:
+      case VIDEO_MEDIA_ID:
+      case IMAGES_MEDIA_ID:
+      case AUDIO_ALBUMART_ID:
+      case VIDEO_THUMBNAILS_ID:
+      case IMAGES_THUMBNAILS_ID:
+      case AUDIO_PLAYLISTS_ID:
+      case FILES_ID:
+      case DOWNLOADS_ID:
+        qb.appendWhere(MediaStore.MediaColumns._ID + "=" + uri.getLastPathSegment());
+        break;
+      default:
+        break;
+    }
+
+    Cursor cursor =
+        qb.query(
+            dbSupplier.get(),
+            projection,
+            selection,
+            selectionArgs,
+            null,
+            null,
+            sortOrder,
+            null,
+            cancellationSignal);
+    cursor.setNotificationUri(getContext().getContentResolver(), uri);
+    return cursor;
+  }
+
+  @Override
+  public String getType(Uri uri) {
+    // copy of MediaProvider#getType
+
+    final int match = uriMatcher.matchUri(uri);
+    switch (match) {
+      case IMAGES_MEDIA_ID:
+      case AUDIO_MEDIA_ID:
+      case AUDIO_PLAYLISTS_ID:
+      case AUDIO_PLAYLISTS_ID_MEMBERS_ID:
+      case VIDEO_MEDIA_ID:
+      case DOWNLOADS_ID:
+      case FILES_ID:
+        return queryForType(uri);
+
+      case IMAGES_MEDIA:
+      case IMAGES_THUMBNAILS:
+        return Images.Media.CONTENT_TYPE;
+
+      case AUDIO_ALBUMART_ID:
+      case AUDIO_ALBUMART_FILE_ID:
+      case IMAGES_THUMBNAILS_ID:
+      case VIDEO_THUMBNAILS_ID:
+        return "image/jpeg";
+
+      case AUDIO_MEDIA:
+      case AUDIO_GENRES_ID_MEMBERS:
+      case AUDIO_PLAYLISTS_ID_MEMBERS:
+        return Audio.Media.CONTENT_TYPE;
+
+      case AUDIO_GENRES:
+      case AUDIO_MEDIA_ID_GENRES:
+        return Audio.Genres.CONTENT_TYPE;
+      case AUDIO_GENRES_ID:
+      case AUDIO_MEDIA_ID_GENRES_ID:
+        return Audio.Genres.ENTRY_CONTENT_TYPE;
+      case AUDIO_PLAYLISTS:
+        return Audio.Playlists.CONTENT_TYPE;
+
+      case VIDEO_MEDIA:
+        return Video.Media.CONTENT_TYPE;
+      case DOWNLOADS:
+        return Downloads.CONTENT_TYPE;
+      default:
+        throw new IllegalStateException("Unknown URI : " + uri);
+    }
+  }
+
+  private String queryForType(Uri url) {
+    Cursor cursor = queryForSingleItem(url, new String[] {MediaColumns.MIME_TYPE}, null, null);
+    return cursor.getString(0);
+  }
+
+  private Cursor queryForSingleItem(
+      Uri uri, String[] projection, String selection, String[] selectionArgs) {
+    Cursor c = query(uri, projection, selection, selectionArgs, null);
+    if (c == null) {
+      throw new IllegalArgumentException("Failed to find single item for uri " + uri);
+    }
+    if (c.getCount() != 1 || !c.moveToFirst()) {
+      c.close();
+      throw new IllegalArgumentException("Failed to find single item for uri " + uri);
+    }
+    return c;
+  }
+
+  @Override
+  public Uri insert(Uri uri, ContentValues originalValues) {
+    ContentValues values = new ContentValues(checkNotNull(originalValues));
+
+    final int match = uriMatcher.matchUri(uri);
+    checkState(match != UriMatcher.NO_MATCH, "Unrecognized uri " + uri.toString());
+
+    if (match == AUDIO_PLAYLISTS_ID || match == AUDIO_PLAYLISTS_ID_MEMBERS) {
+      // playlist support is deprecated in android, but there are still tests
+      // that rely on insert at least not crashing
+      Log.w(TAG, "Ignoring insert of unsupported playlist members");
+      return null;
+    }
+
+    // Give the record reasonable defaults when missing
+    String displayName = values.getAsString(MediaColumns.DISPLAY_NAME);
+    String mimeType = values.getAsString(MediaColumns.MIME_TYPE);
+    // assume mp4 by default
+    String currentDisplayExtension = displayName != null ? Files.getFileExtension(displayName) : "";
+    if (TextUtils.isEmpty(currentDisplayExtension)
+        && TextUtils.isEmpty(mimeType)
+        && !TextUtils.isEmpty(displayName)) {
+      throw new IllegalArgumentException("Could not determine mime type ");
+    }
+    if (TextUtils.isEmpty(displayName)) {
+      // Real media provider uses System.currentTimeMillis() as default name
+      // This could be problematic for Robolectric where clock is fixed, so just use
+      // a random number.
+      displayName = String.valueOf(Math.abs(displayNameRandom.nextInt()));
+      values.put(MediaColumns.DISPLAY_NAME, displayName);
+    }
+    if (TextUtils.isEmpty(mimeType)) {
+      if (TextUtils.isEmpty(currentDisplayExtension)) {
+        mimeType = getDefaultMimeTypeFromUri(match);
+      } else {
+        // try to guess from extension
+        mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(currentDisplayExtension);
+        if (TextUtils.isEmpty(mimeType)) {
+          throw new IllegalArgumentException("Could not guess mimeType from name " + displayName);
+        }
+      }
+      values.put(MediaColumns.MIME_TYPE, mimeType);
+    }
+    validateMimeType(match, mimeType);
+
+    // Check that the current given extension matches the mime type.
+    // and if it doesn't, append the correct extension to the display name
+    // The logic flows this way to handle mime types like image/jpeg that have multiple valid
+    // extensions
+    String mimeTypeFromExtension =
+        MimeTypeMap.getSingleton().getMimeTypeFromExtension(currentDisplayExtension);
+    if (mimeTypeFromExtension == null || !mimeTypeFromExtension.equals(mimeType)) {
+      String extensionFromMime = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
+      if (extensionFromMime == null) {
+        throw new IllegalArgumentException("Unsupported MIME type " + mimeType);
+      }
+      displayName += "." + extensionFromMime;
+      values.put(MediaColumns.DISPLAY_NAME, displayName);
+    }
+
+    // Use default directories when missing
+    String relativePath = values.getAsString(MediaColumns.RELATIVE_PATH);
+    if (TextUtils.isEmpty(relativePath)) {
+      relativePath = getDefaultRelativePath(match);
+      values.put(MediaColumns.RELATIVE_PATH, relativePath + "/");
+    } else {
+      // TODO: support other types
+      validateRelativePath(mimeType, relativePath);
+    }
+
+    validateRelativePath(relativePath, values.getAsString(MediaColumns.RELATIVE_PATH));
+    values.put(MediaStore.MediaColumns.DATE_ADDED, System.currentTimeMillis() / 1000);
+    values.put(MediaColumns.BUCKET_DISPLAY_NAME, relativePath.split("/")[0]);
+
+    String baseFileName = Files.getNameWithoutExtension(displayName);
+    if (TextUtils.isEmpty(values.getAsString(MediaColumns.TITLE))) {
+      // default to display name if not set
+      values.put(MediaColumns.TITLE, baseFileName);
+    }
+    values.remove(FileColumns.MEDIA_TYPE);
+    if (!values.containsKey(MediaColumns.IS_PENDING)) {
+      values.put(MediaColumns.IS_PENDING, false);
+    }
+    String dataPath =
+        Paths.get(
+                Environment.getExternalStorageDirectory().toString(),
+                relativePath,
+                makeUniqueFileName(baseFileName, Files.getFileExtension(displayName)))
+            .toAbsolutePath()
+            .toString();
+    if (values.containsKey(MediaColumns.DATA)) {
+      // technically this is only rejected on SDKs >= 34 but lets just forbid it everywhere
+      throw new IllegalArgumentException("Mutation of _data is not allowed");
+    }
+    values.put(MediaColumns.DATA, dataPath);
+
+    long rowId = dbSupplier.get().insert(TABLE_NAME, null, values);
+    return rowId > 0 ? ContentUris.withAppendedId(uri, rowId) : null;
+  }
+
+  // guard against two entries with same displayname and relative path being inserted by adding a
+  // random number to each entry
+  private String makeUniqueFileName(String baseName, String ext) {
+    return String.format("%s-%d.%s", baseName, Math.abs(displayNameRandom.nextInt()), ext);
+  }
+
+  private String getDefaultRelativePath(int match) {
+    switch (match) {
+      case AUDIO_MEDIA:
+      case AUDIO_MEDIA_ID:
+      case AUDIO_PLAYLISTS:
+      case AUDIO_PLAYLISTS_ID:
+        return Environment.DIRECTORY_MUSIC;
+      case VIDEO_MEDIA:
+      case VIDEO_MEDIA_ID:
+        return Environment.DIRECTORY_MOVIES;
+      case IMAGES_MEDIA:
+      case IMAGES_MEDIA_ID:
+      case AUDIO_ALBUMART:
+      case AUDIO_ALBUMART_ID:
+      case VIDEO_THUMBNAILS:
+      case VIDEO_THUMBNAILS_ID:
+      case IMAGES_THUMBNAILS:
+      case IMAGES_THUMBNAILS_ID:
+        return Environment.DIRECTORY_PICTURES;
+      case DOWNLOADS:
+      case DOWNLOADS_ID:
+      default:
+        return Environment.DIRECTORY_DOWNLOADS;
+    }
+  }
+
+  private String getDefaultMimeTypeFromUri(int match) {
+    // stripped copy of MediaProvider#ensureFileColumns
+    switch (match) {
+      case AUDIO_MEDIA:
+      case AUDIO_MEDIA_ID:
+        return "audio/mpeg";
+      case VIDEO_MEDIA:
+      case VIDEO_MEDIA_ID:
+        return "video/mp4";
+      case IMAGES_MEDIA:
+      case IMAGES_MEDIA_ID:
+      case AUDIO_ALBUMART:
+      case AUDIO_ALBUMART_ID:
+      case VIDEO_THUMBNAILS:
+      case VIDEO_THUMBNAILS_ID:
+      case IMAGES_THUMBNAILS:
+      case IMAGES_THUMBNAILS_ID:
+        return "image/jpeg";
+      case AUDIO_PLAYLISTS:
+      case AUDIO_PLAYLISTS_ID:
+        return "audio/mpegurl";
+      default:
+        return ClipDescription.MIMETYPE_UNKNOWN;
+    }
+  }
+
+  private void validateMimeType(int match, String mimeType) {
+    if (match == AUDIO_MEDIA && !mimeType.startsWith("audio")) {
+      throw new IllegalArgumentException("Invalid mimeType for uri " + mimeType + " " + match);
+    } else if (match == VIDEO_MEDIA && !mimeType.startsWith("video")) {
+      throw new IllegalArgumentException("Invalid mimeType for uri " + mimeType + " " + match);
+    } else if (match == IMAGES_MEDIA && !mimeType.startsWith("image")) {
+      throw new IllegalArgumentException("Invalid mimeType for uri " + mimeType + " " + match);
+    }
+  }
+
+  private void validateRelativePath(String mimeType, String relativePath) {
+    if (mimeType.startsWith("video")) {
+      String primaryDir = relativePath.split("/")[0];
+      Set<String> allowedPaths = Set.of("DCIM", "Movies", "Pictures");
+      if (!allowedPaths.contains(primaryDir)) {
+        throw new IllegalArgumentException(
+            String.format(
+                "Primary directory %s not allowed for content://media/external/video/media; allowed"
+                    + " directories are %s",
+                primaryDir, allowedPaths));
+      }
+    }
+  }
+
+  @Override
+  public int delete(Uri uri, String selection, String[] selectionArgs) {
+    // TODO: also delete the associated file
+    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+
+    qb.setTables(TABLE_NAME);
+
+    selection =
+        selection == null
+            ? MediaStore.MediaColumns._ID + " = ?"
+            : selection + " AND " + MediaStore.MediaColumns._ID + " = ?";
+    selectionArgs =
+        selectionArgs == null
+            ? new String[] {uri.getLastPathSegment()}
+            : appendSelectionArgs(selectionArgs, uri.getLastPathSegment());
+
+    int count = 0;
+    try (Cursor cursor =
+        qb.query(
+            dbSupplier.get(),
+            new String[] {MediaStore.MediaColumns._ID},
+            selection,
+            selectionArgs,
+            /* groupBy= */ null,
+            /* having= */ null,
+            /* orderBy= */ null)) {
+      while (cursor != null && cursor.moveToNext()) {
+        long mediaStoreId = cursor.getLong(/* columnIndex= */ 0);
+
+        count +=
+            qb.delete(
+                dbSupplier.get(),
+                MediaStore.MediaColumns._ID + " = ?",
+                new String[] {String.valueOf(mediaStoreId)});
+      }
+    }
+
+    // real Android will just throw SecurityException if it doesn't recognize the id.
+    // so just do that
+    if (count <= 0) {
+      throw new SecurityException("Could not find entries " + uri.toString());
+    }
+    return count;
+  }
+
+  private static String[] appendSelectionArgs(String[] originalArgs, String additionalArgs) {
+    int length = originalArgs.length + 1;
+    String[] result = Arrays.copyOf(originalArgs, length);
+    result[length - 1] = additionalArgs;
+    return result;
+  }
+
+  @Override
+  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+    selection =
+        selection == null
+            ? MediaStore.MediaColumns._ID + " = ?"
+            : selection + " AND " + MediaStore.MediaColumns._ID + " = ?";
+    selectionArgs =
+        selectionArgs == null
+            ? new String[] {uri.getLastPathSegment()}
+            : appendSelectionArgs(selectionArgs, uri.getLastPathSegment());
+
+    return dbSupplier.get().update(TABLE_NAME, values, selection, selectionArgs);
+  }
+
+  @Override
+  public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
+    try (Cursor cursor =
+        query(
+            uri,
+            /* projection= */ new String[] {
+              MediaColumns.DATA,
+            },
+            /* selection= */ null,
+            /* selectionArgs= */ null,
+            /* sortOrder= */ null)) {
+      if (cursor.getCount() == 1 && cursor.moveToFirst()) {
+        String data = cursor.getString(0);
+        File file = new File(data);
+        if (!file.exists()) {
+          if (!mode.contains("w")) {
+            throw new FileNotFoundException(
+                "File does not exist and mode is not write: " + file.getPath() + " " + mode);
+          }
+          file.getParentFile().mkdirs();
+          try {
+            // On real MediaProvider, the behavior for opening a non-existing file to write is to
+            // proactively create a new one as opposed to throwing exception.
+            file.createNewFile();
+          } catch (IOException e) {
+            throw new FileNotFoundException(e.getMessage());
+          }
+        }
+        return ParcelFileDescriptor.open(file, ParcelFileDescriptor.parseMode(mode));
+      }
+    }
+    throw new FileNotFoundException("Can't find file for uri: " + uri);
+  }
+
+  private static String createTableStatement() {
+    // copy of MediaProvider's DatabaseHelper#createLatestSchema
+    return "CREATE TABLE files (_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+        + "_data TEXT UNIQUE COLLATE NOCASE,_size INTEGER,format INTEGER,parent INTEGER,"
+        + "date_added INTEGER,date_modified INTEGER,mime_type TEXT,title TEXT,"
+        + "description TEXT,_display_name TEXT,picasa_id TEXT,orientation INTEGER,"
+        + "latitude DOUBLE,longitude DOUBLE,datetaken INTEGER,mini_thumb_magic INTEGER,"
+        + "bucket_id TEXT,bucket_display_name TEXT,isprivate INTEGER,title_key TEXT,"
+        + "artist_id INTEGER,album_id INTEGER,composer TEXT,track INTEGER,"
+        + "year INTEGER CHECK(year!=0),is_ringtone INTEGER,is_music INTEGER,"
+        + "is_alarm INTEGER,is_notification INTEGER,is_podcast INTEGER,album_artist TEXT,"
+        + "duration INTEGER,bookmark INTEGER,artist TEXT,album TEXT,resolution TEXT,"
+        + "tags TEXT,category TEXT,language TEXT,mini_thumb_data TEXT,name TEXT,"
+        + "media_type INTEGER,old_id INTEGER,is_drm INTEGER,"
+        + "width INTEGER, height INTEGER, title_resource_uri TEXT,"
+        + "owner_package_name TEXT DEFAULT NULL,"
+        + "color_standard INTEGER, color_transfer INTEGER, color_range INTEGER,"
+        + "_hash BLOB DEFAULT NULL, is_pending INTEGER DEFAULT 0,"
+        + "is_download INTEGER DEFAULT 0, download_uri TEXT DEFAULT NULL,"
+        + "referer_uri TEXT DEFAULT NULL, is_audiobook INTEGER DEFAULT 0,"
+        + "date_expires INTEGER DEFAULT NULL,is_trashed INTEGER DEFAULT 0,"
+        + "group_id INTEGER DEFAULT NULL,primary_directory TEXT DEFAULT NULL,"
+        + "secondary_directory TEXT DEFAULT NULL,document_id TEXT DEFAULT NULL,"
+        + "instance_id TEXT DEFAULT NULL,original_document_id TEXT DEFAULT NULL,"
+        + "relative_path TEXT DEFAULT NULL,volume_name TEXT DEFAULT NULL,"
+        + "artist_key TEXT DEFAULT NULL,album_key TEXT DEFAULT NULL,"
+        + "genre TEXT DEFAULT NULL,genre_key TEXT DEFAULT NULL,genre_id INTEGER,"
+        + "author TEXT DEFAULT NULL, bitrate INTEGER DEFAULT NULL,"
+        + "capture_framerate REAL DEFAULT NULL, cd_track_number TEXT DEFAULT NULL,"
+        + "compilation INTEGER DEFAULT NULL, disc_number TEXT DEFAULT NULL,"
+        + "is_favorite INTEGER DEFAULT 0, num_tracks INTEGER DEFAULT NULL,"
+        + "writer TEXT DEFAULT NULL, exposure_time TEXT DEFAULT NULL,"
+        + "f_number TEXT DEFAULT NULL, iso INTEGER DEFAULT NULL,"
+        + "scene_capture_type INTEGER DEFAULT NULL, generation_added INTEGER DEFAULT 0,"
+        + "generation_modified INTEGER DEFAULT 0, xmp BLOB DEFAULT NULL,"
+        + "_transcode_status INTEGER DEFAULT 0, _video_codec_type TEXT DEFAULT NULL,"
+        + "_modifier INTEGER DEFAULT 0, is_recording INTEGER DEFAULT 0,"
+        + "redacted_uri_id TEXT DEFAULT NULL, _user_id INTEGER DEFAULT "
+        + UserHandle.myUserId()
+        + ", _special_format INTEGER DEFAULT NULL,"
+        + "oem_metadata BLOB DEFAULT NULL,"
+        + "inferred_media_date INTEGER,"
+        + "bits_per_sample INTEGER DEFAULT NULL, samplerate INTEGER DEFAULT NULL,"
+        + "inferred_date INTEGER,"
+        // in real mediaprovider thumbnail metadata is stored in a separate table
+        // that adds a lot of complexity, so just add some common fields to this 'files' table
+        + "kind INTEGER,"
+        + "image_id INTEGER"
+        + ")";
+  }
+
+  private static String extractFileName(String data) {
+    if (data == null) {
+      return null;
+    }
+    data = extractDisplayName(data);
+
+    final int lastDot = data.lastIndexOf('.');
+    if (lastDot == -1) {
+      return data;
+    } else {
+      return data.substring(0, lastDot);
+    }
+  }
+
+  private static String extractDisplayName(String data) {
+    if (data == null) {
+      return null;
+    }
+    if (data.indexOf('/') == -1) {
+      return data;
+    }
+    if (data.endsWith("/")) {
+      data = data.substring(0, data.length() - 1);
+    }
+    return data.substring(data.lastIndexOf('/') + 1);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/MediaUriMatcher.java b/shadows/framework/src/main/java/org/robolectric/fakes/MediaUriMatcher.java
new file mode 100644
index 000000000..7e7bad8f3
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/MediaUriMatcher.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.robolectric.fakes;
+
+import android.content.UriMatcher;
+import android.net.Uri;
+
+/**
+ * A simplified fork of MediaProvider's LocalUriMatcher.
+ *
+ * <p>This version only supports public files Uris, no support for hidden Uris or photo picker Uris
+ */
+class MediaUriMatcher {
+
+  // WARNING: the values of IMAGES_MEDIA, AUDIO_MEDIA, and VIDEO_MEDIA and AUDIO_PLAYLISTS
+  // are stored in the "files" table, so do not renumber them unless you also add
+  // a corresponding database upgrade step for it.
+  static final int IMAGES_MEDIA = 1;
+  static final int IMAGES_MEDIA_ID = 2;
+  static final int IMAGES_MEDIA_ID_THUMBNAIL = 3;
+  static final int IMAGES_THUMBNAILS = 4;
+  static final int IMAGES_THUMBNAILS_ID = 5;
+
+  static final int AUDIO_MEDIA = 100;
+  static final int AUDIO_MEDIA_ID = 101;
+  static final int AUDIO_MEDIA_ID_GENRES = 102;
+  static final int AUDIO_MEDIA_ID_GENRES_ID = 103;
+  static final int AUDIO_GENRES = 106;
+  static final int AUDIO_GENRES_ID = 107;
+  static final int AUDIO_GENRES_ID_MEMBERS = 108;
+  static final int AUDIO_GENRES_ALL_MEMBERS = 109;
+  static final int AUDIO_PLAYLISTS = 110;
+  static final int AUDIO_PLAYLISTS_ID = 111;
+  static final int AUDIO_PLAYLISTS_ID_MEMBERS = 112;
+  static final int AUDIO_PLAYLISTS_ID_MEMBERS_ID = 113;
+  static final int AUDIO_ARTISTS = 114;
+  static final int AUDIO_ARTISTS_ID = 115;
+  static final int AUDIO_ALBUMS = 116;
+  static final int AUDIO_ALBUMS_ID = 117;
+  static final int AUDIO_ARTISTS_ID_ALBUMS = 118;
+  static final int AUDIO_ALBUMART = 119;
+  static final int AUDIO_ALBUMART_ID = 120;
+  static final int AUDIO_ALBUMART_FILE_ID = 121;
+
+  static final int VIDEO_MEDIA = 200;
+  static final int VIDEO_MEDIA_ID = 201;
+  static final int VIDEO_MEDIA_ID_THUMBNAIL = 202;
+  static final int VIDEO_THUMBNAILS = 203;
+  static final int VIDEO_THUMBNAILS_ID = 204;
+
+  static final int MEDIA_SCANNER = 500;
+
+  static final int FS_ID = 600;
+  static final int VERSION = 601;
+
+  static final int FILES = 700;
+  static final int FILES_ID = 701;
+
+  static final int DOWNLOADS = 800;
+  static final int DOWNLOADS_ID = 801;
+
+  // MediaProvider Command Line Interface
+  static final int CLI = 100_000;
+
+  private final UriMatcher mPublic = new UriMatcher(UriMatcher.NO_MATCH);
+
+  int matchUri(Uri uri) {
+    return mPublic.match(uri);
+  }
+
+  MediaUriMatcher(String auth) {
+    // Warning: Do not move these exact string matches below "*/.." matches.
+    // If "*/.." match is added to mPublic children before "picker/#/#", then while matching
+    // "picker/0/10", UriMatcher matches "*" node with "picker" and tries to match "0/10"
+    // with children of "*".
+    // UriMatcher does not look for exact "picker" string match if it finds * node before
+    // it. It finds the first best child match and proceeds the match from there without
+    // looking at other siblings.
+
+    mPublic.addURI(auth, "cli", CLI);
+
+    mPublic.addURI(auth, "*/images/media", IMAGES_MEDIA);
+    mPublic.addURI(auth, "*/images/media/#", IMAGES_MEDIA_ID);
+    mPublic.addURI(auth, "*/images/media/#/thumbnail", IMAGES_MEDIA_ID_THUMBNAIL);
+    mPublic.addURI(auth, "*/images/thumbnails", IMAGES_THUMBNAILS);
+    mPublic.addURI(auth, "*/images/thumbnails/#", IMAGES_THUMBNAILS_ID);
+
+    mPublic.addURI(auth, "*/audio/media", AUDIO_MEDIA);
+    mPublic.addURI(auth, "*/audio/media/#", AUDIO_MEDIA_ID);
+    mPublic.addURI(auth, "*/audio/media/#/genres", AUDIO_MEDIA_ID_GENRES);
+    mPublic.addURI(auth, "*/audio/media/#/genres/#", AUDIO_MEDIA_ID_GENRES_ID);
+    mPublic.addURI(auth, "*/audio/genres", AUDIO_GENRES);
+    mPublic.addURI(auth, "*/audio/genres/#", AUDIO_GENRES_ID);
+    mPublic.addURI(auth, "*/audio/genres/#/members", AUDIO_GENRES_ID_MEMBERS);
+    // TODO: not actually defined in API, but CTS tested
+    mPublic.addURI(auth, "*/audio/genres/all/members", AUDIO_GENRES_ALL_MEMBERS);
+    mPublic.addURI(auth, "*/audio/playlists", AUDIO_PLAYLISTS);
+    mPublic.addURI(auth, "*/audio/playlists/#", AUDIO_PLAYLISTS_ID);
+    mPublic.addURI(auth, "*/audio/playlists/#/members", AUDIO_PLAYLISTS_ID_MEMBERS);
+    mPublic.addURI(auth, "*/audio/playlists/#/members/#", AUDIO_PLAYLISTS_ID_MEMBERS_ID);
+    mPublic.addURI(auth, "*/audio/artists", AUDIO_ARTISTS);
+    mPublic.addURI(auth, "*/audio/artists/#", AUDIO_ARTISTS_ID);
+    mPublic.addURI(auth, "*/audio/artists/#/albums", AUDIO_ARTISTS_ID_ALBUMS);
+    mPublic.addURI(auth, "*/audio/albums", AUDIO_ALBUMS);
+    mPublic.addURI(auth, "*/audio/albums/#", AUDIO_ALBUMS_ID);
+    // TODO: not actually defined in API, but CTS tested
+    mPublic.addURI(auth, "*/audio/albumart", AUDIO_ALBUMART);
+    // TODO: not actually defined in API, but CTS tested
+    mPublic.addURI(auth, "*/audio/albumart/#", AUDIO_ALBUMART_ID);
+    // TODO: not actually defined in API, but CTS tested
+    mPublic.addURI(auth, "*/audio/media/#/albumart", AUDIO_ALBUMART_FILE_ID);
+
+    mPublic.addURI(auth, "*/video/media", VIDEO_MEDIA);
+    mPublic.addURI(auth, "*/video/media/#", VIDEO_MEDIA_ID);
+    mPublic.addURI(auth, "*/video/media/#/thumbnail", VIDEO_MEDIA_ID_THUMBNAIL);
+    mPublic.addURI(auth, "*/video/thumbnails", VIDEO_THUMBNAILS);
+    mPublic.addURI(auth, "*/video/thumbnails/#", VIDEO_THUMBNAILS_ID);
+
+    mPublic.addURI(auth, "*/media_scanner", MEDIA_SCANNER);
+
+    // NOTE: technically hidden, since Uri is never exposed
+    mPublic.addURI(auth, "*/fs_id", FS_ID);
+    // NOTE: technically hidden, since Uri is never exposed
+    mPublic.addURI(auth, "*/version", VERSION);
+
+    mPublic.addURI(auth, "*/file", FILES);
+    mPublic.addURI(auth, "*/file/#", FILES_ID);
+
+    mPublic.addURI(auth, "*/downloads", DOWNLOADS);
+    mPublic.addURI(auth, "*/downloads/#", DOWNLOADS_ID);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java
index 0a38e44e6..aa457f7bb 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java
@@ -1,5 +1,8 @@
 package org.robolectric.fakes;
 
+import android.annotation.DrawableRes;
+import android.annotation.LayoutRes;
+import android.annotation.StringRes;
 import android.content.Context;
 import android.content.Intent;
 import android.graphics.drawable.Drawable;
@@ -9,36 +12,43 @@ import android.view.LayoutInflater;
 import android.view.MenuItem;
 import android.view.SubMenu;
 import android.view.View;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 
-/** Robolectric implementation of {@link android.view.MenuItem}. */
+/** Robolectric implementation of {@link MenuItem}. */
 public class RoboMenuItem implements MenuItem {
   private int itemId;
   private int groupId;
-  private CharSequence title;
+  @Nullable private CharSequence title;
+  @Nullable private CharSequence titleCondensed;
   private boolean enabled = true;
   private boolean checked = false;
   private boolean checkable = false;
   private boolean visible = true;
   private boolean expanded = false;
-  private OnMenuItemClickListener menuItemClickListener;
-  public Drawable icon;
-  private Intent intent;
-  private SubMenu subMenu;
-  private View actionView;
-  private OnActionExpandListener actionExpandListener;
+  @Nullable private OnMenuItemClickListener menuItemClickListener;
+  @Nullable public Drawable icon;
+  @Nullable private Intent intent;
+  @Nullable private SubMenu subMenu;
+  @Nullable private View actionView;
+  @Nullable private OnActionExpandListener actionExpandListener;
   private int order;
-  private Context context;
+  @Nonnull private final Context context;
+  private char numericChar;
+  private char alphaChar;
+  @Nullable private ActionProvider actionProvider;
 
   public RoboMenuItem() {
     this(RuntimeEnvironment.getApplication());
   }
 
-  public RoboMenuItem(Context context) {
+  public RoboMenuItem(@Nonnull Context context) {
     this.context = context;
   }
 
   public RoboMenuItem(int itemId) {
+    this();
     this.itemId = itemId;
   }
 
@@ -70,85 +80,103 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
-  public MenuItem setTitle(CharSequence title) {
+  @Nonnull
+  public MenuItem setTitle(@Nullable CharSequence title) {
     this.title = title;
     return this;
   }
 
   @Override
-  public MenuItem setTitle(int title) {
+  @Nonnull
+  public MenuItem setTitle(@StringRes int title) {
+    this.title = title == 0 ? null : context.getString(title);
     return this;
   }
 
   @Override
+  @Nullable
   public CharSequence getTitle() {
     return title;
   }
 
   @Override
-  public MenuItem setTitleCondensed(CharSequence title) {
+  @Nonnull
+  public MenuItem setTitleCondensed(@Nullable CharSequence title) {
+    this.titleCondensed = title;
     return this;
   }
 
   @Override
+  @Nullable
   public CharSequence getTitleCondensed() {
-    return null;
+    return titleCondensed;
   }
 
   @Override
-  public MenuItem setIcon(Drawable icon) {
+  @Nonnull
+  public MenuItem setIcon(@Nullable Drawable icon) {
     this.icon = icon;
     return this;
   }
 
   @Override
-  public MenuItem setIcon(int iconRes) {
-    this.icon = iconRes == 0 ? null : context.getResources().getDrawable(iconRes);
+  @Nonnull
+  public MenuItem setIcon(@DrawableRes int iconRes) {
+    this.icon = iconRes == 0 ? null : context.getDrawable(iconRes);
     return this;
   }
 
   @Override
+  @Nullable
   public Drawable getIcon() {
     return this.icon;
   }
 
   @Override
-  public MenuItem setIntent(Intent intent) {
+  @Nonnull
+  public MenuItem setIntent(@Nullable Intent intent) {
     this.intent = intent;
     return this;
   }
 
   @Override
+  @Nullable
   public Intent getIntent() {
     return this.intent;
   }
 
   @Override
+  @Nonnull
   public MenuItem setShortcut(char numericChar, char alphaChar) {
     return this;
   }
 
   @Override
+  @Nonnull
   public MenuItem setNumericShortcut(char numericChar) {
+    this.numericChar = numericChar;
     return this;
   }
 
   @Override
   public char getNumericShortcut() {
-    return 0;
+    return numericChar;
   }
 
   @Override
+  @Nonnull
   public MenuItem setAlphabeticShortcut(char alphaChar) {
+    this.alphaChar = alphaChar;
     return this;
   }
 
   @Override
   public char getAlphabeticShortcut() {
-    return 0;
+    return alphaChar;
   }
 
   @Override
+  @Nonnull
   public MenuItem setCheckable(boolean checkable) {
     this.checkable = checkable;
     return this;
@@ -160,6 +188,7 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
+  @Nonnull
   public MenuItem setChecked(boolean checked) {
     this.checked = checked;
     return this;
@@ -171,6 +200,7 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
+  @Nonnull
   public MenuItem setVisible(boolean visible) {
     this.visible = visible;
     return this;
@@ -182,6 +212,7 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
+  @Nonnull
   public MenuItem setEnabled(boolean enabled) {
     this.enabled = enabled;
     return this;
@@ -198,21 +229,25 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
+  @Nullable
   public SubMenu getSubMenu() {
     return subMenu;
   }
 
-  public void setSubMenu(SubMenu subMenu) {
+  public void setSubMenu(@Nullable SubMenu subMenu) {
     this.subMenu = subMenu;
   }
 
   @Override
-  public MenuItem setOnMenuItemClickListener(OnMenuItemClickListener menuItemClickListener) {
+  @Nonnull
+  public MenuItem setOnMenuItemClickListener(
+      @Nullable OnMenuItemClickListener menuItemClickListener) {
     this.menuItemClickListener = menuItemClickListener;
     return this;
   }
 
   @Override
+  @Nullable
   public ContextMenu.ContextMenuInfo getMenuInfo() {
     return null;
   }
@@ -229,35 +264,42 @@ public class RoboMenuItem implements MenuItem {
   public void setShowAsAction(int actionEnum) {}
 
   @Override
+  @Nonnull
   public MenuItem setShowAsActionFlags(int actionEnum) {
     return this;
   }
 
   @Override
-  public MenuItem setActionView(View view) {
+  @Nonnull
+  public MenuItem setActionView(@Nullable View view) {
     actionView = view;
     return this;
   }
 
   @Override
-  public MenuItem setActionView(int resId) {
+  @Nonnull
+  public MenuItem setActionView(@LayoutRes int resId) {
     actionView = LayoutInflater.from(context).inflate(resId, null);
     return this;
   }
 
   @Override
+  @Nullable
   public View getActionView() {
     return actionView;
   }
 
   @Override
-  public MenuItem setActionProvider(ActionProvider actionProvider) {
+  @Nonnull
+  public MenuItem setActionProvider(@Nullable ActionProvider actionProvider) {
+    this.actionProvider = actionProvider;
     return this;
   }
 
   @Override
+  @Nullable
   public ActionProvider getActionProvider() {
-    return null;
+    return actionProvider;
   }
 
   @Override
@@ -294,7 +336,8 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
-  public MenuItem setOnActionExpandListener(OnActionExpandListener listener) {
+  @Nonnull
+  public MenuItem setOnActionExpandListener(@Nullable OnActionExpandListener listener) {
     actionExpandListener = listener;
     return this;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java
index 91ccebb53..ea8cfd2ef 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java
@@ -1,9 +1,15 @@
 package org.robolectric.fakes;
 
 import android.webkit.WebSettings;
+import javax.annotation.Nullable;
 
 /** Robolectric implementation of {@link android.webkit.WebSettings}. */
 public class RoboWebSettings extends WebSettings {
+  private static final String DEFAULT_USER_AGENT =
+      "Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30"
+          + " (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30";
+  @Nullable private static String defaultUserAgentOverride = null;
+
   private boolean blockNetworkImage = false;
   private boolean javaScriptEnabled = false;
   private boolean javaScriptCanOpenWindowAutomatically = false;
@@ -323,9 +329,7 @@ public class RoboWebSettings extends WebSettings {
 
   private boolean allowFileAccess = true;
   private boolean builtInZoomControls = true;
-  private String userAgentString =
-      "Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30"
-          + " (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30";
+  private String userAgentString = null;
 
   @Override
   public boolean getAllowFileAccess() {
@@ -348,13 +352,15 @@ public class RoboWebSettings extends WebSettings {
   }
 
   @Override
-  public synchronized void setUserAgentString(String ua) {
+  public synchronized void setUserAgentString(@Nullable String ua) {
     userAgentString = ua;
   }
 
   @Override
   public synchronized String getUserAgentString() {
-    return userAgentString;
+    return userAgentString == null || userAgentString.isEmpty()
+        ? getDefaultUserAgent()
+        : userAgentString;
   }
 
   // End API 3
@@ -676,4 +682,28 @@ public class RoboWebSettings extends WebSettings {
   }
 
   // End API 29
+
+  /**
+   * Returns the default User-Agent used by a WebView. An instance of WebView could use a different
+   * User-Agent if a call is made to {@link WebSettings#setUserAgentString(String)}.
+   *
+   * <p>The default User-Agent can be overridden (for the entire application) by calling {@link
+   * #setDefaultUserAgentOverride(String)}.
+   */
+  public static String getDefaultUserAgent() {
+    return defaultUserAgentOverride == null ? DEFAULT_USER_AGENT : defaultUserAgentOverride;
+  }
+
+  /**
+   * Overrides the default user agent for all WebViews. The value set here is returned from {@link
+   * #getDefaultUserAgent()}.
+   *
+   * <p>Note that particular WebView instances will ignore this value if they have been configured
+   * with a custom user agent via {@link WebSettings#setUserAgentString(String)}.
+   *
+   * <p>If the value is null, the default user agent will be provided by Robolectric.
+   */
+  public static void setDefaultUserAgentOverride(@Nullable String defaultUserAgent) {
+    defaultUserAgentOverride = defaultUserAgent;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
index ac4ef50bc..5683dc701 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
@@ -3,15 +3,14 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.companion.AssociatedDevice;
 import android.companion.AssociationInfo;
-import android.graphics.drawable.Icon;
 import android.net.MacAddress;
+import com.google.common.base.Preconditions;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
-import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
-import org.robolectric.util.reflector.WithType;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Builder for {@link AssociationInfo}. */
@@ -56,6 +55,10 @@ public class AssociationInfoBuilder {
   }
 
   public AssociationInfoBuilder setTag(String tag) {
+    // tag was removed in Baklava
+    Preconditions.checkState(
+        ReflectionHelpers.hasMethod(AssociationInfo.Builder.class, "setTag", String.class),
+        "tag was removed in post-V SDKs");
     this.tag = tag;
     return this;
   }
@@ -115,103 +118,26 @@ public class AssociationInfoBuilder {
       MacAddress macAddress =
           deviceMacAddress == null ? null : MacAddress.fromString(deviceMacAddress);
 
-      if (getNumOfConstructorParams() == 16) {
-        return reflector(AssociationInfoReflector.class)
-            .nwwAssociationInfoPostV(
-                id,
-                userId,
-                packageName,
-                tag,
-                macAddress,
-                displayName,
-                deviceProfile,
-                associatedDevice,
-                selfManaged,
-                notifyOnDeviceNearby,
-                revoked,
-                pending,
-                approvedMs,
-                lastTimeConnectedMs,
-                systemDataSyncFlags,
-                null /* icon */);
-      }
-      // TODO: convert the rest of this logic to use number of parameters and reflector
       if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
-        // We have two different constructors for AssociationInfo across
-        // T branches. aosp has the constructor that takes a new "revoked" parameter.
-        // Since there is not deterministic way to know which branch we are running in,
-        // we will reflect on the class to see if it has the mRevoked member.
-        // Based on the result we will either invoke the constructor with "revoked" or the
-        // one without this parameter.
-        if (ReflectionHelpers.hasField(AssociationInfo.class, "mRevoked")) {
-          return ReflectionHelpers.callConstructor(
-              AssociationInfo.class,
-              ClassParameter.from(int.class, id),
-              ClassParameter.from(int.class, userId),
-              ClassParameter.from(String.class, packageName),
-              ClassParameter.from(MacAddress.class, macAddress),
-              ClassParameter.from(CharSequence.class, displayName),
-              ClassParameter.from(String.class, deviceProfile),
-              ClassParameter.from(boolean.class, selfManaged),
-              ClassParameter.from(boolean.class, notifyOnDeviceNearby),
-              ClassParameter.from(boolean.class, revoked /*revoked only supported in aosp*/),
-              ClassParameter.from(long.class, approvedMs),
-              ClassParameter.from(long.class, lastTimeConnectedMs));
-        } else {
-          return ReflectionHelpers.callConstructor(
-              AssociationInfo.class,
-              ClassParameter.from(int.class, id),
-              ClassParameter.from(int.class, userId),
-              ClassParameter.from(String.class, packageName),
-              ClassParameter.from(MacAddress.class, macAddress),
-              ClassParameter.from(CharSequence.class, displayName),
-              ClassParameter.from(String.class, deviceProfile),
-              ClassParameter.from(boolean.class, selfManaged),
-              ClassParameter.from(boolean.class, notifyOnDeviceNearby),
-              ClassParameter.from(long.class, approvedMs),
-              ClassParameter.from(long.class, lastTimeConnectedMs));
-        }
-      } else if (RuntimeEnvironment.getApiLevel() <= U.SDK_INT) {
-        // AOSP does not yet contains the new fields - mAssociatedDevice & mSystemDataSyncFlags yet
-        if (ReflectionHelpers.hasField(AssociationInfo.class, "mAssociatedDevice")) {
-          return ReflectionHelpers.callConstructor(
-              AssociationInfo.class,
-              ClassParameter.from(int.class, id),
-              ClassParameter.from(int.class, userId),
-              ClassParameter.from(String.class, packageName),
-              ClassParameter.from(MacAddress.class, macAddress),
-              ClassParameter.from(CharSequence.class, displayName),
-              ClassParameter.from(String.class, deviceProfile),
-              ClassParameter.from(
-                  Class.forName("android.companion.AssociatedDevice"), associatedDevice),
-              ClassParameter.from(boolean.class, selfManaged),
-              ClassParameter.from(boolean.class, notifyOnDeviceNearby),
-              ClassParameter.from(boolean.class, revoked),
-              ClassParameter.from(long.class, approvedMs),
-              ClassParameter.from(long.class, lastTimeConnectedMs),
-              ClassParameter.from(int.class, systemDataSyncFlags));
-        } else {
-          return ReflectionHelpers.callConstructor(
-              AssociationInfo.class,
-              ClassParameter.from(int.class, id),
-              ClassParameter.from(int.class, userId),
-              ClassParameter.from(String.class, packageName),
-              ClassParameter.from(MacAddress.class, macAddress),
-              ClassParameter.from(CharSequence.class, displayName),
-              ClassParameter.from(String.class, deviceProfile),
-              ClassParameter.from(boolean.class, selfManaged),
-              ClassParameter.from(boolean.class, notifyOnDeviceNearby),
-              ClassParameter.from(boolean.class, revoked),
-              ClassParameter.from(long.class, approvedMs),
-              ClassParameter.from(long.class, lastTimeConnectedMs));
-        }
-      } else {
         return ReflectionHelpers.callConstructor(
             AssociationInfo.class,
             ClassParameter.from(int.class, id),
             ClassParameter.from(int.class, userId),
             ClassParameter.from(String.class, packageName),
-            ClassParameter.from(String.class, tag),
+            ClassParameter.from(MacAddress.class, macAddress),
+            ClassParameter.from(CharSequence.class, displayName),
+            ClassParameter.from(String.class, deviceProfile),
+            ClassParameter.from(boolean.class, selfManaged),
+            ClassParameter.from(boolean.class, notifyOnDeviceNearby),
+            ClassParameter.from(long.class, approvedMs),
+            ClassParameter.from(long.class, lastTimeConnectedMs));
+
+      } else if (RuntimeEnvironment.getApiLevel() == U.SDK_INT) {
+        return ReflectionHelpers.callConstructor(
+            AssociationInfo.class,
+            ClassParameter.from(int.class, id),
+            ClassParameter.from(int.class, userId),
+            ClassParameter.from(String.class, packageName),
             ClassParameter.from(MacAddress.class, macAddress),
             ClassParameter.from(CharSequence.class, displayName),
             ClassParameter.from(String.class, deviceProfile),
@@ -220,45 +146,36 @@ public class AssociationInfoBuilder {
             ClassParameter.from(boolean.class, selfManaged),
             ClassParameter.from(boolean.class, notifyOnDeviceNearby),
             ClassParameter.from(boolean.class, revoked),
-            ClassParameter.from(boolean.class, pending),
             ClassParameter.from(long.class, approvedMs),
             ClassParameter.from(long.class, lastTimeConnectedMs),
             ClassParameter.from(int.class, systemDataSyncFlags));
+      } else {
+        // delegate to platform builder
+        AssociationInfo.Builder builder =
+            new AssociationInfo.Builder(id, userId, packageName)
+                .setDeviceMacAddress(macAddress)
+                .setDisplayName(displayName)
+                .setDeviceProfile(deviceProfile)
+                .setAssociatedDevice((AssociatedDevice) associatedDevice)
+                .setSelfManaged(selfManaged)
+                .setNotifyOnDeviceNearby(notifyOnDeviceNearby)
+                .setTimeApproved(approvedMs)
+                .setRevoked(revoked)
+                .setLastTimeConnected(lastTimeConnectedMs)
+                .setSystemDataSyncFlags(systemDataSyncFlags);
+        // setTag was removed in Baklava
+        if (tag != null) {
+          reflector(BuilderReflector.class, builder).setTag(tag);
+        }
+        return builder.build();
       }
     } catch (ClassNotFoundException e) {
       throw new RuntimeException(e);
     }
   }
 
-  private static int getNumOfConstructorParams() {
-    for (java.lang.reflect.Constructor<?> constructor :
-        AssociationInfo.class.getDeclaredConstructors()) {
-      if (constructor.getParameterCount() > 1) {
-        return constructor.getParameterCount();
-      }
-    }
-    throw new IllegalStateException("Could not find a AssociationInfo constructor");
-  }
-
-  @ForType(AssociationInfo.class)
-  interface AssociationInfoReflector {
-    @Constructor
-    AssociationInfo nwwAssociationInfoPostV(
-        int id,
-        int userId,
-        String packageName,
-        String tag,
-        MacAddress macAddress,
-        CharSequence displayName,
-        String deviceProfile,
-        @WithType("android.companion.AssociatedDevice") Object associatedDevice,
-        boolean selfManaged,
-        boolean notifyOnDeviceNearby,
-        boolean revoked,
-        boolean pending,
-        long timeApprovedMs,
-        long lastTimeConnectedMs,
-        int systemDataSyncFlags,
-        Icon icon);
+  @ForType(AssociationInfo.Builder.class)
+  private interface BuilderReflector {
+    void setTag(String tag);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/AudioDeviceInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/AudioDeviceInfoBuilder.java
index b092d1d64..c8a4881f1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/AudioDeviceInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/AudioDeviceInfoBuilder.java
@@ -11,7 +11,6 @@ import android.util.SparseIntArray;
 import com.google.common.collect.ImmutableList;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.List;
-import java.util.Optional;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
@@ -82,13 +81,6 @@ public class AudioDeviceInfoBuilder {
   }
 
   private static int externalToInternalType(int externalType) {
-    return Optional.ofNullable(
-            reflector(AudioDeviceInfoReflector.class).getExtToIntDeviceMapping().get(externalType))
-        .orElseThrow(
-            () ->
-                new IllegalArgumentException(
-                    "External type "
-                        + externalType
-                        + " does not have a mapping to an internal type defined."));
+    return reflector(AudioDeviceInfoReflector.class).getExtToIntDeviceMapping().get(externalType);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java
new file mode 100644
index 000000000..d61d599f2
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java
@@ -0,0 +1,67 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertisingSetCallback;
+import android.bluetooth.le.AdvertisingSetParameters;
+import android.bluetooth.le.IAdvertisingSetCallback;
+import android.bluetooth.le.PeriodicAdvertisingParameters;
+import android.content.AttributionSource;
+import android.os.IBinder;
+import android.os.RemoteException;
+import org.robolectric.shadows.BluetoothGattProxyDelegate.IAdvertisingSetCallbackReflectorV;
+import org.robolectric.util.ReflectionHelpers;
+
+/** Delegating proxy for the IBluetoothAdvertise system service */
+@SuppressWarnings("unused") // methods called via reflection
+class BluetoothAdvertiseProxyDelegate {
+
+  private BluetoothAdvertiseProxyDelegate() {}
+
+  /**
+   * Creates a fake/stub implementation of the IBluetoothAdvertise system service for the current
+   * API level.
+   *
+   * <p>It is recommended to cache the result
+   */
+  static /* IBluetoothAdvertise */ Object createBluetoothAdvertiseProxy() {
+    try {
+      return ReflectionHelpers.createDelegatingProxy(
+          Class.forName("android.bluetooth.IBluetoothAdvertise"),
+          new BluetoothAdvertiseProxyDelegate());
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public void startAdvertisingSet(
+      AdvertisingSetParameters parameters,
+      AdvertiseData advertiseData,
+      AdvertiseData scanResponse,
+      PeriodicAdvertisingParameters periodicParameters,
+      AdvertiseData periodicData,
+      int duration,
+      int maxExtAdvEvents,
+      int gattServerIf,
+      IAdvertisingSetCallback callback,
+      AttributionSource attributionSource) {
+
+    reflector(IAdvertisingSetCallbackReflectorV.class, callback)
+        .onAdvertisingSetStarted(
+            ReflectionHelpers.createNullProxy(IBinder.class),
+            0,
+            parameters.getTxPowerLevel(),
+            AdvertisingSetCallback.ADVERTISE_SUCCESS);
+  }
+
+  public void stopAdvertisingSet(
+      IAdvertisingSetCallback callback, AttributionSource attributionSource) {
+    try {
+      callback.onAdvertisingSetStopped(0 /* advertiserId */);
+    } catch (RemoteException e) {
+      // should never happen
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothGattProxyDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothGattProxyDelegate.java
index 4a805504c..af8a6d22b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothGattProxyDelegate.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothGattProxyDelegate.java
@@ -161,14 +161,14 @@ class BluetoothGattProxyDelegate {
   }
 
   @ForType(IAdvertisingSetCallback.class)
-  private interface IAdvertisingSetCallbackReflectorV {
+  interface IAdvertisingSetCallbackReflectorV {
     // for android V
     void onAdvertisingSetStarted(IBinder binder, int advertiserId, int txPower, int status);
   }
 
   @ForType(
       className = "com.android.bluetooth.x.com.android.modules.utils.SynchronousResultReceiver")
-  private interface SynchronousResultReceiverReflector {
+  interface SynchronousResultReceiverReflector {
     void send(Object value);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java b/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java
index 2559db6fd..2371dbfc0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java
@@ -8,7 +8,6 @@ import java.util.List;
 import org.robolectric.res.AttrData;
 import org.robolectric.res.ResType;
 import org.robolectric.res.TypedResource;
-import org.robolectric.util.Util;
 
 @SuppressWarnings("NewApi")
 public class Converter<T> {
@@ -177,12 +176,7 @@ public class Converter<T> {
     @Override
     public boolean fillTypedValue(String data, TypedValue typedValue) {
       try {
-        if (data.startsWith("0x")) {
-          typedValue.type =
-              data.startsWith("0x") ? TypedValue.TYPE_INT_HEX : TypedValue.TYPE_INT_DEC;
-        } else {
-          typedValue.type = TypedValue.TYPE_INT_DEC;
-        }
+        typedValue.type = data.startsWith("0x") ? TypedValue.TYPE_INT_HEX : TypedValue.TYPE_INT_DEC;
         typedValue.data = convertInt(data);
         typedValue.assetCookie = 0;
         typedValue.string = null;
@@ -333,7 +327,7 @@ public class Converter<T> {
           throw new Resources.NotFoundException("no value found for " + key);
         }
       }
-      return Util.parseInt(valueFor);
+      return Integer.decode(valueFor);
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java b/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java
index 532137758..443192d1d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import android.util.TypedValue;
 import org.robolectric.res.AttrData;
-import org.robolectric.util.Util;
 
 public class Converter2<T> {
   private static int nextStringCookie = 0xbaaa5;
@@ -207,7 +206,7 @@ public class Converter2<T> {
           throw new RuntimeException("no value found for " + key);
         }
       }
-      return Util.parseInt(valueFor);
+      return Integer.decode(valueFor);
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/DragEventBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/DragEventBuilder.java
index 9362f61a0..c34e9e4ef 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/DragEventBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/DragEventBuilder.java
@@ -4,12 +4,12 @@ import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 
-import android.annotation.Nullable;
 import android.content.ClipData;
 import android.content.ClipDescription;
 import android.view.DragEvent;
 import android.view.SurfaceControl;
 import com.android.internal.view.IDragAndDropPermissions;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
@@ -105,6 +105,38 @@ public class DragEventBuilder {
           ClassParameter.from(SurfaceControl.class, null),
           ClassParameter.from(IDragAndDropPermissions.class, null),
           ClassParameter.from(boolean.class, result));
+    } else if (ReflectionHelpers.hasMethod(
+        DragEvent.class,
+        "obtain",
+        int.class,
+        float.class,
+        float.class,
+        float.class,
+        float.class,
+        int.class,
+        int.class,
+        Object.class,
+        ClipDescription.class,
+        ClipData.class,
+        SurfaceControl.class,
+        IDragAndDropPermissions.class,
+        boolean.class)) {
+      return ReflectionHelpers.callStaticMethod(
+          DragEvent.class,
+          "obtain",
+          ClassParameter.from(int.class, action),
+          ClassParameter.from(float.class, x),
+          ClassParameter.from(float.class, y),
+          ClassParameter.from(float.class, 0),
+          ClassParameter.from(float.class, 0),
+          ClassParameter.from(int.class, ShadowDisplay.getDefaultDisplay().getDisplayId()),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(Object.class, localState),
+          ClassParameter.from(ClipDescription.class, clipDescription),
+          ClassParameter.from(ClipData.class, clipData),
+          ClassParameter.from(SurfaceControl.class, null),
+          ClassParameter.from(IDragAndDropPermissions.class, null),
+          ClassParameter.from(boolean.class, result));
     } else {
       return ReflectionHelpers.callStaticMethod(
           DragEvent.class,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/GnssStatusBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/GnssStatusBuilder.java
index 29b05b48e..383dbb9ad 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/GnssStatusBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/GnssStatusBuilder.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.location.GnssStatus;
 import android.os.Build;
 import com.google.auto.value.AutoValue;
@@ -8,6 +7,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
+import javax.annotation.Nullable;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java b/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
index 0fe29a9b0..e01930a4e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
@@ -42,8 +42,7 @@ public final class HardwareRenderingScreenshot {
 
   /**
    * Indicates whether {@link #takeScreenshot(View, Bitmap)} can run, by validating the API level,
-   * the presence of the {@link #USE_HARDWARE_RENDERER_NATIVE_ENV} property, and the {@link
-   * GraphicsMode}.
+   * the value of the {@link #PIXEL_COPY_RENDER_MODE} property, and the {@link GraphicsMode}.
    */
   static boolean canTakeScreenshot(View view) {
     return RuntimeEnvironment.getApiLevel() >= P
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java
index ba5511aca..1f9ade2ee 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java
@@ -2,8 +2,8 @@ package org.robolectric.shadows;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.annotation.Nullable;
 import android.content.pm.ModuleInfo;
+import javax.annotation.Nullable;
 
 /**
  * Builder for {@link ModuleInfo} as ModuleInfo has hidden constructors, this builder class has been
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java b/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java
index cbda24865..408f94aea 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java
@@ -2,7 +2,10 @@ package org.robolectric.shadows;
 
 import static com.google.common.base.Preconditions.checkState;
 import static org.robolectric.shadows.NativeAndroidInput.AINPUT_EVENT_TYPE_MOTION;
+import static org.robolectric.shadows.NativeAndroidInput.AINPUT_SOURCE_CLASS_JOYSTICK;
 import static org.robolectric.shadows.NativeAndroidInput.AINPUT_SOURCE_CLASS_POINTER;
+import static org.robolectric.shadows.NativeAndroidInput.AINPUT_SOURCE_CLASS_POSITION;
+import static org.robolectric.shadows.NativeAndroidInput.AINPUT_SOURCE_MOUSE_RELATIVE;
 import static org.robolectric.shadows.NativeAndroidInput.AKEY_EVENT_FLAG_CANCELED;
 import static org.robolectric.shadows.NativeAndroidInput.AMOTION_EVENT_ACTION_CANCEL;
 import static org.robolectric.shadows.NativeAndroidInput.AMOTION_EVENT_ACTION_DOWN;
@@ -30,7 +33,9 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Optional;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.res.android.Ref;
+import org.robolectric.versioning.AndroidVersions;
 
 /**
  * Java representation of framework native input Transliterated from oreo-mr1 (SDK 27)
@@ -436,6 +441,9 @@ public class NativeInput {
 
     public float getAxisValue(int axis, int pointerIndex) {
       float value = getRawPointerCoords(pointerIndex).getAxisValue(axis);
+      if (shouldDisregardTransformation(mSource)) {
+        return value;
+      }
       switch (axis) {
         case AMOTION_EVENT_AXIS_X:
           return value + mXOffset;
@@ -507,6 +515,9 @@ public class NativeInput {
 
     public float getHistoricalAxisValue(int axis, int pointerIndex, int historicalIndex) {
       float value = getHistoricalRawPointerCoords(pointerIndex, historicalIndex).getAxisValue(axis);
+      if (shouldDisregardTransformation(mSource)) {
+        return value;
+      }
       switch (axis) {
         case AMOTION_EVENT_AXIS_X:
           return value + mXOffset;
@@ -954,5 +965,26 @@ public class NativeInput {
     List<NativeInput.PointerCoords> getSamplePointerCoords() {
       return mSamplePointerCoords;
     }
+
+    // frameworks/native/libs/input/Input.cpp#isFromSource
+    private static boolean isFromSource(int source, int test) {
+      return (source & test) == test;
+    }
+
+    // frameworks/native/libs/input/Input.cpp#shouldDisregardTransformation
+    private static boolean shouldDisregardTransformation(int source) {
+      // From the ctesque test result, the offsetLocation is not supported by non pointer source
+      // sources from Android 12L. So this method expects itself can work from Android 12L.
+      if (RuntimeEnvironment.getApiLevel() >= AndroidVersions.Sv2.SDK_INT) {
+        // See
+        // https://cs.android.com/android/_/android/platform/frameworks/native/+/7e1ee565b3fe4738e6771bceb2e9679562232992.
+        // Do not apply any transformations to axes from joysticks, touchpads, or relative mice.
+        return isFromSource(source, AINPUT_SOURCE_CLASS_JOYSTICK)
+            || isFromSource(source, AINPUT_SOURCE_CLASS_POSITION)
+            || isFromSource(source, AINPUT_SOURCE_MOUSE_RELATIVE);
+      } else {
+        return false;
+      }
+    }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java
index 393a32d72..5f371f6df 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import android.annotation.Nullable;
 import android.content.pm.VersionedPackage;
 import android.content.rollback.PackageRollbackInfo;
 import android.content.rollback.PackageRollbackInfo.RestoreInfo;
@@ -12,6 +11,7 @@ import android.util.IntArray;
 import android.util.SparseLongArray;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SensorEventBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/SensorEventBuilder.java
index 17d07afe1..3ac523e37 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/SensorEventBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SensorEventBuilder.java
@@ -2,9 +2,9 @@ package org.robolectric.shadows;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import android.annotation.NonNull;
 import android.hardware.Sensor;
 import android.hardware.SensorEvent;
+import javax.annotation.Nonnull;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
@@ -21,7 +21,7 @@ public class SensorEventBuilder {
     return new SensorEventBuilder();
   }
 
-  public SensorEventBuilder setValues(@NonNull float[] value) {
+  public SensorEventBuilder setValues(@Nonnull float[] value) {
     values = value;
     return this;
   }
@@ -30,7 +30,7 @@ public class SensorEventBuilder {
    * If the 'type' property of Sensor is all that is important to your use case, an instance of from
    * ShadowSensor.newInstance(sensorType) should suffice.
    */
-  public SensorEventBuilder setSensor(@NonNull Sensor value) {
+  public SensorEventBuilder setSensor(@Nonnull Sensor value) {
     sourceSensor = value;
     return this;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
index 16c4da75e..ad4b42094 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
@@ -80,7 +80,6 @@ public class ShadowAccessibilityRecord {
     reflector(AccessibilityRecordReflector.class, realRecord).setWindowId(id);
   }
 
-
   public View getSourceRoot() {
     return sourceRoot;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
index 877e21f42..725c4ed8c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
@@ -12,7 +12,6 @@ import android.accounts.AuthenticatorException;
 import android.accounts.IAccountManager;
 import android.accounts.OnAccountsUpdateListener;
 import android.accounts.OperationCanceledException;
-import android.annotation.Nullable;
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
@@ -31,6 +30,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
index 92f4b6ed1..894e5cb1b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
@@ -20,6 +20,7 @@ import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.os.Build.VERSION_CODES;
 import android.os.Handler;
+import android.os.LocaleList;
 import android.os.Process;
 import android.os.UserHandle;
 import android.util.ArrayMap;
@@ -31,6 +32,7 @@ import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.CopyOnWriteArrayList;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
@@ -68,6 +70,8 @@ public class ShadowActivityManager {
   private static final Deque<Object> appExitInfoList = new ArrayDeque<>();
   private ConfigurationInfo configurationInfo;
   private Context context;
+  private static final ArrayList<Locale> supportedLocales = new ArrayList<>();
+  private LocaleList deviceLocales;
 
   @Implementation
   protected void __constructor__(Context context, Handler handler) {
@@ -135,6 +139,25 @@ public class ShadowActivityManager {
     return recentTasks.size() > maxNum ? recentTasks.subList(0, maxNum) : recentTasks;
   }
 
+  /**
+   * Sets the current locales of the device. If the input is {@code null}, sets the {@link
+   * Locale#ENGLISH} as default locale.
+   */
+  @Implementation(minSdk = VERSION_CODES.Q)
+  protected void setDeviceLocales(LocaleList locales) {
+    deviceLocales =
+        locales == null ? LocaleList.forLanguageTags(Locale.ENGLISH.toLanguageTag()) : locales;
+  }
+
+  /**
+   * Gets the values set by {@link #setDeviceLocales(LocaleList)}.
+   *
+   * @return an {@link LocaleList} object contains the current locales.
+   */
+  public LocaleList getDeviceLocales() {
+    return deviceLocales;
+  }
+
   @Implementation
   protected List<ActivityManager.RunningServiceInfo> getRunningServices(int maxNum) {
     return services;
@@ -180,7 +203,7 @@ public class ShadowActivityManager {
     return true;
   }
 
-  @Implementation(minSdk = android.os.Build.VERSION_CODES.Q)
+  @Implementation(minSdk = VERSION_CODES.Q)
   protected boolean switchUser(UserHandle userHandle) {
     return switchUser(userHandle.getIdentifier());
   }
@@ -364,6 +387,7 @@ public class ShadowActivityManager {
     uidImportances.clear();
     appExitInfoList.clear();
     isLowRamDeviceOverride = null;
+    supportedLocales.clear();
   }
 
   /** Returns the background restriction state set by {@link #setBackgroundRestricted}. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
index 7e08ba9de..38d7845dd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
@@ -153,6 +154,9 @@ public class ShadowActivityThread {
             if (method.getName().equals("getSplitPermissions")) {
               return Collections.emptyList();
             }
+            if (method.getName().equals("getPermissionRequestState")) {
+              return PERMISSION_GRANTED;
+            }
             return method.getDefaultValue();
           }
         });
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java
index cc666e81e..dbdb2b949 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static android.app.AlarmManager.RTC_WAKEUP;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.app.AlarmManager;
 import android.app.AlarmManager.AlarmClockInfo;
 import android.app.AlarmManager.OnAlarmListener;
@@ -24,6 +23,7 @@ import java.util.PriorityQueue;
 import java.util.TimeZone;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java
index 25642f71c..39328ed9e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.app.PendingIntent;
 import android.app.ambientcontext.AmbientContextEventRequest;
 import android.app.ambientcontext.AmbientContextManager;
@@ -9,6 +8,7 @@ import com.android.internal.annotations.GuardedBy;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
index 52d85f279..3ce43c969 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
@@ -10,8 +10,6 @@ import static java.util.stream.Collectors.toSet;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.RequiresApi;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
@@ -50,6 +48,8 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.stream.IntStream;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
@@ -226,7 +226,7 @@ public class ShadowAppOpsManager {
   @Implementation(minSdk = Q)
   @HiddenApi
   @SystemApi
-  @NonNull
+  @Nonnull
   protected List<PackageOps> getPackagesForOps(@Nullable String[] ops) {
     List<PackageOps> result = null;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
index 150775e3d..ad56acb28 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
@@ -2,9 +2,9 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.L;
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.app.PendingIntent;
 import android.app.PendingIntent.CanceledException;
 import android.appwidget.AppWidgetHostView;
@@ -28,6 +28,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -50,6 +51,7 @@ public class ShadowAppWidgetManager {
   private static boolean allowedToBindWidgets;
   private static boolean requestPinAppWidgetSupported = false;
   private static boolean validWidgetProviderComponentName = true;
+  private final Map<Integer, RemoteViews> widgetPreviews = new HashMap<>();
   private final ArrayList<AppWidgetProviderInfo> installedProviders = new ArrayList<>();
   private Multimap<UserHandle, AppWidgetProviderInfo> installedProvidersForProfile =
       HashMultimap.create();
@@ -302,6 +304,30 @@ public class ShadowAppWidgetManager {
     return false;
   }
 
+  /** Sets the widget preview for a given widget category in a local HashMap. */
+  @Implementation(minSdk = VANILLA_ICE_CREAM)
+  protected boolean setWidgetPreview(
+      ComponentName provider, int widgetCategories, RemoteViews preview) {
+    widgetPreviews.put(widgetCategories, preview);
+    return true;
+  }
+
+  /**
+   * Gets the widget preview for a given widget category in a local HashMap. The UserHandle is
+   * ignored.
+   */
+  @Implementation(minSdk = VANILLA_ICE_CREAM)
+  protected RemoteViews getWidgetPreview(
+      ComponentName provider, UserHandle user, int widgetCategories) {
+    return widgetPreviews.get(widgetCategories);
+  }
+
+  /** Removes the widget preview for a given widget category in a local HashMap. */
+  @Implementation(minSdk = VANILLA_ICE_CREAM)
+  protected void removeWidgetPreview(ComponentName provider, int widgetCategories) {
+    widgetPreviews.remove(widgetCategories);
+  }
+
   /**
    * Triggers a reapplication of the most recent set of actions against the widget, which is what
    * happens when the phone is rotated. Does not attempt to simulate a change in screen geometry.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
index b7c66b458..ea7abe12b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
@@ -38,8 +38,6 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest.permission;
 import android.annotation.DrawableRes;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.StringRes;
 import android.annotation.UserIdInt;
@@ -115,6 +113,8 @@ import java.util.SortedMap;
 import java.util.concurrent.Executor;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.GetInstallerPackageNameMode;
@@ -1034,7 +1034,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation
-  protected Resources getResourcesForApplication(@NonNull ApplicationInfo applicationInfo)
+  protected Resources getResourcesForApplication(@Nonnull ApplicationInfo applicationInfo)
       throws PackageManager.NameNotFoundException {
     synchronized (lock) {
       if (getContext().getPackageName().equals(applicationInfo.packageName)) {
@@ -1578,12 +1578,12 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = N)
-  protected @NonNull String getServicesSystemSharedLibraryPackageName() {
+  protected @Nonnull String getServicesSystemSharedLibraryPackageName() {
     return null;
   }
 
   @Implementation(minSdk = N)
-  protected @NonNull String getSharedSystemSharedLibraryPackageName() {
+  protected @Nonnull String getSharedSystemSharedLibraryPackageName() {
     return "";
   }
 
@@ -2065,7 +2065,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = M)
-  protected @NonNull List<VolumeInfo> getPrimaryStorageCandidateVolumes() {
+  protected @Nonnull List<VolumeInfo> getPrimaryStorageCandidateVolumes() {
     return null;
   }
 
@@ -2473,7 +2473,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   private interface ReflectorApplicationPackageManager {
 
     @Direct
-    Resources getResourcesForApplication(@NonNull ApplicationInfo applicationInfo);
+    Resources getResourcesForApplication(@Nonnull ApplicationInfo applicationInfo);
 
     @Direct
     Drawable getDrawable(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
index 07f0eabc0..90cac3cd8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
@@ -5,7 +5,6 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static org.robolectric.res.android.Errors.NO_ERROR;
 import static org.robolectric.res.android.Util.ATRACE_NAME;
-import static org.robolectric.res.android.Util.JNI_TRUE;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.res.ApkAssets;
@@ -242,11 +241,9 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
     return apk_assets.GetLoadedArsc().GetStringPool().getNativePtr();
   }
 
-  // static jboolean NativeIsUpToDate(JNIEnv* /*env*/, jclass /*clazz*/, jlong ptr) {
   @Implementation
-  protected static boolean nativeIsUpToDate(long ptr) {
-    // (void)apk_assets;
-    return JNI_TRUE;
+  protected boolean isUpToDate() {
+    return true;
   }
 
   // static jlong NativeOpenXml(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring file_name) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
index 104874187..612ee9919 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
@@ -26,8 +26,6 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.annotation.AnyRes;
 import android.annotation.ArrayRes;
 import android.annotation.AttrRes;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.StyleRes;
 import android.content.res.ApkAssets;
 import android.content.res.AssetManager;
@@ -49,6 +47,8 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -526,7 +526,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P, maxSdk = U.SDK_INT)
   protected static void nativeSetApkAssets(
       long ptr,
-      @NonNull android.content.res.ApkAssets[] apk_assets_array,
+      @Nonnull android.content.res.ApkAssets[] apk_assets_array,
       boolean invalidate_caches) {
     ATRACE_NAME("AssetManager::SetApkAssets");
 
@@ -626,7 +626,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
 
   // static jobject NativeGetAssignedPackageIdentifiers(JNIEnv* env, jclass /*clazz*/, jlong ptr) {
   @Implementation(minSdk = P, maxSdk = Q)
-  protected static @NonNull SparseArray<String> nativeGetAssignedPackageIdentifiers(long ptr) {
+  protected static @Nonnull SparseArray<String> nativeGetAssignedPackageIdentifiers(long ptr) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
 
     SparseArray<String> sparse_array = new SparseArray<>();
@@ -659,7 +659,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
 
   // static jobjectArray NativeList(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring path) {
   @Implementation(minSdk = P)
-  protected static @Nullable String[] nativeList(long ptr, @NonNull String path)
+  protected static @Nullable String[] nativeList(long ptr, @Nonnull String path)
       throws IOException {
     String path_utf8 = path;
     if (path_utf8 == null) {
@@ -701,7 +701,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   // static jlong NativeOpenAsset(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring asset_path,
   //                              jint access_mode) {
   @Implementation(minSdk = P)
-  protected static long nativeOpenAsset(long ptr, @NonNull String asset_path, int access_mode)
+  protected static long nativeOpenAsset(long ptr, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
     String asset_path_utf8 = asset_path;
     if (asset_path_utf8 == null) {
@@ -730,7 +730,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   //                                  jlongArray out_offsets) {
   @Implementation(minSdk = P)
   protected static ParcelFileDescriptor nativeOpenAssetFd(
-      long ptr, @NonNull String asset_path, long[] out_offsets) throws IOException {
+      long ptr, @Nonnull String asset_path, long[] out_offsets) throws IOException {
     String asset_path_utf8 = asset_path;
     if (asset_path_utf8 == null) {
       // This will throw NPE.
@@ -751,7 +751,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   //                                 jstring asset_path, jint access_mode) {
   @Implementation(minSdk = P)
   protected static long nativeOpenNonAsset(
-      long ptr, int jcookie, @NonNull String asset_path, int access_mode)
+      long ptr, int jcookie, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
     String asset_path_utf8 = asset_path;
@@ -788,7 +788,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   //                                     jstring asset_path, jlongArray out_offsets) {
   @Implementation(minSdk = P)
   protected static @Nullable ParcelFileDescriptor nativeOpenNonAssetFd(
-      long ptr, int jcookie, @NonNull String asset_path, @NonNull long[] out_offsets)
+      long ptr, int jcookie, @Nonnull String asset_path, @Nonnull long[] out_offsets)
       throws IOException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
     String asset_path_utf8 = asset_path;
@@ -816,7 +816,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   // static jlong NativeOpenXmlAsset(JNIEnv* env, jobject /*clazz*/, jlong ptr, jint jcookie,
   //                                 jstring asset_path) {
   @Implementation(minSdk = P)
-  protected static long nativeOpenXmlAsset(long ptr, int jcookie, @NonNull String asset_path)
+  protected static long nativeOpenXmlAsset(long ptr, int jcookie, @Nonnull String asset_path)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
     String asset_path_utf8 = asset_path;
@@ -862,7 +862,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       long ptr,
       @AnyRes int resid,
       short density,
-      @NonNull TypedValue typed_value,
+      @Nonnull TypedValue typed_value,
       boolean resolve_references) {
     return PerfStatsCollector.getInstance()
         .measure(
@@ -900,7 +900,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   //                                       jint bag_entry_id, jobject typed_value) {
   @Implementation(minSdk = P)
   protected static int nativeGetResourceBagValue(
-      long ptr, @AnyRes int resid, int bag_entry_id, @NonNull TypedValue typed_value) {
+      long ptr, @AnyRes int resid, int bag_entry_id, @Nonnull TypedValue typed_value) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     ResolvedBag bag = assetmanager.GetBag(resid);
     if (bag == null) {
@@ -1118,7 +1118,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   //                                    jintArray out_data) {
   @Implementation(minSdk = P)
   protected static int nativeGetResourceArray(
-      long ptr, @ArrayRes int resid, @NonNull int[] out_data) {
+      long ptr, @ArrayRes int resid, @Nonnull int[] out_data) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     ResolvedBag bag = assetmanager.GetBag(resid);
     if (bag == null) {
@@ -1177,7 +1177,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   //                                         jstring def_type, jstring def_package) {
   @Implementation(minSdk = P)
   protected static @AnyRes int nativeGetResourceIdentifier(
-      long ptr, @NonNull String name, @Nullable String def_type, @Nullable String def_package) {
+      long ptr, @Nonnull String name, @Nullable String def_type, @Nullable String def_package) {
     String name_utf8 = name;
     if (name_utf8 == null) {
       // This will throw NPE.
@@ -1374,7 +1374,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       @AttrRes int def_style_attr,
       @StyleRes int def_style_resid,
       long xml_parser_ptr,
-      @NonNull int[] java_attrs,
+      @Nonnull int[] java_attrs,
       long out_values_ptr,
       long out_indices_ptr) {
     PerfStatsCollector.getInstance()
@@ -1398,7 +1398,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       @AttrRes int def_style_attr,
       @StyleRes int def_style_resid,
       long xml_parser_ptr,
-      @NonNull int[] java_attrs,
+      @Nonnull int[] java_attrs,
       long out_values_ptr,
       long out_indices_ptr) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
@@ -1445,9 +1445,9 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       @AttrRes int def_style_attr,
       @StyleRes int def_style_resid,
       @Nullable int[] java_values,
-      @NonNull int[] java_attrs,
-      @NonNull int[] out_java_values,
-      @NonNull int[] out_java_indices) {
+      @Nonnull int[] java_attrs,
+      @Nonnull int[] out_java_values,
+      @Nonnull int[] out_java_indices) {
     int attrs_len = java_attrs.length;
     int out_values_len = out_java_values.length;
     if (out_values_len < (attrs_len * STYLE_NUM_ENTRIES)) {
@@ -1535,9 +1535,9 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   protected static boolean nativeRetrieveAttributes(
       long ptr,
       long xml_parser_ptr,
-      @NonNull int[] java_attrs,
-      @NonNull int[] out_java_values,
-      @NonNull int[] out_java_indices) {
+      @Nonnull int[] java_attrs,
+      @Nonnull int[] out_java_values,
+      @Nonnull int[] out_java_indices) {
     int attrs_len = java_attrs.length;
     int out_values_len = out_java_values.length;
     if (out_values_len < (attrs_len * STYLE_NUM_ENTRIES)) {
@@ -1673,7 +1673,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       long ptr,
       long theme_ptr,
       @AttrRes int resid,
-      @NonNull TypedValue typed_value,
+      @Nonnull TypedValue typed_value,
       boolean resolve_references) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Theme theme = Registries.NATIVE_THEME9_REGISTRY.getNativeObject(theme_ptr);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java
index b01322af8..e2585c651 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java
@@ -1,9 +1,9 @@
 package org.robolectric.shadows;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.content.res.ApkAssets;
 import android.content.res.AssetManager;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.InDevelopment;
@@ -83,7 +83,7 @@ public class ShadowArscAssetManager14 extends ShadowArscAssetManager10 {
       /* Used only when locales is null or empty. */
       @Nullable String defaultLocale,
       /* At this moment, only the first element in locales is used and others are ignored. */
-      @NonNull String[] locales,
+      @Nonnull String[] locales,
       int orientation,
       int touchscreen,
       int density,
@@ -133,7 +133,7 @@ public class ShadowArscAssetManager14 extends ShadowArscAssetManager10 {
   @Implementation(minSdk = V.SDK_INT)
   @InDevelopment
   protected static void nativeSetApkAssets(
-      long ptr, @NonNull ApkAssets[] apkAssets, boolean invalidateCaches, boolean preset) {
+      long ptr, @Nonnull ApkAssets[] apkAssets, boolean invalidateCaches, boolean preset) {
     nativeSetApkAssets(ptr, apkAssets, invalidateCaches);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java
index 44787cf0a..70adee336 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java
@@ -25,8 +25,6 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.annotation.AnyRes;
 import android.annotation.ArrayRes;
 import android.annotation.AttrRes;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.StyleRes;
 import android.content.res.ApkAssets;
 import android.content.res.AssetManager;
@@ -48,6 +46,8 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -521,7 +521,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P, maxSdk = U.SDK_INT)
   protected static void nativeSetApkAssets(
       long ptr,
-      @NonNull android.content.res.ApkAssets[] apk_assets_array,
+      @Nonnull android.content.res.ApkAssets[] apk_assets_array,
       boolean invalidate_caches) {
     ATRACE_NAME("AssetManager::SetApkAssets");
 
@@ -621,7 +621,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
 
   // static jobject NativeGetAssignedPackageIdentifiers(JNIEnv* env, jclass /*clazz*/, jlong ptr) {
   @Implementation(minSdk = P, maxSdk = Q)
-  protected static @NonNull SparseArray<String> nativeGetAssignedPackageIdentifiers(long ptr) {
+  protected static @Nonnull SparseArray<String> nativeGetAssignedPackageIdentifiers(long ptr) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
 
     SparseArray<String> sparse_array = new SparseArray<>();
@@ -648,7 +648,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
 
   // static jobjectArray NativeList(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring path) {
   @Implementation(minSdk = P)
-  protected static @Nullable String[] nativeList(long ptr, @NonNull String path)
+  protected static @Nullable String[] nativeList(long ptr, @Nonnull String path)
       throws IOException {
     String path_utf8 = path;
     if (path_utf8 == null) {
@@ -690,7 +690,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   // static jlong NativeOpenAsset(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring asset_path,
   //                              jint access_mode) {
   @Implementation(minSdk = P)
-  protected static long nativeOpenAsset(long ptr, @NonNull String asset_path, int access_mode)
+  protected static long nativeOpenAsset(long ptr, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
     String asset_path_utf8 = asset_path;
     if (asset_path_utf8 == null) {
@@ -719,7 +719,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   //                                  jlongArray out_offsets) {
   @Implementation(minSdk = P)
   protected static ParcelFileDescriptor nativeOpenAssetFd(
-      long ptr, @NonNull String asset_path, long[] out_offsets) throws IOException {
+      long ptr, @Nonnull String asset_path, long[] out_offsets) throws IOException {
     String asset_path_utf8 = asset_path;
     if (asset_path_utf8 == null) {
       // This will throw NPE.
@@ -740,7 +740,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   //                                 jstring asset_path, jint access_mode) {
   @Implementation(minSdk = P)
   protected static long nativeOpenNonAsset(
-      long ptr, int jcookie, @NonNull String asset_path, int access_mode)
+      long ptr, int jcookie, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
     String asset_path_utf8 = asset_path;
@@ -777,7 +777,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   //                                     jstring asset_path, jlongArray out_offsets) {
   @Implementation(minSdk = P)
   protected static @Nullable ParcelFileDescriptor nativeOpenNonAssetFd(
-      long ptr, int jcookie, @NonNull String asset_path, @NonNull long[] out_offsets)
+      long ptr, int jcookie, @Nonnull String asset_path, @Nonnull long[] out_offsets)
       throws IOException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
     String asset_path_utf8 = asset_path;
@@ -805,7 +805,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   // static jlong NativeOpenXmlAsset(JNIEnv* env, jobject /*clazz*/, jlong ptr, jint jcookie,
   //                                 jstring asset_path) {
   @Implementation(minSdk = P)
-  protected static long nativeOpenXmlAsset(long ptr, int jcookie, @NonNull String asset_path)
+  protected static long nativeOpenXmlAsset(long ptr, int jcookie, @Nonnull String asset_path)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
     String asset_path_utf8 = asset_path;
@@ -851,7 +851,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       long ptr,
       @AnyRes int resid,
       short density,
-      @NonNull TypedValue typed_value,
+      @Nonnull TypedValue typed_value,
       boolean resolve_references) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     final Ref<Res_value> value = new Ref<>(null);
@@ -879,7 +879,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   //                                       jint bag_entry_id, jobject typed_value) {
   @Implementation(minSdk = P)
   protected static int nativeGetResourceBagValue(
-      long ptr, @AnyRes int resid, int bag_entry_id, @NonNull TypedValue typed_value) {
+      long ptr, @AnyRes int resid, int bag_entry_id, @Nonnull TypedValue typed_value) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     ResolvedBag bag = assetmanager.GetBag(resid);
     if (bag == null) {
@@ -1098,7 +1098,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   //                                    jintArray out_data) {
   @Implementation(minSdk = P)
   protected static int nativeGetResourceArray(
-      long ptr, @ArrayRes int resid, @NonNull int[] out_data) {
+      long ptr, @ArrayRes int resid, @Nonnull int[] out_data) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     ResolvedBag bag = assetmanager.GetBag(resid);
     if (bag == null) {
@@ -1157,7 +1157,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   //                                         jstring def_type, jstring def_package) {
   @Implementation(minSdk = P)
   protected static @AnyRes int nativeGetResourceIdentifier(
-      long ptr, @NonNull String name, @Nullable String def_type, @Nullable String def_package) {
+      long ptr, @Nonnull String name, @Nullable String def_type, @Nullable String def_package) {
     String name_utf8 = name;
     if (name_utf8 == null) {
       // This will throw NPE.
@@ -1354,7 +1354,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       @AttrRes int def_style_attr,
       @StyleRes int def_style_resid,
       long xml_parser_ptr,
-      @NonNull int[] java_attrs,
+      @Nonnull int[] java_attrs,
       long out_values_ptr,
       long out_indices_ptr) {
     PerfStatsCollector.getInstance()
@@ -1378,7 +1378,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       @AttrRes int def_style_attr,
       @StyleRes int def_style_resid,
       long xml_parser_ptr,
-      @NonNull int[] java_attrs,
+      @Nonnull int[] java_attrs,
       long out_values_ptr,
       long out_indices_ptr) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
@@ -1425,9 +1425,9 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       @AttrRes int def_style_attr,
       @StyleRes int def_style_resid,
       @Nullable int[] java_values,
-      @NonNull int[] java_attrs,
-      @NonNull int[] out_java_values,
-      @NonNull int[] out_java_indices) {
+      @Nonnull int[] java_attrs,
+      @Nonnull int[] out_java_values,
+      @Nonnull int[] out_java_indices) {
     int attrs_len = java_attrs.length;
     int out_values_len = out_java_values.length;
     if (out_values_len < (attrs_len * STYLE_NUM_ENTRIES)) {
@@ -1515,9 +1515,9 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   protected static boolean nativeRetrieveAttributes(
       long ptr,
       long xml_parser_ptr,
-      @NonNull int[] java_attrs,
-      @NonNull int[] out_java_values,
-      @NonNull int[] out_java_indices) {
+      @Nonnull int[] java_attrs,
+      @Nonnull int[] out_java_values,
+      @Nonnull int[] out_java_indices) {
     int attrs_len = java_attrs.length;
     int out_values_len = out_java_values.length;
     if (out_values_len < (attrs_len * STYLE_NUM_ENTRIES)) {
@@ -1646,7 +1646,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       long ptr,
       long theme_ptr,
       @AttrRes int resid,
-      @NonNull TypedValue typed_value,
+      @Nonnull TypedValue typed_value,
       boolean resolve_references) {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Theme theme = Registries.NATIVE_THEME9_REGISTRY.getNativeObject(theme_ptr);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
index 5e0f186c4..649ffb232 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
@@ -1,7 +1,5 @@
 package org.robolectric.shadows;
 
-
-
 @SuppressWarnings("UnusedDeclaration")
 public abstract class ShadowAssetInputStream {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
index a0eb64b31..5b7014bde 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
@@ -12,7 +12,6 @@ import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
 import android.annotation.RequiresPermission;
 import android.annotation.TargetApi;
 import android.media.AudioAttributes;
@@ -41,6 +40,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
@@ -474,21 +474,21 @@ public class ShadowAudioManager {
    * </ol>
    */
   @Implementation(minSdk = R)
-  @NonNull
+  @Nonnull
   protected List</*android.media.AudioDeviceAttributes*/ ?> getDevicesForAttributes(
-      @NonNull AudioAttributes attributes) {
+      @Nonnull AudioAttributes attributes) {
     ImmutableList<Object> devices = devicesForAttributes.get(attributes);
     return devices == null ? defaultDevicesForAttributes : devices;
   }
 
   /** Sets the devices associated with the given audio stream. */
   public void setDevicesForAttributes(
-      @NonNull AudioAttributes attributes, @NonNull ImmutableList<Object> devices) {
+      @Nonnull AudioAttributes attributes, @Nonnull ImmutableList<Object> devices) {
     devicesForAttributes.put(attributes, devices);
   }
 
   /** Sets the devices to use as default for all audio streams. */
-  public void setDefaultDevicesForAttributes(@NonNull ImmutableList<Object> devices) {
+  public void setDefaultDevicesForAttributes(@Nonnull ImmutableList<Object> devices) {
     defaultDevicesForAttributes = devices;
   }
 
@@ -500,16 +500,16 @@ public class ShadowAudioManager {
    * return value of this method.
    */
   @Implementation(minSdk = TIRAMISU)
-  @NonNull
+  @Nonnull
   protected List<AudioDeviceInfo> getAudioDevicesForAttributes(
-      @NonNull AudioAttributes attributes) {
+      @Nonnull AudioAttributes attributes) {
     ImmutableList<AudioDeviceInfo> devices = audioDevicesForAttributes.get(attributes);
     return devices == null ? ImmutableList.of() : devices;
   }
 
   /** Sets the audio devices returned from {@link #getAudioDevicesForAttributes}. */
   public void setAudioDevicesForAttributes(
-      @NonNull AudioAttributes attributes, @NonNull ImmutableList<AudioDeviceInfo> devices) {
+      @Nonnull AudioAttributes attributes, @Nonnull ImmutableList<AudioDeviceInfo> devices) {
     audioDevicesForAttributes.put(attributes, devices);
   }
 
@@ -973,7 +973,7 @@ public class ShadowAudioManager {
   @Implementation(minSdk = P)
   @RequiresPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING)
   protected int registerAudioPolicy(
-      @NonNull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
+      @Nonnull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
     Preconditions.checkNotNull(audioPolicy, "Illegal null AudioPolicy argument");
     AudioPolicy policy = (AudioPolicy) audioPolicy;
     String id = getIdForAudioPolicy(audioPolicy);
@@ -988,7 +988,7 @@ public class ShadowAudioManager {
   @HiddenApi
   @Implementation(minSdk = Q)
   protected void unregisterAudioPolicy(
-      @NonNull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
+      @Nonnull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
     Preconditions.checkNotNull(audioPolicy, "Illegal null AudioPolicy argument");
     AudioPolicy policy = (AudioPolicy) audioPolicy;
     registeredAudioPolicies.remove(getIdForAudioPolicy(policy));
@@ -1010,8 +1010,8 @@ public class ShadowAudioManager {
    * #removeOutputDeviceWithDirectProfiles(AudioDeviceInfo)}.
    */
   @Implementation(minSdk = TIRAMISU)
-  @NonNull
-  protected List<AudioProfile> getDirectProfilesForAttributes(@NonNull AudioAttributes attributes) {
+  @Nonnull
+  protected List<AudioProfile> getDirectProfilesForAttributes(@Nonnull AudioAttributes attributes) {
     ImmutableSet.Builder<AudioProfile> audioProfiles = new ImmutableSet.Builder<>();
     for (int i = 0; i < outputDevicesWithDirectProfiles.size(); i++) {
       audioProfiles.addAll(outputDevicesWithDirectProfiles.get(i).getAudioProfiles());
@@ -1057,7 +1057,7 @@ public class ShadowAudioManager {
     return audioSessionIdCounter++;
   }
 
-  private static String getIdForAudioPolicy(@NonNull Object audioPolicy) {
+  private static String getIdForAudioPolicy(@Nonnull Object audioPolicy) {
     return Integer.toString(System.identityHashCode(audioPolicy));
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
index 1cfa80680..630160ad9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
@@ -6,7 +6,6 @@ import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.annotation.NonNull;
 import android.media.AudioAttributes;
 import android.media.AudioFormat;
 import android.media.AudioSystem;
@@ -17,6 +16,7 @@ import com.google.common.collect.Multimaps;
 import com.google.common.collect.Table;
 import com.google.common.collect.Tables;
 import java.util.Optional;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -95,7 +95,7 @@ public class ShadowAudioSystem {
    *     and {@link AudioSystem#DIRECT_BITSTREAM_SUPPORTED}
    */
   public static void setDirectPlaybackSupport(
-      @NonNull AudioFormat format, @NonNull AudioAttributes attr, int directPlaybackSupport) {
+      @Nonnull AudioFormat format, @Nonnull AudioAttributes attr, int directPlaybackSupport) {
     checkNotNull(format, "Illegal null AudioFormat");
     checkNotNull(attr, "Illegal null AudioAttributes");
     directPlaybackSupportTable.put(format, attr.getUsage(), directPlaybackSupport);
@@ -112,7 +112,7 @@ public class ShadowAudioSystem {
    */
   @Implementation(minSdk = TIRAMISU)
   protected static int getDirectPlaybackSupport(
-      @NonNull AudioFormat format, @NonNull AudioAttributes attr) {
+      @Nonnull AudioFormat format, @Nonnull AudioAttributes attr) {
     return Optional.ofNullable(directPlaybackSupportTable.get(format, attr.getUsage()))
         .orElse(AudioSystem.DIRECT_NOT_SUPPORTED);
   }
@@ -129,7 +129,7 @@ public class ShadowAudioSystem {
    *     AudioSystem#OFFLOAD_SUPPORTED} or {@link AudioSystem#OFFLOAD_GAPLESS_SUPPORTED}.
    */
   public static void setOffloadPlaybackSupport(
-      @NonNull AudioFormat format, @NonNull AudioAttributes attr, int offloadSupport) {
+      @Nonnull AudioFormat format, @Nonnull AudioAttributes attr, int offloadSupport) {
     checkNotNull(format, "Illegal null AudioFormat");
     checkNotNull(attr, "Illegal null AudioAttributes");
     offloadPlaybackSupportTable.put(
@@ -151,7 +151,7 @@ public class ShadowAudioSystem {
    * @param attr the {@link AudioAttributes} to be used for playback
    */
   public static void setOffloadSupported(
-      @NonNull AudioFormat format, @NonNull AudioAttributes attr, boolean supported) {
+      @Nonnull AudioFormat format, @Nonnull AudioAttributes attr, boolean supported) {
     OffloadSupportFormat offloadSupportFormat =
         new OffloadSupportFormat(
             format.getEncoding(),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
index 84b91d4ea..7e02b6ade 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
@@ -1,8 +1,10 @@
 package org.robolectric.shadows;
 
 import static android.media.AudioTrack.ERROR_DEAD_OBJECT;
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
@@ -12,8 +14,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.robolectric.shadow.api.Shadow.directlyOn;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.RequiresApi;
 import android.media.AudioAttributes;
 import android.media.AudioDeviceInfo;
@@ -36,6 +36,8 @@ import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -66,7 +68,7 @@ public class ShadowAudioTrack {
      * @param audioData The data that is written to the {@link ShadowAudioTrack}.
      * @param format The output format of the {@link ShadowAudioTrack}.
      */
-    void onAudioDataWritten(ShadowAudioTrack audioTrack, byte[] audioData, AudioFormat format);
+    void onAudioDataWritten(AudioTrack audioTrack, byte[] audioData, AudioFormat format);
   }
 
   protected static final int DEFAULT_MIN_BUFFER_SIZE = 1024;
@@ -97,8 +99,12 @@ public class ShadowAudioTrack {
 
   private int numBytesReceived;
   private PlaybackParams playbackParams;
+  private int latencyMs;
   @RealObject AudioTrack audioTrack;
 
+  /** The buffer size to be returned by {@link AudioTrack#getBufferSizeInFrames()}. */
+  private int bufferSizeInFrames;
+
   /**
    * In the real class, the minimum buffer size is estimated from audio sample rate and other
    * factors. We do not provide such estimation in {@link #native_get_min_buff_size(int, int, int)},
@@ -125,7 +131,7 @@ public class ShadowAudioTrack {
    * @param attr The {@link AudioAttributes}.
    */
   public static void addDirectPlaybackSupport(
-      @NonNull AudioFormat format, @NonNull AudioAttributes attr) {
+      @Nonnull AudioFormat format, @Nonnull AudioAttributes attr) {
     checkNotNull(format);
     checkNotNull(attr);
     checkArgument(!isPcm(format.getEncoding()));
@@ -211,6 +217,54 @@ public class ShadowAudioTrack {
     return minBufferSize;
   }
 
+  @Implementation(minSdk = M, maxSdk = M)
+  protected int native_get_native_frame_count() {
+    return bufferSizeInFrames;
+  }
+
+  @Implementation(minSdk = N)
+  protected int native_get_buffer_size_frames() {
+    return bufferSizeInFrames;
+  }
+
+  private void setBufferSizeInFrames(int buffSizeInBytes) {
+    bufferSizeInFrames =
+        isPcm(audioTrack.getAudioFormat())
+            ? buffSizeInBytes / getFrameSizeInBytes()
+            : buffSizeInBytes;
+  }
+
+  @Implementation(minSdk = M, maxSdk = M)
+  protected int native_setup(
+      Object /*WeakReference<AudioTrack>*/ audioTrack,
+      Object /*AudioAttributes*/ attributes,
+      int sampleRate,
+      int channelMask,
+      int channelIndexMask,
+      int audioFormat,
+      int buffSizeInBytes,
+      int mode,
+      int[] sessionId) {
+    setBufferSizeInFrames(buffSizeInBytes);
+    return AudioTrack.SUCCESS;
+  }
+
+  @Implementation(minSdk = N, maxSdk = O_MR1)
+  protected int native_setup(
+      Object /*WeakReference<AudioTrack>*/ audioTrack,
+      Object /*AudioAttributes*/ attributes,
+      int[] sampleRate,
+      int channelMask,
+      int channelIndexMask,
+      int audioFormat,
+      int buffSizeInBytes,
+      int mode,
+      int[] sessionId,
+      long nativeAudioTrack) {
+    setBufferSizeInFrames(buffSizeInBytes);
+    return AudioTrack.SUCCESS;
+  }
+
   @Implementation(minSdk = P, maxSdk = Q)
   protected int native_setup(
       Object /*WeakReference<AudioTrack>*/ audioTrack,
@@ -228,6 +282,7 @@ public class ShadowAudioTrack {
     if (!offload && !isPcm(audioFormat) && !allowedNonPcmEncodings.contains(audioFormat)) {
       return AUDIOTRACK_ERROR_SETUP_NATIVEINITFAILED;
     }
+    setBufferSizeInFrames(buffSizeInBytes);
     return AudioTrack.SUCCESS;
   }
 
@@ -250,6 +305,7 @@ public class ShadowAudioTrack {
     if (!offload && !isPcm(audioFormat) && !allowedNonPcmEncodings.contains(audioFormat)) {
       return AUDIOTRACK_ERROR_SETUP_NATIVEINITFAILED;
     }
+    setBufferSizeInFrames(buffSizeInBytes);
     return AudioTrack.SUCCESS;
   }
 
@@ -273,6 +329,7 @@ public class ShadowAudioTrack {
     if (!offload && !isPcm(audioFormat) && !allowedNonPcmEncodings.contains(audioFormat)) {
       return AUDIOTRACK_ERROR_SETUP_NATIVEINITFAILED;
     }
+    setBufferSizeInFrames(buffSizeInBytes);
     return AudioTrack.SUCCESS;
   }
 
@@ -287,16 +344,17 @@ public class ShadowAudioTrack {
       int buffSizeInBytes,
       int mode,
       int[] sessionId,
-      @NonNull Parcel attributionSource,
+      @Nonnull Parcel attributionSource,
       long nativeAudioTrack,
       boolean offload,
       int encapsulationMode,
       Object tunerConfiguration,
-      @NonNull String opPackageName) {
+      @Nonnull String opPackageName) {
     // If offload, AudioTrack.Builder.build() has checked offload support via AudioSystem.
     if (!offload && !isPcm(audioFormat) && !allowedNonPcmEncodings.contains(audioFormat)) {
       return AUDIOTRACK_ERROR_SETUP_NATIVEINITFAILED;
     }
+    setBufferSizeInFrames(buffSizeInBytes);
     return AudioTrack.SUCCESS;
   }
 
@@ -351,7 +409,7 @@ public class ShadowAudioTrack {
 
     numBytesReceived += audioData.length;
     for (OnAudioDataWrittenListener listener : audioDataWrittenListeners) {
-      listener.onAudioDataWritten(this, audioData, audioTrack.getFormat());
+      listener.onAudioDataWritten(audioTrack, audioData, audioTrack.getFormat());
     }
 
     return audioData.length;
@@ -364,7 +422,7 @@ public class ShadowAudioTrack {
 
   @Implementation(minSdk = N)
   protected void addOnRoutingChangedListener(
-      @NonNull OnRoutingChangedListener listener, Handler handler) {
+      @Nonnull OnRoutingChangedListener listener, Handler handler) {
     OnRoutingChangedListenerInfo listenerInfo =
         new OnRoutingChangedListenerInfo(listener, audioTrack, handler);
     onRoutingChangedListeners.add(listenerInfo);
@@ -374,25 +432,40 @@ public class ShadowAudioTrack {
   }
 
   @Implementation(minSdk = N)
-  protected void removeOnRoutingChangedListener(@NonNull OnRoutingChangedListener listener) {
+  protected void removeOnRoutingChangedListener(@Nonnull OnRoutingChangedListener listener) {
     onRoutingChangedListeners.removeIf(
         registeredListener -> registeredListener.listener.equals(listener));
   }
 
   @Implementation(minSdk = M)
-  public void setPlaybackParams(@NonNull PlaybackParams params) {
+  public void setPlaybackParams(@Nonnull PlaybackParams params) {
     playbackParams = checkNotNull(params, "Illegal null params");
   }
 
+  /**
+   * Sets the estimated latency of this {@link AudioTrack} that will be returned by {@code
+   * AudioTrack.getLatency()}, in milliseconds.
+   */
+  @RequiresApi(LOLLIPOP)
+  public void setLatency(int latencyMs) {
+    this.latencyMs = latencyMs;
+  }
+
+  /** Returns the estimated latency of this {@link AudioTrack}, in milliseconds. */
+  @Implementation(minSdk = LOLLIPOP)
+  protected int native_get_latency() {
+    return latencyMs;
+  }
+
   @Implementation(minSdk = M)
-  @NonNull
+  @Nonnull
   protected PlaybackParams getPlaybackParams() {
     return playbackParams;
   }
 
   @Implementation
   protected int getPlaybackHeadPosition() {
-    return numBytesReceived / audioTrack.getFormat().getFrameSizeInBytes();
+    return numBytesReceived / getFrameSizeInBytes();
   }
 
   @Implementation
@@ -454,6 +527,72 @@ public class ShadowAudioTrack {
     }
   }
 
+  /**
+   * Return the frame size in bytes. See {@link AudioFormat#getFrameSizeInBytes()}.
+   *
+   * <p>As {@link AudioFormat#getFrameSizeInBytes()} is only available from API 29, this method
+   * manually calculates the frame size in bytes from encoding and channel count for APIs lower than
+   * 29, which further supports {@link #getPlaybackHeadPosition()} (available from API 3) for APIs
+   * lower than 29.
+   */
+  private int getFrameSizeInBytes() {
+    if (VERSION.SDK_INT >= Q) {
+      return audioTrack.getFormat().getFrameSizeInBytes();
+    }
+
+    int frameSizeInBytes;
+    int encoding = audioTrack.getAudioFormat();
+    if (isEncodingLinearPcm(encoding)) {
+      frameSizeInBytes = audioTrack.getChannelCount() * getBytesPerSample(encoding);
+    } else {
+      frameSizeInBytes = 1;
+    }
+    return frameSizeInBytes;
+  }
+
+  private static boolean isEncodingLinearPcm(int encoding) {
+    switch (encoding) {
+      case AudioFormat.ENCODING_PCM_8BIT:
+      case AudioFormat.ENCODING_PCM_16BIT:
+      case AudioFormat.ENCODING_PCM_FLOAT:
+      case AudioFormat.ENCODING_DEFAULT:
+        return true;
+      case AudioFormat.ENCODING_AC3:
+      case AudioFormat.ENCODING_E_AC3:
+      case AudioFormat.ENCODING_E_AC3_JOC:
+      case AudioFormat.ENCODING_DTS:
+      case AudioFormat.ENCODING_DTS_HD:
+      case AudioFormat.ENCODING_MP3:
+      case AudioFormat.ENCODING_AAC_LC:
+      case AudioFormat.ENCODING_AAC_HE_V1:
+      case AudioFormat.ENCODING_AAC_HE_V2:
+      case AudioFormat.ENCODING_IEC61937: // wrapped in PCM but compressed
+      case AudioFormat.ENCODING_AAC_ELD:
+      case AudioFormat.ENCODING_AAC_XHE:
+      case AudioFormat.ENCODING_AC4:
+        return false;
+      case AudioFormat.ENCODING_INVALID:
+      default:
+        throw new IllegalArgumentException("Bad encoding: " + encoding);
+    }
+  }
+
+  private static int getBytesPerSample(int encoding) {
+    switch (encoding) {
+      case AudioFormat.ENCODING_PCM_8BIT:
+        return 1;
+      case AudioFormat.ENCODING_PCM_16BIT:
+      case AudioFormat.ENCODING_IEC61937:
+      case AudioFormat.ENCODING_DEFAULT:
+        return 2;
+      case AudioFormat.ENCODING_PCM_FLOAT:
+        return 4;
+      case AudioFormat.ENCODING_INVALID:
+      default:
+        throw new IllegalArgumentException("Bad encoding: " + encoding);
+    }
+  }
+
   /**
    * Specific fields from {@link AudioFormat} that are used for detection of direct playback
    * support.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
index 5178a33fe..5a4b465b9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
@@ -3,10 +3,10 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 
-import android.annotation.Nullable;
 import android.content.ComponentName;
 import android.service.autofill.FillEventHistory;
 import android.view.autofill.AutofillManager;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataOutput.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataOutput.java
index c2460d213..370c0b722 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataOutput.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataOutput.java
@@ -1,11 +1,11 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.app.backup.BackupDataOutput;
 import com.google.common.collect.ImmutableList;
 import java.io.FileDescriptor;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.ReflectorObject;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java
index 698146fda..8af24a650 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java
@@ -3,9 +3,15 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.Q;
 
 import android.os.Binder;
+import android.os.IBinder.DeathRecipient;
 import android.os.Parcel;
 import android.os.RemoteException;
 import android.os.UserHandle;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -19,6 +25,8 @@ public class ShadowBinder {
   private static Integer callingPid;
   private static UserHandle callingUserHandle;
 
+  private final List<WeakReference<DeathRecipient>> deathRecipients = new ArrayList<>();
+
   @Implementation
   protected boolean transact(int code, Parcel data, Parcel reply, int flags)
       throws RemoteException {
@@ -44,6 +52,30 @@ public class ShadowBinder {
     return result;
   }
 
+  @Implementation
+  protected void linkToDeath(DeathRecipient deathRecipient, int flags) {
+    // The caller must hold a strong reference, the binder does not.
+    deathRecipients.add(new WeakReference<>(deathRecipient));
+  }
+
+  @Implementation
+  protected boolean unlinkToDeath(DeathRecipient deathRecipient, int flags) {
+    WeakReference<DeathRecipient> itemToRemove = null;
+    for (WeakReference<DeathRecipient> item : deathRecipients) {
+      // If the same recipient is registered twice, it must be unregistered twice as well.
+      if (item.get() == deathRecipient) {
+        itemToRemove = item;
+        break;
+      }
+    }
+    if (itemToRemove != null) {
+      deathRecipients.remove(itemToRemove);
+      return true;
+    } else {
+      return false;
+    }
+  }
+
   @Implementation
   protected static int getCallingPid() {
     if (callingPid != null) {
@@ -86,6 +118,14 @@ public class ShadowBinder {
     return android.os.Process.myUserHandle();
   }
 
+  public List<DeathRecipient> getDeathRecipients() {
+    return deathRecipients.stream()
+        .map(Reference::get)
+        // References that have been collected will be null.
+        .filter(Objects::nonNull)
+        .toList();
+  }
+
   public static void setCallingPid(int pid) {
     ShadowBinder.callingPid = pid;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
index 183636434..ce857ff4d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
@@ -32,7 +32,6 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ImageUtil.RobolectricBufferedImage;
-import org.robolectric.util.Join;
 import org.robolectric.util.Logger;
 import org.robolectric.util.NamedStream;
 import org.robolectric.util.ReflectionHelpers;
@@ -346,7 +345,7 @@ public class ShadowBitmapFactory {
     if (options.inJustDecodeBounds) opts.add("inJustDecodeBounds");
     if (options.inSampleSize > 1) opts.add("inSampleSize=" + options.inSampleSize);
 
-    return Join.join(", ", opts);
+    return String.join(", ", opts);
   }
 
   @Resetter
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java
index 77fd608d8..eac7525f4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java
@@ -23,9 +23,11 @@ import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions;
 
 /** Shadow of {@link BluetoothA2dp}. */
 @Implements(BluetoothA2dp.class)
@@ -198,8 +200,15 @@ public class ShadowBluetoothA2dp {
     void verifyDeviceNotNull(BluetoothDevice device, String methodName);
   }
 
-  @Implementation(minSdk = R)
-  protected void verifyDeviceNotNull(BluetoothDevice device, String methodName) {
+  @InDevelopment
+  @Implementation(minSdk = R, maxSdk = AndroidVersions.V.SDK_INT, methodName = "verifyDeviceNotNull")
+  protected void verifyDeviceNotNullPreBaklava(BluetoothDevice device, String methodName) {
     reflector(BluetoothA2dpReflector.class, realObject).verifyDeviceNotNull(device, methodName);
   }
+
+  @InDevelopment
+  @Implementation(minSdk = AndroidVersions.Baklava.SDK_INT)
+  protected static void verifyDeviceNotNull(BluetoothDevice device, String methodName) {
+    reflector(BluetoothA2dpReflector.class).verifyDeviceNotNull(device, methodName);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
index 0d954ae47..f9d5732aa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
@@ -48,8 +48,10 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
@@ -57,6 +59,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.V;
 
 @SuppressWarnings({"UnusedDeclaration"})
@@ -113,6 +116,7 @@ public class ShadowBluetoothAdapter {
   private final Map<Integer, List<BluetoothProfile.ServiceListener>>
       bluetoothProfileServiceListeners = new HashMap<>();
   private IBluetoothGatt ibluetoothGatt;
+  private /* IBluetoothAdvertise */ Object ibluetoothAdvertise;
 
   @Resetter
   public static void reset() {
@@ -794,6 +798,15 @@ public class ShadowBluetoothAdapter {
     return ibluetoothGatt;
   }
 
+  @Implementation(minSdk = Baklava.SDK_INT)
+  @InDevelopment
+  protected @ClassName("android.bluetooth.IBluetoothAdvertise") Object getBluetoothAdvertise() {
+    if (ibluetoothAdvertise == null) {
+      ibluetoothAdvertise = BluetoothAdvertiseProxyDelegate.createBluetoothAdvertiseProxy();
+    }
+    return ibluetoothAdvertise;
+  }
+
   private static final class BackgroundRfcommServerEntry {
     final BluetoothServerSocket serverSocket;
     final PendingIntent pendingIntent;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothPan.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothPan.java
new file mode 100644
index 000000000..e5f53634a
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothPan.java
@@ -0,0 +1,76 @@
+package org.robolectric.shadows;
+
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import com.google.common.collect.ImmutableList;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+
+/** Shadow for {@link BluetoothPan} */
+@Implements(value = BluetoothPan.class, isInAndroidSdk = false)
+public class ShadowBluetoothPan {
+  private final Map<BluetoothDevice, Integer> bluetoothDevices = new HashMap<>();
+
+  /**
+   * Adds the given bluetoothDevice with connectionState to the list of devices returned by {@link
+   * ShadowBluetoothPan#getConnectedDevices} and {@link
+   * ShadowBluetoothPan#getDevicesMatchingConnectionStates}
+   *
+   * @param bluetoothDevice the device to add
+   * @param connectionState the connection state of the device
+   *     <p>The connection state must be one of the following:
+   *     <ul>
+   *       <li>{@link BluetoothProfile#STATE_DISCONNECTED}
+   *       <li>{@link BluetoothProfile#STATE_CONNECTING}
+   *       <li>{@link BluetoothProfile#STATE_CONNECTED}
+   *     </ul>
+   */
+  public void addDevice(BluetoothDevice bluetoothDevice, int connectionState) {
+    bluetoothDevices.put(bluetoothDevice, connectionState);
+  }
+
+  /**
+   * Removes the given bluetoothDevice from the list of devices returned by {@link
+   * ShadowBluetoothPan#getConnectedDevices} and {@link
+   * ShadowBluetoothPan#getDevicesMatchingConnectionStates}
+   *
+   * @param bluetoothDevice the device to remove
+   */
+  public void removeDevice(BluetoothDevice bluetoothDevice) {
+    bluetoothDevices.remove(bluetoothDevice);
+  }
+
+  /**
+   * Returns a list of devices that are currently connected.
+   *
+   * @return a list of devices that are currently connected
+   */
+  @Implementation
+  protected List<BluetoothDevice> getConnectedDevices() {
+    return getDevicesMatchingConnectionStates(new int[] {BluetoothProfile.STATE_CONNECTED});
+  }
+
+  /**
+   * Returns a list of devices that match the given connection states.
+   *
+   * @param states the connection states to match
+   * @return a list of devices that match the given connection states
+   */
+  @Implementation
+  protected List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    List<BluetoothDevice> deviceList = new ArrayList<>();
+    for (Map.Entry<BluetoothDevice, Integer> entry : bluetoothDevices.entrySet()) {
+      for (int state : states) {
+        if (entry.getValue() == state) {
+          deviceList.add(entry.getKey());
+        }
+      }
+    }
+    return ImmutableList.copyOf(deviceList);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java
index 08957d9f1..de6347c01 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java
@@ -4,13 +4,13 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 
-import android.annotation.Nullable;
 import android.os.BugreportManager;
 import android.os.BugreportManager.BugreportCallback;
 import android.os.BugreportParams;
 import android.os.ParcelFileDescriptor;
 import java.io.IOException;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCharacteristics.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCharacteristics.java
index 66012f389..2932a6a3f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCharacteristics.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCharacteristics.java
@@ -1,11 +1,11 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.hardware.camera2.CameraCharacteristics;
 import android.hardware.camera2.CameraCharacteristics.Key;
 import com.google.common.base.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
index 58a53cc70..d469e48b6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
 import android.content.Context;
 import android.hardware.camera2.CameraAccessException;
 import android.hardware.camera2.CameraCharacteristics;
@@ -23,6 +22,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.WeakHashMap;
 import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
@@ -89,15 +89,15 @@ public class ShadowCameraManager {
   }
 
   @Implementation
-  @NonNull
+  @Nonnull
   protected String[] getCameraIdList() throws CameraAccessException {
     Set<String> cameraIds = cameraIdToCharacteristics.keySet();
     return cameraIds.toArray(new String[0]);
   }
 
   @Implementation
-  @NonNull
-  protected CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId) {
+  @Nonnull
+  protected CameraCharacteristics getCameraCharacteristics(@Nonnull String cameraId) {
     Preconditions.checkNotNull(cameraId);
     CameraCharacteristics characteristics = cameraIdToCharacteristics.get(cameraId);
     Preconditions.checkArgument(characteristics != null);
@@ -105,7 +105,7 @@ public class ShadowCameraManager {
   }
 
   @Implementation(minSdk = VERSION_CODES.M)
-  protected void setTorchMode(@NonNull String cameraId, boolean enabled) {
+  protected void setTorchMode(@Nonnull String cameraId, boolean enabled) {
     Preconditions.checkNotNull(cameraId);
     Preconditions.checkArgument(cameraIdToCharacteristics.keySet().contains(cameraId));
     cameraTorches.put(cameraId, enabled);
@@ -328,7 +328,7 @@ public class ShadowCameraManager {
    * Calls all registered callbacks's onCameraAvailable method. This is a no-op if no callbacks are
    * registered.
    */
-  private void triggerOnCameraAvailable(@NonNull String cameraId) {
+  private void triggerOnCameraAvailable(@Nonnull String cameraId) {
     Preconditions.checkNotNull(cameraId);
     for (CameraManager.AvailabilityCallback callback : registeredCallbacks) {
       callback.onCameraAvailable(cameraId);
@@ -339,7 +339,7 @@ public class ShadowCameraManager {
    * Calls all registered callbacks's onCameraUnavailable method. This is a no-op if no callbacks
    * are registered.
    */
-  private void triggerOnCameraUnavailable(@NonNull String cameraId) {
+  private void triggerOnCameraUnavailable(@Nonnull String cameraId) {
     Preconditions.checkNotNull(cameraId);
     for (CameraManager.AvailabilityCallback callback : registeredCallbacks) {
       callback.onCameraUnavailable(cameraId);
@@ -353,7 +353,7 @@ public class ShadowCameraManager {
    *
    * @throws IllegalArgumentException if there's already an existing camera with the given id.
    */
-  public void addCamera(@NonNull String cameraId, @NonNull CameraCharacteristics characteristics) {
+  public void addCamera(@Nonnull String cameraId, @Nonnull CameraCharacteristics characteristics) {
     Preconditions.checkNotNull(cameraId);
     Preconditions.checkNotNull(characteristics);
     Preconditions.checkArgument(!cameraIdToCharacteristics.containsKey(cameraId));
@@ -367,7 +367,7 @@ public class ShadowCameraManager {
    *
    * @throws IllegalArgumentException if there is not an existing camera with the given id.
    */
-  public void removeCamera(@NonNull String cameraId) {
+  public void removeCamera(@Nonnull String cameraId) {
     Preconditions.checkNotNull(cameraId);
     Preconditions.checkArgument(cameraIdToCharacteristics.containsKey(cameraId));
 
@@ -376,7 +376,7 @@ public class ShadowCameraManager {
   }
 
   /** Returns what the supplied camera's torch is set to. */
-  public boolean getTorchMode(@NonNull String cameraId) {
+  public boolean getTorchMode(@Nonnull String cameraId) {
     Preconditions.checkNotNull(cameraId);
     Preconditions.checkArgument(cameraIdToCharacteristics.keySet().contains(cameraId));
     Boolean torchState = cameraTorches.get(cameraId);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptioningManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptioningManager.java
index 203e43968..568d3017c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptioningManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptioningManager.java
@@ -6,6 +6,7 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.content.ContentResolver;
 import android.provider.Settings;
 import android.view.accessibility.CaptioningManager;
+import java.util.Locale;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -36,6 +37,24 @@ public class ShadowCaptioningManager {
         == 1;
   }
 
+  /** Sets the enabled state of the captioning manager. */
+  public void setEnabled(boolean enabled) {
+    Settings.Secure.putInt(
+        getContentResolver(), Settings.Secure.ACCESSIBILITY_CAPTIONING_ENABLED, enabled ? 1 : 0);
+  }
+
+  /**
+   * Sets the preferred locale of the captioning manager.
+   *
+   * @param locale The {@link Locale}.
+   */
+  public void setLocale(Locale locale) {
+    Settings.Secure.putString(
+        getContentResolver(),
+        Settings.Secure.ACCESSIBILITY_CAPTIONING_LOCALE,
+        locale.toLanguageTag());
+  }
+
   private ContentResolver getContentResolver() {
     return reflector(CaptioningManagerReflector.class, realCaptioningManager).getContentResolver();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java
index ce5ac233d..1105b9f08 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java
@@ -1,11 +1,11 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.hardware.camera2.CaptureResult;
 import android.hardware.camera2.CaptureResult.Key;
 import com.google.common.base.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
index 22795d84b..028768fe3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
@@ -13,6 +12,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -30,6 +30,9 @@ public class ShadowCardEmulation {
   private static final Set<ComponentName> defaultObserveModeEnabledServices = new HashSet<>();
   private static Map<String, ComponentName> defaultServiceForCategoryMap = new HashMap<>();
   private static ComponentName preferredService = null;
+  private static Map<ComponentName, Map<String, Boolean>> pollingLoopPatternFiltersForService =
+      new HashMap<>();
+  private static String pollingLoopFilterAllowedCharactersRegex = "[a-fA-F0-9\\?\\.\\*]+";
 
   @RealObject CardEmulation cardEmulation;
 
@@ -61,6 +64,40 @@ public class ShadowCardEmulation {
     return true;
   }
 
+  /** Registers a polling loop filter for a service and stores if auto transact is enabled. */
+  @Implementation(minSdk = V.SDK_INT)
+  protected boolean registerPollingLoopPatternFilterForService(
+      ComponentName service, String pollingLoopFilter, boolean autoTransact) {
+    if (pollingLoopFilter.isEmpty()
+        || !pollingLoopFilter.matches(pollingLoopFilterAllowedCharactersRegex)) {
+      return false;
+    }
+
+    if (pollingLoopPatternFiltersForService.containsKey(service)) {
+      pollingLoopPatternFiltersForService.get(service).put(pollingLoopFilter, autoTransact);
+    } else {
+      Map<String, Boolean> pollingLoopFilters = new HashMap<>();
+      pollingLoopFilters.put(pollingLoopFilter, autoTransact);
+      pollingLoopPatternFiltersForService.put(service, pollingLoopFilters);
+    }
+    return true;
+  }
+
+  /** Registers a polling loop filter for a service and stores if auto transact is enabled. */
+  @Implementation(minSdk = V.SDK_INT)
+  protected boolean removePollingLoopPatternFilterForService(
+      ComponentName service, String pollingLoopFilter) {
+    if (pollingLoopFilter.isEmpty()
+        || !pollingLoopFilter.matches(pollingLoopFilterAllowedCharactersRegex)) {
+      return false;
+    }
+
+    if (pollingLoopPatternFiltersForService.containsKey(service)) {
+      pollingLoopPatternFiltersForService.get(service).remove(pollingLoopFilter);
+    }
+    return true;
+  }
+
   /**
    * Modifies the behavior of {@link #isDefaultServiceForCategory(ComponentName, String)} to return
    * {@code true} for the given inputs.
@@ -96,10 +133,21 @@ public class ShadowCardEmulation {
     return defaultObserveModeEnabledServices.contains(service);
   }
 
+  /**
+   * Utility function that returns the list of polling loop filters and their auto transact status
+   * for a given service.
+   */
+  @Nullable
+  public static Map<String, Boolean> getRegisteredPollingLoopPatternFiltersForService(
+      ComponentName service) {
+    return pollingLoopPatternFiltersForService.get(service);
+  }
+
   @Resetter
   public static void reset() {
     defaultServiceForCategoryMap = new HashMap<>();
     preferredService = null;
+    pollingLoopPatternFiltersForService = new HashMap<>();
     CardEmulationReflector reflector = reflector(CardEmulationReflector.class);
     reflector.setIsInitialized(false);
     reflector.setService(null);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
index 3530f1099..ea45b1c00 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
@@ -3,13 +3,13 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.os.PersistableBundle;
 import android.telephony.CarrierConfigManager;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableSet;
 import java.util.HashMap;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -63,8 +63,8 @@ public class ShadowCarrierConfigManager {
    * invalid {@code subId}.
    */
   @Implementation(minSdk = U.SDK_INT)
-  @NonNull
-  public PersistableBundle getConfigForSubId(int subId, @NonNull String... keys) {
+  @Nonnull
+  public PersistableBundle getConfigForSubId(int subId, @Nonnull String... keys) {
     checkReadPhoneStatePermission();
 
     PersistableBundle bundle = getConfigForSubId(subId);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
index 760070a3f..ac38d3d91 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
@@ -40,14 +40,15 @@ public abstract class ShadowChoreographer {
   private ChoreographerReflector reflector;
 
   private static volatile boolean isPaused = false;
-  private static volatile Duration frameDelay = Duration.ofMillis(1);
+
+  private static volatile Duration frameDelay = getDefaultFrameDelay();
 
   /**
    * This field is only used when {@link #isPaused()} is true. It represents the next scheduled
    * vsync time (with respect to the system clock). See the {@link #getNextVsyncTime()} javadoc for
    * more details.
    */
-  private static volatile long nextVsyncTime;
+  private static volatile long nextVsyncTimeNanos;
 
   public static class Picker extends LooperShadowPicker<ShadowChoreographer> {
 
@@ -96,6 +97,14 @@ public abstract class ShadowChoreographer {
     return isPaused;
   }
 
+  /**
+   * @deprecated use {@link #getNextVsyncTimeNanos()} instead
+   */
+  @Deprecated
+  public static long getNextVsyncTime() {
+    return Duration.ofNanos(getNextVsyncTimeNanos()).toMillis();
+  }
+
   /**
    * This field is only used when {@link ShadowChoreographer#isPaused()} is true. It represents the
    * next scheduled vsync time (with respect to the system clock). When the system clock is advanced
@@ -103,12 +112,12 @@ public abstract class ShadowChoreographer {
    * know when the next scheduled vsync time is in order to determine how long to idle the main
    * looper in order to trigger the next Choreographer callback.
    */
-  public static long getNextVsyncTime() {
-    return nextVsyncTime;
+  public static long getNextVsyncTimeNanos() {
+    return nextVsyncTimeNanos;
   }
 
-  static void setNextVsyncTime(long nextVsyncTime) {
-    ShadowChoreographer.nextVsyncTime = nextVsyncTime;
+  static void setNextVsyncTimeNanos(long nextVsyncTimeNanos) {
+    ShadowChoreographer.nextVsyncTimeNanos = nextVsyncTimeNanos;
   }
 
   /**
@@ -199,14 +208,19 @@ public abstract class ShadowChoreographer {
 
   @Resetter
   public static void reset() {
-    nextVsyncTime = 0;
+    nextVsyncTimeNanos = 0;
     isPaused = false;
-    frameDelay = Duration.ofMillis(1);
+    frameDelay = getDefaultFrameDelay();
     if (RuntimeEnvironment.getApiLevel() >= N) {
       ShadowBackdropFrameRenderer.reset();
     }
   }
 
+  private static Duration getDefaultFrameDelay() {
+    // Uses 15ms to approximate 60fps.
+    return Duration.ofMillis(Integer.getInteger("robolectric.defaultFrameDelayMs", 15));
+  }
+
   /** Accessor interface for {@link Choreographer}'s internals */
   @ForType(Choreographer.class)
   protected interface ChoreographerReflector {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
index 18e62c7db..5fdf1faec 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
@@ -5,7 +5,6 @@ import static java.util.stream.Collectors.toCollection;
 import static java.util.stream.Collectors.toList;
 
 import android.Manifest.permission;
-import android.annotation.Nullable;
 import android.app.ActivityThread;
 import android.companion.AssociationInfo;
 import android.companion.AssociationRequest;
@@ -23,6 +22,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
index 2213fac12..e2a81bf86 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
@@ -12,7 +12,6 @@ import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.accounts.Account;
-import android.annotation.NonNull;
 import android.annotation.SuppressLint;
 import android.content.ContentProvider;
 import android.content.ContentProviderClient;
@@ -50,6 +49,7 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Supplier;
+import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -114,12 +114,12 @@ public class ShadowContentResolver {
 
   private static class ContentObserverEntry {
     public final Uri uri;
-    public final boolean notifyForDescendents;
+    public final boolean notifyForDescendants;
     public final ContentObserver observer;
 
-    private ContentObserverEntry(Uri uri, boolean notifyForDescendents, ContentObserver observer) {
+    private ContentObserverEntry(Uri uri, boolean notifyForDescendants, ContentObserver observer) {
       this.uri = uri;
-      this.notifyForDescendents = notifyForDescendents;
+      this.notifyForDescendants = notifyForDescendants;
       this.observer = observer;
 
       if (uri == null || observer == null) {
@@ -139,7 +139,7 @@ public class ShadowContentResolver {
       String testPath = test.getPath();
 
       return Objects.equals(uriPath, testPath)
-          || (notifyForDescendents && testPath != null && testPath.startsWith(uriPath));
+          || (notifyForDescendants && testPath != null && testPath.startsWith(uriPath));
     }
   }
 
@@ -517,7 +517,7 @@ public class ShadowContentResolver {
   }
 
   @Implementation
-  protected @NonNull ContentProviderResult[] applyBatch(
+  protected @Nonnull ContentProviderResult[] applyBatch(
       String authority, ArrayList<ContentProviderOperation> operations)
       throws OperationApplicationException {
     ContentProvider provider = getProvider(authority, getContext());
@@ -655,7 +655,7 @@ public class ShadowContentResolver {
   }
 
   @Implementation
-  protected void takePersistableUriPermission(@NonNull Uri uri, int modeFlags) {
+  protected void takePersistableUriPermission(@Nonnull Uri uri, int modeFlags) {
     Objects.requireNonNull(uri, "uri may not be null");
     modeFlags &= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
 
@@ -683,7 +683,7 @@ public class ShadowContentResolver {
   }
 
   @Implementation
-  protected void releasePersistableUriPermission(@NonNull Uri uri, int modeFlags) {
+  protected void releasePersistableUriPermission(@Nonnull Uri uri, int modeFlags) {
     Objects.requireNonNull(uri, "uri may not be null");
     modeFlags &= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
 
@@ -717,12 +717,12 @@ public class ShadowContentResolver {
   }
 
   @Implementation
-  @NonNull
+  @Nonnull
   protected List<UriPermission> getPersistedUriPermissions() {
     return uriPermissions;
   }
 
-  private void addUriPermission(@NonNull Uri uri, int modeFlags) {
+  private void addUriPermission(@Nonnull Uri uri, int modeFlags) {
     UriPermission perm =
         ReflectionHelpers.callConstructor(
             UriPermission.class,
@@ -925,20 +925,20 @@ public class ShadowContentResolver {
 
   @Implementation
   protected void registerContentObserver(
-      Uri uri, boolean notifyForDescendents, ContentObserver observer) {
+      Uri uri, boolean notifyForDescendants, ContentObserver observer) {
     if (uri == null || observer == null) {
       throw new NullPointerException();
     }
     if (registerContentProviderExceptions.containsKey(uri)) {
       throw registerContentProviderExceptions.get(uri);
     }
-    contentObservers.add(new ContentObserverEntry(uri, notifyForDescendents, observer));
+    contentObservers.add(new ContentObserverEntry(uri, notifyForDescendants, observer));
   }
 
   @Implementation
   protected void registerContentObserver(
-      Uri uri, boolean notifyForDescendents, ContentObserver observer, int userHandle) {
-    registerContentObserver(uri, notifyForDescendents, observer);
+      Uri uri, boolean notifyForDescendants, ContentObserver observer, int userHandle) {
+    registerContentObserver(uri, notifyForDescendants, observer);
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
index ccc200541..76c39560d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
@@ -438,4 +438,3 @@ public class ShadowContextHubManager {
     ContextHubTransaction.Response<List<NanoAppState>> create(int result, Object contents);
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java
index 8ffe4430e..8a21c2313 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java
@@ -8,7 +8,6 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.shadow.api.Shadow.directlyOn;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.app.ActivityThread;
 import android.app.LoadedApk;
@@ -40,6 +39,7 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -71,8 +71,8 @@ public class ShadowContextImpl {
 
   /**
    * Returns the handle to a system-level service by name. If the service is not available in
-   * Roboletric, or it is set to unavailable in {@link ShadowServiceManager#setServiceAvailability},
-   * {@code null} will be returned.
+   * Robolectric, or it is set to unavailable in {@link
+   * ShadowServiceManager#setServiceAvailability}, {@code null} will be returned.
    */
   @Implementation
   @Nullable
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCountDownTimer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCountDownTimer.java
index 0540eb48a..0d6c3a12b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCountDownTimer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCountDownTimer.java
@@ -1,60 +1,91 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
 import android.os.CountDownTimer;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
-import org.robolectric.shadow.api.Shadow;
-import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 
 @Implements(CountDownTimer.class)
 public class ShadowCountDownTimer {
-  private boolean started;
-  private long countDownInterval;
-  private long millisInFuture;
-
-  @RealObject CountDownTimer countDownTimer;
+  static final String PROPERTY_USE_REAL_IMPL = "robolectric.useRealCountDownTimer";
 
-  @Implementation
-  protected void __constructor__(long millisInFuture, long countDownInterval) {
-    this.countDownInterval = countDownInterval;
-    this.millisInFuture = millisInFuture;
-    this.started = false;
-    Shadow.invokeConstructor(
-        CountDownTimer.class,
-        countDownTimer,
-        ClassParameter.from(long.class, millisInFuture),
-        ClassParameter.from(long.class, countDownInterval));
-  }
+  private boolean started;
+  @RealObject private CountDownTimer realCountDownTimer;
 
   @Implementation
   protected synchronized CountDownTimer start() {
     started = true;
-    return countDownTimer;
+
+    if (useRealCountDownTimer()) {
+      return reflector(CountDownTimerReflector.class, realCountDownTimer).start();
+    } else {
+      return realCountDownTimer;
+    }
   }
 
   @Implementation
-  protected void cancel() {
+  protected synchronized void cancel() {
     started = false;
+
+    reflector(CountDownTimerReflector.class, realCountDownTimer).cancel();
   }
 
   public void invokeTick(long millisUntilFinished) {
-    countDownTimer.onTick(millisUntilFinished);
+    realCountDownTimer.onTick(millisUntilFinished);
   }
 
   public void invokeFinish() {
-    countDownTimer.onFinish();
+    realCountDownTimer.onFinish();
   }
 
   public boolean hasStarted() {
     return started;
   }
 
+  public boolean isCancelled() {
+    return reflector(CountDownTimerReflector.class, realCountDownTimer).getCancelled();
+  }
+
   public long getCountDownInterval() {
-    return countDownInterval;
+    return reflector(CountDownTimerReflector.class, realCountDownTimer).getCountDownInterval();
   }
 
   public long getMillisInFuture() {
-    return millisInFuture;
+    return reflector(CountDownTimerReflector.class, realCountDownTimer).getMillisInFuture();
+  }
+
+  /**
+   * If the {@code robolectric.useRealCountDownTimer} system property is {@code true}, the real
+   * framework code of {@link CountDownTimer} is used.
+   *
+   * <p>If it is {@code false}, the {@link #start()} and {@link #cancel()} methods are no-ops.
+   *
+   * <p>This allows tests to use the old behavior (ie. the no-op version) during a migration.
+   */
+  private static boolean useRealCountDownTimer() {
+    return Boolean.parseBoolean(System.getProperty(PROPERTY_USE_REAL_IMPL, "true"));
+  }
+
+  @ForType(CountDownTimer.class)
+  interface CountDownTimerReflector {
+    @Direct
+    CountDownTimer start();
+
+    @Direct
+    void cancel();
+
+    @Accessor("mCancelled")
+    boolean getCancelled();
+
+    @Accessor("mCountdownInterval")
+    long getCountDownInterval();
+
+    @Accessor("mMillisInFuture")
+    long getMillisInFuture();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
index 355e3664a..53d247e1f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
@@ -20,8 +20,6 @@ import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.accounts.Account;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
@@ -65,6 +63,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
@@ -1372,7 +1372,7 @@ public class ShadowDevicePolicyManager {
   }
 
   @Implementation
-  protected boolean hasGrantedPolicy(@NonNull ComponentName admin, int usesPolicy) {
+  protected boolean hasGrantedPolicy(@Nonnull ComponentName admin, int usesPolicy) {
     enforceActiveAdmin(admin);
     Set<Integer> policyGrantedSet = adminPolicyGrantedMap.get(admin);
     return policyGrantedSet != null && policyGrantedSet.contains(usesPolicy);
@@ -1404,38 +1404,38 @@ public class ShadowDevicePolicyManager {
   }
 
   @Implementation
-  protected void setLockTaskPackages(@NonNull ComponentName admin, String[] packages) {
+  protected void setLockTaskPackages(@Nonnull ComponentName admin, String[] packages) {
     enforceDeviceOwnerOrProfileOwner(admin);
     lockTaskPackages.clear();
     Collections.addAll(lockTaskPackages, packages);
   }
 
   @Implementation
-  protected String[] getLockTaskPackages(@NonNull ComponentName admin) {
+  protected String[] getLockTaskPackages(@Nonnull ComponentName admin) {
     enforceDeviceOwnerOrProfileOwner(admin);
     return lockTaskPackages.toArray(new String[0]);
   }
 
   @Implementation
-  protected boolean isLockTaskPermitted(@NonNull String pkg) {
+  protected boolean isLockTaskPermitted(@Nonnull String pkg) {
     return lockTaskPackages.contains(pkg);
   }
 
   @Implementation(minSdk = O)
-  protected void setAffiliationIds(@NonNull ComponentName admin, @NonNull Set<String> ids) {
+  protected void setAffiliationIds(@Nonnull ComponentName admin, @Nonnull Set<String> ids) {
     enforceDeviceOwnerOrProfileOwner(admin);
     affiliationIds.clear();
     affiliationIds.addAll(ids);
   }
 
   @Implementation(minSdk = O)
-  protected Set<String> getAffiliationIds(@NonNull ComponentName admin) {
+  protected Set<String> getAffiliationIds(@Nonnull ComponentName admin) {
     enforceDeviceOwnerOrProfileOwner(admin);
     return affiliationIds;
   }
 
   @Implementation(minSdk = M)
-  protected void setPermissionPolicy(@NonNull ComponentName admin, int policy) {
+  protected void setPermissionPolicy(@Nonnull ComponentName admin, int policy) {
     enforceDeviceOwnerOrProfileOwner(admin);
     permissionPolicy = policy;
   }
@@ -1453,7 +1453,7 @@ public class ShadowDevicePolicyManager {
    *     be an active administrator, or an exception will be thrown. This value must never be null.
    * @param usesPolicy the uses-policy to check
    */
-  public void grantPolicy(@NonNull ComponentName admin, int usesPolicy) {
+  public void grantPolicy(@Nonnull ComponentName admin, int usesPolicy) {
     enforceActiveAdmin(admin);
     Set<Integer> policyGrantedSet = adminPolicyGrantedMap.get(admin);
     if (policyGrantedSet == null) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java
index 70249de3c..0a5ae1e64 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java
@@ -2,13 +2,13 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.admin.DevicePolicyResourcesManager;
 import android.os.Build.VERSION_CODES;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.function.Supplier;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -30,14 +30,14 @@ public class ShadowDevicePolicyResourcesManager {
    * Override string returned by the resource identified by {@code stringId}. Reset the override by
    * providing null as the {@code vaNlue}.
    */
-  public void setString(@NonNull String stringId, String value) {
+  public void setString(@Nonnull String stringId, String value) {
     stringMappings.put(stringId, value);
   }
 
   @Implementation
   @Nullable
   protected String getString(
-      @NonNull String stringId, @NonNull Supplier<String> defaultStringLoader) {
+      @Nonnull String stringId, @Nonnull Supplier<String> defaultStringLoader) {
     String value = stringMappings.get(stringId);
     if (value != null) {
       return value;
@@ -50,6 +50,6 @@ public class ShadowDevicePolicyResourcesManager {
   @ForType(DevicePolicyResourcesManager.class)
   interface DevicePolicyResourcesManagerReflector {
     @Direct
-    String getString(@NonNull String stringId, @NonNull Supplier<String> defaultStringLoader);
+    String getString(@Nonnull String stringId, @Nonnull Supplier<String> defaultStringLoader);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java
index 6a88f769b..04cb0fd8f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java
@@ -3,13 +3,13 @@ package org.robolectric.shadows;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.Context;
+import android.hardware.display.DisplayManager;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.util.DisplayMetrics;
 import android.view.Display;
 import android.view.Display.HdrCapabilities;
 import android.view.Surface;
-import android.view.WindowManager;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -33,10 +33,10 @@ public class ShadowDisplay {
    * @return the default display
    */
   public static Display getDefaultDisplay() {
-    WindowManager windowManager =
-        (WindowManager)
-            RuntimeEnvironment.getApplication().getSystemService(Context.WINDOW_SERVICE);
-    return windowManager.getDefaultDisplay();
+    DisplayManager displayManager =
+        (DisplayManager)
+            RuntimeEnvironment.getApplication().getSystemService(Context.DISPLAY_SERVICE);
+    return displayManager.getDisplay(Display.DEFAULT_DISPLAY);
   }
 
   @RealObject Display realObject;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
index c42647082..09e744d8d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
@@ -11,7 +11,6 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.os.MessageQueue;
-import android.os.SystemClock;
 import android.view.Choreographer;
 import android.view.DisplayEventReceiver;
 import dalvik.system.CloseGuard;
@@ -108,6 +107,12 @@ public class ShadowDisplayEventReceiver {
     nativeObjRegistry.getNativeObject(receiverPtr).scheduleVsync();
   }
 
+  @Implementation(minSdk = TIRAMISU)
+  protected static @ClassName("android.view.DisplayEventReceiver$VsyncEventData") Object
+      nativeGetLatestVsyncEventData(long receiverPtr) {
+    return nativeObjRegistry.getNativeObject(receiverPtr).getLatestVsyncEventData();
+  }
+
   @Implementation(maxSdk = R)
   protected void dispose(boolean finalized) {
     CloseGuard closeGuard = displayEventReceiverReflector.getCloseGuard();
@@ -118,25 +123,19 @@ public class ShadowDisplayEventReceiver {
     displayEventReceiverReflector.dispose(finalized);
   }
 
-  protected void onVsync() {
+  protected void onVsync(long frameTimeNanos, int frame, Object vsyncEventData) {
     if (RuntimeEnvironment.getApiLevel() < Q) {
       displayEventReceiverReflector.onVsync(
-          ShadowSystem.nanoTime(), 0, /* SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN */ 1);
+          frameTimeNanos, 0 /* SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN */, frame);
     } else if (RuntimeEnvironment.getApiLevel() < S) {
       displayEventReceiverReflector.onVsync(
-          ShadowSystem.nanoTime(), 0L, /* SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN */ 1);
-    } else if (RuntimeEnvironment.getApiLevel() < TIRAMISU) {
-      displayEventReceiverReflector.onVsync(
-          ShadowSystem.nanoTime(),
-          0L, /* physicalDisplayId currently ignored */
-          /* frame= */ 1,
-          newVsyncEventData() /* VsyncEventData */);
+          ShadowSystem.nanoTime(), 0L /* SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN */, frame);
     } else {
       displayEventReceiverReflector.onVsync(
           ShadowSystem.nanoTime(),
-          0L, /* physicalDisplayId currently ignored */
-          1, /* frame */
-          newVsyncEventData() /* VsyncEventData */);
+          0L /* physicalDisplayId currently ignored */,
+          frame,
+          vsyncEventData);
     }
   }
 
@@ -148,6 +147,9 @@ public class ShadowDisplayEventReceiver {
       frameReflector.setHavePendingVsync(false);
       frameReflector.setTimestampNanos(0);
     }
+    long nativeReceiverPtr =
+        reflector(DisplayEventReceiverReflector.class, realReceiver).getReceiverPtr();
+    nativeObjRegistry.getNativeObject(nativeReceiverPtr).resetState();
   }
 
   /**
@@ -170,6 +172,8 @@ public class ShadowDisplayEventReceiver {
 
     private final WeakReference<DisplayEventReceiver> receiverRef;
     private final ShadowPausedSystemClock.Listener clockListener = this::onClockAdvanced;
+    private int frame = 0;
+    private Object /* VsyncEventData */ latestVsyncEventData = null;
 
     public NativeDisplayEventReceiver(WeakReference<DisplayEventReceiver> receiverRef) {
       this.receiverRef = receiverRef;
@@ -179,11 +183,11 @@ public class ShadowDisplayEventReceiver {
 
     private void onClockAdvanced() {
       synchronized (this) {
-        long nextVsyncTime = ShadowChoreographer.getNextVsyncTime();
-        if (nextVsyncTime == 0 || ShadowPausedSystemClock.uptimeMillis() < nextVsyncTime) {
+        long nextVsyncTime = ShadowChoreographer.getNextVsyncTimeNanos();
+        if (nextVsyncTime == 0 || ShadowPausedSystemClock.uptimeNanos() < nextVsyncTime) {
           return;
         }
-        ShadowChoreographer.setNextVsyncTime(0);
+        ShadowChoreographer.setNextVsyncTimeNanos(0);
       }
 
       doVsync();
@@ -196,8 +200,9 @@ public class ShadowDisplayEventReceiver {
     public void scheduleVsync() {
       Duration frameDelay = ShadowChoreographer.getFrameDelay();
       if (ShadowChoreographer.isPaused()) {
-        if (ShadowChoreographer.getNextVsyncTime() < SystemClock.uptimeMillis()) {
-          ShadowChoreographer.setNextVsyncTime(SystemClock.uptimeMillis() + frameDelay.toMillis());
+        if (ShadowChoreographer.getNextVsyncTimeNanos() < ShadowPausedSystemClock.uptimeNanos()) {
+          ShadowChoreographer.setNextVsyncTimeNanos(
+              ShadowPausedSystemClock.uptimeNanos() + frameDelay.toNanos());
         }
       } else {
         // simulate an immediate callback
@@ -210,64 +215,72 @@ public class ShadowDisplayEventReceiver {
       DisplayEventReceiver receiver = receiverRef.get();
       if (receiver != null) {
         ShadowDisplayEventReceiver shadowReceiver = Shadow.extract(receiver);
-        shadowReceiver.onVsync();
+        if (RuntimeEnvironment.getApiLevel() >= S) {
+          latestVsyncEventData = newVsyncEventData(ShadowChoreographer.getFrameDelay().toNanos());
+        }
+        shadowReceiver.onVsync(ShadowSystem.nanoTime(), frame, latestVsyncEventData);
+        frame++;
       }
     }
-  }
-
-  @Implementation(minSdk = TIRAMISU)
-  protected @ClassName("android.view.DisplayEventReceiver$VsyncEventData") Object
-      getLatestVsyncEventData() {
-    return newVsyncEventData();
-  }
 
-  private static Object /* VsyncEventData */ newVsyncEventData() {
-    VsyncEventDataReflector vsyncEventDataReflector = reflector(VsyncEventDataReflector.class);
-    if (RuntimeEnvironment.getApiLevel() < TIRAMISU) {
-      return vsyncEventDataReflector.newVsyncEventData(
-          /* id= */ 1, /* frameDeadline= */ 10, /* frameInterval= */ 1);
-    }
-    try {
-      // onVsync on T takes a package-private VsyncEventData class, which is itself composed of a
-      // package private VsyncEventData.FrameTimeline  class. So use reflection to build these up
-      Class<?> frameTimelineClass =
-          Class.forName("android.view.DisplayEventReceiver$VsyncEventData$FrameTimeline");
-
-      int timelineArrayLength = RuntimeEnvironment.getApiLevel() == TIRAMISU ? 1 : 7;
-      FrameTimelineReflector frameTimelineReflector = reflector(FrameTimelineReflector.class);
-      Object timelineArray = Array.newInstance(frameTimelineClass, timelineArrayLength);
-      for (int i = 0; i < timelineArrayLength; i++) {
-        Array.set(timelineArray, i, frameTimelineReflector.newFrameTimeline(1, 1, 10));
-      }
-      if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
+    private static Object /* VsyncEventData */ newVsyncEventData(long frameIntervalNanos) {
+      VsyncEventDataReflector vsyncEventDataReflector = reflector(VsyncEventDataReflector.class);
+      if (RuntimeEnvironment.getApiLevel() < TIRAMISU) {
         return vsyncEventDataReflector.newVsyncEventData(
-            timelineArray, /* preferredFrameTimelineIndex= */ 0, /* frameInterval= */ 1);
-      } else {
-        boolean baklavaConstructor =
-            ReflectionHelpers.hasConstructor(
-                DisplayEventReceiver.VsyncEventData.class,
-                DisplayEventReceiver.VsyncEventData.FrameTimeline[].class,
-                int.class,
-                int.class,
-                long.class,
-                int.class);
-        if (RuntimeEnvironment.getApiLevel() < Baklava.SDK_INT || !baklavaConstructor) {
+            /* id= */ 1, /* frameDeadline= */ 10, frameIntervalNanos);
+      }
+      try {
+        // onVsync on T takes a package-private VsyncEventData class, which is itself composed of a
+        // package private VsyncEventData.FrameTimeline  class. So use reflection to build these up
+        Class<?> frameTimelineClass =
+            Class.forName("android.view.DisplayEventReceiver$VsyncEventData$FrameTimeline");
+
+        int timelineArrayLength = RuntimeEnvironment.getApiLevel() == TIRAMISU ? 1 : 7;
+        FrameTimelineReflector frameTimelineReflector = reflector(FrameTimelineReflector.class);
+        Object timelineArray = Array.newInstance(frameTimelineClass, timelineArrayLength);
+        for (int i = 0; i < timelineArrayLength; i++) {
+          Array.set(timelineArray, i, frameTimelineReflector.newFrameTimeline(1, 1, 10));
+        }
+        if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
           return vsyncEventDataReflector.newVsyncEventData(
-              timelineArray,
-              /* preferredFrameTimelineIndex= */ 0,
-              timelineArrayLength,
-              /* frameInterval= */ 1);
+              timelineArray, /* preferredFrameTimelineIndex= */ 0, frameIntervalNanos);
         } else {
-          return vsyncEventDataReflector.newVsyncEventData(
-              timelineArray,
-              /* preferredFrameTimelineIndex= */ 0,
-              timelineArrayLength,
-              /* frameInterval= */ 1,
-              /* numberQueuedBuffers= */ 0);
+          boolean baklavaConstructor =
+              ReflectionHelpers.hasConstructor(
+                  DisplayEventReceiver.VsyncEventData.class,
+                  DisplayEventReceiver.VsyncEventData.FrameTimeline[].class,
+                  int.class,
+                  int.class,
+                  long.class,
+                  int.class);
+          if (RuntimeEnvironment.getApiLevel() < Baklava.SDK_INT || !baklavaConstructor) {
+            return vsyncEventDataReflector.newVsyncEventData(
+                timelineArray,
+                /* preferredFrameTimelineIndex= */ 0,
+                timelineArrayLength,
+                frameIntervalNanos);
+          } else {
+            return vsyncEventDataReflector.newVsyncEventData(
+                timelineArray,
+                /* preferredFrameTimelineIndex= */ 0,
+                timelineArrayLength,
+                frameIntervalNanos,
+                /* numberQueuedBuffers= */ 0);
+          }
         }
+      } catch (ClassNotFoundException e) {
+        throw new LinkageError("Unable to construct VsyncEventData", e);
       }
-    } catch (ClassNotFoundException e) {
-      throw new LinkageError("Unable to construct VsyncEventData", e);
+    }
+
+    public @ClassName("android.view.DisplayEventReceiver$VsyncEventData") Object
+        getLatestVsyncEventData() {
+      return latestVsyncEventData;
+    }
+
+    public void resetState() {
+      frame = 0;
+      latestVsyncEventData = null;
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
index 75b8c3843..d7889746f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
@@ -9,7 +9,6 @@ import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.annotation.RequiresApi;
 import android.content.Context;
 import android.content.res.Configuration;
@@ -24,6 +23,8 @@ import android.view.Surface;
 import com.google.auto.value.AutoBuilder;
 import java.util.HashMap;
 import java.util.List;
+import java.util.function.Consumer;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.Bootstrap;
 import org.robolectric.android.internal.DisplayConfig;
@@ -34,7 +35,6 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.res.Qualifiers;
-import org.robolectric.util.Consumer;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Direct;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
index 548f57261..348c15361 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
@@ -48,6 +48,9 @@ public class ShadowDisplayManagerGlobal {
   private static final String TOPOLOGY_LISTENERS_FIELD_NAME = "mTopologyListeners";
   private static DisplayManagerGlobal instance;
 
+  // TODO: remove and use DisplayManagerGlobal directly when compiling against Baklava
+  private static final int EVENT_DISPLAY_BASIC_CHANGED = 2;
+
   private float saturationLevel = 1f;
   private final SparseArray<BrightnessConfiguration> brightnessConfiguration = new SparseArray<>();
   private final List<BrightnessChangeEvent> brightnessChangeEvents = new ArrayList<>();
@@ -91,11 +94,10 @@ public class ShadowDisplayManagerGlobal {
     displayManagerGlobal.setLock(new Object());
     List<Handler> displayListeners = createDisplayListeners();
     displayManagerGlobal.setDisplayListeners(displayListeners);
-    if (ReflectionHelpers.hasField(DisplayManagerGlobal.class,
-            TOPOLOGY_LISTENERS_FIELD_NAME)) {
+    displayManagerGlobal.setDisplayInfoCache(new SparseArray<>());
+    if (ReflectionHelpers.hasField(DisplayManagerGlobal.class, TOPOLOGY_LISTENERS_FIELD_NAME)) {
       displayManagerGlobal.setTopologyListeners(new CopyOnWriteArrayList<>());
     }
-    displayManagerGlobal.setDisplayInfoCache(new SparseArray<>());
     return instance;
   }
 
@@ -324,7 +326,7 @@ public class ShadowDisplayManagerGlobal {
       }
 
       displayInfos.put(displayId, displayInfo);
-      notifyListeners(displayId, DisplayManagerGlobal.EVENT_DISPLAY_CHANGED);
+      notifyListeners(displayId, EVENT_DISPLAY_BASIC_CHANGED);
     }
 
     private synchronized void removeDisplay(int displayId) {
@@ -419,10 +421,10 @@ public class ShadowDisplayManagerGlobal {
     @Accessor("mDisplayListeners")
     void setDisplayListeners(List<Handler> list);
 
-    @Accessor(TOPOLOGY_LISTENERS_FIELD_NAME)
-    void setTopologyListeners(List<Handler> list);
-
     @Accessor("mDisplayInfoCache")
     void setDisplayInfoCache(SparseArray<DisplayInfo> displayInfoCache);
+
+    @Accessor("mTopologyListeners")
+    void setTopologyListeners(CopyOnWriteArrayList<?> listeners);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDistanceMeasurementManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDistanceMeasurementManager.java
index 0f0e4836e..8442a0e69 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDistanceMeasurementManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDistanceMeasurementManager.java
@@ -24,6 +24,7 @@ import java.util.concurrent.Executor;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 /** Shadow implementation of {@link DistanceMeasurementManager}. */
 @Implements(
@@ -47,16 +48,49 @@ public class ShadowDistanceMeasurementManager {
       DistanceMeasurementParams params,
       Executor executor,
       DistanceMeasurementSession.Callback callback) {
-    IBluetoothGatt gatt = ReflectionHelpers.createNullProxy(IBluetoothGatt.class);
-    sessionMap.put(
-        params.getDevice(),
-        new DistanceMeasurementSession(
-            gatt,
-            new ParcelUuid(UUID.randomUUID()),
-            params,
-            executor,
-            AttributionSource.myAttributionSource(),
-            callback));
+    Class<?> iDistanceMeasurementClazz = null;
+    try {
+      iDistanceMeasurementClazz =
+          ReflectionHelpers.loadClass(
+              Thread.currentThread().getContextClassLoader(),
+              "android.bluetooth.IDistanceMeasurement");
+    } catch (RuntimeException e) {
+      // no op, class not available
+    }
+    if (iDistanceMeasurementClazz != null
+        && ReflectionHelpers.hasConstructor(
+            DistanceMeasurementSession.class,
+            iDistanceMeasurementClazz,
+            ParcelUuid.class,
+            DistanceMeasurementParams.class,
+            Executor.class,
+            AttributionSource.class,
+            DistanceMeasurementSession.Callback.class)) {
+      sessionMap.put(
+          params.getDevice(),
+          ReflectionHelpers.callConstructor(
+              DistanceMeasurementSession.class,
+              ClassParameter.from(
+                  iDistanceMeasurementClazz,
+                  ReflectionHelpers.createNullProxy(iDistanceMeasurementClazz)),
+              ClassParameter.from(ParcelUuid.class, new ParcelUuid(UUID.randomUUID())),
+              ClassParameter.from(DistanceMeasurementParams.class, params),
+              ClassParameter.from(Executor.class, executor),
+              ClassParameter.from(AttributionSource.class, AttributionSource.myAttributionSource()),
+              ClassParameter.from(DistanceMeasurementSession.Callback.class, callback)));
+    } else {
+      sessionMap.put(
+          params.getDevice(),
+          ReflectionHelpers.callConstructor(
+              DistanceMeasurementSession.class,
+              ClassParameter.from(
+                  IBluetoothGatt.class, ReflectionHelpers.createNullProxy(IBluetoothGatt.class)),
+              ClassParameter.from(ParcelUuid.class, new ParcelUuid(UUID.randomUUID())),
+              ClassParameter.from(DistanceMeasurementParams.class, params),
+              ClassParameter.from(Executor.class, executor),
+              ClassParameter.from(AttributionSource.class, AttributionSource.myAttributionSource()),
+              ClassParameter.from(DistanceMeasurementSession.Callback.class, callback)));
+    }
     sessionCallbackMap.put(params.getDevice(), callback);
 
     return new CancellationSignal();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java
index ae12f99de..cfbeacbb7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.drawable.GradientDrawable;
+import android.os.Build;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -15,6 +16,7 @@ public class ShadowGradientDrawable extends ShadowDrawable {
   @RealObject private GradientDrawable realGradientDrawable;
 
   private int color;
+  private int shape;
   private int strokeColor;
   private int strokeWidth;
 
@@ -24,6 +26,12 @@ public class ShadowGradientDrawable extends ShadowDrawable {
     reflector(GradientDrawableReflector.class, realGradientDrawable).setColor(color);
   }
 
+  @Implementation
+  protected void setShape(int shape) {
+    this.shape = shape;
+    reflector(GradientDrawableReflector.class, realGradientDrawable).setShape(shape);
+  }
+
   @Implementation
   protected void setStroke(int width, int color) {
     this.strokeWidth = width;
@@ -41,6 +49,15 @@ public class ShadowGradientDrawable extends ShadowDrawable {
     return color;
   }
 
+  @Implementation(minSdk = Build.VERSION_CODES.N)
+  protected int getShape() {
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
+      return shape;
+    }
+
+    return reflector(GradientDrawableReflector.class, realGradientDrawable).getShape();
+  }
+
   public int getStrokeWidth() {
     return strokeWidth;
   }
@@ -52,9 +69,15 @@ public class ShadowGradientDrawable extends ShadowDrawable {
   @ForType(GradientDrawable.class)
   interface GradientDrawableReflector {
 
+    @Direct
+    int getShape();
+
     @Direct
     void setColor(int color);
 
+    @Direct
+    void setShape(int shape);
+
     @Direct
     void setStroke(int width, int color);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIcon.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIcon.java
index 04d255eb4..fddd40ee5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIcon.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIcon.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
@@ -13,6 +12,7 @@ import android.net.Uri;
 import android.os.Handler;
 import android.os.Message;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
index 6e8dad158..ff53ff828 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
@@ -4,7 +4,6 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest;
 import android.annotation.CallbackExecutor;
-import android.annotation.NonNull;
 import android.annotation.RequiresApi;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
@@ -22,6 +21,7 @@ import android.util.ArrayMap;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -72,7 +72,7 @@ public class ShadowImsMmTelManager {
   @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
   @Implementation
   protected void registerImsRegistrationCallback(
-      @NonNull @CallbackExecutor Executor executor, @NonNull ImsMmTelManager.RegistrationCallback c)
+      @Nonnull @CallbackExecutor Executor executor, @Nonnull ImsMmTelManager.RegistrationCallback c)
       throws ImsException {
     if (!imsAvailableOnDevice) {
       throw new ImsException(
@@ -88,8 +88,8 @@ public class ShadowImsMmTelManager {
       })
   @Implementation(minSdk = VERSION_CODES.R)
   protected void registerImsRegistrationCallback(
-      @NonNull @CallbackExecutor Executor executor,
-      @NonNull RegistrationManager.RegistrationCallback c)
+      @Nonnull @CallbackExecutor Executor executor,
+      @Nonnull RegistrationManager.RegistrationCallback c)
       throws ImsException {
     if (!imsAvailableOnDevice) {
       throw new ImsException(
@@ -101,7 +101,7 @@ public class ShadowImsMmTelManager {
   @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
   @Implementation
   protected void unregisterImsRegistrationCallback(
-      @NonNull ImsMmTelManager.RegistrationCallback c) {
+      @Nonnull ImsMmTelManager.RegistrationCallback c) {
     registrationCallbackExecutorMap.remove(c);
   }
 
@@ -112,7 +112,7 @@ public class ShadowImsMmTelManager {
       })
   @Implementation(minSdk = VERSION_CODES.R)
   protected void unregisterImsRegistrationCallback(
-      @NonNull RegistrationManager.RegistrationCallback c) {
+      @Nonnull RegistrationManager.RegistrationCallback c) {
     registrationManagerCallbackExecutorMap.remove(c);
   }
 
@@ -135,7 +135,7 @@ public class ShadowImsMmTelManager {
   }
 
   @RequiresApi(api = VERSION_CODES.S)
-  public void setImsRegistering(@NonNull ImsRegistrationAttributes attrs) {
+  public void setImsRegistering(@Nonnull ImsRegistrationAttributes attrs) {
     for (Map.Entry<RegistrationManager.RegistrationCallback, Executor> entry :
         registrationManagerCallbackExecutorMap.entrySet()) {
       entry.getValue().execute(() -> entry.getKey().onRegistering(attrs));
@@ -162,7 +162,7 @@ public class ShadowImsMmTelManager {
   }
 
   @RequiresApi(api = VERSION_CODES.S)
-  public void setImsRegistered(@NonNull ImsRegistrationAttributes attrs) {
+  public void setImsRegistered(@Nonnull ImsRegistrationAttributes attrs) {
     for (Map.Entry<RegistrationManager.RegistrationCallback, Executor> entry :
         registrationManagerCallbackExecutorMap.entrySet()) {
       entry.getValue().execute(() -> entry.getKey().onRegistered(attrs));
@@ -175,7 +175,7 @@ public class ShadowImsMmTelManager {
    *
    * @see #registerImsRegistrationCallback(Executor, RegistrationCallback)
    */
-  public void setImsUnregistered(@NonNull ImsReasonInfo imsReasonInfo) {
+  public void setImsUnregistered(@Nonnull ImsReasonInfo imsReasonInfo) {
     this.imsRegistrationTech = ImsRegistrationImplBase.REGISTRATION_TECH_NONE;
     for (Map.Entry<ImsMmTelManager.RegistrationCallback, Executor> entry :
         registrationCallbackExecutorMap.entrySet()) {
@@ -194,7 +194,7 @@ public class ShadowImsMmTelManager {
    *
    * @see #registerImsRegistrationCallback(Executor, RegistrationCallback)
    */
-  public void setOnTechnologyChangeFailed(int imsRadioTech, @NonNull ImsReasonInfo imsReasonInfo) {
+  public void setOnTechnologyChangeFailed(int imsRadioTech, @Nonnull ImsReasonInfo imsReasonInfo) {
     for (Map.Entry<RegistrationManager.RegistrationCallback, Executor> entry :
         registrationManagerCallbackExecutorMap.entrySet()) {
       entry
@@ -247,7 +247,7 @@ public class ShadowImsMmTelManager {
   @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
   @Implementation
   protected void registerMmTelCapabilityCallback(
-      @NonNull @CallbackExecutor Executor executor, @NonNull CapabilityCallback c)
+      @Nonnull @CallbackExecutor Executor executor, @Nonnull CapabilityCallback c)
       throws ImsException {
     if (!imsAvailableOnDevice) {
       throw new ImsException(
@@ -258,7 +258,7 @@ public class ShadowImsMmTelManager {
 
   @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
   @Implementation
-  protected void unregisterMmTelCapabilityCallback(@NonNull CapabilityCallback c) {
+  protected void unregisterMmTelCapabilityCallback(@Nonnull CapabilityCallback c) {
     capabilityCallbackExecutorMap.remove(c);
   }
 
@@ -276,7 +276,7 @@ public class ShadowImsMmTelManager {
    * CapabilityCallback#onCapabilitiesStatusChanged(MmTelCapabilities)} if IMS has been registered
    * using {@link #setImsUnregistered(ImsReasonInfo)}.
    */
-  public void setMmTelCapabilitiesAvailable(@NonNull MmTelCapabilities capabilities) {
+  public void setMmTelCapabilitiesAvailable(@Nonnull MmTelCapabilities capabilities) {
     this.mmTelCapabilitiesAvailable = capabilities;
     if (imsRegistrationTech != ImsRegistrationImplBase.REGISTRATION_TECH_NONE) {
       for (Map.Entry<CapabilityCallback, Executor> entry :
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIncidentManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIncidentManager.java
index 36c5aafac..fd31fe167 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIncidentManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIncidentManager.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.R;
 
-import android.annotation.NonNull;
 import android.net.Uri;
 import android.os.IncidentManager;
 import android.os.IncidentManager.IncidentReport;
@@ -10,6 +9,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
@@ -19,7 +19,7 @@ public class ShadowIncidentManager {
 
   private final Map<Uri, IncidentReport> reports = new LinkedHashMap<>();
 
-  @NonNull
+  @Nonnull
   @Implementation
   protected List<Uri> getIncidentReportList(String receiverClass) {
     return new ArrayList<>(reports.keySet());
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
index 672771ee1..787969696 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
@@ -14,7 +14,6 @@ import static com.google.common.util.concurrent.Futures.immediateFuture;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.app.Activity;
 import android.app.ActivityThread;
 import android.app.Fragment;
@@ -57,6 +56,7 @@ import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
index bc1e88b92..c1781e865 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
@@ -8,8 +8,6 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.content.ComponentName;
 import android.content.IntentSender;
 import android.content.pm.ApplicationInfo;
@@ -38,6 +36,8 @@ import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -182,7 +182,7 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = Q)
   protected void startPackageInstallerSessionDetailsActivity(
-      @NonNull SessionInfo sessionInfo, @Nullable Rect sourceBounds, @Nullable Bundle opts) {
+      @Nonnull SessionInfo sessionInfo, @Nullable Rect sourceBounds, @Nullable Bundle opts) {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
   }
@@ -196,7 +196,7 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = O)
   protected List<LauncherActivityInfo> getShortcutConfigActivityList(
-      @Nullable String packageName, @NonNull UserHandle user) {
+      @Nullable String packageName, @Nonnull UserHandle user) {
     return shortcutActivityList.get(user).stream()
         .filter(matchesPackage(packageName))
         .collect(Collectors.toList());
@@ -204,7 +204,7 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = O)
   @Nullable
-  protected IntentSender getShortcutConfigActivityIntent(@NonNull LauncherActivityInfo info) {
+  protected IntentSender getShortcutConfigActivityIntent(@Nonnull LauncherActivityInfo info) {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
   }
@@ -223,7 +223,7 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = O)
   protected ApplicationInfo getApplicationInfo(
-      @NonNull String packageName, int flags, @NonNull UserHandle user)
+      @Nonnull String packageName, int flags, @Nonnull UserHandle user)
       throws NameNotFoundException {
     if (applicationInfoList.containsKey(user)) {
       Map<String, ApplicationInfo> map = applicationInfoList.get(user);
@@ -269,7 +269,7 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = Q)
   protected boolean shouldHideFromSuggestions(
-      @NonNull String packageName, @NonNull UserHandle user) {
+      @Nonnull String packageName, @Nonnull UserHandle user) {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
   }
@@ -301,7 +301,7 @@ public class ShadowLauncherApps {
   @Implementation(minSdk = N_MR1)
   @Nullable
   protected List<ShortcutInfo> getShortcuts(
-      @NonNull ShortcutQuery query, @NonNull UserHandle user) {
+      @Nonnull ShortcutQuery query, @Nonnull UserHandle user) {
     if (reflector(ReflectorShortcutQuery.class, query).getChangedSince() != 0) {
       throw new UnsupportedOperationException(
           "Robolectric does not currently support ShortcutQueries that filter on time since"
@@ -335,7 +335,7 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = N_MR1)
   protected void pinShortcuts(
-      @NonNull String packageName, @NonNull List<String> shortcutIds, @NonNull UserHandle user) {
+      @Nonnull String packageName, @Nonnull List<String> shortcutIds, @Nonnull UserHandle user) {
     Iterable<ShortcutInfo> changed =
         Iterables.filter(shortcuts, shortcut -> !shortcutIds.contains(shortcut.getId()));
     List<ShortcutInfo> ret = Lists.newArrayList(changed);
@@ -348,18 +348,18 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = N_MR1)
   protected void startShortcut(
-      @NonNull String packageName,
-      @NonNull String shortcutId,
+      @Nonnull String packageName,
+      @Nonnull String shortcutId,
       @Nullable Rect sourceBounds,
       @Nullable Bundle startActivityOptions,
-      @NonNull UserHandle user) {
+      @Nonnull UserHandle user) {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
   }
 
   @Implementation(minSdk = N_MR1)
   protected void startShortcut(
-      @NonNull ShortcutInfo shortcut,
+      @Nonnull ShortcutInfo shortcut,
       @Nullable Rect sourceBounds,
       @Nullable Bundle startActivityOptions) {
     throw new UnsupportedOperationException(
@@ -387,19 +387,19 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = Q)
   protected void registerPackageInstallerSessionCallback(
-      @NonNull Executor executor, @NonNull SessionCallback callback) {
+      @Nonnull Executor executor, @Nonnull SessionCallback callback) {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
   }
 
   @Implementation(minSdk = Q)
-  protected void unregisterPackageInstallerSessionCallback(@NonNull SessionCallback callback) {
+  protected void unregisterPackageInstallerSessionCallback(@Nonnull SessionCallback callback) {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
   }
 
   @Implementation(minSdk = Q)
-  @NonNull
+  @Nonnull
   protected List<SessionInfo> getAllPackageInstallerSessions() {
     throw new UnsupportedOperationException(
         "This method is not currently supported in Robolectric.");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
index 841911805..cbd81e0d1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
@@ -49,9 +49,12 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.util.SQLiteLibraryLoader;
 import org.robolectric.util.PerfStatsCollector;
+import org.robolectric.versioning.AndroidVersions.V;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 
 /** Shadow for {@link android.database.sqlite.SQLiteConnection} that is backed by sqlite4java. */
 @Implements(value = android.database.sqlite.SQLiteConnection.class, isInAndroidSdk = false)
@@ -101,11 +104,17 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
     CONNECTIONS.reset();
   }
 
-  @Implementation
+  @Implementation(maxSdk=V.SDK_INT)
   protected static void nativeClose(long connectionPtr) {
     CONNECTIONS.close(connectionPtr);
   }
 
+  @InDevelopment
+  @Implementation(minSdk=Baklava.SDK_INT)
+  protected static void nativeClose(long connectionPtr, boolean fast) {
+    CONNECTIONS.close(connectionPtr);
+  }
+
   @Implementation
   protected static void nativeFinalizeStatement(long connectionPtr, long statementPtr) {
     CONNECTIONS.finalizeStmt(connectionPtr, statementPtr);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
index a0ccefb0c..f91473989 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
@@ -8,18 +8,18 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.SuppressLint;
 import android.content.res.AssetManager;
 import android.graphics.Typeface;
+import android.graphics.fonts.FontStyle;
 import android.util.ArrayMap;
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
@@ -28,42 +28,23 @@ import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.RealObject;
-import org.robolectric.annotation.Resetter;
 import org.robolectric.res.Fs;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
-import org.robolectric.versioning.AndroidVersions.Baklava;
-import org.robolectric.versioning.AndroidVersions.T;
-import org.robolectric.versioning.AndroidVersions.U;
-import org.robolectric.versioning.AndroidVersions.V;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link Typeface}. */
 @Implements(value = Typeface.class, isInAndroidSdk = false)
 @SuppressLint("NewApi")
 public class ShadowLegacyTypeface extends ShadowTypeface {
-  private static final Map<Long, FontDesc> FONTS = Collections.synchronizedMap(new HashMap<>());
   private static final AtomicLong nextFontId = new AtomicLong(1);
   private FontDesc description;
 
-  /** Starting in U, this constructor calls {@link #__constructor__(long, String )} below. */
-  @Implementation(maxSdk = T.SDK_INT)
-  protected void __constructor__(long fontId) {
-    description = findById(fontId);
-  }
-
-  @Implementation(minSdk = U.SDK_INT, maxSdk = V.SDK_INT)
-  protected void __constructor__(long fontId, String familyName) {
-    description = findById(fontId);
-  }
-
-  @Implementation(minSdk = Baklava.SDK_INT)
-  @InDevelopment
-  protected void __constructor__(long fontId, String familyName, Typeface derivedFrom) {
-    description = findById(fontId);
-  }
+  @RealObject Typeface realTypeface;
 
   @Implementation
   protected static void __staticInitializer__() {
@@ -171,26 +152,26 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
   @HiddenApi
   @Implementation
   protected static Typeface createFromFamilies(
-      @ClassName("android.graphics.FontFamily[]") Object families) {
+      @ClassName("[Landroid.graphics.FontFamily;") Object families) {
     return null;
   }
 
   @HiddenApi
   @Implementation(maxSdk = N_MR1)
   protected static Typeface createFromFamiliesWithDefault(
-      @ClassName("android.graphics.FontFamily[]") Object families) {
+      @ClassName("[Landroid.graphics.FontFamily;") Object families) {
     return null;
   }
 
   @Implementation(minSdk = O, maxSdk = O_MR1)
   protected static Typeface createFromFamiliesWithDefault(
-      @ClassName("android.graphics.FontFamily[]") Object families, int weight, int italic) {
+      @ClassName("[Landroid.graphics.FontFamily;") Object families, int weight, int italic) {
     return createUnderlyingTypeface("fake-font", Typeface.NORMAL);
   }
 
   @Implementation(minSdk = P)
   protected static Typeface createFromFamiliesWithDefault(
-      @ClassName("android.graphics.FontFamily[]") Object families,
+      @ClassName("[Landroid.graphics.FontFamily;") Object families,
       String fallbackName,
       int weight,
       int italic) {
@@ -202,7 +183,7 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
       String xmlPath,
       String fontDir,
       ArrayMap<String, Typeface> fontMap,
-      ArrayMap<String, @ClassName("android.graphics.FontFamily[]") Object> fallbackMap) {
+      ArrayMap<String, /*android.graphics.FontFamily[]*/ ?> fallbackMap) {
     fontMap.put("sans-serif", createUnderlyingTypeface("sans-serif", 0));
   }
 
@@ -215,33 +196,22 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
   protected static void initSystemDefaultTypefaces(
       Map<String, Typeface> systemFontMap,
       Map<String, /*android.graphics.FontFamily[]*/ ?> fallbacks,
-      @ClassName("android.text.FontConfig$Alias[]") Object aliases) {}
-
-  @Resetter
-  public static synchronized void reset() {
-    FONTS.clear();
-  }
+      @ClassName("[Landroid.text.FontConfig$Alias;") Object aliases) {}
 
   protected static Typeface createUnderlyingTypeface(String familyName, int style) {
     long thisFontId = nextFontId.getAndIncrement();
-    FONTS.put(thisFontId, new FontDesc(familyName, style));
-    return ReflectionHelpers.callConstructor(
-        Typeface.class, ClassParameter.from(long.class, thisFontId));
+    Typeface result =
+        ReflectionHelpers.callConstructor(
+            Typeface.class, ClassParameter.from(long.class, thisFontId));
+    ((ShadowLegacyTypeface) Shadow.extract(result)).description = new FontDesc(familyName, style);
+    return result;
   }
 
-  private static synchronized FontDesc findById(long fontId) {
-    if (FONTS.containsKey(fontId)) {
-      return FONTS.get(fontId);
-    }
-    throw new RuntimeException("Unknown font id: " + fontId);
-  }
 
   @Implementation(minSdk = O, maxSdk = R)
   protected static long nativeCreateFromArray(long[] familyArray, int weight, int italic) {
     // TODO: implement this properly
-    long thisFontId = nextFontId.getAndIncrement();
-    FONTS.put(thisFontId, new FontDesc(null, weight));
-    return thisFontId;
+    return nextFontId.incrementAndGet();
   }
 
   /**
@@ -276,4 +246,38 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
       return createUnderlyingTypeface(path, Typeface.NORMAL);
     }
   }
+
+  /** Shadow for {@link Typeface.CustomFallbackBuilder} that populates {@link #description} */
+  @Implements(
+      value = Typeface.CustomFallbackBuilder.class,
+      minSdk = Q,
+      shadowPicker = CustomFallbackBuilderPicker.class)
+  public static class ShadowCustomFallbackBuilder {
+    @RealObject Typeface.CustomFallbackBuilder realBuilder;
+
+    @Implementation
+    protected Typeface build() {
+      Typeface result = reflector(CustomFallbackBuilderReflector.class, realBuilder).build();
+      FontStyle style = reflector(CustomFallbackBuilderReflector.class, realBuilder).getStyle();
+      ((ShadowLegacyTypeface) Shadow.extract(result)).description =
+          new FontDesc(null, style.getWeight());
+      return result;
+    }
+  }
+
+  /** Shadow picker for {@link Typeface.CustomFallbackBuilder}. */
+  public static final class CustomFallbackBuilderPicker extends GraphicsShadowPicker<Object> {
+    public CustomFallbackBuilderPicker() {
+      super(ShadowLegacyTypeface.ShadowCustomFallbackBuilder.class, null);
+    }
+  }
+
+  @ForType(Typeface.CustomFallbackBuilder.class)
+  interface CustomFallbackBuilderReflector {
+    @Direct
+    Typeface build();
+
+    @Accessor("mStyle")
+    FontStyle getStyle();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
index 0859baed8..9c9e39574 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
@@ -12,7 +12,6 @@ import static android.provider.Settings.Secure.LOCATION_MODE_SENSORS_ONLY;
 import static android.provider.Settings.Secure.LOCATION_PROVIDERS_ALLOWED;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
-import android.annotation.Nullable;
 import android.annotation.RequiresApi;
 import android.app.PendingIntent;
 import android.app.PendingIntent.CanceledException;
@@ -56,6 +55,7 @@ import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.function.Consumer;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
@@ -1633,7 +1633,7 @@ public class ShadowLocationManager {
         if (newLocationMode != oldLocationMode) {
           // this sets LOCATION_MODE and LOCATION_PROVIDERS_ALLOWED
           setLocationModeInternal(newLocationMode);
-        } else if (RuntimeEnvironment.getApiLevel() >= VERSION_CODES.Q) {
+        } else {
           if (enabled == this.enabled) {
             return;
           }
@@ -1644,15 +1644,6 @@ public class ShadowLocationManager {
           // but ignore any direct writes to it
           ShadowSettings.ShadowSecure.updateEnabledProviders(
               getContext().getContentResolver(), name, enabled);
-        } else {
-          if (enabled == this.enabled) {
-            return;
-          }
-
-          this.enabled = enabled;
-          // set LOCATION_PROVIDERS_ALLOWED directly, without setting LOCATION_MODE
-          ShadowSettings.ShadowSecure.updateEnabledProviders(
-              getContext().getContentResolver(), name, enabled);
         }
 
         transports = locationTransports;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMagnificationController.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMagnificationController.java
index faa8a9660..b35d45f36 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMagnificationController.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMagnificationController.java
@@ -1,9 +1,11 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.N;
-
 import android.accessibilityservice.AccessibilityService.MagnificationController;
+import android.accessibilityservice.MagnificationConfig;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.graphics.Region;
+import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.os.Looper;
 import java.util.HashMap;
@@ -12,7 +14,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 
 /** Shadow of MagnificationController. */
-@Implements(value = MagnificationController.class, minSdk = N)
+@Implements(value = MagnificationController.class, minSdk = VERSION_CODES.N)
 public class ShadowMagnificationController {
 
   private static final float DEFAULT_CENTER_X = 0.0f;
@@ -25,6 +27,7 @@ public class ShadowMagnificationController {
       new HashMap<>();
 
   private final Region magnificationRegion = new Region();
+  private MagnificationConfig magnificationConfig = null;
   private float centerX = DEFAULT_CENTER_X;
   private float centerY = DEFAULT_CENTER_Y;
   private float scale = DEFAULT_SCALE;
@@ -40,6 +43,12 @@ public class ShadowMagnificationController {
     addListener(listener, new Handler(Looper.getMainLooper()));
   }
 
+  @Implementation(minSdk = VERSION_CODES.TIRAMISU)
+  @Nullable
+  protected MagnificationConfig getMagnificationConfig() {
+    return magnificationConfig;
+  }
+
   @Implementation
   protected float getCenterX() {
     return centerX;
@@ -72,6 +81,7 @@ public class ShadowMagnificationController {
 
   @Implementation
   protected boolean reset(boolean animate) {
+    magnificationConfig = null;
     centerX = DEFAULT_CENTER_X;
     centerY = DEFAULT_CENTER_Y;
     scale = DEFAULT_SCALE;
@@ -79,6 +89,12 @@ public class ShadowMagnificationController {
     return true;
   }
 
+  @Implementation(minSdk = VERSION_CODES.TIRAMISU)
+  protected boolean setMagnificationConfig(@NonNull MagnificationConfig config, boolean animate) {
+    magnificationConfig = config;
+    return true;
+  }
+
   @Implementation
   protected boolean setCenter(float centerX, float centerY, boolean animate) {
     this.centerX = centerX;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
index 2bc1d40f5..ca8f4d56c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
@@ -9,8 +9,6 @@ import static java.util.concurrent.TimeUnit.MICROSECONDS;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.media.MediaCodec;
 import android.media.MediaCodec.BufferInfo;
 import android.media.MediaCodec.CodecException;
@@ -18,6 +16,7 @@ import android.media.MediaCodecInfo;
 import android.media.MediaCodecList;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
+import android.os.Build.VERSION;
 import android.os.IBinder;
 import android.view.Surface;
 import com.google.common.annotations.VisibleForTesting;
@@ -31,6 +30,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingDeque;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -212,6 +213,7 @@ public class ShadowMediaCodec {
     // Reset state
     inputBuffersPendingDequeue.clear();
     outputBuffersPendingDequeue.clear();
+    inputBuffersPendingQueuing.clear();
     for (int i = 0; i < BUFFER_COUNT; i++) {
       inputBuffersPendingDequeue.add(i);
     }
@@ -313,11 +315,16 @@ public class ShadowMediaCodec {
           /* errorCode= */ 0, /* actionCode= */ 0, "Input buffer not owned by client: " + index);
     }
 
-    BufferInfo info = new BufferInfo();
-    info.set(offset, size, presentationTimeUs, flags);
+    if (VERSION.SDK_INT >= 34 && (flags & MediaCodec.BUFFER_FLAG_DECODE_ONLY) != 0) {
+      inputBuffersPendingQueuing.remove(Integer.valueOf(index));
+      makeInputBufferAvailable(index);
+    } else {
+      BufferInfo info = new BufferInfo();
+      info.set(offset, size, presentationTimeUs, flags);
 
-    makeOutputBufferAvailable(index, info);
-    inputBuffersPendingQueuing.remove(Integer.valueOf(index));
+      makeOutputBufferAvailable(index, info);
+      inputBuffersPendingQueuing.remove(Integer.valueOf(index));
+    }
   }
 
   @Implementation
@@ -376,6 +383,9 @@ public class ShadowMediaCodec {
     ((Buffer) inputBuffers[index]).clear();
 
     if (isAsync) {
+      if (canQueueInputBuffer(index)) {
+        throw new IllegalStateException("Input buffer is already available for queuing.");
+      }
       inputBuffersPendingQueuing.add(index);
       // Signal input buffer availability.
       postFakeNativeEvent(EVENT_CALLBACK, CB_INPUT_AVAILABLE, index, null);
@@ -461,7 +471,7 @@ public class ShadowMediaCodec {
    */
   @Implementation(maxSdk = TIRAMISU)
   protected void validateOutputByteBuffer(
-      @Nullable ByteBuffer[] buffers, int index, @NonNull BufferInfo info) {
+      @Nullable ByteBuffer[] buffers, int index, @Nonnull BufferInfo info) {
     if (buffers != null && index >= 0 && index < buffers.length) {
       Buffer buffer = (Buffer) buffers[index];
       if (buffer != null) {
@@ -472,7 +482,7 @@ public class ShadowMediaCodec {
 
   @Implementation(minSdk = U.SDK_INT)
   protected void validateOutputByteBufferLocked(
-      @Nullable ByteBuffer[] buffers, int index, @NonNull BufferInfo info) {
+      @Nullable ByteBuffer[] buffers, int index, @Nonnull BufferInfo info) {
     validateOutputByteBuffer(buffers, index, info);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java
index 1c139b09a..e0b08d262 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java
@@ -2,8 +2,6 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.PendingIntent;
 import android.media.MediaMetadata;
 import android.media.Rating;
@@ -15,6 +13,8 @@ import android.os.Bundle;
 import android.os.Handler;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -111,7 +111,7 @@ public class ShadowMediaController {
   }
 
   /**
-   * Saves the sessionActivty to control the return value of {@link
+   * Saves the sessionActivity to control the return value of {@link
    * MediaController#getSessionActivity()}.
    */
   public void setSessionActivity(PendingIntent sessionActivity) {
@@ -140,7 +140,7 @@ public class ShadowMediaController {
    * registered callbacks. Handler is just passed on to the real class.
    */
   @Implementation
-  protected void registerCallback(@NonNull Callback callback, @Nullable Handler handler) {
+  protected void registerCallback(@Nonnull Callback callback, @Nullable Handler handler) {
     callbacks.add(callback);
     reflector(MediaControllerReflector.class, realMediaController)
         .registerCallback(callback, handler);
@@ -151,7 +151,7 @@ public class ShadowMediaController {
    * registered callbacks.
    */
   @Implementation
-  protected void unregisterCallback(@NonNull Callback callback) {
+  protected void unregisterCallback(@Nonnull Callback callback) {
     callbacks.remove(callback);
     reflector(MediaControllerReflector.class, realMediaController).unregisterCallback(callback);
   }
@@ -206,9 +206,9 @@ public class ShadowMediaController {
   interface MediaControllerReflector {
 
     @Direct
-    void registerCallback(@NonNull Callback callback, @Nullable Handler handler);
+    void registerCallback(@Nonnull Callback callback, @Nullable Handler handler);
 
     @Direct
-    void unregisterCallback(@NonNull Callback callback);
+    void unregisterCallback(@Nonnull Callback callback);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java
index 14de44a53..2110a47cf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.O_MR1;
+import static android.os.Build.VERSION_CODES.R;
 import static org.robolectric.shadows.util.DataSource.toDataSource;
 
 import android.content.Context;
@@ -67,6 +68,12 @@ public class ShadowMediaMetadataRetriever {
     return null;
   }
 
+  @Implementation(minSdk = R)
+  protected Bitmap getFrameAtTime(
+      long timeUs, int option, MediaMetadataRetriever.BitmapParams params) {
+    return getFrameAtTime(timeUs, option);
+  }
+
   @Implementation
   protected Bitmap getFrameAtTime(long timeUs, int option) {
     return (frames.containsKey(dataSource) ? frames.get(dataSource).get(timeUs) : null);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java
index aa2793097..c3196c102 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
 
-import android.annotation.NonNull;
 import android.media.MediaCodec;
 import android.media.MediaMuxer;
 import android.media.MediaMuxer.Format;
@@ -14,6 +13,7 @@ import java.nio.ByteBuffer;
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -54,7 +54,7 @@ public class ShadowMediaMuxer {
    * method overrides that behavior to instead open and maintain a FileOutputStream.
    */
   @Implementation
-  protected void __constructor__(@NonNull String path, @Format int format) throws IOException {
+  protected void __constructor__(@Nonnull String path, @Format int format) throws IOException {
     if (path == null) {
       throw new IllegalArgumentException("path must not be null");
     }
@@ -90,7 +90,7 @@ public class ShadowMediaMuxer {
    * MediaMuxer instances.
    */
   @Implementation
-  protected static long nativeSetup(@NonNull FileDescriptor fd, int format) throws IOException {
+  protected static long nativeSetup(@Nonnull FileDescriptor fd, int format) throws IOException {
     FileOutputStream outputStream = fdToStream.get(fd);
     if (outputStream == null) {
       // If this MediaMuxer was constructed with the un-shadowed MediaMuxer(FileDescriptor, int), no
@@ -111,7 +111,7 @@ public class ShadowMediaMuxer {
   /** Returns an incremented track id for the associated muxer. */
   @Implementation
   protected static int nativeAddTrack(
-      long nativeObject, @NonNull String[] keys, @NonNull Object[] values) {
+      long nativeObject, @Nonnull String[] keys, @Nonnull Object[] values) {
     AtomicInteger nextTrackIndex = nextTrackIndices.get(nativeObject);
     if (nextTrackIndex == null) {
       throw new IllegalStateException("No next track index configured for key: " + nativeObject);
@@ -125,7 +125,7 @@ public class ShadowMediaMuxer {
   protected static void nativeWriteSampleData(
       long nativeObject,
       int trackIndex,
-      @NonNull ByteBuffer byteBuf,
+      @Nonnull ByteBuffer byteBuf,
       int offset,
       int size,
       long presentationTimeUs,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
index e63abfd70..f7be05333 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
@@ -19,7 +19,6 @@ import static org.robolectric.shadows.ShadowMediaPlayer.State.STOPPED;
 import static org.robolectric.shadows.util.DataSource.toDataSource;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
 import android.content.Context;
 import android.content.res.AssetFileDescriptor;
 import android.media.AudioAttributes;
@@ -43,6 +42,7 @@ import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.Random;
 import java.util.TreeMap;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -555,7 +555,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   }
 
   @Implementation(minSdk = U.SDK_INT)
-  protected void __constructor__(@NonNull Context context, int sessionId) {
+  protected void __constructor__(@Nonnull Context context, int sessionId) {
     init();
     // Ensure that the real object is set up properly.
     Shadow.invokeConstructor(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaStore.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaStore.java
index 0d1283af8..0e73fcfaf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaStore.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaStore.java
@@ -3,8 +3,6 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.content.ContentResolver;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory.Options;
@@ -14,6 +12,8 @@ import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -145,7 +145,7 @@ public class ShadowMediaStore {
 
   @Implementation(minSdk = TIRAMISU)
   protected static boolean isSupportedCloudMediaProviderAuthority(
-      @NonNull ContentResolver resolver, @NonNull String authority) {
+      @Nonnull ContentResolver resolver, @Nonnull String authority) {
     return supportedCloudMediaProviderAuthorities.contains(authority);
   }
 
@@ -153,7 +153,7 @@ public class ShadowMediaStore {
    * Mutator method to add the input {@code authorities} to the list of supported cloud media
    * provider authorities.
    */
-  public static void addSupportedCloudMediaProviderAuthorities(@NonNull List<String> authorities) {
+  public static void addSupportedCloudMediaProviderAuthorities(@Nonnull List<String> authorities) {
     supportedCloudMediaProviderAuthorities.addAll(authorities);
   }
 
@@ -164,7 +164,7 @@ public class ShadowMediaStore {
 
   @Implementation(minSdk = TIRAMISU)
   protected static boolean isCurrentCloudMediaProviderAuthority(
-      @NonNull ContentResolver resolver, @NonNull String authority) {
+      @Nonnull ContentResolver resolver, @Nonnull String authority) {
     return currentCloudMediaProviderAuthority.equals(authority);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java
index 572cb9019..86a118a3e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java
@@ -1,72 +1,159 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.os.Build.VERSION_CODES;
+import android.util.Log;
 import android.webkit.MimeTypeMap;
 import java.util.HashMap;
 import java.util.Map;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.annotation.Resetter;
+import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
 
-@Implements(MimeTypeMap.class)
+/**
+ * Shadow for webkit's MimeTypeMap.
+ *
+ * <p>Only needed for APIs < 31. Above that the real mime type mappings are used.
+ *
+ * @deprecated run on Android APIs >= S, which allows the real Android mime type data to be used
+ */
+@Deprecated
+@Implements(value = MimeTypeMap.class)
 public class ShadowMimeTypeMap {
+
+  private static final String LOG_TAG = "ShadowMimeTypeMap";
   private final Map<String, String> extensionToMimeTypeMap = new HashMap<>();
   private final Map<String, String> mimeTypeToExtensionMap = new HashMap<>();
   private static volatile MimeTypeMap singleton = null;
   private static final Object singletonLock = new Object();
 
+  @ReflectorObject private MimeTypeMapReflector mimeTypeMapReflector;
+  private volatile boolean hasClearedMappings = false;
+
   @Implementation
   protected static MimeTypeMap getSingleton() {
-    if (singleton == null) {
-      synchronized (singletonLock) {
-        if (singleton == null) {
-          singleton = Shadow.newInstanceOf(MimeTypeMap.class);
+    if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.R) {
+      if (singleton == null) {
+        synchronized (singletonLock) {
+          if (singleton == null) {
+            singleton = Shadow.newInstanceOf(MimeTypeMap.class);
+          }
         }
+        ShadowMimeTypeMap shadowMimeTypeMap = Shadow.extract(singleton);
+        // add some basic mime type maps for now
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("3gp", "video/3gpp");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("3gpp", "video/3gpp");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("mp4", "video/mp4");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("jpg", "image/jpeg");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("jpeg", "image/jpeg");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("gif", "image/gif");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("png", "image/png");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("m4a", "audio/mpeg");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("mp3", "audio/mpeg");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("zip", "application/zip");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("txt", "text/plain");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping("pdf", "application/pdf");
+        shadowMimeTypeMap.addExtensionMimeTypeMapping(
+            "apk", "application/vnd.android.package-archive");
       }
-    }
-
-    return singleton;
-  }
 
-  @Resetter
-  public static void reset() {
-    if (singleton != null) {
-      ShadowMimeTypeMap shadowMimeTypeMap = Shadow.extract(getSingleton());
-      shadowMimeTypeMap.clearMappings();
+      return singleton;
     }
+    return reflector(MimeTypeMapReflector.class).getSingleton();
   }
 
   @Implementation
   protected String getMimeTypeFromExtension(String extension) {
-    if (extensionToMimeTypeMap.containsKey(extension)) return extensionToMimeTypeMap.get(extension);
-
-    return null;
+    if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.R || hasClearedMappings) {
+      return extensionToMimeTypeMap.get(extension);
+    } else {
+      return mimeTypeMapReflector.getMimeTypeFromExtension(extension);
+    }
   }
 
   @Implementation
   protected String getExtensionFromMimeType(String mimeType) {
-    if (mimeTypeToExtensionMap.containsKey(mimeType)) return mimeTypeToExtensionMap.get(mimeType);
-
-    return null;
+    if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.R || hasClearedMappings) {
+      return mimeTypeToExtensionMap.get(mimeType);
+    } else {
+      return mimeTypeMapReflector.getExtensionFromMimeType(mimeType);
+    }
   }
 
+  /**
+   * Adds a mapping between an extension and a mime type.
+   *
+   * <p>Will be ignored when running on SDKs >= S, where a full mime type mapping is already
+   * present.
+   */
   public void addExtensionMimeTypeMapping(String extension, String mimeType) {
-    extensionToMimeTypeMap.put(extension, mimeType);
-    mimeTypeToExtensionMap.put(mimeType, extension);
+    if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.R || hasClearedMappings) {
+      extensionToMimeTypeMap.put(extension, mimeType);
+      mimeTypeToExtensionMap.put(mimeType, extension);
+    } else {
+      Log.w(
+          LOG_TAG,
+          String.format(
+              "Ignoring addExtensionMimeTypeMapping, API %d has full MimeTypeMap support",
+              RuntimeEnvironment.getApiLevel()));
+    }
   }
 
+  /**
+   * Will clear all built-in mime type mappings, so future calls to APIS like
+   * getExtensionFromMimeType will only return data provided manually via
+   * addExtensionMimeTypeMapping.
+   *
+   * <p>Use of this API is not recommended! It is only present to support legacy, improperly written
+   * tests that fail with valid mime type mappings.
+   */
   public void clearMappings() {
+    hasClearedMappings = true;
     extensionToMimeTypeMap.clear();
     mimeTypeToExtensionMap.clear();
   }
 
   @Implementation
   protected boolean hasExtension(String extension) {
-    return extensionToMimeTypeMap.containsKey(extension);
+    if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.R || hasClearedMappings) {
+      return extensionToMimeTypeMap.containsKey(extension);
+    } else {
+      return mimeTypeMapReflector.hasExtension(extension);
+    }
   }
 
   @Implementation
   protected boolean hasMimeType(String mimeType) {
-    return mimeTypeToExtensionMap.containsKey(mimeType);
+    if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.R || hasClearedMappings) {
+      return mimeTypeToExtensionMap.containsKey(mimeType);
+    } else {
+      return mimeTypeMapReflector.hasMimeType(mimeType);
+    }
+  }
+
+  @ForType(MimeTypeMap.class)
+  private interface MimeTypeMapReflector {
+
+    @Static
+    @Direct
+    MimeTypeMap getSingleton();
+
+    @Direct
+    String getMimeTypeFromExtension(String extension);
+
+    @Direct
+    String getExtensionFromMimeType(String mimeType);
+
+    @Direct
+    boolean hasExtension(String extension);
+
+    @Direct
+    boolean hasMimeType(String mimeType);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
index 2ca5fbf7a..58308c364 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
@@ -31,6 +31,8 @@ import org.robolectric.nativeruntime.HardwareRendererNatives;
 import org.robolectric.shadows.ShadowNativeHardwareRenderer.Picker;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.Baklava;
+import org.robolectric.annotation.InDevelopment;
 
 /** Shadow for {@link HardwareRenderer} that is backed by native code */
 @Implements(
@@ -49,6 +51,12 @@ public class ShadowNativeHardwareRenderer {
     HardwareRendererNatives.preload();
   }
 
+  @InDevelopment
+  @Implementation(minSdk = Baklava.SDK_INT)
+  protected static void preInitBufferAllocator() {
+    // no-op, this method isn't bound on host platforms.
+  }
+
   @Implementation(minSdk = S, maxSdk = U.SDK_INT)
   protected static boolean isWebViewOverlaysEnabled() {
     return HardwareRendererNatives.isWebViewOverlaysEnabled();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSQLiteConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSQLiteConnection.java
index 9209c94fb..8ab3caee8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSQLiteConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSQLiteConnection.java
@@ -8,11 +8,14 @@ import static android.os.Build.VERSION_CODES.S_V2;
 import android.database.sqlite.SQLiteConnection;
 import java.util.function.BinaryOperator;
 import java.util.function.UnaryOperator;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
 import org.robolectric.nativeruntime.SQLiteConnectionNatives;
 import org.robolectric.util.PerfStatsCollector;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
 
@@ -22,6 +25,16 @@ import org.robolectric.versioning.AndroidVersions.U;
     isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
 public class ShadowNativeSQLiteConnection extends ShadowSQLiteConnection {
+  
+  /**
+   * TODO: rexhoffman@google.com delete when new .so is available.
+   */
+  @Implementation(maxSdk=U.SDK_INT)
+  protected static void nativeClose(long connectionPtr, boolean fast) {
+    PerfStatsCollector.getInstance()
+            .measure("androidsqlite", () -> SQLiteConnectionNatives.nativeClose(connectionPtr));
+  }
+
   @Implementation(maxSdk = O)
   protected static long nativeOpen(
       String path, int openFlags, String label, boolean enableTrace, boolean enableProfile) {
@@ -58,14 +71,6 @@ public class ShadowNativeSQLiteConnection extends ShadowSQLiteConnection {
         .measure("androidsqlite", () -> SQLiteConnectionNatives.nativeClose(connectionPtr));
   }
 
-  @Implementation(maxSdk = U.SDK_INT)
-  protected static long nativePrepareStatement(long connectionPtr, String sql) {
-    return PerfStatsCollector.getInstance()
-        .measure(
-            "androidsqlite",
-            () -> SQLiteConnectionNatives.nativePrepareStatement(connectionPtr, sql));
-  }
-
   @Implementation(maxSdk = U.SDK_INT)
   protected static void nativeFinalizeStatement(long connectionPtr, long statementPtr) {
     PerfStatsCollector.getInstance()
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java
index ef12e6905..12b9bca26 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java
@@ -4,8 +4,6 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.graphics.fonts.Font;
 import android.graphics.fonts.FontCustomizationParser;
 import android.graphics.fonts.FontFamily;
@@ -23,6 +21,8 @@ import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.Map;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
@@ -88,7 +88,7 @@ public class ShadowNativeSystemFonts {
 
   @Implementation(minSdk = Q, maxSdk = Q)
   @Nullable
-  protected static ByteBuffer mmap(@NonNull String fullPath) {
+  protected static ByteBuffer mmap(@Nonnull String fullPath) {
     try (FileInputStream file = new FileInputStream(fullPath)) {
       final FileChannel fileChannel = file.getChannel();
       final long fontSize = fileChannel.size();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
index eb106444b..c8a05d1e6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
@@ -28,12 +28,14 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
 import org.robolectric.nativeruntime.TypefaceNatives;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow for {@link Typeface} that is backed by native code */
@@ -205,6 +207,14 @@ public class ShadowNativeTypeface extends ShadowTypeface {
     return TypefaceNatives.nativeGetFamily(nativePtr, index);
   }
 
+  @Implementation(minSdk = AndroidVersions.Baklava.SDK_INT)
+  @InDevelopment
+  protected static boolean nativeIsVariationInstance(long nativePtr) {
+    return false;
+    // TODO: call the real impl when it's finally available in native binaries
+    // return TypefaceNatives.nativeIsVariationInstance(nativePtr);
+  }
+
   @Implementation(minSdk = Q, maxSdk = U.SDK_INT)
   protected static void nativeRegisterGenericFamily(String str, long nativePtr) {
     TypefaceNatives.nativeRegisterGenericFamily(str, nativePtr);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
index 13325c0d3..d4cd3f3f5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
@@ -8,7 +8,6 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 
-import android.annotation.NonNull;
 import android.app.AutomaticZenRule;
 import android.app.Notification;
 import android.app.NotificationChannel;
@@ -30,6 +29,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -425,7 +425,7 @@ public class ShadowNotificationManager {
   }
 
   @Implementation(minSdk = Q)
-  protected boolean canNotifyAsPackage(@NonNull String pkg) {
+  protected boolean canNotifyAsPackage(@Nonnull String pkg) {
     // TODO: This doesn't work correctly with notification delegates because
     // ShadowNotificationManager doesn't respect the associated context, it just uses the global
     // RuntimeEnvironment.getApplication() context.
@@ -443,7 +443,7 @@ public class ShadowNotificationManager {
    * @param otherPackage the package for which the current package can notify on behalf
    * @param canNotify whether the current package is set as notification delegate for 'otherPackage'
    */
-  public void setCanNotifyAsPackage(@NonNull String otherPackage, boolean canNotify) {
+  public void setCanNotifyAsPackage(@Nonnull String otherPackage, boolean canNotify) {
     if (canNotify) {
       canNotifyOnBehalfPackages.add(otherPackage);
     } else {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
index ae01b8794..b0aec4585 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
@@ -3,20 +3,23 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.content.Context;
 import android.content.om.OverlayInfo;
 import android.content.om.OverlayManager;
 import android.content.pm.PackageManager;
 import android.os.UserHandle;
+import com.android.internal.content.om.OverlayManagerImpl;
 import java.util.HashMap;
 import java.util.Map;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions;
 
 /**
  * Basic shadow implementation for the {@link OverlayManager}.
@@ -60,12 +63,12 @@ public final class ShadowOverlayManager {
   @Implementation
   @Nullable
   protected OverlayInfo getOverlayInfo(
-      @NonNull String packageName, @NonNull UserHandle userHandle) {
+      @Nonnull String packageName, @Nonnull UserHandle userHandle) {
     return overlaysByPackageName.get(packageName);
   }
 
   @Implementation
-  protected void setEnabled(@NonNull String packageName, boolean enable, @NonNull UserHandle user) {
+  protected void setEnabled(@Nonnull String packageName, boolean enable, @Nonnull UserHandle user) {
     checkPermission();
 
     OverlayInfo overlay = overlaysByPackageName.get(packageName);
@@ -88,10 +91,26 @@ public final class ShadowOverlayManager {
   interface OverlayManagerReflector {
     @Accessor("mContext")
     Context getContext();
+
+    @Accessor("mOverlayManagerImpl")
+    OverlayManagerImpl getOverlayManagerImpl();
+  }
+
+  @ForType(OverlayManagerImpl.class)
+  interface OverlayManagerImplReflector {
+    @Accessor("mContext")
+    Context getContext();
   }
 
   private void checkPermission() {
-    Context context = reflector(OverlayManagerReflector.class, realOverlayManager).getContext();
+    Context context = null;
+    if (RuntimeEnvironment.getApiLevel() >= AndroidVersions.Baklava.SDK_INT) {
+      OverlayManagerImpl overlayManagerImpl =
+          reflector(OverlayManagerReflector.class, realOverlayManager).getOverlayManagerImpl();
+      context = reflector(OverlayManagerImplReflector.class, overlayManagerImpl).getContext();
+    } else {
+      context = reflector(OverlayManagerReflector.class, realOverlayManager).getContext();
+    }
     if (context.checkSelfPermission(android.Manifest.permission.CHANGE_OVERLAY_PACKAGES)
         != PackageManager.PERMISSION_GRANTED) {
       throw new SecurityException(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
index 38a0b1ff4..d4a24033b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
@@ -6,14 +6,11 @@ import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.Shadows.shadowOf;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.content.Intent;
 import android.content.IntentSender;
 import android.content.IntentSender.SendIntentException;
 import android.content.pm.PackageInstaller;
-import android.content.pm.PackageInstaller.PreapprovalDetails;
 import android.content.pm.PackageInstaller.SessionInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.VersionedPackage;
@@ -32,7 +29,10 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -79,7 +79,7 @@ public class ShadowPackageInstaller {
 
   @Implementation
   protected void registerSessionCallback(
-      @NonNull PackageInstaller.SessionCallback callback, @NonNull Handler handler) {
+      @Nonnull PackageInstaller.SessionCallback callback, @Nonnull Handler handler) {
     CallbackInfo callbackInfo = new CallbackInfo();
     callbackInfo.callback = callback;
     callbackInfo.handler = handler;
@@ -87,7 +87,7 @@ public class ShadowPackageInstaller {
   }
 
   @Implementation
-  protected void unregisterSessionCallback(@NonNull PackageInstaller.SessionCallback callback) {
+  protected void unregisterSessionCallback(@Nonnull PackageInstaller.SessionCallback callback) {
     for (Iterator<CallbackInfo> i = callbackInfos.iterator(); i.hasNext(); ) {
       final CallbackInfo callbackInfo = i.next();
       if (callbackInfo.callback == callback) {
@@ -104,7 +104,7 @@ public class ShadowPackageInstaller {
   }
 
   @Implementation
-  protected int createSession(@NonNull PackageInstaller.SessionParams params) throws IOException {
+  protected int createSession(@Nonnull PackageInstaller.SessionParams params) throws IOException {
     final PackageInstaller.SessionInfo sessionInfo = new PackageInstaller.SessionInfo();
     sessionInfo.sessionId = nextSessionId++;
     sessionInfo.active = true;
@@ -135,7 +135,7 @@ public class ShadowPackageInstaller {
   }
 
   @Implementation
-  @NonNull
+  @Nonnull
   protected PackageInstaller.Session openSession(int sessionId) throws IOException {
     if (!sessionInfos.containsKey(sessionId)) {
       throw new SecurityException("Invalid session Id: " + sessionId);
@@ -343,7 +343,9 @@ public class ShadowPackageInstaller {
 
     @Implementation(minSdk = UPSIDE_DOWN_CAKE)
     protected void requestUserPreapproval(
-        @NonNull PreapprovalDetails details, @NonNull IntentSender statusReceiver) {
+        @Nonnull @ClassName("android.content.pm.PackageInstaller$PreapprovalDetails")
+            Object details,
+        @Nonnull IntentSender statusReceiver) {
       preapprovalStatusReceiver = statusReceiver;
     }
 
@@ -353,14 +355,14 @@ public class ShadowPackageInstaller {
     }
 
     @Implementation(minSdk = UPSIDE_DOWN_CAKE)
-    @NonNull
+    @Nonnull
     protected PersistableBundle getAppMetadata() {
       return appMetadata;
     }
 
     @Implementation
-    @NonNull
-    protected OutputStream openWrite(@NonNull String name, long offsetBytes, long lengthBytes)
+    @Nonnull
+    protected OutputStream openWrite(@Nonnull String name, long offsetBytes, long lengthBytes)
         throws IOException {
       outputStream =
           new OutputStream() {
@@ -377,10 +379,10 @@ public class ShadowPackageInstaller {
     }
 
     @Implementation
-    protected void fsync(@NonNull OutputStream out) throws IOException {}
+    protected void fsync(@Nonnull OutputStream out) throws IOException {}
 
     @Implementation
-    protected void commit(@NonNull IntentSender statusReceiver) {
+    protected void commit(@Nonnull IntentSender statusReceiver) {
       this.statusReceiver = statusReceiver;
       if (outputStreamOpen) {
         throw new SecurityException("OutputStream still open");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java
index 73deac68a..503286af3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java
@@ -27,6 +27,7 @@ import org.robolectric.annotation.TextLayoutMode;
 import org.robolectric.config.ConfigurationRegistry;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
@@ -210,6 +211,13 @@ public class ShadowPaint {
     return typeface;
   }
 
+  @Implementation(minSdk = AndroidVersions.Baklava.SDK_INT)
+  @InDevelopment
+  protected Typeface setTypefaceWithoutWarning(Typeface typeface) {
+    this.typeface = typeface;
+    return typeface;
+  }
+
   @Implementation
   protected float getTextSize() {
     return textSize;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
index 4eeada1bb..d5ed7ea5f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
@@ -109,11 +109,12 @@ public final class ShadowPausedLooper extends ShadowLooper {
     long endingTimeMs = SystemClock.uptimeMillis() + timeUnit.toMillis(time);
     long nextScheduledTimeMs = getNextScheduledTaskTime().toMillis();
     while (nextScheduledTimeMs != 0 && nextScheduledTimeMs <= endingTimeMs) {
-      SystemClock.setCurrentTimeMillis(nextScheduledTimeMs);
+      ShadowSystemClock.advanceBy(
+          nextScheduledTimeMs - SystemClock.uptimeMillis(), TimeUnit.MILLISECONDS);
       idle();
       nextScheduledTimeMs = getNextScheduledTaskTime().toMillis();
     }
-    SystemClock.setCurrentTimeMillis(endingTimeMs);
+    ShadowSystemClock.advanceBy(endingTimeMs - SystemClock.uptimeMillis(), TimeUnit.MILLISECONDS);
     // the last SystemClock update might have added new tasks to the main looper via Choreographer
     // so idle once more.
     idle();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
index 1390d0acc..dd4d5535a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
@@ -320,7 +320,7 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
           }
         }
         if (msg.isAsynchronous() && getApiLevel() >= V.SDK_INT) {
-            queueReflector.setAsyncMessageCount(queueReflector.getAsyncMessageCount() - 1);
+          queueReflector.setAsyncMessageCount(queueReflector.getAsyncMessageCount() - 1);
         }
       }
       return msg;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
index 21024ad82..d9afb7f1d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
@@ -1,9 +1,11 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.S;
 
 import android.os.SystemClock;
 import java.time.DateTimeException;
+import java.time.Duration;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 import javax.annotation.concurrent.GuardedBy;
@@ -30,20 +32,21 @@ import org.robolectric.annotation.Resetter;
     isInAndroidSdk = false,
     shadowPicker = ShadowSystemClock.Picker.class)
 public class ShadowPausedSystemClock extends ShadowSystemClock {
-  private static final long INITIAL_TIME = 100;
-  private static final int MILLIS_PER_NANO = 1000000;
+  static final int MILLIS_PER_NANO = 1_000_000;
+  private static final int MILLIS_PER_MICRO = 1_000;
+  private static final long INITIAL_TIME_NS = 100 * MILLIS_PER_NANO;
 
   @SuppressWarnings("NonFinalStaticField")
   @GuardedBy("ShadowPausedSystemClock.class")
-  private static long currentUptimeMillis = INITIAL_TIME;
+  private static long currentUptimeNs = INITIAL_TIME_NS;
 
   @SuppressWarnings("NonFinalStaticField")
   @GuardedBy("ShadowPausedSystemClock.class")
-  private static long currentRealtimeMillis = INITIAL_TIME;
+  private static long currentRealtimeNs = INITIAL_TIME_NS;
 
   private static final List<Listener> listeners = new CopyOnWriteArrayList<>();
   // hopefully temporary list of clock listeners that are NOT cleared between tests
-  // This is needed to accomodate Loopers which are not reset between tests
+  // This is needed to accommodate Loopers which are not reset between tests
   private static final List<Listener> staticListeners = new CopyOnWriteArrayList<>();
 
   /** Callback for clock updates */
@@ -71,8 +74,8 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
   @Implementation
   protected static void sleep(long millis) {
     synchronized (ShadowPausedSystemClock.class) {
-      currentUptimeMillis += millis;
-      currentRealtimeMillis += millis;
+      currentUptimeNs += (millis * MILLIS_PER_NANO);
+      currentRealtimeNs += (millis * MILLIS_PER_NANO);
     }
     informListeners();
   }
@@ -86,7 +89,7 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
    */
   protected static void deepSleep(long millis) {
     synchronized (ShadowPausedSystemClock.class) {
-      currentRealtimeMillis += millis;
+      currentRealtimeNs += (millis * MILLIS_PER_NANO);
     }
     informListeners();
   }
@@ -105,20 +108,34 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
    *
    * <p>This API sets both of the elapsed realtime and uptime to the specified value.
    *
-   * <p>Currently does not perform any permission checks.
+   * <p>Use of this method is discouraged. It currently has the following inconsistent behavior:
+   *
+   * <ol>
+   *   <li>>It doesn't check permissions. In real android this method is protected by the
+   *       signature/privileged SET_TIME permission, thus it is uncallable by most apps
+   *   <li>It doesn't actually change the value of System.currentTimeMillis for non-instrumented
+   *       code aka nearly all user tests and apps It only allows advancing the current time, not
+   *       moving it backwards
+   *   <li>It incorrectly changes the value of SystemClock.uptime, elapsedRealtime, and for
+   *       instrumented code System.nanoTime. In real android these are all independent clocks
+   * </ol>
+   *
+   * <p>It is recommended to use ShadowSystemClock.advanceBy instead to advance
+   * SystemClock.uptimeMillis and SystemClock.elapsedRealTime
    *
    * @return false if specified time is less than current uptime.
    */
   @Implementation
   protected static boolean setCurrentTimeMillis(long millis) {
+    long newTimeNs = millis * MILLIS_PER_NANO;
     synchronized (ShadowPausedSystemClock.class) {
-      if (currentUptimeMillis > millis) {
+      if (currentUptimeNs > newTimeNs) {
         return false;
-      } else if (currentUptimeMillis == millis) {
+      } else if (currentUptimeNs == newTimeNs) {
         return true;
       } else {
-        currentUptimeMillis = millis;
-        currentRealtimeMillis = millis;
+        currentUptimeNs = newTimeNs;
+        currentRealtimeNs = newTimeNs;
       }
     }
     informListeners();
@@ -126,18 +143,23 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
   }
 
   @Implementation
-  protected static synchronized long uptimeMillis() {
-    return currentUptimeMillis;
+  protected static long uptimeMillis() {
+    return uptimeNanos() / MILLIS_PER_NANO;
+  }
+
+  @Implementation(minSdk = S)
+  protected static synchronized long uptimeNanos() {
+    return currentUptimeNs;
   }
 
   @Implementation
-  protected static synchronized long elapsedRealtime() {
-    return currentRealtimeMillis;
+  protected static long elapsedRealtime() {
+    return elapsedRealtimeNanos() / MILLIS_PER_NANO;
   }
 
   @Implementation
-  protected static long elapsedRealtimeNanos() {
-    return elapsedRealtime() * MILLIS_PER_NANO;
+  protected static synchronized long elapsedRealtimeNanos() {
+    return currentRealtimeNs;
   }
 
   @Implementation
@@ -148,7 +170,7 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
   @HiddenApi
   @Implementation
   protected static long currentThreadTimeMicro() {
-    return uptimeMillis() * 1000;
+    return uptimeNanos() / MILLIS_PER_MICRO;
   }
 
   @HiddenApi
@@ -161,16 +183,28 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
   @HiddenApi
   protected static synchronized long currentNetworkTimeMillis() {
     if (networkTimeAvailable) {
-      return currentUptimeMillis;
+      return uptimeMillis();
     } else {
       throw new DateTimeException("Network time not available");
     }
   }
 
+  static void internalAdvanceBy(Duration duration) {
+    if (duration.toNanos() <= 0) {
+      // ignore
+      return;
+    }
+    synchronized (ShadowPausedSystemClock.class) {
+      currentUptimeNs += duration.toNanos();
+      currentRealtimeNs += duration.toNanos();
+    }
+    informListeners();
+  }
+
   @Resetter
   public static synchronized void reset() {
-    currentUptimeMillis = INITIAL_TIME;
-    currentRealtimeMillis = INITIAL_TIME;
+    currentUptimeNs = INITIAL_TIME_NS;
+    currentRealtimeNs = INITIAL_TIME_NS;
     ShadowSystemClock.reset();
     listeners.clear();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
index 73bcfa052..d664923c3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
@@ -12,7 +12,6 @@ import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.ActivityThread;
@@ -33,6 +32,7 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.RuntimeEnvironment;
@@ -69,7 +69,7 @@ public class ShadowPendingIntent {
 
   @RealObject private PendingIntent realPendingIntent;
 
-  @NonNull private Intent[] savedIntents;
+  @Nonnull private Intent[] savedIntents;
   private Context savedContext;
   private Type type;
   private int requestCode;
@@ -88,43 +88,43 @@ public class ShadowPendingIntent {
 
   @Implementation
   protected static PendingIntent getActivity(
-      Context context, int requestCode, @NonNull Intent intent, int flags) {
+      Context context, int requestCode, @Nonnull Intent intent, int flags) {
     return create(context, new Intent[] {intent}, Type.ACTIVITY, requestCode, flags, null);
   }
 
   @Implementation
   protected static PendingIntent getActivity(
-      Context context, int requestCode, @NonNull Intent intent, int flags, Bundle options) {
+      Context context, int requestCode, @Nonnull Intent intent, int flags, Bundle options) {
     return create(context, new Intent[] {intent}, Type.ACTIVITY, requestCode, flags, options);
   }
 
   @Implementation
   protected static PendingIntent getActivities(
-      Context context, int requestCode, @NonNull Intent[] intents, int flags) {
+      Context context, int requestCode, @Nonnull Intent[] intents, int flags) {
     return create(context, intents, Type.ACTIVITY, requestCode, flags, null);
   }
 
   @Implementation
   protected static PendingIntent getActivities(
-      Context context, int requestCode, @NonNull Intent[] intents, int flags, Bundle options) {
+      Context context, int requestCode, @Nonnull Intent[] intents, int flags, Bundle options) {
     return create(context, intents, Type.ACTIVITY, requestCode, flags, options);
   }
 
   @Implementation
   protected static PendingIntent getBroadcast(
-      Context context, int requestCode, @NonNull Intent intent, int flags) {
+      Context context, int requestCode, @Nonnull Intent intent, int flags) {
     return create(context, new Intent[] {intent}, Type.BROADCAST, requestCode, flags, null);
   }
 
   @Implementation
   protected static PendingIntent getService(
-      Context context, int requestCode, @NonNull Intent intent, int flags) {
+      Context context, int requestCode, @Nonnull Intent intent, int flags) {
     return create(context, new Intent[] {intent}, Type.SERVICE, requestCode, flags, null);
   }
 
   @Implementation(minSdk = O)
   protected static PendingIntent getForegroundService(
-      Context context, int requestCode, @NonNull Intent intent, int flags) {
+      Context context, int requestCode, @Nonnull Intent intent, int flags) {
     return create(
         context, new Intent[] {intent}, Type.FOREGROUND_SERVICE, requestCode, flags, null);
   }
@@ -541,7 +541,7 @@ public class ShadowPendingIntent {
 
   @Implementation
   @Nullable
-  public static PendingIntent readPendingIntentOrNullFromParcel(@NonNull Parcel in) {
+  public static PendingIntent readPendingIntentOrNullFromParcel(@Nonnull Parcel in) {
     int intentIndex = in.readInt();
     if (intentIndex == NULL_PENDING_INTENT_VALUE) {
       return null;
@@ -551,7 +551,7 @@ public class ShadowPendingIntent {
 
   @Implementation
   public static void writePendingIntentOrNullToParcel(
-      @Nullable PendingIntent sender, @NonNull Parcel out) {
+      @Nullable PendingIntent sender, @Nonnull Parcel out) {
     if (sender == null) {
       out.writeInt(NULL_PENDING_INTENT_VALUE);
       return;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java
index d34cb5e91..5f6f20b67 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java
@@ -6,7 +6,6 @@ import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowApplicationPackageManager.PERMISSION_CONTROLLER_PACKAGE_NAME;
 
 import android.annotation.CallbackExecutor;
-import android.annotation.NonNull;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -24,6 +23,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -41,7 +41,7 @@ public class ShadowPermissionControllerManager {
   @RealObject PermissionControllerManager realObject;
 
   @Implementation
-  protected void __constructor__(@NonNull Context context, @NonNull Handler handler) {
+  protected void __constructor__(@Nonnull Context context, @Nonnull Handler handler) {
     packageManager = context.getPackageManager();
     if (resolveInfoRegistered.compareAndSet(false, true)) {
       ensureResolveInfoRegistered();
@@ -63,11 +63,11 @@ public class ShadowPermissionControllerManager {
    */
   @Implementation
   protected void revokeRuntimePermissions(
-      @NonNull Map<String, List<String>> request,
+      @Nonnull Map<String, List<String>> request,
       boolean doDryRun,
       @Reason int reason,
-      @NonNull @CallbackExecutor Executor executor,
-      @NonNull OnRevokeRuntimePermissionsCallback callback) {
+      @Nonnull @CallbackExecutor Executor executor,
+      @Nonnull OnRevokeRuntimePermissionsCallback callback) {
     if (doDryRun) {
       throw new UnsupportedOperationException("Dry run not implemented");
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
index ee6befb04..e1a2449b8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
@@ -4,8 +4,6 @@ import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Paint;
@@ -22,6 +20,8 @@ import android.view.Window;
 import android.view.WindowManagerGlobal;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -47,20 +47,20 @@ public class ShadowPixelCopy {
   @Implementation
   protected static void request(
       SurfaceView source,
-      @NonNull Bitmap dest,
-      @NonNull OnPixelCopyFinishedListener listener,
-      @NonNull Handler listenerThread) {
+      @Nonnull Bitmap dest,
+      @Nonnull OnPixelCopyFinishedListener listener,
+      @Nonnull Handler listenerThread) {
     takeScreenshot(source, dest, null);
     alertFinished(listener, listenerThread, PixelCopy.SUCCESS);
   }
 
   @Implementation
   protected static void request(
-      @NonNull SurfaceView source,
+      @Nonnull SurfaceView source,
       @Nullable Rect srcRect,
-      @NonNull Bitmap dest,
-      @NonNull OnPixelCopyFinishedListener listener,
-      @NonNull Handler listenerThread) {
+      @Nonnull Bitmap dest,
+      @Nonnull OnPixelCopyFinishedListener listener,
+      @Nonnull Handler listenerThread) {
     if (srcRect != null && srcRect.isEmpty()) {
       throw new IllegalArgumentException("sourceRect is empty");
     }
@@ -70,20 +70,20 @@ public class ShadowPixelCopy {
 
   @Implementation
   protected static void request(
-      @NonNull Window source,
-      @NonNull Bitmap dest,
-      @NonNull OnPixelCopyFinishedListener listener,
-      @NonNull Handler listenerThread) {
+      @Nonnull Window source,
+      @Nonnull Bitmap dest,
+      @Nonnull OnPixelCopyFinishedListener listener,
+      @Nonnull Handler listenerThread) {
     request(source, null, dest, listener, listenerThread);
   }
 
   @Implementation
   protected static void request(
-      @NonNull Window source,
+      @Nonnull Window source,
       @Nullable Rect srcRect,
-      @NonNull Bitmap dest,
-      @NonNull OnPixelCopyFinishedListener listener,
-      @NonNull Handler listenerThread) {
+      @Nonnull Bitmap dest,
+      @Nonnull OnPixelCopyFinishedListener listener,
+      @Nonnull Handler listenerThread) {
     if (srcRect != null && srcRect.isEmpty()) {
       throw new IllegalArgumentException("sourceRect is empty");
     }
@@ -93,11 +93,11 @@ public class ShadowPixelCopy {
 
   @Implementation
   protected static void request(
-      @NonNull Surface source,
+      @Nonnull Surface source,
       @Nullable Rect srcRect,
-      @NonNull Bitmap dest,
-      @NonNull OnPixelCopyFinishedListener listener,
-      @NonNull Handler listenerThread) {
+      @Nonnull Bitmap dest,
+      @Nonnull OnPixelCopyFinishedListener listener,
+      @Nonnull Handler listenerThread) {
     if (srcRect != null && srcRect.isEmpty()) {
       throw new IllegalArgumentException("sourceRect is empty");
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
index bb3f0e575..03b09eb8e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
@@ -16,8 +16,6 @@ import static java.util.Comparator.comparing;
 import static java.util.stream.Collectors.toCollection;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.TargetApi;
@@ -40,6 +38,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
@@ -328,7 +328,7 @@ public class ShadowPowerManager {
   @RequiresPermission(android.Manifest.permission.DEVICE_POWER)
   @Implementation(minSdk = S)
   protected void setBatteryDischargePrediction(
-      @NonNull Duration timeRemaining, boolean isPersonalized) {
+      @Nonnull Duration timeRemaining, boolean isPersonalized) {
     this.batteryDischargePrediction = timeRemaining;
     this.isBatteryDischargePredictionPersonalized = isPersonalized;
   }
@@ -472,6 +472,7 @@ public class ShadowPowerManager {
     private void acquireInternal(Optional<Long> timeoutOptional) {
       ++timesHeld;
       timeoutTimestampList.add(timeoutOptional);
+      reflector(WakeLockReflector.class, realWakeLock).setHeld(true);
     }
 
     /** Iterate all the wake lock and remove those timeouted ones. */
@@ -531,6 +532,7 @@ public class ShadowPowerManager {
         // the effect of all previous calls to acquire().
         timeoutTimestampList = new ArrayList<>();
       }
+      reflector(WakeLockReflector.class, realWakeLock).setHeld(false);
     }
 
     @Implementation
@@ -578,6 +580,9 @@ public class ShadowPowerManager {
     private interface WakeLockReflector {
       @Accessor("mTag")
       String getTag();
+
+      @Accessor("mHeld")
+      void setHeld(boolean held);
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
index 9fea8a952..40a202378 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
@@ -3,12 +3,12 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkArgument;
 
-import android.annotation.NonNull;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ThreadLocalRandom;
+import javax.annotation.Nonnull;
 import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -191,7 +191,7 @@ public class ShadowProcess {
    *
    * @param processName New process name to set. Cannot be null.
    */
-  public static void setProcessName(@NonNull String processName) {
+  public static void setProcessName(@Nonnull String processName) {
     ShadowProcess.processName = processName;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java
index 58c191912..9f2a30349 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java
@@ -8,7 +8,7 @@ import org.robolectric.annotation.Implements;
 /**
  * Shadow for {@link android.net.wifi.rtt.RangingResult}.
  *
- * @deprecated Use {link RangingResultBuilder} instead.
+ * @deprecated Use {@link RangingResultBuilder} instead.
  */
 @Deprecated
 @Implements(value = RangingResult.class, minSdk = VERSION_CODES.P)
@@ -19,7 +19,7 @@ public class ShadowRangingResult {
    * are all mandatory fields. Additional fields can be specified by setters. Use build() to return
    * the ShadowRangingResult object.
    *
-   * @deprecated Use {link RangingResultBuilder} instead.
+   * @deprecated Use {@link RangingResultBuilder} instead.
    */
   @Deprecated
   public static class Builder extends RangingResultBuilder {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java
index 8f8cf4fe8..429181563 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java
@@ -3,8 +3,6 @@ package org.robolectric.shadows;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.role.IRoleManager;
 import android.app.role.RoleManager;
 import android.content.Context;
@@ -16,6 +14,8 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -68,7 +68,7 @@ public class ShadowRoleManager {
    * @return whether the calling application is holding the role
    */
   @Implementation
-  protected boolean isRoleHeld(@NonNull String roleName) {
+  protected boolean isRoleHeld(@Nonnull String roleName) {
     Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
     return context.getPackageName().equals(roleToHolder.get(roleName));
   }
@@ -79,13 +79,13 @@ public class ShadowRoleManager {
    *
    * <p>This method makes the role available as well.
    */
-  public void addHeldRole(@NonNull String roleName) {
+  public void addHeldRole(@Nonnull String roleName) {
     addAvailableRole(roleName);
     roleToHolder.put(roleName, context.getPackageName());
   }
 
   /* Remove a role previously added via {@link #addHeldRole(String)}. */
-  public void removeHeldRole(@NonNull String roleName) {
+  public void removeHeldRole(@Nonnull String roleName) {
     Preconditions.checkArgument(isRoleHeld(roleName), "the supplied roleName was never added.");
     roleToHolder.put(roleName, null);
   }
@@ -101,7 +101,7 @@ public class ShadowRoleManager {
    * @return whether the role is available
    */
   @Implementation
-  protected boolean isRoleAvailable(@NonNull String roleName) {
+  protected boolean isRoleAvailable(@Nonnull String roleName) {
     Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
     return roleToHolder.containsKey(roleName);
   }
@@ -110,7 +110,7 @@ public class ShadowRoleManager {
    * Add a role that will be recognized as available when invoking {@link
    * RoleManager#isRoleAvailable(String)}.
    */
-  public void addAvailableRole(@NonNull String roleName) {
+  public void addAvailableRole(@Nonnull String roleName) {
     Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
     if (!isRoleAvailable(roleName)) {
       roleToHolder.put(roleName, null);
@@ -118,7 +118,7 @@ public class ShadowRoleManager {
   }
 
   /* Remove a role previously added via {@link #addAvailableRole(String)}. */
-  public void removeAvailableRole(@NonNull String roleName) {
+  public void removeAvailableRole(@Nonnull String roleName) {
     Preconditions.checkArgument(
         roleToHolder.containsKey(roleName), "the supplied roleName was never added.");
     roleToHolder.remove(roleName);
@@ -126,17 +126,17 @@ public class ShadowRoleManager {
 
   @Nullable
   @Implementation(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
-  protected String getDefaultApplication(@NonNull String roleName) {
+  protected String getDefaultApplication(@Nonnull String roleName) {
     return roleToHolder.get(roleName);
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
   protected void setDefaultApplication(
-      @NonNull String roleName,
+      @Nonnull String roleName,
       @Nullable String packageName,
       int flags,
-      @NonNull Executor executor,
-      @NonNull Consumer<Boolean> callback) {
+      @Nonnull Executor executor,
+      @Nonnull Consumer<Boolean> callback) {
     Preconditions.checkArgument(
         Arrays.asList(DEFAULT_APPLICATION_ROLES).contains(roleName),
         "the supplied roleName in not a default app.");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java
index 510601aad..6bfad1429 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java
@@ -1,10 +1,18 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O_MR1;
+import static android.os.Build.VERSION_CODES.P;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.annotation.RequiresApi;
+import android.database.sqlite.SQLiteDatabase.OpenParams;
 import android.database.sqlite.SQLiteOpenHelper;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 
 /**
  * Avoid calls to setIdleConnectionTimeout. They shouldn't matter for tests, but sometimes induced
@@ -12,9 +20,56 @@ import org.robolectric.annotation.Implements;
  */
 @Implements(SQLiteOpenHelper.class)
 public class ShadowSQLiteOpenHelper {
+
+  @RealObject private SQLiteOpenHelper realSQLiteOpenHelper;
+
+  public static final long IDLE_CONNECTION_TIMEOUT_DISABLED = -1L;
+
+  private long idleConnectionTimeoutMs = IDLE_CONNECTION_TIMEOUT_DISABLED;
+
+  public long getIdleConnectionTimeout() {
+    return idleConnectionTimeoutMs;
+  }
+
+  @RequiresApi(api = P)
+  public OpenParams getOpenParams() {
+    OpenParams.Builder openParamsBuilder =
+        reflector(SQLiteOpenHelperReflector.class, realSQLiteOpenHelper).getOpenParamsBuilder();
+    if (idleConnectionTimeoutMs != IDLE_CONNECTION_TIMEOUT_DISABLED) {
+      // Add the idle connection timeout (see setIdleConnectionTimeout()).
+      // Copy the builder to avoid modifying the real object.
+      openParamsBuilder =
+          new OpenParams.Builder(openParamsBuilder.build())
+              .setIdleConnectionTimeout(idleConnectionTimeoutMs);
+    }
+    return openParamsBuilder.build();
+  }
+
   @Implementation(minSdk = O_MR1)
   protected void setIdleConnectionTimeout(long idleConnectionTimeoutMs) {
-    // Calling the real one currently results in a Robolectric deadlock. Just ignore it.
+    // Calling the real one currently results in a Robolectric deadlock.
     // See https://github.com/robolectric/robolectric/issues/6853.
+    this.idleConnectionTimeoutMs = idleConnectionTimeoutMs;
+  }
+
+  @Implementation(minSdk = P)
+  protected void setOpenParams(OpenParams openParams) {
+    this.idleConnectionTimeoutMs = openParams.getIdleConnectionTimeout();
+    if (openParams.getIdleConnectionTimeout() != IDLE_CONNECTION_TIMEOUT_DISABLED) {
+      // Remove the idle connection timeout (see setIdleConnectionTimeout()).
+      // The copy constructor doesn't copy the idle connection timeout.
+      openParams = new OpenParams.Builder(openParams).build();
+    }
+    reflector(SQLiteOpenHelperReflector.class, realSQLiteOpenHelper).setOpenParams(openParams);
+  }
+
+  /** Accessor interface for {@link SQLiteOpenHelper}'s internals. */
+  @ForType(SQLiteOpenHelper.class)
+  private interface SQLiteOpenHelperReflector {
+    @Direct
+    void setOpenParams(OpenParams openParams);
+
+    @Accessor("mOpenParamsBuilder")
+    OpenParams.Builder getOpenParamsBuilder();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java
index 4fb33ba34..e98c10040 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java
@@ -1,7 +1,5 @@
 package org.robolectric.shadows;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.os.Build.VERSION_CODES;
 import android.safetycenter.SafetyCenterManager;
 import android.safetycenter.SafetyEvent;
@@ -12,6 +10,8 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -49,9 +49,9 @@ public class ShadowSafetyCenterManager {
 
   @Implementation
   protected void setSafetySourceData(
-      @NonNull String safetySourceId,
+      @Nonnull String safetySourceId,
       @Nullable SafetySourceData safetySourceData,
-      @NonNull SafetyEvent safetyEvent) {
+      @Nonnull SafetyEvent safetyEvent) {
     synchronized (lock) {
       if (!isSafetyCenterEnabled()) {
         return;
@@ -63,7 +63,7 @@ public class ShadowSafetyCenterManager {
   }
 
   @Implementation
-  protected SafetySourceData getSafetySourceData(@NonNull String safetySourceId) {
+  protected SafetySourceData getSafetySourceData(@Nonnull String safetySourceId) {
     synchronized (lock) {
       if (!isSafetyCenterEnabled()) {
         return null;
@@ -75,7 +75,7 @@ public class ShadowSafetyCenterManager {
 
   @Implementation
   protected void reportSafetySourceError(
-      @NonNull String safetySourceId, @NonNull SafetySourceErrorDetails safetySourceErrorDetails) {
+      @Nonnull String safetySourceId, @Nonnull SafetySourceErrorDetails safetySourceErrorDetails) {
     synchronized (lock) {
       if (!isSafetyCenterEnabled()) {
         return;
@@ -105,7 +105,7 @@ public class ShadowSafetyCenterManager {
   /**
    * Makes the APIs throw an {@link IllegalArgumentException} for the given {@code safetySourceId}.
    */
-  public void throwOnSafetySourceId(@NonNull String safetySourceId) {
+  public void throwOnSafetySourceId(@Nonnull String safetySourceId) {
     synchronized (lock) {
       throwForId.add(safetySourceId);
     }
@@ -115,7 +115,7 @@ public class ShadowSafetyCenterManager {
    * Returns the {@link SafetyEvent} that was given to {@link SafetyCenterManager} the last time
    * {@link #setSafetySourceData} was called with this {@code safetySourceId}.
    */
-  public SafetyEvent getLastSafetyEvent(@NonNull String safetySourceId) {
+  public SafetyEvent getLastSafetyEvent(@Nonnull String safetySourceId) {
     synchronized (lock) {
       return eventsById.get(safetySourceId);
     }
@@ -125,7 +125,7 @@ public class ShadowSafetyCenterManager {
    * Returns the {@link SafetySourceErrorDetails} that was given to {@link SafetyCenterManager} the
    * last time {@link #reportSafetySourceError} was called with this {@code safetySourceId}.
    */
-  public SafetySourceErrorDetails getLastSafetySourceError(@NonNull String safetySourceId) {
+  public SafetySourceErrorDetails getLastSafetySourceError(@Nonnull String safetySourceId) {
     synchronized (lock) {
       return errorsById.get(safetySourceId);
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java
index 7a795bd6d..6b0fea1c6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java
@@ -226,7 +226,6 @@ public class ShadowSecureElementService {
     @Override
     public void close() {
       isClosed = true;
-      throw new RuntimeException();
     }
 
     @Override
@@ -246,6 +245,9 @@ public class ShadowSecureElementService {
 
     @Override
     public byte[] transmit(byte[] command) {
+      if (isClosed) {
+        throw new IllegalStateException("Channel is closed");
+      }
       return mockApplet.processRequestApdu(command);
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
index e2f925e1f..5474f0a70 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
@@ -334,6 +334,10 @@ public class ShadowSettings {
       return dataMap.getOrDefault(name, Optional.empty()).filter(type::isInstance).map(type::cast);
     }
 
+    public static void remove(String name) {
+      dataMap.remove(name);
+    }
+
     @Resetter
     public static void reset() {
       dataMap.clear();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java
index f44e09852..2daf9a4b7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
 
-import android.annotation.NonNull;
 import android.app.slice.SliceManager;
 import android.app.slice.SliceSpec;
 import android.content.Context;
@@ -17,6 +16,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -76,17 +76,17 @@ public class ShadowSliceManager {
   }
 
   @Implementation
-  protected void pinSlice(@NonNull Uri uri, @NonNull Set<SliceSpec> specs) {
+  protected void pinSlice(@Nonnull Uri uri, @Nonnull Set<SliceSpec> specs) {
     pinnedUriMap.put(uri, specs);
   }
 
   @Implementation
-  protected void unpinSlice(@NonNull Uri uri) {
+  protected void unpinSlice(@Nonnull Uri uri) {
     pinnedUriMap.remove(uri);
   }
 
   @Implementation
-  @NonNull
+  @Nonnull
   protected Set<SliceSpec> getPinnedSpecs(Uri uri) {
     if (pinnedUriMap.containsKey(uri)) {
       return pinnedUriMap.get(uri);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java
index 1a72f6885..7f9d17df9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java
@@ -4,7 +4,6 @@ import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 
-import android.annotation.Nullable;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.net.Uri;
@@ -14,6 +13,7 @@ import android.text.TextUtils;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
index 534727b32..006e2ada5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
@@ -2,8 +2,6 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.RequiresApi;
 import android.content.ComponentName;
 import android.content.Context;
@@ -22,6 +20,8 @@ import android.speech.SpeechRecognizer;
 import com.google.common.base.Preconditions;
 import java.util.Queue;
 import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -188,9 +188,9 @@ public class ShadowSpeechRecognizer {
   @RequiresApi(api = VERSION_CODES.TIRAMISU)
   @Implementation(minSdk = VERSION_CODES.TIRAMISU, maxSdk = U.SDK_INT)
   protected void checkRecognitionSupport(
-      @NonNull Intent recognizerIntent,
-      @NonNull Executor executor,
-      @NonNull @ClassName("android.speech.RecognitionSupportCallback") Object supportListener) {
+      @Nonnull Intent recognizerIntent,
+      @Nonnull Executor executor,
+      @Nonnull @ClassName("android.speech.RecognitionSupportCallback") Object supportListener) {
     Preconditions.checkArgument(supportListener instanceof RecognitionSupportCallback);
 
     ShadowSpeechRecognizerState shadowState = getState();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java
index 51cf7ccca..9e0f29454 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
 import android.annotation.RequiresApi;
 import android.content.Context;
 import android.content.Intent;
@@ -14,6 +13,7 @@ import android.speech.RecognitionListener;
 import android.speech.SpeechRecognizer;
 import java.util.Queue;
 import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -85,9 +85,9 @@ public class ShadowSpeechRecognizerImpl extends ShadowSpeechRecognizer {
   @Implementation(minSdk = VERSION_CODES.TIRAMISU)
   @Override
   protected void checkRecognitionSupport(
-      @NonNull Intent recognizerIntent,
-      @NonNull Executor executor,
-      @NonNull @ClassName("android.speech.RecognitionSupportCallback") Object supportListener) {
+      @Nonnull Intent recognizerIntent,
+      @Nonnull Executor executor,
+      @Nonnull @ClassName("android.speech.RecognitionSupportCallback") Object supportListener) {
     super.checkRecognitionSupport(recognizerIntent, executor, supportListener);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
index da27f752c..678b6e6c0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
@@ -2,7 +2,9 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
 
+import android.app.PendingIntent;
 import android.app.StatsManager;
+import com.google.auto.value.AutoValue;
 import java.util.HashMap;
 import java.util.Map;
 import org.robolectric.annotation.Implementation;
@@ -19,12 +21,15 @@ public class ShadowStatsManager {
   private static byte[] statsMetadata = new byte[] {};
 
   private static final Map<Long, byte[]> configDataMap = new HashMap<>();
+  private static final Map<BroadcastSubscriberKey, PendingIntent> broadcastSubscriberMap =
+      new HashMap<>();
 
   @Resetter
   public static void reset() {
     reportDataMap.clear();
     statsMetadata = new byte[] {};
     configDataMap.clear();
+    broadcastSubscriberMap.clear();
   }
 
   /** Adds metrics data that the shadow should return from {@link StatsManager#getReports()}. */
@@ -48,6 +53,17 @@ public class ShadowStatsManager {
     return configDataMap.getOrDefault(configKey, new byte[] {});
   }
 
+  /**
+   * Retrieves the broadcast subscriber map stored in the shadow as a result of {@link
+   * StatsManager#setBroadcastSubscriber()}.
+   *
+   * @return A map where the keys are {@link BroadcastSubscriberKey} objects, which contain the
+   *     configKey and subscriberId, and the values are {@link PendingIntent} objects.
+   */
+  public static Map<BroadcastSubscriberKey, PendingIntent> getBroadcastSubscriberMap() {
+    return broadcastSubscriberMap;
+  }
+
   @Implementation
   protected byte[] getReports(long configKey) {
     byte[] data = reportDataMap.getOrDefault(configKey, new byte[] {});
@@ -69,4 +85,27 @@ public class ShadowStatsManager {
   protected void removeConfig(long configKey) {
     configDataMap.remove(configKey);
   }
+
+  @Implementation
+  protected void setBroadcastSubscriber(
+      PendingIntent pendingIntent, long configKey, long subscriberId) {
+    BroadcastSubscriberKey key = BroadcastSubscriberKey.create(configKey, subscriberId);
+    if (pendingIntent != null) {
+      broadcastSubscriberMap.put(key, pendingIntent);
+    } else {
+      broadcastSubscriberMap.remove(key);
+    }
+  }
+
+  /** A key used to store the configKey and subscriberId in the broadcastSubscriberMap. */
+  @AutoValue
+  public abstract static class BroadcastSubscriberKey {
+    public static BroadcastSubscriberKey create(long key, long id) {
+      return new AutoValue_ShadowStatsManager_BroadcastSubscriberKey(key, id);
+    }
+
+    public abstract long getKey();
+
+    public abstract long getId();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
index d9adb94cd..f655e9f6c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
@@ -3,12 +3,14 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static android.telephony.SubscriptionManager.INVALID_SIM_SLOT_INDEX;
 
 import android.os.Build.VERSION;
 import android.telephony.SubscriptionInfo;
@@ -508,6 +510,18 @@ public class ShadowSubscriptionManager {
     return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
   }
 
+  @Implementation(minSdk = O)
+  protected static int getSlotIndex(int subscriptionId) {
+    if (subscriptionList != null) {
+      for (SubscriptionInfo info : subscriptionList) {
+        if (info.getSubscriptionId() == subscriptionId) {
+          return info.getSimSlotIndex();
+        }
+      }
+    }
+    return INVALID_SIM_SLOT_INDEX;
+  }
+
   /**
    * When set to false methods requiring {@link android.Manifest.permission.READ_PHONE_STATE}
    * permission will throw a {@link SecurityException}. By default it's set to true for backwards
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystem.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystem.java
index b9013704a..76ba2a366 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystem.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystem.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import android.os.SystemClock;
-import java.util.concurrent.TimeUnit;
 import org.robolectric.annotation.LooperMode;
 
 public class ShadowSystem {
@@ -16,7 +15,7 @@ public class ShadowSystem {
     if (ShadowLooper.looperMode() == LooperMode.Mode.LEGACY) {
       return ShadowLegacySystemClock.nanoTime();
     } else {
-      return TimeUnit.MILLISECONDS.toNanos(SystemClock.uptimeMillis());
+      return ShadowPausedSystemClock.uptimeNanos();
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
index eff905283..95059cf26 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.Q;
 import static java.time.ZoneOffset.UTC;
 import static org.robolectric.shadows.ShadowLooper.assertLooperMode;
+import static org.robolectric.shadows.ShadowLooper.looperMode;
 
 import android.os.SimpleClock;
 import android.os.SystemClock;
@@ -71,7 +72,7 @@ public abstract class ShadowSystemClock {
    * available.
    */
   public static void advanceBy(long time, TimeUnit unit) {
-    SystemClock.setCurrentTimeMillis(SystemClock.uptimeMillis() + unit.toMillis(time));
+    advanceBy(Duration.of(time, unit.toChronoUnit()));
   }
 
   /**
@@ -80,7 +81,11 @@ public abstract class ShadowSystemClock {
    * @param duration The interval by which to advance.
    */
   public static void advanceBy(Duration duration) {
-    SystemClock.setCurrentTimeMillis(SystemClock.uptimeMillis() + duration.toMillis());
+    if (looperMode() == Mode.LEGACY) {
+      SystemClock.setCurrentTimeMillis(SystemClock.uptimeMillis() + duration.toMillis());
+    } else {
+      ShadowPausedSystemClock.internalAdvanceBy(duration);
+    }
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java
index 47577f545..d2c713e5b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java
@@ -6,10 +6,12 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Properties;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @Implements(value = SystemProperties.class, isInAndroidSdk = false)
 public class ShadowSystemProperties {
@@ -125,6 +127,11 @@ public class ShadowSystemProperties {
     buildProperties.setProperty("debug.sqlite.syncmode", "OFF");
     buildProperties.setProperty("debug.sqlite.wal.syncmode", "OFF");
     buildProperties.setProperty("debug.sqlite.journalmode", "MEMORY");
+
+    // TODO: definitely put this into generated build.prop
+    if (RuntimeEnvironment.getApiLevel() > V.SDK_INT) {
+      buildProperties.setProperty("ro.vendor.api_level", "202404");
+    }
   }
 
   @Resetter
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
index bfe1fbb44..4b2b1b0b5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
@@ -10,7 +10,6 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.base.Verify.verifyNotNull;
 
-import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
@@ -39,6 +38,7 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nullable;
 import org.robolectric.android.controller.ServiceController;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java
index aba5d2ad2..7e3c18f99 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java
@@ -1,9 +1,9 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.content.Context;
 import android.provider.Telephony;
 import android.provider.Telephony.Sms;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
index 3b298f71c..ec7d5e5bc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
@@ -10,6 +10,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static android.telephony.PhoneStateListener.LISTEN_CALL_STATE;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_INFO;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_LOCATION;
@@ -116,7 +117,7 @@ public class ShadowTelephonyManager {
   private String meid;
   private String groupIdLevel1;
   private String networkOperatorName = "";
-  private String networkCountryIso;
+  private String networkCountryIso = "";
   private String networkOperator = "";
   private String networkSpecifier = "";
   private Locale simLocale;
@@ -628,6 +629,11 @@ public class ShadowTelephonyManager {
     return simStates.getOrDefault(slotIndex, TelephonyManager.SIM_STATE_UNKNOWN);
   }
 
+  @Implementation(minSdk = UPSIDE_DOWN_CAKE)
+  protected static int getSimStateForSlotIndex(int slotIndex) {
+    return simStates.getOrDefault(slotIndex, TelephonyManager.SIM_STATE_UNKNOWN);
+  }
+
   /** Sets the UICC slots information returned by {@link #getUiccSlotsInfo()}. */
   public void setUiccSlotsInfo(/*UiccSlotInfo[]*/ Object uiccSlotsInfos) {
     ShadowTelephonyManager.uiccSlotInfos = uiccSlotsInfos;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
index 54cd10b0a..f7f9c6d00 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
@@ -19,6 +19,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
+import java.util.MissingResourceException;
 import java.util.Set;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -162,14 +163,18 @@ public class ShadowTextToSpeech {
   @Implementation
   protected int isLanguageAvailable(Locale lang) {
     for (Locale locale : languageAvailabilities) {
-      if (locale.getISO3Language().equals(lang.getISO3Language())) {
-        if (locale.getISO3Country().equals(lang.getISO3Country())) {
-          if (locale.getVariant().equals(lang.getVariant())) {
-            return TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE;
+      try {
+        if (locale.getISO3Language().equals(lang.getISO3Language())) {
+          if (locale.getISO3Country().equals(lang.getISO3Country())) {
+            if (locale.getVariant().equals(lang.getVariant())) {
+              return TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE;
+            }
+            return TextToSpeech.LANG_COUNTRY_AVAILABLE;
           }
-          return TextToSpeech.LANG_COUNTRY_AVAILABLE;
+          return TextToSpeech.LANG_AVAILABLE;
         }
-        return TextToSpeech.LANG_AVAILABLE;
+      } catch (MissingResourceException e) {
+        // Couldn't retrieve ISO 639-2/T language code or ISO 3166 country code for the locale"
       }
     }
     return TextToSpeech.LANG_NOT_SUPPORTED;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextUtils.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextUtils.java
index f2c06efd2..e591c50d1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextUtils.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextUtils.java
@@ -1,12 +1,24 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
 import android.text.TextPaint;
 import android.text.TextUtils;
 import android.text.TextUtils.TruncateAt;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
 
-/** Implement {@link TextUtils#ellipsize} by truncating the text. */
+/**
+ * Implement {@link TextUtils#ellipsize} by truncating the text.
+ *
+ * <p>Ideally this would use {@link GraphicsShadowPicker} to get disabled when native graphics are
+ * enabled, but TextUtils is used by {@link android.os.Build}, which is often referenced in static
+ * initializers, and shadow pickers referencing {@link org.robolectric.config.ConfigurationRegistry}
+ * are not supported in static initializers.
+ */
 @SuppressWarnings({"UnusedDeclaration"})
 @Implements(TextUtils.class)
 public class ShadowTextUtils {
@@ -14,6 +26,9 @@ public class ShadowTextUtils {
   @Implementation
   protected static CharSequence ellipsize(
       CharSequence text, TextPaint p, float avail, TruncateAt where) {
+    if (ShadowView.useRealGraphics()) {
+      return reflector(TextUtilsReflector.class).ellipsize(text, p, avail, where);
+    }
     // This shadow follows the convention of ShadowPaint#measureText where each
     // characters width is 1.0.
     if (avail <= 0) {
@@ -24,4 +39,11 @@ public class ShadowTextUtils {
       return text.subSequence(0, (int) avail);
     }
   }
+
+  @ForType(TextUtils.class)
+  interface TextUtilsReflector {
+    @Direct
+    @Static
+    CharSequence ellipsize(CharSequence text, TextPaint p, float avail, TruncateAt where);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
index 9ccf875e2..744b94ca5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
@@ -32,8 +32,8 @@ public class ShadowTimeManager {
   private static TimeZoneConfiguration timeZoneConfiguration;
 
   /**
-   * Capabilites are predefined and not controlled by user, so they can't be changed via TimeManager
-   * API.
+   * Capabilities are predefined and not controlled by user, so they can't be changed via
+   * TimeManager API.
    */
   public void setCapabilityState(String capability, @CapabilityState int value) {
     TimeZoneCapabilities.Builder builder = new TimeZoneCapabilities.Builder(timeZoneCapabilities);
@@ -122,6 +122,16 @@ public class ShadowTimeManager {
             .setConfigureAutoDetectionEnabledCapability(Capabilities.CAPABILITY_POSSESSED)
             .setConfigureGeoDetectionEnabledCapability(Capabilities.CAPABILITY_POSSESSED);
 
+    if (ReflectionHelpers.hasMethod(
+        TimeZoneCapabilities.Builder.class,
+        "setConfigureNotificationsEnabledCapability",
+        int.class)) {
+      ReflectionHelpers.callInstanceMethod(
+          timeZoneCapabilitiesBuilder,
+          "setConfigureNotificationsEnabledCapability",
+          ClassParameter.from(int.class, Capabilities.CAPABILITY_POSSESSED));
+    }
+
     if (RuntimeEnvironment.getApiLevel() >= U.SDK_INT) {
       ReflectionHelpers.callInstanceMethod(
           timeZoneCapabilitiesBuilder,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java
index 878057c08..b669614cc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java
@@ -17,11 +17,11 @@ import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.media.Rating;
 import android.media.session.MediaController.TransportControls;
 import android.net.Uri;
 import android.os.Bundle;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUIModeManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUIModeManager.java
index af3cfe8fe..75f286bdb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUIModeManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUIModeManager.java
@@ -1,9 +1,11 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static com.google.common.base.Preconditions.checkArgument;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.SystemApi;
+import android.app.IUiModeManager;
 import android.app.UiModeManager;
 import android.content.ContentResolver;
 import android.content.Context;
@@ -11,6 +13,7 @@ import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
+import android.os.IBinder;
 import android.provider.Settings;
 import com.android.internal.annotations.GuardedBy;
 import com.google.common.collect.ImmutableSet;
@@ -23,12 +26,19 @@ import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
+import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link UiModeManager}. */
 @Implements(UiModeManager.class)
 public class ShadowUIModeManager {
+  private static final int DEFAULT_PRIORITY = 0;
+
   public int currentModeType = Configuration.UI_MODE_TYPE_UNDEFINED;
   public int currentNightMode = UiModeManager.MODE_NIGHT_AUTO;
   public int lastFlags;
@@ -36,13 +46,6 @@ public class ShadowUIModeManager {
   private int currentApplicationNightMode = 0;
   private final Map<Integer, Set<String>> activeProjectionTypes = new HashMap<>();
   private boolean failOnProjectionToggle;
-
-  private static final ImmutableSet<Integer> VALID_NIGHT_MODES =
-      ImmutableSet.of(
-          UiModeManager.MODE_NIGHT_AUTO, UiModeManager.MODE_NIGHT_NO, UiModeManager.MODE_NIGHT_YES);
-
-  private static final int DEFAULT_PRIORITY = 0;
-
   private final Object lock = new Object();
 
   @GuardedBy("lock")
@@ -246,10 +249,67 @@ public class ShadowUIModeManager {
     }
   }
 
+  /**
+   * Sets the contrast value.
+   *
+   * <p>The default value for contrast is 0.0f. The permitted values are between -1.0f and 1.0f
+   * inclusive.
+   */
+  public void setContrast(float contrast) {
+    checkArgument(
+        contrast >= -1.0f && contrast <= 1.0f,
+        "Contrast value must be between -1.0f and 1.0f inclusive. Provided value: %s",
+        contrast);
+
+    if (RuntimeEnvironment.getApiLevel() == VERSION_CODES.UPSIDE_DOWN_CAKE) {
+      reflector(UiModeManagerReflector.class, realUiModeManager).setContrast(contrast);
+    } else {
+      Object globals = reflector(UiModeManagerReflector.class, realUiModeManager).getGlobals();
+      reflector(UiModeManagerGlobalsReflector.class, globals).setContrast(contrast);
+    }
+  }
+
+  @Resetter
+  public static void reset() {
+    if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT) {
+      IUiModeManager service =
+          IUiModeManager.Stub.asInterface(
+              reflector(ServiceManagerReflector.class).getServiceOrThrow(Context.UI_MODE_SERVICE));
+      reflector(UiModeManagerReflector.class)
+          .setGlobals(reflector(UiModeManagerGlobalsReflector.class).newGlobals(service));
+    }
+  }
+
+  @ForType(className = "android.os.ServiceManager")
+  interface ServiceManagerReflector {
+    @Static
+    IBinder getServiceOrThrow(String name);
+  }
+
   @ForType(UiModeManager.class)
   interface UiModeManagerReflector {
     @Accessor("mContext")
     Context getContext();
+
+    @Accessor("mContrast")
+    void setContrast(float value); // Stores the contrast value for Android U.
+
+    @Accessor("sGlobals")
+    @Static
+    Object getGlobals(); // Stores the contrast value for Android V and above.
+
+    @Accessor("sGlobals")
+    @Static
+    void setGlobals(@WithType("android.app.UiModeManager$Globals") Object value);
+  }
+
+  @ForType(className = "android.app.UiModeManager$Globals")
+  interface UiModeManagerGlobalsReflector {
+    @Accessor("mContrast")
+    void setContrast(float contrast);
+
+    @Constructor
+    Object newGlobals(IUiModeManager iUiModeManager);
   }
 
   private void assertHasPermission(String... permissions) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
index fe27ea78b..b8f01364f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
@@ -2,16 +2,14 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.TargetApi;
 import android.app.PendingIntent;
 import android.app.PendingIntent.CanceledException;
 import android.app.usage.BroadcastResponseStats;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageEvents.Event;
+import android.app.usage.UsageEventsQuery;
 import android.app.usage.UsageStats;
 import android.app.usage.UsageStatsManager;
 import android.app.usage.UsageStatsManager.StandbyBuckets;
@@ -42,15 +40,14 @@ import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.util.reflector.Accessor;
-import org.robolectric.util.reflector.ForType;
-import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow of {@link UsageStatsManager}. */
 @Implements(value = UsageStatsManager.class)
@@ -87,25 +84,25 @@ public class ShadowUsageStatsManager {
 
     public static AppUsageObserver build(
         int observerId,
-        @NonNull Collection<String> packageNames,
+        @Nonnull Collection<String> packageNames,
         long timeLimit,
-        @NonNull TimeUnit timeUnit,
-        @NonNull PendingIntent callbackIntent) {
+        @Nonnull TimeUnit timeUnit,
+        @Nonnull PendingIntent callbackIntent) {
       return new AutoValue_ShadowUsageStatsManager_AppUsageObserver(
           observerId, ImmutableList.copyOf(packageNames), timeLimit, timeUnit, callbackIntent);
     }
 
     public abstract int getObserverId();
 
-    @NonNull
+    @Nonnull
     public abstract ImmutableList<String> getPackageNames();
 
     public abstract long getTimeLimit();
 
-    @NonNull
+    @Nonnull
     public abstract TimeUnit getTimeUnit();
 
-    @NonNull
+    @Nonnull
     public abstract PendingIntent getCallbackIntent();
   }
 
@@ -121,11 +118,11 @@ public class ShadowUsageStatsManager {
   public abstract static class UsageSessionObserver {
     public static UsageSessionObserver build(
         int observerId,
-        @NonNull List<String> packageNames,
+        @Nonnull List<String> packageNames,
         Duration sessionStepDuration,
         Duration thresholdDuration,
-        @NonNull PendingIntent sessionStepTriggeredIntent,
-        @NonNull PendingIntent sessionEndedIntent) {
+        @Nonnull PendingIntent sessionStepTriggeredIntent,
+        @Nonnull PendingIntent sessionEndedIntent) {
       return new AutoValue_ShadowUsageStatsManager_UsageSessionObserver(
           observerId,
           ImmutableList.copyOf(packageNames),
@@ -137,7 +134,7 @@ public class ShadowUsageStatsManager {
 
     public abstract int getObserverId();
 
-    @NonNull
+    @Nonnull
     public abstract ImmutableList<String> getPackageNames();
 
     @Nullable
@@ -146,10 +143,10 @@ public class ShadowUsageStatsManager {
     @Nullable
     public abstract Duration getThresholdDuration();
 
-    @NonNull
+    @Nonnull
     public abstract PendingIntent getSessionStepTriggeredIntent();
 
-    @NonNull
+    @Nonnull
     public abstract PendingIntent getSessionEndedIntent();
   }
 
@@ -170,10 +167,10 @@ public class ShadowUsageStatsManager {
 
     public AppUsageLimitObserver(
         int observerId,
-        @NonNull List<String> packageNames,
-        @NonNull Duration timeLimit,
-        @NonNull Duration timeUsed,
-        @NonNull PendingIntent callbackIntent) {
+        @Nonnull List<String> packageNames,
+        @Nonnull Duration timeLimit,
+        @Nonnull Duration timeUsed,
+        @Nonnull PendingIntent callbackIntent) {
       this.observerId = observerId;
       this.packageNames = ImmutableList.copyOf(packageNames);
       this.timeLimit = checkNotNull(timeLimit);
@@ -185,22 +182,22 @@ public class ShadowUsageStatsManager {
       return observerId;
     }
 
-    @NonNull
+    @Nonnull
     public ImmutableList<String> getPackageNames() {
       return packageNames;
     }
 
-    @NonNull
+    @Nonnull
     public Duration getTimeLimit() {
       return timeLimit;
     }
 
-    @NonNull
+    @Nonnull
     public Duration getTimeUsed() {
       return timeUsed;
     }
 
-    @NonNull
+    @Nonnull
     public PendingIntent getCallbackIntent() {
       return callbackIntent;
     }
@@ -243,12 +240,13 @@ public class ShadowUsageStatsManager {
     return createUsageEvents(results);
   }
 
-  @Implementation(minSdk = V.SDK_INT)
-  protected UsageEvents queryEvents(@ClassName("android.app.usage.UsageEventsQuery") Object query) {
-    UsageEventsQueryReflector queryReflector = reflector(UsageEventsQueryReflector.class, query);
-    long beginTime = queryReflector.getBeginTimeMillis();
-    long endTime = queryReflector.getEndTimeMillis();
-    int[] eventTypes = queryReflector.getEventTypes();
+  @Implementation(minSdk = Build.VERSION_CODES.VANILLA_ICE_CREAM)
+  protected UsageEvents queryEvents(
+      @ClassName("android.app.usage.UsageEventsQuery") Object queryObject) {
+    UsageEventsQuery query = (UsageEventsQuery) queryObject;
+    long beginTime = query.getBeginTimeMillis();
+    long endTime = query.getEndTimeMillis();
+    int[] eventTypes = query.getEventTypes();
     ImmutableSet<Integer> eventTypesSet = ImmutableSet.copyOf(Ints.asList(eventTypes));
     List<Event> results = new ArrayList<>();
     for (Event event : Iterables.concat(eventsByTimeStamp.subMap(beginTime, endTime).values())) {
@@ -806,29 +804,10 @@ public class ShadowUsageStatsManager {
       return this;
     }
 
-    @TargetApi(V.SDK_INT)
+    @TargetApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
     public EventBuilder setExtras(PersistableBundle extras) {
-      EventReflector eventReflector = reflector(EventReflector.class, event);
-      eventReflector.setExtras(extras);
+      event.mExtras = extras;
       return this;
     }
   }
-
-  // TODO: remove reflection calls once Android V is fully supported.
-  @ForType(className = "android.app.usage.UsageEventsQuery")
-  interface UsageEventsQueryReflector {
-    int[] getEventTypes();
-
-    long getBeginTimeMillis();
-
-    long getEndTimeMillis();
-  }
-
-  @ForType(Event.class)
-  interface EventReflector {
-    @Accessor("mExtras")
-    void setExtras(PersistableBundle extras);
-
-    PersistableBundle getExtras();
-  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
index 6d224217d..a852bf03e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
@@ -9,7 +9,6 @@ import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
 import static org.robolectric.util.ReflectionHelpers.getStaticField;
 
-import android.annotation.Nullable;
 import android.annotation.TargetApi;
 import android.content.Intent;
 import android.hardware.usb.UsbAccessory;
@@ -25,6 +24,7 @@ import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
index 551e31ddb..22fcf33dc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
@@ -65,7 +65,9 @@ public class ShadowVMRuntime {
   @Implementation
   public Object newNonMovableArray(Class<?> type, int size) {
     Preconditions.checkArgument(
-        type == int.class || type == float.class, "unsupported type %s", type.getName());
+        type == int.class || type == float.class || type == byte.class,
+        "unsupported type %s",
+        type.getName());
     Object arrayInstance = Array.newInstance(type, size);
     if (type == float.class && size == 8) {
       // This is being called from android.graphics.PathIterator, so we need to allocate a real
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
index 4afdd4183..cd47491ec 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
@@ -3,8 +3,6 @@ package org.robolectric.shadows;
 import static android.companion.virtual.VirtualDeviceManager.LAUNCH_SUCCESS;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.PendingIntent;
 import android.companion.virtual.IVirtualDevice;
 import android.companion.virtual.IVirtualDeviceManager;
@@ -33,6 +31,8 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.IntConsumer;
 import java.util.stream.Collectors;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -211,17 +211,17 @@ public class ShadowVirtualDeviceManager {
     @Implementation
     protected void launchPendingIntent(
         int displayId,
-        @NonNull PendingIntent pendingIntent,
-        @NonNull Executor executor,
-        @NonNull IntConsumer listener) {
+        @Nonnull PendingIntent pendingIntent,
+        @Nonnull Executor executor,
+        @Nonnull IntConsumer listener) {
       this.pendingIntent = pendingIntent;
       executor.execute(() -> listener.accept(pendingIntentResultCode));
     }
 
     @Implementation
     protected VirtualMouse createVirtualMouse(
-        @NonNull VirtualDisplay display,
-        @NonNull String inputDeviceName,
+        @Nonnull VirtualDisplay display,
+        @Nonnull String inputDeviceName,
         int vendorId,
         int productId) {
       return createVirtualMouse(
@@ -229,7 +229,7 @@ public class ShadowVirtualDeviceManager {
     }
 
     @Implementation
-    protected VirtualMouse createVirtualMouse(@NonNull VirtualMouseConfig config) {
+    protected VirtualMouse createVirtualMouse(@Nonnull VirtualMouseConfig config) {
       IBinder token =
           new Binder("android.hardware.input.VirtualMouse:" + config.getInputDeviceName());
       VirtualMouseReflector accessor = reflector(VirtualMouseReflector.class);
@@ -248,8 +248,8 @@ public class ShadowVirtualDeviceManager {
 
     @Implementation
     protected VirtualTouchscreen createVirtualTouchscreen(
-        @NonNull VirtualDisplay display,
-        @NonNull String inputDeviceName,
+        @Nonnull VirtualDisplay display,
+        @Nonnull String inputDeviceName,
         int vendorId,
         int productId) {
       int displayWidth = 720;
@@ -262,7 +262,7 @@ public class ShadowVirtualDeviceManager {
 
     @Implementation
     protected VirtualTouchscreen createVirtualTouchscreen(
-        @NonNull VirtualTouchscreenConfig config) {
+        @Nonnull VirtualTouchscreenConfig config) {
       IBinder token =
           new Binder("android.hardware.input.VirtualTouchscreen:" + config.getInputDeviceName());
       VirtualTouchscreenReflector accessor = reflector(VirtualTouchscreenReflector.class);
@@ -275,7 +275,7 @@ public class ShadowVirtualDeviceManager {
     }
 
     @Implementation
-    protected VirtualKeyboard createVirtualKeyboard(@NonNull VirtualKeyboardConfig config) {
+    protected VirtualKeyboard createVirtualKeyboard(@Nonnull VirtualKeyboardConfig config) {
       IBinder token =
           new Binder("android.hardware.input.VirtualKeyboard:" + config.getInputDeviceName());
       VirtualKeyboardReflector accessor = reflector(VirtualKeyboardReflector.class);
@@ -289,7 +289,7 @@ public class ShadowVirtualDeviceManager {
 
     @Implementation
     protected VirtualDisplay createVirtualDisplay(
-        @NonNull VirtualDisplayConfig config,
+        @Nonnull VirtualDisplayConfig config,
         @Nullable Executor executor,
         @Nullable VirtualDisplay.Callback callback) {
       return DisplayManagerGlobal.getInstance()
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java
index 17478d6dc..05de496c5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java
@@ -1,12 +1,12 @@
 package org.robolectric.shadows;
 
-import android.annotation.Nullable;
 import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable.Creator;
 import android.telecom.PhoneAccountHandle;
 import android.telephony.VisualVoicemailSms;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.Shadow;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
index ab76f02ff..77adb8ff2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
@@ -43,6 +43,8 @@ public class ShadowWallpaperManager {
   private static final String TAG = "ShadowWallpaperManager";
   private static Bitmap lockScreenImage = null;
   private static Bitmap homeScreenImage = null;
+  private static Rect lockScreenVisibleCropHint = null;
+  private static Rect homeScreenVisibleCropHint = null;
   private static boolean isWallpaperAllowed = true;
   private static boolean isWallpaperSupported = true;
   private static WallpaperInfo wallpaperInfo = null;
@@ -50,6 +52,8 @@ public class ShadowWallpaperManager {
   private static AtomicInteger wallpaperId = new AtomicInteger(0);
   private static int lockScreenId;
   private static int homeScreenId;
+  private static int lockScreenResId;
+  private static int homeScreenResId;
 
   private static float wallpaperDimAmount = 0.0f;
   private static final ArrayList<Float> allWallpaperDimAmounts = new ArrayList<>();
@@ -77,12 +81,19 @@ public class ShadowWallpaperManager {
       return 0;
     }
     if ((which & WallpaperManager.FLAG_SYSTEM) == WallpaperManager.FLAG_SYSTEM) {
-      homeScreenId = resid;
+      homeScreenResId = resid;
+      homeScreenId = wallpaperId.incrementAndGet();
     }
     if ((which & WallpaperManager.FLAG_LOCK) == WallpaperManager.FLAG_LOCK) {
-      lockScreenId = resid;
+      lockScreenResId = resid;
+      lockScreenId =
+          ((which & WallpaperManager.FLAG_SYSTEM) == WallpaperManager.FLAG_SYSTEM)
+              ? -1
+              : wallpaperId.incrementAndGet();
     }
-    return wallpaperId.incrementAndGet();
+    return ((which & WallpaperManager.FLAG_SYSTEM) == WallpaperManager.FLAG_SYSTEM)
+        ? homeScreenId
+        : lockScreenId;
   }
 
   /**
@@ -91,7 +102,7 @@ public class ShadowWallpaperManager {
    */
   @Implementation
   protected boolean hasResourceWallpaper(int resid) {
-    return resid == this.lockScreenId || resid == this.homeScreenId;
+    return resid == this.lockScreenResId || resid == this.homeScreenResId;
   }
 
   /**
@@ -100,7 +111,7 @@ public class ShadowWallpaperManager {
    * <p>After a success call, any previously set live wallpaper is removed,
    *
    * @param fullImage the bitmap image to be cached in the memory
-   * @param visibleCropHint not used
+   * @param visibleCropHint the visible crop hint to be cached in the memory
    * @param allowBackup not used
    * @param which either {@link WallpaperManager#FLAG_LOCK} or {WallpaperManager#FLAG_SYSTEM}
    * @return 0 if fails to cache. Otherwise, 1.
@@ -112,11 +123,18 @@ public class ShadowWallpaperManager {
     }
     if ((which & WallpaperManager.FLAG_LOCK) == WallpaperManager.FLAG_LOCK) {
       lockScreenImage = fullImage;
+      lockScreenVisibleCropHint = visibleCropHint;
+      lockScreenId =
+          ((which & WallpaperManager.FLAG_SYSTEM) == WallpaperManager.FLAG_SYSTEM)
+              ? -1
+              : wallpaperId.incrementAndGet();
       wallpaperInfo = null;
     }
 
     if ((which & WallpaperManager.FLAG_SYSTEM) == WallpaperManager.FLAG_SYSTEM) {
       homeScreenImage = fullImage;
+      homeScreenVisibleCropHint = visibleCropHint;
+      homeScreenId = wallpaperId.incrementAndGet();
       wallpaperInfo = null;
     }
     return 1;
@@ -139,6 +157,20 @@ public class ShadowWallpaperManager {
     return null;
   }
 
+  /**
+   * Returns the last visibleCropHint {@link Rect} provided to {@link WallpaperManager#setBitmap}
+   * associated with {@code which}.
+   */
+  @Nullable
+  public Rect getVisibleCropHint(int which) {
+    if (which == WallpaperManager.FLAG_LOCK) {
+      return lockScreenVisibleCropHint;
+    } else if (which == WallpaperManager.FLAG_SYSTEM) {
+      return homeScreenVisibleCropHint;
+    }
+    return null;
+  }
+
   /**
    * Gets a wallpaper file associated with {@code which}.
    *
@@ -157,6 +189,20 @@ public class ShadowWallpaperManager {
     return null;
   }
 
+  /**
+   * Returns the id of the current wallpaper associated with {@code which}. If there is no such
+   * wallpaper configured, returns a negative number.
+   */
+  @Implementation(minSdk = N)
+  protected int getWallpaperId(int which) {
+    if (which == WallpaperManager.FLAG_LOCK) {
+      return lockScreenId;
+    } else if (which == WallpaperManager.FLAG_SYSTEM) {
+      return homeScreenId;
+    }
+    return -1;
+  }
+
   @Implementation(minSdk = N)
   protected boolean isSetWallpaperAllowed() {
     return isWallpaperAllowed;
@@ -192,10 +238,12 @@ public class ShadowWallpaperManager {
     }
     if ((which & WallpaperManager.FLAG_LOCK) == WallpaperManager.FLAG_LOCK) {
       lockScreenImage = BitmapFactory.decodeStream(bitmapData);
+      lockScreenVisibleCropHint = visibleCropHint;
     }
 
     if ((which & WallpaperManager.FLAG_SYSTEM) == WallpaperManager.FLAG_SYSTEM) {
       homeScreenImage = BitmapFactory.decodeStream(bitmapData);
+      homeScreenVisibleCropHint = visibleCropHint;
     }
     return 1;
   }
@@ -327,6 +375,8 @@ public class ShadowWallpaperManager {
   public static void reset() {
     lockScreenImage = null;
     homeScreenImage = null;
+    lockScreenVisibleCropHint = null;
+    homeScreenVisibleCropHint = null;
     isWallpaperAllowed = true;
     isWallpaperSupported = true;
     wallpaperInfo = null;
@@ -334,6 +384,8 @@ public class ShadowWallpaperManager {
     wallpaperId.set(0);
     lockScreenId = 0;
     homeScreenId = 0;
+    lockScreenResId = 0;
+    homeScreenResId = 0;
     wallpaperDimAmount = 0.0f;
     allWallpaperDimAmounts.clear();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
index 279a88cbe..132286619 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
@@ -1,7 +1,10 @@
 package org.robolectric.shadows;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import android.app.wearable.WearableSensingManager;
 import android.app.wearable.WearableSensingManager.StatusCode;
+import android.content.ComponentName;
 import android.os.ParcelFileDescriptor;
 import android.os.PersistableBundle;
 import android.os.SharedMemory;
@@ -10,10 +13,13 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for VirtualDeviceManager. */
 @Implements(
@@ -26,6 +32,10 @@ public class ShadowWearableSensingManager {
   private static @StatusCode Integer provideDataStreamResult =
       WearableSensingManager.STATUS_SUCCESS;
   private static @StatusCode Integer provideDataResult = WearableSensingManager.STATUS_SUCCESS;
+  private static @StatusCode Integer startHotwordRecognitionResult =
+      WearableSensingManager.STATUS_SUCCESS;
+  private static @StatusCode Integer stopHotwordRecognitionResult =
+      WearableSensingManager.STATUS_SUCCESS;
   private static final ArrayList<PersistableBundle> dataBundleList = new ArrayList<>();
   private static final ArrayList<SharedMemory> sharedMemoryList = new ArrayList<>();
   private static ParcelFileDescriptor lastParcelFileDescriptor;
@@ -50,12 +60,50 @@ public class ShadowWearableSensingManager {
     executor.execute(() -> statusConsumer.accept(provideDataResult));
   }
 
+  @Implementation(minSdk = V.SDK_INT)
+  protected void startHotwordRecognition(
+      @Nullable ComponentName targetVisComponentName,
+      @Nonnull Executor executor,
+      @Nonnull @StatusCode Consumer<Integer> statusConsumer) {
+    checkNotNull(executor);
+    checkNotNull(statusConsumer);
+    executor.execute(() -> statusConsumer.accept(startHotwordRecognitionResult));
+  }
+
+  @Implementation(minSdk = V.SDK_INT)
+  protected void stopHotwordRecognition(
+      @Nonnull Executor executor, @Nonnull @StatusCode Consumer<Integer> statusConsumer) {
+    checkNotNull(executor);
+    checkNotNull(statusConsumer);
+    executor.execute(() -> statusConsumer.accept(stopHotwordRecognitionResult));
+  }
+
   public void setProvideDataStreamResult(@StatusCode Integer provideDataStreamResult) {
-    this.provideDataStreamResult = provideDataStreamResult;
+    ShadowWearableSensingManager.provideDataStreamResult = provideDataStreamResult;
   }
 
   public void setProvideDataResult(@StatusCode Integer provideDataResult) {
-    this.provideDataResult = provideDataResult;
+    ShadowWearableSensingManager.provideDataResult = provideDataResult;
+  }
+
+  /**
+   * Sets the status code that will be sent to the {@code @StatusCode Consumer<Integer>} when {@link
+   * #startHotwordRecognition} is called.
+   */
+  public void setStartHotwordRecognitionResult(
+      @Nonnull @StatusCode Integer startHotwordRecognitionResult) {
+    checkNotNull(startHotwordRecognitionResult);
+    ShadowWearableSensingManager.startHotwordRecognitionResult = startHotwordRecognitionResult;
+  }
+
+  /**
+   * Sets the status code that will be sent to the {@code @StatusCode Consumer<Integer>} when {@link
+   * #stopHotwordRecognition} is called.
+   */
+  public void setStopHotwordRecognitionResult(
+      @Nonnull @StatusCode Integer stopHotwordRecognitionResult) {
+    checkNotNull(stopHotwordRecognitionResult);
+    ShadowWearableSensingManager.stopHotwordRecognitionResult = stopHotwordRecognitionResult;
   }
 
   public ParcelFileDescriptor getLastParcelFileDescriptor() {
@@ -82,6 +130,8 @@ public class ShadowWearableSensingManager {
   public static void reset() {
     provideDataStreamResult = WearableSensingManager.STATUS_SUCCESS;
     provideDataResult = WearableSensingManager.STATUS_SUCCESS;
+    startHotwordRecognitionResult = WearableSensingManager.STATUS_SUCCESS;
+    stopHotwordRecognitionResult = WearableSensingManager.STATUS_SUCCESS;
     dataBundleList.clear();
     sharedMemoryList.clear();
     lastParcelFileDescriptor = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebSettings.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebSettings.java
index 427a10190..384ec45a3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebSettings.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebSettings.java
@@ -2,9 +2,11 @@ package org.robolectric.shadows;
 
 import android.content.Context;
 import android.webkit.WebSettings;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.fakes.RoboWebSettings;
 
 /**
  * Shadow of {@link WebSettings} which returns a dummy user a stub instance rather than the
@@ -13,8 +15,6 @@ import org.robolectric.annotation.Resetter;
 @Implements(value = WebSettings.class)
 public class ShadowWebSettings {
 
-  private static String defaultUserAgent = "user";
-
   /**
    * Returns the default User-Agent used by a WebView. An instance of WebView could use a different
    * User-Agent if a call is made to {@link WebSettings#setUserAgentString(String)}.
@@ -23,19 +23,21 @@ public class ShadowWebSettings {
    */
   @Implementation
   protected static String getDefaultUserAgent(Context context) {
-    return defaultUserAgent;
+    return RoboWebSettings.getDefaultUserAgent();
   }
 
   /**
    * Sets the default user agent for the WebView. The value set here is returned from {@link
    * #getDefaultUserAgent(Context)}.
+   *
+   * <p>If the value is null, the default user agent will be provided by Robolectric.
    */
-  public static void setDefaultUserAgent(String defaultUserAgent) {
-    ShadowWebSettings.defaultUserAgent = defaultUserAgent;
+  public static void setDefaultUserAgent(@Nullable String defaultUserAgent) {
+    RoboWebSettings.setDefaultUserAgentOverride(defaultUserAgent);
   }
 
   @Resetter
   public static void reset() {
-    ShadowWebSettings.defaultUserAgent = "user";
+    RoboWebSettings.setDefaultUserAgentOverride(null);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
index 384ece475..f376d3b37 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
@@ -29,7 +29,6 @@ import static org.robolectric.util.ReflectionHelpers.callInstanceMethod;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.FloatRange;
-import android.annotation.Nullable;
 import android.app.Instrumentation;
 import android.content.ClipData;
 import android.content.Context;
@@ -78,6 +77,7 @@ import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map.Entry;
+import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
@@ -949,7 +949,7 @@ public class ShadowWindowManagerGlobal {
                 edge, // swipe edge
                 null);
       } else {
-            throw new IllegalStateException("Could not find a BackMotionEvent constructor to call");
+        throw new IllegalStateException("Could not find a BackMotionEvent constructor to call");
       }
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
index 546d5dfae..24b36f812 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
@@ -1,17 +1,22 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.hardware.camera2.params.HighSpeedVideoConfiguration;
+import android.hardware.camera2.params.ReprocessFormatsMap;
 import android.hardware.camera2.params.StreamConfiguration;
+import android.hardware.camera2.params.StreamConfigurationDuration;
 import android.hardware.camera2.params.StreamConfigurationMap;
 import android.os.Build.VERSION_CODES;
 import android.util.Size;
-import android.util.SparseIntArray;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
 
 /** Builder for StreamConfigurationMap */
 public final class StreamConfigurationMapBuilder {
@@ -72,14 +77,22 @@ public final class StreamConfigurationMapBuilder {
   /** Builds a StreamConfigurationMap based on data previously added to this builder. */
   public StreamConfigurationMap build() {
     Collection<StreamConfiguration> configsList = new ArrayList<>();
-
+    boolean hasPrivateOutput = false;
     for (Map.Entry<Integer, Collection<Size>> entry : outputFormatWithSupportedSize.entrySet()) {
+      hasPrivateOutput =
+          hasPrivateOutput || (entry.getKey() == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED);
       for (Size size : entry.getValue()) {
         configsList.add(
             new StreamConfiguration(
                 entry.getKey(), size.getWidth(), size.getHeight(), /* input= */ false));
       }
     }
+    // The constructor of StreamConfigurationMap asserts that a
+    // HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED config exists.
+    if (!hasPrivateOutput) {
+      configsList.add(
+          new StreamConfiguration(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, 1, 1, false));
+    }
 
     for (Map.Entry<Integer, Collection<Size>> entry : inputFormatWithSupportedSize.entrySet()) {
       for (Size size : entry.getValue()) {
@@ -92,34 +105,175 @@ public final class StreamConfigurationMapBuilder {
     StreamConfiguration[] configs = new StreamConfiguration[configsList.size()];
     configsList.toArray(configs);
 
-    StreamConfigurationMap map = ReflectionHelpers.callConstructor(StreamConfigurationMap.class);
-    ReflectionHelpers.setField(StreamConfigurationMap.class, map, "mConfigurations", configs);
-
     if (RuntimeEnvironment.getApiLevel() < VERSION_CODES.M) {
-      HashMap<Integer, Integer> outputFormats = new HashMap<>();
-      for (int format : outputFormatWithSupportedSize.keySet()) {
-        outputFormats.put(format, outputFormatWithSupportedSize.get(format).size());
-      }
-      ReflectionHelpers.setField(
-          StreamConfigurationMap.class, map, "mOutputFormats", outputFormats);
+      return reflector(StreamConfigurationMapReflector.class)
+          .newStreamConfigurationMapL(
+              configs,
+              new StreamConfigurationDuration[0],
+              new StreamConfigurationDuration[0],
+              /* highSpeedVideoConfigurations= */ null);
+    } else if (RuntimeEnvironment.getApiLevel() < VERSION_CODES.Q) {
+      return reflector(StreamConfigurationMapReflector.class)
+          .newStreamConfigurationMapM(
+              configs,
+              new StreamConfigurationDuration[0],
+              new StreamConfigurationDuration[0],
+              /* depthConfigurations= */ null,
+              /* depthMinFrameDurations= */ null,
+              /* depthStallDurations= */ null,
+              /* highSpeedVideoConfigurations= */ null,
+              /* inputOutputFormatsMap= */ null,
+              /* listHighResolution= */ false);
+    } else if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.TIRAMISU) {
+      return reflector(StreamConfigurationMapReflector.class)
+          .newStreamConfigurationMapQ(
+              configs,
+              new StreamConfigurationDuration[0],
+              new StreamConfigurationDuration[0],
+              /* depthConfigurations= */ null,
+              /* depthMinFrameDurations= */ null,
+              /* depthStallDurations= */ null,
+              /* dynamicDepthConfigurations= */ null,
+              /* dynamicDepthMinFrameDurations= */ null,
+              /* dynamicDepthStallDurations= */ null,
+              /* heicConfigurations= */ null,
+              /* heicMinFrameDurations= */ null,
+              /* heicStallDurations= */ null,
+              /* highSpeedVideoConfigurations= */ null,
+              /* inputOutputFormatsMap= */ null,
+              /* listHighResolution= */ false);
+    } else if (RuntimeEnvironment.getApiLevel() <= VERSION_CODES.VANILLA_ICE_CREAM) {
+      return reflector(StreamConfigurationMapReflector.class)
+          .newStreamConfigurationMapV(
+              configs,
+              new StreamConfigurationDuration[0],
+              new StreamConfigurationDuration[0],
+              /* depthConfigurations= */ null,
+              /* depthMinFrameDurations= */ null,
+              /* depthStallDurations= */ null,
+              /* dynamicDepthConfigurations= */ null,
+              /* dynamicDepthMinFrameDurations= */ null,
+              /* dynamicDepthStallDurations= */ null,
+              /* heicConfigurations= */ null,
+              /* heicMinFrameDurations= */ null,
+              /* heicStallDurations= */ null,
+              /* jpegRConfigurations= */ null,
+              /* jpegRMinFrameDurations= */ null,
+              /* jpegRStallDurations= */ null,
+              /* highSpeedVideoConfigurations= */ null,
+              /* inputOutputFormatsMap= */ null,
+              /* listHighResolution= */ false);
     } else {
-      SparseIntArray outputFormats = new SparseIntArray();
-      for (int format : outputFormatWithSupportedSize.keySet()) {
-        outputFormats.put(format, outputFormatWithSupportedSize.get(format).size());
-      }
-      ReflectionHelpers.setField(
-          StreamConfigurationMap.class, map, "mOutputFormats", outputFormats);
-      ReflectionHelpers.setField(
-          StreamConfigurationMap.class, map, "mAllOutputFormats", outputFormats);
-
-      // Add input formats for reprocessing
-      SparseIntArray inputFormats = new SparseIntArray();
-      for (int format : inputFormatWithSupportedSize.keySet()) {
-        inputFormats.put(format, inputFormatWithSupportedSize.get(format).size());
-      }
-      ReflectionHelpers.setField(StreamConfigurationMap.class, map, "mInputFormats", inputFormats);
+      return reflector(StreamConfigurationMapReflector.class)
+          .newStreamConfigurationMapW(
+              configs,
+              new StreamConfigurationDuration[0],
+              new StreamConfigurationDuration[0],
+              /* depthConfigurations= */ null,
+              /* depthMinFrameDurations= */ null,
+              /* depthStallDurations= */ null,
+              /* dynamicDepthConfigurations= */ null,
+              /* dynamicDepthMinFrameDurations= */ null,
+              /* dynamicDepthStallDurations= */ null,
+              /* heicConfigurations= */ null,
+              /* heicMinFrameDurations= */ null,
+              /* heicStallDurations= */ null,
+              /* jpegRConfigurations= */ null,
+              /* jpegRMinFrameDurations= */ null,
+              /* jpegRStallDurations= */ null,
+              /* heicUltraHDRConfigurations= */ null,
+              /* heicUltraHDRMinFrameDurations= */ null,
+              /* heicUltraHDRStallDurations= */ null,
+              /* highSpeedVideoConfigurations= */ null,
+              /* inputOutputFormatsMap= */ null,
+              /* listHighResolution= */ false);
     }
-    return map;
+  }
+
+  // Constructors for StreamConfigurationMap per SDK version.
+  @ForType(StreamConfigurationMap.class)
+  interface StreamConfigurationMapReflector {
+    @Constructor
+    StreamConfigurationMap newStreamConfigurationMapL(
+        StreamConfiguration[] configurations,
+        StreamConfigurationDuration[] minFrameDurations,
+        StreamConfigurationDuration[] stallDurations,
+        HighSpeedVideoConfiguration[] highSpeedVideoConfigurations);
+
+    @Constructor
+    StreamConfigurationMap newStreamConfigurationMapM(
+        StreamConfiguration[] configurations,
+        StreamConfigurationDuration[] minFrameDurations,
+        StreamConfigurationDuration[] stallDurations,
+        StreamConfiguration[] depthConfigurations,
+        StreamConfigurationDuration[] depthMinFrameDurations,
+        StreamConfigurationDuration[] depthStallDurations,
+        HighSpeedVideoConfiguration[] highSpeedVideoConfigurations,
+        ReprocessFormatsMap inputOutputFormatsMap,
+        boolean listHighResolution);
+
+    @Constructor
+    StreamConfigurationMap newStreamConfigurationMapQ(
+        StreamConfiguration[] configurations,
+        StreamConfigurationDuration[] minFrameDurations,
+        StreamConfigurationDuration[] stallDurations,
+        StreamConfiguration[] depthConfigurations,
+        StreamConfigurationDuration[] depthMinFrameDurations,
+        StreamConfigurationDuration[] depthStallDurations,
+        StreamConfiguration[] dynamicDepthConfigurations,
+        StreamConfigurationDuration[] dynamicDepthMinFrameDurations,
+        StreamConfigurationDuration[] dynamicDepthStallDurations,
+        StreamConfiguration[] heicConfigurations,
+        StreamConfigurationDuration[] heicMinFrameDurations,
+        StreamConfigurationDuration[] heicStallDurations,
+        HighSpeedVideoConfiguration[] highSpeedVideoConfigurations,
+        ReprocessFormatsMap inputOutputFormatsMap,
+        boolean listHighResolution);
+
+    @Constructor
+    StreamConfigurationMap newStreamConfigurationMapV(
+        StreamConfiguration[] configurations,
+        StreamConfigurationDuration[] minFrameDurations,
+        StreamConfigurationDuration[] stallDurations,
+        StreamConfiguration[] depthConfigurations,
+        StreamConfigurationDuration[] depthMinFrameDurations,
+        StreamConfigurationDuration[] depthStallDurations,
+        StreamConfiguration[] dynamicDepthConfigurations,
+        StreamConfigurationDuration[] dynamicDepthMinFrameDurations,
+        StreamConfigurationDuration[] dynamicDepthStallDurations,
+        StreamConfiguration[] heicConfigurations,
+        StreamConfigurationDuration[] heicMinFrameDurations,
+        StreamConfigurationDuration[] heicStallDurations,
+        StreamConfiguration[] jpegRConfigurations,
+        StreamConfigurationDuration[] jpegRMinFrameDurations,
+        StreamConfigurationDuration[] jpegRStallDurations,
+        HighSpeedVideoConfiguration[] highSpeedVideoConfigurations,
+        ReprocessFormatsMap inputOutputFormatsMap,
+        boolean listHighResolution);
+
+    @Constructor
+    StreamConfigurationMap newStreamConfigurationMapW(
+        StreamConfiguration[] configurations,
+        StreamConfigurationDuration[] minFrameDurations,
+        StreamConfigurationDuration[] stallDurations,
+        StreamConfiguration[] depthConfigurations,
+        StreamConfigurationDuration[] depthMinFrameDurations,
+        StreamConfigurationDuration[] depthStallDurations,
+        StreamConfiguration[] dynamicDepthConfigurations,
+        StreamConfigurationDuration[] dynamicDepthMinFrameDurations,
+        StreamConfigurationDuration[] dynamicDepthStallDurations,
+        StreamConfiguration[] heicConfigurations,
+        StreamConfigurationDuration[] heicMinFrameDurations,
+        StreamConfigurationDuration[] heicStallDurations,
+        StreamConfiguration[] jpegRConfigurations,
+        StreamConfigurationDuration[] jpegRMinFrameDurations,
+        StreamConfigurationDuration[] jpegRStallDurations,
+        StreamConfiguration[] heicUltraHDRConfigurations,
+        StreamConfigurationDuration[] heicUltraHDRMinFrameDurations,
+        StreamConfigurationDuration[] heicUltraHDRStallDurations,
+        HighSpeedVideoConfiguration[] highSpeedVideoConfigurations,
+        ReprocessFormatsMap inputOutputFormatsMap,
+        boolean listHighResolution);
   }
 
   private StreamConfigurationMapBuilder() {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java b/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
index be4038e14..bf564aff1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import android.content.pm.PackageManager;
 import android.os.Build.VERSION_CODES;
+import android.os.SystemProperties;
 import com.google.common.collect.ImmutableMap;
 import java.util.HashMap;
 import java.util.Map;
@@ -34,6 +35,17 @@ final class SystemFeatureListInitializer {
       // such as VcnManager.
       features.put(PackageManager.FEATURE_TELEPHONY_SUBSCRIPTION, true);
     }
+    final int vendorApiLevel = SystemProperties.getInt("ro.vendor.api_level", 0);
+    if (vendorApiLevel >= 202404) {
+      // Devices shipped with 2024Q2 or later are required to declare FEATURE_TELEPHONY_*
+      // for individual sub-features (calling, messaging, data)
+      features.put(PackageManager.FEATURE_TELEPHONY_CALLING, true);
+      features.put(PackageManager.FEATURE_TELEPHONY_MESSAGING, true);
+      features.put(PackageManager.FEATURE_TELEPHONY_DATA, true);
+      features.put(PackageManager.FEATURE_TELEPHONY_EUICC, true);
+      features.put(PackageManager.FEATURE_TELEPHONY_EUICC_MEP, true);
+      features.put(PackageManager.FEATURE_TELEPHONY_IMS, true);
+    }
 
     return ImmutableMap.copyOf(features);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java
index 0ae152b0b..e1bace197 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import android.annotation.NonNull;
 import android.annotation.RequiresApi;
 import android.os.Build.VERSION_CODES;
 import android.telephony.UiccCardInfo;
@@ -8,6 +7,7 @@ import android.telephony.UiccPortInfo;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
@@ -76,7 +76,7 @@ public class UiccCardInfoBuilder {
 
   @CanIgnoreReturnValue
   @RequiresApi(VERSION_CODES.TIRAMISU)
-  public UiccCardInfoBuilder setPorts(@NonNull List<UiccPortInfo> portList) {
+  public UiccCardInfoBuilder setPorts(@Nonnull List<UiccPortInfo> portList) {
     this.portList = portList;
     return this;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/WifiScanResultBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/WifiScanResultBuilder.java
new file mode 100644
index 000000000..30c0e6a43
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/WifiScanResultBuilder.java
@@ -0,0 +1,296 @@
+package org.robolectric.shadows;
+
+import android.annotation.RequiresApi;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiSsid;
+import android.os.Build;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.time.Duration;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+
+/**
+ * Builder class for {@link ScanResult} allowing for more accurate construction of Wi-Fi scan
+ * results in test code.
+ */
+public final class WifiScanResultBuilder {
+  private static final int UNSPECIFIED = -1;
+  private static final int NATIVE_BUILDER_MIN_SDK = VERSION_CODES.VANILLA_ICE_CREAM;
+  private static final boolean USE_NATIVE_BUILDER = Build.VERSION.SDK_INT >= NATIVE_BUILDER_MIN_SDK;
+
+  // Available in or before API 21+
+  @Nullable private String ssid;
+  @Nullable private String bssid;
+  @Nullable private String capabilities;
+  private int rssi = UNSPECIFIED;
+  private int frequency = UNSPECIFIED;
+  private Duration timeSinceSeen = Duration.ZERO;
+
+  // Added in API 23
+  private int channelWidth = ScanResult.CHANNEL_WIDTH_20MHZ;
+  private int centerFreq0 = UNSPECIFIED;
+  private int centerFreq1 = UNSPECIFIED;
+  private boolean is80211McRttResponder = false;
+
+  // Added in API 33
+  @Nullable private WifiSsid wifiSsid;
+
+  // Added in API 35. Past this API level all setters are delegated to the real ScanResult.Builder.
+  @Nullable private ScanResult.Builder realBuilder;
+
+  public WifiScanResultBuilder() {}
+
+  /**
+   * Sets the value of the {@link ScanResult#capabilities} field.
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setCapabilities(@Nullable String capabilities) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setCaps(capabilities);
+    } else {
+      this.capabilities = capabilities;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the value of the {@link ScanResult#BSSID} field.
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setBssid(@Nullable String bssid) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setBssid(bssid);
+    } else {
+      this.bssid = bssid;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the value of the {@link ScanResult#level} field (aka RSSI).
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setRssi(int rssi) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setRssi(rssi);
+    } else {
+      this.rssi = rssi;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the value of the frequency, in MHz, returned by the {@link ScanResult#frequency} field.
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setFrequency(int frequency) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setFrequency(frequency);
+    } else {
+      this.frequency = frequency;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the value of the {@link ScanResult#SSID} field. On API 33 and above, this also sets the
+   * return value of {@link ScanResult#getWifiSsid()}.
+   *
+   * @param ssid the name of the network, or null; this should be either a UTF-8 encoded string,
+   *     surrounded by quotes (e.g. '"Network name"'), or an unquoted hex-encoded string (e.g.
+   *     '0a8b2c1f').
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setSsid(@Nullable String ssid) {
+    if (VERSION.SDK_INT >= VERSION_CODES.TIRAMISU) {
+      setWifiSsid(ssid != null ? WifiSsid.fromString(ssid) : null);
+    } else {
+      this.ssid = ssid;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the duration since boot since the result was seen.
+   *
+   * @see ScanResult#timestamp
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setTimeSinceSeen(Duration timeSinceSeen) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setTsf(TimeUnit.MILLISECONDS.toMicros(timeSinceSeen.toMillis()));
+    } else {
+      this.timeSinceSeen = timeSinceSeen;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the value returned by {@link ScanResult#getWifiSsid()}, additionally setting the
+   * deprecated {@link ScanResult#SSID} field.
+   *
+   * @return this builder, for chaining
+   */
+  @RequiresApi(VERSION_CODES.TIRAMISU)
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setWifiSsid(@Nullable WifiSsid wifiSsid) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setWifiSsid(wifiSsid);
+    } else {
+      this.wifiSsid = wifiSsid;
+      this.ssid = wifiSsid == null ? null : wifiSsid.toString();
+    }
+    return this;
+  }
+
+  /**
+   * Sets the value returned by {@link ScanResult#channelWidth}. This should be one of the constants
+   * in {@link ScanResult} such as {@link ScanResult#CHANNEL_WIDTH_20MHZ}.
+   *
+   * @return this builder, for chaining
+   */
+  @RequiresApi(VERSION_CODES.M)
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setChannelWidth(int channelWidth) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setChannelWidth(channelWidth);
+    } else {
+      this.channelWidth = channelWidth;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the center frequency, in MHz, of the first segment (see {@link ScanResult#centerFreq0}).
+   *
+   * @return this builder, for chaining
+   */
+  @RequiresApi(VERSION_CODES.M)
+  @CanIgnoreReturnValue
+  public WifiScanResultBuilder setCenterFreq0(int centerFreq0) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setCenterFreq0(centerFreq0);
+    } else {
+      this.centerFreq0 = centerFreq0;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the center frequency, in MHz, of the second segment (see {@link ScanResult#centerFreq1}).
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  @RequiresApi(VERSION_CODES.M)
+  public WifiScanResultBuilder setCenterFreq1(int centerFreq1) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setCenterFreq1(centerFreq1);
+    } else {
+      this.centerFreq1 = centerFreq1;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the return value of {@link ScanResult#is80211mcResponder()}.
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  @RequiresApi(VERSION_CODES.M)
+  public WifiScanResultBuilder setIs80211McRttResponder(boolean is80211McRttResponder) {
+    if (USE_NATIVE_BUILDER) {
+      ensureRealBuilder().setIs80211McRTTResponder(is80211McRttResponder);
+    } else {
+      this.is80211McRttResponder = is80211McRttResponder;
+    }
+    return this;
+  }
+
+  /**
+   * Sets the return value of {@link ScanResult#is80211azNtbResponder()}.
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  @RequiresApi(VERSION_CODES.VANILLA_ICE_CREAM)
+  public WifiScanResultBuilder setIs80211azNtbRttResponder(boolean is80211azNtbRttResponder) {
+    ensureRealBuilder().setIs80211azNtbRTTResponder(is80211azNtbRttResponder);
+    return this;
+  }
+
+  /**
+   * Sets the return value of {@link ScanResult#isTwtResponder()}.
+   *
+   * @return this builder, for chaining
+   */
+  @CanIgnoreReturnValue
+  @RequiresApi(VERSION_CODES.VANILLA_ICE_CREAM)
+  public WifiScanResultBuilder setIsTwtResponder(boolean isTwtResponder) {
+    ensureRealBuilder().setIsTwtResponder(isTwtResponder);
+    return this;
+  }
+
+  /** Returns a new {@link ScanResult} instance as configured in this builder. */
+  public ScanResult build() {
+    if (USE_NATIVE_BUILDER) {
+      return ensureRealBuilder().build();
+    }
+
+    long timestampMicros = TimeUnit.MILLISECONDS.toMicros(timeSinceSeen.toMillis());
+    ScanResult scanResult;
+    if (VERSION.SDK_INT >= VERSION_CODES.TIRAMISU) {
+      scanResult =
+          new ScanResult(
+              wifiSsid,
+              bssid,
+              /* hessid= */ UNSPECIFIED,
+              /* anqpDomainId= */ UNSPECIFIED,
+              /* osuProviders= */ null,
+              capabilities,
+              rssi,
+              frequency,
+              timestampMicros);
+    } else {
+      scanResult = new ScanResult();
+      scanResult.SSID = ssid;
+      scanResult.BSSID = bssid;
+      scanResult.capabilities = capabilities;
+      scanResult.level = rssi;
+      scanResult.frequency = frequency;
+      scanResult.timestamp = timestampMicros;
+    }
+
+    if (VERSION.SDK_INT >= VERSION_CODES.M) {
+      scanResult.channelWidth = channelWidth;
+      scanResult.centerFreq0 = centerFreq0;
+      scanResult.centerFreq1 = centerFreq1;
+      if (is80211McRttResponder) {
+        scanResult.setFlag(ScanResult.FLAG_80211mc_RESPONDER);
+      }
+    }
+
+    return scanResult;
+  }
+
+  @RequiresApi(NATIVE_BUILDER_MIN_SDK)
+  private ScanResult.Builder ensureRealBuilder() {
+    if (realBuilder == null) {
+      realBuilder = new ScanResult.Builder();
+    }
+    return realBuilder;
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java
index 0df6d0f87..4480b2392 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.net.wifi.WifiUsabilityStatsEntry;
 import android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
 import android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
@@ -134,6 +133,7 @@ public class WifiUsabilityStatsEntryBuilder {
           ClassParameter.from(int.class, 0),
           ClassParameter.from(int.class, 0),
           ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
           ClassParameter.from(int.class, 0)
           /* end new in post V */
           );
diff --git a/shadows/httpclient/Android.bp b/shadows/httpclient/Android.bp
index a02c2f516..eb194fcde 100644
--- a/shadows/httpclient/Android.bp
+++ b/shadows/httpclient/Android.bp
@@ -12,19 +12,19 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_shadows_httpclient_upstream",
+    name: "Robolectric_shadows_httpclient",
     libs: [
-        "Robolectric_shadows_framework_upstream",
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_shadows_framework",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "Robolectric_utils",
         "robolectric-httpclient-4.0.3",
         "robolectric-httpcore-4.0.1",
         "robolectric-javax.annotation-api-1.2",
         "robolectric-host-android_all",
-        "robolectric-host-org_apache_http_legacy_upstream",
+        "robolectric-host-org_apache_http_legacy",
     ],
-    plugins: ["Robolectric_processor_upstream"],
+    plugins: ["Robolectric_processor"],
     javacflags: ["-Aorg.robolectric.annotation.processing.shadowPackage=org.robolectric.shadows.httpclient"],
     srcs: ["src/main/java/**/*.java"],
 
@@ -38,19 +38,19 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_shadows_httpclient_tests_upstream",
+    name: "Robolectric_shadows_httpclient_tests",
     srcs: ["src/test/java/**/*.java"],
     java_resource_dirs: ["src/test/resources"],
     static_libs: [
-        "Robolectric_shadows_httpclient_upstream",
-        "Robolectric_shadows_framework_upstream",
-        "Robolectric_annotations_upstream",
-        "Robolectric_robolectric_upstream",
-        "Robolectric_resources_upstream",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_sandbox_upstream",
-        "Robolectric_junit_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_shadows_httpclient",
+        "Robolectric_shadows_framework",
+        "Robolectric_annotations",
+        "Robolectric_robolectric",
+        "Robolectric_resources",
+        "Robolectric_shadowapi",
+        "Robolectric_sandbox",
+        "Robolectric_junit",
+        "Robolectric_utils",
         "robolectric-maven-ant-tasks-2.1.3",
         "bouncycastle-unbundled",
         "hamcrest",
@@ -67,8 +67,8 @@ java_test_host {
         "grpc-java-netty-shaded",
         //"grpc-netty-shaded-1.16.1-jar",
         "robolectric-host-android_all",
-        "robolectric-host-org_apache_http_legacy_upstream",
-        "robolectric-host-androidx-test-ext-junit_upstream",
+        "robolectric-host-org_apache_http_legacy",
+        "robolectric-host-androidx-test-ext-junit",
     ],
     test_suites: ["general-tests"],
     //tradefed doesn't run these tests.
diff --git a/shadows/multidex/Android.bp b/shadows/multidex/Android.bp
index c8e214aed..9d9f7b980 100644
--- a/shadows/multidex/Android.bp
+++ b/shadows/multidex/Android.bp
@@ -12,15 +12,15 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_shadows_multidex_upstream",
+    name: "Robolectric_shadows_multidex",
     libs: [
-        "Robolectric_annotations_upstream",
-        "Robolectric_shadowapi_upstream",
-        "robolectric-host-android-support-multidex_upstream",
+        "Robolectric_annotations",
+        "Robolectric_shadowapi",
+        "robolectric-host-android-support-multidex",
         "robolectric-javax.annotation-api-1.2",
         "robolectric-host-android_all",
     ],
-    plugins: ["Robolectric_processor_upstream"],
+    plugins: ["Robolectric_processor"],
     javacflags: ["-Aorg.robolectric.annotation.processing.shadowPackage=org.robolectric.shadows.multidex"],
     srcs: ["src/main/java/**/*.java"],
 }
diff --git a/shadows/multidex/build.gradle.kts b/shadows/multidex/build.gradle.kts
deleted file mode 100644
index d3b9137ec..000000000
--- a/shadows/multidex/build.gradle.kts
+++ /dev/null
@@ -1,19 +0,0 @@
-plugins {
-  alias(libs.plugins.robolectric.deployed.java.module)
-  alias(libs.plugins.robolectric.java.module)
-  alias(libs.plugins.robolectric.shadows)
-}
-
-shadows {
-  packageName = "org.robolectric.shadows.multidex"
-  sdkCheckMode = "OFF"
-}
-
-dependencies {
-  compileOnly(project(":shadows:framework"))
-  api(project(":annotations"))
-
-  compileOnly(AndroidSdk.MAX_SDK.coordinates)
-
-  testImplementation(project(":robolectric"))
-}
diff --git a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java
deleted file mode 100644
index 9da7ea5ac..000000000
--- a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.robolectric.shadows.multidex;
-
-import android.content.Context;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-
-@Implements(className = "androidx.multidex.MultiDex")
-@SuppressWarnings("robolectric.internal.IgnoreMissingClass")
-public class ShadowAndroidXMultiDex {
-
-  @Implementation
-  protected static void install(Context context) {
-    // Do nothing since with Robolectric nothing is dexed.
-  }
-}
diff --git a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowMultiDex.java b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowMultiDex.java
deleted file mode 100644
index bf9f7c7a6..000000000
--- a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowMultiDex.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.robolectric.shadows.multidex;
-
-import android.content.Context;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-
-/** No-op shadow for {@link android.support.multidex.MultiDex}. */
-@Implements(className = "android.support.multidex.MultiDex")
-@SuppressWarnings("robolectric.internal.IgnoreMissingClass")
-public class ShadowMultiDex {
-
-  @Implementation
-  protected static void install(Context context) {
-    // Do nothing since with Robolectric nothing is dexed.
-  }
-}
diff --git a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java
deleted file mode 100644
index 78f05eae8..000000000
--- a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java
+++ /dev/null
@@ -1,7 +0,0 @@
-/**
- * Shadows for the Android Multidex Library.
- *
- * <p>To use this in your project, add the artifact {@code org.robolectric:shadows-multidex} to your
- * project.
- */
-package org.robolectric.shadows.multidex;
diff --git a/shadows/playservices/Android.bp b/shadows/playservices/Android.bp
index e63268c40..b282867fe 100644
--- a/shadows/playservices/Android.bp
+++ b/shadows/playservices/Android.bp
@@ -3,11 +3,11 @@
 //#############################################
 
 //java_library_host {
-//    name: "Robolectric_shadows_playservices_upstream",
+//    name: "Robolectric_shadows_playservices",
 //    libs: [
-//        "Robolectric_shadows_framework_upstream",
-//        "Robolectric_annotations_upstream",
-//        "Robolectric_shadowapi_upstream",
+//        "Robolectric_shadows_framework",
+//        "Robolectric_annotations",
+//        "Robolectric_shadowapi",
 //        "robolectric-javax.annotation-api-1.2",
 //        "guava",
 //        "robolectric-host-android_all",
@@ -16,7 +16,7 @@
 //   compileOnly "com.google.android.gms:play-services-base:8.4.0"
 //   compileOnly "com.google.android.gms:play-services-basement:8.4.0"
 //    ],
-//    plugins: ["Robolectric_processor_upstream"],
+//    plugins: ["Robolectric_processor"],
 //    javacflags: ["-Aorg.robolectric.annotation.processing.shadowPackage=org.robolectric.shadows.gms"],
 //    srcs: ["src/main/java/**/*.java"],
 //}
diff --git a/shadows/versioning/Android.bp b/shadows/versioning/Android.bp
index 3d44f1157..6b8e5bac8 100644
--- a/shadows/versioning/Android.bp
+++ b/shadows/versioning/Android.bp
@@ -12,12 +12,12 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_shadows_versioning_upstream",
+    name: "Robolectric_shadows_versioning",
     srcs: ["src/main/java/**/*.java"],
     static_libs: [
         "robolectric-javax.annotation-api-1.2",
-        "Robolectric_shadowapi_upstream",
-        "Robolectric_utils_upstream",
+        "Robolectric_shadowapi",
+        "Robolectric_utils",
         "jsr305",
     ],
     libs: ["robolectric-host-android_all"],
@@ -28,10 +28,10 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_shadows_versioning_tests_upstream",
+    name: "Robolectric_shadows_versioning_tests",
     srcs: ["src/test/java/**/AndroidVersionsEdgeCaseTest.java"],
     static_libs: [
-        "Robolectric_shadows_versioning_upstream",
+        "Robolectric_shadows_versioning",
         "hamcrest",
         "guava",
         "junit",
@@ -46,7 +46,7 @@ java_test_host {
 //android_robolectric_test {
 //    enabled: true,
 //
-//    name: "Robolectric_shadows_versioning_tests_e2e_upstream",
+//    name: "Robolectric_shadows_versioning_tests_e2e",
 //
 //    srcs: [
 //        "src/**/*.AndroidVersionsTest.java",
@@ -61,5 +61,4 @@ java_test_host {
 //
 //    instrumentation_for: "MyRoboApplication",
 //
-//    upstream: true,
 //}
diff --git a/simulator/src/main/java/org/robolectric/simulator/AppLoader.java b/simulator/src/main/java/org/robolectric/simulator/AppLoader.java
new file mode 100644
index 000000000..f18927ad4
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/AppLoader.java
@@ -0,0 +1,107 @@
+package org.robolectric.simulator;
+
+import android.app.Activity;
+import android.app.Application;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ResolveInfo;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.ConscryptMode;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.LooperMode;
+import org.robolectric.annotation.SQLiteMode;
+import org.robolectric.annotation.experimental.LazyApplication;
+import org.robolectric.internal.AndroidSandbox;
+import org.robolectric.manifest.AndroidManifest;
+import org.robolectric.pluginapi.config.ConfigurationStrategy;
+
+/** Loads an apk into the simulator */
+public class AppLoader implements Runnable {
+
+  private final AndroidSandbox sandbox;
+
+  private final Path apkPath;
+
+  public AppLoader(AndroidSandbox sandbox, Path apkPath) {
+    this.sandbox = sandbox;
+    this.apkPath = apkPath;
+  }
+
+  @Override
+  public void run() {
+    Thread.currentThread().setContextClassLoader(sandbox.getRobolectricClassLoader());
+
+    AndroidManifest manifest = new AndroidManifest(null, null, null, null, "", this.apkPath);
+
+    this.sandbox
+        .getTestEnvironment()
+        .setUpApplicationState("simulator", new FixedConfiguration(), manifest);
+
+    Application application = RuntimeEnvironment.getApplication();
+
+    // Create an intent that will find the main launcher activity
+    Intent intent = new Intent(Intent.ACTION_MAIN, null);
+    intent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+    // Query the PackageManager for activities matching the intent
+    List<ResolveInfo> resolveInfoList =
+        application.getPackageManager().queryIntentActivities(intent, 0);
+
+    Preconditions.checkArgument(!resolveInfoList.isEmpty());
+
+    ResolveInfo resolveInfo = resolveInfoList.get(0);
+    ActivityInfo activityInfo = resolveInfo.activityInfo;
+
+    Preconditions.checkNotNull(activityInfo);
+    Preconditions.checkNotNull(activityInfo.name);
+    // Start the main Activity
+    try {
+      Class<? extends Activity> activityClass =
+          Class.forName(activityInfo.name).asSubclass(Activity.class);
+      System.err.println("Launching " + activityClass.getName());
+      Robolectric.setupActivity(activityClass);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    new Simulator().start();
+  }
+
+  /**
+   * A {@link ConfigurationStrategy.Configuration} that provides a fixed set of values for the
+   * configuration.
+   */
+  public static class FixedConfiguration implements ConfigurationStrategy.Configuration {
+
+    private static final ImmutableMap<Class<?>, Object> MODES =
+        ImmutableMap.of(
+            Config.class, new Config.Builder().build(),
+            ConscryptMode.Mode.class, ConscryptMode.Mode.OFF,
+            LooperMode.Mode.class, LooperMode.Mode.PAUSED,
+            LazyApplication.LazyLoad.class, LazyApplication.LazyLoad.OFF,
+            GraphicsMode.Mode.class, GraphicsMode.Mode.NATIVE,
+            SQLiteMode.Mode.class, SQLiteMode.Mode.NATIVE);
+
+    @Override
+    public <T> T get(Class<T> aClass) {
+      return aClass.cast(MODES.get(aClass));
+    }
+
+    @Override
+    public Collection<Class<?>> keySet() {
+      return MODES.keySet();
+    }
+
+    @Override
+    public Map<Class<?>, Object> map() {
+      return MODES;
+    }
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/DefaultMenuCustomizer.java b/simulator/src/main/java/org/robolectric/simulator/DefaultMenuCustomizer.java
new file mode 100644
index 000000000..746cb3a12
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/DefaultMenuCustomizer.java
@@ -0,0 +1,18 @@
+package org.robolectric.simulator;
+
+import com.google.auto.service.AutoService;
+import com.google.common.annotations.Beta;
+import javax.annotation.Priority;
+import javax.swing.JPopupMenu;
+import org.robolectric.simulator.pluginapi.MenuCustomizer;
+
+/** Default implementation of {@link MenuCustomizer}. */
+@Priority(Integer.MIN_VALUE)
+@Beta
+@AutoService(MenuCustomizer.class)
+public class DefaultMenuCustomizer implements MenuCustomizer {
+  @Override
+  public void customizePopupMenu(JPopupMenu menu) {
+    // no-op
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/KeyboardHandler.java b/simulator/src/main/java/org/robolectric/simulator/KeyboardHandler.java
new file mode 100644
index 000000000..222fe4fac
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/KeyboardHandler.java
@@ -0,0 +1,178 @@
+package org.robolectric.simulator;
+
+import android.os.Handler;
+import android.os.Looper;
+import com.google.common.collect.ImmutableMap;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+import org.robolectric.shadows.ShadowUiAutomation;
+
+/** A {@link KeyListener} that forwards KeyEvents to Robolectric {@link ShadowUiAutomation}. */
+public final class KeyboardHandler implements KeyListener {
+
+  private final Handler handler = new Handler(Looper.getMainLooper());
+
+  // Map of AWT KeyEvent constants to Android KeyEvent constants
+  private static final ImmutableMap<Integer, Integer> KEY_MAP;
+
+  // Whether the shift key is being pressed.
+  private boolean shiftKeyPressed;
+
+  static {
+    KEY_MAP =
+        ImmutableMap.<Integer, Integer>builder()
+            .put(KeyEvent.VK_A, android.view.KeyEvent.KEYCODE_A)
+            .put(KeyEvent.VK_B, android.view.KeyEvent.KEYCODE_B)
+            .put(KeyEvent.VK_C, android.view.KeyEvent.KEYCODE_C)
+            .put(KeyEvent.VK_D, android.view.KeyEvent.KEYCODE_D)
+            .put(KeyEvent.VK_E, android.view.KeyEvent.KEYCODE_E)
+            .put(KeyEvent.VK_F, android.view.KeyEvent.KEYCODE_F)
+            .put(KeyEvent.VK_G, android.view.KeyEvent.KEYCODE_G)
+            .put(KeyEvent.VK_H, android.view.KeyEvent.KEYCODE_H)
+            .put(KeyEvent.VK_I, android.view.KeyEvent.KEYCODE_I)
+            .put(KeyEvent.VK_J, android.view.KeyEvent.KEYCODE_J)
+            .put(KeyEvent.VK_K, android.view.KeyEvent.KEYCODE_K)
+            .put(KeyEvent.VK_L, android.view.KeyEvent.KEYCODE_L)
+            .put(KeyEvent.VK_M, android.view.KeyEvent.KEYCODE_M)
+            .put(KeyEvent.VK_N, android.view.KeyEvent.KEYCODE_N)
+            .put(KeyEvent.VK_O, android.view.KeyEvent.KEYCODE_O)
+            .put(KeyEvent.VK_P, android.view.KeyEvent.KEYCODE_P)
+            .put(KeyEvent.VK_Q, android.view.KeyEvent.KEYCODE_Q)
+            .put(KeyEvent.VK_R, android.view.KeyEvent.KEYCODE_R)
+            .put(KeyEvent.VK_S, android.view.KeyEvent.KEYCODE_S)
+            .put(KeyEvent.VK_T, android.view.KeyEvent.KEYCODE_T)
+            .put(KeyEvent.VK_U, android.view.KeyEvent.KEYCODE_U)
+            .put(KeyEvent.VK_V, android.view.KeyEvent.KEYCODE_V)
+            .put(KeyEvent.VK_W, android.view.KeyEvent.KEYCODE_W)
+            .put(KeyEvent.VK_X, android.view.KeyEvent.KEYCODE_X)
+            .put(KeyEvent.VK_Y, android.view.KeyEvent.KEYCODE_Y)
+            .put(KeyEvent.VK_Z, android.view.KeyEvent.KEYCODE_Z)
+            .put(KeyEvent.VK_0, android.view.KeyEvent.KEYCODE_0)
+            .put(KeyEvent.VK_1, android.view.KeyEvent.KEYCODE_1)
+            .put(KeyEvent.VK_2, android.view.KeyEvent.KEYCODE_2)
+            .put(KeyEvent.VK_3, android.view.KeyEvent.KEYCODE_3)
+            .put(KeyEvent.VK_4, android.view.KeyEvent.KEYCODE_4)
+            .put(KeyEvent.VK_5, android.view.KeyEvent.KEYCODE_5)
+            .put(KeyEvent.VK_6, android.view.KeyEvent.KEYCODE_6)
+            .put(KeyEvent.VK_7, android.view.KeyEvent.KEYCODE_7)
+            .put(KeyEvent.VK_8, android.view.KeyEvent.KEYCODE_8)
+            .put(KeyEvent.VK_9, android.view.KeyEvent.KEYCODE_9)
+            .put(KeyEvent.VK_ENTER, android.view.KeyEvent.KEYCODE_ENTER)
+            .put(KeyEvent.VK_TAB, android.view.KeyEvent.KEYCODE_TAB)
+            .put(KeyEvent.VK_SPACE, android.view.KeyEvent.KEYCODE_SPACE)
+            .put(KeyEvent.VK_LEFT, android.view.KeyEvent.KEYCODE_DPAD_LEFT)
+            .put(KeyEvent.VK_RIGHT, android.view.KeyEvent.KEYCODE_DPAD_RIGHT)
+            .put(KeyEvent.VK_UP, android.view.KeyEvent.KEYCODE_DPAD_UP)
+            .put(KeyEvent.VK_DOWN, android.view.KeyEvent.KEYCODE_DPAD_DOWN)
+            .put(KeyEvent.VK_HOME, android.view.KeyEvent.KEYCODE_HOME)
+            .put(KeyEvent.VK_END, android.view.KeyEvent.KEYCODE_ENDCALL)
+            .put(KeyEvent.VK_INSERT, android.view.KeyEvent.KEYCODE_INSERT)
+            .put(KeyEvent.VK_BACK_SPACE, android.view.KeyEvent.KEYCODE_DEL)
+            .put(KeyEvent.VK_DELETE, android.view.KeyEvent.KEYCODE_FORWARD_DEL)
+            .put(KeyEvent.VK_PAGE_UP, android.view.KeyEvent.KEYCODE_PAGE_UP)
+            .put(KeyEvent.VK_PAGE_DOWN, android.view.KeyEvent.KEYCODE_PAGE_DOWN)
+            .put(KeyEvent.VK_F1, android.view.KeyEvent.KEYCODE_F1)
+            .put(KeyEvent.VK_F2, android.view.KeyEvent.KEYCODE_F2)
+            .put(KeyEvent.VK_F3, android.view.KeyEvent.KEYCODE_F3)
+            .put(KeyEvent.VK_F4, android.view.KeyEvent.KEYCODE_F4)
+            .put(KeyEvent.VK_F5, android.view.KeyEvent.KEYCODE_F5)
+            .put(KeyEvent.VK_F6, android.view.KeyEvent.KEYCODE_F6)
+            .put(KeyEvent.VK_F7, android.view.KeyEvent.KEYCODE_F7)
+            .put(KeyEvent.VK_F8, android.view.KeyEvent.KEYCODE_F8)
+            .put(KeyEvent.VK_F9, android.view.KeyEvent.KEYCODE_F9)
+            .put(KeyEvent.VK_F10, android.view.KeyEvent.KEYCODE_F10)
+            .put(KeyEvent.VK_F11, android.view.KeyEvent.KEYCODE_F11)
+            .put(KeyEvent.VK_F12, android.view.KeyEvent.KEYCODE_F12)
+            .put(KeyEvent.VK_ESCAPE, android.view.KeyEvent.KEYCODE_ESCAPE)
+            .put(KeyEvent.VK_BACK_QUOTE, android.view.KeyEvent.KEYCODE_GRAVE)
+            .put(KeyEvent.VK_MINUS, android.view.KeyEvent.KEYCODE_MINUS)
+            .put(KeyEvent.VK_EQUALS, android.view.KeyEvent.KEYCODE_EQUALS)
+            .put(KeyEvent.VK_OPEN_BRACKET, android.view.KeyEvent.KEYCODE_LEFT_BRACKET)
+            .put(KeyEvent.VK_CLOSE_BRACKET, android.view.KeyEvent.KEYCODE_RIGHT_BRACKET)
+            .put(KeyEvent.VK_BACK_SLASH, android.view.KeyEvent.KEYCODE_BACKSLASH)
+            .put(KeyEvent.VK_SEMICOLON, android.view.KeyEvent.KEYCODE_SEMICOLON)
+            .put(KeyEvent.VK_QUOTE, android.view.KeyEvent.KEYCODE_APOSTROPHE)
+            .put(KeyEvent.VK_COMMA, android.view.KeyEvent.KEYCODE_COMMA)
+            .put(KeyEvent.VK_PERIOD, android.view.KeyEvent.KEYCODE_PERIOD)
+            .put(KeyEvent.VK_SLASH, android.view.KeyEvent.KEYCODE_SLASH)
+            .put(KeyEvent.VK_CAPS_LOCK, android.view.KeyEvent.KEYCODE_CAPS_LOCK)
+            .put(KeyEvent.VK_CONTROL, android.view.KeyEvent.KEYCODE_CTRL_LEFT)
+            .put(KeyEvent.VK_ALT, android.view.KeyEvent.KEYCODE_ALT_LEFT)
+            .put(KeyEvent.VK_META, android.view.KeyEvent.KEYCODE_META_LEFT)
+            .buildOrThrow();
+  }
+
+  public KeyboardHandler() {}
+
+  @Override
+  public void keyTyped(KeyEvent e) {
+    // No-op
+  }
+
+  @Override
+  public void keyPressed(KeyEvent e) {
+    if (e.getKeyCode() == KeyEvent.VK_SHIFT) {
+      shiftKeyPressed = true;
+      return;
+    }
+    handler.post(
+        () -> {
+          if (!KEY_MAP.containsKey(e.getKeyCode())) {
+            System.err.println("Unknown mapping for AWT key " + e.getKeyCode());
+          } else {
+            if (shiftKeyPressed) {
+              ShadowUiAutomation.injectInputEvent(
+                  newAndroidKeyEvent(
+                      android.view.KeyEvent.ACTION_DOWN,
+                      android.view.KeyEvent.KEYCODE_SHIFT_LEFT,
+                      android.view.KeyEvent.META_SHIFT_ON
+                          | android.view.KeyEvent.META_SHIFT_LEFT_ON));
+            }
+
+            ShadowUiAutomation.injectInputEvent(
+                newAndroidKeyEvent(
+                    android.view.KeyEvent.ACTION_DOWN,
+                    KEY_MAP.get(e.getKeyCode()),
+                    shiftKeyPressed
+                        ? android.view.KeyEvent.META_SHIFT_ON
+                            | android.view.KeyEvent.META_SHIFT_LEFT_ON
+                        : 0));
+          }
+        });
+  }
+
+  @Override
+  public void keyReleased(KeyEvent e) {
+    if (e.getKeyCode() == KeyEvent.VK_SHIFT) {
+      shiftKeyPressed = false;
+      return;
+    }
+    handler.post(
+        () -> {
+          if (!KEY_MAP.containsKey(e.getKeyCode())) {
+            System.err.println("Unknown mapping for AWT key " + e.getKeyCode());
+          } else {
+            ShadowUiAutomation.injectInputEvent(
+                newAndroidKeyEvent(
+                    android.view.KeyEvent.ACTION_UP,
+                    KEY_MAP.get(e.getKeyCode()),
+                    shiftKeyPressed
+                        ? android.view.KeyEvent.META_SHIFT_ON
+                            | android.view.KeyEvent.META_SHIFT_LEFT_ON
+                        : 0));
+            if (shiftKeyPressed) {
+              ShadowUiAutomation.injectInputEvent(
+                  newAndroidKeyEvent(
+                      android.view.KeyEvent.ACTION_UP,
+                      android.view.KeyEvent.KEYCODE_SHIFT_LEFT,
+                      0));
+            }
+          }
+        });
+  }
+
+  private static android.view.KeyEvent newAndroidKeyEvent(int action, int code, int metaState) {
+    return new android.view.KeyEvent(
+        /* downTime= */ 0, /* eventTime= */ 0, action, code, /* repeat= */ 0, metaState);
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java b/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java
new file mode 100644
index 000000000..9062a1407
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java
@@ -0,0 +1,127 @@
+package org.robolectric.simulator;
+
+import android.app.UiAutomation;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import androidx.test.platform.app.InstrumentationRegistry;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.time.Duration;
+import java.time.Instant;
+import javax.swing.JMenuItem;
+import javax.swing.JPopupMenu;
+import javax.swing.SwingUtilities;
+import org.robolectric.shadows.ShadowUiAutomation;
+import org.robolectric.simulator.pluginapi.MenuCustomizer;
+import org.robolectric.util.inject.Injector;
+
+/** A {@link MouseAdapter} that triggers Android {@link MotionEvent}s when the mouse is pressed. */
+public class MouseHandler extends MouseAdapter {
+  private final UiAutomation uiAutomation =
+      InstrumentationRegistry.getInstrumentation().getUiAutomation();
+
+  private boolean isPressed;
+  private Duration androidSystemClockTimeDelta;
+  private Instant downTime;
+
+  private final Handler handler = new Handler(Looper.getMainLooper());
+
+  private final JPopupMenu rightClickMenu;
+
+  public MouseHandler() {
+    rightClickMenu = new JPopupMenu();
+    rightClickMenu.add(getBackMenuItem());
+
+    // Allow plugins to customize the right click menu.
+    Injector injector = new Injector.Builder(Looper.class.getClassLoader()).build();
+    MenuCustomizer menuCustomizer = injector.getInstance(MenuCustomizer.class);
+    menuCustomizer.customizePopupMenu(rightClickMenu);
+  }
+
+  private JMenuItem getBackMenuItem() {
+    JMenuItem sendBackMenuItem = new JMenuItem("Press back");
+    sendBackMenuItem.addActionListener(
+        e -> {
+          handler.post(
+              () -> {
+                long eventTime = SystemClock.uptimeMillis();
+                KeyEvent backKeyDown =
+                    new KeyEvent(
+                        eventTime,
+                        eventTime,
+                        KeyEvent.ACTION_DOWN,
+                        KeyEvent.KEYCODE_BACK,
+                        /* repeat= */ 0,
+                        0);
+                ShadowUiAutomation.injectInputEvent(backKeyDown);
+
+                KeyEvent backKeyUp =
+                    new KeyEvent(
+                        eventTime,
+                        eventTime,
+                        KeyEvent.ACTION_UP,
+                        KeyEvent.KEYCODE_BACK,
+                        /* repeat= */ 0,
+                        0);
+                ShadowUiAutomation.injectInputEvent(backKeyUp);
+              });
+        });
+
+    return sendBackMenuItem;
+  }
+
+  @Override
+  public void mousePressed(MouseEvent mouseEvent) {
+    if (shouldHandle(mouseEvent)) {
+      isPressed = true;
+      androidSystemClockTimeDelta =
+          Duration.ofMillis(SystemClock.uptimeMillis()).minus(Duration.ofNanos(System.nanoTime()));
+      downTime = Instant.ofEpochMilli(mouseEvent.getWhen());
+      postMotionEvent(mouseEvent, MotionEvent.ACTION_DOWN);
+    }
+  }
+
+  @Override
+  public void mouseDragged(MouseEvent mouseEvent) {
+    if (isPressed) {
+      postMotionEvent(mouseEvent, MotionEvent.ACTION_MOVE);
+    }
+  }
+
+  @Override
+  public void mouseReleased(MouseEvent mouseEvent) {
+    if (shouldHandle(mouseEvent)) {
+      isPressed = false;
+      postMotionEvent(mouseEvent, MotionEvent.ACTION_UP);
+    } else if (SwingUtilities.isRightMouseButton(mouseEvent)) {
+      rightClickMenu.show(mouseEvent.getComponent(), mouseEvent.getX(), mouseEvent.getY());
+    }
+  }
+
+  private boolean shouldHandle(MouseEvent mouseEvent) {
+    return !mouseEvent.isPopupTrigger() && SwingUtilities.isLeftMouseButton(mouseEvent);
+  }
+
+  private void postMotionEvent(MouseEvent mouseEvent, int action) {
+    MotionEvent androidEvent = obtainMotionEvent(mouseEvent, action);
+    handler.post(() -> uiAutomation.injectInputEvent(androidEvent, true));
+    mouseEvent.consume();
+  }
+
+  private MotionEvent obtainMotionEvent(MouseEvent mouseEvent, int action) {
+    return MotionEvent.obtain(
+        toAndroidTime(downTime),
+        toAndroidTime(Instant.ofEpochMilli(mouseEvent.getWhen())),
+        action,
+        mouseEvent.getX(),
+        mouseEvent.getY(),
+        /* metaState= */ 0);
+  }
+
+  private long toAndroidTime(Instant instant) {
+    return instant.minus(androidSystemClockTimeDelta).toEpochMilli();
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java b/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java
new file mode 100644
index 000000000..272c24f93
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java
@@ -0,0 +1,154 @@
+package org.robolectric.simulator;
+
+import com.google.common.collect.Iterables;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Properties;
+import org.robolectric.android.AndroidSdkShadowMatcher;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.SQLiteMode;
+import org.robolectric.interceptors.AndroidInterceptors;
+import org.robolectric.internal.AndroidSandbox;
+import org.robolectric.internal.SandboxManager;
+import org.robolectric.internal.bytecode.ClassHandler;
+import org.robolectric.internal.bytecode.ClassHandlerBuilder;
+import org.robolectric.internal.bytecode.InstrumentationConfiguration;
+import org.robolectric.internal.bytecode.Interceptors;
+import org.robolectric.internal.bytecode.MethodRef;
+import org.robolectric.internal.bytecode.ShadowMap;
+import org.robolectric.internal.bytecode.ShadowProviders;
+import org.robolectric.pluginapi.Sdk;
+import org.robolectric.pluginapi.SdkProvider;
+import org.robolectric.simulator.SimulatorClassLoader.JarCollection;
+import org.robolectric.util.inject.Injector;
+
+/**
+ * A Builder pattern for Robolectric Sandboxes. This also binds a {@link JarCollection} class that
+ * encapsulates extra jars that can be used by the Robolectric ClassLoader.
+ */
+public final class SandboxBuilder {
+
+  private final List<Path> extraJars = new ArrayList<>();
+
+  private SandboxBuilder() {}
+
+  public static SandboxBuilder newBuilder() {
+    return new SandboxBuilder();
+  }
+
+  @CanIgnoreReturnValue
+  public SandboxBuilder addExtraJar(Path jarPath) {
+    extraJars.add(jarPath);
+    return this;
+  }
+
+  @CanIgnoreReturnValue
+  public SandboxBuilder addExtraJars(Collection<Path> jarPaths) {
+    extraJars.addAll(jarPaths);
+    return this;
+  }
+
+  public AndroidSandbox build() {
+    Injector injector =
+        new Injector.Builder()
+            .bind(Properties.class, System.getProperties())
+            .bind(JarCollection.class, new JarCollection(extraJars))
+            .build();
+
+    SdkProvider sdkProvider = injector.getInstance(SdkProvider.class);
+
+    ArrayList<Sdk> sdks = new ArrayList<>(sdkProvider.getSdks());
+
+    Sdk latestSdk = Iterables.getLast(sdks);
+
+    Interceptors interceptors = new Interceptors(AndroidInterceptors.all());
+
+    InstrumentationConfiguration instrumentationConfiguration =
+        buildInstrumentationConfiguration(interceptors);
+
+    SandboxManager.SandboxBuilder sandboxBuilder =
+        injector.getInstance(SandboxManager.SandboxBuilder.class);
+
+    AndroidSandbox androidSandbox =
+        sandboxBuilder.build(
+            instrumentationConfiguration,
+            latestSdk,
+            latestSdk,
+            ResourcesMode.Mode.BINARY,
+            SQLiteMode.Mode.NATIVE);
+
+    ShadowProviders shadowProviders = injector.getInstance(ShadowProviders.class);
+    ClassHandlerBuilder classHandlerBuilder = injector.getInstance(ClassHandlerBuilder.class);
+
+    ShadowMap.Builder smBuilder = shadowProviders.getBaseShadowMap().newBuilder();
+
+    ShadowMap shadowMap = smBuilder.build();
+    androidSandbox.replaceShadowMap(shadowMap);
+
+    AndroidSdkShadowMatcher shadowMatcher = new AndroidSdkShadowMatcher(latestSdk.getApiLevel());
+
+    ClassHandler classHandler = classHandlerBuilder.build(shadowMap, shadowMatcher, interceptors);
+
+    androidSandbox.configure(classHandler, interceptors);
+
+    return androidSandbox;
+  }
+
+  private InstrumentationConfiguration buildInstrumentationConfiguration(
+      Interceptors interceptors) {
+    InstrumentationConfiguration.Builder builder = new InstrumentationConfiguration.Builder();
+
+    for (MethodRef methodRef : interceptors.getAllMethodRefs()) {
+      builder.addInterceptedMethod(methodRef);
+    }
+
+    builder.doNotAcquireClass("org.robolectric.shadow.api.ShadowPicker");
+
+    builder
+        .doNotAcquirePackage("org.bouncycastle.")
+        .doNotAcquirePackage("org.conscrypt.")
+        .doNotAcquirePackage("org.objectweb.asm")
+        .doNotAcquirePackage("org.robolectric.manifest.")
+        .doNotAcquirePackage("org.robolectric.res.")
+        .doNotAcquirePackage("org.w3c.")
+        .doNotAcquirePackage("org.xml.");
+
+    builder
+        .addClassNameTranslation(
+            "java.net.ExtendedResponseCache", "org.robolectric.fakes.RoboExtendedResponseCache")
+        .addClassNameTranslation(
+            "java.net.ResponseSource", "org.robolectric.fakes.RoboResponseSource")
+        // Needed for android.net.Uri in older SDK versions
+        .addClassNameTranslation("java.nio.charset.Charsets", StandardCharsets.class.getName())
+        .addClassNameTranslation("java.lang.UnsafeByteSequence", Object.class.getName())
+        .addClassNameTranslation("java.util.jar.StrictJarFile", Object.class.getName())
+        .addClassNameTranslation("sun.misc.Cleaner", "java.lang.ref.Cleaner$Cleanable");
+
+    // Don't instrument legacy support packages.
+    builder
+        .doNotInstrumentPackage("android.support.constraint.")
+        .doNotInstrumentPackage("android.support.v7.view.")
+        .doNotInstrumentPackage("android.arch")
+        .doNotInstrumentPackage("android.support.test")
+        .doNotInstrumentPackage("android.R"); // android.R* are pure data classes.
+
+    // Instrumenting this Exceptions causes "java.lang.NegativeArraySizeException: -2" and
+    // leads to java.lang.NoClassDefFoundError.
+    builder.doNotInstrumentClass("android.app.RecoverableSecurityException");
+
+    builder
+        .addInstrumentedPackage("dalvik.")
+        .addInstrumentedPackage("libcore.")
+        .addInstrumentedPackage("android.")
+        .addInstrumentedPackage("com.android.internal.")
+        .addInstrumentedPackage("org.apache.http.") // For httpclient shadows.
+        .addInstrumentedPackage("org.ccil.cowan.tagsoup.") // For the System.arraycopy interceptor.
+        .addInstrumentedPackage("org.kxml2."); // For the System.arraycopy interceptor.
+
+    return builder.build();
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/Simulator.java b/simulator/src/main/java/org/robolectric/simulator/Simulator.java
new file mode 100644
index 000000000..013c90234
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/Simulator.java
@@ -0,0 +1,88 @@
+package org.robolectric.simulator;
+
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+
+import android.app.Application;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.hardware.display.DisplayManager;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.view.Display;
+import androidx.test.platform.app.InstrumentationRegistry;
+import com.google.common.annotations.Beta;
+import com.google.common.base.Preconditions;
+import java.time.Duration;
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.LooperMode.Mode;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowChoreographer;
+import org.robolectric.shadows.ShadowLooper;
+import org.robolectric.shadows.ShadowPausedLooper;
+import org.robolectric.shadows.ShadowSystemClock;
+import org.robolectric.shadows.ShadowView;
+
+/** The main entry point for the Robolectric Simulator for use in existing Robolectric tests. */
+@Beta
+public final class Simulator {
+
+  private SimulatorFrame simulatorFrame;
+
+  public void start() {
+    Preconditions.checkState(ShadowView.useRealGraphics());
+    Preconditions.checkState(ShadowLooper.looperMode() != Mode.LEGACY);
+    System.setProperty("java.awt.headless", "false");
+    startUi();
+    captureScreen();
+    loop();
+  }
+
+  private void loop() {
+    ShadowPausedLooper shadowLooper = Shadow.extract(Looper.myLooper());
+    ShadowChoreographer.setPaused(true);
+    ShadowChoreographer.setFrameDelay(Duration.ofMillis(15));
+    shadowLooper.idle();
+    while (true) {
+      long currentSystemTime = System.nanoTime();
+      long nextTaskTime = shadowLooper.getNextScheduledTaskTime().toMillis();
+      long nextVsyncTime = ShadowChoreographer.getNextVsyncTime();
+      long timeoutTime =
+          nextTaskTime == 0 || nextVsyncTime == 0
+              ? max(nextTaskTime, nextVsyncTime)
+              : min(nextTaskTime, nextVsyncTime);
+      shadowLooper.poll(timeoutTime == 0 ? 0 : max(1, timeoutTime - SystemClock.uptimeMillis()));
+      ShadowSystemClock.advanceBy(Duration.ofNanos(System.nanoTime() - currentSystemTime));
+      shadowLooper.idle();
+      captureScreen();
+    }
+  }
+
+  private void startUi() {
+    Application application = RuntimeEnvironment.getApplication();
+    DisplayManager displayManager =
+        (DisplayManager) application.getSystemService(Context.DISPLAY_SERVICE);
+    Display display = displayManager.getDisplay(Display.DEFAULT_DISPLAY);
+
+    try {
+      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    SwingUtilities.invokeLater(
+        (Runnable)
+            () -> {
+              simulatorFrame = new SimulatorFrame(display.getWidth(), display.getHeight());
+              simulatorFrame.setVisible(true);
+              simulatorFrame.toFront();
+            });
+  }
+
+  private void captureScreen() {
+    final Bitmap bitmap =
+        InstrumentationRegistry.getInstrumentation().getUiAutomation().takeScreenshot();
+    SwingUtilities.invokeLater((Runnable) () -> simulatorFrame.getCanvas().drawBitmap(bitmap));
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/SimulatorCanvas.java b/simulator/src/main/java/org/robolectric/simulator/SimulatorCanvas.java
new file mode 100644
index 000000000..47ff50f51
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/SimulatorCanvas.java
@@ -0,0 +1,54 @@
+package org.robolectric.simulator;
+
+import android.graphics.Bitmap;
+import java.awt.Canvas;
+import java.awt.Color;
+import java.awt.Graphics;
+import java.awt.image.BufferStrategy;
+import java.awt.image.BufferedImage;
+
+/** A {@link Canvas} that draws screenshots taken with RNG. */
+public class SimulatorCanvas extends Canvas {
+  private int[] pixels;
+
+  public SimulatorCanvas() {
+    MouseHandler mouseHandler = new MouseHandler();
+    addMouseListener(mouseHandler);
+    addMouseMotionListener(mouseHandler);
+  }
+
+  private BufferedImage image;
+
+  @Override
+  public Color getBackground() {
+    return Color.BLACK;
+  }
+
+  @Override
+  public void paint(Graphics graphics) {
+    // Required override
+  }
+
+  public void drawBitmap(Bitmap bitmap) {
+    BufferStrategy bufferStrategy = getBufferStrategy();
+    if (bufferStrategy == null) {
+      createBufferStrategy(2);
+      bufferStrategy = getBufferStrategy();
+    }
+    Graphics graphics = bufferStrategy.getDrawGraphics();
+
+    int width = bitmap.getWidth();
+    int height = bitmap.getHeight();
+    if (pixels == null || pixels.length != width * height) {
+      pixels = new int[width * height];
+    }
+    if (image == null || image.getWidth() != width || image.getHeight() != height) {
+      image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
+    }
+    bitmap.getPixels(pixels, /* offset= */ 0, /* stride= */ width, 0, 0, width, height);
+    image.setRGB(0, 0, image.getWidth(), image.getHeight(), pixels, 0, image.getWidth());
+    graphics.drawImage(image, 0, 0, null);
+    graphics.dispose();
+    bufferStrategy.show();
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/SimulatorClassLoader.java b/simulator/src/main/java/org/robolectric/simulator/SimulatorClassLoader.java
new file mode 100644
index 000000000..217a004b1
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/SimulatorClassLoader.java
@@ -0,0 +1,88 @@
+package org.robolectric.simulator;
+
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.List;
+import javax.inject.Named;
+import org.robolectric.internal.AndroidSandbox;
+import org.robolectric.internal.bytecode.ClassInstrumentor;
+import org.robolectric.internal.bytecode.InstrumentationConfiguration;
+import org.robolectric.internal.bytecode.UrlResourceProvider;
+import org.robolectric.pluginapi.Sdk;
+import org.robolectric.util.Util;
+
+/**
+ * An override of {@link AndroidSandbox.SdkSandboxClassLoader} that supports extra local Jars in the
+ * classpath.
+ */
+@AutoService(AndroidSandbox.SdkSandboxClassLoader.class)
+public class SimulatorClassLoader extends AndroidSandbox.SdkSandboxClassLoader {
+
+  private final URLClassLoader extraClassLoader;
+
+  public SimulatorClassLoader(
+      InstrumentationConfiguration config,
+      @Named("runtimeSdk") Sdk runtimeSdk,
+      ClassInstrumentor classInstrumentor,
+      JarCollection jarCollection) {
+    super(config, runtimeSdk, classInstrumentor);
+    extraClassLoader = new UrlResourceProvider(jarCollection.getUrls());
+  }
+
+  @Override
+  protected byte[] getByteCode(String className) throws ClassNotFoundException {
+    String classFilename = className.replace('.', '/') + ".class";
+    try (InputStream classBytesStream = extraClassLoader.getResourceAsStream(classFilename)) {
+      if (classBytesStream == null) {
+        return super.getByteCode(className);
+      }
+      return Util.readBytes(classBytesStream);
+    } catch (IOException e) {
+      throw new ClassNotFoundException("couldn't load " + className, e);
+    }
+  }
+
+  /**
+   * This override is required to support ServiceLoader plugins in the extra jars passed into the
+   * simulator. It looks for all service-related metadata in META-INF/services/... in the extra jars
+   * before falling back to the superclass implementation.
+   */
+  @Override
+  public Enumeration<URL> findResources(String name) throws IOException {
+    ArrayList<URL> urls = new ArrayList<>();
+    urls.addAll(Collections.list(super.findResources(name)));
+    urls.addAll(Collections.list(extraClassLoader.findResources(name)));
+    return Collections.enumeration(urls);
+  }
+
+  /** Encapsulates a collection of Jar files. */
+  public static class JarCollection {
+
+    private final ImmutableList<Path> jarPaths;
+
+    public JarCollection(List<Path> jarPaths) {
+      this.jarPaths = ImmutableList.copyOf(jarPaths);
+    }
+
+    public URL[] getUrls() {
+      return jarPaths.stream().map(JarCollection::toUrl).toArray(URL[]::new);
+    }
+
+    private static URL toUrl(Path path) {
+      try {
+        return path.toUri().toURL();
+      } catch (MalformedURLException e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java b/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java
new file mode 100644
index 000000000..a8a4e463c
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java
@@ -0,0 +1,28 @@
+package org.robolectric.simulator;
+
+import javax.swing.JFrame;
+
+/** The top-level {@link JFrame} for the Robolectric Simulator. */
+public class SimulatorFrame extends JFrame {
+
+  private final SimulatorCanvas simulatorCanvas;
+
+  public SimulatorFrame(int displayWidth, int displayHeight) {
+    setTitle("Robolectric Simulator");
+
+    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+    setLocationByPlatform(true);
+    setAlwaysOnTop(true);
+    setResizable(false);
+    addKeyListener(new KeyboardHandler());
+
+    simulatorCanvas = new SimulatorCanvas();
+    simulatorCanvas.setSize(displayWidth, displayHeight);
+    add(simulatorCanvas);
+    pack();
+  }
+
+  public SimulatorCanvas getCanvas() {
+    return simulatorCanvas;
+  }
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java b/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java
new file mode 100644
index 000000000..3a8bbf8a2
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java
@@ -0,0 +1,57 @@
+package org.robolectric.simulator;
+
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import org.robolectric.internal.AndroidSandbox;
+
+/** The main class for the Robolectric Simulator. */
+public final class SimulatorMain {
+
+  public static void main(String[] args) throws Exception {
+    if (args.length < 2) {
+      System.err.println("Command-line usage: SimulatorLauncher <apk> <deploy_jar> [extra jars]");
+      System.exit(1);
+    }
+
+    File apkFile = new File(args[0]);
+    File deployJar = new File(args[1]);
+
+    List<Path> extraJars = new ArrayList<>();
+    for (int i = 2; i < args.length; i++) {
+      extraJars.add(Path.of(args[i]));
+    }
+
+    if (!apkFile.exists()) {
+      System.err.println("Missing APK file " + args[0]);
+      System.exit(1);
+    }
+
+    if (!deployJar.exists()) {
+      System.err.println("Missing deploy jar " + args[1]);
+      System.exit(1);
+    }
+
+    final AndroidSandbox androidSandbox =
+        SandboxBuilder.newBuilder()
+            .addExtraJar(apkFile.toPath())
+            .addExtraJar(deployJar.toPath())
+            .addExtraJars(extraJars)
+            .build();
+
+    androidSandbox.runOnMainThread(
+        () -> {
+          try {
+            Class<?> appLoaderClass = androidSandbox.bootstrappedClass(AppLoader.class);
+            Constructor<?> ctor = appLoaderClass.getConstructor(AndroidSandbox.class, Path.class);
+            ((Runnable) ctor.newInstance(androidSandbox, apkFile.toPath())).run();
+          } catch (Exception e) {
+            throw new RuntimeException(e);
+          }
+        });
+  }
+
+  private SimulatorMain() {}
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/pluginapi/MenuCustomizer.java b/simulator/src/main/java/org/robolectric/simulator/pluginapi/MenuCustomizer.java
new file mode 100644
index 000000000..118e2fce1
--- /dev/null
+++ b/simulator/src/main/java/org/robolectric/simulator/pluginapi/MenuCustomizer.java
@@ -0,0 +1,10 @@
+package org.robolectric.simulator.pluginapi;
+
+import com.google.common.annotations.Beta;
+import javax.swing.JPopupMenu;
+
+/** A plugin that makes it possible to customize the right click menu in the simulator. */
+@Beta
+public interface MenuCustomizer {
+  void customizePopupMenu(JPopupMenu menu);
+}
diff --git a/soong/robolectric.go b/soong/robolectric.go
index cadeb0fad..8295f2ddb 100644
--- a/soong/robolectric.go
+++ b/soong/robolectric.go
@@ -59,6 +59,7 @@ func (b *buildProps) GenerateAndroidBuildActions(ctx android.ModuleContext) {
 		"ro.hardware=robolectric",
 		"ro.build.version.security_patch=" + ctx.Config().PlatformSecurityPatch(),
 		"ro.build.version.sdk=" + ctx.Config().PlatformSdkVersion().String(),
+		"ro.build.version.sdk_full=" + ctx.Config().PlatformSdkVersion().String() + ".0",
 		"ro.build.version.release=" + ctx.Config().PlatformVersionName(),
 		"ro.build.version.preview_sdk=" + ctx.Config().PlatformPreviewSdkVersion(),
 		// We don't have the API fingerprint available, just use the preview SDK version.
@@ -78,6 +79,8 @@ func (b *buildProps) GenerateAndroidBuildActions(ctx android.ModuleContext) {
 		"ro.product.cpu.abilist32=armeabi-v7a,armeabi",
 		"ro.product.cpu.abilist64=armeabi-v7a,armeabi",
 		"",
+		"ro.vendor.api_level=" + ctx.Config().VendorApiLevel(),
+		"",
 		"# temp fix for robolectric freezing issue b/150011638",
 		"persist.debug.new_insets=0",
 	}
diff --git a/testapp/build.gradle.kts b/testapp/build.gradle.kts
index 5daff99e8..b7778ed47 100644
--- a/testapp/build.gradle.kts
+++ b/testapp/build.gradle.kts
@@ -1,7 +1,7 @@
 plugins { alias(libs.plugins.android.library) }
 
 android {
-  compileSdk = 34
+  compileSdk = 35
   namespace = "org.robolectric.testapp"
 
   defaultConfig {
diff --git a/testapp/src/main/res/color/color_primary_csl_with_theme_attr.xml b/testapp/src/main/res/color/color_primary_csl_with_theme_attr.xml
new file mode 100644
index 000000000..496055a96
--- /dev/null
+++ b/testapp/src/main/res/color/color_primary_csl_with_theme_attr.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/color/colorPrimary_csl_with_theme_attr.xml -->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:color="?attr/colorPrimary"/>
+</selector>
diff --git a/testapp/src/main/res/color/color_primary_dark_csl_with_theme_attr.xml b/testapp/src/main/res/color/color_primary_dark_csl_with_theme_attr.xml
new file mode 100644
index 000000000..9ac76bf93
--- /dev/null
+++ b/testapp/src/main/res/color/color_primary_dark_csl_with_theme_attr.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/color/colorPrimaryDark_csl_with_theme_attr.xml -->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:color="?attr/colorPrimaryDark"/>
+</selector>
diff --git a/testapp/src/main/res/drawable/gradient_drawable_density.xml b/testapp/src/main/res/drawable/gradient_drawable_density.xml
new file mode 100644
index 000000000..63a4a0ab3
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradient_drawable_density.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradient_drawable_density.xml -->
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="ring"
+    android:innerRadius="10dp"
+    android:thickness="4dp">
+    <gradient
+        android:gradientRadius="10dp" />
+    <corners
+        android:topLeftRadius="8dp"
+        android:topRightRadius="9dp"
+        android:bottomLeftRadius="10dp"
+        android:bottomRightRadius="11dp" />
+    <padding
+        android:left="11dp"
+        android:top="12dp"
+        android:right="13dp"
+        android:bottom="14dp" />
+    <stroke
+        android:color="@android:color/black"
+        android:dashGap="4dp"
+        android:dashWidth="4dp"
+        android:width="2dp" />
+    <size
+        android:width="200dp"
+        android:height="200dp" />
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable.xml b/testapp/src/main/res/drawable/gradientdrawable.xml
new file mode 100644
index 000000000..b8767c3dc
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="45"/>
+    <corners android:radius="8px" />
+    <padding android:left="4px" android:top="2px"
+        android:right="6px" android:bottom="10px" />
+    <size android:width="42px" android:height="63px"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_color_all_theme.xml b/testapp/src/main/res/drawable/gradientdrawable_color_all_theme.xml
new file mode 100644
index 000000000..9a140e777
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_color_all_theme.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_color_all_theme.xml -->
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <gradient
+        android:startColor="@color/color_primary_csl_with_theme_attr"
+        android:centerColor="@color/color_primary_dark_csl_with_theme_attr"
+        android:endColor="@color/color_primary_dark_csl_with_theme_attr"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_color_mix_theme.xml b/testapp/src/main/res/drawable/gradientdrawable_color_mix_theme.xml
new file mode 100644
index 000000000..a0cfdc964
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_color_mix_theme.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_color_mix_theme.xml -->
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <gradient
+        android:startColor="?attr/colorAccent"
+        android:centerColor="@color/color_primary_csl_with_theme_attr"
+        android:endColor="?attr/colorPrimaryDark"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_invalid_radius.xml b/testapp/src/main/res/drawable/gradientdrawable_invalid_radius.xml
new file mode 100644
index 000000000..eb738f095
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_invalid_radius.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_invalid_radius.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" >
+
+    <gradient
+        android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"
+        android:gradientRadius="-20px"
+        android:startColor="#ffffffff"
+        android:type="radial" />
+
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_mix_theme.xml b/testapp/src/main/res/drawable/gradientdrawable_mix_theme.xml
new file mode 100644
index 000000000..9a3deebb7
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_mix_theme.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_mix_theme.xml -->
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <gradient
+        android:angle="270"
+        android:type="?attr/GradientType"
+        android:gradientRadius="87px"
+        android:centerColor="@color/colorPrimary"
+        android:endColor="?attr/colorPrimaryDark"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle.xml
new file mode 100644
index 000000000..1835abd3d
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-450"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_135.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_135.xml
new file mode 100644
index 000000000..e586a1733
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_135.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_135.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-135"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_180.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_180.xml
new file mode 100644
index 000000000..d8b221519
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_180.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_180.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-180"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_225.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_225.xml
new file mode 100644
index 000000000..b26c7cea4
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_225.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_225.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-225"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_270.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_270.xml
new file mode 100644
index 000000000..69671d88c
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_270.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_270.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-270"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_315.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_315.xml
new file mode 100644
index 000000000..cc7e4aa66
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_315.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_315.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-315"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_360.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_360.xml
new file mode 100644
index 000000000..721701342
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_360.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_360.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-360"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_45.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_45.xml
new file mode 100644
index 000000000..a8219d304
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_45.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_45.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-45"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_negative_angle_90.xml b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_90.xml
new file mode 100644
index 000000000..afa167629
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_negative_angle_90.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_negative_angle_90.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:opticalInsetLeft="1px"
+    android:opticalInsetTop="2px"
+    android:opticalInsetRight="3px"
+    android:opticalInsetBottom="4px">
+    <gradient android:startColor="#ffffffff" android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"  android:angle="-90"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_no_center_color_all_theme.xml b/testapp/src/main/res/drawable/gradientdrawable_no_center_color_all_theme.xml
new file mode 100644
index 000000000..f7cdd506d
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_no_center_color_all_theme.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_noCenterColor_all_theme.xml -->
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <gradient
+        android:startColor="@color/color_primary_csl_with_theme_attr"
+        android:endColor="@color/color_primary_dark_csl_with_theme_attr"/>
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_radius_base.xml b/testapp/src/main/res/drawable/gradientdrawable_radius_base.xml
new file mode 100644
index 000000000..a2bc25629
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_radius_base.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+-->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_radius_base.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" >
+
+    <gradient
+        android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"
+        android:gradientRadius="50%"
+        android:startColor="#ffffffff"
+        android:type="radial" />
+
+    <corners android:radius="8px" />
+
+    <padding
+        android:bottom="10px"
+        android:left="4px"
+        android:right="6px"
+        android:top="2px" />
+
+    <size
+        android:height="50px"
+        android:width="50px" />
+
+</shape>
diff --git a/testapp/src/main/res/drawable/gradientdrawable_radius_parent.xml b/testapp/src/main/res/drawable/gradientdrawable_radius_parent.xml
new file mode 100644
index 000000000..739f4b334
--- /dev/null
+++ b/testapp/src/main/res/drawable/gradientdrawable_radius_parent.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+-->
+<!-- Copied from https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/graphics/res/drawable/gradientdrawable_radius_parent.xml -->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" >
+
+    <gradient
+        android:centerColor="#ffff0000"
+        android:endColor="#0000ffff"
+        android:gradientRadius="50%p"
+        android:startColor="#ffffffff"
+        android:type="radial" />
+
+    <corners android:radius="8px" />
+
+    <padding
+        android:bottom="10px"
+        android:left="4px"
+        android:right="6px"
+        android:top="2px" />
+
+    <size
+        android:height="50px"
+        android:width="50px" />
+
+</shape>
diff --git a/testapp/src/main/res/values/colors.xml b/testapp/src/main/res/values/colors.xml
index bb4aea08e..8978cc77c 100644
--- a/testapp/src/main/res/values/colors.xml
+++ b/testapp/src/main/res/values/colors.xml
@@ -22,4 +22,8 @@
   <color name="test_ARGB8">#00000002</color>
   <color name="test_RGB4">#00f</color>
   <color name="test_RGB8">#000004</color>
+
+  <color name="colorPrimary">#008577</color>
+  <color name="colorPrimaryDark">#00574B</color>
+  <color name="colorAccent">#D81B60</color>
 </resources>
diff --git a/testapp/src/main/res/values/styles.xml b/testapp/src/main/res/values/styles.xml
new file mode 100644
index 000000000..9fea2b19a
--- /dev/null
+++ b/testapp/src/main/res/values/styles.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <style name="Theme_MixedGradientTheme">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+
+        <!-- overwrite the default gradient type to be radial in the theme -->
+        <item name="GradientType">1</item>
+    </style>
+
+    <attr name="colorPrimary" format="reference|color" />
+    <attr name="colorPrimaryDark" format="reference|color" />
+    <attr name="colorAccent" format="reference|color" />
+
+    <!-- default gradient type of linear -->
+    <attr name="GradientType" format="integer">0</attr>
+</resources>
diff --git a/utils/Android.bp b/utils/Android.bp
index 33b87ebfd..8a5e2b305 100644
--- a/utils/Android.bp
+++ b/utils/Android.bp
@@ -12,14 +12,14 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_utils_upstream",
+    name: "Robolectric_utils",
     srcs: ["src/main/java/**/*.java"],
     common_srcs: ["src/main/java/**/*.kt"],
     plugins: ["auto_service_plugin"],
     static_libs: [
         "robolectric-javax.annotation-api-1.2",
-        "Robolectric_annotations_upstream",
-        "Robolectric_pluginapi_upstream",
+        "Robolectric_annotations",
+        "Robolectric_pluginapi",
         "error_prone_annotations",
         "guava",
         "jsr330",
@@ -34,7 +34,7 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_utils_tests_upstream",
+    name: "Robolectric_utils_tests",
     srcs: [
         "src/test/java/**/*.java",
         "src/test/java/**/*.kt",
@@ -43,7 +43,7 @@ java_test_host {
         "auto_service_plugin",
     ],
     static_libs: [
-        "Robolectric_utils_upstream",
+        "Robolectric_utils",
         "hamcrest",
         "guava",
         "junit",
diff --git a/utils/reflector/Android.bp b/utils/reflector/Android.bp
index 4788641a8..4a81607b4 100644
--- a/utils/reflector/Android.bp
+++ b/utils/reflector/Android.bp
@@ -12,9 +12,9 @@ package {
 }
 
 java_library_host {
-    name: "Robolectric_utils_reflector_upstream",
+    name: "Robolectric_utils_reflector",
     static_libs: [
-        "Robolectric_utils_upstream",
+        "Robolectric_utils",
         "asm-9.6",
         "asm-commons-9.6",
         "asm-tree-9.6",
@@ -28,11 +28,11 @@ java_library_host {
 //#############################################
 
 java_test_host {
-    name: "Robolectric_utils_reflector_tests_upstream",
+    name: "Robolectric_utils_reflector_tests",
     srcs: ["src/test/java/**/*.java"],
     static_libs: [
-        "Robolectric_utils_reflector_upstream",
-        "Robolectric_shadowapi_upstream",
+        "Robolectric_utils_reflector",
+        "Robolectric_shadowapi",
         "hamcrest",
         "guava",
         "junit",
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java
index 12f855f2b..b0f0b0218 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java
@@ -62,11 +62,10 @@ public class Reflector {
       return (T) staticReflectorCache.get(iClass);
     }
 
-    Class<?> targetClass = determineTargetClass(iClass);
-
     Constructor<? extends T> ctor = (Constructor<? extends T>) cache.get(iClass);
     try {
       if (ctor == null) {
+        Class<?> targetClass = determineTargetClass(iClass);
         Class<? extends T> reflectorClass =
             PerfStatsCollector.getInstance()
                 .measure(
@@ -130,8 +129,6 @@ public class Reflector {
 
     final Class<?> proxyClass;
     proxyClass = defineViaUnsafe(iClass, reflectorClassName, bytecode);
-    // proxyClass = defineViaNewClassLoader(iClass, reflectorClassName, bytecode);
-
     return proxyClass.asSubclass(iClass);
   }
 
@@ -140,25 +137,6 @@ public class Reflector {
     return UnsafeAccess.defineClass(iClass, reflectorClassName, bytecode);
   }
 
-  @SuppressWarnings("unused")
-  private static <T> Class<?> defineViaNewClassLoader(
-      Class<T> iClass, String reflectorClassName, byte[] bytecode) {
-    Class<?> proxyClass;
-    ClassLoader classLoader =
-        new ClassLoader(iClass.getClassLoader()) {
-          @Override
-          protected Class<?> findClass(String name) throws ClassNotFoundException {
-            return defineClass(name, bytecode, 0, bytecode.length);
-          }
-        };
-    try {
-      proxyClass = classLoader.loadClass(reflectorClassName);
-    } catch (ClassNotFoundException e) {
-      throw new AssertionError(e);
-    }
-    return proxyClass;
-  }
-
   private static <T> byte[] getBytecode(
       Class<T> iClass, Class<?> targetClass, String reflectorClassName) {
     ReflectorClassWriter writer = new ReflectorClassWriter(iClass, targetClass, reflectorClassName);
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
index 85c902c57..d5c1f196f 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
@@ -68,7 +68,6 @@ public class UnsafeAccess {
     }
   }
 
-  @SuppressWarnings("RethrowReflectiveOperationExceptionAsLinkageError")
   private static class Danger11Plus implements Danger {
     private final Method privateLookupInMethod;
     private final Method defineClassMethod;
@@ -80,7 +79,7 @@ public class UnsafeAccess {
                 "privateLookupIn", Class.class, MethodHandles.Lookup.class);
         defineClassMethod = MethodHandles.Lookup.class.getMethod("defineClass", byte[].class);
       } catch (NoSuchMethodException e) {
-        throw new AssertionError(e);
+        throw new LinkageError("Failed to find defineClass method", e);
       }
     }
 
@@ -89,11 +88,8 @@ public class UnsafeAccess {
       MethodHandles.Lookup lookup = MethodHandles.lookup();
 
       try {
-        // MethodHandles.Lookup privateLookup = MethodHandles.privateLookupIn(iClass, lookup);
         MethodHandles.Lookup privateLookup =
             (Lookup) privateLookupInMethod.invoke(lookup, iClass, lookup);
-
-        // return privateLookup.defineClass(bytecode);
         return (Class<?>) defineClassMethod.invoke(privateLookup, bytecode);
       } catch (IllegalAccessException | InvocationTargetException e) {
         throw new AssertionError(e);
diff --git a/utils/src/main/java/org/robolectric/AndroidMetadata.java b/utils/src/main/java/org/robolectric/AndroidMetadata.java
index 88f272fbb..928029ecc 100644
--- a/utils/src/main/java/org/robolectric/AndroidMetadata.java
+++ b/utils/src/main/java/org/robolectric/AndroidMetadata.java
@@ -14,5 +14,4 @@ public class AndroidMetadata {
   public Map<String, String> getDeviceBootProperties() {
     return deviceBootProperties;
   }
-
 }
diff --git a/utils/src/main/java/org/robolectric/util/Consumer.java b/utils/src/main/java/org/robolectric/util/Consumer.java
deleted file mode 100644
index 971ca2048..000000000
--- a/utils/src/main/java/org/robolectric/util/Consumer.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.robolectric.util;
-
-import java.util.Objects;
-
-/**
- * Represents an operation that accepts a single input argument and returns no result. Unlike most
- * other functional interfaces, {@code Consumer} is expected to operate via side-effects.
- *
- * <p>Included in Robolectric since Android doesn't support streams yet (as of O).
- *
- * @param <T> the type of the input to the operation
- */
-public interface Consumer<T> {
-
-  /**
-   * Performs this operation on the given argument.
-   *
-   * @param t the input argument
-   */
-  void accept(T t);
-
-  /**
-   * Returns a composed {@code Consumer} that performs, in sequence, this operation followed by the
-   * {@code after} operation. If performing either operation throws an exception, it is relayed to
-   * the caller of the composed operation. If performing this operation throws an exception, the
-   * {@code after} operation will not be performed.
-   *
-   * @param after the operation to perform after this operation
-   * @return a composed {@code Consumer} that performs in sequence this operation followed by the
-   *     {@code after} operation
-   * @throws NullPointerException if {@code after} is null
-   */
-  default Consumer<T> andThen(Consumer<? super T> after) {
-    Objects.requireNonNull(after);
-    return (T t) -> {
-      accept(t);
-      after.accept(t);
-    };
-  }
-}
diff --git a/utils/src/main/java/org/robolectric/util/Join.java b/utils/src/main/java/org/robolectric/util/Join.java
deleted file mode 100644
index 8556eacb4..000000000
--- a/utils/src/main/java/org/robolectric/util/Join.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.robolectric.util;
-
-import java.util.Collection;
-
-/** Utility class used to join strings together with a delimiter. */
-public class Join {
-  public static String join(String delimiter, Collection collection) {
-    String del = "";
-    StringBuilder sb = new StringBuilder();
-    for (Object obj : collection) {
-      String asString = obj == null ? null : obj.toString();
-      if (obj != null && asString.length() > 0) {
-        sb.append(del).append(obj);
-        del = delimiter;
-      }
-    }
-    return sb.toString();
-  }
-
-  public static String join(String delimiter, Object... collection) {
-    String del = "";
-    StringBuilder sb = new StringBuilder();
-    for (Object obj : collection) {
-      String asString = obj == null ? null : obj.toString();
-      if (asString != null && asString.length() > 0) {
-        sb.append(del).append(asString);
-        del = delimiter;
-      }
-    }
-    return sb.toString();
-  }
-}
diff --git a/utils/src/main/java/org/robolectric/util/Util.java b/utils/src/main/java/org/robolectric/util/Util.java
index e7bf383bd..d8b844aa2 100644
--- a/utils/src/main/java/org/robolectric/util/Util.java
+++ b/utils/src/main/java/org/robolectric/util/Util.java
@@ -1,6 +1,5 @@
 package org.robolectric.util;
 
-import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -69,23 +68,6 @@ public class Util {
     return array;
   }
 
-  public static File file(String... pathParts) {
-    return file(new File("."), pathParts);
-  }
-
-  public static File file(File f, String... pathParts) {
-    for (String pathPart : pathParts) {
-      f = new File(f, pathPart);
-    }
-
-    String dotSlash = "." + File.separator;
-    if (f.getPath().startsWith(dotSlash)) {
-      f = new File(f.getPath().substring(dotSlash.length()));
-    }
-
-    return f;
-  }
-
   @SuppressWarnings("NewApi")
   public static Path pathFrom(URL localArtifactUrl) {
     try {
@@ -95,14 +77,6 @@ public class Util {
     }
   }
 
-  public static int parseInt(String valueFor) {
-    if (valueFor.startsWith("0x")) {
-      return Integer.parseInt(valueFor.substring(2), 16);
-    } else {
-      return Integer.parseInt(valueFor, 10);
-    }
-  }
-
   /**
    * Re-throw {@code t} (even if it's a checked exception) without requiring a {@code throws}
    * declaration.
```

