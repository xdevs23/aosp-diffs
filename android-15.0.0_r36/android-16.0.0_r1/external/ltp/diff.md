```diff
diff --git a/.b4-config b/.b4-config
new file mode 100644
index 000000000..36aa15c38
--- /dev/null
+++ b/.b4-config
@@ -0,0 +1,9 @@
+# Configuration for the `b4` tool
+# See https://b4.docs.kernel.org/en/latest/config.html
+[b4]
+    send-series-to = Linux Test Project <ltp@lists.linux.it>
+    pw-url = https://patchwork.ozlabs.org/
+    pw-project = ltp
+    prep-perpatch-check-cmd = ./scripts/checkpatch.pl -q --terse --no-summary --mailback --showfile --no-tree --ignore CONST_STRUCT,VOLATILE,SPLIT_STRING,FILE_PATH_CHANGES
+    am-perpatch-check-cmd = ./scripts/checkpatch.pl -q --terse --no-summary --mailback --no-tree --ignore CONST_STRUCT,VOLATILE,SPLIT_STRING,FILE_PATH_CHANGES
+
diff --git a/.github/workflows/ci-docker-build.yml b/.github/workflows/ci-docker-build.yml
index 322c06efa..f33dd8356 100644
--- a/.github/workflows/ci-docker-build.yml
+++ b/.github/workflows/ci-docker-build.yml
@@ -114,7 +114,7 @@ jobs:
     container:
       image: ${{ matrix.container }}
       env: ${{ matrix.env }}
-      options: --security-opt seccomp=unconfined
+      options: --privileged -v/boot:/boot
 
     steps:
     - name: Show OS
@@ -128,7 +128,7 @@ jobs:
         INSTALL=${{ matrix.container }}
         INSTALL="${INSTALL%%:*}"
         INSTALL="${INSTALL%%/*}"
-        ./ci/$INSTALL.sh
+        ACTION="$VARIANT" ./ci/$INSTALL.sh
         if [ "$VARIANT" ]; then ./ci/$INSTALL.$VARIANT.sh; fi
 
     - name: Compiler version
@@ -161,6 +161,11 @@ jobs:
         case "$VARIANT" in cross-compile*) BUILD="cross";; i386) BUILD="32";; *) BUILD="native";; esac
         ./build.sh -r test-shell -o ${TREE:-in} -t $BUILD
 
+    - name: Test shell loader
+      run: |
+        case "$VARIANT" in cross-compile*) BUILD="cross";; i386) BUILD="32";; *) BUILD="native";; esac
+        ./build.sh -r test-shell-loader -o ${TREE:-in} -t $BUILD
+
     - name: Install
       run: |
         if [ "$MAKE_INSTALL" = 1 ]; then INSTALL_OPT="-i"; fi
diff --git a/.mailmap b/.mailmap
index 6c4b8dab3..221e22956 100644
--- a/.mailmap
+++ b/.mailmap
@@ -1,2 +1,3 @@
 Petr Vorel <pvorel@suse.cz> <petr.vorel@gmail.com>
 Petr Vorel <pvorel@suse.cz> <pevik@users.noreply.github.com>
+Xinjian Ma (Fujitsu) <maxj.fnst@fujitsu.com> <maxj.fnst@fujitsu.com>
diff --git a/Android.bp b/Android.bp
index c389e1868..4036ea9c0 100644
--- a/Android.bp
+++ b/Android.bp
@@ -91,11 +91,11 @@ filegroup {
 genrule {
     name: "ltp_syscalls_h",
     tool_files: [
-        "include/lapi/syscalls/order",
-        "include/lapi/syscalls/regen.sh",
+        "include/lapi/syscalls/supported-arch.txt",
+        "include/lapi/syscalls/generate_syscalls.sh",
         "include/lapi/syscalls/*.in",
     ],
-    cmd: "$(location include/lapi/syscalls/regen.sh) $(genDir)/lapi/syscalls.h",
+    cmd: "$(location include/lapi/syscalls/generate_syscalls.sh) $(genDir)/lapi/syscalls.h",
     out: ["lapi/syscalls.h"],
 }
 
@@ -121,7 +121,6 @@ cc_defaults {
         // Too many files import sched.h so we enable -fcommon locally
         // ltp may get away with this with glibc because of the __USE_GNU guard in glibc's <sched.h>
         "-Wall",
-        "-Werror",
         // These warnings should be checked and fixed upstream
         "-Wno-absolute-value",
         "-Wno-uninitialized",
diff --git a/INSTALL b/INSTALL
index 99386bed8..ad43514d4 100644
--- a/INSTALL
+++ b/INSTALL
@@ -55,13 +55,10 @@ in the same directory where the source files reside.
 	$ make all
 	$ make \
 	  "DESTDIR=$SYSROOT" \
-	  SKIP_IDCHECK=[0|1] \
 	  install
 
 - Specifying DESTDIR is optional, but required when installing to a non-host
   sysroot, as opposed to the host system's sysroot.
-- Specify SKIP_IDCHECK=1 if and when you don't want to modify /etc/{group,passwd}
-  on the target system's sysroot.
 
 If you get a build error, please report it to ltp@lists.linux.it with
 following information,
@@ -95,13 +92,10 @@ items which need fixing in the LTP tree.
 	  "top_srcdir=$TOP_SRCDIR" \
 	  "top_builddir=$OUT_OF_BUILD_TREE_DIR" \
 	  "DESTDIR=$SYSROOT" \
-	  SKIP_IDCHECK=[0|1]
 	  install
 
 - Specifying DESTDIR is optional, but required when installing to a non-host
   sysroot, as opposed to the host system's sysroot.
-- Specify SKIP_IDCHECK=1 if and when you don't want to modify /etc/{group,passwd}
-  on the target system's sysroot.
 
 Quick Start
 -----------
@@ -203,46 +197,3 @@ LDLIBS   - libraries listed after objects during link, e.g. -lc, -lpthread,
 
 For other variables and more info about the build systems see
 doc/Build-System.asciidoc.
-
-Common Issues
--------------
-
-Issue:    When executing configure it says:
-
-checking for a BSD-compatible install... /usr/bin/install -c
-checking whether build environment is sane... yes
-checking for gawk... gawk
-checking whether make sets $(MAKE)... yes
-configure: error: cannot run /bin/sh ./config.sub
-
-Solution: You must upgrade autoconf to 0.10.2+ and m4 to 1.4.7+; config.guess and config.sub aren't necessarily generated with older revisions of the Gnu autotools chain.
-
-Issue:    When executing make [all] it says:
-
-    " *** No rule to make target `/$*', needed by `pan-all'.  Stop."
-
-Solution: You must upgrade to make 3.81. Please see the Requirements section above.
-
-Issue:    When executing make [all] it says something like:
-
-    # ...
-    install -m 00644 "/scratch/ltp-dev2/ltp/include/test.h" "/scratch/ltp-install12/include/test.h"
-    install -m 00644 "/scratch/ltp-dev2/ltp/include/tlibio.h" "/scratch/ltp-install12/include/tlibio.h"
-    install -m 00644 "/scratch/ltp-dev2/ltp/include/usctest.h" "/scratch/ltp-install12/include/usctest.h"
-    install -m 00644 "/scratch/ltp-dev2/ltp/include/write_log.h" "/scratch/ltp-install12/include/write_log.h"
-    make[1]: Leaving directory `/scratch/ltp-dev2/ltp/include'
-    make -C lib -f "/scratch/ltp-dev2/ltp/lib/Makefile" all
-    make[1]: Entering directory `/scratch/ltp-dev2/ltp/lib'
-    " *** No rule to make target `dataascii.o', needed by `libltp.a'.  Stop." # <-- the error
-
-Solution: You cannot build LTP with -r / --no-builtin-rules and/or
-	  -R / --no-builtin-variables specified. LTP relies heavily on built-in
-	  implicit rules and variables to function properly.
-
-Issue:    When executing make (no target, 3.80), it does the following, and doesn't execute all:
-
-    #
-    make -C testcases/realtime autotools
-    make[1]: Entering directory `/scratch/ltp/testcases/realtime'
-    autoheader
-    make[1]: Leaving directory `/scratch/ltp/testcases/realtime'
diff --git a/Makefile b/Makefile
index d7d2815f1..506678934 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,7 @@ ifneq ($(build),$(host))
 	$(error running tests on cross-compile build not supported)
 endif
 	$(call _test)
+	$(MAKE) test-shell-loader
 	$(MAKE) test-metadata
 
 test-c: lib-all
@@ -202,6 +203,12 @@ ifneq ($(build),$(host))
 endif
 	$(call _test,-s)
 
+test-shell-loader: lib-all
+ifneq ($(build),$(host))
+	$(error running tests on cross-compile build not supported)
+endif
+	$(top_srcdir)/testcases/lib/run_tests.sh -b $(abs_builddir)
+
 test-metadata: metadata-all
 	$(MAKE) -C $(abs_srcdir)/metadata test
 
@@ -210,9 +217,3 @@ test-metadata: metadata-all
 help:
 	@echo "Please read the Configuration section in $(top_srcdir)/INSTALL"
 	@exit 1
-
-## Menuconfig
-menuconfig:
-	@$(SHELL) "$(top_srcdir)/ltpmenu"
-
-## End misc targets.
diff --git a/OWNERS b/OWNERS
index 47b8b86cb..6808978e4 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,4 +1,6 @@
-adelva@google.com
-balsini@google.com
+# Bug component: 391836
 edliaw@google.com
 bettyzhou@google.com
+adelva@google.com
+balsini@google.com
+include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/VERSION b/VERSION
index 660b1b67a..850652b6b 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-20240524
+20250130
diff --git a/android/Android.bp b/android/Android.bp
index bc60e91e4..9f5f62a13 100644
--- a/android/Android.bp
+++ b/android/Android.bp
@@ -15,6 +15,8 @@
 
 package {
     default_applicable_licenses: ["external_ltp_license"],
+    default_team: "trendy_team_android_kernel",
+
 }
 
 LTP_TESTS = [
@@ -63,6 +65,8 @@ LTP_TESTS = [
     ":ltp_asapi_02",
     ":ltp_asapi_03",
     ":ltp_aslr01",
+    ":ltp_async_handler",
+    ":ltp_async_handler_jk",
     ":ltp_atof01",
     ":ltp_autogroup01",
     ":ltp_bind01",
@@ -83,6 +87,9 @@ LTP_TESTS = [
     ":ltp_brk01",
     ":ltp_brk02",
     ":ltp_cacheflush01",
+    ":ltp_cachestat01",
+    ":ltp_cachestat03",
+    ":ltp_cachestat04",
     ":ltp_can_bcm01",
     ":ltp_can_filter",
     ":ltp_can_rcv_own_msgs",
@@ -112,6 +119,8 @@ LTP_TESTS = [
     ":ltp_chmod03",
     ":ltp_chmod05",
     ":ltp_chmod07",
+    ":ltp_chmod08",
+    ":ltp_chmod09",
     ":ltp_chown01",
     ":ltp_chown01_16",
     ":ltp_chown02",
@@ -357,6 +366,8 @@ LTP_TESTS = [
     ":ltp_fchmod06",
     ":ltp_fchmodat01",
     ":ltp_fchmodat02",
+    ":ltp_fchmodat2_01",
+    ":ltp_fchmodat2_02",
     ":ltp_fchown01",
     ":ltp_fchown01_16",
     ":ltp_fchown02",
@@ -495,6 +506,7 @@ LTP_TESTS = [
     ":ltp_fsopen02",
     ":ltp_fspick01",
     ":ltp_fspick02",
+    ":ltp_fsplough",
     ":ltp_fsstress",
     ":ltp_fstat02",
     ":ltp_fstat02_64",
@@ -577,6 +589,7 @@ LTP_TESTS = [
     ":ltp_get_robust_list01",
     ":ltp_getaddrinfo_01",
     ":ltp_getcpu01",
+    ":ltp_getcpu02",
     ":ltp_getcwd01",
     ":ltp_getcwd02",
     ":ltp_getcwd03",
@@ -658,8 +671,11 @@ LTP_TESTS = [
     ":ltp_getxattr03",
     ":ltp_getxattr04",
     ":ltp_getxattr05",
+    ":ltp_gtod_infinite",
+    ":ltp_gtod_latency",
     ":ltp_hackbench",
     ":ltp_hangup01",
+    ":ltp_hrtimer-prio",
     ":ltp_ht_affinity",
     ":ltp_ht_enabled",
     ":ltp_hugefallocate01",
@@ -695,6 +711,8 @@ LTP_TESTS = [
     ":ltp_hugemmap30",
     ":ltp_hugemmap31",
     ":ltp_hugemmap32",
+    ":ltp_hugemmap34",
+    ":ltp_hugeshmget06",
     ":ltp_icmp_rate_limit01",
     ":ltp_ima_boot_aggregate",
     ":ltp_ima_mmap",
@@ -748,6 +766,12 @@ LTP_TESTS = [
     ":ltp_ioctl07",
     ":ltp_ioctl08",
     ":ltp_ioctl09",
+    ":ltp_ioctl_ficlone01",
+    ":ltp_ioctl_ficlone02",
+    ":ltp_ioctl_ficlone03",
+    ":ltp_ioctl_ficlone04",
+    ":ltp_ioctl_ficlonerange01",
+    ":ltp_ioctl_ficlonerange02",
     ":ltp_ioctl_loop01",
     ":ltp_ioctl_loop02",
     ":ltp_ioctl_loop03",
@@ -803,6 +827,15 @@ LTP_TESTS = [
     ":ltp_ksm05",
     ":ltp_ksm06",
     ":ltp_ksm07",
+    ":ltp_landlock01",
+    ":ltp_landlock02",
+    ":ltp_landlock03",
+    ":ltp_landlock04",
+    ":ltp_landlock05",
+    ":ltp_landlock06",
+    ":ltp_landlock07",
+    ":ltp_landlock08",
+    ":ltp_landlock_exec",
     ":ltp_lchown01",
     ":ltp_lchown01_16",
     ":ltp_lchown02",
@@ -820,6 +853,10 @@ LTP_TESTS = [
     ":ltp_linkat01",
     ":ltp_linkat02",
     ":ltp_listen01",
+    ":ltp_listmount01",
+    ":ltp_listmount02",
+    ":ltp_listmount03",
+    ":ltp_listmount04",
     ":ltp_listxattr01",
     ":ltp_listxattr02",
     ":ltp_listxattr03",
@@ -830,6 +867,7 @@ LTP_TESTS = [
     ":ltp_llseek02",
     ":ltp_llseek03",
     ":ltp_locktests",
+    ":ltp_lookup_pi_state",
     ":ltp_lremovexattr01",
     ":ltp_lseek01",
     ":ltp_lseek02",
@@ -839,6 +877,8 @@ LTP_TESTS = [
     ":ltp_lstat01_64",
     ":ltp_lstat02",
     ":ltp_lstat02_64",
+    ":ltp_lstat03",
+    ":ltp_lstat03_64",
     ":ltp_ltpClient",
     ":ltp_ltpServer",
     ":ltp_ltp_acpi",
@@ -851,9 +891,11 @@ LTP_TESTS = [
     ":ltp_madvise09",
     ":ltp_madvise10",
     ":ltp_madvise11",
+    ":ltp_madvise12",
     ":ltp_mallinfo01",
     ":ltp_mallinfo02",
     ":ltp_mallinfo2_01",
+    ":ltp_matrix_mult",
     ":ltp_max_map_count",
     ":ltp_mbind01",
     ":ltp_mbind02",
@@ -993,6 +1035,8 @@ LTP_TESTS = [
     ":ltp_mremap03",
     ":ltp_mremap05",
     ":ltp_mremap06",
+    ":ltp_mseal01",
+    ":ltp_mseal02",
     ":ltp_msgget05",
     ":ltp_msync01",
     ":ltp_msync02",
@@ -1055,6 +1099,7 @@ LTP_TESTS = [
     ":ltp_open12_child",
     ":ltp_open13",
     ":ltp_open14",
+    ":ltp_open15",
     ":ltp_open_by_handle_at01",
     ":ltp_open_by_handle_at02",
     ":ltp_open_tree01",
@@ -1080,8 +1125,11 @@ LTP_TESTS = [
     ":ltp_perf_event_open01",
     ":ltp_perf_event_open02",
     ":ltp_perf_event_open03",
+    ":ltp_periodic_cpu_load",
+    ":ltp_periodic_cpu_load_single",
     ":ltp_personality01",
     ":ltp_personality02",
+    ":ltp_pi_perf",
     ":ltp_pidfd_getfd01",
     ":ltp_pidfd_getfd02",
     ":ltp_pidfd_open01",
@@ -1129,7 +1177,6 @@ LTP_TESTS = [
     ":ltp_prctl01",
     ":ltp_prctl02",
     ":ltp_prctl03",
-    ":ltp_prctl04",
     ":ltp_prctl05",
     ":ltp_prctl06",
     ":ltp_prctl06_execve",
@@ -1154,6 +1201,8 @@ LTP_TESTS = [
     ":ltp_preadv203",
     ":ltp_preadv203_64",
     ":ltp_print_caps",
+    ":ltp_prio-preempt",
+    ":ltp_prio-wake",
     ":ltp_proc01",
     ":ltp_proc_sched_rt01",
     ":ltp_process_madvise01",
@@ -1169,10 +1218,18 @@ LTP_TESTS = [
     ":ltp_pselect03_64",
     ":ltp_pt_test",
     ":ltp_ptem01",
+    ":ltp_ptem02",
+    ":ltp_ptem03",
+    ":ltp_ptem04",
+    ":ltp_ptem05",
+    ":ltp_ptem06",
     ":ltp_pth_str01",
     ":ltp_pth_str02",
     ":ltp_pth_str03",
     ":ltp_pthcli",
+    ":ltp_pthread_cond_latency",
+    ":ltp_pthread_cond_many",
+    ":ltp_pthread_kill_latency",
     ":ltp_pthserv",
     ":ltp_ptrace01",
     ":ltp_ptrace02",
@@ -1191,6 +1248,8 @@ LTP_TESTS = [
     ":ltp_pty04",
     ":ltp_pty06",
     ":ltp_pty07",
+    ":ltp_pty08",
+    ":ltp_pty09",
     ":ltp_pwrite01",
     ":ltp_pwrite01_64",
     ":ltp_pwrite02",
@@ -1258,6 +1317,7 @@ LTP_TESTS = [
     ":ltp_rename12",
     ":ltp_rename13",
     ":ltp_rename14",
+    ":ltp_rename15",
     ":ltp_renameat01",
     ":ltp_renameat201",
     ":ltp_renameat202",
@@ -1266,10 +1326,12 @@ LTP_TESTS = [
     ":ltp_request_key03",
     ":ltp_request_key04",
     ":ltp_request_key05",
+    ":ltp_request_key06",
     ":ltp_rmdir01",
     ":ltp_rmdir02",
     ":ltp_rmdir03",
     ":ltp_route-change-netlink",
+    ":ltp_rt-migrate",
     ":ltp_rt_sigaction01",
     ":ltp_rt_sigaction02",
     ":ltp_rt_sigaction03",
@@ -1277,6 +1339,7 @@ LTP_TESTS = [
     ":ltp_rt_sigprocmask01",
     ":ltp_rt_sigprocmask02",
     ":ltp_rt_sigqueueinfo01",
+    ":ltp_rt_sigqueueinfo02",
     ":ltp_rt_sigsuspend01",
     ":ltp_rt_sigtimedwait01",
     ":ltp_rt_tgsigqueueinfo01",
@@ -1289,6 +1352,7 @@ LTP_TESTS = [
     ":ltp_sched_cfs_prio",
     ":ltp_sched_dl_runtime",
     ":ltp_sched_driver",
+    ":ltp_sched_football",
     ":ltp_sched_get_priority_max01",
     ":ltp_sched_get_priority_max02",
     ":ltp_sched_get_priority_min01",
@@ -1300,6 +1364,8 @@ LTP_TESTS = [
     ":ltp_sched_getparam03",
     ":ltp_sched_getscheduler01",
     ":ltp_sched_getscheduler02",
+    ":ltp_sched_jitter",
+    ":ltp_sched_latency",
     ":ltp_sched_latency_dl",
     ":ltp_sched_latency_rt",
     ":ltp_sched_prio_3_fifo",
@@ -1327,6 +1393,7 @@ LTP_TESTS = [
     ":ltp_sched_tc6",
     ":ltp_sched_yield01",
     ":ltp_sctp_big_chunk",
+    ":ltp_seccomp01",
     ":ltp_select01",
     ":ltp_select02",
     ":ltp_select03",
@@ -1477,7 +1544,16 @@ LTP_TESTS = [
     ":ltp_setxattr02",
     ":ltp_setxattr03",
     ":ltp_sgetmask01",
+    ":ltp_shell_c_child",
+    ":ltp_shell_test01",
+    ":ltp_shell_test02",
+    ":ltp_shell_test03",
+    ":ltp_shell_test04",
+    ":ltp_shell_test05",
+    ":ltp_shell_test06",
     ":ltp_shmat04",
+    ":ltp_shutdown01",
+    ":ltp_shutdown02",
     ":ltp_sigaction01",
     ":ltp_sigaction02",
     ":ltp_sigaltstack01",
@@ -1490,12 +1566,14 @@ LTP_TESTS = [
     ":ltp_signal05",
     ":ltp_signal06",
     ":ltp_signalfd01",
+    ":ltp_signalfd02",
     ":ltp_signalfd4_01",
     ":ltp_signalfd4_02",
     ":ltp_sigpending02",
     ":ltp_sigprocmask01",
     ":ltp_sigrelse01",
     ":ltp_sigsuspend01",
+    ":ltp_sigsuspend02",
     ":ltp_sigtimedwait01",
     ":ltp_sigwait01",
     ":ltp_sigwaitinfo01",
@@ -1530,12 +1608,22 @@ LTP_TESTS = [
     ":ltp_stat02_64",
     ":ltp_stat03",
     ":ltp_stat03_64",
+    ":ltp_stat04",
+    ":ltp_stat04_64",
     ":ltp_statfs01",
     ":ltp_statfs01_64",
     ":ltp_statfs02",
     ":ltp_statfs02_64",
     ":ltp_statfs03",
     ":ltp_statfs03_64",
+    ":ltp_statmount01",
+    ":ltp_statmount02",
+    ":ltp_statmount03",
+    ":ltp_statmount04",
+    ":ltp_statmount05",
+    ":ltp_statmount06",
+    ":ltp_statmount07",
+    ":ltp_statmount08",
     ":ltp_statvfs01",
     ":ltp_statvfs02",
     ":ltp_statx01",
@@ -1589,6 +1677,7 @@ LTP_TESTS = [
     ":ltp_syslog11",
     ":ltp_syslog12",
     ":ltp_tbio",
+    ":ltp_tc-2",
     ":ltp_tcindex01",
     ":ltp_tee01",
     ":ltp_tee02",
@@ -1843,7 +1932,6 @@ LTP_TESTS = [
     ":ltp_testcases_bin_ftp-upload-stress.sh",
     ":ltp_testcases_bin_ftp-upload-stress01-rmt.sh",
     ":ltp_testcases_bin_ftp-upload-stress02-rmt.sh",
-    ":ltp_testcases_bin_ftp01.sh",
     ":ltp_testcases_bin_ftrace_lib.sh",
     ":ltp_testcases_bin_ftrace_regression01.sh",
     ":ltp_testcases_bin_ftrace_regression02.sh",
@@ -1999,9 +2087,11 @@ LTP_TESTS = [
     ":ltp_testcases_bin_nfs07.sh",
     ":ltp_testcases_bin_nfs08.sh",
     ":ltp_testcases_bin_nfs09.sh",
+    ":ltp_testcases_bin_nfs10.sh",
     ":ltp_testcases_bin_nfs_lib.sh",
     ":ltp_testcases_bin_nfslock01.sh",
     ":ltp_testcases_bin_nfsstat01.sh",
+    ":ltp_testcases_bin_nfsstat02.sh",
     ":ltp_testcases_bin_nft01.sh",
     ":ltp_testcases_bin_nm01.sh",
     ":ltp_testcases_bin_ns-echoclient",
@@ -2038,6 +2128,7 @@ LTP_TESTS = [
     ":ltp_testcases_bin_run_freezer.sh",
     ":ltp_testcases_bin_run_memctl_test.sh",
     ":ltp_testcases_bin_run_sched_cliserv.sh",
+    ":ltp_testcases_bin_run_tests.sh",
     ":ltp_testcases_bin_runpwtests01.sh",
     ":ltp_testcases_bin_runpwtests02.sh",
     ":ltp_testcases_bin_runpwtests03.sh",
@@ -2396,6 +2487,8 @@ LTP_TESTS = [
     ":ltp_testcases_bin_tracepath01.sh",
     ":ltp_testcases_bin_traceroute01.sh",
     ":ltp_testcases_bin_tst_ansi_color.sh",
+    ":ltp_testcases_bin_tst_env.sh",
+    ":ltp_testcases_bin_tst_loader.sh",
     ":ltp_testcases_bin_tst_net.sh",
     ":ltp_testcases_bin_tst_net_stress.sh",
     ":ltp_testcases_bin_tst_security.sh",
@@ -2477,48 +2570,12 @@ LTP_TESTS = [
     ":ltp_testcases_bin_zram01.sh",
     ":ltp_testcases_bin_zram02.sh",
     ":ltp_testcases_bin_zram_lib.sh",
-    ":ltp_testcases_data_ar01_file1.in",
-    ":ltp_testcases_data_ar01_file10.in",
-    ":ltp_testcases_data_ar01_file2.in",
-    ":ltp_testcases_data_ar01_file3.in",
-    ":ltp_testcases_data_ar01_file4.in",
-    ":ltp_testcases_data_binfmt_misc02_file.extension",
-    ":ltp_testcases_data_binfmt_misc02_file.magic",
-    ":ltp_testcases_data_file01_in.ar",
-    ":ltp_testcases_data_file01_in.bash",
-    ":ltp_testcases_data_file01_in.c",
-    ":ltp_testcases_data_file01_in.jpg",
-    ":ltp_testcases_data_file01_in.m4",
-    ":ltp_testcases_data_file01_in.mp3",
-    ":ltp_testcases_data_file01_in.pl",
-    ":ltp_testcases_data_file01_in.png",
-    ":ltp_testcases_data_file01_in.py",
-    ":ltp_testcases_data_file01_in.sh",
-    ":ltp_testcases_data_file01_in.src.rpm",
-    ":ltp_testcases_data_file01_in.tar",
-    ":ltp_testcases_data_file01_in.tar.bz2",
-    ":ltp_testcases_data_file01_in.tar.gz",
-    ":ltp_testcases_data_file01_in.txt",
-    ":ltp_testcases_data_file01_in.wav",
-    ":ltp_testcases_data_file01_in.zip",
-    ":ltp_testcases_data_ima_kexec_kexec.policy",
-    ":ltp_testcases_data_ima_keys_keycheck.policy",
-    ":ltp_testcases_data_ima_keys_x509_ima.der",
-    ":ltp_testcases_data_ima_policy_measure.policy",
-    ":ltp_testcases_data_ima_policy_measure.policy-invalid",
-    ":ltp_testcases_data_ima_selinux_selinux.policy",
-    ":ltp_testcases_data_ld01_d1.c",
-    ":ltp_testcases_data_ld01_f1.c",
-    ":ltp_testcases_data_ld01_main.c",
-    ":ltp_testcases_data_ld01_rd1.c",
-    ":ltp_testcases_data_ld01_rf1.c",
-    ":ltp_testcases_data_lvm_runfile.tpl",
-    ":ltp_testcases_data_mc_member_ManyGroups",
-    ":ltp_testcases_data_mc_member_TooManyGroups",
-    ":ltp_testcases_data_rpc01_file.1",
-    ":ltp_testcases_data_rpc01_file.2",
-    ":ltp_testcases_data_unzip01_dir.out",
-    ":ltp_testcases_data_unzip01_test.zip",
+    ":ltp_testpi-1",
+    ":ltp_testpi-2",
+    ":ltp_testpi-3",
+    ":ltp_testpi-4",
+    ":ltp_testpi-5",
+    ":ltp_testpi-7",
     ":ltp_testsf_c",
     ":ltp_testsf_c6",
     ":ltp_testsf_s",
@@ -2618,10 +2675,12 @@ LTP_TESTS = [
     ":ltp_tst_random",
     ":ltp_tst_record_childstatus",
     ":ltp_tst_res",
+    ":ltp_tst_res_",
     ":ltp_tst_res_flags",
     ":ltp_tst_res_hexd",
     ":ltp_tst_resm",
     ":ltp_tst_rod",
+    ":ltp_tst_run_shell",
     ":ltp_tst_safe_fileops",
     ":ltp_tst_safe_macros",
     ":ltp_tst_safe_sscanf",
@@ -2651,6 +2710,7 @@ LTP_TESTS = [
     ":ltp_unlink07",
     ":ltp_unlink08",
     ":ltp_unlink09",
+    ":ltp_unlink10",
     ":ltp_unlinkat01",
     ":ltp_unshare01",
     ":ltp_unshare02",
@@ -2743,7 +2803,7 @@ genrule {
     name: "ltp_config_arm_64",
     out: ["vts_ltp_test_arm_64.xml"],
     tools: ["gen_ltp_config"],
-    cmd: "$(location gen_ltp_config) --arch arm --bitness 64 --low-mem False --hwasan False $(out)",
+    cmd: "$(location gen_ltp_config) --arch arm --bitness 64 $(out)",
 }
 
 genrule {
@@ -2771,7 +2831,7 @@ genrule {
     name: "ltp_config_arm",
     out: ["vts_ltp_test_arm.xml"],
     tools: ["gen_ltp_config"],
-    cmd: "$(location gen_ltp_config) --arch arm --bitness 32 --low-mem False --hwasan False $(out)",
+    cmd: "$(location gen_ltp_config) --arch arm --bitness 32 $(out)",
 }
 
 genrule {
@@ -2785,21 +2845,21 @@ genrule {
     name: "ltp_config_riscv_64",
     out: ["vts_ltp_test_riscv_64.xml"],
     tools: ["gen_ltp_config"],
-    cmd: "$(location gen_ltp_config) --arch riscv --bitness 64 --low-mem False --hwasan False $(out)",
+    cmd: "$(location gen_ltp_config) --arch riscv --bitness 64 $(out)",
 }
 
 genrule {
     name: "ltp_config_x86_64",
     out: ["vts_ltp_test_x86_64.xml"],
     tools: ["gen_ltp_config"],
-    cmd: "$(location gen_ltp_config) --arch x86 --bitness 64 --low-mem False --hwasan False $(out)",
+    cmd: "$(location gen_ltp_config) --arch x86 --bitness 64 $(out)",
 }
 
 genrule {
     name: "ltp_config_x86",
     out: ["vts_ltp_test_x86.xml"],
     tools: ["gen_ltp_config"],
-    cmd: "$(location gen_ltp_config) --arch x86 --bitness 32 --low-mem False --hwasan False $(out)",
+    cmd: "$(location gen_ltp_config) --arch x86 --bitness 32 $(out)",
 }
 
 sh_test {
diff --git a/android/include/bionic-compat.h b/android/include/bionic-compat.h
index ef849b1e8..d91ec004d 100644
--- a/android/include/bionic-compat.h
+++ b/android/include/bionic-compat.h
@@ -53,4 +53,8 @@ static inline int getdtablesize(void)
 static inline void pthread_testcancel(void) { }
 static inline int pthread_cancel(pthread_t thread) { return 0; }
 
+static inline double exp10(double x) {
+    return pow(x, 10);
+}
+
 #endif /* __BIONIC_COMPAT_H */
diff --git a/android/include/config.h b/android/include/config.h
index 31f186b38..5b8407a03 100644
--- a/android/include/config.h
+++ b/android/include/config.h
@@ -360,6 +360,12 @@
 /* Define to 1 if the system has the type `struct af_alg_iv'. */
 #define HAVE_STRUCT_AF_ALG_IV 1
 
+/* Define to 1 if the system has the type `struct cachestat'. */
+#define HAVE_STRUCT_CACHESTAT 1
+
+/* Define to 1 if the system has the type `struct cachestat_range'. */
+#define HAVE_STRUCT_CACHESTAT_RANGE 1
+
 /* Define to 1 if the system has the type `struct clone_args'. */
 #define HAVE_STRUCT_CLONE_ARGS 1
 
@@ -377,6 +383,9 @@
    */
 #define HAVE_STRUCT_FANOTIFY_EVENT_INFO_HEADER 1
 
+/* Define to 1 if the system has the type `struct file_clone_range'. */
+#define HAVE_STRUCT_FILE_CLONE_RANGE 1
+
 /* Define to 1 if the system has the type `struct file_dedupe_range'. */
 #define HAVE_STRUCT_FILE_DEDUPE_RANGE 1
 
@@ -407,6 +416,9 @@
 /* Define to 1 if the system has the type `struct mount_attr'. */
 #define HAVE_STRUCT_MOUNT_ATTR 1
 
+/* Define to 1 if the system has the type `struct mnt_id_req'. */
+#define HAVE_STRUCT_MNT_ID_REQ 1
+
 /* Define to 1 if `aux_head' is a member of `struct perf_event_mmap_page'. */
 #define HAVE_STRUCT_PERF_EVENT_MMAP_PAGE_AUX_HEAD 1
 
@@ -437,6 +449,9 @@
 /* Define to 1 if the system has the type `struct sockaddr_alg'. */
 #define HAVE_STRUCT_SOCKADDR_ALG 1
 
+/* Define to 1 if the system has the type `struct statmount'. */
+#define HAVE_STRUCT_STATMOUNT 1
+
 /* Define to 1 if the system has the type `struct statx'. */
 #define HAVE_STRUCT_STATX 1
 
diff --git a/android/tools/android_build_generator.py b/android/tools/android_build_generator.py
index 140412c32..b6232441d 100755
--- a/android/tools/android_build_generator.py
+++ b/android/tools/android_build_generator.py
@@ -302,8 +302,7 @@ class BuildGenerator(object):
         bp_result.append('    auto_gen_config: false,')
         bp_result.append('}')
 
-        self._prebuilt_bp_result[base_name] = bp_result
-        self._packages.append(module)
+        self._prebuilt_bp_result[module] = bp_result
 
     def HandleParsedRule(self, line, rules):
         '''Prepare parse rules.
@@ -551,7 +550,7 @@ class BuildGenerator(object):
         bp_result.append('    name: "ltp_config_%s",' % arch_string)
         bp_result.append('    out: ["vts_ltp_test_%s.xml"],' % arch_string)
         bp_result.append('    tools: ["gen_ltp_config"],')
-        bp_result.append('    cmd: "$(location gen_ltp_config) --arch %s --bitness %s --low-mem %r --hwasan %r $(out)",' % (arch, bitness, lowmem, hwasan))
+        bp_result.append('    cmd: "$(location gen_ltp_config) --arch %s --bitness %s $(out)",' % (arch, bitness))
         bp_result.append('}')
 
         for config in extra_test_configs:
diff --git a/android/tools/compare_ltp_projects.py b/android/tools/compare_ltp_projects.py
index 0863bdf8a..edba1d255 100755
--- a/android/tools/compare_ltp_projects.py
+++ b/android/tools/compare_ltp_projects.py
@@ -167,12 +167,19 @@ def print_columns(added_test_suites, deleted_test_suites, added_tests, deleted_t
     if not deleted_test_suites:
         width_suites = DEFAULT_WIDTH
     else:
-        width_suites = max([len(x) for x in deleted_test_suites])
+        width_suites = max(len(x) for x in deleted_test_suites)
+
+    if added_test_suites:
+        width_suites = max(width_suites, max(len(x) for x in added_test_suites))
 
     if not deleted_tests:
         width_tests = DEFAULT_WIDTH
     else:
-        width_tests = max([len(x) for x in deleted_tests])
+        width_tests = max(len(x) for x in deleted_tests)
+
+    if added_tests:
+        width_tests = max(width_tests, max(len(x) for x in added_tests))
+
     width = max(width_suites, width_tests);
 
     # total rows we have to print
diff --git a/android/tools/disabled_tests.txt b/android/tools/disabled_tests.txt
index 5603f07b3..4b7b0c879 100644
--- a/android/tools/disabled_tests.txt
+++ b/android/tools/disabled_tests.txt
@@ -19,6 +19,7 @@ shmctl07
 # Test SysV IPC, which is not allowed in Android kernels.
 
 cve-2017-5669
+cachestat02
 hugeshmat01
 hugeshmat02
 hugeshmat03
@@ -630,3 +631,13 @@ kvm_svm04-payload.elf
 # Redefines cacheflush
 # b/277960476
 hugemmap15
+
+# Uses PTHREAD_MUTEX_ROBUST
+testpi-0
+testpi-6
+sbrk_mutex
+
+# TSC unsupported
+async_handler_tsc
+preempt_timing
+rdtsc-latency
diff --git a/build.sh b/build.sh
index 1767cc21b..47a5a7b05 100755
--- a/build.sh
+++ b/build.sh
@@ -138,7 +138,7 @@ install_in_tree()
 install_out_tree()
 {
 	cd $BUILD_DIR
-	make $MAKE_OPTS_OUT_TREE DESTDIR="$prefix" SKIP_IDCHECK=1 install
+	make $MAKE_OPTS_OUT_TREE DESTDIR="$prefix" install
 }
 
 usage()
@@ -173,13 +173,14 @@ cross    cross-compile build (requires set compiler via -c switch)
 native   native build
 
 RUN:
-autotools   run only 'make autotools'
-configure   run only 'configure'
-build       run only 'make'
-test        run only 'make test' (not supported for cross-compile build)
-test-c      run only 'make test-c' (not supported for cross-compile build)
-test-shell  run only 'make test-shell' (not supported for cross-compile build)
-install     run only 'make install'
+autotools          run only 'make autotools'
+configure          run only 'configure'
+build              run only 'make'
+test               run only 'make test' (not supported for cross-compile build)
+test-c             run only 'make test-c' (not supported for cross-compile build)
+test-shell         run only 'make test-shell' (not supported for cross-compile build)
+test-shell-loader  run only 'make test-shell-loader' (not supported for cross-compile build)
+install            run only 'make install'
 
 Default configure options:
 in-tree:    $CONFIGURE_OPTS_IN_TREE
@@ -206,7 +207,7 @@ while getopts "c:hio:p:r:t:" opt; do
 		esac;;
 	p) prefix="$OPTARG";;
 	r) case "$OPTARG" in
-		autotools|configure|build|test|test-c|test-shell|install) run="$OPTARG";;
+		autotools|configure|build|test|test-c|test-shell|test-shell-loader|install) run="$OPTARG";;
 		*) echo "Wrong run type '$OPTARG'" >&2; usage; exit 1;;
 		esac;;
 	t) case "$OPTARG" in
@@ -232,7 +233,7 @@ if [ -z "$run" -o "$run" = "build" ]; then
 	eval build_${tree}_tree
 fi
 
-if [ -z "$run" -o "$run" = "test" -o "$run" = "test-c" -o "$run" = "test-shell" ]; then
+if [ -z "$run" -o "$run" = "test" -o "$run" = "test-c" -o "$run" = "test-shell" -o "$run" = "test-shell-loader" ]; then
 	if [ "$build" = "cross" ]; then
 		echo "cross-compile build, skipping running tests" >&2
 	else
diff --git a/ci/alpine.sh b/ci/alpine.sh
index d2495c389..93acd6267 100755
--- a/ci/alpine.sh
+++ b/ci/alpine.sh
@@ -1,6 +1,6 @@
 #!/bin/sh -eux
 # SPDX-License-Identifier: GPL-2.0-or-later
-# Copyright (c) 2019-2022 Petr Vorel <petr.vorel@gmail.com>
+# Copyright (c) 2019-2024 Petr Vorel <petr.vorel@gmail.com>
 
 apk update
 
@@ -13,9 +13,9 @@ apk add \
 	clang \
 	gcc \
 	git \
+	acl-dev \
 	keyutils-dev \
 	libaio-dev \
-	libacl \
 	libcap-dev \
 	libselinux-dev \
 	libsepol-dev \
@@ -34,7 +34,6 @@ echo "WARNING: remove unsupported tests (until they're fixed)"
 cd $(dirname $0)/..
 rm -rfv \
 	testcases/kernel/syscalls/fmtmsg/fmtmsg01.c \
-	testcases/kernel/syscalls/rt_tgsigqueueinfo/rt_tgsigqueueinfo01.c \
 	testcases/kernel/syscalls/timer_create/timer_create01.c \
 	testcases/kernel/syscalls/timer_create/timer_create03.c
 
diff --git a/ci/debian.minimal.sh b/ci/debian.minimal.sh
index 058419272..1e8dd19af 100755
--- a/ci/debian.minimal.sh
+++ b/ci/debian.minimal.sh
@@ -2,18 +2,4 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 # Copyright (c) 2018-2024 Petr Vorel <pvorel@suse.cz>
 
-apt="apt remove -y"
-
-$apt \
-	asciidoc \
-	asciidoctor \
-	libacl1-dev \
-	libaio-dev \
-	libcap-dev \
-	libkeyutils-dev \
-	libnuma-dev \
-	libselinux1-dev \
-	libsepol-dev \
-	libssl-dev
-
-$apt asciidoc-base ruby-asciidoctor || true
+ACTION="remove-nonessential" $(dirname $0)/debian.sh
diff --git a/ci/debian.sh b/ci/debian.sh
index 63cf242d2..fc1c1b3ec 100755
--- a/ci/debian.sh
+++ b/ci/debian.sh
@@ -11,39 +11,63 @@ apt update
 # workaround for Ubuntu impish asking to interactively configure tzdata
 export DEBIAN_FRONTEND="noninteractive"
 
-apt="apt install -y --no-install-recommends"
-
-$apt \
-	acl-dev \
-	asciidoc \
-	asciidoctor \
-	autoconf \
-	automake \
-	build-essential \
-	debhelper \
-	devscripts \
-	clang \
-	gcc \
-	git \
-	iproute2 \
-	libacl1-dev \
-	libaio-dev \
-	libcap-dev \
-	libc6 \
-	libc6-dev \
-	libjson-perl \
-	libkeyutils-dev \
-	libmnl-dev \
-	libnuma-dev \
-	libselinux1-dev \
-	libsepol-dev \
-	libssl-dev \
-	libtirpc-dev \
-	linux-libc-dev \
-	lsb-release \
+install="apt install -y --no-install-recommends"
+remove="apt remove -y"
+
+# libc6-dev and libtirpc-dev are hard dependencies for gcc toolchain
+# LTP should be compilable without linux-libc-dev, but we expect kernel headers.
+pkg_minimal="
+	autoconf
+	automake
+	build-essential
+	debhelper
+	devscripts
+	clang
+	gcc
+	git
+	iproute2
+	libc6-dev
+	libtirpc-dev
+	linux-libc-dev
+	lsb-release
 	pkg-config
+"
+
+pkg_nonessential="
+	acl-dev
+	asciidoc-base
+	asciidoc-dblatex
+	asciidoctor
+	libacl1-dev
+	libaio-dev
+	libcap-dev
+	libjson-perl
+	libkeyutils-dev
+	libnuma-dev
+	libmnl-dev
+	libselinux1-dev
+	libsepol-dev
+	libssl-dev
+"
+
+# Missing on Ubuntu 18.04 LTS (Bionic Beaver)
+pkg_maybe_nonessential="ruby-asciidoctor-pdf"
 
-$apt ruby-asciidoctor-pdf || true
-$apt asciidoc-dblatex || true
+case "$ACTION" in
+	minimal)
+		echo "=== Installing only minimal dependencies ==="
+		$install $pkg_minimal
+		;;
+	remove-nonessential)
+		echo "=== Make sure devel libraries are removed ==="
+		$remove $pkg_nonessential
+		$remove $pkg_maybe_nonessential || true
+		;;
+	*)
+		echo "=== Installing dependencies ==="
+		$install $pkg_minimal $pkg_nonessential
+		$install $pkg_maybe_nonessential || true
+		;;
+esac
 
 df -hT
diff --git a/configure.ac b/configure.ac
index b1fee16c1..2f71d352c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -34,6 +34,8 @@ m4_ifndef([PKG_CHECK_EXISTS],
 AC_PREFIX_DEFAULT(/opt/ltp)
 
 AC_CHECK_DECLS([IFLA_NET_NS_PID],,,[#include <linux/if_link.h>])
+AC_CHECK_DECLS([LANDLOCK_RULE_PATH_BENEATH],,,[#include <linux/landlock.h>])
+AC_CHECK_DECLS([LANDLOCK_RULE_NET_PORT],,,[#include <linux/landlock.h>])
 AC_CHECK_DECLS([MADV_MERGEABLE],,,[#include <sys/mman.h>])
 AC_CHECK_DECLS([NFTA_CHAIN_ID, NFTA_VERDICT_CHAIN_ID],,,[#include <linux/netfilter/nf_tables.h>])
 AC_CHECK_DECLS([PR_CAPBSET_DROP, PR_CAPBSET_READ],,,[#include <sys/prctl.h>])
@@ -51,7 +53,6 @@ AC_CHECK_HEADERS_ONCE([ \
     linux/cryptouser.h \
     linux/close_range.h \
     linux/dccp.h \
-    linux/fs.h \
     linux/futex.h \
     linux/genetlink.h \
     linux/if_alg.h \
@@ -60,6 +61,7 @@ AC_CHECK_HEADERS_ONCE([ \
     linux/io_uring.h \
     linux/ioprio.h \
     linux/keyctl.h \
+    linux/landlock.h \
     linux/mempolicy.h \
     linux/module.h \
     linux/mount.h \
@@ -91,6 +93,7 @@ AC_SUBST(HAVE_FTS_H, $have_fts)
 AC_CHECK_HEADERS(linux/vm_sockets.h, [], [], [#include <sys/socket.h>])
 
 AC_CHECK_FUNCS_ONCE([ \
+    cachestat \
     clone3 \
     close_range \
     copy_file_range \
@@ -176,6 +179,7 @@ AC_CHECK_TYPES([struct af_alg_iv, struct sockaddr_alg],,,[# include <linux/if_al
 AC_CHECK_TYPES([struct clone_args],,,[#include <sched.h>])
 AC_CHECK_TYPES([struct fanotify_event_info_fid, struct fanotify_event_info_error,
 		struct fanotify_event_info_header, struct fanotify_event_info_pidfd],,,[#include <sys/fanotify.h>])
+AC_CHECK_TYPES([struct file_clone_range],,,[#include <linux/fs.h>])
 AC_CHECK_TYPES([struct file_dedupe_range],,,[#include <linux/fs.h>])
 
 AC_CHECK_TYPES([struct file_handle],,,[
@@ -183,11 +187,17 @@ AC_CHECK_TYPES([struct file_handle],,,[
 #include <fcntl.h>
 ])
 
-AC_CHECK_TYPES([struct fs_quota_statv],,,[#include <xfs/xqm.h>])
+AC_CHECK_TYPES([struct fs_quota_statv],,,[
+#define _GNU_SOURCE
+#include <xfs/xqm.h>
+])
+
 AC_CHECK_TYPES([struct if_nextdqblk],,,[#include <linux/quota.h>])
 AC_CHECK_TYPES([struct iovec],,,[#include <sys/uio.h>])
 AC_CHECK_TYPES([struct ipc64_perm],,,[#include <sys/ipcbuf.h>])
 AC_CHECK_TYPES([struct loop_config],,,[#include <linux/loop.h>])
+AC_CHECK_TYPES([struct landlock_path_beneath_attr],,,[#include <linux/landlock.h>])
+AC_CHECK_TYPES([struct landlock_net_port_attr],,,[#include <linux/landlock.h>])
 
 AC_CHECK_TYPES([struct mmsghdr],,,[
 #define _GNU_SOURCE
@@ -246,6 +256,11 @@ AC_CHECK_TYPES([struct mount_attr],,,[
 #endif
 ])
 
+AC_CHECK_TYPES([struct cachestat_range],,,[#include <sys/mman.h>])
+AC_CHECK_TYPES([struct cachestat],,,[#include <sys/mman.h>])
+AC_CHECK_TYPES([struct mnt_id_req],,,[#include <linux/mount.h>])
+AC_CHECK_TYPES([struct statmount],,,[#include <linux/mount.h>])
+
 # Tools knobs
 
 # Bash
@@ -372,20 +387,18 @@ fi
 # TODO: testcases/realtime requires bash and python.
 AC_ARG_WITH([realtime-testsuite],
   [AS_HELP_STRING([--with-realtime-testsuite],
-    [compile and install the realtime testsuite])],
+    [unused, kept for compatibility reason])],
   [with_realtime_testsuite=$withval],
   [with_realtime_testsuite=no]
 )
 
 if test "x$with_realtime_testsuite" = xyes; then
     AC_SUBST([WITH_REALTIME_TESTSUITE],["yes"])
-    # Run configure on testcases/realtime as well.
-    AC_CONFIG_SUBDIRS([testcases/realtime])
 else
     AC_SUBST([WITH_REALTIME_TESTSUITE],["no"])
 fi
 
-AC_CONFIG_COMMANDS([syscalls.h], [cd ${ac_top_srcdir}/include/lapi/syscalls; ./regen.sh])
+AC_CONFIG_COMMANDS([syscalls.h], [cd ${ac_top_srcdir}/include/lapi/syscalls; ./generate_syscalls.sh ../syscalls.h; cd - >/dev/null])
 
 # custom functions
 # NOTE: don't create custom functions for simple checks, put them into this file
@@ -435,10 +448,12 @@ AC_LINK_IFELSE([AC_LANG_PROGRAM()],
   [
     AC_MSG_RESULT([yes])
     AC_SUBST([WITH_KVM_TESTSUITE],["yes"])
+    have_kvm=yes
   ],
   [
     AC_MSG_RESULT([no])
     AC_SUBST([WITH_KVM_TESTSUITE],["no"])
+    have_kvm=no
   ])
 _AC_LANG_PREFIX[]FLAGS="$ltp_backup_flags"
 LDFLAGS="$ltp_backup_ldflags"
@@ -448,8 +463,9 @@ AC_OUTPUT
 cat << EOF
 
 TESTSUITES
+KVM testsuite: $have_kvm
 open posix testsuite: ${with_open_posix_testsuite:-no}
-realtime testsuite: ${with_realtime_testsuite:-no}
+TI-RPC testsuite: ${with_tirpc:-yes}
 
 LIBRARIES
 keyutils: ${have_keyutils:-yes}
@@ -467,3 +483,7 @@ metadata generator: $with_metadata_generator
 HTML metadata: $with_metadata_html
 PDF metadata: $with_metadata_pdf
 EOF
+
+if test "x$with_realtime_testsuite" = xyes; then
+    AC_MSG_WARN([--with-realtime-testsuite has no effect and is kept for compatibilty reason. It will be removed in the future.])
+fi
diff --git a/doc/conf.py b/doc/conf.py
index 9525ad7bb..c6a84ea58 100644
--- a/doc/conf.py
+++ b/doc/conf.py
@@ -5,9 +5,9 @@
 
 import os
 import re
-import sphinx
 import socket
 import urllib.request
+import sphinx
 
 # -- Project information -----------------------------------------------------
 # https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information
@@ -16,6 +16,7 @@ project = 'Linux Test Project'
 copyright = '2024, Linux Test Project'
 author = 'Linux Test Project'
 release = '1.0'
+ltp_repo = 'https://github.com/linux-test-project/ltp'
 
 # -- General configuration ---------------------------------------------------
 # https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration
@@ -23,13 +24,14 @@ release = '1.0'
 extensions = [
     'linuxdoc.rstKernelDoc',
     'sphinxcontrib.spelling',
+    'sphinx.ext.autosectionlabel',
     'sphinx.ext.extlinks'
 ]
 
 exclude_patterns = ["html*", '_static*']
 extlinks = {
-    'repo': ('https://github.com/linux-test-project/ltp/%s', '%s'),
-    'master': ('https://github.com/linux-test-project/ltp/blob/master/%s', '%s'),
+    'repo': (f'{ltp_repo}/%s', '%s'),
+    'master': (f'{ltp_repo}/blob/master/%s', '%s'),
     'git_man': ('https://git-scm.com/docs/git-%s', 'git %s'),
     # TODO: allow 2nd parameter to show page description instead of plain URL
     'kernel_doc': ('https://docs.kernel.org/%s.html', 'https://docs.kernel.org/%s.html'),
@@ -38,7 +40,7 @@ extlinks = {
 
 spelling_lang = "en_US"
 spelling_warning = True
-spelling_exclude_patterns=['users/stats.rst']
+spelling_exclude_patterns = ['users/stats.rst']
 spelling_word_list_filename = "spelling_wordlist"
 
 # -- Options for HTML output -------------------------------------------------
@@ -60,72 +62,83 @@ def generate_syscalls_stats(_):
     # because in some cases (i.e. io_ring) syscalls are tested, but they are
     # part of a more complex scenario. In the following list, we define syscalls
     # which we know they are 100% tested already.
-    white_list = [
-        'rt_sigpending',
-        'sethostname',
-        'lsetxattr',
-        'inotify_add_watch',
-        'inotify_rm_watch',
-        'newfstatat',
-        'pselect6',
-        'fanotify_init',
-        'fanotify_mark',
-        'prlimit64',
-        'getdents64',
-        'pkey_mprotect',
-        'pkey_alloc',
-        'pkey_free',
-        'io_uring_setup',
-        'io_uring_enter',
-        'io_uring_register',
-        'epoll_pwait2',
-        'quotactl_fd',
-        'pread64',
-        'pwrite64',
-        'fadvise64',
-        'getmsg',
-        'getpmsg',
-        'putmsg',
-        'putpmsg',
-    ]
+    ltp_syscalls_path = "testcases/kernel/syscalls"
+    white_list = {
+        'bpf': f'{ltp_syscalls_path}/bpf',
+        'epoll_pwait2': f'{ltp_syscalls_path}/epoll_pwait',
+        'fadvise64': f'{ltp_syscalls_path}/fadvise',
+        'fanotify_init': f'{ltp_syscalls_path}/fanotify',
+        'fanotify_mark': f'{ltp_syscalls_path}/fanotify',
+        'futex': f'{ltp_syscalls_path}/futex',
+        'getdents64': f'{ltp_syscalls_path}/gettdents',
+        'inotify_add_watch': f'{ltp_syscalls_path}/inotify',
+        'inotify_init': f'{ltp_syscalls_path}/inotify',
+        'inotify_rm_watch': f'{ltp_syscalls_path}/inotify',
+        'io_uring_enter': f'{ltp_syscalls_path}/io_uring',
+        'io_uring_register': f'{ltp_syscalls_path}/io_uring',
+        'io_uring_setup': f'{ltp_syscalls_path}/io_uring',
+        'landlock_add_rule': f'{ltp_syscalls_path}/landlock',
+        'landlock_create_ruleset': f'{ltp_syscalls_path}/landlock',
+        'landlock_restrict_self': f'{ltp_syscalls_path}/landlock',
+        'lsetxattr': f'{ltp_syscalls_path}/lgetxattr',
+        'newfstatat': f'{ltp_syscalls_path}/fstatat',
+        'pkey_alloc': f'{ltp_syscalls_path}/pkeys',
+        'pkey_free': f'{ltp_syscalls_path}/pkeys',
+        'pkey_mprotect': f'{ltp_syscalls_path}/pkeys',
+        'prlimit64': f'{ltp_syscalls_path}/getrlimit',
+        'pread64': f'{ltp_syscalls_path}/pread',
+        'pselect6': f'{ltp_syscalls_path}/pselect',
+        'pwrite64': f'{ltp_syscalls_path}/pwrite',
+        'quotactl_fd': f'{ltp_syscalls_path}/quotactl',
+        'rt_sigpending': f'{ltp_syscalls_path}/sigpending',
+        'semtimedop': f'{ltp_syscalls_path}/ipc/semop',
+        'sethostname': f'{ltp_syscalls_path}/sethostname'
+    }
 
     # populate with not implemented, reserved, unmaintained syscalls defined
     # inside the syscalls file
     black_list = [
-        'reserved177',
-        'reserved193',
-        'rseq',
         '_newselect',
         '_sysctl',
+        'afs_syscall',
+        'cachectl',
         'create_module',
         'get_kernel_syms',
-        'query_module',
+        'getmsg',
+        'getpmsg',
+        'mq_getsetattr',
         'nfsservctl',
-        'afs_syscall',
+        'putmsg',
+        'putpmsg',
+        'query_module',
+        'reserved177',
+        'reserved193',
+        'restart_syscall',
+        'rseq',
         'sysmips',
-        'mq_getsetattr',
         'vserver',
     ]
 
     # fetch syscalls file
+    syscalls_url = "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/arch/mips/kernel/syscalls"
     error = False
     try:
         socket.setdefaulttimeout(3)
         urllib.request.urlretrieve(
-            "https://raw.githubusercontent.com/torvalds/linux/master/arch/mips/kernel/syscalls/syscall_n64.tbl",
-            "syscalls.tbl")
-    except Exception as err:
+            f"{syscalls_url}/syscall_n64.tbl", "syscalls.tbl")
+    except urllib.error.URLError as err:
         error = True
         logger = sphinx.util.logging.getLogger(__name__)
-        msg = "Can't download syscall_n64.tbl from kernel sources"
+        msg = f"Can't download syscall_n64.tbl from kernel sources ({err})"
         logger.warning(msg)
 
-        with open(output, 'w+') as stats:
+        with open(output, 'w+', encoding='utf-8') as stats:
             stats.write(f".. warning::\n\n    {msg}")
 
     if error:
         return
 
+    syscalls_base_url = f"{ltp_repo}/tree/master"
     text = [
         'Syscalls\n',
         '--------\n\n',
@@ -134,18 +147,36 @@ def generate_syscalls_stats(_):
     # collect all available kernel syscalls
     regexp = re.compile(r'\d+\s+n64\s+(?P<syscall>\w+)\s+\w+')
     ker_syscalls = []
-    with open("syscalls.tbl", 'r') as data:
+    with open("syscalls.tbl", 'r', encoding='utf-8') as data:
         for line in data:
             match = regexp.search(line)
-            if match:
-                ker_syscalls.append(match.group('syscall'))
+            if not match:
+                continue
+
+            ker_syscalls.append(match.group('syscall'))
 
     # collect all LTP tested syscalls
-    ltp_syscalls = []
-    for root, _, files in os.walk('../testcases/kernel/syscalls'):
+    name_patterns = [
+        re.compile(r'(?P<name>[a-zA-Z_]+[^_])\d{2}\.c'),
+        re.compile(r'(?P<name>[a-zA-Z_]+[1-9])_\d{2}\.c'),
+    ]
+    ltp_syscalls = {}
+    for dirpath, _, files in os.walk(f'../{ltp_syscalls_path}'):
         for myfile in files:
-            if myfile.endswith('.c'):
-                ltp_syscalls.append(myfile)
+            match = None
+            for pattern in name_patterns:
+                match = pattern.search(myfile)
+                if match:
+                    break
+
+            if not match:
+                continue
+
+            # we need to use relative path from the project root
+            path = dirpath.replace('../', '')
+            name = match.group('name')
+
+            ltp_syscalls[name] = f'{syscalls_base_url}/{path}'
 
     # compare kernel syscalls with LTP tested syscalls
     syscalls = {}
@@ -155,18 +186,19 @@ def generate_syscalls_stats(_):
 
         if kersc not in syscalls:
             if kersc in white_list:
-                syscalls[kersc] = True
+                syscalls[kersc] = f'{syscalls_base_url}/{white_list[kersc]}'
                 continue
 
-            syscalls[kersc] = False
+            syscalls[kersc] = None
 
-        for ltpsc in ltp_syscalls:
-            if ltpsc.startswith(kersc):
-                syscalls[kersc] = True
+        for ltpsc, ltpsp in ltp_syscalls.items():
+            if ltpsc == kersc:
+                syscalls[kersc] = ltpsp
 
     # generate the statistics file
-    tested_syscalls = [key for key, val in syscalls.items() if val]
-    text.append('syscalls which are tested under :master:`testcases/kernel/syscalls`:\n\n')
+    tested_syscalls = [key for key, val in syscalls.items() if val is not None]
+    text.append('syscalls which are tested under '
+                ':master:`testcases/kernel/syscalls`:\n\n')
     text.append(f'* kernel syscalls: {len(ker_syscalls)}\n')
     text.append(f'* tested syscalls: {len(tested_syscalls)}\n\n')
 
@@ -187,41 +219,47 @@ def generate_syscalls_stats(_):
         '    :header-rows: 0\n\n',
     ]
 
-    for sysname, tested in syscalls.items():
-        if tested:
-            if (index_tested % 3) == 0:
-                table_tested.append(f'    * - {sysname}\n')
+    max_columns = 3
+
+    for sysname, path in syscalls.items():
+        if path is not None:
+            if (index_tested % max_columns) == 0:
+                table_tested.append(f'    * - `{sysname} <{path}>`_\n')
             else:
-                table_tested.append(f'      - {sysname}\n')
+                table_tested.append(f'      - `{sysname} <{path}>`_\n')
 
             index_tested += 1
         else:
-            if (index_untest % 3) == 0:
+            if (index_untest % max_columns) == 0:
                 table_untest.append(f'    * - {sysname}\n')
             else:
                 table_untest.append(f'      - {sysname}\n')
 
             index_untest += 1
 
-    left = index_tested % 3
+    left = index_tested % max_columns
     if left > 0:
-        for index in range(0, 3 - left):
-            table_tested.append(f'      -\n')
+        for _ in range(0, max_columns - left):
+            table_tested.append('      -\n')
 
-    left = index_untest % 3
+    left = index_untest % max_columns
     if left > 0:
-        for index in range(0, 3 - left):
-            table_untest.append(f'      -\n')
+        for _ in range(0, max_columns - left):
+            table_untest.append('      -\n')
 
     text.extend(table_tested)
     text.append('\n')
     text.extend(table_untest)
 
     # write the file
-    with open(output, 'w+') as stats:
+    with open(output, 'w+', encoding='utf-8') as stats:
         stats.writelines(text)
 
 
 def setup(app):
+    """
+    Setup the current documentation, using self generated data and graphics
+    customizations.
+    """
     app.add_css_file('custom.css')
     app.connect('builder-inited', generate_syscalls_stats)
diff --git a/doc/developers/api_c_tests.rst b/doc/developers/api_c_tests.rst
index 2a9f3e7b9..46f5d3360 100644
--- a/doc/developers/api_c_tests.rst
+++ b/doc/developers/api_c_tests.rst
@@ -4,36 +4,45 @@
 .. Include headers in this file with:
 .. .. kernel-doc:: ../../include/tst_test.h
 
-Developing using C API
-======================
+LTP C API
+=========
 
 Core LTP API
 ------------
-
 .. kernel-doc:: ../../include/tst_res_flags.h
 .. kernel-doc:: ../../include/tst_test.h
-.. kernel-doc:: ../../include/tst_kernel.h
 
-Option parsing
---------------
+Capabilities
+------------
+.. kernel-doc:: ../../include/tst_capability.h
 
-.. kernel-doc:: ../../include/tst_parse.h
+Checkpoints
+-----------
+
+.. kernel-doc:: ../../include/tst_checkpoint.h
+
+Crypto
+------
+.. kernel-doc:: ../../include/tst_crypto.h
+.. kernel-doc:: ../../include/tst_af_alg.h
 
 Guarded buffers
 ---------------
-
 .. kernel-doc:: ../../include/tst_buffers.h
 
-Checkpoints
------------
+Kernel
+------
+.. kernel-doc:: ../../include/tst_kernel.h
 
-.. kernel-doc:: ../../include/tst_checkpoint.h
+Option parsing
+--------------
 
-Capabilities
-------------
+.. kernel-doc:: ../../include/tst_parse.h
 
-.. kernel-doc:: ../../include/tst_capability.h
+Temporary directory
+-------------------
+.. kernel-doc:: ../../include/tst_tmpdir.h
 
-libltpswap
-----------
+LTP libraries
+-------------
 .. kernel-doc:: ../../include/libswap.h
diff --git a/doc/developers/api_shell_tests.rst b/doc/developers/api_shell_tests.rst
index 2fb2a5068..b6e8560d9 100644
--- a/doc/developers/api_shell_tests.rst
+++ b/doc/developers/api_shell_tests.rst
@@ -1,4 +1,4 @@
 .. SPDX-License-Identifier: GPL-2.0-or-later
 
-Developing using shell API
-==========================
+LTP shell API
+=============
diff --git a/doc/developers/build_system.rst b/doc/developers/build_system.rst
index bf4714dd6..8dca57207 100644
--- a/doc/developers/build_system.rst
+++ b/doc/developers/build_system.rst
@@ -45,11 +45,9 @@ directly tie into applications, e.g. baz.c -> baz):
             --> baz.c
 
 .. code-block:: make
-  :caption: .../foo/Makefile
+    :caption: .../foo/Makefile
 
-    #
-    # Copyright disclaimer goes here -- please use GPLv2.
-    #
+    # SPDX-License-Identifier: GPL-2.0-or-later
 
     top_srcdir		?= ..
 
@@ -57,11 +55,9 @@ directly tie into applications, e.g. baz.c -> baz):
     include $(top_srcdir)/include/mk/generic_trunk_target.mk
 
 .. code-block:: make
-  :caption: .../foo/bar/Makefile
+    :caption: .../foo/bar/Makefile
 
-    #
-    # Copyright disclaimer goes here -- please use GPLv2.
-    #
+    # SPDX-License-Identifier: GPL-2.0-or-later
 
     top_srcdir		?= ../..
 
diff --git a/doc/developers/documentation.rst b/doc/developers/documentation.rst
index 606edc014..0cd3173fa 100644
--- a/doc/developers/documentation.rst
+++ b/doc/developers/documentation.rst
@@ -20,7 +20,7 @@ command as following:
 
     cd doc
 
-    # prepare virtual enviroment
+    # prepare virtual environment
     python3 -m virtualenv .venv
     . .venv/bin/activate
 
diff --git a/doc/developers/ltp_library.rst b/doc/developers/ltp_library.rst
index 723781feb..f76cbb75e 100644
--- a/doc/developers/ltp_library.rst
+++ b/doc/developers/ltp_library.rst
@@ -6,11 +6,14 @@ LTP Library guidelines
 General Rules
 -------------
 
-When we extend library API, we need to apply the same general rules that we use
-when writing tests, plus:
+For extending the LTP library API it applies the same general rules as
+for :doc:`writing tests <../developers/writing_tests>`
+(with strong focus on readability and simplicity), plus:
 
 #. LTP library tests must go inside :master:`lib/newlib_tests` directory
 #. LTP documentation has to be updated according to API changes
+#. Do not add new API functions to the old API. Add new functions to
+   ``tst_.[ch]`` files.
 
 Shell API
 ---------
diff --git a/doc/developers/test_case_tutorial.rst b/doc/developers/test_case_tutorial.rst
index be9a0ea8b..97f385e58 100644
--- a/doc/developers/test_case_tutorial.rst
+++ b/doc/developers/test_case_tutorial.rst
@@ -302,24 +302,27 @@ for a distribution's C library version to be older than its kernel or it may use
 cut down C library in comparison to the GNU one. So we must call ``statx()``
 using the general ``syscall()`` interface.
 
-The LTP contains a library for dealing with the ``syscall`` interface, which is
+LTP contains a library for dealing with the ``syscall`` interface, which is
 located in :master:`include/lapi`. System call numbers are listed against the relevant
 call in the ``*.in`` files (e.g. ``x86_64.in``) which are used to generate
-``syscalls.h``, which is the header you should include. On rare occasions you
-may find the system call number is missing from the ``*.in`` files and will need
-to add it (see :master:`include/lapi/syscalls/strip_syscall.awk`).
-
+``syscalls.h``, the header you should include.
 System call numbers vary between architectures, hence there are multiple
-``*.in`` files for each architecture. You can find the various values for the
-``statx`` system call across a number of ``unistd.h`` files in the Linux kernel.
+``*.in`` files for each architecture.
+
+On rare occasions, you may find that system call number is missing from ``*.in``
+files. In these cases, they will need to be updated using
+:master:`include/lapi/syscalls/generate_arch.sh` script as following:
+
+.. code-block:: bash
+
+    $ include/lapi/syscalls/generate_arch.sh /path/to/Linux/sources
 
-Note that we don't use the system-call-identifier value available in
-``/usr/include/linux/uinstd.h`` because the kernel might be much newer than the
-user land development packages.
+The script will generate all the needed ``*.in`` files accordingly to the Linux
+source code which has been used. Make sure that your Linux source code has
+been updated to the latest version.
 
-For ``statx`` we had to add ``statx 332`` to :master:`include/lapi/syscalls/x86_64.in`,
-``statx 383`` to :master:`include/lapi/syscalls/powerpc.in`, etc.  Now lets look at
-the code, which I will explain in more detail further down.
+Once the new syscalls files have been updated, to rebuild our ``syscalls.h``
+file, please re-run ``./configure`` script.
 
 .. code-block:: c
 
diff --git a/doc/developers/writing_tests.rst b/doc/developers/writing_tests.rst
index 2293800a1..ab633121e 100644
--- a/doc/developers/writing_tests.rst
+++ b/doc/developers/writing_tests.rst
@@ -390,7 +390,7 @@ LTP C And Shell Test API Comparison
       - TST_FS_TYPE
 
     * - .dev_min_size
-      - not applicable
+      - TST_DEVICE_SIZE
 
     * - .format_device
       - TST_FORMAT_DEVICE
diff --git a/doc/maintainers/patch_review.rst b/doc/maintainers/patch_review.rst
index 0561ffd9d..36caaf23b 100644
--- a/doc/maintainers/patch_review.rst
+++ b/doc/maintainers/patch_review.rst
@@ -146,17 +146,17 @@ New test should
 C tests
 ~~~~~~~
 
-* Use the new C API, implementing ``struct tst_test``
+* Use :doc:`../developers/api_c_tests`, implementing :ref:`struct tst_test`
 * Test binaries are added into corresponding ``.gitignore`` files
 * Check coding style with ``make check``
 * Docparse documentation
-* If a test is a regression test it should include ``.tags`` in the
-  ``struct tst_test`` definition
+* If a test is a regression test it should include :ref:`.tags<struct tst_tag>` in the
+  :ref:`struct tst_test` definition
 
 Shell tests
 ~~~~~~~~~~~
 
-* Use new shell API
+* Use :doc:`../developers/api_shell_tests`
 * Check coding style with ``make check``
 * If a test is a regression test it should include related kernel or glibc
   commits as a comment
@@ -164,4 +164,4 @@ Shell tests
 LTP library
 ~~~~~~~~~~~
 
-For patchset touching the LTP library, follow the LTP library guidelines.
+For patchset touching the LTP library, follow :doc:`../developers/ltp_library`.
diff --git a/doc/old/Build-System.asciidoc b/doc/old/Build-System.asciidoc
deleted file mode 100644
index 95ba3b70e..000000000
--- a/doc/old/Build-System.asciidoc
+++ /dev/null
@@ -1,218 +0,0 @@
-Short introduction into LTP build system
-========================================
-
-******************************************************************************
-The following document briefly describes the steps and methodologies used for
-the new and improved Makefile system.
-
-Changelog:
-
- * Initial version: Ngie Cooper <yaneurabeya@gmail.com>
- * Reformated for asciidoc: Cyril Hrubis <chrubis@suse.cz>
-******************************************************************************
-
-The Problem
------------
-
-The problem with the old Makefile system is that it was very difficult to
-maintain and it lacked any sense of formal structure, thus developing for LTP
-and including new targets was more difficult than it should have been
-(maintenance). Furthermore, proper option-based cross-compilation was
-impossible due to the fact that the Makefiles didn't support a prefixing
-system, and the appropriate implicit / static rules hadn't been configured to
-compile into multiple object directories for out-of-tree build support (ease of
-use / functionality). Finally, there wasn't a means to setup dependencies
-between components, such that if a component required libltp.a in order to
-compile, it would go off and compile libltp.a first (ease of use).
-
-These items needed to be fixed to reduce maintenance nightmares for the
-development community contributing to LTP, and the project maintainers.
-
-Design
-------
-
-The system was designed such that including a single GNU Makefile compatible
-set in each new directory component is all that's essentially required to
-build the system.
-
-Say you had a directory like the following (with .c files in them which
-directly tie into applications, e.g. baz.c -> baz):
-
--------------------------------------------------------------------------------
-.../foo/
-     |--> Makefile
-     |
-      --> bar/
-	   |
-	    --> Makefile
-           |
-            --> baz.c
--------------------------------------------------------------------------------
-
-Here's an example of how one would accomplish that:
-
--------------------------------------------------------------------------------
-.../foo/Makefile:
-#
-# Copyright disclaimer goes here -- please use GPLv2.
-#
-
-top_srcdir		?= ..
-
-include $(top_srcdir)/include/mk/env_pre.mk
-include $(top_srcdir)/include/mk/generic_trunk_target.mk
-
-.../foo/bar/Makefile:
-#
-# Copyright disclaimer goes here -- please use GPLv2.
-#
-
-top_srcdir		?= ..
-
-include $(top_srcdir)/include/mk/env_pre.mk
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
--------------------------------------------------------------------------------
-
-Kernel Modules
---------------
-
-Some of the tests need to build kernel modules, happily LTP has
-infrastructure for this.
-
--------------------------------------------------------------------------------
-ifneq ($(KERNELRELEASE),)
-
-obj-m := module01.o
-
-else
-
-top_srcdir	?= ../../../..
-include $(top_srcdir)/include/mk/testcases.mk
-
-REQ_VERSION_MAJOR	:= 2
-REQ_VERSION_PATCH	:= 6
-MAKE_TARGETS		:= test01 test02 module01.ko
-
-include $(top_srcdir)/include/mk/module.mk
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
-
-endif
--------------------------------------------------------------------------------
-
-This is example Makefile that allows you build kernel modules inside of LTP.
-The prerequisites for the build are detected by the 'configure' script.
-
-The 'REQ_VERSION_MAJOR' and 'REQ_VERSION_PATCH' describe minimal kernel
-version for which the build system tries to build the module.
-
-The buildsystem is also forward compatible with changes in Linux kernel
-internal API so that if module fails to build the failure is ignored both on
-build and installation. If the userspace counterpart of the test fails to load
-the module because the file does not exists, the test is skipped.
-
-Note the 'ifneq($(KERNELRELEASE),)', the reason it's there is that the
-Makefile is executed twice, once by LTP build system and once by kernel
-kbuild, see 'Documentation/kbuild/modules.rst' in the Linux kernel tree for
-details on external module build.
-
-Make Rules and Make Variables
------------------------------
-
-When using make rules, avoid writing ad hoc rules like:
-
--------------------------------------------------------------------------------
-[prog]: [dependencies]
-	cc -I../../include $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(LDLIBS) \
-	    -o [prog] [dependencies]
--------------------------------------------------------------------------------
-
-etc. This makes cross-compilation and determinism difficult, if not impossible.
-Besides, implicit rules are your friends and as long as you use `MAKEOPTS=;' in
-the top-level caller (or do $(subst r,$(MAKEOPTS)) to remove -r), the compile
-will complete successfully, assuming all other prerequisites have been
-fulfilled (libraries, headers, etc).
-
--------------------------------------------------------------------------------
-$(AR)			: The library archiver.
-
-$(CC)			: The system C compiler.
-
-$(CPP)			: The system C preprocessor.
-
-$(CFLAGS)		: C compiler flags.
-
-$(CPPFLAGS)		: Preprocessor flags, e.g. -I arguments.
-
-$(DEBUG_CFLAGS)		: Debug flags to pass to $(CC), -g, etc.
-
-$(KVM_LD)		: Special linker for wrapping KVM payload binaries
-			  into linkable object files. Defaults to $(LD).
-			  Change this variable if the KVM Makefile fails
-			  to build files named *-payload.o.
-
-$(LD)			: The system linker (typically $(CC), but not
-			  necessarily).
-
-$(LDFLAGS)		: What to pass in to the linker, including -L arguments
-			  and other ld arguments, apart from -l library
-			  includes (see $(LDLIBS)).
-
-			  This should be done in the $(CC) args passing style
-			  when LD := $(CC), e.g. `-Wl,-foo', as opposed to
-			  `-foo'.
-
-$(LDLIBS)		: Libraries to pass to the linker (e.g. -lltp, etc).
-
-$(LTPLDLIBS)            : LTP internal libraries i.e. these in libs/ directory.
-
-$(OPT_CFLAGS)		: Optimization flags to pass into the C compiler, -O2,
-			  etc. If you specify -O2 or higher, you should also
-			  specify -fno-strict-aliasing, because of gcc
-			  fstrict-aliasing optimization bugs in the tree
-			  optimizer. Search for `fstrict-aliasing optimization
-			  bug' with your favorite search engine.
-
-			  Examples of more recent bugs:
-			  1. tree-optimization/17510
-			  2. tree-optimization/39100
-
-			  Various bugs have occurred in the past due to buggy
-			  logic in the tree-optimization portion of the gcc
-			  compiler, from 3.3.x to 4.4.
-
-$(RANLIB)		: What to run after archiving a library.
-
-$(WCFLAGS)		: Warning flags to pass to $(CC), e.g. -Werror,
-			  -Wall, etc.
--------------------------------------------------------------------------------
-
-Make System Variables
----------------------
-
-A series of variables are used within the make system that direct what actions
-need to be taken. Rather than me listing the variables here, please with their
-intended uses, please refer to the comments contained in
-+.../include/mk/env_pre.mk+.
-
-Guidelines and Recommendations
-------------------------------
-
-Of course, the GNU Make manual is key to understanding the Make system, but
-here are the following sections and chapters I suggest reviewing:
-
-link:http://www.gnu.org/software/make/manual/make.html#Implicit-Rules[Implicit Rules]
-link:http://www.gnu.org/software/make/manual/make.html#Using-Variables[Variables and Expansion]
-link:http://www.gnu.org/software/make/manual/make.html#Origin-Function[Origin Use]
-link:http://www.gnu.org/software/make/manual/make.html#Directory-Search[VPath Use]
-
-Before Committing
------------------
-
-One should rebuild from scratch before committing. Please see INSTALL for more
-details.
-
-Other Errata
-------------
-
-Please see TODO for any issues related to the Makefile infrastructure, and
-build structure / source tree in general.
diff --git a/doc/old/C-Test-API.asciidoc b/doc/old/C-Test-API.asciidoc
index 08a76c403..8a531ccb0 100644
--- a/doc/old/C-Test-API.asciidoc
+++ b/doc/old/C-Test-API.asciidoc
@@ -94,26 +94,32 @@ in range of [0, '.tcnt' - 1].
 
 IMPORTANT: Only one of '.test' and '.test_all' can be set at a time.
 
-Each test has a limit on how long it can run and the limit composes of two
-parts max_runtime and timeout. The max_runtime is a limit for how long can the
-'.test_all' or a set of '.test' functions take and the timeout is static part
-that should cover the duration of test setup and cleanup plus some safety.
+Each test has a limit on how long it can run, composed of two parts: 'runtime'
+and 'timeout'. The 'runtime' is the limit for how long the '.test_all' or a set
+of '.test' main functions can execute. The 'timeout', on the other hand, applies
+to the total time for setup, single test function invocation, cleanup, and some
+additional safety margin. If test without an explicit 'runtime', the 'timeout'
+governs the entire test duration.
+
+The timeout timer is also reset on each subsequent iteration with the test -i
+parameter, variants or .all_filesystems.
 
 Any test that runs for more than a second or two has to make sure to:
 
-- set the runtime either by setting the '.max_runtime' in tst_test or by
-  calling 'tst_set_max_runtime()' in the test setup
+- set the runtime by setting '.runtime' in tst_test and calling 'tst_set_runtime()'
+  to monitor the remaining runtime and ensure the test exits when the runtime
+  limit is reached.
 
-- monitor remaning runtime by regular calls to 'tst_remaining_runtime()' and
-  exit when runtime has been used up
+- set the timeout by setting '.timeout' in tst_test to limit the whole test
+  run that does not use 'tst_remaining_runtime()'.
 
-Test is free to exit before max_runtime has been used up for example when
+Test is free to exit before runtime has been used up for example when
 minimal number of iteration was finished.
 
 The limit is applied to a single call of the '.test_all' function that means
 that for example when '.test_variants' or '.all_filesystems' is set the whole
-test will be limited by 'variants * (max_runtime + timeout)' seconds and the
-test runtime will be likely close to 'variants * max_runtime' seconds.
+test will be limited by 'variants * (runtime + timeout)' seconds and the
+test runtime will be likely close to 'variants * runtime' seconds.
 
 [source,c]
 -------------------------------------------------------------------------------
@@ -401,13 +407,25 @@ WARNING: This function is not thread safe.
 
 [source,c]
 -------------------------------------------------------------------------------
-void tst_set_max_runtime(int max_runtime);
+void tst_set_timeout(int timeout);
 -------------------------------------------------------------------------------
 
-Allows for setting max_runtime per test iteration dynamically in the test 'setup()',
-the timeout is specified in seconds. There are a few testcases whose runtime
-can vary arbitrarily, these can disable timeouts by setting it to
-TST_UNLIMITED_RUNTIME.
+Allows for setting the entire timeout dynamically during the test setup(). The
+timeout is specified in seconds and represents the total time allowed for a single
+test iteration, including setup, runtime, and teardown phases.
+
+[source,c]
+-------------------------------------------------------------------------------
+void tst_set_runtime(int runtime);
+-------------------------------------------------------------------------------
+
+Allows for setting the runtime per test iteration dynamically during the test 'setup()'.
+The runtime is specified in seconds and represents the duration the test is allowed
+to execute its main workload, excluding setup and teardown phases.
+
+This function is useful for tests where the duration of the main workload can be
+controlled or needs to be adjusted dynamically. For example, tests that loop until
+the runtime expires can use this function to define how long they should run.
 
 [source,c]
 -------------------------------------------------------------------------------
@@ -1815,7 +1833,7 @@ fault or EFAULT depending on if the access happened in userspace or the kernel
 respectively. The canary before the buffer will also catch any write access
 outside of the buffer.
 
-The purpose of the patch is to catch off-by-one bugs which happens when
+The purpose of this feature is to catch off-by-one bugs which happens when
 buffers and structures are passed to syscalls. New tests should allocate
 guarded buffers for all data passed to the tested syscall which are passed by
 a pointer.
@@ -2019,9 +2037,8 @@ static struct tst_test test = {
 --------------------------------------------------------------------------------
 
 Above is a minimal template for a test using fuzzy-sync. In a simple case, you
-just need to put the bits you want to race inbetween 'start_race' and
-'end_race'. Meanwhile, any setup you need to do per-iteration goes outside the
-windows.
+just need to put the bits you want to race between 'start_race' and 'end_race'.
+Meanwhile, any setup you need to do per-iteration goes outside the windows.
 
 Fuzzy sync synchronises 'run_a' and 'run_b', which act as barriers, so that
 neither thread can progress until the other has caught up with it. There is
@@ -2339,7 +2356,7 @@ Some tests require at least size(MB) of free RAM or Swap.
 To make sure that test will run only on systems with more than minimal
 required amount of RAM set `.min_mem_avail = N`.
 
-Similarily for tests that require certain amount of free Swap use
+Similarly for tests that require certain amount of free Swap use
 `.min_swap_avail = N`.
 
 1.40 Test tags
diff --git a/doc/old/C-Test-Case-Tutorial.asciidoc b/doc/old/C-Test-Case-Tutorial.asciidoc
deleted file mode 100644
index 6575781ab..000000000
--- a/doc/old/C-Test-Case-Tutorial.asciidoc
+++ /dev/null
@@ -1,1079 +0,0 @@
-C Test Case Tutorial
-====================
-
-NOTE: See also
-      https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines[Test Writing Guidelines],
-      https://github.com/linux-test-project/ltp/wiki/C-Test-API[C Test API].
-
-This is a step-by-step tutorial on writing a simple C LTP test, where topics
-of the LTP and Linux kernel testing will be introduced gradually using a
-concrete example. Most sections will include exercises, some trivial and
-others not so much. If you find an exercise is leading you off at too much of
-a tangent, just leave it for later and move on.
-
-LTP tests can be written in C or Shell script. This tutorial is only for tests
-written in C using the new LTP test API. Note that while we go into some
-detail on using Git, this is not intended as a canonical or complete guide
-for Git.
-
-0. Assumptions & Feedback
--------------------------
-
-We assume the reader is familiar with C, Git and common Unix/Linux/GNU tools
-and has some general knowledge of Operating Systems. Experienced Linux
-developers may find it too verbose while people new to system level Linux
-development may find it overwhelming.
-
-Comments and feedback are welcome, please direct them to
-https://lists.linux.it/listinfo/ltp[the mailing list].
-
-1. Getting Started
-------------------
-
-Git-clone the main LTP repository as described in
-https://github.com/linux-test-project/ltp#quick-guide-to-running-the-tests[the +README.md+]
-and change directory to the checked-out Git repository. We recommend installing the LTP
-and running one of the tests mentioned in the Quick guide (in the +README.md+) to
-ensure you are starting from a good state.
-
-We also recommended cloning the Linux kernel repository for reference, this
-guide will refer to files and directories within the mainline kernel 4.12.
-
-[source,shell]
-------------------------------------------------------------------------------
-$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
-------------------------------------------------------------------------------
-
-There are a number of other repositories which are useful for reference as
-well, including the GNU C library +glibc+ and the alternative C library
-+musl+. Some system calls are partially or even entirely implemented in user
-land as part of the standard C library. So in these cases, the C library is an
-important reference. +glibc+ is the most common C library for Linux, however
-+musl+ is generally easier to understand.
-
-How system calls are implemented varies from one architecture to another and
-across kernel and C library versions. To find out whether a system call is
-actually accessing the kernel (whether it is actually a system call) on any
-given machine you can use the +strace+ utility. This intercepts system calls
-made by an executable and prints them. We will use this later in the tutorial.
-
-2. Choose a System Call to test
--------------------------------
-
-We will use the +statx()+ system call, to provide a concrete example of a
-test. At the time of writing there is no test for this call which was
-introduced in Linux kernel version 4.11.
-
-Linux system call specific tests are primarily contained in
-+testcases/kernel/syscalls+, but you should also +git grep+ the entire LTP
-repository to check for any existing usages of a system call.
-
-One way to find a system call which is not currently tested by the LTP is to
-look at +include/linux/syscalls.h+ in the kernel tree.
-
-Something the LTP excels at is ensuring bug-fixes are back ported to
-maintenance releases, so targeting a specific regression is another
-option.
-
-2.1. Find an untested System call
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Try to find an untested system call which has a manual page (i.e. +man
-syscall+ produces a result). It is a good idea to Git-clone the latest kernel
-man-pages repository.
-
-[source,shell]
-------------------------------------------------------------------------------
-$ git clone git://git.kernel.org/pub/scm/docs/man-pages/man-pages.git
-------------------------------------------------------------------------------
-
-At the time of writing the difference between the latest man-pages release and
-the +HEAD+ of the repository (usually the latest commit) is well over 100
-commits. This represents about 9 weeks of changes. If you are using a stable
-Linux distribution, your man-pages package may well be years old. So as with
-the kernel, it is best to have the Git repository as a reference.
-
-You could also find a system call with untested parameters or use whatever it
-is you are planning to use the LTP for.
-
-3. Create the test skeleton
----------------------------
-
-I shall call my test +statx01.c+, by the time you read this that file name
-will probably be taken, so increment the number in the file name as
-appropriate or replace +statx+ with the system call chosen in exercise 2.1.
-
-[source,shell]
-------------------------------------------------------------------------------
-$ mkdir testcases/kernel/syscalls/statx
-$ cd testcases/kernel/syscalls/statx
-$ echo statx >> .gitignore
-------------------------------------------------------------------------------
-
-Next open +statx01.c+ and add the following boilerplate. Make sure to change
-the copy right notice to your name/company, correct the test name and minimum
-kernel version if necessary. I will explain what the code does below.
-
-[source,c]
-------------------------------------------------------------------------------
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (c) 2017 Instruction Ignorer <"can't"@be.bothered.com>
- */
-
-/*\
- * [Description]
- *
- * All tests should start with a description of _what_ we are testing.
- * Non-trivial explanations of _how_ the code works should also go here.
- * Include relevant links, Git commit hashes and CVE numbers.
- * Inline comments should be avoided.
- */
-
-#include "tst_test.h"
-
-static void run(void)
-{
-	tst_res(TPASS, "Doing hardly anything is easy");
-}
-
-static struct tst_test test = {
-	.test_all = run,
-	.min_kver = "4.11",
-};
-------------------------------------------------------------------------------
-
-Starting with the +#include+ statement we copy in the main LTP test library
-headers. This includes the most common test API functions and the test harness
-initialisation code. It is important to note that this is a completely
-ordinary, independent C program, however +main()+ is missing because it is
-implemented in +tst_test.h+.
-
-We specify what code we want to run as part of the test using the +tst_test
-test+ structure. Various callbacks can be set by the test writer, including
-+test.test_all+, which we have set to +run()+. The test harness will execute
-this callback in a separate process (using +fork()+), forcibly terminating it
-if it does not return after +test.timeout+ seconds.
-
-We have also set +test.min_kver+ to the kernel version where +statx+ was
-introduced. The test library will determine the kernel version at runtime. If
-the version is less than 4.11 then the test harness will return +TCONF+,
-indicating that this test is not suitable for the current system
-configuration.
-
-Occasionally features are back ported to older kernel versions, so +statx+ may
-exist on kernels with a lower version. However we don't need to worry about
-that unless there is evidence of it happening.
-
-As mentioned in the code itself, you should specify what you are testing and
-the expected outcome, even if it is relatively simple. If your program flow is
-necessarily complex and difficult to understand (which is often the case when
-trying to manipulate the kernel into doing something bad), then a detailed
-explanation of how the code works is welcome.
-
-What you should not do, is use inline comments or include the same level of
-explanation which is written here. As a general rule, if something is easy to
-document, then the code should also be easy to read. So don't document the easy
-stuff (except for the basic test specification).
-
-Before continuing we should compile this and check that the basics work. In
-order to compile the test we need a +Makefile+ in the same subdirectory. If
-one already exists, then nothing needs to be done, otherwise add one with the
-following contents.
-
-[source,make]
-------------------------------------------------------------------------------
-# SPDX-License-Identifier: GPL-2.0-or-later
-# Copyright (c) 2019 Linux Test Project
-
-top_srcdir		?= ../../../..
-
-include $(top_srcdir)/include/mk/testcases.mk
-
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
-
-------------------------------------------------------------------------------
-
-This will automatically add +statx01.c+ as a build target producing a
-+statx01+ executable. Unless you have heavily deviated from the tutorial, and
-probably need to change +top_srcdir+, nothing else needs to be done.
-
-Normally, if you were starting a Makefile from scratch, then you would need to
-add +statx01+ as a build target. Specifying that you would like to run some
-program (e.g. +gcc+ or +clang+) to transform +statx01.c+ into +statx01+. Here
-we don't need to do that, but sometimes it is still necessary. For example, if
-we needed to link to the POSIX threading library, then we could add the
-following line after +testcases.mk+.
-
-[source,make]
---------------------------------------------------------------------------------
-statx01: CFLAGS += -pthread
---------------------------------------------------------------------------------
-
-Assuming you are in the test's subdirectory +testcases/kernel/syscalls/statx+,
-do
-
-[source,shell]
---------------------------------------------------------------------------------
-$ make
-$ ./statx01
---------------------------------------------------------------------------------
-
-This should build the test and then run it. However, even though the test is
-in the +syscalls+ directory it won't be automatically ran as part of the
-_syscalls_ test group (remember +./runltp -f syscalls+ from the +README.md+?). For
-this we need to add it to the +runtest+ file. So open +runtest/syscalls+ and add
-the lines starting with a +++.
-
-[source,diff]
---------------------------------------------------------------------------------
- statvfs01 statvfs01
- statvfs02 statvfs02
-
-+statx01 statx01
-+
- stime01 stime01
- stime02 stime02
-
---------------------------------------------------------------------------------
-
-The +runtest+ files are in a two column format. The first column is the test
-name, which is mainly used by test runners for reporting and filtering. It is
-just a single string of text with no spaces. The second column, which can
-contain spaces, is passed to the shell in order to execute the test. Often it
-is just the executable name, but some tests also take arguments (the LTP has a
-library for argument parsing, by the way).
-
-If you haven't done so already, we should add all these new files to Git. It
-is vitally important that you do not make changes to the master branch. If you
-do then pulling changes from upstream becomes a major issue. So first of all
-create a new branch.
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git checkout -b statx01 master
---------------------------------------------------------------------------------
-
-Now we want to add the files we have created or modified, but before doing a
-commit make sure you have configured Git correctly. You need to at least set
-your Name and e-mail address in +~/.gitconfig+, but there are some other
-settings which come in handy too. My relatively simple configuration is similar to
-the below
-
-[source,conf]
---------------------------------------------------------------------------------
-[user]
-	name = Sarah Jane
-	email = sjane@e-mail.address
-[core]
-	editor = emacs
-[sendemail]
-	smtpServer = smtp.server.address
---------------------------------------------------------------------------------
-
-Obviously you need to at least change your name and e-mail. The SMTP server is
-useful for +git send-email+, which we will discuss later. The editor value is
-used for things like writing commits (without the +-m+ option).
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git add -v :/testcases/kernel/syscalls/statx :/runtest/syscalls
-$ git commit -m "statx01: Add new test for statx syscall"
---------------------------------------------------------------------------------
-
-This should add all the new files in the +statx+ directory and the +runtest+
-file. It is good practice to commit early and often. Later on we will do a
-Git-rebase, which allows us to clean up the commit history. So don't worry
-about how presentable your commit log is for now. Also don't hesitate to
-create a new branch when doing the exercises or experimenting. This will allow
-you to diverge from the tutorial and then easily come back again.
-
-I can't emphasize enough that Git makes things easy through branching and that
-things quickly get complicated if you don't do it. However if you do get into
-a mess, Git-reflog and Git-reset, will usually get you out of it. If you also
-mess that up then it may be possible to cherry pick 'dangling' commits out of
-the database into a branch.
-
-3.1 Report TCONF instead of TPASS
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Maybe the test should report "TCONF: Not implemented" instead or perhaps
-+TBROK+. Try changing it do so (see +doc/Test-Writing-Guidelines.asciidoc+ or
-https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines[the
-Wiki]).
-
-3.2 Check Git ignores the executable
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Is your +.gitignore+ correct?
-
-3.3 Run make check
-~~~~~~~~~~~~~~~~~~
-
-Check coding style with `make check`
- (more in https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#21-c-coding-style[C coding style])
-
-3.4 Install the LTP and run the test with runtest
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Run +statx01+ on its own; similar to the +madvise+ tests in the +README.md+.
-
-4. Call the system call
------------------------
-
-At the time of writing +statx+ has no +glibc+ wrapper. It is also fairly common
-for a distribution's C library version to be older than its kernel or it may use a
-cut down C library in comparison to the GNU one. So we must call +statx()+
-using the general +syscall()+ interface.
-
-The LTP contains a library for dealing with the +syscall+ interface, which is
-located in +include/lapi+. System call numbers are listed against the relevant
-call in the +*.in+ files (e.g. +x86_64.in+) which are used to generate
-+syscalls.h+, which is the header you should include. On rare occasions you
-may find the system call number is missing from the +*.in+ files and will need
-to add it (see +include/lapi/syscalls/strip_syscall.awk+).
-
-System call numbers vary between architectures, hence there are multiple
-+*.in+ files for each architecture. You can find the various values for the
-+statx+ system call across a number of +unistd.h+ files in the Linux kernel.
-
-Note that we don't use the system-call-identifier value available in
-+/usr/include/linux/uinstd.h+ because the kernel might be much newer than the
-user land development packages.
-
-For +statx+ we had to add +statx 332+ to +include/lapi/syscalls/x86_64.in+,
-+statx 383+ to +include/lapi/syscalls/powerpc.in+, etc.  Now lets look at
-the code, which I will explain in more detail further down.
-
-[source,c]
---------------------------------------------------------------------------------
-/*
- * Test statx
- *
- * Check if statx exists and what error code it returns when we give it dodgy
- * data.
- */
-
-#include <stdint.h>
-#include "tst_test.h"
-#include "lapi/syscalls.h"
-
-struct statx_timestamp {
-	int64_t	       tv_sec;
-	uint32_t       tv_nsec;
-	int32_t	       __reserved;
-};
-
-struct statx {
-	uint32_t	stx_mask;
-	uint32_t	stx_blksize;
-	uint64_t	stx_attributes;
-	uint32_t	stx_nlink;
-	uint32_t	stx_uid;
-	uint32_t	stx_gid;
-	uint16_t	stx_mode;
-	uint16_t	__spare0[1];
-	uint64_t	stx_ino;
-	uint64_t	stx_size;
-	uint64_t	stx_blocks;
-	uint64_t	stx_attributes_mask;
-	struct statx_timestamp	stx_atime;
-	struct statx_timestamp	stx_btime;
-	struct statx_timestamp	stx_ctime;
-	struct statx_timestamp	stx_mtime;
-	uint32_t	stx_rdev_major;
-	uint32_t	stx_rdev_minor;
-	uint32_t	stx_dev_major;
-	uint32_t	stx_dev_minor;
-	uint64_t	__spare2[14];
-};
-
-static int sys_statx(int dirfd, const char *pathname, int flags,
-		     unsigned int mask, struct statx *statxbuf)
-{
-	return tst_syscall(__NR_statx, dirfd, pathname, flags, mask, statxbuf);
-}
-
-...
---------------------------------------------------------------------------------
-
-So the top part of the code is now boiler plate for calling +statx+. It is
-common for the kernel to be newer than the user land libraries and headers. So
-for new system calls like +statx+, we copy, with a few modifications, the
-relevant definitions into the LTP. This is somewhat like 'vendoring', although
-we are usually just copying headers required for interacting with the Kernel's
-ABI (Application Binary Interface), rather than internalising actual
-functionality.
-
-So from the top we include the +stdint.h+ library which gives us the standard
-+(u)int*_t+ type definitions. We use these in place of the Kernel type
-definitions such as +__u64+ in +linux/types.h+. We then have a couple of
-structure definitions which form part of the +statx+ API. These were copied
-from +include/uapi/linux/stat.h+ in the Kernel tree.
-
-After that, there is a wrapper function, which saves us from writing
-+tst_syscall(__NR_statx, ...+, every time we want to make a call to
-+statx+. This also provides a stub for when +statx+ is eventually integrated
-into the LTP library and also implemented by the C library. At that point we
-can switch to using the C library implementation if available or fallback to
-our own.
-
-The advantage of using the C library implementation is that it will often be
-better supported across multiple architectures. It will also mean we are using
-the system call in the same way most real programs would. Sometimes there are
-advantages to bypassing the C library, but in general it should not be our
-first choice.
-
-The final test should do a check during configuration (i.e. when we run
-+./configure+ before building) which checks if the +statx+ system call and
-associated structures exists. This requires writing an +m4+ file for use with
-+configure.ac+ which is processed during +make autotools+ and produces the
-configure script.
-
-For the time being though we shall just ignore this. All you need to know for
-now is that this is a problem which eventually needs to be dealt with and that
-there is a system in place to handle it.
-
-[source,c]
---------------------------------------------------------------------------------
-...
-
-static void run(void)
-{
-	struct statx statxbuf = { 0 };
-
-	TEST(sys_statx(0, NULL, 0, 0, &statxbuf));
-
-	if (TST_RET == 0)
-		tst_res(TFAIL, "statx thinks it can stat NULL");
-	else if (TST_ERR == EFAULT)
-		tst_res(TPASS, "statx set errno to EFAULT as expected");
-	else
-		tst_res(TFAIL | TERRNO, "statx set errno to some unexpected value");
-}
-
-static struct tst_test test = {
-	.test_all = run,
-	.min_kver = "4.11",
-};
---------------------------------------------------------------------------------
-
-The +TEST+ macro sets +TST_RET+ to the return value of +tst_statx()+ and
-+TST_ERR+ to the value of +errno+ immediately after the functions
-return. This is mainly just for convenience, although it potentially could
-have other uses.
-
-We check whether the return value indicates success and if it doesn't also
-check the value of +errno+. The last call to +tst_res+ includes +TERRNO+,
-which will print the current error number and associated description in
-addition to the message we have provided. Note that it uses the current value
-of +errno+ not +TST_ERR+.
-
-What we should have done in the example above is use +TTERRNO+ which takes the
-value of +TST_ERR+.
-
-If we try to run the test on a kernel where +statx+ does not exist, then
-+tst_syscall+ will cause it to fail gracefully with +TCONF+. Where +TCONF+
-indicates the test is not applicable to our configuration.
-
-The function +tst_syscall+ calls +tst_brk(TCONF,...)+ on failure. +tst_brk+
-causes the test to exit immediately, which prevents any further test code from
-being run.
-
-4.1 What are the differences between tst_brk and tst_res?
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-See +include/tst_test.h+ and the
-https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines[test
-writing guide]. Also what do they have in common?
-
-4.2 What happens if you call tst_res(TINFO, ...) after sys_statx?
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Does the test still function correctly?
-
-4.3 Extend the test to handle other basic error conditions.
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-For example, see if you can trigger +ENOENT+ instead. You shouldn't
-have to create any files, which is discussed in the next section.
-
-5. Setup, Cleanup and files
----------------------------
-
-Some tests require resources to be allocated, or system settings to be
-changed, before the test begins. This 'setup' only has to be done once at the
-beginning and at the end of the test needs to be removed or reverted. The
-'cleanup' also has to be done regardless of whether the test breaks.
-
-Fortunately, like most test libraries, we have setup and cleanup (teardown)
-callbacks. +setup+ is called once before +run+ and +cleanup+ is called once
-afterwards. Note that +run+ itself can be called multiple times by the test
-harness, but that +setup+ and +cleanup+ are only called once.
-
-If either your code, a +SAFE_*+ macro or a library function such as
-+tst_syscall+ call +tst_brk+, then +run+ will exit immediately and the
-+cleanup+ function is then called. Once 'cleanup' is completed, the test
-executable will then exit altogether abandoning any remaining iterations of
-+run+.
-
-For +statx+ we would like to create some files or file like objects which we
-have control over. Deciding where to create the files is easy, we just create
-it in the current working directory and let the LTP test harness handle where
-that should be by setting +.needs_tmpdir = 1+.
-
-[source,c]
---------------------------------------------------------------------------------
-/*
- * Test statx
- *
- * Check if statx exists and what error code it returns when we give it dodgy
- * data. Then stat a file and check it returns success.
- */
-
-#include <stdint.h>
-#include "tst_test.h"
-#include "lapi/syscalls.h"
-#include "lapi/fcntl.h"
-
-#define FNAME "file_to_stat"
-#define STATX_BASIC_STATS 0x000007ffU
-
-/*************** statx structure and wrapper goes here ! ***************/
-
-...
---------------------------------------------------------------------------------
-
-We have added an extra include +lapi/fcntl.h+ which wraps the system header by
-the same name (+#include <fcntl.h>+). This header ensures we have definitions
-for recently added macros such as +AT_FDCWD+ by providing fall backs if the
-system header does not have them. The +lapi+ directory contains a number of
-headers like this.
-
-At some point we may wish to add +lapi/stat.h+ to provide a fall back for
-macros such as +STATX_BASIC_STATS+. However for the time being we have just
-defined it in the test.
-
-[source,c]
---------------------------------------------------------------------------------
-...
-
-static void setup(void)
-{
-	SAFE_TOUCH(FNAME, 0777, NULL);
-}
-
-static void run(void)
-{
-	struct statx statxbuf = { 0 };
-
-	TEST(sys_statx(0, NULL, 0, 0, &statxbuf));
-	if (TST_RET == 0)
-		tst_res(TFAIL, "statx thinks it can stat NULL");
-	else if (TST_ERR == EFAULT)
-		tst_res(TPASS, "statx set errno to EFAULT as expected");
-	else
-		tst_res(TFAIL | TERRNO, "statx set errno to some unexpected value");
-
-	TEST(sys_statx(AT_FDCWD, FNAME, 0, STATX_BASIC_STATS, &statxbuf));
-	if (TST_RET == 0)
-		tst_res(TPASS, "It returned zero so it must have worked!");
-	else
-		tst_res(TFAIL | TERRNO, "statx can not stat a basic file");
-}
-
-static struct tst_test test = {
-	.setup = setup,
-	.test_all = run,
-	.min_kver = "4.11",
-	.needs_tmpdir = 1
-};
---------------------------------------------------------------------------------
-
-The +setup+ callback uses one of the LTP's +SAFE+ functions to create an empty
-file +file_to_stat+. Because we have set +.needs_tmpdir+, we can just create
-this file in the present working directory. We don't need to create a
-+cleanup+ callback yet because the LTP test harness will recursively delete
-the temporary directory and its contents.
-
-The +run+ function can be called multiple times by the test harness, however
-+setup+ and +cleanup+ callbacks will only be ran once.
-
-[WARNING]
-By this point you may have begun to explore the LTP library headers or older
-tests. In which case you will have come across functions from the old API such
-as +tst_brkm+. The old API is being phased out, so you should not use these
-functions.
-
-So far we haven't had to do any clean up. So our example doesn't answer the
-question "what happens if part of the clean up fails?". To answer this we are
-going to modify the test to ask the (highly contrived) question "What happens
-if I create and open a file, then create a hard-link to it, then call open
-again on the hard-link, then 'stat' the file".
-
-[source,c]
---------------------------------------------------------------------------------
-#define LNAME "file_to_stat_link"
-
-...
-
-static void setup(void)
-{
-	fd = SAFE_OPEN(FNAME, O_CREAT, 0777);
-	SAFE_LINK(FNAME, LNAME);
-	lfd = SAFE_OPEN(LNAME, 0);
-}
-
-static void cleanup(void)
-{
-	if (lfd != 0)
-		SAFE_CLOSE(lfd);
-
-	if (fd != 0)
-		SAFE_CLOSE(fd);
-}
-
-static void run(void)
-{
-        ...
-
-	TEST(sys_statx(AT_FDCWD, LNAME, 0, STATX_BASIC_STATS, &statxbuf));
-	if (TST_RET == 0)
-		tst_res(TPASS, "It returned zero so it must have worked!");
-	else
-		tst_res(TFAIL | TERRNO, "statx can not stat a basic file");
-}
-
-static struct tst_test test = {
-	.setup = setup,
-	.cleanup = cleanup,
-	.test_all = run,
-	.tcnt = 2,
-	.min_kver = "4.11",
-	.needs_tmpdir = 1
-};
---------------------------------------------------------------------------------
-
-Because we are now opening a file, we need a +cleanup+ function to close the
-file descriptors. We have to manually close the files to ensure the temporary
-directory is deleted by the test harness (see the
-https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines[test
-writing guidelines] for details).
-
-As a matter of good practice, the file descriptors are closed in reverse
-order. In some circumstances the order in which clean up is performed is
-significant. In that case resources created towards the end of 'setup' are
-dependent on ones near the beginning. So during 'cleanup' we remove the
-dependants before their dependencies.
-
-If, for some reason, the file descriptor +lfd+ became invalid during the test,
-but +fd+ was still open, we do not want +SAFE_CLOSE(lfd)+ to cause the
-+cleanup+ function to exit prematurely. If it did, then +fd+ would remain open
-which would cause problems on some file systems.
-
-Nor do we want to call +cleanup+ recursively. So during 'cleanup' +tst_brk+,
-and consequently the +SAFE+ functions, do not cause the test to exit with
-+TBROK+. Instead they just print an error message with +TWARN+.
-
-It is not entirely necessary to check if the file descriptors have a none zero
-value before attempting to close them. However it avoids a bunch of spurious
-warning messages if we fail to open +file_to_stat+. Test case failures can be
-difficult to interpret at the best of times, so avoid filling the log with
-noise.
-
-5.1 Check statx returns the correct number of hard links
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The field +statx.stx_nlink+ should be equal to 2, right?
-
-5.2 Git-branch
-~~~~~~~~~~~~~~
-
-We are about to make some organisational changes to the test, so now would be
-a good time to branch. Then we can switch between the old and new versions, to
-check the behavior has not been changed by accident.
-
-6. Split the test
------------------
-
-In our current test, we have essentially rolled two different test cases into
-one. Firstly we check if an error is returned when bad arguments are provided
-and secondly we check what happens when we stat an actual file. Quite often it
-makes sense to call +tst_res+ multiple times in a single test case because we
-are checking different properties of the same result, but here we are clearly
-testing two different scenarios.
-
-So we should split the test in two. One obvious way to do this is to create
-+statx02.c+, but that seems like overkill in order to separate two simple test
-cases. So, for now at least, we are going to do it a different way.
-
-[source,c]
---------------------------------------------------------------------------------
-...
-
-static void run_stat_null(void)
-{
-	struct statx statxbuf = { 0 };
-
-	TEST(sys_statx(0, NULL, 0, 0, &statxbuf));
-	if (TST_RET == 0)
-		tst_res(TFAIL, "statx thinks it can stat NULL");
-	else if (TST_ERR == EFAULT)
-		tst_res(TPASS, "statx set errno to EFAULT as expected");
-	else
-		tst_res(TFAIL | TERRNO, "statx set errno to some unexpected value");
-}
-
-static void run_stat_symlink(void)
-{
-	struct statx statxbuf = { 0 };
-
-	TEST(sys_statx(AT_FDCWD, LNAME, 0, STATX_BASIC_STATS, &statxbuf));
-	if (TST_RET == 0)
-		tst_res(TPASS, "It returned zero so it must have worked!");
-	else
-		tst_res(TFAIL | TERRNO, "statx can not stat a basic file");
-}
-
-static void run(unsigned int i)
-{
-	switch(i) {
-	case 0: run_stat_null();
-	case 1: run_stat_symlink();
-	}
-}
-
-static struct tst_test test = {
-	.setup = setup,
-	.cleanup = cleanup,
-	.test = run,
-	.tcnt = 2,
-	.min_kver = "4.11",
-	.needs_tmpdir = 1
-};
---------------------------------------------------------------------------------
-
-So we have used an alternative form of the +test+ or +run+ callback which
-accepts an index. Some tests use this index with an array of parameters and
-expected return values. Others do something similar to the above. The index
-can be used how you want so long as each iteration calls +tst_res+ in a
-meaningful way.
-
-If an iteration fails to return a result (i.e. call +tst_res+ with a value
-other than +TINFO+) then the test harness will report +TBROK+ and print the
-iteration which failed. This prevents a scenario in your test from silently
-failing due to some faulty logic.
-
-6.1 What is wrong with the switch statement?
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Were you paying attention? Also see the output of +make check+.
-
-6.2 Test a feature unique to statx
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-So far we have not tested anything which is unique to +statx+. So, for
-example, you could check stx_btime is correct (possibly only to within a
-margin of error) and that it differs from +stx_mtime+ after writing to the
-file.
-
-Alternatively you could check that +stx_dev_major+ and +stx_dev_minor+ are set
-correctly. Note that the LTP has helper functions for creating devices and
-file systems (see
-https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#2214-testing-with-a-block-device[section
-2.2.14] of the Test Writing Guidelines).
-
-This could be quite a challenging exercise. You may wish to tackle an
-altogether different test scenario instead. If you get stuck just move onto
-the next section and come back later.
-
-7. Submitting the test for review
----------------------------------
-
-Ignoring the fact we should probably create +lapi/stat.h+ along with a bunch
-of fallback logic in the build system. We can now get our test ready for
-submission.
-
-The first thing you need to do before considering submitting your test is run
-+make check-statx01+ or + make check+ in the test's directory. Again, we use
-the kernel style guidelines where possible. Next you should create a new
-branch, this will allow you to reshape your commit history without fear.
-
-After that we have the pleasure of doing an interactive 'rebase' to clean up
-our commit history. In its current form the test only really needs a single
-commit, but if you have been using Git correctly then you should have
-many. The main reason we want to compress it to a single commit, is to make
-the LTP's Git-log readable. It also allows us to write a coherent description
-of the work as a whole in retrospective. Although, when adding a new test, the
-test description in the code will probably make the commit message redundant.
-
-Anyway, as an example, we shall look at my personal commit history from this
-tutorial and 'rebase' it. You should try following along with your own
-repository. First lets look at the commit history since we branched from
-master.
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git log --oneline master..HEAD
-152d39fe7 (HEAD -> tutorial-rebase2, tutorial-rebase) tutorial: Start Submitting patch section
-70f7ce7ce statx01: Stop checkpatch from complaining
-bb0332bd7 tutorial: Fix review problems
-6a87a084a statx01: Fix review problems
-d784b1e85 test-writing-guidelines: Remove old API argument
-c26e1be7a fixup! tutorial
-1e24a5fb5 (me/tutorial-rebase) fixup! tutorial
-568a3f7be fixup! tutorial
-09dd2c829 statx: stage 6
-bfeef7902 statx: stage 5b
-76e03d714 statx: stage 5a
-98f5bc7ac statx: stage 4
-6f8c16438 statx: stage 3 (Add statx01)
-5d93b84d8 Add statx and other syscall numbers
-5ca627b78 tutorial: Add a step-by-step C test tutorial
---------------------------------------------------------------------------------
-
-So we have told git to show all the commits which don't exist in 'master', but
-are in +HEAD+, where +HEAD+ is the top of the current branch. The current
-branch is +tutorial-rebase2+ which I just created. I have already done one
-'rebase' and submitted a patch for review, so my original branch was just called
-+tutorial+.
-
-As usual my commit history is starting to look like a bit of mess! There is
-even a commit in there which should not be in the this branch (Remove old API
-argument), however it can be ignored for now and 'cherry picked' into a new branch
-later.
-
-For my patch I actually need at least two commits, one which contains the
-tutorial text and one which contains the test and associated files. So first
-of all I want to 'squash' (amalgamate) all the commits appended with
-+tutorial:+ into the bottom commit.
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git rebase -i 5ca627b78\^
-...
---------------------------------------------------------------------------------
-
-This begins an interactive 'rebase' where commit 5ca6427b78 is the earliest
-commit we want to edit. The +^+ symbol after the commit hash, specifies the
-commit before this one. The interactive 'rebase' command takes the last commit
-we want to keep unaltered as it's argument (in other words it takes a
-non-inclusive range).
-
-Upon entering a similar command you will be presented with a text file
-similar to the following. The file should be displayed in your text editor of
-choice, if it doesn't, then you may change the editor variable in +.gitconfig+
-which was shown in section 3.
-
-[source,rebase]
---------------------------------------------------------------------------------
-pick 5ca627b78 tutorial: Add a step-by-step C test tutorial
-pick 5d93b84d8 Add statx and other syscall numbers
-pick 6f8c16438 statx: stage 3 (Add statx01)
-pick 98f5bc7ac statx: stage 4
-pick 76e03d714 statx: stage 5a
-pick bfeef7902 statx: stage 5b
-pick 09dd2c829 statx: stage 6
-pick 568a3f7be fixup! tutorial
-pick 1e24a5fb5 fixup! tutorial
-pick c26e1be7a fixup! tutorial
-pick d784b1e85 test-writing-guidelines: Remove old API argument
-pick 6a87a084a statx01: Fix review problems
-pick bb0332bd7 tutorial: Fix review problems
-pick 70f7ce7ce statx01: Stop checkpatch from complaining
-pick 152d39fe7 tutorial: Start Submitting patch section
---------------------------------------------------------------------------------
-
-The last commit from Git-log is shown at the top. The left hand column
-contains the commands we want to run on each commit. +pick+ just means we
-re-apply the commit as-is. We can reorder the lines to apply the commits in a
-different order, but we need to be careful when reordering commits to the same
-file. If your 'rebase' results in a merge conflict, then you have probably
-reordered some commits which contained changes to the same piece of code.
-
-Perhaps a better name for the interactive 'rebase' command would be 'replay'. As
-we pick a point in the commit history, undo all those commits before that
-point, then reapply them one at a time. During the replay we can reorder the
-commits, drop, merge, split and edit them, creating a new history.
-
-The commands I am going to use are +reword+ and +fixup+. The +reword+ command
-allows you to edit a single commit's message. The 'fixup' command 'squashes' a
-commit into the commit above/preceding it, merging the two commits into
-one. The commit which has +fixup+ applied has its commit message deleted. If
-you think a commit might have something useful in its message then you can use
-+squash+ instead.
-
-[source,rebase]
---------------------------------------------------------------------------------
-reword 5ca627b78 tutorial: Add a step-by-step C test tutorial
-fixup 568a3f7be fixup! tutorial
-fixup 1e24a5fb5 fixup! tutorial
-fixup c26e1be7a fixup! tutorial
-fixup bb0332bd7 tutorial: Fix review problems
-fixup 152d39fe7 tutorial: Start Submitting patch section
-fixup 276edecab tutorial: Save changes before rebase
-pick 5d93b84d8 Add statx and other syscall numbers
-pick 6f8c16438 statx: stage 3 (Add statx01)
-pick 98f5bc7ac statx: stage 4
-pick 76e03d714 statx: stage 5a
-pick bfeef7902 statx: stage 5b
-pick 09dd2c829 statx: stage 6
-pick d784b1e85 test-writing-guidelines: Remove old API argument
-pick 6a87a084a statx01: Fix review problems
---------------------------------------------------------------------------------
-
-So all the commits marked with +fixup+ will be re-played by Git immediately
-after 5ca62 at the top. A new commit will then be created with the amalgamated
-changes of all the commits and 5ca62's log message. It turns out that I didn't
-need to reword anything, but there is no harm in checking. It is easy to
-forget the +Signed-off-by:+ line.
-
-I could now do the same for the commits to the +statx+ test, making the commit
-message prefixes consistent. However I am not actually going to submit the
-test (yet).
-
-I won't attempt to show you this, but if you need to do the opposite and split
-apart a commit. It is also possible using Git-rebase by marking a line with
-+edit+. This will pause Git just after replaying the marked commit. You can
-then use a 'soft' Git-reset to bring the selected commit's changes back into
-the 'index' where you are then able to un-stage some parts before
-re-committing.
-
-You can also use +edit+ and +git commit --amend+ together to change a commit
-deep in your history, but without resetting the 'index'. The 'index' contains
-changes which you have staged with +git add+, but not yet committed.
-
-So now that the commit history has been cleaned up, we need to submit a patch
-to the mailing list or make a pull request on GitHub. The mailing list is the
-preferred place to make submissions and is more difficult for most people, so
-I will only cover that method.
-
-Just before we create the patch, we need to check that our changes will still
-apply to the master branch without problems. To do this we can use another
-type of 'rebase' and then try rebuilding and running the test.
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git checkout master
-$ git pull origin
-$ git checkout tutorial-rebase2
-$ git rebase master
---------------------------------------------------------------------------------
-
-Above, I update the master branch and then replay our changes onto it using
-+git rebase master+. You may find that after the rebase there is a merge
-conflict. This will result in something which looks like the following (taken
-from a Makefile conflict which was caused by reordering commits in a 'rebase').
-
-[source,diff]
---------------------------------------------------------------------------------
-<<<<<<< HEAD
-cve-2016-7117:	LDFLAGS += -lpthread
-=======
-cve-2014-0196:	LDFLAGS += -lpthread -lutil -lrt
-cve-2016-7117:	LDFLAGS += -lpthread -lrt
->>>>>>> 4dbfb8e79... Add -lrt
---------------------------------------------------------------------------------
-
-The first line tells us this is the beginning of a conflict. The third line
-separates the two conflicting pieces of content and the last line is the end
-of the conflict. Usually, all you need to do is remove the lines you don't
-want, stage the changes and continue the 'rebase' with +git rebase
---continue+.
-
-In order to create a patch e-mail we use https://git-scm.com/docs/git-format-patch[+git format-patch+],
-we can then send that e-mail using https://git-scm.com/docs/git-send-email[+git send-email+].
-It is also possible to import the patch (+mbox+) file into a number of e-mail programs.
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git format-patch -1 -v 2 -o output --to ltp@lists.linux.it fd3cc8596
-output/v2-0001-tutorial-Add-a-step-by-step-C-test-tutorial.patch
---------------------------------------------------------------------------------
-
-The first argument +-1+ specifies we want one commit from fd3cc8596
-onwards. If we wanted this commit and the one after it we could specify +-2+
-instead.
-
-This is my second patch submission so I have used +-v 2+, which indicates this
-is the second version of a patch set. The +-o+ option specifies the output
-directory (literally called +output+). The +--to+ option adds the +To:+ e-mail
-header, which I have set to the LTP mailing list.
-
-We can then send this patch with the following command sans +--dry-run+.
-
-[source,shell]
---------------------------------------------------------------------------------
-$ git send-email --dry-run output/v2-0001-tutorial-Add-a-step-by-step-C-test-tutorial.patch
---------------------------------------------------------------------------------
-
-Git will ask some questions (which you can ignore) and then tell you what it
-would do if this weren't a dry-run. In order for this to work you have to have
-a valid SMTP server set in +.gitconfig+ and also be signed up to the LTP
-mailing list under the same e-mail address you have configured in Git. You can
-sign up at https://lists.linux.it/listinfo/ltp.
-
-8. Doing code review
---------------------
-
-While waiting for your test to be reviewed, you are invited and encouraged to
-review other contributors' code. This may seem bizarre when you are completely
-new to the project, but there are two important ways in which you can
-contribute here:
-
-A.   Point out logical errors in the code.
-B.   Improve your own understanding
-
-It doesn't matter whether you know the canonical way of writing an LTP test in
-C. An error of logic, when properly explained, is usually indisputable. These
-are the most important errors to find as they always result in false test
-results. Once someone points out such an error it is usually obvious to
-everyone that it is a bug and needs to be fixed.
-
-Obviously testing the patch is one way of finding errors. You can apply
-patches using +git am+. Then it is just a case of compiling and running the
-tests.
-
-Finally, reading and attempting to comment on other peoples patches, gives
-you a better understanding of the reviewers perspective. This is better for
-the project and for you.
-
-Style and organisational issues are best left to after you have found logical
-errors.
-
-9. Final notes
---------------
-
-Hopefully you can now grasp the structure of an LTP test and have some idea of
-what is available in the LTP test library. There are a vast number of library
-functions available (mainly located in include and lib), some of which are
-documented in the test writing guidelines and many of which are not.
-
-We have only scratched the surface of the immense technical complexity of
-systems programming across multiple Kernel and C lib versions as well as
-different hardware architectures. The important thing to take away from this
-is that you have to be conscientious of what will happen on systems different
-from yours. The LTP has a huge and varied user base, so situations you may
-think are unlikely can and do happen to somebody.
-
-Of course you don't want to spend time allowing for situations which may never
-arise either, so you have to do your research and think about each situation
-critically. The more systems you can test on before submitting your changes,
-the better, although we understand not everyone has access to a lab.
-
-One important topic which has not been covered by this tutorial, is
-multi-process or multi-threaded testing. The LTP library functions work inside
-child processes and threads, but their semantics change slightly. There are
-also various helper functions for synchronising and forking processes. For
-more information see
-https://github.com/linux-test-project/ltp/wiki/C-Test-API[C Test API],
-in particular sections
-https://github.com/linux-test-project/ltp/wiki/C-Test-API#17-fork-ing[1.7 Fork()-ing] to
-https://github.com/linux-test-project/ltp/wiki/C-Test-API#110-signals-and-signal-handlers[1.10 Signals and signal handlers] and
-https://github.com/linux-test-project/ltp/wiki/C-Test-API#114-thread-safety-in-the-ltp-library[1.14 Thread-safety in the LTP library].
-
-When it comes time to submit a test, the preferred way to do it is on the
-mailing list although you can also use GitHub. The LTP follows similar rules
-to the kernel for formatting and submitting patches. Generally speaking the
-review cycle is easier for small patches, so try to make small changes or
-additions where possible.
diff --git a/doc/old/Contact-Info.asciidoc b/doc/old/Contact-Info.asciidoc
deleted file mode 100644
index 34d6fb770..000000000
--- a/doc/old/Contact-Info.asciidoc
+++ /dev/null
@@ -1,28 +0,0 @@
-Contact information
-===================
-
-Mailing lists
--------------
-
-Current list
-~~~~~~~~~~~~
-
-- https://lists.linux.it/listinfo/ltp
-
-3rd-party mailing list archive sites
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-- *https://lore.kernel.org/ltp/*
-- http://marc.info/?l=ltp-list
-- http://www.mail-archive.com/ltp-list@lists.sourceforge.net/
-
-Old mailing list archive
-~~~~~~~~~~~~~~~~~~~~~~~~
-Archive of the old list, before we got new mailing list on linux.it.
-
-- http://sourceforge.net/mail/?group_id=3382
-
-IRC
----
-
-- IRC channel: irc.freenode.net #ltp
\ No newline at end of file
diff --git a/doc/old/LTP-Library-API-Writing-Guidelines.asciidoc b/doc/old/LTP-Library-API-Writing-Guidelines.asciidoc
deleted file mode 100644
index 3b9a905f3..000000000
--- a/doc/old/LTP-Library-API-Writing-Guidelines.asciidoc
+++ /dev/null
@@ -1,84 +0,0 @@
-LTP Library API Writing Guidelines
-==================================
-
-NOTE: See also
-      https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines[Test Writing Guidelines],
-      https://github.com/linux-test-project/ltp/wiki/C-Test-API[C Test API],
-      https://github.com/linux-test-project/ltp/wiki/Shell-Test-API[Shell Test API].
-
-1. General Rules
-----------------
-
-For extending library API it applies the same general rules as for writing tests,
-(see https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines[Test Writing Guidelines],
-offline: 'doc/Test-Writing-Guidelines.asciidoc'),
-with strong focus on readability and simplicity.
-
-Library tests are in 'lib/newlib_tests' directory.
-
-Don't forget to update docs when you change the API.
-
-Environment variables should be listed in
-https://github.com/linux-test-project/ltp/wiki/User-Guidelines[LTP User Guidelines]
-and in help output (`-h`) for both C and shell API.
-
-2. C API
---------
-
-2.1 LTP-001: Sources have tst_ prefix
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-API source code is in headers in 'include/{empty}*.h', 'include/lapi/{empty}*.h'
-(backward compatibility for old kernel and libc) and C sources in 'lib/{empty}*.c'.
-Files have `tst_` prefix.
-
-2.2 LTP-002: TST_RET and TST_ERR are not modified
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The test author is guaranteed that the test API will not modify these
-variables. This prevents silent errors where the return value and
-errno are overwritten before the test has chance to check them.
-
-The macros which are clearly intended to update these variables. That
-is `TEST` and those in 'tst_test_macros.h'. Are of course allowed to
-update these variables.
-
-2.3 LTP-003: Externally visible library symbols have the tst_ prefix
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Functions, types and variables in the public test API should have the
-tst_ prefix. With some exceptions for symbols already prefixed with
-`safe_` or `ltp_`.
-
-Static (private) symbols should not have the prefix.
-
-
-3. Shell API
-------------
-
-API source code is in 'tst_test.sh', 'tst_security.sh' and 'tst_net.sh'
-(all in 'testcases/lib' directory).
-
-Changes in the shell API should not introduce uncommon dependencies
-(use basic commands installed everywhere by default).
-
-3.1 Shell libraries
-~~~~~~~~~~~~~~~~~~~
-
-Aside from shell API libraries in 'testcases/lib', it's worth putting
-common code for a group of tests into a shell library. The filename
-should end with '_lib.sh' and the library should load 'tst_test.sh' or
-'tst_net.sh'.
-
-Shell libraries should have conditional expansion for 'TST_SETUP' or 'TST_CLEANUP',
-to avoid surprises when test specific setup/cleanup function is redefined by
-shell library.
-
-[source,sh]
--------------------------------------------------------------------------------
-# ipsec_lib.sh
-# SPDX-License-Identifier: GPL-2.0-or-later
-TST_SETUP="${TST_SETUP:-ipsec_lib_setup}"
-...
-. tst_test.sh
--------------------------------------------------------------------------------
diff --git a/doc/old/LTP-Release-Procedure.asciidoc b/doc/old/LTP-Release-Procedure.asciidoc
deleted file mode 100644
index c2336e4a4..000000000
--- a/doc/old/LTP-Release-Procedure.asciidoc
+++ /dev/null
@@ -1,171 +0,0 @@
-LTP Release Procedure
-=====================
-
-1. Release preparations
------------------------
-
-The release procedure generally takes a few weeks. In the first week or two,
-patches that should go into the release are reviewed and possibly merged. These
-patches are either fixes or patches pointed out by the community.
-
-Patch review, when finished, is followed by a git freeze, which is a period
-where only fixes are pushed to the git. During that period community is
-expected to run a LTP pre-release tests, reports problems, and/or send fixes to
-the mailing list. In this period we are especially making sure that there are
-no regressions in the test results on a wide range of distributions and
-architectures.
-
-Once the stabilization period has ended the time has finally come to proceed
-with the release.
-
-2. Prepare the release notes
-----------------------------
-
-Part of the preparation is also to write the release notes, which are then
-added to the GitHub release and also sent as announcement to various mailing
-lists (see below).
-
-Have a look at https://lore.kernel.org/ltp/ZGNiQ1sMGvPU_ETp@yuki/ to get the
-idea how it should look.
-
-3. Tag the git and push changes to github
------------------------------------------
-
-[source,sh]
---------------------------------------------------------------------
-cd ltp
-echo YYYYMMDD > VERSION
-git commit -S -s -m 'LTP YYYYMMDD' VERSION
-git tag -s -a YYYYMMDD -m 'LTP YYYYMMDD'
-git push origin master:master
-git push origin YYYYMMDD
---------------------------------------------------------------------
-
-NOTE: The string `YYYYMMDD` should be substituted to the current date.
-
-NOTE: You can use https://github.com/linux-test-project/ltp/blob/master/tools/tag-release.sh[`tools/tag-release.sh`]
-      script to have the above automated.
-      It allows you to verify the tag before pushing it and does other checks.
-
-[source,sh]
---------------------------------------------------------------------
-$ ./tools/tag-release.sh
-===== git push =====
-new tag: 'YYYYMMDD', previous tag: '20230127'
-tag YYYYMMDD
-Tagger: Person-who-released LTP <foo@example.com>
-Date:   ...
-
-LTP YYYYMMDD
------BEGIN PGP SIGNATURE-----
-...
------END PGP SIGNATURE-----
-
-commit 3ebc2dfa85c2445bb68d8c0d66e33c4da1e1b3a7
-gpg:                using RSA key ...
-...
-Primary key fingerprint: ...
-Author: Person-who-released LTP <foo@example.com>
-Date:   ...
-
-    LTP YYYYMMDD
-
-    Signed-off-by: Person-who-released LTP <foo@example.com>
-
-diff --git a/VERSION b/VERSION
-index af4c41fec..ae488c0e7 100644
---- a/VERSION
-+++ b/VERSION
-@@ -1 +1 @@
--20230127
-+YYYYMMDD
-
-Please check tag and signature. Proceed? [N/y]: y
-Pushing changes to upstream git. Proceed? [N/y]: y
-...
-To github.com:linux-test-project/ltp.git
- * [new tag]             YYYYMMDD -> YYYYMMDD
---------------------------------------------------------------------
-
-4. Prepare tarballs and metadata documentation
-----------------------------------------------
-
-[source,sh]
---------------------------------------------------------------------
-# clone already clonned git repository to new folder
-cd ..
-git clone ltp ltp-full-YYYYMMDD
-cd ltp-full-YYYYMMDD
-
-# update all submodules
-git submodule update --init
-
-# Generate configure script
-make autotools
-
-# Generate tarballs
-cd ..
-tar -cjf ltp-full-YYYYMMDD.tar.bz2 ltp-full-YYYYMMDD --exclude .git
-tar -cJf ltp-full-YYYYMMDD.tar.xz ltp-full-YYYYMMDD --exclude .git
-
-# Generate checksums
-md5 ltp-full-YYYYMMDD.tar.xz > ltp-full-YYYYMMDD.tar.xz.md5
-sha1 ltp-full-YYYYMMDD.tar.xz > ltp-full-YYYYMMDD.tar.xz.sha1
-sha256sum ltp-full-YYYYMMDD.tar.xz > ltp-full-YYYYMMDD.tar.xz.sha256
-
-# Generate metadata documentation
-./configure --with-metadata-generator=asciidoctor
-make -C metadata
-cp -v docparse/metadata.html ../metadata.YYYYMMDD.html
---------------------------------------------------------------------
-
-NOTE: You can use https://github.com/linux-test-project/ltp/blob/master/tools/create-tarballs-metadata.sh[`tools/create-tarballs-metadata.sh`]
-	  script to have the above automated. All generated files are placed in
-	  ltp-release-YYYYMMDD directory.
-
-[source,sh]
---------------------------------------------------------------------
-$ ./tools/create-tarballs-metadata.sh
-===== git clone =====
-Cloning into 'ltp-full-YYYYMMDD'...
-done.
-===== Update submodules =====
-Submodule 'tools/kirk' (https://github.com/linux-test-project/kirk.git) registered for path 'tools/kirk'
-...
-===== Generate configure script =====
-sed -n '1{s:LTP-:m4_define([LTP_VERSION],[:;s:$:]):;p;q}' VERSION > m4/ltp-version.m4
-aclocal -I m4
-...
-===== Generate tarballs =====
-===== Generate checksums =====
-===== Generate metadata documentation =====
-checking for a BSD-compatible install... /usr/bin/install -c
-...
-'docparse/metadata.html' -> '/home/foo/ltp-release-YYYYMMDD/metadata.YYYYMMDD.html'
-Generated files are in '/home/foo/ltp-release-YYYYMMDD', upload them to github
---------------------------------------------------------------------
-
-5. Upload the generated files to GitHub
----------------------------------------
-
-Click on https://github.com/linux-test-project/ltp/releases['Releases'], then
-switch to https://github.com/linux-test-project/ltp/tags['Tags'], then click on
-'Add release notes'.  There should be 'Attach binaries ...' link at the
-bottom of the page.
-
-Don't forget to upload checksums for the tarballs and metadata documentation as well.
-
-5. Send release announcement
-----------------------------
-
-The announcement is sent to:
-
-* ltp at lists.linux.it
-* linux-kernel at vger.kernel.org
-* libc-alpha at sourceware.org
-
-CCed to:
-
-* lwn at lwn.net
-* akpm at linux-foundation.org
-* torvalds at linux-foundation.org
diff --git a/doc/old/Maintainer-Patch-Review-Checklist.asciidoc b/doc/old/Maintainer-Patch-Review-Checklist.asciidoc
deleted file mode 100644
index 8977b7585..000000000
--- a/doc/old/Maintainer-Patch-Review-Checklist.asciidoc
+++ /dev/null
@@ -1,139 +0,0 @@
-# Patch Review
-
-Anyone can and should review patches. It's the only way to get good at
-patch review and for the project to scale.
-
-## Goals of patch review
-
-1. Prevent false positive test results
-2. Prevent false negative test results
-3. Keep the code as simple as possible, but no simpler
-
-## How to find clear errors
-
-A clear error is one where there is unlikely to be any argument if you
-provide evidence of it. Evidence being an error trace or logical proof
-that an error will occur in a common situation.
-
-The following are examples and may not be appropriate for all tests.
-
-* Merge the patch locally. It should apply cleanly to master.
-* Compile the patch with default and non-default configurations.
-  - Use sanitizers e.g. undefined behaviour, address.
-  - Compile on non-x86
-  - Compile on x86 with -m32
-  - Compile testing patches with GitHub Actions in LTP repo fork can cover
-    various distros/architectures
-* Use `make check`
-* Run effected tests in a VM
-  - Use single vCPU
-  - Use many vCPUs and enable NUMA
-  - Restrict RAM to < 1GB.
-* Run effected tests on an embedded device
-* Run effected tests on non-x86 machine in general
-* Run reproducers on a kernel where the bug is present
-* Run tests with "-i0" and "-i2"
-* Compare usage of system calls with man page descriptions
-* Compare usage of system calls with kernel code
-* Double check commit message
-* Search the LTP library for existing helper functions
-* Check doc formatting, i.e. make doc && chromium docparse/metadata.html
-
-## How to find subtle errors
-
-A subtle error is one where you can expect some argument because you
-do not have clear evidence of an error. It is best to state these as
-questions and not make assertions if possible.
-
-Although if it is a matter of style or "taste" then senior maintainers
-can assert what is correct to avoid bike shedding.
-
-* Ask what happens if there is an error, could it be debugged just
-  with the test output?
-* Are we testing undefined behavior?
-  - Could future kernel behaviour change without "breaking userland"?
-  - Does the kernel behave differently depending on hardware?
-  - Does it behave differently depending on kernel configuration?
-  - Does it behave differently depending on the compiler?
-  - Would it behave differently if the order of checks on syscall parameters
-    changed in the kernel?
-* Will it scale to tiny and huge systems?
-  - What happens if there are 100+ CPUs?
-  - What happens if each CPU core is very slow?
-  - What happens if there are 2TB of RAM?
-* Are we repeating a pattern that can be turned into a library function?
-* Is a single test trying to do too much?
-* Could multiple similar tests be merged?
-* Race conditions
-  - What happens if a process gets preempted?
-  - Could checkpoints or fuzzsync by used instead?
-  - Note, usually you can insert a sleep to prove a race condition
-    exists however finding them is hard
-* Is there a simpler way to achieve the same kernel coverage?
-
-## How to get patches merged
-
-Once you think a patch is good enough you should add your Reviewed-by
-and/or Tested-by tags. This means you will get some credit for getting
-the patch merged. Also some blame if there are problems.
-
-If you ran the test you can add the Tested-by tag. If you read the
-code or used static analysis tools on it, you can add the Reviewed-by
-tag.
-
-In addition you can expect others to review your patches and add their
-tags. This will speed up the process of getting your patches merged.
-
-## Maintainers Checklist
-
-Patchset should be tested locally and ideally also in maintainer's fork in
-GitHub Actions on GitHub.
-
-NOTE: GitHub Actions do only build testing, passing the CI means only that
-      the test compiles fine on variety of different distributions and releases.
-
-The test should be executed at least once locally and should PASS as well.
-
-Commit messages should have
-
-* Author's `Signed-off-by` tag
-* Committer's `Reviewed-by` or `Signed-off-by` tag
-* Check also mailing lists for other reviewers / testers tags, notes and failure reports
-* `Fixes: hash` if it fixes particular LTP commit
-* `Fixes: #N` if it fixes github issue number N, so it's automatically closed
-* LTP WIKI (git: https://github.com/linux-test-project/ltp.wiki.git) should be kept up to date.
-
-After patch is accepted or rejected, set correct state and archive in
-https://patchwork.ozlabs.org/project/ltp/list/[LTP patchwork instance].
-
-## New tests
-New test should
-
-* Have a record in runtest file
-* Test should work fine with more than one iteration
-  (e.g. run with `-i 100`)
-* Run with `-i 0` to check that setup and cleanup are coded properly (no test is being run)
-* Have a brief description
-* License: the default license for new tests is GPL v2 or later, use
-  GPL-2.0-or-later; the licence for test (e.g. GPL-2.0) should not change
-  unless test is completely rewritten
-* Old copyrights should be kept unless test is completely rewritten
-
-### C tests
-* Use new https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#22-writing-a-test-in-c[C API]
-* Test binaries are added into corresponding `.gitignore` files
-* Check coding style with `make check`
-  (more in https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#21-c-coding-style[C coding style])
-* Docparse documentation
-* If a test is a regression test it should include tags
-  (more in https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#2238-test-tags[Test tags])
-
-### Shell tests
-* Use new https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#23-writing-a-testcase-in-shell[shell API]
-* Check coding style with `make check`
-  (more in https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines#132-shell-coding-style[Shell coding style])
-* If a test is a regression test it should include related kernel or glibc commits as a comment
-
-## LTP library
-For patchset touching library please check also
-https://github.com/linux-test-project/ltp/wiki/LTP-Library-API-Writing-Guidelines[LTP Library API Writing Guidelines].
diff --git a/doc/old/Makefile b/doc/old/Makefile
deleted file mode 100644
index f7e4dd021..000000000
--- a/doc/old/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
-# Copyright (C) 2009, Cisco Systems Inc.
-# Ngie Cooper, July 2009
-
-top_srcdir			?= ..
-
-include $(top_srcdir)/include/mk/env_pre.mk
-
-RECURSIVE_TARGETS	:= install
-
-include $(top_srcdir)/include/mk/generic_trunk_target.mk
diff --git a/doc/old/Shell-Test-API.asciidoc b/doc/old/Shell-Test-API.asciidoc
index 4cf630dab..c38fb0698 100644
--- a/doc/old/Shell-Test-API.asciidoc
+++ b/doc/old/Shell-Test-API.asciidoc
@@ -188,7 +188,7 @@ space as default value is used. Of course, it's possible to use separate functio
 1.2 Library environment variables and functions for shell
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-Similarily to the C library various checks and preparations can be requested
+Similarly to the C library various checks and preparations can be requested
 simply by setting right '$TST_FOO'.
 
 [options="header"]
diff --git a/doc/old/Supported-kernel,-libc,-toolchain-versions.asciidoc b/doc/old/Supported-kernel,-libc,-toolchain-versions.asciidoc
deleted file mode 100644
index 6b53d4da0..000000000
--- a/doc/old/Supported-kernel,-libc,-toolchain-versions.asciidoc
+++ /dev/null
@@ -1,77 +0,0 @@
-Supported kernel, libc, toolchain versions
-==========================================
-
-1. Build testing with GitHub Actions
-------------------------------------
-
-We test master branch in https://github.com/linux-test-project/ltp/actions[GitHub Actions]
-to ensure LTP builds on various distributions including old, current and bleeding edge.
-We test both gcc and clang toolchains, various architectures with cross-compilation.
-For list of tested distros see
-https://github.com/linux-test-project/ltp/blob/master/.github/workflows/ci-docker-build.yml[.github/workflows/ci-docker-build.yml].
-
-
-NOTE: GitHub Actions does only build testing, passing the CI means only that
-      the test compiles fine on variety of different distributions and releases.
-      GitHub Actions also uses the latest distribution image of a particular release.
-
-1.1 Oldest tested distributions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-[align="center",options="header"]
-|=================================================================
-| Distro                       | kernel  | glibc | gcc    | clang
-| openSUSE Leap 42.2           | 4.4     | 2.22  | 4.8.5  | -
-| Ubuntu 18.04 LTS bionic      | 4.15    | 2.27  | 7.3.0  | -
-| Debian 11 (bullseye)         | 5.10    | 2.31  | 10.2.1 | 11.0.1
-|=================================================================
-
-Older distributions are not officially supported, which means that it
-may or may not work. It all depends on your luck. It should be possible
-to compile latest LTP even on slightly older distributions than we
-support with a few manual tweaks, e.g. disabling manually tests for
-newly added syscalls, etc. Trivial fixes/workarounds may be accepted,
-but users are encouraged to move to a newer distro.
-
-If latest LTP cannot be compiled even with some amount of workarounds,
-you may result to older LTP releases, however these are _not_ supported
-in any way. Also if you are trying to run LTP on more than 10 years old
-distribution you may as well reconsider you life choices.
-
-1.2 Tested architectures
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-[align="center",options="header"]
-|==================================
-| arch          | build
-| x86_64        | native
-| x86 emulation | native
-| aarch64       | cross compilation
-| ppc64le       | cross compilation
-| s390x         | cross compilation
-|==================================
-
-1.3 Minimal supported kernel version
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Minimal supported kernel version is 4.4.
-
-1.4 Supported libc
-~~~~~~~~~~~~~~~~~~
-
-[align="center",options="header"]
-|==================================
-| Libc      | Note
-| https://www.gnu.org/software/libc/[GNU C Library (glibc)] | Targeted libc, tested both compilation and actual test results.
-| https://uclibc-ng.org/[uClibc-ng] | Although not being tested it should work as well as it attempt to maintain a glibc compatible interface.
-| https://www.uclibc.org/[uClibc]   | Older https://www.uclibc.org/[uClibc] might have problems.
-| https://musl.libc.org/[musl] | Not yet fully supported (see
-                                 https://github.com/linux-test-project/ltp/blob/master/ci/alpine.sh[CI script]
-                                 for list of files which need to be deleted in order to compile under musl).
-| binder (Android) | Please use https://android.googlesource.com/platform/external/ltp/[AOSP fork].
-|==================================
-
-1.5 Used C standard
-~~~~~~~~~~~~~~~~~~~
-
-LTP compiles with '-std=gnu99'.
diff --git a/doc/old/Test-Writing-Guidelines.asciidoc b/doc/old/Test-Writing-Guidelines.asciidoc
deleted file mode 100644
index 4f40a4ab3..000000000
--- a/doc/old/Test-Writing-Guidelines.asciidoc
+++ /dev/null
@@ -1,430 +0,0 @@
-LTP Test Writing Guidelines
-===========================
-
-This document describes LTP guidelines and is intended for anybody who want to
-write or modify a LTP testcase. It's not a definitive guide and it's not, by
-any means, a substitute for common sense.
-
-NOTE: See also
-      https://github.com/linux-test-project/ltp/wiki/C-Test-API[C Test API],
-      https://github.com/linux-test-project/ltp/wiki/Shell-Test-API[Shell Test API],
-      https://github.com/linux-test-project/ltp/wiki/LTP-Library-API-Writing-Guidelines[LTP Library API Writing Guidelines].
-
-Rules and recommendations which are "machine checkable" should be
-tagged with an ID like +LTP-XXX+. There will be a corresponding entry
-in
-https://github.com/linux-test-project/ltp/tree/master/doc/rules.tsv[doc/rules.tsv]. When
-you run 'make check' or 'make check-test' it will display these IDs as
-a reference.
-
-1. Guide to clean and understandable code
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-For testcases it's required that the source code is as easy to follow as
-possible. When a test starts to fail the failure has to be analyzed, clean
-test codebase makes this task much easier and quicker.
-
-Here are some hints on how to write clean and understandable code, a few of
-these points are further discussed below:
-
-* First of all *Keep things simple*
-
-* Keep function and variable names short but descriptive
-
-* Keep functions reasonably short and focused on a single task
-
-* Do not overcomment
-
-* Be consistent
-
-* Avoid deep nesting
-
-* DRY
-
-1.1 Keep things simple
-~~~~~~~~~~~~~~~~~~~~~~
-
-For all it's worth keep the testcases simple or better as simple as possible.
-
-The kernel and libc are tricky beasts and the complexity imposed by their
-interfaces is quite high. Concentrate on the interface you want to test and
-follow the UNIX philosophy.
-
-It's a good idea to make the test as self-contained as possible too, ideally
-tests should not depend on tools or libraries that are not widely available.
-
-Do not reinvent the wheel!
-
-* Use LTP standard interface
-
-* Do not add custom PASS/FAIL reporting functions
-
-* Do not write Makefiles from scratch, use LTP build system instead
-
-* Etc.
-
-1.2 Keep functions and variable names short
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Choosing a good name for an API functions or even variables is a difficult
-task do not underestimate it.
-
-There are a couple of customary names for different things that help people to
-understand code, for example:
-
-* For loop variables are usually named with a single letter 'i', 'j', ...
-
-* File descriptors 'fd' or 'fd_foo'.
-
-* Number of bytes stored in file are usually named as 'size' or 'len'
-
-* Etc.
-
-1.3 Do not overcomment
-~~~~~~~~~~~~~~~~~~~~~~
-
-Comments can sometimes save you day but they can easily do more harm than
-good. There has been several cases where comments and actual implementation
-drifted slowly apart which yielded into API misuses and hard to find bugs.
-Remember there is only one thing worse than no documentation, wrong
-documentation.
-
-Ideally everybody should write code that is obvious, which unfortunately isn't
-always possible. If there is a code that requires to be commented keep it
-short and to the point. These comments should explain *why* and not *how*
-things are done.
-
-Never ever comment the obvious.
-
-In case of LTP testcases it's customary to add an asciidoc formatted comment
-paragraph with highlevel test description at the beginning of the file right
-under the GPL SPDX header. This helps other people to understand the overall
-goal of the test before they dive into the technical details. It's also
-exported into generated documentation hence it should mostly explain what is
-tested.
-
-1.4 DRY (Code duplication)
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Copy & paste is a good servant but very poor master. If you are about to copy a
-large part of the code from one testcase to another, think what would happen if
-you find bug in the code that has been copied all around the tree. What about
-moving it to a library instead?
-
-The same goes for short but complicated parts, whenever you are about to copy &
-paste a syscall wrapper that packs arguments accordingly to machine
-architecture or similarly complicated code, put it into a header instead.
-
-2 Coding style
-~~~~~~~~~~~~~~
-
-2.1 C coding style
-^^^^^^^^^^^^^^^^^^
-
-LTP adopted Linux kernel coding style:
-https://www.kernel.org/doc/html/latest/process/coding-style.html
-
-If you aren't familiar with its rules please read it, it's a well written
-introduction.
-
-Run `make check` in the test's directory and/or use `make check-$TCID`,
-it uses (among other checks) our vendored version of
-https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/scripts/checkpatch.pl[checkpatch.pl]
-script from kernel git tree.
-
-NOTE: If `make check` does not report any problems, the code still may be wrong
-      as all tools used for checking only look for common mistakes.
-
-2.1.1 LTP-004: Test executable symbols are marked static
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-Test executables should not export symbols unnecessarily. This means
-that all top-level variables and functions should be marked with the
-static keyword. The only visible symbols should be those included from
-shared object files.
-
-2.2 Shell coding style
-^^^^^^^^^^^^^^^^^^^^^^
-
-When writing testcases in shell write in *portable shell* only, it's a good
-idea to try to run the test using alternative shell (alternative to bash, for
-example dash) too.
-
-*Portable shell* means Shell Command Language as defined by POSIX with an
-exception of few widely used extensions, namely 'local' keyword used inside of
-functions and '-o' and '-a' test parameters (that are marked as obsolete in
-POSIX).
-
-You can either try to run the testcases on Debian which has '/bin/sh' pointing
-to 'dash' by default or install 'dash' on your favorite distribution and use
-it to run the tests. If your distribution lacks 'dash' package you can always
-compile it from http://gondor.apana.org.au/~herbert/dash/files/[source].
-
-Run `make check` in the test's directory and/or use `make check-$TCID.sh`,
-it uses (among other checks) our vendored version of
-https://salsa.debian.org/debian/devscripts/raw/master/scripts/checkbashisms.pl[checkbashism.pl]
-from Debian, that is used to check for non-portable shell code.
-
-NOTE: If `make check` does not report any problems, the code still may be wrong
-      as `checkbashisms.pl` used for checking only looks for common mistakes.
-
-Here are some common sense style rules for shell
-
-* Keep lines under 80 chars
-
-* Use tabs for indentation
-
-* Keep things simple, avoid unnecessary subshells
-
-* Don't do confusing things (i.e. don't name your functions like common shell
-  commands, etc.)
-
-* Quote variables
-
-* Be consistent
-
-3 Backwards compatibility
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-LTP test should be as backward compatible as possible. Think of an enterprise
-distributions with long term support (more than five years since the initial
-release) or of an embedded platform that needs to use several years old
-toolchain supplied by the manufacturer.
-
-Therefore LTP test for more current features should be able to cope with older
-systems. It should at least compile fine and if it's not appropriate for the
-configuration it should return 'TCONF'.
-
-There are several types of checks we use:
-
-The *configure script* is usually used to detect availability of a function
-declarations in system headers. It's used to disable tests at compile time or
-to enable fallback definitions.
-
-Checking the *errno* value is another type of runtime check. Most of the
-syscalls returns either 'EINVAL' or 'ENOSYS' when syscall was not implemented
-or was disabled upon kernel compilation.
-
-LTP has kernel version detection that can be used to disable tests at runtime,
-unfortunately kernel version does not always corresponds to a well defined
-feature set as distributions tend to backport hundreds of patches while the
-kernel version stays the same. Use with caution.
-
-Lately we added kernel '.config' parser, a test can define a boolean
-expression of kernel config variables that has to be satisfied in order for a
-test to run. This is mostly used for kernel namespaces at the moment.
-
-Sometimes it also makes sense to define a few macros instead of creating
-configure test. One example is Linux specific POSIX clock ids in
-'include/lapi/posix_clocks.h'.
-
-3.1 Dealing with messed up legacy code
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-LTP still contains a lot of old and messy code and we are cleaning it up as
-fast as we can but despite the decade of efforts there is still a lot. If you
-start modifying old or a messy testcase and your changes are more complicated
-than simple typo fixes you should convert the test into a new library first.
-
-It's also much easier to review the changes if you split them into a smaller
-logical groups. The same goes for moving files. If you need a rename or move
-file do it in a separate patch.
-
-4 License
-~~~~~~~~~
-
-Code contributed to LTP should be licensed under GPLv2+ (GNU GPL version 2 or
-any later version).
-
-Use `SPDX-License-Identifier: GPL-2.0-or-later`
-
-5 LTP Structure
-~~~~~~~~~~~~~~~
-
-The structure of LTP is quite simple. Each test is a binary written either in
-portable shell or C. The test gets a configuration via environment variables
-and/or command line parameters, it prints additional information into the
-stdout and reports overall success/failure via the exit value.
-
-Tests are generally placed under the 'testcases/' directory. Everything that
-is a syscall or (slightly confusingly) libc syscall wrapper goes under
-'testcases/kernel/syscalls/'.
-
-Then there is 'testcases/open_posix_testsuite/' which is a well maintained fork
-of the upstream project that has been dead since 2005 and also a number of
-directories with tests for more specific features.
-
-5.1 Runtest Files
-^^^^^^^^^^^^^^^^^
-
-The list of tests to be executed is stored in runtest files under the
-'runtest/' directory. The default set of runtest files to be executed is
-stored in 'scenario_groups/default'. When you add a test you should add
-corresponding entries into some runtest file(s) as well.
-
-Each line of runtest file contain one test. First item is the test name
-('shell_test01', 'splice02'). All other items, separated by space will be
-executed ('echo "SUCCESS" | shell_pipe01.sh', 'splice02 -s 20').
-
-[source,sh]
--------------------------------------------------------------------------------
-shell_test01 echo "SUCCESS" | shell_pipe01.sh
-splice02 splice02 -s 20
--------------------------------------------------------------------------------
-
-Blank lines and lines starting with a '#' (comments) are ignored.
-
-For syscall tests (these placed under 'testcases/kernel/syscalls/') use
-'runtest/syscalls' file, for kernel related tests for memory management we
-have 'runtest/mm', etc.
-
-IMPORTANT: The runtest files should have one entry per a test. Creating a
-           wrapper that runs all your tests and adding it as a single test
-           into runtest file is strongly discouraged.
-
-5.2 Datafiles
-^^^^^^^^^^^^^
-
-If your test needs datafiles to work, these should be put into a subdirectory
-named 'datafiles' and installed into the 'testcases/data/$TCID' directory (to
-do that you have to add 'INSTALL_DIR := testcases/data/TCID' into the
-'datafiles/Makefile').
-
-You can obtain path to datafiles via $TST_DATAROOT provided by test.sh
-'$TST_DATAROOT/...'
-or via C function 'tst_dataroot()' provided by libltp:
-
-[source,c]
--------------------------------------------------------------------------------
-const char *dataroot = tst_dataroot();
--------------------------------------------------------------------------------
-
-Datafiles can also be accessed as '$LTPROOT/testcases/data/$TCID/...',
-but '$TST_DATAROOT' and 'tst_dataroot()' are preferred as these can be used
-when running testcases directly in git tree as well as from install
-location.
-
-The path is constructed according to these rules:
-
-1. if '$LTPROOT' is set, return '$LTPROOT/testcases/data/$TCID'
-2. else if 'tst_tmpdir()' was called return '$STARTWD/datafiles'
-   (where '$STARTWD' is initial working directory as recorded by 'tst_tmpdir()')
-3. else return '$CWD/datafiles'
-
-See 'testcases/commands/file/' for example.
-
-5.3 Subexecutables
-^^^^^^^^^^^^^^^^^^
-
-If your test needs to execute a binary, place it in the same directory as the
-testcase and name the file starting with '${test_binary_name}_'.  Once the
-test is executed by the framework, the path to the directory with all LTP
-binaries is added to the '$PATH' and you can execute it just by its name.
-
-TIP: If you need to execute such test from the LTP tree, you can add path to
-     current directory to '$PATH' manually with: 'PATH="$PATH:$PWD" ./foo01'.
-
-6 Test Contribution Checklist
-------------------------------
-
-NOTE: See also
-      https://github.com/linux-test-project/ltp/wiki/Maintainer-Patch-Review-Checklist[Maintainer Patch Review Checklist].
-
-1. Test compiles and runs fine (check with `-i 10` too)
-2. `make check` does not emit any warnings for the test you are working on
-   (hint: run it in the test's directory and/or use `make check-$TCID`)
-3. The runtest entries are in place
-4. Test binaries are added into corresponding '.gitignore' files
-5. Patches apply over the latest git
-
-6.1 About .gitignore files
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-There are numerous '.gitignore' files in the LTP tree. Usually there is a
-'.gitignore' file per a group of tests. The reason for this setup is simple.
-It's easier to maintain a '.gitignore' file per directory with tests, rather
-than having single file in the project root directory. This way, we don't have
-to update all the gitignore files when moving directories, and they get deleted
-automatically when a directory with tests is removed.
-
-7 Testing pre-release kernel features
--------------------------------------
-
-Tests for features not yet in a mainline kernel release are accepted. However
-they must only be added to the +staging+ runtest file. Once a feature is part
-of the stable kernel ABI the associated test must be moved out of staging.
-
-This is primarily to help test kernel RCs by avoiding the need to download
-separate LTP patchsets.
-
-8 LTP C And Shell Test API Comparison
--------------------------------------
-
-Comparison of
-https://github.com/linux-test-project/ltp/wiki/C-Test-API[C Test API] and
-https://github.com/linux-test-project/ltp/wiki/Shell-Test-API[Shell Test API].
-
-[options="header"]
-|================================================================================
-| C API ('struct tst_test' members) | shell API ('$TST_*' environment variables)
-| '.all_filesystems' | 'TST_ALL_FILESYSTEMS'
-| '.bufs' | 
-| '.caps' | 
-| '.child_needs_reinit' | not applicable
-| '.cleanup' | 'TST_CLEANUP'
-| '.dev_extra_opts' | 'TST_DEV_EXTRA_OPTS'
-| '.dev_fs_opts' | 'TST_DEV_FS_OPTS'
-| '.dev_fs_type' | 'TST_FS_TYPE'
-| '.dev_min_size' | not applicable
-| '.format_device' | 'TST_FORMAT_DEVICE'
-| '.max_runtime' | 
-| '.min_cpus' | not applicable
-| '.min_kver' | 'TST_MIN_KVER'
-| '.min_mem_avail' | not applicable
-| '.mnt_flags' | 'TST_MNT_PARAMS'
-| '.min_swap_avail' | not applicable
-| '.mntpoint', '.mnt_data' | 'TST_MNTPOINT'
-| '.mount_device' | 'TST_MOUNT_DEVICE'
-| '.needs_cgroup_ctrls' | 
-| '.needs_checkpoints' | 'TST_NEEDS_CHECKPOINTS'
-| '.needs_cmds' | 'TST_NEEDS_CMDS'
-| '.needs_devfs' | 
-| '.needs_device' | 'TST_NEEDS_DEVICE'
-| '.needs_drivers' | 'TST_NEEDS_DRIVERS'
-| '.needs_kconfigs' | 'TST_NEEDS_KCONFIGS'
-| '.needs_overlay' |
-| '.needs_rofs' | 
-| '.needs_root' | 'TST_NEEDS_ROOT'
-| '.needs_tmpdir' | 'TST_NEEDS_TMPDIR'
-| '.options' | 'TST_PARSE_ARGS', 'TST_OPTS'
-| '.resource_files' | 
-| '.restore_wallclock' | not applicable
-| '.sample' | 
-| '.save_restore' | 
-| '.scall' | not applicable
-| '.setup' | 'TST_SETUP'
-| '.skip_filesystems' | 'TST_SKIP_FILESYSTEMS'
-| '.skip_in_compat' | 
-| '.skip_in_lockdown' | 'TST_SKIP_IN_LOCKDOWN'
-| '.skip_in_secureboot' | 'TST_SKIP_IN_SECUREBOOT'
-| '.supported_archs' | not applicable
-| '.tags' | 
-| '.taint_check' | 
-| '.tcnt' | 'TST_CNT'
-| '.tconf_msg' | not applicable
-| '.test', '.test_all' | 'TST_TESTFUNC'
-| '.test_variants' | 
-| '.timeout' | 'TST_TIMEOUT'
-| '.tst_hugepage' | not applicable
-| '.ulimit' | not applicable
-| not applicable | 'TST_NEEDS_KCONFIGS_IFS'
-| not applicable | 'TST_NEEDS_MODULE'
-| not applicable | 'TST_POS_ARGS'
-| not applicable | 'TST_USAGE'
-|================================================================================
-
-[options="header"]
-|================================================================================
-| C API (other structs) | shell API ('$TST_*' environment variables)
-| 'struct tst_device' | 'TST_DEVICE'
-|================================================================================
diff --git a/doc/old/User-Guidelines.asciidoc b/doc/old/User-Guidelines.asciidoc
deleted file mode 100644
index 9ff9a59e7..000000000
--- a/doc/old/User-Guidelines.asciidoc
+++ /dev/null
@@ -1,73 +0,0 @@
-LTP User Guidelines
-===================
-
-For compiling, installing and running the tests see `README.md`.
-For running LTP network tests see `testcases/network/README.md`.
-
-1. Library environment variables
---------------------------------
-
-Following environment variables are expected to be set by LTP users. Therefore,
-with some exceptions, they have 'LTP_' prefix. Environment variables with 'TST_'
-prefix are used inside LTP shell API and should *not* be set by users.
-
-|==============================================================================
-| 'KCONFIG_PATH'        | The path to the kernel config file, (if not set, it tries
-                          the usual paths '/boot/config-RELEASE' or '/proc/config.gz').
-| 'KCONFIG_SKIP_CHECK'  | Skip kernel config check if variable set (not set by default).
-| 'LTPROOT'             | Prefix for installed LTP.  **Should be always set**
-                          as some tests need it for path to test data files
-                          ('LTP_DATAROOT'). LTP is by default installed into '/opt/ltp'.
-| 'LTP_COLORIZE_OUTPUT' | By default LTP colorizes it's output unless it's redirected
-                          to a pipe or file.  Force colorized output behaviour:
-                          'y' or '1': always colorize, 'n' or '0': never colorize.
-| 'LTP_DEV'             | Path to the block device to be used
-                          (C: '.needs_device = 1', shell: 'TST_NEEDS_DEVICE=1').
-| 'LTP_SINGLE_FS_TYPE'  | Testing only - specifies filesystem instead all
-                          supported (for tests with '.all_filesystems').
-| 'LTP_DEV_FS_TYPE'     | Filesystem used for testing (default: 'ext2').
-| 'LTP_TIMEOUT_MUL'     | Multiplies timeout, must be number >= 0.1 (> 1 is useful for
-                          slow machines to avoid unexpected timeout).
-                          Variable is also used in shell tests, but ceiled to int.
-| 'LTP_RUNTIME_MUL'     | Multiplies maximal test iteration runtime. Tests
-                          that run for more than a second or two are capped on
-                          runtime. You can scale the default runtime both up
-                          and down with this multiplier. NOTE: Not yet implemented
-                          in shell API.
-| 'LTP_VIRT_OVERRIDE'   | Overrides virtual machine detection in the test
-                          library. Setting it to empty string tell the library
-                          that system is not a virtual machine. Other possible
-                          values are 'kvm', 'xen', 'zvm' and 'microsoft' that
-                          describe different types supervisors.
-| 'PATH'                | It's required to addjust path:
-                          `PATH="$PATH:$LTPROOT/testcases/bin"`
-| 'TMPDIR'              | Base directory for template directory (C: '.needs_tmpdir = 1'
-                          and others, which imply it, shell: 'TST_NEEDS_TMPDIR=1').
-                          Must be an absolute path (default: '/tmp').
-| 'LTP_NO_CLEANUP'      | Disable running test cleanup (defined in 'TST_CLEANUP').
-                          Shell API only.
-| 'LTP_ENABLE_DEBUG'    | Enable debug info (value '1' or 'y').
-|==============================================================================
-
-2. Test execution time and timeout
-----------------------------------
-
-The limit on how long a test can run does compose of two parts max_runtime and
-timeout. The limit does apply to a single test variant, that means for example
-that tests that run for all available filesystems will apply this limit for a
-single filesystem only.
-
-The max_runtime is a cap on how long the run() function can take, for most
-testcases this part is set to zero. For tests that do run for more than a
-second or two the max_runtime has to be defined and the run() function has to
-check actively how much runtime is left.
-
-Test runtime can be scaled up and down with 'LTP_RUNTIME_MUL' environment
-variable or set on a commandline by the '-I' parameter. Hoewever be vary that
-setting the runtime too low will cause long running tests to exit prematurely
-possibly before the have a chance actually test anyting.
-
-The timeout part is a limit for the test setup and cleanup and also safety
-margin for the runtime accounting. It's currently set to 30 seconds but may
-change later. If your target machine is too slow it can be scaled up with the
-'LTP_TIMEOUT_MUL' environment variable.
diff --git a/doc/old/man1/Makefile b/doc/old/man1/Makefile
deleted file mode 100644
index ecd2b6da9..000000000
--- a/doc/old/man1/Makefile
+++ /dev/null
@@ -1,27 +0,0 @@
-#
-#    man1 Makefile.
-#
-#    Copyright (C) 2009, Cisco Systems Inc.
-#
-#    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
-#    the Free Software Foundation; either version 2 of the License, or
-#    (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU General Public License for more details.
-#
-#    You should have received a copy of the GNU General Public License along
-#    with this program; if not, write to the Free Software Foundation, Inc.,
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Ngie Cooper, July 2009
-#
-
-MANPREFIX		:= 1
-
-top_srcdir		?= ../..
-
-include $(top_srcdir)/include/mk/man.mk
diff --git a/doc/old/man1/doio.1 b/doc/old/man1/doio.1
deleted file mode 100644
index e488c03f1..000000000
--- a/doc/old/man1/doio.1
+++ /dev/null
@@ -1,70 +0,0 @@
-.\"
-.\" $Id: doio.1,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH doio 1 10/13/93 "UNICOS Testing"
-.SH NAME
-\*Cdoio\fR - Executes I/O Requests
-.SH IMPLEMENTATION
-All Cray Research systems
-.SH SYNOPSIS
-\*Cdoio\fR
-.SH DESCRIPTION
-.QS
-Doio is one of the device-beater tools.
-.PP
-Options:
-.RS .5i
-.IP "-a"
-abort on data compare errors
-.IP "-n opt"
-.IP "-k opt"
-lockd request pipe
-.IP "-K opt"
-use fcntl() file locking
-.IP "-r opt"
-resource release interval
-.IP "-s opt"
-syscall log file
-.IP "-w opt"
-file write log file
-.IP "-v"
-verify writes if set
-.IP "-U opt"
-upanic() on varios conditions
-.RE
-.SH AUTHOR
-Mark Maule wrote the code.
-.br
-Glen Overby wrote the man page.
-.SH BUGS
-See "Features".
diff --git a/doc/old/man1/iogen.1 b/doc/old/man1/iogen.1
deleted file mode 100644
index f59415714..000000000
--- a/doc/old/man1/iogen.1
+++ /dev/null
@@ -1,78 +0,0 @@
-.\"
-.\" $Id: iogen.1,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH iogen 1 10/13/93 "UNICOS Testing"
-.SH NAME
-\*Ciogen\fR - Generate I/O Requests
-.SH IMPLEMENTATION
-All Cray Research systems
-.SH SYNOPSIS
-\*Ciogen\fR
-.SH DESCRIPTION
-.QS
-Iogen is one of the device-beater tools.
-.PP
-Options:
-.RS .5i
-.IP "-f [opt]"
-open flags:
-raw, sync, ssd, ldraw, buffered
-.IP "-i [opt]"
-Number of iterations to run.
-0 implies infinite.
-.IP "-q"
-.IP "-m [opt]"
-Offset mode.
-One of: random, sequential, reverse.
-.IP "-o"
-Overlap flag.
-.IP "-p [opt]"
-output pipe (default is stdout)
-.IP "-r [opt]"
-specify raw io multiple instead of getting it from the mounted on device.
-Only applies to regular files.
-.IP "-s [opt]"
-System calls to use for I/O.
-A list of:
-read, write, reada, writea, ssread, sswrite
-.IP "-t [opt]"
-min transfer size
-.IP "-T [opt]"
-max transfer size
-.RE
-.SH AUTHOR
-Mark Maule wrote the code.
-.br
-Glen Overby wrote the man page.
-.SH BUGS
-See "Features".
diff --git a/doc/old/man1/ltp-bump.1 b/doc/old/man1/ltp-bump.1
deleted file mode 100644
index aef2b4a30..000000000
--- a/doc/old/man1/ltp-bump.1
+++ /dev/null
@@ -1,80 +0,0 @@
-.\"
-.\" $Id: ltp-bump.1,v 1.1 2009/05/19 09:39:11 subrata_modak Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH BUMP 1 "14 Sep 2000" "LTP" "Linux Test Project"
-.SH NAME
-ltp-bump \- send signal to tags run by ltp-pan
-.SH SYNOPSIS
-\fBltp-bump [-1] [-s \fIsig\fB] [\fI-a active-file\fB] [tags...]
-.SH DESCRIPTION
-
-Bump will send a SIGINT signal to processes, given that each process has a
-corresponding tag in an active-file.  The active-file is the same one that is
-used by the ltp-pan to start the processes.
-
-If the active file has multiple occurrences of a single tag name then only the
-first process will be signaled.  You may specify the tag name multiple times
-on the commandline if necessary.
-
-.TP 1i
-\fB-1\fP
-Send a SIGUSR1 signal.  By default a SIGINT will be sent.
-.TP 1i
-\fB-a \fIactive_file\fB
-A file containing the tagnames, pids, and commands being run by a ltp-pan.  If this
-is not specified then the ZOO environment variable will be read for the name of
-the directory where the active file can be found.
-.TP 1i
-\fB-s \fIsig\fB
-Used to specify a signal number to send.  By default a SIGINT will be sent.
-
-.in -1i
-
-.SH ENVIRONMENT
-.TP
-ZOO
-If set, should name the directory where the active file can be found.
-This is ignored if \fI-a\fP is specified.
-
-.SH FILES
-.TP
-active
-Default name of active file if \fI-a\fP is not specified.  This is prefixed
-by the directory name found in the ZOO environment variable.
-
-.SH "SEE ALSO"
-Zoo tools - ltp-pan(1)
-
-.SH DIAGNOSTICS
-Exits zero, unless it cannot find the active file or if there were no tags
-listed on the commandline.
diff --git a/doc/old/man1/ltp-pan.1 b/doc/old/man1/ltp-pan.1
deleted file mode 100644
index 5ffa57dba..000000000
--- a/doc/old/man1/ltp-pan.1
+++ /dev/null
@@ -1,262 +0,0 @@
-.\"
-.\" $Id: ltp-pan.1,v 1.1 2009/05/19 09:39:11 subrata_modak Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.TH PAN 1 "21 Jan 2011" "LTP" "Linux Test Project"
-.SH NAME
-ltp-pan \- A light-weight driver to run tests and clean up their pgrps
-.SH SYNOPSIS
-\fBltp-pan -n tagname [-SyAehp] [-t #s|m|h|d \fItime\fB] [-s \fIstarts\fB] [\fI-x nactive\fB] [\fI-l logfile\fB] [\fI-a active-file\fB] [\fI-f command-file\fB] [\fI-d debug-level\fB] [\fI-o output-file\fB] [\fI-O buffer_directory\fB] [\fI-r report_type\fB] [\fI-C fail-command-file\fB] [cmd]
-.SH DESCRIPTION
-
-Pan will run a command, as specified on the commandline, or collection of
-commands from a command-file.  By default ltp-pan runs one command, choosing it at
-random from the whole set of commands available to it.  The ltp-pan's name in the
-active file is specified by the tagname.  When a command terminates ltp-pan will
-kill any orphans that may have been left behind in its pgrp.  If ltp-pan is
-signaled it will kill any active commands and, again, clean up any orphans.
-
-Pan uses the signal ratchet found in other zoo tools.  The first time ltp-pan is
-signaled it sends a SIGTERM to the active pgrps; the second time it sends
-SIGHUP; the third time a SIGINT; after that it always sends SIGKILL.
-
-Pan will not terminate until all the active commands and everything in their
-pgrps is dead.  It will loop around at 5 second intervals, triggering its own
-signal ratchet, until it succeeds in killing the pgrps.
-
-When the ltp-pan starts up it places its own tagname and commandline in the active
-file and begins scheduling commands.  After a command is started ltp-pan puts an
-entry for it into the active file with its indicated tagname.  If the command
-was specified on the command line, rather than in the command-file, then its
-tagname will be "cmdln".  When a process terminates ltp-pan frees the active file
-entry.  If a command terminates and leaves an orphaned pgrp then ltp-pan will put
-an entry into the active file called "panorphan" which will be removed only
-when the orphaned pgrp is cleaned up.  Before ltp-pan exits it will ensure that
-all orphaned pgrps are dead (see above) and then it will remove its own
-tagname from the active file.
-
-The command-file is a file containing tag/command pairs.  Each line in the
-file begins with a tag identifying the command, followed by white space, and
-then the command and its arguments.  A line beginning with the # character is
-a comment.  Pan recognizes the token "%f" in a command's arguments and
-replaces it with a unique identifier--add this to filename arguments to
-prevent two instances of the command from interfering with each other.
-
-When ltp-pan receives a SIGUSR2 it stops scheduling new tests and waits for the
-active tests to terminate.  If the \fB-y\fP option was used then it will begin
-scheduling again, otherwise it will exit.  It does not propagate the SIGUSR2.
-
-.TP 1i
-\fB-A\fP
-The all-stop flag.  If any command exits non-zero ltp-pan will shutdown its
-scheduler and signal any active pgrps.  The ltp-pan will exit non-zero after
-everything is shut down.  By default ltp-pan ignores command exit statuses.
-The \fI-e\fP option is implied when this option is used.
-.TP 1i
-\fB-a \fIactive_file\fB
-A file containing the tagnames, pids, and commands being run.  If this is
-not specified then the ZOO environment variable will be read for the name
-of a directory where the active file will be placed, and in this case the
-active file's name will be "active".  A single active file may be shared
-by any number of Zoo tools.
-.TP 1i
-\fB-C \fIfail-command-file\fB
-The file to which all failed test commands will be saved.  You can use it later with \fI-f\fP option if you want to run only the failed test cases.
-.TP 1i
-\fB-d \fIdebug-level\fB
-See the source for settings.
-.TP 1i
-\fB-e\fP
-Pan will exit non-zero if any of its commands exited non-zero.  By default
-ltp-pan ignores command exit statuses.
-.TP 1i
-\fB-f \fIcommand-file\fB
-The file that has a collection of commands that ltp-pan will execute.
-.TP 1i
-\fB-h\fP
-Print some simple help.
-.TP 1i
-\fB-l \fIlogfile\fB
-Name of a log file to be used to store exit information for each of the
-commands (tags) that are run.  This log file may not be shared with other Zoo
-tools or other ltp-pan processes.
-.TP 1i
-\fB-n \fItagname\fB
-The tagname by which this ltp-pan process will be known by the zoo tools.  This
-is a required argument.
-.TP 1i
-\fB-o \fIoutput_file\fB
-The file to which all test output will be saved.  Normally all test output is sent to standard output.  This includes each test's standard output and standard error.
-.TP 1i
-\fB-O \fIbuffer_directory\fB
-A directory where ltp-pan can place temporary files to capture test output.  This will prevent output from several tests mixing together in the output file.
-.TP 1i
-\fB-p\fP
-Enables printing results in human readable format.
-.TP 1i
-\fB-r \fIreport_type\fB
-This controls the type of output that ltp-pan will produce.  Supported formats are \fIrts\fP and \fInone\fP.  The default is \fIrts\fP.
-.TP 1i
-\fB-S\fP
-Causes ltp-pan to run commands (tags) sequentially, as they are listed in the
-command-file.  By default it chooses tags randomly.  If a command is specified
-on the commandline and a command-file is also specified, then the commandline
-tag will be the last command.  If this is specified and \fI-s\fP is not
-specified then the default setting for \fI-s\fP is equal to the total number
-of commands.
-.TP 1i
-\fB-s \fIstarts\fB
-Indicates the number of commands (tags) that should be run before terminating.
-Set this to zero to run forever.  By default this is set to 1 (but see
-\fI-S\fP for an exception).  If this is specified and is less than the value
-specified for \fI-x\fP then it is bumped up to be equal to the value of
-\fI-x\fP (in other words, \fI-x\fP is always satisfied).
-.TP 1i
-\fB-t #s|m|h|d \fItime\fB
-Indicates the length that ltp-pan should run tests. By default this is not set.  If specified,
-the \fI-s\fP flag is automatically set to 0 (infinite).  Presumably, you want as many
-tests ran during this timeframe. Duration is measured in \fIs\fPeconds, \fIm\fPinutes,
-\fIh\fPours, or \fId\fPays.
-.TP 1i
-\fB-x \fInactive\fB
-Indicates the number of commands (tags) that should be kept active at any one
-time.  If this is greater than 1 then it is possible to have multiple
-instances of the same tag active at once.  By default this is 1.
-.TP 1i
-\fB-y\fP
-Causes the ltp-pan scheduler to go idle if a signal is received or if a command
-exits non-zero.  All active commands and their pgrps will be killed.  After
-everything is dead the scheduler will restart again where it left off.  If the
-signal is SIGUSR1 then ltp-pan will behave as if \fI-y\fP had not been specified.
-
-.in -1i
-
-.SH EXAMPLES
-
-In practice, the ZOO environment variable is generally preferred over the
-\fI-a\fP option.  All examples assume this is being set.
-
-The following creates a ltp-pan named "ex1" with an active file in /tmp/active.
-It runs the command "echo hello", keeping 3 copies running at all times,
-running 10 copies before terminating.
-
-$ export ZOO=/tmp
-.br
-$ ltp-pan -n ex1 -s 10 -x 3 echo hello
-
-The next example will use this command file.  Call this /tmp/cmds1.
-.br
-----------cut------
-.br
-fido    ls /bin
-.br
-rover   echo hello wally
-.br
-gidget  sleep 2
-.br
-lassie  ls /etc
-.br
-----------cut------
-.br
-
-Using the above command file, /tmp/cmds1, run one command at a time,
-sequentially, running each command only once.  If one command should fail then
-terminate immediately.  An exit log is kept for all the commands.
-
-$ ltp-pan -n ex3 -S -A -f /tmp/cmds1 -l ex3.log
-
-Here is just a simple stress case. In this case the test will run for 24 hours,
-printing the output as a human readable format, with the test output at /tmp/output-file
-and all failed test commands (if you have any) at /tmp/fail-command-file.
-
-$ ltp-pan -n stress -e -p -q -S -t 24h -a stress -l logfile -f command-file \
-		-o /tmp/output-file -C /tmp/fail-command-file
-
-.SH LAYERING
-
-Pan is often used in layers.  This section extends the above examples to show
-how this is done.
-
-The next example will use this command file.  Call this /tmp/cmds2.  Note that
-the embedded ltp-pans inside this file have exit logs, and that %f is used to give
-each ltp-pan a unique log file name.
-.br
-----------cut------
-.br
-larry  ltp-pan -n ex4b -s10 -A -l ex4_%f.log echo hello
-.br
-curly  ltp-pan -n ex4c -S -A -f /tmp/cmds1 -l ex4_%f.log
-.br
-moe    echo done here
-.br
-----------cut------
-.br
-
-The following will run commands from the command file, keeping two at a time
-running, choosing them sequentially, and terminating if any of them exits
-non-zero.
-
-$ ltp-pan -n ex4 -x2 -A -S -f /tmp/cmds2
-
-Now run the commands in /tmp/cmds2, but this time we want to recover if one of
-the commands should exit non-zero.  In this example it is possible for the
-"larry" or "curly" tags to exit non-zero.  When this happens the ltp-pan will kill
-all active tags, making sure both larry and curly are dead, and then will
-continue scheduling--ensuring that our "done here" message comes out no matter
-what.
-
-$ ltp-pan -n ex5 -x2 -A -S -y -f /tmp/cmds2
-
-.SH ENVIRONMENT
-.TP
-ZOO
-If set, should name the directory where the active file should be placed.
-This is ignored if \fI-a\fP is specified.
-
-.SH FILES
-.TP
-active
-Default name of active file if \fI-a\fP is not specified.  This is prefixed
-by the directory name found in the ZOO environment variable.
-.TP
-PAN_STOP_FILE
-The creation of this file in the defined \fITMP\fP directory will cause ltp-pan to
-execute one more loop and stop.  This is useful when testing needs to be stopped
-before its scheduled stop time (\fI-t\fP).  By doing a 'touch' on this file, testing
-is ended, i.e. touch /tmp/runalltests-2345/PAN_STOP_FILE
-
-.SH "SEE ALSO"
-Zoo tools - ltp-bump(1)
-
-.SH DIAGNOSTICS
-By default it exits zero unless signaled, regardless of the exit status of any
-of the commands it is running.  If \fI-A\fP or \fI-e\fP are specified it exits non-zero if
-it is signaled or if any of the commands it is running should exit non-zero.
diff --git a/doc/old/man3/Makefile b/doc/old/man3/Makefile
deleted file mode 100644
index ff36ddd15..000000000
--- a/doc/old/man3/Makefile
+++ /dev/null
@@ -1,27 +0,0 @@
-#
-#    man3 Makefile.
-#
-#    Copyright (C) 2009, Cisco Systems Inc.
-#
-#    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
-#    the Free Software Foundation; either version 2 of the License, or
-#    (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU General Public License for more details.
-#
-#    You should have received a copy of the GNU General Public License along
-#    with this program; if not, write to the Free Software Foundation, Inc.,
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Ngie Cooper, July 2009
-#
-
-MANPREFIX		:= 3
-
-top_srcdir		?= ../..
-
-include $(top_srcdir)/include/mk/man.mk
diff --git a/doc/old/man3/parse_opts.3 b/doc/old/man3/parse_opts.3
deleted file mode 100644
index b3472ce9a..000000000
--- a/doc/old/man3/parse_opts.3
+++ /dev/null
@@ -1,179 +0,0 @@
-.\"
-.\" $Id: parse_opts.3,v 1.3 2000/08/31 18:40:28 nstraz Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH PARSE_OPTS 3 "21 Jan 2011" "LTP" "Linux Test Project"
-.SH NAME
-parse_opts \- parse standard and user options for LTP test programs
-.SH SYNOPSIS
-.nf
-.B #include \(rqtest.h\(rq
-.B #include \(rqusctest.h\(rq
-.sp
-.BI "char *parse_opts(int " argc ", char *" argv[] ", "
-.BI "                 option_t " option_array[] ","
-.BI "                 void (*" user_help_func ")());"
-.fi
-.SH DESCRIPTION
-The \fBparse_opts()\fP routine parses options from the command line, looking
-for user specified options or standard options (see below). Its arguments
-\fIargc\fP and \fIargv\fP are the argument count and array as passed to the
-main() function on program invocation. User options may be specified in the
-\fIoption_array\fR argument. A help function may be specified in the
-\fIuser_help_func\fP argument.
-.sp
-\fIoption_array\fP is a pointer to the first element of an array of
-\fBoption_t\fP.  If no additional options are needed, pass NULL.
-\fBoption_t\fR is declared in \fBusctest.h\fP as
-.nf
-.sp
-.in 10
-typedef struct {
-.in 14
-char	*option;
-int	*flag;
-char	**arg;
-.in 10
-} option_t;
-.fi
-.PP
-The meanings of the different fields are:
-.TP
-.I option
-is a valid option string to be given to getopt().
-.TP
-.I flag
-is a pointer to an integer location to set true if option is given in
-\fIargv\fR.  This can be NULL if the option doesn't require an argument.
-.TP
-.I arg
-is a pointer to a character pointer variable that will be set with the option
-argument if the option is present in argv.  This pointer MUST be provided if
-the option can take an argument.  Failure to provide a location will cause
-\fBparse_opts()\fR to return an error.
-.PP
-.I user_help_func
-is a pointer to a function that will be called when the \-h option is found.
-This function should print help messages for the options in \fIoption_array\fR
-to standard out. The standard help messages are formatted such that the option
-designator starts in column 3 and the description starts in column 11.
-.sp
-.SH "STANDARD OPTIONS"
-Below is a list of the standard options defined in \fBparse_opts()\fR:
-.TP
-.BI \-c " n"
-Run \fIn\fR copies of the test in parallel.  This is done by forking \fIn\fR
-times and running the test as usual.  If \-i or \-I are specified, each process
-will run for that amount of time.
-.TP
-.B \-e
-Turn on logging all errno's received.  This option is to facilitate security
-audit testing for MLS.
-.TP
-.B \-f
-Suppresses functional testing messages.
-.TP
-.B \-h
-Print help message.  The standard options will be printed first, then a call to
-.I user_help_func()
-will be made.
-.TP
-.BI \-i " n"
-Run for \fIn\fR iterations. A value of 0 makes the test loop infinitely.
-(default 1)
-.TP
-.BI \-I " x"
-The test will loop until \fIx\fR seconds have passed. (default 0.0)
-.TP
-.B \-p
-Pause for SIGUSR1 before testing. The test will pause where you place
-TEST_PAUSE.  \fIWarning\fR: The test will also fork at this point if \-c is
-used.
-.TP
-.BI \-P " x"
-This option will do a delay of \fIx\fR seconds after each iteration. (default 0.0)
-.TP
-.B \-t
-Produce timing statistics. *NOT IMPLEMENTED*
-.PP
-.sp
-The STD_* flags are used by system call test macros defined in usctest.h
-(see \fBusctest(3)\fR), or may be used in the user's code.
-.SH "RETURN VALUE"
-.B parse_opts()
-returns a NULL pointer upon successful completion.  If an error occurs a
-pointer to an error message is returned.
-.SH "EXAMPLE"
-The following example defines two options, one with an argument, one without.
-.sp
-.nf
-int fflag, Tflag;	/* binary flags: opt or not */
-char *Topt;		/* option arguments */
-
-option_t options[] = {
-	{ "F", &fflag, NULL },		/* No argument */
-	{ "T:",	&Tflag, &Topt },	/* argument required */
-	{ NULL, NULL, NULL }		/* NULL required to end array */
-};
-
-void help()
-{
-	printf("  -F       An option with no argument\\n");
-	printf("  -T opt   An option that requires an argument\\n");
-}
-
-int main(int argc, char *argv[])
-{
-	char *msg;
-
-	if ((msg = parse_opts(argc, argv, options, &help)) != NULL)
-		error_exit(msg);
-
-	return 0;
-}
-.fi
-.sp
-The following example shows how to use \fBparse_opts()\fR without defining new options.
-.sp
-.nf
-int main(int argc, char *argv[])
-{
-	char *msg;
-
-	if ((msg = parse_opts(argc, argv, NULL, NULL)) != NULL)
-		error_exit(msg);
-
-	return 0;
-}
-.fi
-.SH "SEE ALSO"
-usctest(3), getopt(3).
diff --git a/doc/old/man3/parse_ranges.3 b/doc/old/man3/parse_ranges.3
deleted file mode 100644
index d92e001f1..000000000
--- a/doc/old/man3/parse_ranges.3
+++ /dev/null
@@ -1,169 +0,0 @@
-.\"
-.\" $Id: parse_ranges.3,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH PARSE_RANGES 3 07/25/2000 "Linux Test Project"
-.SH NAME
-parse_ranges \- function to parse a string formatted like 'min:max:mult,...'
-.SH SYNOPSIS
-.nf
-int parse_ranges(char *str, int defmin, int defmax, int defmult, int (*parse_func)(), char **rangeptr, char **errptr);
-int range_min(char *rbuf, int r);
-int range_max(char *rbuf, int r);
-int range_mult(char *rbuf, int r);
-.fi
-.SH DESCRIPTION
-parse_ranges() is a function to parse a comma-separated list of range
-tokens each having the following form:
-.SP
-.nf
-		num
-	or
-		min:max[:mult]
-.fi
-
-any of the values may be blank (ie. min::mult, :max, etc.) and default
-values for missing arguments may be supplied by the caller.
-
-The special first form is short hand for 'num:num'.
-
-After parsing the string, the ranges are put into an array of integers,
-which is malloc'd by the routine.  The min, max, and mult entries of each
-range can be extracted from the array using the range_min(), range_max(),
-and range_mult() functions.
-
-If \fIrange_ptr\fP is not NULL, and parse_ranges() successfully parses the
-range string (ie. does not return -1), *range_ptr will point to space
-malloc'd by parse_ranges().  The user may free this space by calling free().
-
-parse_ranges() parameters are:
-.SP
-.TP 1i
-\fIstr\fP
-The string to parse - assumed to be a comma-separated
-list of tokens having the above format.
-.TP 1i
-\fIdefmin\fP
-default value to plug in for min, if it is missing
-.TP 1i
-\fIdefmax\fP
-default value to plug in for max, if it is missing
-.TP 1i
-\fIdefmult\fP
-default value to plug in for mult, if missing
-.TP 1i
-\fIparse_func\fP
-A user-supplied function pointer, which parse_ranges()
-can call to parse the min, max, and mult strings.  This
-allows for customized number formats.  The function
-MUST have the following prototype:
-.SP
-.nf
-	int parse_func(char *str, int *val)
-.fi
-.SP
-The function should return -1 if str cannot be parsed
-into an integer, or >= 0 if it was successfully
-parsed.  The resulting integer will be stored in
-*val.  If parse_func is NULL, parse_ranges will parse
-the tokens in a manner consistent with the sscanf %i format.
-.TP 1i
-\fIrange_ptr\fP
-A user-supplied char **, which will be set to point
-at malloc'd space which holds the parsed range
-values.   If range_ptr is NULL, parse_ranges() just
-parses the string.  The data returned in range_ptr
-should not be processed directly - use the functions
-range_min(), range_max(), and range_mult() to access
-data for a given range.
-.TP 1i
-\fIerrptr\fP
-user-supplied char ** which can be set to point to a
-static error string.  If errptr is NULL, it is ignored.
-.in -1i
-
-.SP
-range_min(), range_max(), and range_mult() parameters are:
-.SP
-.SP
-.TP 1i
-\fIrbuf\fP
-An array of ranges set up by parse_ranges().
-.TP 1i
-\fIr\fP
-The range number to extract information from.  Must be an integer >= 0 and
-< the number of ranges returned by parse_ranges().
-.in -1i
-
-.SH EXAMPLES
-\fC
-.ta .25i +.25i +.25i +.25i
-.nf
-/*
- * simple example to take a list of ranges on the cmdline (in argv[1]), and
- * print a random number from within that range.
- */
-
-#include <stdio.h>
-
-main()
-{
-	extern int	parse_ranges(), range_min(), range_max(), range_mult();
-	extern long	random_range(), random_range_seed();
-	int		min, max, mult, nranges;
-	char		*ep, *rp;
-
-	random_range_seed(getpid());
-	if ((nranges = parse_ranges(argv[1], 0, INT_MAX, 1, NULL, &rp, &ep)) < 0) {
-		fprintf(stderr, "parse_ranges() failed:  %s\n", ep);
-		exit(1);
-	}
-
-	range = random_range(0, nranges-1, 1);
-	min = range_min(rp, range);
-	max = range_max(rp, range);
-	mult = range_mult(rp, range);
-
-	fprintf("%d\\n", random_range(min, max-1, mult));
-	exit(0);
-}
-\fP
-.DT
-.SH "SEE ALSO"
-random_range(3),
-random_range_seed(3),
-bytes_by_prefix(3).
-.SH DIAGNOSTICS
-parse_ranges() returns -1 on error or the number of ranges parsed.  No space
-will be malloc'd if parse_ranges() fails.  Error
-messages are passed back through the errptr parameter.  There are no error
-conditions for range_min(), range_max(), or range_mult().
diff --git a/doc/old/man3/random_range.3 b/doc/old/man3/random_range.3
deleted file mode 100644
index e7ab67271..000000000
--- a/doc/old/man3/random_range.3
+++ /dev/null
@@ -1,114 +0,0 @@
-.\"
-.\" $Id: random_range.3,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH random_range 3 07/25/2000 "Linux Test Project"
-.SH NAME
-random_range \- a set of routines for dealing with integer ranges, and random numbers in a range
-.SH SYNOPSIS
-.nf
-void random_range_seed(int seed)
-long random_range(int min, int max, int mult, char **errp)
-long random_rangel(long min, long max, long mult, char **errp)
-long long random_rangell(long long min, long long max,
-		         long long mult, char **errp)
-long random_bit(long mask)
-.fi
-.SH DESCRIPTION
-This is a set of routines for parsing numeric ranges, and choosing random
-numbers from a range.
-
-random_range() chooses a random number in the range min-max (inclusive) which
-is a multiple of mult.  min and max may be any integer, but mult must be
-a positive integer greater than 0.  errp is a char ** which is used to detect
-error conditions.  If errp is not NULL, *errp will be set to point to an
-error message.  If errp is NULL, error conditions cannot be detected by the
-caller.  If mult is 1 (the most common case), there are no possible error
-conditions, and the return value is guaranteed to be valid.
-
-random_range_seed() sets the random number generator seed to the specified
-value.
-
-random_bit() will return a randomly selected single bit bitmask from the bits
-set in mask.  The bit is randomly chosen using random_range().
-If mask is zero, zero is returned.
-
-random_range() functions uses lrand48() internally.  If the range is bigger
-than will fit in a 32 bit long (2G), lrand48() with a
-a internal recursive algorithm to produce a random number.
-
-.SH EXAMPLES
-\fC
-.ta .25i +.25i +.25i +.25i
-.nf
-#include <stdio.h>
-
-main(argc, argv)
-int	argc;
-char	**argv;
-{
-	int		r;
-	char		*errp;
-	extern void	random_range_seed();
-	extern long	random_range();
-
-	random_range_seed(getpid());
-
-	r = random_range(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]), &errp);
-	if (errp == NULL) {
-		fprintf(stderr, "random_range failed:  %s\n", errp);
-		exit(1);
-	} else {
-		printf("%d\n", r);
-	}
-
-	exit(0);
-}
-\fP
-.fi
-
-.SH "SEE ALSO"
-lrand48(3c)
-.SH DIAGNOSTICS
-If random_range() fails, errp will point to NULL, and the return value will be
-undefined.  If mult is 1, there are no possible error conditions, so the return
-value is always valid in this case.
-
-.SH BUGS
-On CRAY systems, random_range(), random_rangel(), random_rangell()
-all have the 64 bit limit since int, long and long long are always 64 bits.
-
-On IRIX systems, random_range() can only produce a 32 number.
-random_rangel() when compiled as a 32 bit object is still limited to 32 bit
-number.  random_rangell() can be used to return a value bigger than 32 bits
-even when compiled as a 32 bit object.
-
diff --git a/doc/old/man3/random_range_seed.3 b/doc/old/man3/random_range_seed.3
deleted file mode 100644
index 2344b570f..000000000
--- a/doc/old/man3/random_range_seed.3
+++ /dev/null
@@ -1,114 +0,0 @@
-.\"
-.\" $Id: random_range_seed.3,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH random_range 3 07/25/2000 "Linux Test Project"
-.SH NAME
-random_range \- a set of routines for dealing with integer ranges, and random numbers in a range
-.SH SYNOPSIS
-.nf
-void random_range_seed(int seed)
-long random_range(int min, int max, int mult, char **errp)
-long random_rangel(long min, long max, long mult, char **errp)
-long long random_rangell(long long min, long long max,
-		         long long mult, char **errp)
-long random_bit(long mask)
-.fi
-.SH DESCRIPTION
-This is a set of routines for parsing numeric ranges, and choosing random
-numbers from a range.
-
-random_range() chooses a random number in the range min-max (inclusive) which
-is a multiple of mult.  min and max may be any integer, but mult must be
-a positive integer greater than 0.  errp is a char ** which is used to detect
-error conditions.  If errp is not NULL, *errp will be set to point to an
-error message.  If errp is NULL, error conditions cannot be detected by the
-caller.  If mult is 1 (the most common case), there are no possible error
-conditions, and the return value is guaranteed to be valid.
-
-random_range_seed() sets the random number generator seed to the specified
-value.
-
-random_bit() will return a randomly selected single bit bitmask from the bits
-set in mask.  The bit is randomly chosen using random_range().
-If mask is zero, zero is returned.
-
-random_range() functions uses lrand48() internally.  If the range is bigger
-than will fit in a 32 bit long (2G), lrand48() with a
-a internal recursive algorithm to produce a random number.
-
-.SH EXAMPLES
-\fC
-.ta .25i +.25i +.25i +.25i
-.nf
-#include <stdio.h>
-
-main(argc, argv)
-int	argc;
-char	**argv;
-{
-	int		r;
-	char		*errp;
-	extern void	random_range_seed();
-	extern long	random_range();
-
-	random_range_seed(getpid());
-
-	r = random_range(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]), &errp);
-	if (errp == NULL) {
-		fprintf(stderr, "random_range failed:  %s\n", errp);
-		exit(1);
-	} else {
-		printf("%d\n", r);
-	}
-
-	exit(0);
-}
-\fP
-.fi
-
-.SH "SEE ALSO"
-lrand48(3c)
-.SH DIAGNOSTICS
-If random_range() fails, errp will point to NULL, and the return value will be
-undefined.  If mult is 1, there are no possible error conditions, so the return
-value is always valid in this case.
-
-.SH BUGS
-On CRAY systems, random_range(), random_rangel(), random_rangell()
-all have the 64 bit limit since int, long and long long are always 64 bits.
-
-On IRIX systems, random_range() can only produce a 32 number.
-random_rangel() when compiled as a 32 bit object is still limited to 32 bit
-number.  random_rangell() can be used to return a value bigger than 32 bits
-even when compiled as a 32 bit object.
-
diff --git a/doc/old/man3/tst_res.3 b/doc/old/man3/tst_res.3
deleted file mode 100644
index 56f722436..000000000
--- a/doc/old/man3/tst_res.3
+++ /dev/null
@@ -1,313 +0,0 @@
-.\"
-.\" $Id: tst_res.3,v 1.2 2008/06/10 05:52:02 subrata_modak Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH TST_RES 3 01/21/2011 "Linux Test Project"
-.SH NAME
-tst_resm \- Print result message
-.sp
-tst_resm_hexd \- Print result message, including specified buffer in hexadecimal format
-.sp
-tst_brkm \- Print result message and break remaining test cases
-.sp
-tst_old_flush \- Print any messages pending because of CONDENSE mode, and flush output stream
-.sp
-tst_exit \- Exit test with a meaningful exit value
-.sp
-tst_environ \- Keep results coming to original stdout
-.SH SYNOPSIS
-\fB#include "test.h"\fR
-.P
-.P
-\fBvoid tst_resm(int \fIttype\fB, char *\fItmesg, [arg ...]\fR)
-.P
-\fBvoid tst_resm_hexd(int \fIttype\fB, const void *\fIbuf\fB, size_t \fIsize\fB,
-char *\fItmesg, [arg ...]\fR)
-.P
-\fBvoid tst_brkm(int \fIttype\fB, void (*\fIfunc\fB)(), char *\fItmesg,
-[arg ...]\fR)
-.P
-\fBvoid tst_old_flush()
-.P
-\fBvoid tst_exit()
-.P
-\fBint  tst_environ()
-.P
-\fBextern int tst_count;
-.br
-extern int tst_range;
-.br
-\fR
-.SH DESCRIPTION
-.SS Introduction
-This library of functions are used by UNICOS tests to report results to
-standard output in a consistent manner.  It is assumed that tests using this
-library have a distinct number of test cases, and that each test case is
-distinct and uniquely identified by the test case number.  It is also assumed
-that test case results are printed in consecutive order, starting with 1.
-The library maintains a set of global variables (\fBTCID\fR, \fBTST_TOTAL\fR,
-\fBtst_count\fR), which are used by the various functions to format the
-results and to keep track of the current result reporting state (i.e. how many
-total test cases there are, and how many have been reported so far) for the
-calling test.
-.P
-The \fBTCID\fR and \fBTST_TOTAL\fR global variables are externed in the
-library, and MUST be defined/initialized by tests using the library.
-\fBTCID\fR must be set to the \fBT\fRest \fBC\fRase \fBID\fRentifier, and
-\fBTST_TOTAL\fR must be set to the total number of test cases that will be
-reported.
-.P
-The other global variables are available as externs to tests linked with
-tst_res.o.  \fBtst_count\fR is the running count of the number of test
-results that have been reported so far.  The library initializes it to 0, and
-it should not be modified by the test.
-The details are described below under the appropriate functions.
-.SS Arguments
-.RS 5
-.TP 10
-.I ttype
-test result type; one of \fBTPASS, TFAIL, TBROK, TCONF, TWARN\fR, or
-\fBTINFO\fR (explained below).
-.TP 10
-.I fname
-pointer to a character string holding the name of a file whose contents will
-be printed on a new line following \fItmesg\fR.  If this pointer is NULL, it
-is ignored.
-.TP 10
-.I tmesg, [arg ...]
-pointer to a character string containing a message explaining the test
-result.  This character string can contain percent-sign conversion
-specifications as in \fBprintf\fR(3C) with corresponding \fIarg\fR arguments
-following the \fItmesg\fR argument.
-.br
-\fBNOTE:\fR These routines use static space internally to hold the
-expanded message.  The maximum size allowed for an expanded message is
-2048 bytes.
-.TP 10
-.I func
-pointer to a function which performs either the cleanup necessary prior to
-exiting the test or some function executed at the end of each iteration of a
-loop.
-.TP 10
-.I buf
-pointer to a buffer whose contents will be printed in hexadecimal format.
-.TP 10
-.I size
-size of the buffer.
-.RE
-.SS Result Types
-The possible test result types defined in \fBtest.h\fR are as follows:
-.RS 5
-.TP 10
-.B TPASS
-The test case produced expected results.
-.TP 10
-.B TFAIL
-The test case produced unexpected results.
-.TP 10
-.B TBROK
-A resource needed to execute the test case was not available (e.g. a
-temporary file could not be opened).
-.TP 10
-.B TCONF
-The test case was not appropriate for the current hardware or software
-configuration (e.g. MLS was not enabled).
-.TP 10
-.B TWARN
-The testing procedure caused undesirable side effects that did not affect
-test results (e.g. a temporary file could not be removed after all test
-results were recorded).
-.TP 10
-.B TINFO
-An informative message about the execution of the test that does not
-correspond to a test case result and does not indicate a problem.
-.RE
-.SS Function Descriptions
-
-\fBtst_resm()\fR and \fBtst_resm_hexd()\fR are the basic
-result reporting functions. They report 1 or more test case results of the
-specified \fIttype\fR.  All result types are valid for these functions.  The
-\fBtst_range\fR global variable indicates the number of results that will be
-reported for each call to one of these functions.  It is initialized by the
-library to 1, but may be set to a value > 1 by the test.  Each call to one of
-these functions will result in \fBtst_range\fR test case results being
-reported, each with an identical message (\fItmesg\fR).  \fBtst_range\fR is
-always reset to 1 by the library before returning to the caller.
-.P
-\fBtst_brk()\fR and \fBtst_brkm()\fR are used to report results for all test
-cases remaining in the test, and then call a cleanup function.  The only
-result types that are valid for these functions are: \fBTFAIL, TBROK,
-and TCONF\fR.  When called with a \fIttype\fR of \fBTFAIL\fR or
-\fBTBROK\fR, one result of the specified \fIttype\fR will be printed,
-followed by results of type \fBTBROK\fR for the remaining test cases.  When
-called with a \fIttype\fR of \fBTCONF\fR, the specified
-\fIttype\fR will be printed for all remaining test cases.  If \fIfunc\fR is
-not NULL, \fBtst_brk()\fR and \fBtst_brkm()\fR will call \fIfunc\fR after all
-results have been printed.  If the call to \fIfunc\fR returns,
-\fBtst_brk()\fR and \fBtst_brkm()\fR will then call \fBtst_exit()\fR.  If
-\fIfunc\fR is NULL, \fBtst_brk()\fR and \fBtst_brkm()\fR return to the caller
-after all results have been printed.  If \fBtst_brk()\fR is called with a
-\fIfname\fR argument, the contents of the file will only be printed for the
-first reported result.  \fBtst_brk()\fR takes the \fIfname\fR argument
-whereas \fBtst_brkm()\fR does not.
-.P
-\fBtst_old_flush()\fR is used to print any results pending because of
-\fBCONDENSE\fR or \fBNOPASS\fR modes (described below), and flushes the
-output stream.
-.P
-\fBtst_exit()\fR is used to allow tests to exit with a meaningful exit
-value.  A bit is set in the exit value for each of the non passing test
-case result types (TFAIL, TBROK, and TWARN) encountered by the library.
-Thus any bit which is set in the exit value indicates that the
-corresponding result flag was used at least once in the test run.
-.P
-The current bit fields for the result types are as follows:
-.RS 5
-.TP 10
-TPASS
-0000	/* .... .... */
-.TP 10
-TFAIL
-0001	/* .... ...1 */
-.TP 10
-TBROK
-0002	/* .... ..1. */
-.TP 10
-TWARN
-0004	/* .... .1.. */
-.TP 10
-TINFO
-0020	/* ...1 .... */
-.TP 10
-TCONF
-0040	/* ..1. .... */
-.RE
-.P
-NOTE: \fBTPASS and TINFO\fR do not have an effect
-on the test program exit status.
-.P
-\fBtst_environ()\fR is used to ensure that results reported by this library
-will go to the original stdout, even if the test changes the original stdout
-to another file, or closes it.  A test may want to do this in order to
-redirect output that normally goes to stdout (e.g. printf() output) to a
-file.  \fBtst_environ()\fR returns 0 upon successful completion, and -1 if it
-encountered any problems.
-.SS Output Modes
-Four output display modes are supported by the \fBtst_resm()\fR family of
-functions to enhance output readability. The active mode is controlled via
-the environment variable \fBTOUTPUT\fR, which must be set prior to the start
-of the test in order to have any effect (see \fBksh\fR(1) for information on
-environment variables).  The supported modes are as follows:
-.RS 5
-.TP 15
-.B VERBOSE
-A test result output line is generated for each test result.  This is the
-default mode.
-.TP 15
-.B CONDENSE
-Consecutive, identical PASS, FAIL, BROK, CONF, and RETR test results are
-condensed into one output line.  The test case number field contains the range
-of results involved.  WARN and INFO output lines are not condensed, but
-printed as usual.
-.TP 15
-.B NOPASS
-All PASS, CONF, INFO, and RETR output lines are discarded (i.e. not printed),
-and consecutive, identical FAIL and BROK output lines are condensed as in
-\fBCONDENSE\fR mode.  WARN output lines are printed as usual.
-.TP 15
-.B DISCARD
-All output lines are discarded.
-.RE
-.SH EXAMPLES
-.nf
-#include "test.h"
-
-char *TCID = "tsttcs01"; /* set test case identifier */
-int TST_TOTAL = 15;      /* set total number of test results */
-
-main()
-{
-		.
-		.
-	/* a successful test result */
-	tst_resm(TPASS, "\fIwhat was tested\fR");
-		.
-		.
-
-	/* break all remaining test results */
-	tst_brkm(TBROK, cleanup, "\fIwhat didn't work\fR");
-		/* or */
-	tst_brk(TBROK, file, cleanup, "\fIwhat didn't work\fR");
-		.
-		.
-
-	/* exit after all test results have been passed to tst_res */
-	tst_exit();
-}
-.fi
-.P
-Sample output:
-.RS 5
-.nf
-tsttcs01    1       PASS  :  Able to create MAXUP processes
-tsttcs01    2       FAIL  :  Too many processes (MAXUP+1) created
-tsttcs01    3       BROK  :  tabinfo(PROCTAB, &tbs) failed; errno = 13: Permission denied
-.fi
-.SH "SEE ALSO"
-tst_setup(1),
-printf(3C),
-ksh(1).
-.SH DIAGNOSTICS
-.P
-A WARN result message will be printed if any of the following occur:
-.RS 5
-.P
-If an invalid test type is specified.
-.P
-If \fBtst_count\fR is negative.
-.P
-If one of the \fBtst_brk[m]()\fR routines is called with a test type
-other than \fBTFAIL, TBROK, TCONF\fR.
-.P
-If there are any problems opening/reading/writing the contents of \fIfname\fR.
-.RE
-.SH LIMITATIONS
-If \fIfname\fR is NULL and \fItmesg\fR is NULL or empty, the result message
-will be empty.  This allows a test to not print a message for a result, but
-it is not advised.
-.SH NOTES
-In multithreaded environment, output of \fBtst_resm_hexd()\fR may be interleaved
-with messages produced by other threads.
-.SH BUGS
-.P
-The programmer is free to alter the value of \fBtst_count\fR causing possible
-test result order problems.
diff --git a/doc/old/man3/tst_sig.3 b/doc/old/man3/tst_sig.3
deleted file mode 100644
index 7550644fd..000000000
--- a/doc/old/man3/tst_sig.3
+++ /dev/null
@@ -1,141 +0,0 @@
-.\"
-.\" $Id: tst_sig.3,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH TST_SIG 3 07/25/2000 "Linux Test Project"
-.SH NAME
-tst_sig \- set up for unexpected signals
-.SH SYNOPSIS
-.nf
-\fB
-#include "test.h"
-
-void tst_sig(fork_flag, handler, cleanup)
-char *fork_flag;
-int (*handler)();
-void (*cleanup)();
-\fR
-.fi
-.SH DESCRIPTION
-.P
-\fItst_sig\fR is used by UNICOS test case programs
-to set up signal handling functions for unexpected
-signals.  This provides test cases with a graceful means
-of exiting following an unexpected interruption by a signal.
-\fItst_sig\fR should be called only once by a test
-program.
-.P
-The \fIfork_flag\fR parameter is used to tell \fItst_sig\fR
-whether or not to ignore the SIGCHLD signal caused by the death of a
-child process that had previously been created by the
-\fIfork\fR(2) system call (see \fIsignal\fR(2) for more
-information on the SIGCHLD signal).
-.P
-Setting \fIfork_flag\fR to FORK will cause \fItst_sig\fR to
-ignore the SIGCHLD signal.  This option should be set if the
-test program directly (eg. call \fIfork\fR(2)) or indirectly
-(eg. call \fIsystem\fR(3S)) creates a child process.
-.P
-Setting \fIfork_flag\fR to NOFORK will cause \fItst_sig\fR to
-treat the SIGCHLD signal just as any other unexpected
-signal (ie. the \fIhandler\fR will be called).
-This option should be set by any test program which does not
-directly or indirectly create any child processes.
-.P
-The \fIhandler\fR parameter is
-a pointer to a function returning type int which is
-executed upon the receipt of an unexpected signal.
-The test program may pass a pointer to a signal handling
-function or it may elect to use a \fIdefault handler\fR
-supplied by \fItst_sig\fR.
-
-The \fIdefault handler\fR is specified by passing DEF_HANDLER
-as the \fIhandler\fR argument.  Upon receipt of an unexpected
-signal, the \fIdefault handler\fR will generate
-\fItst_res\fR(3) messages for all test results that had
-not been completed at the time of the signal, execute the
-\fIcleanup\fR routine, if provided, and call \fItst_exit\fR.
-Note: if the \fIdefault handler\fR is used, the variables
-\fBTCID\fR and \fBtst_count\fR must be defined and available to
-\fItst_sig\fR (see \fItst_res\fR(3)).
-.P
-The \fIcleanup\fR parameter is a pointer to a user-defined
-function returning type void which is executed
-by the \fIdefault handler\fR.  The \fIcleanup\fR function
-should remove any files, directories, processes, etc. created
-by the test program.
-If no cleanup is required, this parameter should be set to NULL.
-
-.SH EXAMPLES
-
-.nf
-#include "test.h"
-
-/*
- * the TCID and TST_TOTAL variables must be available to tst_sig
- * if the \fIdefault handler\fR is used.  The \fIdefault handler\fR will call
- * \fItst_res\fR(3) and will need this information.
- */
-int TCID = "tsttcs01";  /* set test case identifier */
-int TST_TOTAL = 5;        /* set total number of test results */
-
-
-	void tst_sig();
-
-	/*
-	 * set up for unexpected signals:
-	 *		no \fIfork\fR() system calls will be executed during the test run
-	 *		use the default signal handler provided by \fItst_sig\fR
-	 *		no cleanup is necessary
-	 */
-	tst_sig(NOFORK, DEF_HANDLER, NULL);
-
-
-	void tst_sig(), cleanup();
-	int handler();
-
-	/*
-	 * set up for unexpected signals:
-	 *		\fIfork\fR() system calls will be executed during the test run
-	 *		use user-defined signal handler
-	 *		use cleanup
-	 */
-	tst_sig(FORK, handler, cleanup);
-
-.fi
-.SH "SEE ALSO"
-signal(2),
-tst_setup(1).
-.SH DIAGNOSTICS
-.P
-\fItst_sig\fR will output warnings in standard \fItst_res\fR
-format if it cannot set up the signal handlers.
diff --git a/doc/old/man3/tst_tmpdir.3 b/doc/old/man3/tst_tmpdir.3
deleted file mode 100644
index b8a8d7994..000000000
--- a/doc/old/man3/tst_tmpdir.3
+++ /dev/null
@@ -1,76 +0,0 @@
-.\"
-.\" $Id: tst_tmpdir.3,v 1.1 2000/07/27 16:59:03 alaffin Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH TST_TMPDIR 3 07/25/2000 "Linux Test Project"
-.SH NAME
-tst_tmpdir \- create a unique testing directory and make it current.
-.br
-tst_rmdir \- remove the directory created by \fBtst_tmpdir\fR.
-.SH SYNOPSIS
-\fBvoid tst_tmpdir()
-.P
-void tst_rmdir()
-.P
-extern char *TESTDIR;\fR
-.SH DESCRIPTION
-The \fBtst_tmpdir()\fR function uses the first three characters of the
-\fBTCID\fR global variable as the prefix in forming a unique directory name
-(via \fBtempnam\fR(3S)).  The directory is then created and made the current
-working directory.
-.P
-If \fBtst_tmpdir()\fR cannot form a unique directory name, create the
-directory, or \fBchdir\fR to the directory, it uses \fBtst_brk()\fR to issue
-"BROK" messages for all test cases.  It then exits via \fBtst_exit()\fR.
-Because \fBtst_tmpdir()\fR exits in the event of a problem, a test must call
-it \fBbefore\fR performing any operations that would require running a
-cleanup routine.
-.P
-The \fBtst_rmdir()\fR function recursively removes the directory created by
-\fBtst_tmpdir()\fR.  This function should be used \fBonly\fR as a companion
-to \fBtst_tmpdir()\fR and should be called immediately prior to the test
-exiting via \fBtst_exit()\fR.
-.P
-\fBtst_rmdir()\fR uses the \fBsystem\fR(3S) library routine (which in turn
-calls \fBfork\fR(2)), so tests that use it \fBcannot\fR treat SIGCHLD as an
-unexpected signal.
-.P
-Users may gain access to the name of the temporary directory by declaring the
-external character pointer \fBTESTDIR\fR.
-.SH DIAGNOSTICS
-The \fBtst_rmdir()\fR function will check the \fBTESTDIR\fR global variable
-to ensure that the user is not attempting to remove the root directory or
-some unspecified directories with a "*" parameter.  All error/warning
-messages are delivered through \fBtst_resm()\fR.
-.SH "SEE ALSO"
-fork(2), system(3S), tst_res(3), tmpnam(3S).
-
diff --git a/doc/old/man3/usctest.3 b/doc/old/man3/usctest.3
deleted file mode 100644
index df3c5ad12..000000000
--- a/doc/old/man3/usctest.3
+++ /dev/null
@@ -1,164 +0,0 @@
-.\" $Id: usctest.3,v 1.2 2000/08/31 18:40:28 nstraz Exp $
-.\"
-.\" Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
-.\"
-.\" This program is free software; you can redistribute it and/or modify it
-.\" under the terms of version 2 of the GNU General Public License as
-.\" published by the Free Software Foundation.
-.\"
-.\" This program is distributed in the hope that it would be useful, but
-.\" WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-.\"
-.\" Further, this software is distributed without any warranty that it is
-.\" free of the rightful claim of any third person regarding infringement
-.\" or the like.  Any license provided herein, whether implied or
-.\" otherwise, applies only to this software file.  Patent licenses, if
-.\" any, provided herein do not apply to combinations of this program with
-.\" other software, or any other product whatsoever.
-.\"
-.\" You should have received a copy of the GNU General Public License along
-.\" with this program; if not, write the Free Software Foundation, Inc.,
-.\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-.\"
-.\" Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
-.\" Mountain View, CA  94043, or:
-.\"
-.\" http://www.sgi.com
-.\"
-.\" For further information regarding this notice, see:
-.\"
-.\" http://oss.sgi.com/projects/GenInfo/NoticeExplan/
-.\"
-.TH USCTEST 3 01/21/2011 "Linux Test Project"
-.SH NAME
-usctest \-  macros and libraries for common functions in system call tests
-.SH SYNOPSIS
-\fBRoutines:\fR
-.br
-.in +1
-char *\fBparse_opts(\fI...\fB)\fR
-.in -1
-.sp
-\fBMacros\fR
-.in +1
-.br
-\fBTEST_PAUSE\fR
-.br
-\fBTEST(\fIsyscall\fB)\fR
-.br
-.\"\fBTEST_CALLER(\fIsyscall\fB, \fIpid\fB)\fR
-.\".br
-\fBTEST_VOID(\fIsyscall\fB)\fR
-.br
-\fBTEST_CLEANUP\fR
-.br
-\fBTEST_LOOPING(\fIcounter\fB)\fR
-.br
-\fBTEST_ERROR_LOG(\fIerrno\fB)\fR
-.br
-\fBTEST_EXP_ENOS(\fIarray\fB)\fR
-.in -1
-.sp
-\fBGlobal Variable(s)\fR (see \fBparse_opts(3)\fR for complete list):
-.br
-.in +1
-int \fBTEST_RETURN\fR;	/* set by the \fBTEST\fR macro to the return code from \fIsyscall\fR */
-.br
-int \fBTEST_ERRNO\fR;	/* set by the \fBTEST\fR macro to the value of \fBerrno\fR after \fIsyscall\fR returns */
-.br
-/* All STD_* variables referenced below are set by the \fBparse_opts(3)\fR routine. */
-.in -1
-
-.SH DESCRIPTION
-The \fBTEST_PAUSE\fR macro checks if the global variable STD_PAUSE is set.  If so, it
-pauses for a SIGUSR1 before continuing execution.  The signal handler used does nothing.
-After the signal is processed, the previous action is replaced for SIGUSR1.
-.sp
-The \fBTEST(\fIsyscall\fB)\fR macro executes (\fIsyscall\fR) and times its execution.
-It saves the max time, min time, accumulated time, and
-execution count, if STD_TIMING_ON is set.
-.sp
-.\"The\fBTEST_CALLER(\fIsyscall\fB, \fIpid\fB)\fR macro executes (\fIsyscall\fR) and times its execution.
-.\"It saves the max time, min time, accumulated time, and
-.\"execution count, if STD_TIMING_ON is set and if \fIpid\fR is equal to the current pid.
-.\".sp
-The \fBTEST_VOID(\fIsyscall\fB)\fR macro works exactly the same as the \fBTEST()\fR
-macro except that it does NOT set the global \fBTEST_RETURN\fR.  It is intended
-to be used with system calls that do not have a return value.
-.sp
-The \fBTEST_CLEANUP\fR macro prints timing statistics,
-accumulated through the TEST macro, if STD_TIMING_ON is set.  Also, prints the \fBerrno\fR return
-counts as logged by the \fBTEST_ERROR_LOG\fR macro, if STD_ERR_LOG is set.  \fBTEST_CLEANUP\fR uses
-\fBtst_resm(3)\fR to output this information.
-.sp
-The \fBTEST_LOOPING(\fIcounter\fB)\fR macro checks \fIcounter\fR against
-the global variable STD_LOOP_COUNTER.  If \fIcounter\fR is less than STD_LOOP_COUNTER or STD_INFINITE
-is set, it returns TRUE.
-.sp
-The \fBTEST_ERROR_LOG\fR macro records the return of \fIerrno\fR as unexpected, unless the option to
-turn it off is specified on the command line.
-.sp
-The \fBTEST_EXP_ENOS(\fIarray\fB)\fR macro sets an internal flag for each errno in \fIarray\fR, indicating
-that the errno is expected at some point in the test.  This is used by the TEST_CLEANUP macro to determine
-which errnos are expected when printing the log.  The \fIarray\fR must be zero terminated.
-.sp
-The \fBparse_opts\fR routine parses the command line (see \fBparse_opts(3)\fR).  All STD_* global
-variables used are set by the \fBparse_opts(3)\fR routine.
-
-.SH EXAMPLES
-Below is a partial template of a system call test using these routines, macros, and global variables.
-
-.nf
-void setup(void)
-{
-	TEST_PAUSE;	/* Pause  if option specified */
-}
-
-void cleanup(void)
-{
-	TEST_CLEANUP;
-}
-
-int main(int argc, char *argv[])
-{
-	int lc;
-	char *msg;
-
-	int exp_enos[]={EACCESS, 0};
-
-
-	TEST_EXP_ENOS(exp_enos);	/* set expected errnos */
-
-	setup();	/* execute setup */
-
-	/* parse options */
-	msg = parse_opts(ac, av, NULL, NULL);
-
-	/* Check parse_opts return */
-
-	for (lc=0; TEST_LOOPING(lc); lc++) {
-		TEST(open("file", O_RDWR))
-
-		if (TEST_RETURN == -1) {
-			TEST_ERROR_LOG(TEST_ERRNO)
-			/* BREAK test case, or whatever... */
-		}
-
-	}
-
-	cleanup();
-	tst_exit();
-}
-.fi
-
-.SH "SEE ALSO"
-parse_opts(3).
-
-.SH "RETURN VALUES"
-The TEST_LOOPING macro evaluates to TRUE (1) or FALSE (0), and is intended for
-use in while or for loops.  The TEST macro places the return value from
-\fIsyscall\fR in the global variable TEST_RETURN and the errno in the global
-variable TEST_ERRNO.  The \fBTEST_PAUSE\fR, \fBTEST_CLEANUP\fR,
-\fBTEST_ERROR_LOG\fR, and \fBTEST_EXP_ENOS\fR macros do not have any return
-values.
diff --git a/doc/old/rules.tsv b/doc/old/rules.tsv
deleted file mode 100644
index 66dbdeccf..000000000
--- a/doc/old/rules.tsv
+++ /dev/null
@@ -1,6 +0,0 @@
-ID	DESCRIPTION
-LTP-001	Library source files have tst_ prefix
-LTP-002	TST_RET and TST_ERR are never modified by test library functions
-LTP-003 Externally visible library symbols have the tst_ prefix
-LTP-004 Test executable symbols are marked static
-LTP-005 Array must terminate with a sentinel value (i.e. NULL or '{}')
diff --git a/doc/users/quick_start.rst b/doc/users/quick_start.rst
index 4a48745be..8a25b9129 100644
--- a/doc/users/quick_start.rst
+++ b/doc/users/quick_start.rst
@@ -17,7 +17,7 @@ Basics requirements to build LTP are the following:
 
 .. code-block:: console
 
-   $ git clone https://github.com/linux-test-project/ltp.git
+   $ git clone --recurse-submodules https://github.com/linux-test-project/ltp.git
    $ cd ltp
    $ make autotools
    $ ./configure
@@ -53,6 +53,7 @@ generated first:
 
 .. code-block:: console
 
+   $ ./configure --with-open-posix-testsuite
    $ cd testcases/open_posix_testsuite/
    $ make generate-makefiles
    $ cd conformance/interfaces/foo
diff --git a/doc/users/setup_tests.rst b/doc/users/setup_tests.rst
index c5f82e627..721ec6bb5 100644
--- a/doc/users/setup_tests.rst
+++ b/doc/users/setup_tests.rst
@@ -80,17 +80,21 @@ users.
    * - LTP_ENABLE_DEBUG
      - Enable debug info (value ``1`` or ``y``). Equivalent of ``-D`` parameter.
 
+Environment variables for network tests
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+See :master:`testcases/network/README.md`.
+
 Test execution time and timeout
 -------------------------------
 
-The limit on how long a test can run does compose of two parts: ``max_runtime``
+The limit on how long a test can run does compose of two parts: ``runtime``
 and ``timeout``. The limit does apply to a single test variant. That means, for
 example, that tests which run for all available filesystems will apply this
 limit for a single filesystem only.
 
-The ``max_runtime`` is a cap on how long the ``run()`` function can take and for
+The ``runtime`` is a cap on how long the ``run()`` function can take and for
 most testcases this part is set to zero. For tests that do run for more than a
-second or two the ``max_runtime`` has to be defined and the ``run()`` function
+second or two the ``runtime`` has to be defined and the ``run()`` function
 has to check actively how much runtime is left.
 
 Test runtime can be scaled up and down with ``LTP_RUNTIME_MUL`` environment
diff --git a/docparse/testinfo.pl b/docparse/testinfo.pl
index 78433c40a..487b7d5f2 100755
--- a/docparse/testinfo.pl
+++ b/docparse/testinfo.pl
@@ -408,7 +408,11 @@ sub content_all_tests
 				# two dimensional array
 				if (ref(@$v[0]) eq 'ARRAY') {
 					for my $v2 (@$v) {
-						$content .= paragraph(table_escape(join(' ', @$v2)));
+						# convert NULL to "NULL" string to be printed
+						for my $v3 (@$v2) {
+							$v3 = "NULL" if (!defined $v3);
+						}
+						$content .= paragraph(table_escape(join(', ', @$v2)));
 					}
 				} else {
 					# one dimensional array
diff --git a/gen.bp b/gen.bp
index ff438f92d..251c3dec1 100644
--- a/gen.bp
+++ b/gen.bp
@@ -171,7 +171,7 @@ cc_library_static {
         "include/old",
     ],
     srcs: [
-        "libs/libltpnewipc/libnewipc.c",
+        "libs/newipc/libnewipc.c",
     ],
 }
 
@@ -183,7 +183,7 @@ cc_library_static {
         "include/old",
     ],
     srcs: [
-        "libs/libltpnuma/tst_numa.c",
+        "libs/numa/tst_numa.c",
     ],
 }
 
@@ -195,7 +195,7 @@ cc_library_static {
         "include/old",
     ],
     srcs: [
-        "libs/libltpsigwait/sigwait.c",
+        "libs/sigwait/sigwait.c",
     ],
 }
 
@@ -207,7 +207,7 @@ cc_library_static {
         "include/old",
     ],
     srcs: [
-        "libs/libltpswap/libswap.c",
+        "libs/swap/libswap.c",
     ],
 }
 
@@ -219,7 +219,7 @@ cc_library_static {
         "include/old",
     ],
     srcs: [
-        "libs/libltpuinput/tst_uinput.c",
+        "libs/uinput/tst_uinput.c",
     ],
 }
 
@@ -231,8 +231,8 @@ cc_library_static {
         "include/old",
     ],
     srcs: [
-        "libs/libltpvdso/parse_vdso.c",
-        "libs/libltpvdso/vdso_helpers.c",
+        "libs/vdso/parse_vdso.c",
+        "libs/vdso/vdso_helpers.c",
     ],
 }
 
@@ -250,6 +250,38 @@ cc_library_static {
     ],
 }
 
+cc_library_static {
+    name: "libltp_realtime",
+    defaults: ["ltp_defaults"],
+    local_include_dirs: [
+        "include",
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    cflags: [
+        "-D_GNU_SOURCE",
+    ],
+    srcs: [
+        "testcases/realtime/lib/librttest.c",
+        "testcases/realtime/lib/libstats.c",
+    ],
+}
+
+cc_library_static {
+    name: "libltp_ujson",
+    defaults: ["ltp_defaults"],
+    local_include_dirs: [
+        "include",
+        "include/old",
+    ],
+    srcs: [
+        "libs/ujson/ujson_common.c",
+        "libs/ujson/ujson_reader.c",
+        "libs/ujson/ujson_utf.c",
+        "libs/ujson/ujson_writer.c",
+    ],
+}
+
 cc_test {
     name: "ltp_abort01",
     stem: "abort01",
@@ -661,6 +693,32 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_async_handler",
+    stem: "async_handler",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/async_handler/async_handler.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_async_handler_jk",
+    stem: "async_handler_jk",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/async_handler/async_handler_jk.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_atof01",
     stem: "atof01",
@@ -876,6 +934,33 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_cachestat01",
+    stem: "cachestat01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/cachestat/cachestat01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_cachestat03",
+    stem: "cachestat03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/cachestat/cachestat03.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_cachestat04",
+    stem: "cachestat04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/cachestat/cachestat04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_can_bcm01",
     stem: "can_bcm01",
@@ -1166,6 +1251,24 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_chmod08",
+    stem: "chmod08",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/chmod/chmod08.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_chmod09",
+    stem: "chmod09",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/chmod/chmod09.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_chown01",
     stem: "chown01",
@@ -3613,6 +3716,24 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_fchmodat2_01",
+    stem: "fchmodat2_01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/fchmodat2/fchmodat2_01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_fchmodat2_02",
+    stem: "fchmodat2_02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/fchmodat2/fchmodat2_02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_fchown01",
     stem: "fchown01",
@@ -5569,6 +5690,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_fsplough",
+    stem: "fsplough",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/fs/fsplough/fsplough.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_fsstress",
     stem: "fsstress",
@@ -6404,6 +6534,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_getcpu02",
+    stem: "getcpu02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/getcpu/getcpu02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_getcwd01",
     stem: "getcwd01",
@@ -7279,6 +7418,32 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_gtod_infinite",
+    stem: "gtod_infinite",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/gtod_latency/gtod_infinite.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_gtod_latency",
+    stem: "gtod_latency",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/gtod_latency/gtod_latency.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_hackbench",
     stem: "hackbench",
@@ -7297,6 +7462,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_hrtimer-prio",
+    stem: "hrtimer-prio",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/hrtimer-prio/hrtimer-prio.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_ht_affinity",
     stem: "ht_affinity",
@@ -7948,6 +8126,44 @@ cc_test {
     ],
 }
 
+cc_test {
+    name: "ltp_hugemmap34",
+    stem: "hugemmap34",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/mem/hugetlb/hugemmap/hugemmap34.c"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/include",
+        "testcases/kernel/mem/hugetlb/lib",
+        "testcases/kernel/mem/include",
+    ],
+    static_libs: [
+        "libltp_hugetlb",
+        "libltp_kerntest",
+        "libltp_ltp",
+        "libltp_mem",
+    ],
+}
+
+cc_test {
+    name: "ltp_hugeshmget06",
+    stem: "hugeshmget06",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/mem/hugetlb/hugeshmget/hugeshmget06.c"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/include",
+        "testcases/kernel/mem/hugetlb/lib",
+        "testcases/kernel/mem/include",
+    ],
+    static_libs: [
+        "libltp_hugetlb",
+        "libltp_kerntest",
+        "libltp_ltp",
+        "libltp_mem",
+    ],
+}
+
 cc_test {
     name: "ltp_icmp_rate_limit01",
     stem: "icmp_rate_limit01",
@@ -8176,60 +8392,60 @@ cc_test {
     name: "ltp_input01",
     stem: "input01",
     defaults: ["ltp_test_defaults"],
-    srcs: [
-        "testcases/kernel/input/input01.c",
-        "testcases/kernel/input/input_helper.c",
-    ],
+    srcs: ["testcases/kernel/input/input01.c"],
     local_include_dirs: ["include/old"],
-    static_libs: ["libltp_ltp"],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_ltpuinput",
+    ],
 }
 
 cc_test {
     name: "ltp_input02",
     stem: "input02",
     defaults: ["ltp_test_defaults"],
-    srcs: [
-        "testcases/kernel/input/input02.c",
-        "testcases/kernel/input/input_helper.c",
-    ],
+    srcs: ["testcases/kernel/input/input02.c"],
     local_include_dirs: ["include/old"],
-    static_libs: ["libltp_ltp"],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_ltpuinput",
+    ],
 }
 
 cc_test {
     name: "ltp_input04",
     stem: "input04",
     defaults: ["ltp_test_defaults"],
-    srcs: [
-        "testcases/kernel/input/input04.c",
-        "testcases/kernel/input/input_helper.c",
-    ],
+    srcs: ["testcases/kernel/input/input04.c"],
     local_include_dirs: ["include/old"],
-    static_libs: ["libltp_ltp"],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_ltpuinput",
+    ],
 }
 
 cc_test {
     name: "ltp_input05",
     stem: "input05",
     defaults: ["ltp_test_defaults"],
-    srcs: [
-        "testcases/kernel/input/input05.c",
-        "testcases/kernel/input/input_helper.c",
-    ],
+    srcs: ["testcases/kernel/input/input05.c"],
     local_include_dirs: ["include/old"],
-    static_libs: ["libltp_ltp"],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_ltpuinput",
+    ],
 }
 
 cc_test {
     name: "ltp_input06",
     stem: "input06",
     defaults: ["ltp_test_defaults"],
-    srcs: [
-        "testcases/kernel/input/input06.c",
-        "testcases/kernel/input/input_helper.c",
-    ],
+    srcs: ["testcases/kernel/input/input06.c"],
     local_include_dirs: ["include/old"],
-    static_libs: ["libltp_ltp"],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_ltpuinput",
+    ],
 }
 
 cc_test {
@@ -8448,6 +8664,60 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_ioctl_ficlone01",
+    stem: "ioctl_ficlone01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/ioctl/ioctl_ficlone01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ioctl_ficlone02",
+    stem: "ioctl_ficlone02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/ioctl/ioctl_ficlone02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ioctl_ficlone03",
+    stem: "ioctl_ficlone03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/ioctl/ioctl_ficlone03.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ioctl_ficlone04",
+    stem: "ioctl_ficlone04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/ioctl/ioctl_ficlone04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ioctl_ficlonerange01",
+    stem: "ioctl_ficlonerange01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/ioctl/ioctl_ficlonerange01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ioctl_ficlonerange02",
+    stem: "ioctl_ficlonerange02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/ioctl/ioctl_ficlonerange02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_ioctl_loop01",
     stem: "ioctl_loop01",
@@ -9017,55 +9287,136 @@ cc_test {
 }
 
 cc_test {
-    name: "ltp_lchown01",
-    stem: "lchown01",
+    name: "ltp_landlock01",
+    stem: "landlock01",
     defaults: ["ltp_test_defaults"],
-    srcs: ["testcases/kernel/syscalls/lchown/lchown01.c"],
-    local_include_dirs: [
-        "include/old",
-        "testcases/kernel/syscalls/lchown",
-        "testcases/kernel/syscalls/utils",
-    ],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock01.c"],
+    local_include_dirs: ["include/old"],
     static_libs: ["libltp_ltp"],
 }
 
 cc_test {
-    name: "ltp_lchown01_16",
-    stem: "lchown01_16",
+    name: "ltp_landlock02",
+    stem: "landlock02",
     defaults: ["ltp_test_defaults"],
-    srcs: ["testcases/kernel/syscalls/lchown/lchown01.c"],
-    cflags: ["-DTST_USE_COMPAT16_SYSCALL=1"],
-    local_include_dirs: [
-        "include/old",
-        "testcases/kernel/syscalls/lchown",
-        "testcases/kernel/syscalls/utils",
-    ],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock02.c"],
+    local_include_dirs: ["include/old"],
     static_libs: ["libltp_ltp"],
 }
 
 cc_test {
-    name: "ltp_lchown02",
-    stem: "lchown02",
+    name: "ltp_landlock03",
+    stem: "landlock03",
     defaults: ["ltp_test_defaults"],
-    srcs: ["testcases/kernel/syscalls/lchown/lchown02.c"],
-    local_include_dirs: [
-        "include/old",
-        "testcases/kernel/syscalls/lchown",
-        "testcases/kernel/syscalls/utils",
-    ],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock03.c"],
+    local_include_dirs: ["include/old"],
     static_libs: ["libltp_ltp"],
 }
 
 cc_test {
-    name: "ltp_lchown02_16",
-    stem: "lchown02_16",
+    name: "ltp_landlock04",
+    stem: "landlock04",
     defaults: ["ltp_test_defaults"],
-    srcs: ["testcases/kernel/syscalls/lchown/lchown02.c"],
-    cflags: ["-DTST_USE_COMPAT16_SYSCALL=1"],
-    local_include_dirs: [
-        "include/old",
-        "testcases/kernel/syscalls/lchown",
-        "testcases/kernel/syscalls/utils",
+    srcs: ["testcases/kernel/syscalls/landlock/landlock04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_landlock05",
+    stem: "landlock05",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock05.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_landlock06",
+    stem: "landlock06",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock06.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_landlock07",
+    stem: "landlock07",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock07.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_landlock08",
+    stem: "landlock08",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock08.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_landlock_exec",
+    stem: "landlock_exec",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/landlock/landlock_exec.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_lchown01",
+    stem: "lchown01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/lchown/lchown01.c"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/lchown",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_lchown01_16",
+    stem: "lchown01_16",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/lchown/lchown01.c"],
+    cflags: ["-DTST_USE_COMPAT16_SYSCALL=1"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/lchown",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_lchown02",
+    stem: "lchown02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/lchown/lchown02.c"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/lchown",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_lchown02_16",
+    stem: "lchown02_16",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/lchown/lchown02.c"],
+    cflags: ["-DTST_USE_COMPAT16_SYSCALL=1"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/lchown",
+        "testcases/kernel/syscalls/utils",
     ],
     static_libs: ["libltp_ltp"],
 }
@@ -9200,6 +9551,42 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_listmount01",
+    stem: "listmount01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/listmount/listmount01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_listmount02",
+    stem: "listmount02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/listmount/listmount02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_listmount03",
+    stem: "listmount03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/listmount/listmount03.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_listmount04",
+    stem: "listmount04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/listmount/listmount04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_listxattr01",
     stem: "listxattr01",
@@ -9305,6 +9692,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_lookup_pi_state",
+    stem: "lookup_pi_state",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/stress/pi-tests/lookup_pi_state.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_lremovexattr01",
     stem: "lremovexattr01",
@@ -9410,6 +9810,36 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_lstat03",
+    stem: "lstat03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/lstat/lstat03.c"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/lstat",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_lstat03_64",
+    stem: "lstat03_64",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/lstat/lstat03.c"],
+    cflags: [
+        "-DTST_USE_NEWER64_SYSCALL=1",
+        "-D_FILE_OFFSET_BITS=64",
+    ],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/lstat",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_ltpClient",
     stem: "ltpClient",
@@ -9518,6 +9948,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_madvise12",
+    stem: "madvise12",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/madvise/madvise12.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_mallinfo01",
     stem: "mallinfo01",
@@ -9548,6 +9987,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_matrix_mult",
+    stem: "matrix_mult",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/matrix_mult/matrix_mult.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_max_map_count",
     stem: "max_map_count",
@@ -11030,6 +11482,24 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_mseal01",
+    stem: "mseal01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/mseal/mseal01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_mseal02",
+    stem: "mseal02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/mseal/mseal02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_msgget05",
     stem: "msgget05",
@@ -11736,6 +12206,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_open15",
+    stem: "open15",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/open/open15.c"],
+    cflags: [
+        "-D_FILE_OFFSET_BITS=64",
+        "-D_LARGEFILE_SOURCE",
+    ],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_open_by_handle_at01",
     stem: "open_by_handle_at01",
@@ -11988,6 +12471,32 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_periodic_cpu_load",
+    stem: "periodic_cpu_load",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/periodic_cpu_load/periodic_cpu_load.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_periodic_cpu_load_single",
+    stem: "periodic_cpu_load_single",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/periodic_cpu_load/periodic_cpu_load_single.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_personality01",
     stem: "personality01",
@@ -12006,6 +12515,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_pi_perf",
+    stem: "pi_perf",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pi_perf/pi_perf.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_pidfd_getfd01",
     stem: "pidfd_getfd01",
@@ -12483,15 +13005,6 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
-cc_test {
-    name: "ltp_prctl04",
-    stem: "prctl04",
-    defaults: ["ltp_test_defaults"],
-    srcs: ["testcases/kernel/syscalls/prctl/prctl04.c"],
-    local_include_dirs: ["include/old"],
-    static_libs: ["libltp_ltp"],
-}
-
 cc_test {
     name: "ltp_prctl05",
     stem: "prctl05",
@@ -12805,6 +13318,32 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_prio-preempt",
+    stem: "prio-preempt",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/prio-preempt/prio-preempt.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_prio-wake",
+    stem: "prio-wake",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/prio-wake/prio-wake.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_proc01",
     stem: "proc01",
@@ -12976,6 +13515,51 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_ptem02",
+    stem: "ptem02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/ptem02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ptem03",
+    stem: "ptem03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/ptem03.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ptem04",
+    stem: "ptem04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/ptem04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ptem05",
+    stem: "ptem05",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/ptem05.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_ptem06",
+    stem: "ptem06",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/ptem06.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_pth_str01",
     stem: "pth_str01",
@@ -13016,6 +13600,45 @@ cc_test {
     local_include_dirs: ["include/old"],
 }
 
+cc_test {
+    name: "ltp_pthread_cond_latency",
+    stem: "pthread_cond_latency",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/perf/latency/pthread_cond_latency.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_pthread_cond_many",
+    stem: "pthread_cond_many",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/perf/latency/pthread_cond_many.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_pthread_kill_latency",
+    stem: "pthread_kill_latency",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pthread_kill_latency/pthread_kill_latency.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_pthserv",
     stem: "pthserv",
@@ -13182,6 +13805,24 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_pty08",
+    stem: "pty08",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/pty08.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_pty09",
+    stem: "pty09",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/pty/pty09.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_pwrite01",
     stem: "pwrite01",
@@ -13903,6 +14544,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_rename15",
+    stem: "rename15",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/rename/rename15.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_renameat01",
     stem: "renameat01",
@@ -13975,6 +14625,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_request_key06",
+    stem: "request_key06",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/request_key/request_key06.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_rmdir01",
     stem: "rmdir01",
@@ -14011,6 +14670,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_rt-migrate",
+    stem: "rt-migrate",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/rt-migrate/rt-migrate.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_rt_sigaction01",
     stem: "rt_sigaction01",
@@ -14075,6 +14747,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_rt_sigqueueinfo02",
+    stem: "rt_sigqueueinfo02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/rt_sigqueueinfo/rt_sigqueueinfo02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_rt_sigsuspend01",
     stem: "rt_sigsuspend01",
@@ -14201,6 +14882,22 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_sched_football",
+    stem: "sched_football",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/sched_football/sched_football.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_realtime",
+    ],
+}
+
 cc_test {
     name: "ltp_sched_get_priority_max01",
     stem: "sched_get_priority_max01",
@@ -14300,6 +14997,32 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_sched_jitter",
+    stem: "sched_jitter",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/sched_jitter/sched_jitter.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_sched_latency",
+    stem: "sched_latency",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/sched_latency/sched_latency.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_sched_latency_dl",
     stem: "sched_latency_dl",
@@ -14580,6 +15303,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_seccomp01",
+    stem: "seccomp01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/seccomp/seccomp01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_select01",
     stem: "select01",
@@ -16383,6 +17115,69 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_shell_c_child",
+    stem: "shell_c_child",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_c_child.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shell_test01",
+    stem: "shell_test01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_test01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shell_test02",
+    stem: "shell_test02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_test02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shell_test03",
+    stem: "shell_test03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_test03.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shell_test04",
+    stem: "shell_test04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_test04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shell_test05",
+    stem: "shell_test05",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_test05.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shell_test06",
+    stem: "shell_test06",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tests/shell_test06.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_shmat04",
     stem: "shmat04",
@@ -16395,6 +17190,24 @@ cc_test {
     ],
 }
 
+cc_test {
+    name: "ltp_shutdown01",
+    stem: "shutdown01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/shutdown/shutdown01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_shutdown02",
+    stem: "shutdown02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/shutdown/shutdown02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_sigaction01",
     stem: "sigaction01",
@@ -16511,6 +17324,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_signalfd02",
+    stem: "signalfd02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/signalfd/signalfd02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_signalfd4_01",
     stem: "signalfd4_01",
@@ -16566,6 +17388,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_sigsuspend02",
+    stem: "sigsuspend02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/sigsuspend/sigsuspend02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_sigtimedwait01",
     stem: "sigtimedwait01",
@@ -16924,6 +17755,36 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_stat04",
+    stem: "stat04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/stat/stat04.c"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/stat",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_stat04_64",
+    stem: "stat04_64",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/stat/stat04.c"],
+    cflags: [
+        "-DTST_USE_NEWER64_SYSCALL=1",
+        "-D_FILE_OFFSET_BITS=64",
+    ],
+    local_include_dirs: [
+        "include/old",
+        "testcases/kernel/syscalls/stat",
+        "testcases/kernel/syscalls/utils",
+    ],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_statfs01",
     stem: "statfs01",
@@ -17014,6 +17875,78 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_statmount01",
+    stem: "statmount01",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount01.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount02",
+    stem: "statmount02",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount02.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount03",
+    stem: "statmount03",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount03.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount04",
+    stem: "statmount04",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount04.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount05",
+    stem: "statmount05",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount05.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount06",
+    stem: "statmount06",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount06.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount07",
+    stem: "statmount07",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount07.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
+cc_test {
+    name: "ltp_statmount08",
+    stem: "statmount08",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/statmount/statmount08.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_statvfs01",
     stem: "statvfs01",
@@ -17535,6 +18468,19 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_tc-2",
+    stem: "tc-2",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/thread_clock/tc-2.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_tcindex01",
     stem: "tcindex01",
@@ -19607,14 +20553,6 @@ sh_test {
     compile_multilib: "both",
 }
 
-sh_test {
-    name: "ltp_testcases_bin_ftp01.sh",
-    src: "testcases/network/tcp_cmds/ftp/ftp01.sh",
-    sub_dir: "vts_ltp_tests/testcases/bin",
-    filename: "ftp01.sh",
-    compile_multilib: "both",
-}
-
 sh_test {
     name: "ltp_testcases_bin_ftrace_lib.sh",
     src: "testcases/kernel/tracing/ftrace_test/ftrace_lib.sh",
@@ -20855,6 +21793,14 @@ sh_test {
     compile_multilib: "both",
 }
 
+sh_test {
+    name: "ltp_testcases_bin_nfs10.sh",
+    src: "testcases/network/nfs/nfs_stress/nfs10.sh",
+    sub_dir: "vts_ltp_tests/testcases/bin",
+    filename: "nfs10.sh",
+    compile_multilib: "both",
+}
+
 sh_test {
     name: "ltp_testcases_bin_nfs_lib.sh",
     src: "testcases/network/nfs/nfs_stress/nfs_lib.sh",
@@ -20879,6 +21825,14 @@ sh_test {
     compile_multilib: "both",
 }
 
+sh_test {
+    name: "ltp_testcases_bin_nfsstat02.sh",
+    src: "testcases/network/nfs/nfsstat01/nfsstat02.sh",
+    sub_dir: "vts_ltp_tests/testcases/bin",
+    filename: "nfsstat02.sh",
+    compile_multilib: "both",
+}
+
 sh_test {
     name: "ltp_testcases_bin_nft01.sh",
     src: "testcases/network/iptables/nft01.sh",
@@ -21167,6 +22121,14 @@ sh_test {
     compile_multilib: "both",
 }
 
+sh_test {
+    name: "ltp_testcases_bin_run_tests.sh",
+    src: "testcases/lib/run_tests.sh",
+    sub_dir: "vts_ltp_tests/testcases/bin",
+    filename: "run_tests.sh",
+    compile_multilib: "both",
+}
+
 sh_test {
     name: "ltp_testcases_bin_runpwtests01.sh",
     src: "testcases/kernel/power_management/runpwtests01.sh",
@@ -24031,6 +24993,22 @@ sh_test {
     compile_multilib: "both",
 }
 
+sh_test {
+    name: "ltp_testcases_bin_tst_env.sh",
+    src: "testcases/lib/tst_env.sh",
+    sub_dir: "vts_ltp_tests/testcases/bin",
+    filename: "tst_env.sh",
+    compile_multilib: "both",
+}
+
+sh_test {
+    name: "ltp_testcases_bin_tst_loader.sh",
+    src: "testcases/lib/tst_loader.sh",
+    sub_dir: "vts_ltp_tests/testcases/bin",
+    filename: "tst_loader.sh",
+    compile_multilib: "both",
+}
+
 sh_test {
     name: "ltp_testcases_bin_tst_net.sh",
     src: "testcases/lib/tst_net.sh",
@@ -24679,6 +25657,84 @@ sh_test {
     compile_multilib: "both",
 }
 
+cc_test {
+    name: "ltp_testpi-1",
+    stem: "testpi-1",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pi-tests/testpi-1.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_testpi-2",
+    stem: "testpi-2",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pi-tests/testpi-2.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_testpi-3",
+    stem: "testpi-3",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/stress/pi-tests/testpi-3.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_testpi-4",
+    stem: "testpi-4",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pi-tests/testpi-4.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_testpi-5",
+    stem: "testpi-5",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pi-tests/testpi-5.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
+cc_test {
+    name: "ltp_testpi-7",
+    stem: "testpi-7",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/realtime/func/pi-tests/testpi-7.c"],
+    cflags: ["-D_GNU_SOURCE"],
+    local_include_dirs: [
+        "include/old",
+        "testcases/realtime/include",
+    ],
+    static_libs: ["libltp_realtime"],
+}
+
 cc_test {
     name: "ltp_testsf_c",
     stem: "testsf_c",
@@ -25656,6 +26712,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_tst_res_",
+    stem: "tst_res_",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tst_res_.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_tst_res_flags",
     stem: "tst_res_flags",
@@ -25693,6 +26758,18 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_tst_run_shell",
+    stem: "tst_run_shell",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/lib/tst_run_shell.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: [
+        "libltp_ltp",
+        "libltp_ujson",
+    ],
+}
+
 cc_test {
     name: "ltp_tst_safe_fileops",
     stem: "tst_safe_fileops",
@@ -25958,6 +27035,15 @@ cc_test {
     static_libs: ["libltp_ltp"],
 }
 
+cc_test {
+    name: "ltp_unlink10",
+    stem: "unlink10",
+    defaults: ["ltp_test_defaults"],
+    srcs: ["testcases/kernel/syscalls/unlink/unlink10.c"],
+    local_include_dirs: ["include/old"],
+    static_libs: ["libltp_ltp"],
+}
+
 cc_test {
     name: "ltp_unlinkat01",
     stem: "unlinkat01",
diff --git a/include/lapi/capability.h b/include/lapi/capability.h
index 2b593797c..14d2d3c12 100644
--- a/include/lapi/capability.h
+++ b/include/lapi/capability.h
@@ -20,6 +20,10 @@
 # endif
 #endif
 
+#ifndef CAP_NET_BIND_SERVICE
+# define CAP_NET_BIND_SERVICE 10
+#endif
+
 #ifndef CAP_NET_RAW
 # define CAP_NET_RAW          13
 #endif
@@ -44,14 +48,18 @@
 # define CAP_SYS_TIME         25
 #endif
 
-#ifndef CAP_AUDIT_READ
-# define CAP_AUDIT_READ       37
-#endif
-
 #ifndef CAP_SYS_RESOURCE
 # define CAP_SYS_RESOURCE     24
 #endif
 
+#ifndef CAP_MKNOD
+# define CAP_MKNOD            27
+#endif
+
+#ifndef CAP_AUDIT_READ
+# define CAP_AUDIT_READ       37
+#endif
+
 #ifndef CAP_BPF
 # define CAP_BPF              39
 #endif
diff --git a/include/lapi/ficlone.h b/include/lapi/ficlone.h
new file mode 100644
index 000000000..221673313
--- /dev/null
+++ b/include/lapi/ficlone.h
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ * Copyright (C) 2024 Cyril Hrubis <chrubis@suse.cz>
+ */
+
+#ifndef LAPI_FICLONE_H__
+#define LAPI_FICLONE_H__
+
+#include "config.h"
+#include <linux/fs.h>
+#include <stdint.h>
+
+#ifndef HAVE_STRUCT_FILE_CLONE_RANGE
+struct file_clone_range {
+	int64_t src_fd;
+	uint64_t src_offset;
+	uint64_t src_length;
+	uint64_t dest_offset;
+};
+#endif
+
+#ifndef FICLONE
+# define FICLONE		_IOW(0x94, 9, int)
+#endif
+
+#ifndef FICLONERANGE
+# define FICLONERANGE		_IOW(0x94, 13, struct file_clone_range)
+#endif
+
+#endif /* LAPI_FICLONE_H__ */
diff --git a/include/lapi/fs.h b/include/lapi/fs.h
index 635979b02..8261ca41d 100644
--- a/include/lapi/fs.h
+++ b/include/lapi/fs.h
@@ -11,9 +11,7 @@
 
 #include "config.h"
 #ifndef HAVE_MOUNT_SETATTR
-# ifdef HAVE_LINUX_FS_H
-#  include <linux/fs.h>
-# endif
+# include <linux/fs.h>
 #endif
 
 #include <sys/user.h>
diff --git a/include/lapi/keyctl.h b/include/lapi/keyctl.h
index 3be782494..e08b8f132 100644
--- a/include/lapi/keyctl.h
+++ b/include/lapi/keyctl.h
@@ -116,6 +116,10 @@ static inline key_serial_t keyctl_join_session_keyring(const char *name) {
 # define KEYCTL_SETPERM 5
 #endif
 
+#ifndef KEYCTL_DESCRIBE
+# define KEYCTL_DESCRIBE 6
+#endif
+
 #ifndef KEYCTL_CLEAR
 # define KEYCTL_CLEAR 7
 #endif
@@ -124,6 +128,10 @@ static inline key_serial_t keyctl_join_session_keyring(const char *name) {
 # define KEYCTL_UNLINK 9
 #endif
 
+#ifndef KEYCTL_SEARCH
+# define KEYCTL_SEARCH 10
+#endif
+
 #ifndef KEYCTL_READ
 # define KEYCTL_READ 11
 #endif
@@ -136,10 +144,26 @@ static inline key_serial_t keyctl_join_session_keyring(const char *name) {
 # define KEYCTL_SET_TIMEOUT 15
 #endif
 
+#ifndef KEYCTL_ASSUME_AUTHORITY
+# define KEYCTL_ASSUME_AUTHORITY 16
+#endif
+
+#ifndef KEYCTL_GET_SECURITY
+# define KEYCTL_GET_SECURITY 17
+#endif
+
 #ifndef KEYCTL_INVALIDATE
 # define KEYCTL_INVALIDATE 21
 #endif
 
+#ifndef KEYCTL_GET_PERSISTENT
+# define KEYCTL_GET_PERSISTENT 22
+#endif
+
+#ifndef KEYCTL_DH_COMPUTE
+# define KEYCTL_DH_COMPUTE 23
+#endif
+
 #ifndef KEYCTL_WATCH_KEY
 # define KEYCTL_WATCH_KEY 32
 #endif
@@ -179,4 +203,53 @@ static inline key_serial_t keyctl_join_session_keyring(const char *name) {
 # define KEY_OTH_ALL     0x0000003f
 #endif /* !KEY_POS_VIEW */
 
+static inline long safe_keyctl(const char *file, const int lineno,
+	int cmd, unsigned long arg2, unsigned long arg3,
+	unsigned long arg4, unsigned long arg5)
+{
+	long rval;
+	int failure = 0;
+
+	rval = keyctl(cmd, arg2, arg3, arg4, arg5);
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"keyctl(%d, %lu, %lu, %lu, %lu)",
+			cmd, arg2, arg3, arg4, arg5);
+	}
+
+	switch (cmd) {
+	case KEYCTL_GET_KEYRING_ID:
+	case KEYCTL_JOIN_SESSION_KEYRING:
+	case KEYCTL_DESCRIBE:
+	case KEYCTL_SEARCH:
+	case KEYCTL_READ:
+	case KEYCTL_SET_REQKEY_KEYRING:
+	case KEYCTL_GET_SECURITY:
+	case KEYCTL_GET_PERSISTENT:
+	case KEYCTL_DH_COMPUTE:
+		if (rval < 0)
+			failure = 1;
+		break;
+	case KEYCTL_ASSUME_AUTHORITY:
+		if ((!arg2 && rval) || (arg2 && rval < 0))
+			failure = 1;
+		break;
+	default:
+		if (rval)
+			failure = 1;
+		break;
+	}
+
+	if (failure) {
+		tst_brk_(file, lineno, TBROK,
+			"keyctl(%d, %lu, %lu, %lu, %lu) returned %ld",
+			cmd, arg2, arg3, arg4, arg5, rval);
+	}
+
+	return rval;
+}
+#define SAFE_KEYCTL(cmd, arg2, arg3, arg4, arg5) \
+	safe_keyctl(__FILE__, __LINE__, \
+	     (cmd), (arg2), (arg3), (arg4), (arg5))
+
 #endif	/* LAPI_KEYCTL_H__ */
diff --git a/include/lapi/landlock.h b/include/lapi/landlock.h
new file mode 100644
index 000000000..b3c8c548e
--- /dev/null
+++ b/include/lapi/landlock.h
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef LAPI_LANDLOCK_H__
+#define LAPI_LANDLOCK_H__
+
+#include "config.h"
+#include <stdint.h>
+
+#ifdef HAVE_LINUX_LANDLOCK_H
+# include <linux/landlock.h>
+#endif
+
+#include "lapi/syscalls.h"
+
+struct tst_landlock_ruleset_attr_abi1
+{
+	uint64_t handled_access_fs;
+};
+
+struct tst_landlock_ruleset_attr_abi4
+{
+	uint64_t handled_access_fs;
+	uint64_t handled_access_net;
+};
+
+#ifndef HAVE_STRUCT_LANDLOCK_PATH_BENEATH_ATTR
+struct landlock_path_beneath_attr
+{
+	uint64_t allowed_access;
+	int32_t parent_fd;
+} __attribute__((packed));
+#endif
+
+#if !HAVE_DECL_LANDLOCK_RULE_PATH_BENEATH
+# define LANDLOCK_RULE_PATH_BENEATH 1
+#endif
+
+#if !HAVE_DECL_LANDLOCK_RULE_NET_PORT
+# define LANDLOCK_RULE_NET_PORT 2
+#endif
+
+#ifndef HAVE_STRUCT_LANDLOCK_NET_PORT_ATTR
+struct landlock_net_port_attr
+{
+	uint64_t allowed_access;
+	uint64_t port;
+};
+#endif
+
+#ifndef LANDLOCK_CREATE_RULESET_VERSION
+# define LANDLOCK_CREATE_RULESET_VERSION	(1U << 0)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_EXECUTE
+# define LANDLOCK_ACCESS_FS_EXECUTE			(1ULL << 0)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_WRITE_FILE
+# define LANDLOCK_ACCESS_FS_WRITE_FILE		(1ULL << 1)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_READ_FILE
+# define LANDLOCK_ACCESS_FS_READ_FILE		(1ULL << 2)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_READ_DIR
+# define LANDLOCK_ACCESS_FS_READ_DIR		(1ULL << 3)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_REMOVE_DIR
+# define LANDLOCK_ACCESS_FS_REMOVE_DIR		(1ULL << 4)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_REMOVE_FILE
+# define LANDLOCK_ACCESS_FS_REMOVE_FILE		(1ULL << 5)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_CHAR
+# define LANDLOCK_ACCESS_FS_MAKE_CHAR		(1ULL << 6)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_DIR
+# define LANDLOCK_ACCESS_FS_MAKE_DIR		(1ULL << 7)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_REG
+# define LANDLOCK_ACCESS_FS_MAKE_REG		(1ULL << 8)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_SOCK
+# define LANDLOCK_ACCESS_FS_MAKE_SOCK		(1ULL << 9)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_FIFO
+# define LANDLOCK_ACCESS_FS_MAKE_FIFO		(1ULL << 10)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_BLOCK
+# define LANDLOCK_ACCESS_FS_MAKE_BLOCK		(1ULL << 11)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_MAKE_SYM
+# define LANDLOCK_ACCESS_FS_MAKE_SYM		(1ULL << 12)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_REFER
+# define LANDLOCK_ACCESS_FS_REFER			(1ULL << 13)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_TRUNCATE
+# define LANDLOCK_ACCESS_FS_TRUNCATE		(1ULL << 14)
+#endif
+
+#ifndef LANDLOCK_ACCESS_FS_IOCTL_DEV
+# define LANDLOCK_ACCESS_FS_IOCTL_DEV		(1ULL << 15)
+#endif
+
+#ifndef LANDLOCK_ACCESS_NET_BIND_TCP
+# define LANDLOCK_ACCESS_NET_BIND_TCP		(1ULL << 0)
+#endif
+
+#ifndef LANDLOCK_ACCESS_NET_CONNECT_TCP
+# define LANDLOCK_ACCESS_NET_CONNECT_TCP	(1ULL << 1)
+#endif
+
+static inline int safe_landlock_create_ruleset(const char *file, const int lineno,
+	const void *attr, size_t size , uint32_t flags)
+{
+	int rval;
+
+	rval = tst_syscall(__NR_landlock_create_ruleset, attr, size, flags);
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"landlock_create_ruleset(%p, %zi, %u)",
+			attr, size, flags);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid landlock_create_ruleset(%p, %lu, %u) return value %d",
+			attr, size, flags, rval);
+	}
+
+	return rval;
+}
+
+static inline int safe_landlock_add_rule(const char *file, const int lineno,
+	int ruleset_fd, int rule_type, const void *rule_attr, uint32_t flags)
+{
+	int rval;
+
+	rval = tst_syscall(__NR_landlock_add_rule,
+		ruleset_fd, rule_type, rule_attr, flags);
+
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"landlock_add_rule(%d, %d, %p, %u)",
+			ruleset_fd, rule_type, rule_attr, flags);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid landlock_add_rule(%d, %d, %p, %u) return value %d",
+			ruleset_fd, rule_type, rule_attr, flags, rval);
+	}
+
+	return rval;
+}
+
+static inline int safe_landlock_restrict_self(const char *file, const int lineno,
+	int ruleset_fd, int flags)
+{
+	int rval;
+
+	rval = tst_syscall(__NR_landlock_restrict_self, ruleset_fd, flags);
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"landlock_restrict_self(%d, %u)",
+			ruleset_fd, flags);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid landlock_restrict_self(%d, %u) return value %d",
+			ruleset_fd, flags, rval);
+	}
+
+	return rval;
+}
+
+#define SAFE_LANDLOCK_CREATE_RULESET(attr, size, flags) \
+	safe_landlock_create_ruleset(__FILE__, __LINE__, (attr), (size), (flags))
+
+#define SAFE_LANDLOCK_ADD_RULE(ruleset_fd, rule_type, rule_attr, flags) \
+	safe_landlock_add_rule(__FILE__, __LINE__, \
+		(ruleset_fd), (rule_type), (rule_attr), (flags))
+
+#define SAFE_LANDLOCK_RESTRICT_SELF(ruleset_fd, flags) \
+	safe_landlock_restrict_self(__FILE__, __LINE__, (ruleset_fd), (flags))
+
+#endif
diff --git a/include/lapi/mman.h b/include/lapi/mman.h
new file mode 100644
index 000000000..edd517c6e
--- /dev/null
+++ b/include/lapi/mman.h
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef LAPI_MMAN_H__
+#define LAPI_MMAN_H__
+
+#include <stdint.h>
+#include <sys/mman.h>
+#include "config.h"
+#include "lapi/syscalls.h"
+
+#ifndef HAVE_STRUCT_CACHESTAT_RANGE
+struct cachestat_range {
+	uint64_t off;
+	uint64_t len;
+};
+#endif
+
+#ifndef HAVE_STRUCT_CACHESTAT
+struct cachestat {
+	uint64_t nr_cache;
+	uint64_t nr_dirty;
+	uint64_t nr_writeback;
+	uint64_t nr_evicted;
+	uint64_t nr_recently_evicted;
+};
+#endif
+
+#ifndef HAVE_CACHESTAT
+/*
+ * cachestat: wrapper function of cachestat
+ *
+ * Returns: It returns status of cachestat syscall
+ */
+static inline int cachestat(int fd, struct cachestat_range *cstat_range,
+	struct cachestat *cstat, unsigned int flags)
+{
+	return tst_syscall(__NR_cachestat, fd, cstat_range, cstat, flags);
+}
+#endif
+
+#endif /* LAPI_MMAN_H__ */
diff --git a/include/lapi/mmap.h b/include/lapi/mmap.h
index 7512e9f81..ea9730586 100644
--- a/include/lapi/mmap.h
+++ b/include/lapi/mmap.h
@@ -38,6 +38,14 @@
 # define MADV_SOFT_OFFLINE 101
 #endif
 
+#ifndef MADV_GUARD_INSTALL
+# define MADV_GUARD_INSTALL 102
+#endif
+
+#ifndef MADV_GUARD_REMOVE
+# define MADV_GUARD_REMOVE 103
+#endif
+
 #ifndef MADV_MERGEABLE
 # define MADV_MERGEABLE   12
 #endif
diff --git a/include/lapi/mount.h b/include/lapi/mount.h
index c1af944fe..aea6bca77 100644
--- a/include/lapi/mount.h
+++ b/include/lapi/mount.h
@@ -1,12 +1,20 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (c) Linux Test Project, 2015-2022
+ * Copyright (c) Linux Test Project, 2015-2025
  * Copyright (c) 2015 Cui Bixuan <cuibixuan@huawei.com>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
 #ifndef LAPI_MOUNT_H__
 #define LAPI_MOUNT_H__
 
+#include "config.h"
+#include <stdint.h>
+
+/*
+ * NOTE: <linux/mount.h> conflicts with <sys/mount.h>, therefore not added
+ * although some definitions from it are used.
+ */
 #include <sys/mount.h>
 
 #ifndef MS_REC
@@ -37,4 +45,71 @@
 # define MS_NOSYMFOLLOW 256
 #endif
 
+#ifndef HAVE_STRUCT_MNT_ID_REQ
+struct mnt_id_req {
+	uint32_t size;
+	uint32_t spare;
+	uint64_t mnt_id;
+	uint64_t param;
+};
+#endif
+
+#ifndef HAVE_STRUCT_STATMOUNT
+struct statmount {
+	uint32_t size;
+	uint32_t __spare1;
+	uint64_t mask;
+	uint32_t sb_dev_major;
+	uint32_t sb_dev_minor;
+	uint64_t sb_magic;
+	uint32_t sb_flags;
+	uint32_t fs_type;
+	uint64_t mnt_id;
+	uint64_t mnt_parent_id;
+	uint32_t mnt_id_old;
+	uint32_t mnt_parent_id_old;
+	uint64_t mnt_attr;
+	uint64_t mnt_propagation;
+	uint64_t mnt_peer_group;
+	uint64_t mnt_master;
+	uint64_t propagate_from;
+	uint32_t mnt_root;
+	uint32_t mnt_point;
+	uint64_t __spare2[50];
+	char str[];
+};
+#endif
+
+#ifndef MNT_ID_REQ_SIZE_VER0
+# define MNT_ID_REQ_SIZE_VER0 24
+#endif
+
+#ifndef STATMOUNT_SB_BASIC
+# define STATMOUNT_SB_BASIC 0x00000001U
+#endif
+
+#ifndef STATMOUNT_MNT_BASIC
+# define STATMOUNT_MNT_BASIC 0x00000002U
+#endif
+
+#ifndef STATMOUNT_PROPAGATE_FROM
+# define STATMOUNT_PROPAGATE_FROM 0x00000004U
+#endif
+
+#ifndef STATMOUNT_MNT_ROOT
+# define STATMOUNT_MNT_ROOT 0x00000008U
+#endif
+
+#ifndef STATMOUNT_MNT_POINT
+# define STATMOUNT_MNT_POINT 0x00000010U
+#endif
+
+#ifndef STATMOUNT_FS_TYPE
+# define STATMOUNT_FS_TYPE 0x00000020U
+#endif
+
+#ifndef LSMT_ROOT
+# define LSMT_ROOT 0xffffffffffffffff
+#endif
+
 #endif /* LAPI_MOUNT_H__ */
diff --git a/testcases/kernel/syscalls/pkeys/pkey.h b/include/lapi/pkey.h
similarity index 61%
rename from testcases/kernel/syscalls/pkeys/pkey.h
rename to include/lapi/pkey.h
index 6e32326b6..eb9bf7fb4 100644
--- a/testcases/kernel/syscalls/pkeys/pkey.h
+++ b/include/lapi/pkey.h
@@ -1,12 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (c) 2019 Red Hat, Inc.
- * Copyright (c) Linux Test Project, 2019
+ * Copyright (c) 2019-2024 Red Hat, Inc.
+ * Copyright (c) Linux Test Project, 2019-2024
  */
 
-#ifndef PKEYS_H
-#define PKEYS_H
+#ifndef PKEYS_H__
+#define PKEYS_H__
 
+#include "config.h"
 #include "tst_test.h"
 #include "lapi/syscalls.h"
 #include "lapi/mmap.h"
@@ -16,30 +17,30 @@
 # define PKEY_DISABLE_WRITE  0x2
 #endif
 
+#ifndef PKEY_DISABLE_EXECUTE
+# define PKEY_DISABLE_EXECUTE 0x4
+#endif
+
 #ifndef HAVE_PKEY_MPROTECT
-inline int ltp_pkey_mprotect(void *addr, size_t len, int prot, int pkey)
+inline int pkey_mprotect(void *addr, size_t len, int prot, int pkey)
 {
 	return tst_syscall(__NR_pkey_mprotect, addr, len, prot, pkey);
 }
 
-inline int ltp_pkey_alloc(unsigned int flags, unsigned int access_rights)
+inline int pkey_alloc(unsigned int flags, unsigned int access_rights)
 {
 	return tst_syscall(__NR_pkey_alloc, flags, access_rights);
 }
 
-inline int ltp_pkey_free(int pkey)
+inline int pkey_free(int pkey)
 {
 	return tst_syscall(__NR_pkey_free, pkey);
 }
-#else
-#define ltp_pkey_alloc pkey_alloc
-#define ltp_pkey_free pkey_free
-#define ltp_pkey_mprotect pkey_mprotect
 #endif /* HAVE_PKEY_MPROTECT */
 
 static inline void check_pkey_support(void)
 {
-	int pkey = ltp_pkey_alloc(0, 0);
+	int pkey = tst_syscall(__NR_pkey_alloc, 0, 0);
 
 	if (pkey == -1) {
 		if (errno == ENOSYS)
@@ -50,7 +51,7 @@ static inline void check_pkey_support(void)
 			tst_brk(TCONF, "pkeys are not available for test");
 	}
 
-	ltp_pkey_free(pkey);
+	tst_syscall(__NR_pkey_free, pkey);
 }
 
-#endif /* PKEYS_H */
+#endif /* PKEYS_H__ */
diff --git a/include/lapi/pwritev2.h b/include/lapi/pwritev2.h
deleted file mode 100644
index 48b53f463..000000000
--- a/include/lapi/pwritev2.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (c) 2019 FUJITSU LIMITED. All rights reserved.
- * Author: Jinhui Huang <huangjh.jy@cn.fujitsu.com>
- */
-
-#ifndef LAPI_PWRITEV2_H__
-#define LAPI_PWRITEV2_H__
-
-#include "config.h"
-#include "lapi/syscalls.h"
-
-#if !defined(HAVE_PWRITEV2)
-
-/* LO_HI_LONG taken from glibc */
-# define LO_HI_LONG(val) (long) (val), (long) (((uint64_t) (val)) >> 32)
-
-static inline ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
-                               off_t offset, int flags)
-{
-	return tst_syscall(__NR_pwritev2, fd, iov, iovcnt,
-			   LO_HI_LONG(offset), flags);
-}
-#endif
-
-#endif /* LAPI_PWRITEV2_H__ */
diff --git a/include/lapi/sched.h b/include/lapi/sched.h
index 720b75502..0ffe44641 100644
--- a/include/lapi/sched.h
+++ b/include/lapi/sched.h
@@ -13,8 +13,9 @@
 #include <inttypes.h>
 #include "config.h"
 #include "lapi/syscalls.h"
-#include "lapi/sched.h"
 
+/* sched_attr is not defined in glibc < 2.41 */
+#ifndef SCHED_ATTR_SIZE_VER0
 struct sched_attr {
 	uint32_t size;
 
@@ -45,6 +46,10 @@ static inline int sched_getattr(pid_t pid, struct sched_attr *attr,
 	return syscall(__NR_sched_getattr, pid, attr, size, flags);
 }
 
+# define SCHED_ATTR_SIZE_VER0 48	/* sizeof first published struct */
+#endif
+
+#ifndef HAVE_CLONE3
 #ifndef HAVE_STRUCT_CLONE_ARGS
 struct clone_args {
 	uint64_t __attribute__((aligned(8))) flags;
@@ -72,7 +77,6 @@ struct clone_args_minimal {
 	uint64_t __attribute__((aligned(8))) tls;
 };
 
-#ifndef HAVE_CLONE3
 static inline int clone3(struct clone_args *args, size_t size)
 {
 	return tst_syscall(__NR_clone3, args, size);
diff --git a/include/lapi/stat.h b/include/lapi/stat.h
index 3606c9eb0..17b62ea98 100644
--- a/include/lapi/stat.h
+++ b/include/lapi/stat.h
@@ -30,6 +30,7 @@ struct statx_timestamp {
 	int32_t __reserved;
 };
 #endif
+
 /*
  * Structures for the extended file attribute retrieval system call
  * (statx()).
@@ -67,39 +68,53 @@ struct statx_timestamp {
  * will have values installed for compatibility purposes so that stat() and
  * co. can be emulated in userspace.
  */
-#ifndef HAVE_STRUCT_STATX
-struct statx {
-	/* 0x00 */
-	uint32_t	stx_mask;
-	uint32_t	stx_blksize;
-	uint64_t	stx_attributes;
-	/* 0x10 */
-	uint32_t	stx_nlink;
-	uint32_t	stx_uid;
-	uint32_t	stx_gid;
-	uint16_t	stx_mode;
-	uint16_t	__spare0[1];
-	/* 0x20 */
-	uint64_t	stx_ino;
-	uint64_t	stx_size;
-	uint64_t	stx_blocks;
-	uint64_t	stx_attributes_mask;
-	/* 0x40 */
-	const struct statx_timestamp	stx_atime;
-	const struct statx_timestamp	stx_btime;
-	const struct statx_timestamp	stx_ctime;
-	const struct statx_timestamp	stx_mtime;
-	/* 0x80 */
-	uint32_t	stx_rdev_major;
-	uint32_t	stx_rdev_minor;
-	uint32_t	stx_dev_major;
-	uint32_t	stx_dev_minor;
-	/* 0x90 */
-	uint64_t	__spare2[14];
-	/* 0x100 */
+ #define LTP_DEFINE_STATX_STRUCT(x) \
+ 	struct x { \
+	uint32_t	stx_mask; \
+	uint32_t	stx_blksize; \
+	uint64_t	stx_attributes; \
+	uint32_t	stx_nlink; \
+	uint32_t	stx_uid; \
+	uint32_t	stx_gid; \
+	uint16_t	stx_mode; \
+	uint16_t	__spare0[1]; \
+	uint64_t	stx_ino; \
+	uint64_t	stx_size; \
+	uint64_t	stx_blocks; \
+	uint64_t	stx_attributes_mask; \
+	const struct statx_timestamp	stx_atime; \
+	const struct statx_timestamp	stx_btime; \
+	const struct statx_timestamp	stx_ctime; \
+	const struct statx_timestamp	stx_mtime; \
+	uint32_t	stx_rdev_major; \
+	uint32_t	stx_rdev_minor; \
+	uint32_t	stx_dev_major; \
+	uint32_t	stx_dev_minor; \
+	uint64_t	stx_mnt_id; \
+	uint32_t	stx_dio_mem_align; \
+	uint32_t	stx_dio_offset_align; \
+	uint64_t	__spare3[12]; \
 };
+
+LTP_DEFINE_STATX_STRUCT(statx_fallback);
+
+#ifndef HAVE_STRUCT_STATX
+LTP_DEFINE_STATX_STRUCT(statx);
 #endif
 
+/*
+ * This is the fallback statx that we pass to the safe_statx() syscall.
+ * The reason why we need it, is that statx struct is constantly changing
+ * inside the kernel and we need to extend its definition when structure
+ * changes in order to compile the tests.
+ */
+struct ltp_statx {
+	union {
+		struct statx buff;
+		struct statx_fallback data;
+	};
+};
+
 #ifndef HAVE_STATX
 
 /*
@@ -108,9 +123,9 @@ struct statx {
  * Returns: It returns status of statx syscall
  */
 static inline int statx(int dirfd, const char *pathname, unsigned int flags,
-			unsigned int mask, struct statx *statxbuf)
+			unsigned int mask, struct statx *st)
 {
-	return tst_syscall(__NR_statx, dirfd, pathname, flags, mask, statxbuf);
+	return tst_syscall(__NR_statx, dirfd, pathname, flags, mask, st);
 }
 #endif
 
@@ -229,4 +244,54 @@ static inline int statx(int dirfd, const char *pathname, unsigned int flags,
 # define STATX_ATTR_VERITY	0x00100000
 #endif
 
+#ifndef STATX_MNT_ID_UNIQUE
+# define STATX_MNT_ID_UNIQUE  0x00004000U
+#endif
+
+#define SAFE_FCHMODAT2(dfd, filename, mode, flags) \
+	safe_fchmodat2(__FILE__, __LINE__, (dfd), (filename), (mode), (flags))
+
+static inline int safe_fchmodat2(const char *file, const int lineno,
+		int dfd, const char *filename, mode_t mode, int flags)
+{
+	int ret;
+
+	ret = tst_syscall(__NR_fchmodat2, dfd, filename, mode, flags);
+	if (ret == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			 "syscall(__NR_fchmodat2,%d,%s,%d,%d) failed",
+			 dfd, filename, mode, flags);
+	} else if (ret) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			 "Invalid syscall(__NR_fchmodat2,%d,%s,%d,%d) return value %d",
+			 dfd, filename, mode, flags, ret);
+	}
+
+	return ret;
+}
+
+#define SAFE_STATX(dirfd, pathname, flags, mask, buf) \
+	safe_statx(__FILE__, __LINE__, (dirfd), (pathname), (flags), (mask), (buf))
+
+static inline int safe_statx(const char *file, const int lineno,
+	int dirfd, const char *pathname, int flags, unsigned int mask,
+	struct ltp_statx *buf)
+{
+	int rval;
+
+	rval = statx(dirfd, pathname, flags, mask, &buf->buff);
+
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"statx(%d,%s,%d,%u,%p) failed", dirfd, pathname, flags, mask, buf);
+	} else if (rval) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid statx(%d,%s,%d,%u,%p) return value %d",
+			dirfd, pathname, flags, mask, buf,
+			rval);
+	}
+
+	return rval;
+}
+
 #endif /* LAPI_STAT_H__ */
diff --git a/include/lapi/syscalls/arc.in b/include/lapi/syscalls/arc.in
index 7fde1d263..f680d4119 100644
--- a/include/lapi/syscalls/arc.in
+++ b/include/lapi/syscalls/arc.in
@@ -23,7 +23,7 @@ epoll_ctl 21
 epoll_pwait 22
 dup 23
 dup3 24
-fcntl 25
+fcntl64 25
 inotify_init1 26
 inotify_add_watch 27
 inotify_rm_watch 28
@@ -41,10 +41,10 @@ umount2 39
 mount 40
 pivot_root 41
 nfsservctl 42
-statfs 43
-fstatfs 44
-truncate 45
-ftruncate 46
+statfs64 43
+fstatfs64 44
+truncate64 45
+ftruncate64 46
 fallocate 47
 faccessat 48
 chdir 49
@@ -60,7 +60,7 @@ vhangup 58
 pipe2 59
 quotactl 60
 getdents64 61
-lseek 62
+llseek 62
 read 63
 write 64
 readv 65
@@ -69,7 +69,7 @@ pread64 67
 pwrite64 68
 preadv 69
 pwritev 70
-sendfile 71
+sendfile64 71
 pselect6 72
 ppoll 73
 signalfd4 74
@@ -77,12 +77,11 @@ vmsplice 75
 splice 76
 tee 77
 readlinkat 78
-fstatat 79
-fstat 80
+fstatat64 79
+fstat64 80
 sync 81
 fsync 82
 fdatasync 83
-sync_file_range2 84
 sync_file_range 84
 timerfd_create 85
 timerfd_settime 86
@@ -221,8 +220,8 @@ request_key 218
 keyctl 219
 clone 220
 execve 221
-mmap 222
-fadvise64 223
+mmap2 222
+fadvise64_64 223
 swapon 224
 swapoff 225
 mprotect 226
@@ -261,6 +260,11 @@ sendmmsg 269
 process_vm_readv 270
 process_vm_writev 271
 kcmp 272
+finit_module 273
+sched_setattr 274
+sched_getattr 275
+renameat2 276
+seccomp 277
 getrandom 278
 memfd_create 279
 bpf 280
@@ -314,9 +318,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/arm.in b/include/lapi/syscalls/arm.in
index 8e76ad164..32e48b215 100644
--- a/include/lapi/syscalls/arm.in
+++ b/include/lapi/syscalls/arm.in
@@ -1,401 +1,415 @@
-restart_syscall (__NR_SYSCALL_BASE+  0)
-exit (__NR_SYSCALL_BASE+  1)
-fork (__NR_SYSCALL_BASE+  2)
-read (__NR_SYSCALL_BASE+  3)
-write (__NR_SYSCALL_BASE+  4)
-open (__NR_SYSCALL_BASE+  5)
-close (__NR_SYSCALL_BASE+  6)
-creat (__NR_SYSCALL_BASE+  8)
-link (__NR_SYSCALL_BASE+  9)
-unlink (__NR_SYSCALL_BASE+ 10)
-execve (__NR_SYSCALL_BASE+ 11)
-chdir (__NR_SYSCALL_BASE+ 12)
-mknod (__NR_SYSCALL_BASE+ 14)
-chmod (__NR_SYSCALL_BASE+ 15)
-lchown (__NR_SYSCALL_BASE+ 16)
-lseek (__NR_SYSCALL_BASE+ 19)
-getpid (__NR_SYSCALL_BASE+ 20)
-mount (__NR_SYSCALL_BASE+ 21)
-setuid (__NR_SYSCALL_BASE+ 23)
-getuid (__NR_SYSCALL_BASE+ 24)
-ptrace (__NR_SYSCALL_BASE+ 26)
-pause (__NR_SYSCALL_BASE+ 29)
-access (__NR_SYSCALL_BASE+ 33)
-nice (__NR_SYSCALL_BASE+ 34)
-sync (__NR_SYSCALL_BASE+ 36)
-kill (__NR_SYSCALL_BASE+ 37)
-rename (__NR_SYSCALL_BASE+ 38)
-mkdir (__NR_SYSCALL_BASE+ 39)
-rmdir (__NR_SYSCALL_BASE+ 40)
-dup (__NR_SYSCALL_BASE+ 41)
-pipe (__NR_SYSCALL_BASE+ 42)
-times (__NR_SYSCALL_BASE+ 43)
-brk (__NR_SYSCALL_BASE+ 45)
-setgid (__NR_SYSCALL_BASE+ 46)
-getgid (__NR_SYSCALL_BASE+ 47)
-geteuid (__NR_SYSCALL_BASE+ 49)
-getegid (__NR_SYSCALL_BASE+ 50)
-acct (__NR_SYSCALL_BASE+ 51)
-umount2 (__NR_SYSCALL_BASE+ 52)
-ioctl (__NR_SYSCALL_BASE+ 54)
-fcntl (__NR_SYSCALL_BASE+ 55)
-setpgid (__NR_SYSCALL_BASE+ 57)
-umask (__NR_SYSCALL_BASE+ 60)
-chroot (__NR_SYSCALL_BASE+ 61)
-ustat (__NR_SYSCALL_BASE+ 62)
-dup2 (__NR_SYSCALL_BASE+ 63)
-getppid (__NR_SYSCALL_BASE+ 64)
-getpgrp (__NR_SYSCALL_BASE+ 65)
-setsid (__NR_SYSCALL_BASE+ 66)
-sigaction (__NR_SYSCALL_BASE+ 67)
-setreuid (__NR_SYSCALL_BASE+ 70)
-setregid (__NR_SYSCALL_BASE+ 71)
-sigsuspend (__NR_SYSCALL_BASE+ 72)
-sigpending (__NR_SYSCALL_BASE+ 73)
-sethostname (__NR_SYSCALL_BASE+ 74)
-setrlimit (__NR_SYSCALL_BASE+ 75)
-getrusage (__NR_SYSCALL_BASE+ 77)
-gettimeofday (__NR_SYSCALL_BASE+ 78)
-settimeofday (__NR_SYSCALL_BASE+ 79)
-getgroups (__NR_SYSCALL_BASE+ 80)
-setgroups (__NR_SYSCALL_BASE+ 81)
-symlink (__NR_SYSCALL_BASE+ 83)
-readlink (__NR_SYSCALL_BASE+ 85)
-uselib (__NR_SYSCALL_BASE+ 86)
-swapon (__NR_SYSCALL_BASE+ 87)
-reboot (__NR_SYSCALL_BASE+ 88)
-munmap (__NR_SYSCALL_BASE+ 91)
-truncate (__NR_SYSCALL_BASE+ 92)
-ftruncate (__NR_SYSCALL_BASE+ 93)
-fchmod (__NR_SYSCALL_BASE+ 94)
-fchown (__NR_SYSCALL_BASE+ 95)
-getpriority (__NR_SYSCALL_BASE+ 96)
-setpriority (__NR_SYSCALL_BASE+ 97)
-statfs (__NR_SYSCALL_BASE+ 99)
-fstatfs (__NR_SYSCALL_BASE+100)
-syslog (__NR_SYSCALL_BASE+103)
-setitimer (__NR_SYSCALL_BASE+104)
-getitimer (__NR_SYSCALL_BASE+105)
-stat (__NR_SYSCALL_BASE+106)
-lstat (__NR_SYSCALL_BASE+107)
-fstat (__NR_SYSCALL_BASE+108)
-vhangup (__NR_SYSCALL_BASE+111)
-wait4 (__NR_SYSCALL_BASE+114)
-swapoff (__NR_SYSCALL_BASE+115)
-sysinfo (__NR_SYSCALL_BASE+116)
-fsync (__NR_SYSCALL_BASE+118)
-sigreturn (__NR_SYSCALL_BASE+119)
-clone (__NR_SYSCALL_BASE+120)
-setdomainname (__NR_SYSCALL_BASE+121)
-uname (__NR_SYSCALL_BASE+122)
-adjtimex (__NR_SYSCALL_BASE+124)
-mprotect (__NR_SYSCALL_BASE+125)
-sigprocmask (__NR_SYSCALL_BASE+126)
-init_module (__NR_SYSCALL_BASE+128)
-delete_module (__NR_SYSCALL_BASE+129)
-quotactl (__NR_SYSCALL_BASE+131)
-getpgid (__NR_SYSCALL_BASE+132)
-fchdir (__NR_SYSCALL_BASE+133)
-bdflush (__NR_SYSCALL_BASE+134)
-sysfs (__NR_SYSCALL_BASE+135)
-personality (__NR_SYSCALL_BASE+136)
-setfsuid (__NR_SYSCALL_BASE+138)
-setfsgid (__NR_SYSCALL_BASE+139)
-_llseek (__NR_SYSCALL_BASE+140)
-getdents (__NR_SYSCALL_BASE+141)
-_newselect (__NR_SYSCALL_BASE+142)
-flock (__NR_SYSCALL_BASE+143)
-msync (__NR_SYSCALL_BASE+144)
-readv (__NR_SYSCALL_BASE+145)
-writev (__NR_SYSCALL_BASE+146)
-getsid (__NR_SYSCALL_BASE+147)
-fdatasync (__NR_SYSCALL_BASE+148)
-_sysctl (__NR_SYSCALL_BASE+149)
-mlock (__NR_SYSCALL_BASE+150)
-munlock (__NR_SYSCALL_BASE+151)
-mlockall (__NR_SYSCALL_BASE+152)
-munlockall (__NR_SYSCALL_BASE+153)
-sched_setparam (__NR_SYSCALL_BASE+154)
-sched_getparam (__NR_SYSCALL_BASE+155)
-sched_setscheduler (__NR_SYSCALL_BASE+156)
-sched_getscheduler (__NR_SYSCALL_BASE+157)
-sched_yield (__NR_SYSCALL_BASE+158)
-sched_get_priority_max (__NR_SYSCALL_BASE+159)
-sched_get_priority_min (__NR_SYSCALL_BASE+160)
-sched_rr_get_interval (__NR_SYSCALL_BASE+161)
-nanosleep (__NR_SYSCALL_BASE+162)
-mremap (__NR_SYSCALL_BASE+163)
-setresuid (__NR_SYSCALL_BASE+164)
-getresuid (__NR_SYSCALL_BASE+165)
-poll (__NR_SYSCALL_BASE+168)
-nfsservctl (__NR_SYSCALL_BASE+169)
-setresgid (__NR_SYSCALL_BASE+170)
-getresgid (__NR_SYSCALL_BASE+171)
-prctl (__NR_SYSCALL_BASE+172)
-rt_sigreturn (__NR_SYSCALL_BASE+173)
-rt_sigaction (__NR_SYSCALL_BASE+174)
-rt_sigprocmask (__NR_SYSCALL_BASE+175)
-rt_sigpending (__NR_SYSCALL_BASE+176)
-rt_sigtimedwait (__NR_SYSCALL_BASE+177)
-rt_sigqueueinfo (__NR_SYSCALL_BASE+178)
-rt_sigsuspend (__NR_SYSCALL_BASE+179)
-pread64 (__NR_SYSCALL_BASE+180)
-pwrite64 (__NR_SYSCALL_BASE+181)
-chown (__NR_SYSCALL_BASE+182)
-getcwd (__NR_SYSCALL_BASE+183)
-capget (__NR_SYSCALL_BASE+184)
-capset (__NR_SYSCALL_BASE+185)
-sigaltstack (__NR_SYSCALL_BASE+186)
-sendfile (__NR_SYSCALL_BASE+187)
-vfork (__NR_SYSCALL_BASE+190)
-ugetrlimit (__NR_SYSCALL_BASE+191)
-mmap2 (__NR_SYSCALL_BASE+192)
-truncate64 (__NR_SYSCALL_BASE+193)
-ftruncate64 (__NR_SYSCALL_BASE+194)
-stat64 (__NR_SYSCALL_BASE+195)
-lstat64 (__NR_SYSCALL_BASE+196)
-fstat64 (__NR_SYSCALL_BASE+197)
-lchown32 (__NR_SYSCALL_BASE+198)
-getuid32 (__NR_SYSCALL_BASE+199)
-getgid32 (__NR_SYSCALL_BASE+200)
-geteuid32 (__NR_SYSCALL_BASE+201)
-getegid32 (__NR_SYSCALL_BASE+202)
-setreuid32 (__NR_SYSCALL_BASE+203)
-setregid32 (__NR_SYSCALL_BASE+204)
-getgroups32 (__NR_SYSCALL_BASE+205)
-setgroups32 (__NR_SYSCALL_BASE+206)
-fchown32 (__NR_SYSCALL_BASE+207)
-setresuid32 (__NR_SYSCALL_BASE+208)
-getresuid32 (__NR_SYSCALL_BASE+209)
-setresgid32 (__NR_SYSCALL_BASE+210)
-getresgid32 (__NR_SYSCALL_BASE+211)
-chown32 (__NR_SYSCALL_BASE+212)
-setuid32 (__NR_SYSCALL_BASE+213)
-setgid32 (__NR_SYSCALL_BASE+214)
-setfsuid32 (__NR_SYSCALL_BASE+215)
-setfsgid32 (__NR_SYSCALL_BASE+216)
-getdents64 (__NR_SYSCALL_BASE+217)
-pivot_root (__NR_SYSCALL_BASE+218)
-mincore (__NR_SYSCALL_BASE+219)
-madvise (__NR_SYSCALL_BASE+220)
-fcntl64 (__NR_SYSCALL_BASE+221)
-gettid (__NR_SYSCALL_BASE+224)
-readahead (__NR_SYSCALL_BASE+225)
-setxattr (__NR_SYSCALL_BASE+226)
-lsetxattr (__NR_SYSCALL_BASE+227)
-fsetxattr (__NR_SYSCALL_BASE+228)
-getxattr (__NR_SYSCALL_BASE+229)
-lgetxattr (__NR_SYSCALL_BASE+230)
-fgetxattr (__NR_SYSCALL_BASE+231)
-listxattr (__NR_SYSCALL_BASE+232)
-llistxattr (__NR_SYSCALL_BASE+233)
-flistxattr (__NR_SYSCALL_BASE+234)
-removexattr (__NR_SYSCALL_BASE+235)
-lremovexattr (__NR_SYSCALL_BASE+236)
-fremovexattr (__NR_SYSCALL_BASE+237)
-tkill (__NR_SYSCALL_BASE+238)
-sendfile64 (__NR_SYSCALL_BASE+239)
-futex (__NR_SYSCALL_BASE+240)
-sched_setaffinity (__NR_SYSCALL_BASE+241)
-sched_getaffinity (__NR_SYSCALL_BASE+242)
-io_setup (__NR_SYSCALL_BASE+243)
-io_destroy (__NR_SYSCALL_BASE+244)
-io_getevents (__NR_SYSCALL_BASE+245)
-io_submit (__NR_SYSCALL_BASE+246)
-io_cancel (__NR_SYSCALL_BASE+247)
-exit_group (__NR_SYSCALL_BASE+248)
-lookup_dcookie (__NR_SYSCALL_BASE+249)
-epoll_create (__NR_SYSCALL_BASE+250)
-epoll_ctl (__NR_SYSCALL_BASE+251)
-epoll_wait (__NR_SYSCALL_BASE+252)
-remap_file_pages (__NR_SYSCALL_BASE+253)
-set_tid_address (__NR_SYSCALL_BASE+256)
-timer_create (__NR_SYSCALL_BASE+257)
-timer_settime (__NR_SYSCALL_BASE+258)
-timer_gettime (__NR_SYSCALL_BASE+259)
-timer_getoverrun (__NR_SYSCALL_BASE+260)
-timer_delete (__NR_SYSCALL_BASE+261)
-clock_settime (__NR_SYSCALL_BASE+262)
-clock_gettime (__NR_SYSCALL_BASE+263)
-clock_getres (__NR_SYSCALL_BASE+264)
-clock_nanosleep (__NR_SYSCALL_BASE+265)
-statfs64 (__NR_SYSCALL_BASE+266)
-fstatfs64 (__NR_SYSCALL_BASE+267)
-tgkill (__NR_SYSCALL_BASE+268)
-utimes (__NR_SYSCALL_BASE+269)
-arm_fadvise64_64 (__NR_SYSCALL_BASE+270)
-pciconfig_iobase (__NR_SYSCALL_BASE+271)
-pciconfig_read (__NR_SYSCALL_BASE+272)
-pciconfig_write (__NR_SYSCALL_BASE+273)
-mq_open (__NR_SYSCALL_BASE+274)
-mq_unlink (__NR_SYSCALL_BASE+275)
-mq_timedsend (__NR_SYSCALL_BASE+276)
-mq_timedreceive (__NR_SYSCALL_BASE+277)
-mq_notify (__NR_SYSCALL_BASE+278)
-mq_getsetattr (__NR_SYSCALL_BASE+279)
-waitid (__NR_SYSCALL_BASE+280)
-socket (__NR_SYSCALL_BASE+281)
-bind (__NR_SYSCALL_BASE+282)
-connect (__NR_SYSCALL_BASE+283)
-listen (__NR_SYSCALL_BASE+284)
-accept (__NR_SYSCALL_BASE+285)
-getsockname (__NR_SYSCALL_BASE+286)
-getpeername (__NR_SYSCALL_BASE+287)
-socketpair (__NR_SYSCALL_BASE+288)
-send (__NR_SYSCALL_BASE+289)
-sendto (__NR_SYSCALL_BASE+290)
-recv (__NR_SYSCALL_BASE+291)
-recvfrom (__NR_SYSCALL_BASE+292)
-shutdown (__NR_SYSCALL_BASE+293)
-setsockopt (__NR_SYSCALL_BASE+294)
-getsockopt (__NR_SYSCALL_BASE+295)
-sendmsg (__NR_SYSCALL_BASE+296)
-recvmsg (__NR_SYSCALL_BASE+297)
-semop (__NR_SYSCALL_BASE+298)
-semget (__NR_SYSCALL_BASE+299)
-semctl (__NR_SYSCALL_BASE+300)
-msgsnd (__NR_SYSCALL_BASE+301)
-msgrcv (__NR_SYSCALL_BASE+302)
-msgget (__NR_SYSCALL_BASE+303)
-msgctl (__NR_SYSCALL_BASE+304)
-shmat (__NR_SYSCALL_BASE+305)
-shmdt (__NR_SYSCALL_BASE+306)
-shmget (__NR_SYSCALL_BASE+307)
-shmctl (__NR_SYSCALL_BASE+308)
-add_key (__NR_SYSCALL_BASE+309)
-request_key (__NR_SYSCALL_BASE+310)
-keyctl (__NR_SYSCALL_BASE+311)
-semtimedop (__NR_SYSCALL_BASE+312)
-vserver (__NR_SYSCALL_BASE+313)
-ioprio_set (__NR_SYSCALL_BASE+314)
-ioprio_get (__NR_SYSCALL_BASE+315)
-inotify_init (__NR_SYSCALL_BASE+316)
-inotify_add_watch (__NR_SYSCALL_BASE+317)
-inotify_rm_watch (__NR_SYSCALL_BASE+318)
-mbind (__NR_SYSCALL_BASE+319)
-get_mempolicy (__NR_SYSCALL_BASE+320)
-set_mempolicy (__NR_SYSCALL_BASE+321)
-openat (__NR_SYSCALL_BASE+322)
-mkdirat (__NR_SYSCALL_BASE+323)
-mknodat (__NR_SYSCALL_BASE+324)
-fchownat (__NR_SYSCALL_BASE+325)
-futimesat (__NR_SYSCALL_BASE+326)
-fstatat64 (__NR_SYSCALL_BASE+327)
-unlinkat (__NR_SYSCALL_BASE+328)
-renameat (__NR_SYSCALL_BASE+329)
-linkat (__NR_SYSCALL_BASE+330)
-symlinkat (__NR_SYSCALL_BASE+331)
-readlinkat (__NR_SYSCALL_BASE+332)
-fchmodat (__NR_SYSCALL_BASE+333)
-faccessat (__NR_SYSCALL_BASE+334)
-pselect6 (__NR_SYSCALL_BASE+335)
-ppoll (__NR_SYSCALL_BASE+336)
-unshare (__NR_SYSCALL_BASE+337)
-set_robust_list (__NR_SYSCALL_BASE+338)
-get_robust_list (__NR_SYSCALL_BASE+339)
-splice (__NR_SYSCALL_BASE+340)
-arm_sync_file_range (__NR_SYSCALL_BASE+341)
-sync_file_range2 __NR_arm_sync_file_range
-tee (__NR_SYSCALL_BASE+342)
-vmsplice (__NR_SYSCALL_BASE+343)
-move_pages (__NR_SYSCALL_BASE+344)
-getcpu (__NR_SYSCALL_BASE+345)
-epoll_pwait (__NR_SYSCALL_BASE+346)
-kexec_load (__NR_SYSCALL_BASE+347)
-utimensat (__NR_SYSCALL_BASE+348)
-signalfd (__NR_SYSCALL_BASE+349)
-timerfd_create (__NR_SYSCALL_BASE+350)
-eventfd (__NR_SYSCALL_BASE+351)
-fallocate (__NR_SYSCALL_BASE+352)
-timerfd_settime (__NR_SYSCALL_BASE+353)
-timerfd_gettime (__NR_SYSCALL_BASE+354)
-signalfd4 (__NR_SYSCALL_BASE+355)
-eventfd2 (__NR_SYSCALL_BASE+356)
-epoll_create1 (__NR_SYSCALL_BASE+357)
-dup3 (__NR_SYSCALL_BASE+358)
-pipe2 (__NR_SYSCALL_BASE+359)
-inotify_init1 (__NR_SYSCALL_BASE+360)
-preadv (__NR_SYSCALL_BASE+361)
-pwritev (__NR_SYSCALL_BASE+362)
-rt_tgsigqueueinfo (__NR_SYSCALL_BASE+363)
-perf_event_open (__NR_SYSCALL_BASE+364)
-recvmmsg (__NR_SYSCALL_BASE+365)
-accept4 (__NR_SYSCALL_BASE+366)
-fanotify_init (__NR_SYSCALL_BASE+367)
-fanotify_mark (__NR_SYSCALL_BASE+368)
-prlimit64 (__NR_SYSCALL_BASE+369)
-name_to_handle_at (__NR_SYSCALL_BASE+370)
-open_by_handle_at (__NR_SYSCALL_BASE+371)
-clock_adjtime (__NR_SYSCALL_BASE+372)
-syncfs (__NR_SYSCALL_BASE+373)
-sendmmsg (__NR_SYSCALL_BASE+374)
-setns (__NR_SYSCALL_BASE+375)
-process_vm_readv (__NR_SYSCALL_BASE+376)
-process_vm_writev (__NR_SYSCALL_BASE+377)
-kcmp (__NR_SYSCALL_BASE+378)
-finit_module (__NR_SYSCALL_BASE+379)
-sched_setattr (__NR_SYSCALL_BASE+380)
-sched_getattr (__NR_SYSCALL_BASE+381)
-renameat2 (__NR_SYSCALL_BASE+382)
-seccomp (__NR_SYSCALL_BASE+383)
-getrandom (__NR_SYSCALL_BASE+384)
-memfd_create (__NR_SYSCALL_BASE+385)
-bpf (__NR_SYSCALL_BASE+386)
-execveat (__NR_SYSCALL_BASE+387)
-userfaultfd (__NR_SYSCALL_BASE+388)
-membarrier (__NR_SYSCALL_BASE+389)
-mlock2 (__NR_SYSCALL_BASE+390)
-copy_file_range (__NR_SYSCALL_BASE+391)
-preadv2 (__NR_SYSCALL_BASE+392)
-pwritev2 (__NR_SYSCALL_BASE+393)
-pkey_mprotect (__NR_SYSCALL_BASE+394)
-pkey_alloc (__NR_SYSCALL_BASE+395)
-pkey_free (__NR_SYSCALL_BASE+396)
-statx (__NR_SYSCALL_BASE+397)
-rseq (__NR_SYSCALL_BASE+398)
-io_pgetevents (__NR_SYSCALL_BASE+399)
-migrate_pages (__NR_SYSCALL_BASE+400)
-kexec_file_load (__NR_SYSCALL_BASE+401)
-clock_gettime64 (__NR_SYSCALL_BASE+403)
-clock_settime64 (__NR_SYSCALL_BASE+404)
-clock_adjtime64 (__NR_SYSCALL_BASE+405)
-clock_getres_time64 (__NR_SYSCALL_BASE+406)
-clock_nanosleep_time64 (__NR_SYSCALL_BASE+407)
-timer_gettime64 (__NR_SYSCALL_BASE+408)
-timer_settime64 (__NR_SYSCALL_BASE+409)
-timerfd_gettime64 (__NR_SYSCALL_BASE+410)
-timerfd_settime64 (__NR_SYSCALL_BASE+411)
-utimensat_time64 (__NR_SYSCALL_BASE+412)
-pselect6_time64 (__NR_SYSCALL_BASE+413)
-ppoll_time64 (__NR_SYSCALL_BASE+414)
-io_pgetevents_time64 (__NR_SYSCALL_BASE+416)
-recvmmsg_time64 (__NR_SYSCALL_BASE+417)
-mq_timedsend_time64 (__NR_SYSCALL_BASE+418)
-mq_timedreceive_time64 (__NR_SYSCALL_BASE+419)
-semtimedop_time64 (__NR_SYSCALL_BASE+420)
-rt_sigtimedwait_time64 (__NR_SYSCALL_BASE+421)
-futex_time64 (__NR_SYSCALL_BASE+422)
-sched_rr_get_interval_time64 (__NR_SYSCALL_BASE+423)
-pidfd_send_signal (__NR_SYSCALL_BASE+424)
-io_uring_setup (__NR_SYSCALL_BASE+425)
-io_uring_enter (__NR_SYSCALL_BASE+426)
-io_uring_register (__NR_SYSCALL_BASE+427)
-open_tree (__NR_SYSCALL_BASE+428)
-move_mount (__NR_SYSCALL_BASE+429)
-fsopen (__NR_SYSCALL_BASE+430)
-fsconfig (__NR_SYSCALL_BASE+431)
-fsmount (__NR_SYSCALL_BASE+432)
-fspick (__NR_SYSCALL_BASE+433)
-pidfd_open (__NR_SYSCALL_BASE+434)
-clone3 (__NR_SYSCALL_BASE+435)
-close_range (__NR_SYSCALL_BASE+436)
-openat2 (__NR_SYSCALL_BASE+437)
-pidfd_getfd (__NR_SYSCALL_BASE+438)
-faccessat2 (__NR_SYSCALL_BASE+439)
-epoll_pwait2 (__NR_SYSCALL_BASE+441)
-quotactl_fd (__NR_SYSCALL_BASE+443)
-landlock_create_ruleset (__NR_SYSCALL_BASE+444)
-landlock_add_rule (__NR_SYSCALL_BASE+445)
-landlock_restrict_self (__NR_SYSCALL_BASE+446)
-memfd_secret (__NR_SYSCALL_BASE+447)
-futex_waitv (__NR_SYSCALL_BASE+449)
+restart_syscall 0
+exit 1
+fork 2
+read 3
+write 4
+open 5
+close 6
+creat 8
+link 9
+unlink 10
+execve 11
+chdir 12
+mknod 14
+chmod 15
+lchown 16
+lseek 19
+getpid 20
+mount 21
+setuid 23
+getuid 24
+ptrace 26
+pause 29
+access 33
+nice 34
+sync 36
+kill 37
+rename 38
+mkdir 39
+rmdir 40
+dup 41
+pipe 42
+times 43
+brk 45
+setgid 46
+getgid 47
+geteuid 49
+getegid 50
+acct 51
+umount2 52
+ioctl 54
+fcntl 55
+setpgid 57
+umask 60
+chroot 61
+ustat 62
+dup2 63
+getppid 64
+getpgrp 65
+setsid 66
+sigaction 67
+setreuid 70
+setregid 71
+sigsuspend 72
+sigpending 73
+sethostname 74
+setrlimit 75
+getrusage 77
+gettimeofday 78
+settimeofday 79
+getgroups 80
+setgroups 81
+symlink 83
+readlink 85
+uselib 86
+swapon 87
+reboot 88
+munmap 91
+truncate 92
+ftruncate 93
+fchmod 94
+fchown 95
+getpriority 96
+setpriority 97
+statfs 99
+fstatfs 100
+syslog 103
+setitimer 104
+getitimer 105
+stat 106
+lstat 107
+fstat 108
+vhangup 111
+wait4 114
+swapoff 115
+sysinfo 116
+fsync 118
+sigreturn 119
+clone 120
+setdomainname 121
+uname 122
+adjtimex 124
+mprotect 125
+sigprocmask 126
+init_module 128
+delete_module 129
+quotactl 131
+getpgid 132
+fchdir 133
+sysfs 135
+personality 136
+setfsuid 138
+setfsgid 139
+_llseek 140
+getdents 141
+_newselect 142
+flock 143
+msync 144
+readv 145
+writev 146
+getsid 147
+fdatasync 148
+_sysctl 149
+mlock 150
+munlock 151
+mlockall 152
+munlockall 153
+sched_setparam 154
+sched_getparam 155
+sched_setscheduler 156
+sched_getscheduler 157
+sched_yield 158
+sched_get_priority_max 159
+sched_get_priority_min 160
+sched_rr_get_interval 161
+nanosleep 162
+mremap 163
+setresuid 164
+getresuid 165
+poll 168
+nfsservctl 169
+setresgid 170
+getresgid 171
+prctl 172
+rt_sigreturn 173
+rt_sigaction 174
+rt_sigprocmask 175
+rt_sigpending 176
+rt_sigtimedwait 177
+rt_sigqueueinfo 178
+rt_sigsuspend 179
+pread64 180
+pwrite64 181
+chown 182
+getcwd 183
+capget 184
+capset 185
+sigaltstack 186
+sendfile 187
+vfork 190
+ugetrlimit 191
+mmap2 192
+truncate64 193
+ftruncate64 194
+stat64 195
+lstat64 196
+fstat64 197
+lchown32 198
+getuid32 199
+getgid32 200
+geteuid32 201
+getegid32 202
+setreuid32 203
+setregid32 204
+getgroups32 205
+setgroups32 206
+fchown32 207
+setresuid32 208
+getresuid32 209
+setresgid32 210
+getresgid32 211
+chown32 212
+setuid32 213
+setgid32 214
+setfsuid32 215
+setfsgid32 216
+getdents64 217
+pivot_root 218
+mincore 219
+madvise 220
+fcntl64 221
+gettid 224
+readahead 225
+setxattr 226
+lsetxattr 227
+fsetxattr 228
+getxattr 229
+lgetxattr 230
+fgetxattr 231
+listxattr 232
+llistxattr 233
+flistxattr 234
+removexattr 235
+lremovexattr 236
+fremovexattr 237
+tkill 238
+sendfile64 239
+futex 240
+sched_setaffinity 241
+sched_getaffinity 242
+io_setup 243
+io_destroy 244
+io_getevents 245
+io_submit 246
+io_cancel 247
+exit_group 248
+lookup_dcookie 249
+epoll_create 250
+epoll_ctl 251
+epoll_wait 252
+remap_file_pages 253
+set_tid_address 256
+timer_create 257
+timer_settime 258
+timer_gettime 259
+timer_getoverrun 260
+timer_delete 261
+clock_settime 262
+clock_gettime 263
+clock_getres 264
+clock_nanosleep 265
+statfs64 266
+fstatfs64 267
+tgkill 268
+utimes 269
+arm_fadvise64_64 270
+pciconfig_iobase 271
+pciconfig_read 272
+pciconfig_write 273
+mq_open 274
+mq_unlink 275
+mq_timedsend 276
+mq_timedreceive 277
+mq_notify 278
+mq_getsetattr 279
+waitid 280
+socket 281
+bind 282
+connect 283
+listen 284
+accept 285
+getsockname 286
+getpeername 287
+socketpair 288
+send 289
+sendto 290
+recv 291
+recvfrom 292
+shutdown 293
+setsockopt 294
+getsockopt 295
+sendmsg 296
+recvmsg 297
+semop 298
+semget 299
+semctl 300
+msgsnd 301
+msgrcv 302
+msgget 303
+msgctl 304
+shmat 305
+shmdt 306
+shmget 307
+shmctl 308
+add_key 309
+request_key 310
+keyctl 311
+semtimedop 312
+vserver 313
+ioprio_set 314
+ioprio_get 315
+inotify_init 316
+inotify_add_watch 317
+inotify_rm_watch 318
+mbind 319
+get_mempolicy 320
+set_mempolicy 321
+openat 322
+mkdirat 323
+mknodat 324
+fchownat 325
+futimesat 326
+fstatat64 327
+unlinkat 328
+renameat 329
+linkat 330
+symlinkat 331
+readlinkat 332
+fchmodat 333
+faccessat 334
+pselect6 335
+ppoll 336
+unshare 337
+set_robust_list 338
+get_robust_list 339
+splice 340
+arm_sync_file_range 341
+sync_file_range2 341
+tee 342
+vmsplice 343
+move_pages 344
+getcpu 345
+epoll_pwait 346
+kexec_load 347
+utimensat 348
+signalfd 349
+timerfd_create 350
+eventfd 351
+fallocate 352
+timerfd_settime 353
+timerfd_gettime 354
+signalfd4 355
+eventfd2 356
+epoll_create1 357
+dup3 358
+pipe2 359
+inotify_init1 360
+preadv 361
+pwritev 362
+rt_tgsigqueueinfo 363
+perf_event_open 364
+recvmmsg 365
+accept4 366
+fanotify_init 367
+fanotify_mark 368
+prlimit64 369
+name_to_handle_at 370
+open_by_handle_at 371
+clock_adjtime 372
+syncfs 373
+sendmmsg 374
+setns 375
+process_vm_readv 376
+process_vm_writev 377
+kcmp 378
+finit_module 379
+sched_setattr 380
+sched_getattr 381
+renameat2 382
+seccomp 383
+getrandom 384
+memfd_create 385
+bpf 386
+execveat 387
+userfaultfd 388
+membarrier 389
+mlock2 390
+copy_file_range 391
+preadv2 392
+pwritev2 393
+pkey_mprotect 394
+pkey_alloc 395
+pkey_free 396
+statx 397
+rseq 398
+io_pgetevents 399
+migrate_pages 400
+kexec_file_load 401
+clock_gettime64 403
+clock_settime64 404
+clock_adjtime64 405
+clock_getres_time64 406
+clock_nanosleep_time64 407
+timer_gettime64 408
+timer_settime64 409
+timerfd_gettime64 410
+timerfd_settime64 411
+utimensat_time64 412
+pselect6_time64 413
+ppoll_time64 414
+io_pgetevents_time64 416
+recvmmsg_time64 417
+mq_timedsend_time64 418
+mq_timedreceive_time64 419
+semtimedop_time64 420
+rt_sigtimedwait_time64 421
+futex_time64 422
+sched_rr_get_interval_time64 423
+pidfd_send_signal 424
+io_uring_setup 425
+io_uring_enter 426
+io_uring_register 427
+open_tree 428
+move_mount 429
+fsopen 430
+fsconfig 431
+fsmount 432
+fspick 433
+pidfd_open 434
+clone3 435
+close_range 436
+openat2 437
+pidfd_getfd 438
+faccessat2 439
+process_madvise 440
+epoll_pwait2 441
+mount_setattr 442
+quotactl_fd 443
+landlock_create_ruleset 444
+landlock_add_rule 445
+landlock_restrict_self 446
+process_mrelease 448
+futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/loongarch.in b/include/lapi/syscalls/arm64.in
similarity index 95%
rename from include/lapi/syscalls/loongarch.in
rename to include/lapi/syscalls/arm64.in
index 301f611f6..be7e9df64 100644
--- a/include/lapi/syscalls/loongarch.in
+++ b/include/lapi/syscalls/arm64.in
@@ -77,12 +77,11 @@ vmsplice 75
 splice 76
 tee 77
 readlinkat 78
-fstatat 79
+newfstatat 79
 fstat 80
 sync 81
 fsync 82
 fdatasync 83
-sync_file_range2 84
 sync_file_range 84
 timerfd_create 85
 timerfd_settime 86
@@ -305,3 +304,15 @@ memfd_secret 447
 process_mrelease 448
 futex_waitv 449
 set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/generate_arch.sh b/include/lapi/syscalls/generate_arch.sh
new file mode 100755
index 000000000..5d731794d
--- /dev/null
+++ b/include/lapi/syscalls/generate_arch.sh
@@ -0,0 +1,213 @@
+#!/bin/sh -eu
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) Linux Test Project, 2009-2024
+# Copyright (c) Marcin Juszkiewicz, 2023-2024
+#
+# This is an adaptation of the update-tables.sh script, included in the
+# syscalls-table project (https://github.com/hrw/syscalls-table) and released
+# under the MIT license.
+#
+# Author: Andrea Cervesato <andrea.cervesato@suse.com>
+
+if [ "$#" -eq "0" ]; then
+	echo "Please provide kernel sources:"
+	echo ""
+	echo "$0 path/to/Linux/kernel/sources"
+	echo ""
+	exit 1
+fi
+
+KERNELSRC="$1"
+
+# to keep sorting in order
+export LC_ALL=C
+
+if [ ! -d "${KERNELSRC}" ]; then
+	echo "${KERNELSRC} is not a directory"
+	exit 1
+fi
+
+if [ ! -e "${KERNELSRC}/Makefile" ]; then
+	echo "No Makefile in ${KERNELSRC} directory"
+	exit 1
+fi
+
+TEMP="$(mktemp -d)"
+KVER="$(make -C ${KERNELSRC} kernelversion -s)"
+
+SCRIPT_DIR="$(realpath $(dirname "$0"))"
+SUPPORTED_ARCH="${SCRIPT_DIR}/supported-arch.txt"
+LINUX_HEADERS="${TEMP}/headers"
+
+grab_syscall_names_from_tables() {
+	for tbl_file in $(find ${KERNELSRC}/arch -name syscall*.tbl); do
+		grep -E -v "(^#|^$|sys_ni_syscall)" $tbl_file |
+			awk '{ print $3 }' >>${TEMP}/syscall-names.tosort
+	done
+
+	drop_bad_entries
+}
+
+grab_syscall_names_from_unistd_h() {
+	grep -E -h "^#define __NR_" \
+		${LINUX_HEADERS}/usr/include/asm/unistd*.h \
+		${LINUX_HEADERS}/usr/include/asm-generic/unistd.h \
+		>${TEMP}/syscall-names.tosort
+
+	drop_bad_entries
+}
+
+drop_bad_entries() {
+	grep -E -v "(unistd.h|NR3264|__NR_syscall|__SC_COMP|__NR_.*Linux|__NR_FAST)" \
+		${TEMP}/syscall-names.tosort |
+		grep -E -v "(__SYSCALL|SYSCALL_BASE|SYSCALL_MASK)" |
+		sed -e "s/#define\s*__NR_//g" -e "s/\s.*//g" |
+		sort -u >${TEMP}/syscall-names.txt
+}
+
+generate_table() {
+	echo "- $arch"
+
+	if [ "$bits" -eq "32" ]; then
+		extraflags="${extraflags} -D__BITS_PER_LONG=32"
+	fi
+
+	local uppercase_arch=$(echo "$arch" | tr '[:lower:]' '[:upper:]')
+
+	# ignore any error generated by gcc. We want to obtain all the
+	# available architecture syscalls for the current platform and to handle
+	# only supported architectures later on
+	gcc ${TEMP}/list-syscalls.c -U__LP64__ -U__ILP32__ -U__i386__ \
+		-D${uppercase_arch} \
+		-D__${arch}__ ${extraflags} \
+		-I ${LINUX_HEADERS}/usr/include/ \
+		-o ${TEMP}/list-syscalls || true
+
+	${TEMP}/list-syscalls >"${TEMP}/${arch}.in.tosort"
+
+	sort -k2,2n "${TEMP}/${arch}.in.tosort" >"${TEMP}/${arch}.in"
+}
+
+generate_list_syscalls_c() {
+	(
+		printf "
+		#include <stdio.h>
+		#include <asm/unistd.h>
+
+		int main(void)
+		{
+		"
+		for syscall in $(cat ${TEMP}/syscall-names.txt); do
+			printf "
+		#ifdef __NR_$syscall
+			printf(\"$syscall %%d"
+			# i know the following print is ugly, but dash and bash
+			# treat double quoted strings in a different way and we
+			# really need to inject '\n' character in the C code
+			# rather than carriage return
+			printf '\\n'
+			printf "\", __NR_$syscall);
+		#endif
+		"
+		done
+		printf " return 0;
+		}"
+	) >${TEMP}/list-syscalls.c
+}
+
+export_headers() {
+	make -s -C ${KERNELSRC} ARCH=${arch} O=${LINUX_HEADERS} \
+		headers_install >/dev/null 2>&1
+}
+
+do_all_tables() {
+	for archdir in ${KERNELSRC}/arch/*; do
+		arch=$(basename $archdir)
+
+		bits=64
+		extraflags=
+
+		case ${arch} in
+		Kconfig)
+			continue
+			;;
+		um)
+			continue
+			;;
+		esac
+
+		export_headers
+		grab_syscall_names_from_unistd_h
+
+		case ${arch} in
+		arm)
+			bits=32
+			arch=armoabi extraflags= generate_table
+			arch=arm extraflags=-D__ARM_EABI__ generate_table
+			;;
+		loongarch)
+			# 32-bit variant of loongarch may appear
+			arch=loongarch64 extraflags=-D_LOONGARCH_SZLONG=64 generate_table
+			;;
+		mips)
+			arch=mips64 extraflags=-D_MIPS_SIM=_MIPS_SIM_ABI64 generate_table
+			bits=32
+			arch=mipso32 extraflags=-D_MIPS_SIM=_MIPS_SIM_ABI32 generate_table
+			arch=mips64n32 extraflags=-D_MIPS_SIM=_MIPS_SIM_NABI32 generate_table
+			;;
+		powerpc)
+			generate_table
+			arch=powerpc64 generate_table
+			;;
+		riscv)
+			arch=riscv64 extraflags=-D__LP64__ generate_table
+			bits=32
+			arch=riscv32 extraflags=-D__SIZEOF_POINTER__=4 generate_table
+			;;
+		s390)
+			bits=32
+			generate_table
+			bits=64
+			arch=s390x generate_table
+			;;
+		sparc)
+			bits=32
+			extraflags=-D__32bit_syscall_numbers__ generate_table
+			bits=64
+			arch=sparc64 extraflags=-D__arch64__ generate_table
+			;;
+		x86)
+			arch=x86_64 extraflags=-D__LP64__ generate_table
+			bits=32
+			arch=i386 generate_table
+			arch=x32 extraflags=-D__ILP32__ generate_table
+			;;
+		arc | csky | hexagon | m68k | microblaze | nios2 | openrisc | sh | xtensa)
+			bits=32 generate_table
+			;;
+		*)
+			generate_table
+			;;
+		esac
+	done
+}
+
+copy_supported_arch() {
+	while IFS= read -r arch; do
+		if [ -f "${TEMP}/${arch}.in" ]; then
+			echo "- ${arch}"
+			cp "${TEMP}/${arch}.in" "${SCRIPT_DIR}/${arch}.in"
+		fi
+	done <${SUPPORTED_ARCH}
+}
+
+echo "Temporary directory ${TEMP}"
+echo "Extracting syscalls"
+
+grab_syscall_names_from_tables
+generate_list_syscalls_c
+
+do_all_tables
+
+echo "Copying supported syscalls"
+copy_supported_arch
diff --git a/include/lapi/syscalls/generate_syscalls.sh b/include/lapi/syscalls/generate_syscalls.sh
new file mode 100755
index 000000000..b17c72ddf
--- /dev/null
+++ b/include/lapi/syscalls/generate_syscalls.sh
@@ -0,0 +1,109 @@
+#!/bin/sh -eu
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Generate the syscalls.h file, merging all architectures syscalls input file
+# which are in the current folder and defined inside supported-arch.txt file.
+
+SYSCALLS_FILE="$1"
+
+if [ -z "${SYSCALLS_FILE}" ]; then
+	echo "Please provide the syscalls.h directory:"
+	echo ""
+	echo "$0 path/of/syscalls.h"
+	echo ""
+	exit 1
+fi
+
+SCRIPT_DIR="$(realpath $(dirname "$0"))"
+SUPPORTED_ARCH="${SCRIPT_DIR}/supported-arch.txt"
+
+echo '// SPDX-License-Identifier: GPL-2.0-or-later
+/************************************************
+ * GENERATED FILE: DO NOT EDIT/PATCH THIS FILE  *
+ *  change your arch specific .in file instead  *
+ ************************************************/
+
+/*
+ * Here we stick all the ugly *fallback* logic for linux
+ * system call numbers (those __NR_ thingies).
+ */
+
+#ifndef LAPI_SYSCALLS_H__
+#define LAPI_SYSCALLS_H__
+
+#include <errno.h>
+#include <sys/syscall.h>
+#include <asm/unistd.h>
+
+#ifdef TST_TEST_H__
+#define TST_SYSCALL_BRK__(NR, SNR) ({ \
+tst_brk(TCONF, \
+	"syscall(%d) " SNR " not supported on your arch", NR); \
+})
+#else
+inline static void dummy_cleanup(void) {}
+
+#define TST_SYSCALL_BRK__(NR, SNR) ({ \
+tst_brkm(TCONF, dummy_cleanup, \
+	"syscall(%d) " SNR " not supported on your arch", NR); \
+})
+#endif
+
+#define tst_syscall(NR, ...) ({ \
+intptr_t tst_ret; \
+if (NR == __LTP__NR_INVALID_SYSCALL) { \
+	errno = ENOSYS; \
+	tst_ret = -1; \
+} else { \
+	tst_ret = syscall(NR, ##__VA_ARGS__); \
+} \
+if (tst_ret == -1 && errno == ENOSYS) { \
+	TST_SYSCALL_BRK__(NR, #NR); \
+} \
+tst_ret; \
+})
+
+#define __LTP__NR_INVALID_SYSCALL -1' >${SYSCALLS_FILE}
+
+while IFS= read -r arch; do
+	(
+		echo
+		case ${arch} in
+		sparc64) echo "#if defined(__sparc__) && defined(__arch64__)" ;;
+		sparc) echo "#if defined(__sparc__) && !defined(__arch64__)" ;;
+		s390) echo "#if defined(__s390__) && !defined(__s390x__)" ;;
+		mips64n32) echo "#if defined(__mips__) && defined(_ABIN32)" ;;
+		mips64) echo "#if defined(__mips__) && defined(_ABI64)" ;;
+		mipso32) echo "#if defined(__mips__) && defined(_ABIO32) && _MIPS_SZLONG == 32" ;;
+		parisc) echo "#ifdef __hppa__" ;;
+		loongarch64) echo "#ifdef __loongarch__" ;;
+		arm64) echo "#ifdef __aarch64__" ;;
+		*) echo "#ifdef __${arch}__" ;;
+		esac
+
+		while read -r line; do
+			set -- ${line}
+			syscall_nr="__NR_$1"
+			shift
+
+			echo "# ifndef ${syscall_nr}"
+			echo "#  define ${syscall_nr} $*"
+			echo "# endif"
+		done <"${SCRIPT_DIR}/${arch}.in"
+		echo "#endif"
+		echo
+	) >>${SYSCALLS_FILE}
+done <${SUPPORTED_ARCH}
+
+(
+	echo
+	echo "/* Common stubs */"
+	for num in $(awk '{print $1}' "${SCRIPT_DIR}/"*.in | sort -u); do
+		syscall_nr="__NR_${num}"
+
+		echo "# ifndef ${syscall_nr}"
+		echo "#  define ${syscall_nr} __LTP__NR_INVALID_SYSCALL"
+		echo "# endif"
+	done
+	echo "#endif"
+) >>${SYSCALLS_FILE}
diff --git a/include/lapi/syscalls/hppa.in b/include/lapi/syscalls/hppa.in
deleted file mode 100644
index 60c02aff2..000000000
--- a/include/lapi/syscalls/hppa.in
+++ /dev/null
@@ -1,49 +0,0 @@
-_sysctl 149
-openat 275
-mkdirat (__NR_openat + 1)
-mknodat (__NR_openat + 2)
-fchownat (__NR_openat + 3)
-futimesat (__NR_openat + 4)
-newfstatat (__NR_openat + 5)
-fstatat64 (__NR_openat + 5)
-unlinkat (__NR_openat + 6)
-renameat (__NR_openat + 7)
-linkat (__NR_openat + 8)
-symlinkat (__NR_openat + 9)
-readlinkat (__NR_openat + 10)
-fchmodat (__NR_openat + 11)
-faccessat (__NR_openat + 12)
-splice 291
-tee 293
-vmsplice 294
-syncfs 327
-setns 328
-process_vm_readv 330
-process_vm_writev 331
-memfd_create 340
-membarrier 343
-execveat 342
-mlock2 345
-copy_file_range 346
-preadv2 347
-pwritev2 348
-io_pgetevents 350
-pidfd_send_signal 424
-io_uring_setup 425
-io_uring_enter 426
-io_uring_register 427
-open_tree 428
-move_mount 429
-fsopen 430
-fsconfig 431
-fsmount 432
-fspick 433
-pidfd_open 434
-close_range 436
-faccessat2 439
-epoll_pwait2 441
-quotactl_fd 443
-landlock_create_ruleset 444
-landlock_add_rule 445
-landlock_restrict_self 446
-futex_waitv 449
diff --git a/include/lapi/syscalls/i386.in b/include/lapi/syscalls/i386.in
index 31ec1ecb2..13f72e795 100644
--- a/include/lapi/syscalls/i386.in
+++ b/include/lapi/syscalls/i386.in
@@ -111,7 +111,6 @@ olduname 109
 iopl 110
 vhangup 111
 idle 112
-vm86old 113
 wait4 114
 swapoff 115
 sysinfo 116
@@ -132,7 +131,6 @@ get_kernel_syms 130
 quotactl 131
 getpgid 132
 fchdir 133
-bdflush 134
 sysfs 135
 personality 136
 afs_syscall 137
@@ -164,7 +162,6 @@ nanosleep 162
 mremap 163
 setresuid 164
 getresuid 165
-vm86 166
 query_module 167
 poll 168
 nfsservctl 169
@@ -218,7 +215,6 @@ setfsgid32 216
 pivot_root 217
 mincore 218
 madvise 219
-madvise1 219
 getdents64 220
 fcntl64 221
 gettid 224
@@ -428,9 +424,26 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+memfd_secret 447
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/ia64.in b/include/lapi/syscalls/ia64.in
index 2e56da7f9..cd770bace 100644
--- a/include/lapi/syscalls/ia64.in
+++ b/include/lapi/syscalls/ia64.in
@@ -347,3 +347,8 @@ landlock_create_ruleset 1468
 landlock_add_rule 1469
 landlock_restrict_self 1470
 futex_waitv 1473
+cachestat 1475
+fchmodat2 1476
+mseal 1486
+statmount 1481
+listmount 1482
diff --git a/include/lapi/syscalls/aarch64.in b/include/lapi/syscalls/loongarch64.in
similarity index 93%
rename from include/lapi/syscalls/aarch64.in
rename to include/lapi/syscalls/loongarch64.in
index 3e7797718..2c1ecd7ae 100644
--- a/include/lapi/syscalls/aarch64.in
+++ b/include/lapi/syscalls/loongarch64.in
@@ -36,7 +36,6 @@ mkdirat 34
 unlinkat 35
 symlinkat 36
 linkat 37
-renameat 38
 umount2 39
 mount 40
 pivot_root 41
@@ -77,12 +76,11 @@ vmsplice 75
 splice 76
 tee 77
 readlinkat 78
-fstatat 79
+newfstatat 79
 fstat 80
 sync 81
 fsync 82
 fdatasync 83
-sync_file_range2 84
 sync_file_range 84
 timerfd_create 85
 timerfd_settime 86
@@ -162,8 +160,6 @@ setgroups 159
 uname 160
 sethostname 161
 setdomainname 162
-getrlimit 163
-setrlimit 164
 getrusage 165
 umask 166
 prctl 167
@@ -294,10 +290,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
-_sysctl 1078
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/mips_n64.in b/include/lapi/syscalls/mips64.in
similarity index 95%
rename from include/lapi/syscalls/mips_n64.in
rename to include/lapi/syscalls/mips64.in
index f81c60e66..8be734158 100644
--- a/include/lapi/syscalls/mips_n64.in
+++ b/include/lapi/syscalls/mips64.in
@@ -175,7 +175,6 @@ nfsservctl 5173
 getpmsg 5174
 putpmsg 5175
 afs_syscall 5176
-reserved177 5177
 gettid 5178
 readahead 5179
 setxattr 5180
@@ -191,7 +190,6 @@ removexattr 5189
 lremovexattr 5190
 fremovexattr 5191
 tkill 5192
-reserved193 5193
 futex 5194
 sched_setaffinity 5195
 sched_getaffinity 5196
@@ -349,4 +347,18 @@ quotactl_fd 5443
 landlock_create_ruleset 5444
 landlock_add_rule 5445
 landlock_restrict_self 5446
+process_mrelease 5448
 futex_waitv 5449
+set_mempolicy_home_node 5450
+cachestat 5451
+fchmodat2 5452
+map_shadow_stack 5453
+futex_wake 5454
+futex_wait 5455
+futex_requeue 5456
+statmount 5457
+listmount 5458
+lsm_get_self_attr 5459
+lsm_set_self_attr 5460
+lsm_list_modules 5461
+mseal 5462
diff --git a/include/lapi/syscalls/mips_n32.in b/include/lapi/syscalls/mips64n32.in
similarity index 95%
rename from include/lapi/syscalls/mips_n32.in
rename to include/lapi/syscalls/mips64n32.in
index 5f0fe65eb..153fe50bf 100644
--- a/include/lapi/syscalls/mips_n32.in
+++ b/include/lapi/syscalls/mips64n32.in
@@ -175,7 +175,6 @@ nfsservctl 6173
 getpmsg 6174
 putpmsg 6175
 afs_syscall 6176
-reserved177 6177
 gettid 6178
 readahead 6179
 setxattr 6180
@@ -191,7 +190,6 @@ removexattr 6189
 lremovexattr 6190
 fremovexattr 6191
 tkill 6192
-reserved193 6193
 futex 6194
 sched_setaffinity 6195
 sched_getaffinity 6196
@@ -373,4 +371,18 @@ quotactl_fd 6443
 landlock_create_ruleset 6444
 landlock_add_rule 6445
 landlock_restrict_self 6446
+process_mrelease 6448
 futex_waitv 6449
+set_mempolicy_home_node 6450
+cachestat 6451
+fchmodat2 6452
+map_shadow_stack 6453
+futex_wake 6454
+futex_wait 6455
+futex_requeue 6456
+statmount 6457
+listmount 6458
+lsm_get_self_attr 6459
+lsm_set_self_attr 6460
+lsm_list_modules 6461
+mseal 6462
diff --git a/include/lapi/syscalls/mips_o32.in b/include/lapi/syscalls/mipso32.in
similarity index 95%
rename from include/lapi/syscalls/mips_o32.in
rename to include/lapi/syscalls/mipso32.in
index c2beffb75..1ed74c1ec 100644
--- a/include/lapi/syscalls/mips_o32.in
+++ b/include/lapi/syscalls/mipso32.in
@@ -16,7 +16,6 @@ mknod 4014
 chmod 4015
 lchown 4016
 break 4017
-unused18 4018
 lseek 4019
 getpid 4020
 mount 4021
@@ -26,7 +25,6 @@ getuid 4024
 stime 4025
 ptrace 4026
 alarm 4027
-unused28 4028
 pause 4029
 utime 4030
 stty 4031
@@ -80,9 +78,7 @@ gettimeofday 4078
 settimeofday 4079
 getgroups 4080
 setgroups 4081
-reserved82 4082
 symlink 4083
-unused84 4084
 readlink 4085
 uselib 4086
 swapon 4087
@@ -111,7 +107,6 @@ unused109 4109
 iopl 4110
 vhangup 4111
 idle 4112
-vm86 4113
 wait4 4114
 swapoff 4115
 sysinfo 4116
@@ -132,7 +127,6 @@ get_kernel_syms 4130
 quotactl 4131
 getpgid 4132
 fchdir 4133
-bdflush 4134
 sysfs 4135
 personality 4136
 afs_syscall 4137
@@ -148,7 +142,6 @@ writev 4146
 cacheflush 4147
 cachectl 4148
 sysmips 4149
-unused150 4150
 getsid 4151
 fdatasync 4152
 _sysctl 4153
@@ -219,7 +212,6 @@ mincore 4217
 madvise 4218
 getdents64 4219
 fcntl64 4220
-reserved221 4221
 gettid 4222
 readahead 4223
 setxattr 4224
@@ -419,4 +411,18 @@ quotactl_fd 4443
 landlock_create_ruleset 4444
 landlock_add_rule 4445
 landlock_restrict_self 4446
+process_mrelease 4448
 futex_waitv 4449
+set_mempolicy_home_node 4450
+cachestat 4451
+fchmodat2 4452
+map_shadow_stack 4453
+futex_wake 4454
+futex_wait 4455
+futex_requeue 4456
+statmount 4457
+listmount 4458
+lsm_get_self_attr 4459
+lsm_set_self_attr 4460
+lsm_list_modules 4461
+mseal 4462
diff --git a/include/lapi/syscalls/parisc.in b/include/lapi/syscalls/parisc.in
new file mode 100644
index 000000000..662bfea44
--- /dev/null
+++ b/include/lapi/syscalls/parisc.in
@@ -0,0 +1,397 @@
+restart_syscall 0
+exit 1
+fork 2
+read 3
+write 4
+open 5
+close 6
+waitpid 7
+creat 8
+link 9
+unlink 10
+execve 11
+chdir 12
+time 13
+mknod 14
+chmod 15
+lchown 16
+socket 17
+stat 18
+lseek 19
+getpid 20
+mount 21
+bind 22
+setuid 23
+getuid 24
+stime 25
+ptrace 26
+alarm 27
+fstat 28
+pause 29
+utime 30
+connect 31
+listen 32
+access 33
+nice 34
+accept 35
+sync 36
+kill 37
+rename 38
+mkdir 39
+rmdir 40
+dup 41
+pipe 42
+times 43
+getsockname 44
+brk 45
+setgid 46
+getgid 47
+signal 48
+geteuid 49
+getegid 50
+acct 51
+umount2 52
+getpeername 53
+ioctl 54
+fcntl 55
+socketpair 56
+setpgid 57
+send 58
+uname 59
+umask 60
+chroot 61
+ustat 62
+dup2 63
+getppid 64
+getpgrp 65
+setsid 66
+pivot_root 67
+sgetmask 68
+ssetmask 69
+setreuid 70
+setregid 71
+mincore 72
+sigpending 73
+sethostname 74
+setrlimit 75
+getrlimit 76
+getrusage 77
+gettimeofday 78
+settimeofday 79
+getgroups 80
+setgroups 81
+sendto 82
+symlink 83
+lstat 84
+readlink 85
+uselib 86
+swapon 87
+reboot 88
+mmap2 89
+mmap 90
+munmap 91
+truncate 92
+ftruncate 93
+fchmod 94
+fchown 95
+getpriority 96
+setpriority 97
+recv 98
+statfs 99
+fstatfs 100
+stat64 101
+syslog 103
+setitimer 104
+getitimer 105
+capget 106
+capset 107
+pread64 108
+pwrite64 109
+getcwd 110
+vhangup 111
+fstat64 112
+vfork 113
+wait4 114
+swapoff 115
+sysinfo 116
+shutdown 117
+fsync 118
+madvise 119
+clone 120
+setdomainname 121
+sendfile 122
+recvfrom 123
+adjtimex 124
+mprotect 125
+sigprocmask 126
+init_module 128
+delete_module 129
+quotactl 131
+getpgid 132
+fchdir 133
+sysfs 135
+personality 136
+setfsuid 138
+setfsgid 139
+_llseek 140
+getdents 141
+_newselect 142
+flock 143
+msync 144
+readv 145
+writev 146
+getsid 147
+fdatasync 148
+_sysctl 149
+mlock 150
+munlock 151
+mlockall 152
+munlockall 153
+sched_setparam 154
+sched_getparam 155
+sched_setscheduler 156
+sched_getscheduler 157
+sched_yield 158
+sched_get_priority_max 159
+sched_get_priority_min 160
+sched_rr_get_interval 161
+nanosleep 162
+mremap 163
+setresuid 164
+getresuid 165
+sigaltstack 166
+poll 168
+setresgid 170
+getresgid 171
+prctl 172
+rt_sigreturn 173
+rt_sigaction 174
+rt_sigprocmask 175
+rt_sigpending 176
+rt_sigtimedwait 177
+rt_sigqueueinfo 178
+rt_sigsuspend 179
+chown 180
+setsockopt 181
+getsockopt 182
+sendmsg 183
+recvmsg 184
+semop 185
+semget 186
+semctl 187
+msgsnd 188
+msgrcv 189
+msgget 190
+msgctl 191
+shmat 192
+shmdt 193
+shmget 194
+shmctl 195
+lstat64 198
+truncate64 199
+ftruncate64 200
+getdents64 201
+fcntl64 202
+gettid 206
+readahead 207
+tkill 208
+sendfile64 209
+futex 210
+sched_setaffinity 211
+sched_getaffinity 212
+io_setup 215
+io_destroy 216
+io_getevents 217
+io_submit 218
+io_cancel 219
+exit_group 222
+lookup_dcookie 223
+epoll_create 224
+epoll_ctl 225
+epoll_wait 226
+remap_file_pages 227
+semtimedop 228
+mq_open 229
+mq_unlink 230
+mq_timedsend 231
+mq_timedreceive 232
+mq_notify 233
+mq_getsetattr 234
+waitid 235
+fadvise64_64 236
+set_tid_address 237
+setxattr 238
+lsetxattr 239
+fsetxattr 240
+getxattr 241
+lgetxattr 242
+fgetxattr 243
+listxattr 244
+llistxattr 245
+flistxattr 246
+removexattr 247
+lremovexattr 248
+fremovexattr 249
+timer_create 250
+timer_settime 251
+timer_gettime 252
+timer_getoverrun 253
+timer_delete 254
+clock_settime 255
+clock_gettime 256
+clock_getres 257
+clock_nanosleep 258
+tgkill 259
+mbind 260
+get_mempolicy 261
+set_mempolicy 262
+add_key 264
+request_key 265
+keyctl 266
+ioprio_set 267
+ioprio_get 268
+inotify_init 269
+inotify_add_watch 270
+inotify_rm_watch 271
+migrate_pages 272
+pselect6 273
+ppoll 274
+openat 275
+mkdirat 276
+mknodat 277
+fchownat 278
+futimesat 279
+fstatat64 280
+unlinkat 281
+renameat 282
+linkat 283
+symlinkat 284
+readlinkat 285
+fchmodat 286
+faccessat 287
+unshare 288
+set_robust_list 289
+get_robust_list 290
+splice 291
+sync_file_range 292
+tee 293
+vmsplice 294
+move_pages 295
+getcpu 296
+epoll_pwait 297
+statfs64 298
+fstatfs64 299
+kexec_load 300
+utimensat 301
+signalfd 302
+eventfd 304
+fallocate 305
+timerfd_create 306
+timerfd_settime 307
+timerfd_gettime 308
+signalfd4 309
+eventfd2 310
+epoll_create1 311
+dup3 312
+pipe2 313
+inotify_init1 314
+preadv 315
+pwritev 316
+rt_tgsigqueueinfo 317
+perf_event_open 318
+recvmmsg 319
+accept4 320
+prlimit64 321
+fanotify_init 322
+fanotify_mark 323
+clock_adjtime 324
+name_to_handle_at 325
+open_by_handle_at 326
+syncfs 327
+setns 328
+sendmmsg 329
+process_vm_readv 330
+process_vm_writev 331
+kcmp 332
+finit_module 333
+sched_setattr 334
+sched_getattr 335
+utimes 336
+renameat2 337
+seccomp 338
+getrandom 339
+memfd_create 340
+bpf 341
+execveat 342
+membarrier 343
+userfaultfd 344
+mlock2 345
+copy_file_range 346
+preadv2 347
+pwritev2 348
+statx 349
+io_pgetevents 350
+pkey_mprotect 351
+pkey_alloc 352
+pkey_free 353
+rseq 354
+kexec_file_load 355
+cacheflush 356
+clock_gettime64 403
+clock_settime64 404
+clock_adjtime64 405
+clock_getres_time64 406
+clock_nanosleep_time64 407
+timer_gettime64 408
+timer_settime64 409
+timerfd_gettime64 410
+timerfd_settime64 411
+utimensat_time64 412
+pselect6_time64 413
+ppoll_time64 414
+io_pgetevents_time64 416
+recvmmsg_time64 417
+mq_timedsend_time64 418
+mq_timedreceive_time64 419
+semtimedop_time64 420
+rt_sigtimedwait_time64 421
+futex_time64 422
+sched_rr_get_interval_time64 423
+pidfd_send_signal 424
+io_uring_setup 425
+io_uring_enter 426
+io_uring_register 427
+open_tree 428
+move_mount 429
+fsopen 430
+fsconfig 431
+fsmount 432
+fspick 433
+pidfd_open 434
+clone3 435
+close_range 436
+openat2 437
+pidfd_getfd 438
+faccessat2 439
+process_madvise 440
+epoll_pwait2 441
+mount_setattr 442
+quotactl_fd 443
+landlock_create_ruleset 444
+landlock_add_rule 445
+landlock_restrict_self 446
+process_mrelease 448
+futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/powerpc.in b/include/lapi/syscalls/powerpc.in
index 5460e4197..faaa75883 100644
--- a/include/lapi/syscalls/powerpc.in
+++ b/include/lapi/syscalls/powerpc.in
@@ -111,7 +111,6 @@ olduname 109
 iopl 110
 vhangup 111
 idle 112
-vm86 113
 wait4 114
 swapoff 115
 sysinfo 116
@@ -132,7 +131,6 @@ get_kernel_syms 130
 quotactl 131
 getpgid 132
 fchdir 133
-bdflush 134
 sysfs 135
 personality 136
 afs_syscall 137
@@ -199,7 +197,6 @@ fstat64 197
 pciconfig_read 198
 pciconfig_write 199
 pciconfig_iobase 200
-multiplexer 201
 getdents64 202
 pivot_root 203
 fcntl64 204
@@ -253,7 +250,6 @@ statfs64 252
 fstatfs64 253
 fadvise64_64 254
 rtas 255
-sys_debug_setcontext 256
 migrate_pages 258
 mbind 259
 get_mempolicy 260
@@ -287,7 +283,6 @@ mkdirat 287
 mknodat 288
 fchownat 289
 futimesat 290
-newfstatat 291
 fstatat64 291
 unlinkat 292
 renameat 293
@@ -374,7 +369,6 @@ pkey_free 385
 pkey_mprotect 386
 rseq 387
 io_pgetevents 388
-semtimedop 392
 semget 393
 semctl 394
 shmget 395
@@ -421,9 +415,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/powerpc64.in b/include/lapi/syscalls/powerpc64.in
index 5460e4197..23b65e784 100644
--- a/include/lapi/syscalls/powerpc64.in
+++ b/include/lapi/syscalls/powerpc64.in
@@ -111,7 +111,6 @@ olduname 109
 iopl 110
 vhangup 111
 idle 112
-vm86 113
 wait4 114
 swapoff 115
 sysinfo 116
@@ -132,7 +131,6 @@ get_kernel_syms 130
 quotactl 131
 getpgid 132
 fchdir 133
-bdflush 134
 sysfs 135
 personality 136
 afs_syscall 137
@@ -190,19 +188,11 @@ putpmsg 188
 vfork 189
 ugetrlimit 190
 readahead 191
-mmap2 192
-truncate64 193
-ftruncate64 194
-stat64 195
-lstat64 196
-fstat64 197
 pciconfig_read 198
 pciconfig_write 199
 pciconfig_iobase 200
-multiplexer 201
 getdents64 202
 pivot_root 203
-fcntl64 204
 madvise 205
 mincore 206
 gettid 207
@@ -223,7 +213,6 @@ futex 221
 sched_setaffinity 222
 sched_getaffinity 223
 tuxcall 225
-sendfile64 226
 io_setup 227
 io_destroy 228
 io_getevents 229
@@ -251,9 +240,7 @@ tgkill 250
 utimes 251
 statfs64 252
 fstatfs64 253
-fadvise64_64 254
 rtas 255
-sys_debug_setcontext 256
 migrate_pages 258
 mbind 259
 get_mempolicy 260
@@ -288,7 +275,6 @@ mknodat 288
 fchownat 289
 futimesat 290
 newfstatat 291
-fstatat64 291
 unlinkat 292
 renameat 293
 linkat 294
@@ -385,26 +371,6 @@ msgget 399
 msgsnd 400
 msgrcv 401
 msgctl 402
-clock_gettime64 403
-clock_settime64 404
-clock_adjtime64 405
-clock_getres_time64 406
-clock_nanosleep_time64 407
-timer_gettime64 408
-timer_settime64 409
-timerfd_gettime64 410
-timerfd_settime64 411
-utimensat_time64 412
-pselect6_time64 413
-ppoll_time64 414
-io_pgetevents_time64 416
-recvmmsg_time64 417
-mq_timedsend_time64 418
-mq_timedreceive_time64 419
-semtimedop_time64 420
-rt_sigtimedwait_time64 421
-futex_time64 422
-sched_rr_get_interval_time64 423
 pidfd_send_signal 424
 io_uring_setup 425
 io_uring_enter 426
@@ -421,9 +387,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/regen.sh b/include/lapi/syscalls/regen.sh
deleted file mode 100755
index 871a8dffb..000000000
--- a/include/lapi/syscalls/regen.sh
+++ /dev/null
@@ -1,142 +0,0 @@
-#!/bin/sh
-
-output="syscalls.h"
-
-# For soon to be able to provide an argument
-# for output file so the header generation can
-# be added as a dependency in Android.bp
-if [ $# -gt 0 ]; then
-	output=$1
-	echo "ltp syscalls gen output: "$output
-	rm -f "${output}"
-fi
-
-rm -f "${output}".[1-9]*
-output_pid="${output}.$$"
-
-max_jobs=$(getconf _NPROCESSORS_ONLN 2>/dev/null)
-: ${max_jobs:=1}
-
-srcdir=${0%/*}
-
-err() {
-	echo "$*" 1>&2
-	exit 1
-}
-
-cat << EOF > "${output_pid}"
-/************************************************
- * GENERATED FILE: DO NOT EDIT/PATCH THIS FILE  *
- *  change your arch specific .in file instead  *
- ************************************************/
-
-/*
- * Here we stick all the ugly *fallback* logic for linux
- * system call numbers (those __NR_ thingies).
- *
- * Licensed under the GPLv2 or later, see the COPYING file.
- */
-
-#ifndef LAPI_SYSCALLS_H__
-#define LAPI_SYSCALLS_H__
-
-#include <errno.h>
-#include <sys/syscall.h>
-#include <asm/unistd.h>
-#include "cleanup.c"
-
-#ifdef TST_TEST_H__
-#define TST_SYSCALL_BRK__(NR, SNR) ({ \\
-	tst_brk(TCONF, \\
-		"syscall(%d) " SNR " not supported on your arch", NR); \\
-})
-#else
-#define TST_SYSCALL_BRK__(NR, SNR) ({ \\
-	tst_brkm(TCONF, CLEANUP, \\
-		"syscall(%d) " SNR " not supported on your arch", NR); \\
-})
-#endif
-
-#define tst_syscall(NR, ...) ({ \\
-	intptr_t tst_ret; \\
-	if (NR == __LTP__NR_INVALID_SYSCALL) { \\
-		errno = ENOSYS; \\
-		tst_ret = -1; \\
-	} else { \\
-		tst_ret = syscall(NR, ##__VA_ARGS__); \\
-	} \\
-	if (tst_ret == -1 && errno == ENOSYS) { \\
-		TST_SYSCALL_BRK__(NR, #NR); \\
-	} \\
-	tst_ret; \\
-})
-
-EOF
-
-jobs=0
-for arch in $(cat "${srcdir}/order") ; do
-	(
-	echo "Generating data for arch $arch ... "
-
-	(
-	echo
-	case ${arch} in
-		sparc64) echo "#if defined(__sparc__) && defined(__arch64__)" ;;
-		sparc) echo "#if defined(__sparc__) && !defined(__arch64__)" ;;
-		s390) echo "#if defined(__s390__) && !defined(__s390x__)" ;;
-		mips_n32) echo "#if defined(__mips__) && defined(_ABIN32)" ;;
-		mips_n64) echo "#if defined(__mips__) && defined(_ABI64)" ;;
-		mips_o32) echo "#if defined(__mips__) && defined(_ABIO32) && _MIPS_SZLONG == 32" ;;
-		*) echo "#ifdef __${arch}__" ;;
-	esac
-	while read line ; do
-		set -- ${line}
-		nr="__NR_$1"
-		shift
-		if [ $# -eq 0 ] ; then
-			err "invalid line found: $line"
-		fi
-		echo "# ifndef ${nr}"
-		echo "#  define ${nr} $*"
-		echo "# endif"
-	done < "${srcdir}/${arch}.in"
-	echo "#endif"
-	echo
-	) >> "${output_pid}.${arch}"
-
-	) &
-
-	jobs=$(( jobs + 1 ))
-	if [ ${jobs} -ge ${max_jobs} ] ; then
-		wait || exit 1
-		jobs=0
-	fi
-done
-
-echo "Generating stub list ... "
-(
-echo
-echo "/* Common stubs */"
-echo "#define __LTP__NR_INVALID_SYSCALL -1" >> "${output_pid}"
-for nr in $(awk '{print $1}' "${srcdir}/"*.in | sort -u) ; do
-	nr="__NR_${nr}"
-	echo "# ifndef ${nr}"
-	echo "#  define ${nr} __LTP__NR_INVALID_SYSCALL"
-	echo "# endif"
-done
-echo "#endif"
-) >> "${output_pid}._footer"
-
-wait || exit 1
-
-printf "Combining them all ... "
-for arch in $(cat "${srcdir}/order") _footer ; do
-	cat "${output_pid}.${arch}"
-done >> "${output_pid}"
-if [ $# -gt 0 ]; then
-	mv "${output_pid}" "${output}"
-else
-	mv "${output_pid}" "../${output}"
-fi
-rm -f "${output_pid}"*
-echo "OK!"
diff --git a/include/lapi/syscalls/s390.in b/include/lapi/syscalls/s390.in
index 275b27f47..69d7408b7 100644
--- a/include/lapi/syscalls/s390.in
+++ b/include/lapi/syscalls/s390.in
@@ -112,7 +112,6 @@ get_kernel_syms 130
 quotactl 131
 getpgid 132
 fchdir 133
-bdflush 134
 sysfs 135
 personality 136
 afs_syscall 137
@@ -408,9 +407,26 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+memfd_secret 447
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/s390x.in b/include/lapi/syscalls/s390x.in
index c200d02b2..fa98054c7 100644
--- a/include/lapi/syscalls/s390x.in
+++ b/include/lapi/syscalls/s390x.in
@@ -96,7 +96,6 @@ get_kernel_syms 130
 quotactl 131
 getpgid 132
 fchdir 133
-bdflush 134
 sysfs 135
 personality 136
 afs_syscall 137
@@ -356,9 +355,26 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+memfd_secret 447
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/sh.in b/include/lapi/syscalls/sh.in
index 6f482a77b..2e584253c 100644
--- a/include/lapi/syscalls/sh.in
+++ b/include/lapi/syscalls/sh.in
@@ -115,7 +115,6 @@ delete_module 129
 quotactl 131
 getpgid 132
 fchdir 133
-bdflush 134
 sysfs 135
 personality 136
 setfsuid 138
@@ -357,6 +356,7 @@ pkey_mprotect 384
 pkey_alloc 385
 pkey_free 386
 rseq 387
+sync_file_range2 388
 semget 393
 semctl 394
 shmget 395
@@ -402,9 +402,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/sparc.in b/include/lapi/syscalls/sparc.in
index 7181e80a0..fcdb9b812 100644
--- a/include/lapi/syscalls/sparc.in
+++ b/include/lapi/syscalls/sparc.in
@@ -221,7 +221,6 @@ create_module 221
 delete_module 222
 get_kernel_syms 223
 getpgid 224
-bdflush 225
 sysfs 226
 afs_syscall 227
 setfsuid 228
@@ -407,9 +406,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/sparc64.in b/include/lapi/syscalls/sparc64.in
index c96ab2021..4256aaf77 100644
--- a/include/lapi/syscalls/sparc64.in
+++ b/include/lapi/syscalls/sparc64.in
@@ -29,8 +29,6 @@ alarm 27
 sigaltstack 28
 pause 29
 utime 30
-lchown32 31
-fchown32 32
 access 33
 nice 34
 sync 36
@@ -206,7 +204,6 @@ create_module 221
 delete_module 222
 get_kernel_syms 223
 getpgid 224
-bdflush 225
 sysfs 226
 afs_syscall 227
 setfsuid 228
@@ -372,9 +369,25 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+process_mrelease 448
 futex_waitv 449
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/syscalls/strip_syscall.awk b/include/lapi/syscalls/strip_syscall.awk
deleted file mode 100755
index e8dff422e..000000000
--- a/include/lapi/syscalls/strip_syscall.awk
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/usr/bin/awk -f
-#
-# Dumb script that can be used to strip all of the syscall information from
-# the arch-respective unistd*.h.
-#
-# Examples:
-#
-# 1. Grab the i386 32-bit syscalls from unistd_32.h and put them in i386.in
-# strip_syscall.awk arch/x86/include/asm/unistd_32.h > i386.in
-#
-
-/^#define[[:space:]]+__NR_[0-9a-z]+/ {
-
-	sub (/#define[[:space:]]+__NR_/, "", $0);
-	sub (/[[:space:]]*(\/\*.*)/, "", $0);
-	sub (/[[:space:]]+/, " ", $0);
-
-	print
-}
diff --git a/include/lapi/syscalls/order b/include/lapi/syscalls/supported-arch.txt
similarity index 58%
rename from include/lapi/syscalls/order
rename to include/lapi/syscalls/supported-arch.txt
index c18aa38cf..c5c5191ac 100644
--- a/include/lapi/syscalls/order
+++ b/include/lapi/syscalls/supported-arch.txt
@@ -1,13 +1,13 @@
-aarch64
 arc
+arm64
 arm
-hppa
 i386
 ia64
-loongarch
-mips_n32
-mips_n64
-mips_o32
+loongarch64
+mips64n32
+mips64
+mipso32
+parisc
 powerpc64
 powerpc
 s390x
diff --git a/include/lapi/syscalls/x86_64.in b/include/lapi/syscalls/x86_64.in
index 3082ca110..e6c0a3b40 100644
--- a/include/lapi/syscalls/x86_64.in
+++ b/include/lapi/syscalls/x86_64.in
@@ -333,6 +333,7 @@ pkey_free 331
 statx 332
 io_pgetevents 333
 rseq 334
+uretprobe 335
 pidfd_send_signal 424
 io_uring_setup 425
 io_uring_enter 426
@@ -349,45 +350,26 @@ close_range 436
 openat2 437
 pidfd_getfd 438
 faccessat2 439
+process_madvise 440
 epoll_pwait2 441
+mount_setattr 442
 quotactl_fd 443
 landlock_create_ruleset 444
 landlock_add_rule 445
 landlock_restrict_self 446
+memfd_secret 447
+process_mrelease 448
 futex_waitv 449
-rt_sigaction 512
-rt_sigreturn 513
-ioctl 514
-readv 515
-writev 516
-recvfrom 517
-sendmsg 518
-recvmsg 519
-execve 520
-ptrace 521
-rt_sigpending 522
-rt_sigtimedwait 523
-rt_sigqueueinfo 524
-sigaltstack 525
-timer_create 526
-mq_notify 527
-kexec_load 528
-waitid 529
-set_robust_list 530
-get_robust_list 531
-vmsplice 532
-move_pages 533
-preadv 534
-pwritev 535
-rt_tgsigqueueinfo 536
-recvmmsg 537
-sendmmsg 538
-process_vm_readv 539
-process_vm_writev 540
-setsockopt 541
-getsockopt 542
-io_setup 543
-io_submit 544
-execveat 545
-preadv2 546
-pwritev2 547
+set_mempolicy_home_node 450
+cachestat 451
+fchmodat2 452
+map_shadow_stack 453
+futex_wake 454
+futex_wait 455
+futex_requeue 456
+statmount 457
+listmount 458
+lsm_get_self_attr 459
+lsm_set_self_attr 460
+lsm_list_modules 461
+mseal 462
diff --git a/include/lapi/preadv2.h b/include/lapi/uio.h
similarity index 50%
rename from include/lapi/preadv2.h
rename to include/lapi/uio.h
index db89547e2..0ad2faacf 100644
--- a/include/lapi/preadv2.h
+++ b/include/lapi/uio.h
@@ -7,6 +7,7 @@
 #ifndef LAPI_PREADV2_H__
 #define LAPI_PREADV2_H__
 
+#include <sys/uio.h>
 #include "config.h"
 #include "lapi/syscalls.h"
 
@@ -14,11 +15,27 @@
 # define RWF_NOWAIT 0x00000008
 #endif
 
-#if !defined(HAVE_PREADV2)
 
 /* LO_HI_LONG taken from glibc */
 # define LO_HI_LONG(val) (long) (val), (long) (((uint64_t) (val)) >> 32)
 
+#if !defined(HAVE_PREADV)
+static inline ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
+	off_t offset)
+{
+	return tst_syscall(__NR_preadv, fd, iov, iovcnt, LO_HI_LONG(offset));
+}
+#endif
+
+#if !defined(HAVE_PWRITEV)
+static inline ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
+	off_t offset)
+{
+	return tst_syscall(__NR_pwritev, fd, iov, iovcnt, LO_HI_LONG(offset));
+}
+#endif
+
+#if !defined(HAVE_PREADV2)
 static inline ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
                               off_t offset, int flags)
 {
@@ -27,4 +44,15 @@ static inline ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
 }
 #endif
 
+#if !defined(HAVE_PWRITEV2)
+static inline ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
+                               off_t offset, int flags)
+{
+	return tst_syscall(__NR_pwritev2, fd, iov, iovcnt,
+			   LO_HI_LONG(offset), flags);
+}
+#endif
+
+#undef LO_HI_LONG
+
 #endif /* LAPI_PREADV2_H__ */
diff --git a/include/libswap.h b/include/libswap.h
index 1389b5857..6904e8f45 100644
--- a/include/libswap.h
+++ b/include/libswap.h
@@ -5,7 +5,9 @@
  * Author: Stanislav Kholmanskikh <stanislav.kholmanskikh@oracle.com>
  */
 
-/*
+/**
+ * DOC: libltpswap
+ *
  * Contains common content for all swapon/swapoff tests.
  */
 
diff --git a/include/mk/automake.mk b/include/mk/automake.mk
index 3ecdd3144..0fa059f11 100644
--- a/include/mk/automake.mk
+++ b/include/mk/automake.mk
@@ -27,15 +27,10 @@ AUTOHEADER	?= autoheader
 AUTOMAKE	?= automake
 
 AUTOCONFED_SUBDIRS	= \
-			testcases/realtime \
 			testcases/open_posix_testsuite
 
 # We want to run this every single time to ensure that all of the prereq files
 # are there.
-.PHONY: testcases/realtime/configure
-testcases/realtime/configure:
-	$(MAKE) -C $(@D) autotools
-
 .PHONY: testcases/open_posix_testsuite/configure
 testcases/open_posix_testsuite/configure:
 	$(MAKE) -C $(@D) autotools
diff --git a/include/mk/env_post.mk b/include/mk/env_post.mk
index 0bbbc3705..4dd3f1e2d 100644
--- a/include/mk/env_post.mk
+++ b/include/mk/env_post.mk
@@ -90,7 +90,7 @@ CHECK_TARGETS			?= $(addprefix check-,$(notdir $(patsubst %.c,%,$(sort $(wildcar
 CHECK_TARGETS			:= $(filter-out $(addprefix check-, $(FILTER_OUT_MAKE_TARGETS)), $(CHECK_TARGETS))
 CHECK_HEADER_TARGETS		?= $(addprefix check-,$(notdir $(sort $(wildcard $(abs_srcdir)/*.h))))
 CHECK				?= $(abs_top_srcdir)/tools/sparse/sparse-ltp
-CHECK_NOFLAGS			?= $(abs_top_srcdir)/scripts/checkpatch.pl -f --no-tree --terse --no-summary --ignore CONST_STRUCT,VOLATILE,SPLIT_STRING
+CHECK_NOFLAGS			?= $(abs_top_srcdir)/scripts/checkpatch.pl -f --no-tree --terse --no-summary --ignore CONST_STRUCT,VOLATILE,SPLIT_STRING,FILE_PATH_CHANGES
 SHELL_CHECK			?= $(abs_top_srcdir)/scripts/checkbashisms.pl --force --extra
 SHELL_CHECK_TARGETS		?= $(addprefix check-,$(notdir $(sort $(wildcard $(abs_srcdir)/*.sh))))
 
diff --git a/include/mk/features.mk.in b/include/mk/features.mk.in
index 73a2f6658..2fc5230d4 100644
--- a/include/mk/features.mk.in
+++ b/include/mk/features.mk.in
@@ -39,8 +39,5 @@ WITH_METADATA_PDF		:= @WITH_METADATA_PDF@
 # Enable testcases/open_posix_testsuite's compile and install?
 WITH_OPEN_POSIX_TESTSUITE	:= @WITH_OPEN_POSIX_TESTSUITE@
 
-# Enable testcases/realtime's compile and install?
-WITH_REALTIME_TESTSUITE		:= @WITH_REALTIME_TESTSUITE@
-
 # Enable testcases/kernel/kvm compile and install?
 WITH_KVM_TESTSUITE		:= @WITH_KVM_TESTSUITE@
diff --git a/include/mk/testcases.mk b/include/mk/testcases.mk
index 444020f16..bec8d8cc4 100644
--- a/include/mk/testcases.mk
+++ b/include/mk/testcases.mk
@@ -44,8 +44,8 @@ LDLIBS		+= -lltp
 
 ifdef LTPLIBS
 
-LTPLIBS_DIRS = $(addprefix $(abs_top_builddir)/libs/lib, $(LTPLIBS))
-LTPLIBS_FILES = $(addsuffix .a, $(addprefix $(abs_top_builddir)/libs/, $(foreach LIB,$(LTPLIBS),lib$(LIB)/lib$(LIB))))
+LTPLIBS_DIRS = $(addprefix $(abs_top_builddir)/libs/, $(LTPLIBS))
+LTPLIBS_FILES = $(addsuffix .a, $(addprefix $(abs_top_builddir)/libs/, $(foreach LIB,$(LTPLIBS),$(LIB)/lib$(LIB))))
 
 MAKE_DEPS += $(LTPLIBS_FILES)
 
@@ -61,7 +61,7 @@ else
 	@$(MAKE) --no-print-directory -C "$(dir $@)" -f "$(subst $(abs_top_builddir),$(abs_top_srcdir),$(dir $@))/Makefile" all
 endif
 
-LDFLAGS += $(addprefix -L$(top_builddir)/libs/lib, $(LTPLIBS))
+LDFLAGS += $(addprefix -L$(top_builddir)/libs/, $(LTPLIBS))
 
 endif
 
diff --git a/include/old/cleanup.c b/include/old/cleanup.c
deleted file mode 100644
index 040dff852..000000000
--- a/include/old/cleanup.c
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Default cleanup logic because linux_syscall_numbers.h's need for cleanup
- * and binutils bugs suck.
- *
- * Copyright (c) 2009 Cisco Systems, Inc.  All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it would be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * Further, this software is distributed without any warranty that it is
- * free of the rightful claim of any third person regarding infringement
- * or the like.  Any license provided herein, whether implied or
- * otherwise, applies only to this software file.  Patent licenses, if
- * any, provided herein do not apply to combinations of this program with
- * other software, or any other product whatsoever.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- */
-
-#ifndef __CLEANUP_C__
-#define __CLEANUP_C__
-
-/* Did the user define a cleanup function? */
-#ifndef CLEANUP
-#define USING_DUMMY_CLEANUP 1
-#define CLEANUP dummy_cleanup
-#endif
-
-/* A freebie for defining the function prototype. */
-static void CLEANUP(void) __attribute__ ((unused));
-
-#ifdef USING_DUMMY_CLEANUP
-/* The stub function. Wewt.. */
-static void dummy_cleanup(void)
-{
-}
-#endif
-
-#endif
diff --git a/include/old/old_module.h b/include/old/old_module.h
index 496520d64..f49c9937e 100644
--- a/include/old/old_module.h
+++ b/include/old/old_module.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013 Oracle and/or its affiliates. All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2016-2024
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -34,6 +35,8 @@
 #ifndef TST_MODULE
 #define TST_MODULE
 
+#include <stdbool.h>
+
 void tst_module_exists_(void (cleanup_fn)(void), const char *mod_name,
 					 char **mod_path);
 
@@ -42,6 +45,9 @@ void tst_module_load_(void (cleanup_fn)(void), const char *mod_name,
 
 void tst_module_unload_(void (cleanup_fn)(void), const char *mod_name);
 
+bool tst_module_signature_enforced_(void);
+void tst_requires_module_signature_disabled_(void);
+
 /*
  * Check module existence.
  *
@@ -86,4 +92,31 @@ static inline void tst_module_unload(void (cleanup_fn)(void), const char *mod_na
 	tst_module_unload_(cleanup_fn, mod_name);
 }
 
+/**
+ * tst_requires_module_signature_disabled() - Check if enforced module signature.
+ *
+ * Module signature is enforced if module.sig_enforce=1 kernel parameter or
+ * CONFIG_MODULE_SIG_FORCE=y.
+ *
+ * return: Returns true if module signature is enforced false otherwise.
+ *
+ */
+static inline bool tst_module_signature_enforced(void)
+{
+	return tst_module_signature_enforced_();
+}
+
+/**
+ * tst_requires_module_signature_disabled() - Check if test needs to be skipped due
+ * enforced module signature.
+ *
+ * Skip test with tst_brk(TCONF) due module signature enforcement if
+ * module.sig_enforce=1 kernel parameter or CONFIG_MODULE_SIG_FORCE=y.
+ */
+
+static inline void tst_requires_module_signature_disabled(void)
+{
+	tst_requires_module_signature_disabled_();
+}
+
 #endif /* TST_MODULE */
diff --git a/include/old/test.h b/include/old/test.h
index 0e210e4ef..306868fb5 100644
--- a/include/old/test.h
+++ b/include/old/test.h
@@ -31,7 +31,6 @@
 #include "tst_pid.h"
 #include "tst_cmd.h"
 #include "tst_cpu.h"
-#include "tst_clone.h"
 #include "old_device.h"
 #include "old_tmpdir.h"
 #include "tst_minmax.h"
diff --git a/include/pgsize_helpers.h b/include/pgsize_helpers.h
index a66448a4f..518dcd8b6 100644
--- a/include/pgsize_helpers.h
+++ b/include/pgsize_helpers.h
@@ -22,20 +22,12 @@ static inline size_t kernel_page_size(void)
 {
     return 0x1000;
 }
-
-/* Handle upto MAX_PAGE_SIZE emulation on 4KiB kernel base page size system */
-#define DECLARE_MINCORE_VECTOR(vec_name, num_pages) \
-    unsigned char vec_name[(num_pages) * (MAX_PAGE_SIZE / 4096)]
-
-#else	/* !defined(__x86_64__) */
-
+#else
 static inline size_t kernel_page_size(void)
 {
 	return getpagesize();
 }
-
-#define DECLARE_MINCORE_VECTOR(vec_name, num_pages) unsigned char vec_name[(num_pages)]
-#endif  /* defined(__x86_64__) */
+#endif
 
 /*
  * NOTE: For all cases except Android x86_64 page size emulators,
@@ -61,21 +53,6 @@ static size_t nr_kernel_pgs_to_nr_pgs(size_t nr_pages)
     return nr_pages / nr_kernel_pages(getpagesize());
 }
 
-/*
- * Test populating the last partial 4KiB page if the page size is emulated,
- * instead of the first. This faults in the preceding pages for convenient
- * test accounting.
- */
-#define MLOCK_PAGE_SIZE_EMULATION_OFFSET(tcases)                                            \
-do {                                                                                        \
-    if (getpagesize() != kernel_page_size()) {                                              \
-        for (int i = 0; i < ARRAY_SIZE(tcases); i++) {                                      \
-            struct tcase *test = tcases + i;                                                \
-            if (test->offset > 0) test->offset = pgsz - kernel_page_size() + test->offset;  \
-        }                                                                                   \
-    }                                                                                       \
-} while (0)
-
 /*
  * Make the backing file large enough to cover the last corresponding kernel page.
  *
diff --git a/include/tst_af_alg.h b/include/tst_af_alg.h
index 86df18eb8..5c307ed06 100644
--- a/include/tst_af_alg.h
+++ b/include/tst_af_alg.h
@@ -3,10 +3,11 @@
  * Copyright 2019 Google LLC
  * Copyright (c) Linux Test Project, 2021
  */
+
 /**
- * @file tst_af_alg.h
+ * DOC: tst_af_alg.h -- Kernel crypto algorithms (AF_ALG) helpers
  *
- * Library for accessing kernel crypto algorithms via AF_ALG.
+ * Helpers for accessing kernel crypto algorithms via AF_ALG.
  *
  * See https://www.kernel.org/doc/html/latest/crypto/userspace-if.html
  * for more information about AF_ALG.
@@ -19,21 +20,21 @@
 #include <stdbool.h>
 
 /**
- * Create an AF_ALG algorithm socket.
+ * tst_alg_create() - Create an AF_ALG algorithm socket.
  *
  * This creates an AF_ALG algorithm socket that is initially not bound to any
  * particular algorithm.  On failure, tst_brk() is called with TCONF if the
  * kernel doesn't support AF_ALG, otherwise TBROK.
  *
- * @return a new AF_ALG algorithm socket
+ * Return: a new AF_ALG algorithm socket
  */
 int tst_alg_create(void);
 
 /**
- * Bind an AF_ALG algorithm socket to an algorithm.
+ * tst_alg_bind_addr() - Bind an AF_ALG algorithm socket to an algorithm.
  *
- * @param algfd An AF_ALG algorithm socket
- * @param addr A structure which specifies the algorithm to use
+ * @algfd: An AF_ALG algorithm socket
+ * @addr: A structure which specifies the algorithm to use
  *
  * On failure, tst_brk() is called with TCONF if the kernel doesn't support the
  * specified algorithm, otherwise TBROK.
@@ -41,11 +42,11 @@ int tst_alg_create(void);
 void tst_alg_bind_addr(int algfd, const struct sockaddr_alg *addr);
 
 /**
- * Bind an AF_ALG algorithm socket to an algorithm.
+ * tst_alg_bind() - Bind an AF_ALG algorithm socket to an algorithm.
  *
- * @param algfd An AF_ALG algorithm socket
- * @param algtype The type of algorithm, such as "hash" or "skcipher"
- * @param algname The name of the algorithm, such as "sha256" or "xts(aes)"
+ * @algfd: An AF_ALG algorithm socket
+ * @algtype: The type of algorithm, such as "hash" or "skcipher"
+ * @algname: The name of the algorithm, such as "sha256" or "xts(aes)"
  *
  * Like tst_alg_bind_addr(), except this just takes in the algorithm type and
  * name.  The 'feat' and 'mask' fields are left 0.
@@ -56,32 +57,32 @@ void tst_alg_bind_addr(int algfd, const struct sockaddr_alg *addr);
 void tst_alg_bind(int algfd, const char *algtype, const char *algname);
 
 /**
- * Check for the availability of an algorithm.
+ * tst_try_alg() - Check for the availability of an algorithm.
  *
- * @param algtype The type of algorithm, such as "hash" or "skcipher"
- * @param algname The name of the algorithm, such as "sha256" or "xts(aes)"
+ * @algtype: The type of algorithm, such as "hash" or "skcipher"
+ * @algname: The name of the algorithm, such as "sha256" or "xts(aes)"
  *
- * Return 0 if the algorithm is available, or errno if unavailable.
+ * Return: 0 if the algorithm is available, or errno if unavailable.
  */
 int tst_try_alg(const char *algtype, const char *algname);
 
 /**
- * Check for the availability of an algorithm.
+ * tst_have_alg() - Check for the availability of an algorithm.
  *
- * @param algtype The type of algorithm, such as "hash" or "skcipher"
- * @param algname The name of the algorithm, such as "sha256" or "xts(aes)"
+ * @algtype: The type of algorithm, such as "hash" or "skcipher"
+ * @algname: The name of the algorithm, such as "sha256" or "xts(aes)"
  *
- * Return true if the algorithm is available, or false if unavailable
+ * Return: true if the algorithm is available, or false if unavailable
  * and call tst_res() with TCONF. If another error occurs, tst_brk() is called
  * with TBROK unless algorithm is disabled due FIPS mode (errno ELIBBAD).
  */
 bool tst_have_alg(const char *algtype, const char *algname);
 
 /**
- * Require the availability of an algorithm.
+ * tst_require_alg() - Require the availability of an algorithm.
  *
- * @param algtype The type of algorithm, such as "hash" or "skcipher"
- * @param algname The name of the algorithm, such as "sha256" or "xts(aes)"
+ * @algtype: The type of algorithm, such as "hash" or "skcipher"
+ * @algname: The name of the algorithm, such as "sha256" or "xts(aes)"
  *
  * If the algorithm is unavailable, tst_brk() is called with TCONF.
  * If another error occurs, tst_brk() is called with TBROK.
@@ -89,20 +90,20 @@ bool tst_have_alg(const char *algtype, const char *algname);
 void tst_require_alg(const char *algtype, const char *algname);
 
 /**
- * Assign a cryptographic key to an AF_ALG algorithm socket.
+ * tst_alg_setkey() - Assign a cryptographic key to an AF_ALG algorithm socket.
  *
- * @param algfd An AF_ALG algorithm socket
- * @param key Pointer to the key.  If NULL, a random key is generated.
- * @param keylen Length of the key in bytes
+ * @algfd: An AF_ALG algorithm socket
+ * @key: Pointer to the key.  If NULL, a random key is generated.
+ * @keylen: Length of the key in bytes
  *
  * On failure, tst_brk() is called with TBROK.
  */
 void tst_alg_setkey(int algfd, const uint8_t *key, unsigned int keylen);
 
 /**
- * Create an AF_ALG request socket for the given algorithm socket.
+ * tst_alg_accept() - Create an AF_ALG request socket for the given algorithm socket.
  *
- * @param algfd An AF_ALG algorithm socket
+ * @algfd: An AF_ALG algorithm socket
  *
  * This creates a request socket for the given algorithm socket, which must be
  * bound to an algorithm.  The same algorithm socket can have many request
@@ -112,35 +113,40 @@ void tst_alg_setkey(int algfd, const uint8_t *key, unsigned int keylen);
  *
  * On failure, tst_brk() is called with TBROK.
  *
- * @return a new AF_ALG request socket
+ * Return: a new AF_ALG request socket
  */
 int tst_alg_accept(int algfd);
 
 /**
- * Set up an AF_ALG algorithm socket for the given algorithm w/ given key.
+ * tst_alg_setup() - Set up an AF_ALG algorithm socket for the given algorithm w/ given key.
  *
- * @param algtype The type of algorithm, such as "hash" or "skcipher"
- * @param algname The name of the algorithm, such as "sha256" or "xts(aes)"
- * @param key The key to use (optional)
- * @param keylen The length of the key in bytes (optional)
+ * @algtype: The type of algorithm, such as "hash" or "skcipher"
+ * @algname: The name of the algorithm, such as "sha256" or "xts(aes)"
+ * @key: The key to use (optional)
+ * @keylen: The length of the key in bytes (optional)
  *
  * This is a helper function which creates an AF_ALG algorithm socket, binds it
  * to the specified algorithm, and optionally sets a key.  If keylen is 0 then
  * no key is set; otherwise if key is NULL a key of the given length is randomly
  * generated and set; otherwise the given key is set.
  *
- * @return the AF_ALG algorithm socket that was set up
+ * Return: the AF_ALG algorithm socket that was set up
  */
 int tst_alg_setup(const char *algtype, const char *algname,
 		  const uint8_t *key, unsigned int keylen);
 
 /**
- * Set up an AF_ALG request socket for the given algorithm w/ given key.
+ * tst_alg_setup_reqfd() - Set up an AF_ALG request socket for the given algorithm w/ given key.
+ *
+ * @algtype: The type of algorithm, such as "hash" or "skcipher"
+ * @algname: The name of the algorithm, such as "sha256" or "xts(aes)"
+ * @key: The key to use (optional)
+ * @keylen: The length of the key in bytes (optional)
  *
  * This is like tst_alg_setup(), except this returns a request fd instead of the
  * alg fd.  The alg fd is closed, so it doesn't need to be kept track of.
  *
- * @return the AF_ALG request socket that was set up
+ * Return: the AF_ALG request socket that was set up
  */
 int tst_alg_setup_reqfd(const char *algtype, const char *algname,
 			const uint8_t *key, unsigned int keylen);
@@ -166,11 +172,11 @@ struct tst_alg_sendmsg_params {
 };
 
 /**
- * Send some data to an AF_ALG request socket, including control data.
- * @param reqfd An AF_ALG request socket
- * @param data The data to send
- * @param datalen The length of data in bytes
- * @param params Specification of the control data to send
+ * tst_alg_sendmsg() - Send some data to an AF_ALG request socket, including control data.
+ * @reqfd: An AF_ALG request socket
+ * @data: The data to send
+ * @datalen: The length of data in bytes
+ * @params: Specification of the control data to send
  *
  * On failure, tst_brk() is called with TBROK.
  */
diff --git a/include/tst_clone.h b/include/tst_clone.h
index 56f23142d..a57d761ca 100644
--- a/include/tst_clone.h
+++ b/include/tst_clone.h
@@ -5,6 +5,8 @@
 #ifndef TST_CLONE_H__
 #define TST_CLONE_H__
 
+#include <sched.h>
+
 #ifdef TST_TEST_H__
 
 /* The parts of clone3's clone_args we support */
diff --git a/include/tst_crypto.h b/include/tst_crypto.h
index 421e6b947..4511adf22 100644
--- a/include/tst_crypto.h
+++ b/include/tst_crypto.h
@@ -3,9 +3,9 @@
  */
 
 /**
- * @file tst_crypto.h
+ * DOC: tst_crypto.h -- kernel's crypto layer helpers
  *
- * Library for interacting with kernel's crypto layer using the netlink
+ * Helpers for interacting with kernel's crypto layer using the netlink
  * interface.
  */
 
@@ -16,28 +16,28 @@
 #include "tst_netlink.h"
 
 /**
- * Add a crypto algorithm to a session.
+ * tst_crypto_add_alg() - Add a crypto algorithm to a session.
  *
- * @param ctx Initialized netlink context
- * @param alg The crypto algorithm or module to add.
+ * @ctx: Initialized netlink context
+ * @alg: The crypto algorithm or module to add.
  *
  * This requests a new crypto algorithm/engine/module to be initialized by the
  * kernel. It sends the request contained in alg and then waits for a
  * response. If sending the message or receiving the ack fails at the netlink
  * level then tst_brk() with TBROK will be called.
  *
- * @return On success it will return 0 otherwise it will return an inverted
- *         error code from the crypto layer.
+ * Return: On success it will return 0 otherwise it will return an inverted
+ * error code from the crypto layer.
  */
 int tst_crypto_add_alg(struct tst_netlink_context *ctx,
 		       const struct crypto_user_alg *alg);
 
 /**
- * Delete a crypto algorithm from a session.
+ * tst_crypto_del_alg() - Delete a crypto algorithm from a session.
  *
- * @param ctx Initialized netlink context
- * @param alg The crypto algorithm to delete.
- * @param retries Number of retries before giving up. Recommended value: 1000
+ * @ctx: Initialized netlink context
+ * @alg: The crypto algorithm to delete.
+ * @retries: Number of retries before giving up. Recommended value: 1000
  *
  * Request that the kernel remove an existing crypto algorithm. This behaves
  * in a similar way to tst_crypto_add_alg() except that it is the inverse
@@ -47,9 +47,9 @@ int tst_crypto_add_alg(struct tst_netlink_context *ctx,
  * EBUSY.
  *
  * Return: Either 0 or an inverted error code from the crypto layer. If called
- *         during cleanup it may return a positive ENODATA value from the LTP
- *         library, you don't need to log this error as it will already have
- *         been printed by tst_brk().
+ * during cleanup it may return a positive ENODATA value from the LTP
+ * library, you don't need to log this error as it will already have
+ * been printed by tst_brk().
  */
 int tst_crypto_del_alg(struct tst_netlink_context *ctx,
 	const struct crypto_user_alg *alg, unsigned int retries);
diff --git a/include/tst_device.h b/include/tst_device.h
index 1b4a55ae9..2597fb4e2 100644
--- a/include/tst_device.h
+++ b/include/tst_device.h
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2016-2019 Cyril Hrubis <chrubis@suse.cz>
+ * Copyright (c) Linux Test Project, 2019-2024
  */
 
 #ifndef TST_DEVICE_H__
@@ -103,11 +104,6 @@ int tst_dev_sync(int fd);
  */
 unsigned long tst_dev_bytes_written(const char *dev);
 
-/*
- * Wipe the contents of given directory but keep the directory itself
- */
-void tst_purge_dir(const char *path);
-
 /*
  * Find the file or path belongs to which block dev
  * @path       Path to find the backing dev
diff --git a/include/tst_kconfig.h b/include/tst_kconfig.h
index dcb370574..b0608498d 100644
--- a/include/tst_kconfig.h
+++ b/include/tst_kconfig.h
@@ -7,6 +7,7 @@
 #define TST_KCONFIG_H__
 
 #include <stdbool.h>
+#include <stddef.h>
 
 /**
  * Initialization helper macro for struct tst_kconfig_var. Requires <string.h>
@@ -29,7 +30,7 @@ struct tst_kconfig_var {
  * tst_kconfig_var structures.
  *
  * The path to the kernel config should be autodetected in most of the cases as
- * the code looks for know locations. It can be explicitely set/overrided with
+ * the code looks for know locations. It can be explicitly set/overridden with
  * the KCONFIG_PATH environment variable as well.
  *
  * The caller has to initialize the tst_kconfig_var structure. The id has to be
@@ -47,7 +48,7 @@ struct tst_kconfig_var {
  * In the case that match is set to 'v' the val pointer points to a newly
  * allocated string that holds the value.
  *
- * @param vars An array of caller initalized tst_kconfig_var structures.
+ * @param vars An array of caller initialized tst_kconfig_var structures.
  * @param vars_len Length of the vars array.
  */
 void tst_kconfig_read(struct tst_kconfig_var vars[], size_t vars_len);
@@ -87,7 +88,7 @@ int tst_kconfig_check(const char *const kconfigs[]);
  */
 struct tst_kcmdline_var {
 	const char *key;
-	char value[128];
+	char value[256];
 	bool found;
 };
 
@@ -98,4 +99,16 @@ struct tst_kcmdline_var {
  */
 void tst_kcmdline_parse(struct tst_kcmdline_var params[], size_t params_len);
 
+/*
+ * tst_has_slow_kconfig() - Check if any performance-degrading kernel configs are enabled.
+ *
+ * This function iterates over the list of slow kernel configuration options
+ * (`tst_slow_kconfigs`) and checks if any of them are enabled in the running kernel.
+ *
+ * Return:
+ * - 1 if at least one slow kernel config is enabled.
+ * - 0 if none of the slow kernel configs are enabled.
+ */
+int tst_has_slow_kconfig(void);
+
 #endif	/* TST_KCONFIG_H__ */
diff --git a/include/tst_kernel.h b/include/tst_kernel.h
index 5f49952b7..63ecb19a4 100644
--- a/include/tst_kernel.h
+++ b/include/tst_kernel.h
@@ -58,4 +58,13 @@ int tst_check_builtin_driver(const char *driver);
  */
 int tst_check_driver(const char *driver);
 
+/**
+ * tst_check_preempt_rt() - Check if the running kernel is RT.
+ *
+ * Check support for the kernel module (both built-in and loadable).
+ *
+ * Return: -1 if the kernel is RT, 0 otherwise.
+ */
+int tst_check_preempt_rt(void);
+
 #endif	/* TST_KERNEL_H__ */
diff --git a/include/tst_module.h b/include/tst_module.h
index 2654c5afb..8bbaf08f3 100644
--- a/include/tst_module.h
+++ b/include/tst_module.h
@@ -1,12 +1,15 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2013 Oracle and/or its affiliates. All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2016-2024
  * Alexey Kodanev <alexey.kodanev@oracle.com>
  */
 
 #ifndef TST_MODULE_H
 #define TST_MODULE_H
 
+#include <stdbool.h>
+
 void tst_module_exists_(void (cleanup_fn)(void), const char *mod_name,
 					 char **mod_path);
 
@@ -30,4 +33,18 @@ static inline void tst_module_unload(const char *mod_name)
 	tst_module_unload_(NULL, mod_name);
 }
 
+bool tst_module_signature_enforced_(void);
+
+static inline bool tst_module_signature_enforced(void)
+{
+	return tst_module_signature_enforced_();
+}
+
+void tst_requires_module_signature_disabled_(void);
+
+static inline void tst_requires_module_signature_disabled(void)
+{
+	tst_requires_module_signature_disabled_();
+}
+
 #endif /* TST_MODULE_H */
diff --git a/include/tst_numa.h b/include/tst_numa.h
index 3af311e5e..48c494308 100644
--- a/include/tst_numa.h
+++ b/include/tst_numa.h
@@ -48,7 +48,7 @@ const char *tst_mempolicy_mode_name(int mode);
  */
 void *tst_numa_map(const char *path, size_t size);
 
-/*
+/**
  * Writes to memory in order to get the pages faulted.
  *
  * @ptr Start of the mapping.
@@ -59,7 +59,7 @@ static inline void tst_numa_fault(void *ptr, size_t size)
 	memset(ptr, 'a', size);
 }
 
-/*
+/**
  * Frees the memory.
  *
  * @ptr Start of the mapping.
diff --git a/include/tst_private.h b/include/tst_private.h
index 6f4f39b15..4c6479f4b 100644
--- a/include/tst_private.h
+++ b/include/tst_private.h
@@ -40,11 +40,11 @@ char tst_kconfig_get(const char *confname);
 
 /*
  * If cmd argument is a single command, this function just checks command
- * whether exists. If not, case skips.
+ * whether exists. If not, case breaks if brk_nosupp is defined.
  * If cmd argument is a complex string ie 'mkfs.ext4 >= 1.43.0', this
  * function checks command version whether meets this requirement.
- * If not, case skips.
+ * If not, case breaks if brk_nosupp is defined.
  */
-void tst_check_cmd(const char *cmd);
+int tst_check_cmd(const char *cmd, const int brk_nosupp);
 
 #endif
diff --git a/include/tst_res_flags.h b/include/tst_res_flags.h
index 806940e0d..eb291b6bd 100644
--- a/include/tst_res_flags.h
+++ b/include/tst_res_flags.h
@@ -9,11 +9,26 @@
 /**
  * enum tst_res_flags - Test result reporting flags.
  *
- * @TPASS: Reports a single success.
- * @TFAIL: Reports a single failure.
- * @TBROK: Reports a single breakage.
+ * @TPASS: Reports a single success. Successes increment passed counter and
+ *         show up in the test results.
+ *
+ * @TFAIL: Reports a single failure. Failures increment failure counter and
+ *         show up in the test results. A failure occurs when test assertion
+ *         is broken.
+ *
+ * @TBROK: Reports a single breakage. Breakages increment breakage counter and
+ *         show up in the test results. Breakages are reported in cases where a
+ *         test couldn't be executed due to an unexpected failure during the
+ *         test setup. The TBROK status is mostly used with tst_brk() which
+ *         exit the test immediately. The difference between TBROK and TCONF is
+ *         that TCONF is used in cases where optional functionality is missing
+ *         while TBROK is used in cases where something that is supposed to
+ *         work is broken unexpectedly.
+ *
  * @TWARN: Reports a single warning. Warnings increment a warning counter and
- *         show up in test results.
+ *         show up in test results. Warnings are somewhere in the middle between
+ *         TBROK and TCONF. Warnings usually appear when something that is
+ *         supposed to be working is broken but the test can somehow continue.
  *
  * @TDEBUG: Prints additional debugging messages, it does not change the test result counters and
  *          the message is not displayed unless debugging is enabled with -D
diff --git a/include/tst_safe_macros.h b/include/tst_safe_macros.h
index 8de8ef106..6985aa4bd 100644
--- a/include/tst_safe_macros.h
+++ b/include/tst_safe_macros.h
@@ -14,6 +14,7 @@
 #include <sys/stat.h>
 #include <sys/vfs.h>
 #include <sys/sysinfo.h>
+#include <sys/uio.h>
 #include <fcntl.h>
 #include <libgen.h>
 #include <signal.h>
@@ -281,8 +282,8 @@ static inline void *safe_mmap(const char *file, const int lineno,
 	tst_prot_to_str(prot, prot_buf);
 
 	tst_res_(file, lineno, TDEBUG,
-		"mmap(%p, %zu, %s(%x), %d, %d, %ld)",
-		addr, length, prot_buf, prot, flags, fd, offset);
+		"mmap(%p, %zu, %s(%x), %d, %d, %lld)",
+		addr, length, prot_buf, prot, flags, fd, (long long int)offset);
 
 	rval = mmap(addr, length, prot, flags, fd, offset);
 	if (rval == MAP_FAILED) {
@@ -503,4 +504,32 @@ int safe_sscanf(const char *file, const int lineno, const char *restrict buffer,
 #define SAFE_SSCANF(buffer, format, ...) \
 	safe_sscanf(__FILE__, __LINE__, (buffer), (format),	##__VA_ARGS__)
 
+int safe_prctl(const char *file, const int lineno,
+	int option, unsigned long arg2, unsigned long arg3,
+	unsigned long arg4, unsigned long arg5);
+#define SAFE_PRCTL(option, arg2, arg3, arg4, arg5) \
+	safe_prctl(__FILE__, __LINE__, (option), (arg2), (arg3), (arg4), (arg5))
+
+int safe_symlinkat(const char *file, const int lineno,
+	const char *oldpath, const int newdirfd, const char *newpath);
+
+#define SAFE_SYMLINKAT(oldpath, newdirfd, newpath) \
+	safe_symlinkat(__FILE__, __LINE__, (oldpath), (newdirfd), (newpath))
+
+ssize_t safe_readv(const char *file, const int lineno, char len_strict,
+	int fildes, const struct iovec *iov, int iovcnt);
+#define SAFE_READV(len_strict, fildes, iov, iovcnt) \
+	safe_readv(__FILE__, __LINE__, (len_strict), (fildes), \
+		(iov), (iovcnt))
+
+ssize_t safe_writev(const char *file, const int lineno, char len_strict,
+	int fildes, const struct iovec *iov, int iovcnt);
+#define SAFE_WRITEV(len_strict, fildes, iov, iovcnt) \
+	safe_writev(__FILE__, __LINE__, (len_strict), (fildes), \
+		(iov), (iovcnt))
+
+char *safe_ptsname(const char *const file, const int lineno, int masterfd);
+#define SAFE_PTSNAME(masterfd) \
+	safe_ptsname(__FILE__, __LINE__, (masterfd))
+
 #endif /* TST_SAFE_MACROS_H__ */
diff --git a/include/tst_safe_prw.h b/include/tst_safe_prw.h
index 2e506cb41..349fb46b4 100644
--- a/include/tst_safe_prw.h
+++ b/include/tst_safe_prw.h
@@ -5,6 +5,8 @@
 #ifndef TST_SAFE_PRW_H__
 #define TST_SAFE_PRW_H__
 
+#include "lapi/uio.h"
+
 static inline ssize_t safe_pread(const char *file, const int lineno,
 		char len_strict, int fildes, void *buf, size_t nbyte,
 		off_t offset)
@@ -52,4 +54,60 @@ static inline ssize_t safe_pwrite(const char *file, const int lineno,
 	safe_pwrite(__FILE__, __LINE__, (len_strict), (fildes), \
 	            (buf), (nbyte), (offset))
 
+static inline ssize_t safe_preadv(const char *file, const int lineno,
+	char len_strict, int fildes, const struct iovec *iov, int iovcnt,
+	off_t offset)
+{
+	ssize_t rval, nbyte;
+	int i;
+
+	for (i = 0, nbyte = 0; i < iovcnt; i++)
+		nbyte += iov[i].iov_len;
+
+	rval = preadv(fildes, iov, iovcnt, offset);
+
+	if (rval == -1 || (len_strict && rval != nbyte)) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"preadv(%d,%p,%d,%lld) failed",
+			fildes, iov, iovcnt, (long long)offset);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid preadv(%d,%p,%d,%lld) return value %zd",
+			fildes, iov, iovcnt, (long long)offset, rval);
+	}
+
+	return rval;
+}
+#define SAFE_PREADV(len_strict, fildes, iov, iovcnt, offset) \
+	safe_preadv(__FILE__, __LINE__, (len_strict), (fildes), \
+		(iov), (iovcnt), (offset))
+
+static inline ssize_t safe_pwritev(const char *file, const int lineno,
+	char len_strict, int fildes, const struct iovec *iov, int iovcnt,
+	off_t offset)
+{
+	ssize_t rval, nbyte;
+	int i;
+
+	for (i = 0, nbyte = 0; i < iovcnt; i++)
+		nbyte += iov[i].iov_len;
+
+	rval = pwritev(fildes, iov, iovcnt, offset);
+
+	if (rval == -1 || (len_strict && rval != nbyte)) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"pwritev(%d,%p,%d,%lld) failed",
+			fildes, iov, iovcnt, (long long)offset);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid pwritev(%d,%p,%d,%lld) return value %zd",
+			fildes, iov, iovcnt, (long long)offset, rval);
+	}
+
+	return rval;
+}
+#define SAFE_PWRITEV(len_strict, fildes, iov, iovcnt, offset) \
+	safe_pwritev(__FILE__, __LINE__, (len_strict), (fildes), \
+		(iov), (iovcnt), (offset))
+
 #endif /* SAFE_PRW_H__ */
diff --git a/include/tst_taint.h b/include/tst_taint.h
index bd8076c1c..b2b201688 100644
--- a/include/tst_taint.h
+++ b/include/tst_taint.h
@@ -64,6 +64,7 @@
 #define TST_TAINT_K     (1 << 15) /* kernel has been live-patched */
 #define TST_TAINT_X     (1 << 16) /* auxiliary taint, for distro's use */
 #define TST_TAINT_T     (1 << 17) /* kernel was built with the struct randomization plugin */
+#define TST_TAINT_N     (1 << 18) /* an in-kernel test has been run */
 
 /*
  * Initialize and prepare support for checking tainted kernel. Called
diff --git a/include/tst_test.h b/include/tst_test.h
index 3846afdff..eb73cd593 100644
--- a/include/tst_test.h
+++ b/include/tst_test.h
@@ -46,6 +46,7 @@
 #include "tst_memutils.h"
 #include "tst_arch.h"
 #include "tst_fd.h"
+#include "tst_tmpdir.h"
 
 void tst_res_(const char *file, const int lineno, int ttype,
               const char *fmt, ...)
@@ -233,7 +234,7 @@ struct tst_tag {
 
 extern unsigned int tst_variant;
 
-#define TST_UNLIMITED_RUNTIME (-1)
+#define TST_UNLIMITED_TIMEOUT (-1)
 
 /**
  * struct tst_ulimit_val - An ulimit resource and value.
@@ -247,6 +248,45 @@ struct tst_ulimit_val {
 	rlim_t rlim_cur;
 };
 
+/**
+ * struct tst_fs - A file system type, mkfs and mount options
+ *
+ * @type: A filesystem type to use.
+ *
+ * @mkfs_opts: A NULL terminated array of options passed to mkfs in the case
+ *             of 'tst_test.format_device'. These options are passed to mkfs
+ *             before the device path.
+ *
+ * @mkfs_size_opt: An option passed to mkfs in the case of
+ *                 'tst_test.format_device'. The device size in blocks is
+ *                 passed to mkfs after the device path and can be used to
+ *                 limit the file system not to use the whole block device.
+ *
+ * @mkfs_ver: mkfs tool version. The string format supports relational
+ *            operators such as < > <= >= ==.
+ *
+ * @mnt_flags: MS_* flags passed to mount(2) when the test library mounts a
+ *             device in the case of 'tst_test.mount_device'.
+ *
+ * @mnt_data: The data passed to mount(2) when the test library mounts a device
+ *            in the case of 'tst_test.mount_device'.
+ *
+ * @min_kver: A minimum kernel version supporting the filesystem which has been
+ *            created with mkfs.
+ */
+struct tst_fs {
+	const char *type;
+
+	const char *const *mkfs_opts;
+	const char *mkfs_size_opt;
+	const char *mkfs_ver;
+
+	unsigned int mnt_flags;
+	const void *mnt_data;
+
+	const char *min_kver;
+};
+
 /**
  * struct tst_test - A test description.
  *
@@ -290,7 +330,7 @@ struct tst_ulimit_val {
  *                 file system at tst_test.mntpoint.
  *
  * @format_device: Does all tst_test.needs_device would do and also formats
- *                 the device with tst_test.dev_fs_type file system as well.
+ *                 the device with a file system as well.
  *
  * @mount_device: Does all tst_test.format_device would do and also mounts the
  *                device at tst_test.mntpoint.
@@ -300,6 +340,8 @@ struct tst_ulimit_val {
  * @child_needs_reinit: Has to be set if the test needs to call tst_reinit()
  *                      from a process started by exec().
  *
+ * @runs_script: Implies child_needs_reinit and forks_child at the moment.
+ *
  * @needs_devfs: If set the devfs is mounted at tst_test.mntpoint. This is
  *               needed for tests that need to create device files since tmpfs
  *               at /tmp is usually mounted with 'nodev' option.
@@ -377,36 +419,42 @@ struct tst_ulimit_val {
  *
  * @dev_min_size: A minimal device size in megabytes.
  *
- * @dev_fs_type: If set overrides the default file system type for the device and
- *               sets the tst_device.fs_type.
- *
- * @dev_fs_opts: A NULL terminated array of options passed to mkfs in the case
- *               of 'tst_test.format_device'. These options are passed to mkfs
- *               before the device path.
- *
- * @dev_extra_opts: A NULL terminated array of extra options passed to mkfs in
- *                  the case of 'tst_test.format_device'. Extra options are
- *                  passed to mkfs after the device path. Commonly the option
- *                  after mkfs is the number of blocks and can be used to limit
- *                  the file system not to use the whole block device.
+ * @filesystems: A NULL type terminated array of per file system type
+ *               parameters for mkfs and mount. If the first entry type is NULL
+ *               it describes a default parameters for all file system tests.
+ *               The rest of the entries the describes per file system type
+ *               parameters. If tst_test.all_filesystems is set, the test runs
+ *               for all filesystems and uses the array to lookup the mkfs
+ *               and mount options. If tst_test.all_filesystems is not set
+ *               the test iterates over file system types defined in the array.
+ *               If there is only a single entry in the array with a NULL type,
+ *               the test runs just once for the default file sytem i.e.
+ *               $TST_FS_TYPE.
  *
  * @mntpoint: A mount point where the test library mounts requested file system.
  *            The directory is created by the library, the test must not create
  *            it itself.
  *
- * @mnt_flags: MS_* flags passed to mount(2) when the test library mounts a
- *             device in the case of 'tst_test.mount_device'.
- *
- * @mnt_data: The data passed to mount(2) when the test library mounts a device
- *            in the case of 'tst_test.mount_device'.
- *
- * @max_runtime: Maximal test runtime in seconds. Any test that runs for more
- *               than a second or two should set this and also use
- *               tst_remaining_runtime() to exit when runtime was used up.
- *               Tests may finish sooner, for example if requested number of
- *               iterations was reached before the runtime runs out. If test
- *               runtime cannot be know in advance it should be set to
- *               TST_UNLIMITED_RUNTIME.
+ * @timeout: Maximum allowable time in seconds for the entire duration of a test.
+ *           By default, the timeout limits the total time for setup, single test
+ *           function invocation, and cleanup phases. However, if .runtime is
+ *           explicitly set and tst_remaining_runtime() is used in the test's
+ *           main loop, the timeout then applies only to the setup and cleanup
+ *           phases, as the runtime separately limits the main test execution.
+ *           This ensures the test does not hang indefinitely, in the rare case
+ *           that the test timeout cannot be accurately determined, it can be
+ *           set to a sufficiently large value or TST_UNLIMITED_TIMEOUT to remove
+ *           the limit.
+ *
+ * @runtime: Maximum runtime in seconds for the test's main execution loop.
+ *           This should be set for tests that are expected to run longer
+ *           than a few seconds and call tst_remaining_runtime() in their
+ *           main loop to exit gracefully when the runtime is exceeded.
+ *           Tests may finish sooner if their task completes (e.g., reaching
+ *           a requested number of iterations) before the runtime runs out.
+ *           The runtime is fixed and does not scale with timeout multipliers
+ *           (e.g., TIMEOUT_MUL), ensuring consistent test duration across
+ *           different environments (e.g., debug vs. stock kernels).
  *
  * @setup: Setup callback is called once at the start of the test in order to
  *         prepare the test environment.
@@ -428,6 +476,10 @@ struct tst_ulimit_val {
  *            can be set. May be executed several times if test was passed '-i'
  *            or '-d' command line parameters.
  *
+ * @scall: Internal only (timer measurement library).
+ *
+ * @sample: Internal only (timer measurement library).
+ *
  * @resource_files: A NULL terminated array of filenames that will be copied
  *                  to the test temporary directory from the LTP datafiles
  *                  directory.
@@ -493,6 +545,7 @@ struct tst_ulimit_val {
 	unsigned int mount_device:1;
 	unsigned int needs_rofs:1;
 	unsigned int child_needs_reinit:1;
+	unsigned int runs_script:1;
 	unsigned int needs_devfs:1;
 	unsigned int restore_wallclock:1;
 
@@ -501,6 +554,8 @@ struct tst_ulimit_val {
 	unsigned int skip_in_lockdown:1;
 	unsigned int skip_in_secureboot:1;
 	unsigned int skip_in_compat:1;
+
+
 	int needs_abi_bits;
 
 	unsigned int needs_hugetlbfs:1;
@@ -519,16 +574,12 @@ struct tst_ulimit_val {
 
 	unsigned int dev_min_size;
 
-	const char *dev_fs_type;
-
-	const char *const *dev_fs_opts;
-	const char *const *dev_extra_opts;
+	struct tst_fs *filesystems;
 
 	const char *mntpoint;
-	unsigned int mnt_flags;
-	void *mnt_data;
 
-	int max_runtime;
+	int timeout;
+	int runtime;
 
 	void (*setup)(void);
 	void (*cleanup)(void);
@@ -559,7 +610,7 @@ struct tst_ulimit_val {
 
 	const char *const *needs_cgroup_ctrls;
 
-	int needs_cgroup_nsdelegate:1;
+	unsigned int needs_cgroup_nsdelegate:1;
 };
 
 /**
@@ -593,6 +644,43 @@ void tst_run_tcases(int argc, char *argv[], struct tst_test *self)
  */
 void tst_reinit(void);
 
+/**
+ * tst_run_script() - Prepare the environment and execute a (shell) script.
+ *
+ * @script_name: A filename of the script.
+ * @params: A NULL terminated array of (shell) script parameters, pass NULL if
+ *          none are needed. This what is passed starting from argv[1].
+ *
+ * The (shell) script is executed with LTP_IPC_PATH in environment so that the
+ * binary helpers such as tst_res_ or tst_checkpoint work properly when executed
+ * from the script. This also means that the tst_test.runs_script flag needs to
+ * be set.
+ *
+ * A shell script has to source the tst_env.sh shell script at the start and
+ * after that it's free to use tst_res in the same way C code would use.
+ *
+ * Example shell script that reports success::
+ *
+ *   #!/bin/sh
+ *   . tst_env.sh
+ *
+ *   tst_res TPASS "Example test works"
+ *
+ * The call returns a pid in a case that you want to examine the return value
+ * of the script yourself. If you do not need to check the return value
+ * yourself you can use tst_reap_children() to wait for the completion. Or let
+ * the test library collect the child automatically, just be wary that the
+ * script and the test both runs concurently at the same time in this case.
+ *
+ * Return: A pid of the (shell) script process.
+ */
+int tst_run_script(const char *script_name, char *const params[]);
+
+/*
+ * Sets entire timeout in seconds.
+ */
+void tst_set_timeout(int timeout);
+
 unsigned int tst_multiply_timeout(unsigned int timeout);
 
 /*
@@ -607,18 +695,13 @@ unsigned int tst_remaining_runtime(void);
 /*
  * Sets maximal test runtime in seconds.
  */
-void tst_set_max_runtime(int max_runtime);
+void tst_set_runtime(int runtime);
 
 /*
  * Create and open a random file inside the given dir path.
  * It unlinks the file after opening and return file descriptor.
  */
-int tst_creat_unlinked(const char *path, int flags);
-
-/*
- * Returns path to the test temporary directory in a newly allocated buffer.
- */
-char *tst_get_tmpdir(void);
+int tst_creat_unlinked(const char *path, int flags, mode_t mode);
 
 /*
  * Returns path to the test temporary directory root (TMPDIR).
@@ -647,6 +730,8 @@ int main(int argc, char *argv[])
 /**
  * TST_TEST_TCONF() - Exit tests with a TCONF message.
  *
+ * @message: Error message (the reason to skip test).
+ *
  * This macro is used in test that couldn't be compiled either because current
  * CPU architecture is unsupported or because of missing development libraries.
  */
diff --git a/include/tst_test_macros.h b/include/tst_test_macros.h
index 22b39fb14..3d6245f60 100644
--- a/include/tst_test_macros.h
+++ b/include/tst_test_macros.h
@@ -178,6 +178,28 @@ extern void *TST_RET_PTR;
                                                                                \
 	} while (0)
 
+#define TST_EXP_PASS_SILENT_PTR_(SCALL, SSCALL, FAIL_PTR_VAL, ...)             \
+	do {                                                                   \
+		TESTPTR(SCALL);                                                \
+		                                                               \
+		TST_PASS = 0;                                                  \
+		                                                               \
+		if (TST_RET_PTR == FAIL_PTR_VAL) {                             \
+			TST_MSG_(TFAIL | TTERRNO, " failed",                   \
+			         SSCALL, ##__VA_ARGS__);                       \
+		        break;                                                 \
+		}                                                              \
+		                                                               \
+		if (TST_RET != 0) {                                            \
+			TST_MSGP_(TFAIL | TTERRNO, " invalid retval %ld",      \
+			          TST_RET, SSCALL, ##__VA_ARGS__);             \
+			break;                                                 \
+		}                                                              \
+                                                                               \
+		TST_PASS = 1;                                                  \
+                                                                               \
+	} while (0)
+
 #define TST_EXP_PASS_SILENT(SCALL, ...) TST_EXP_PASS_SILENT_(SCALL, #SCALL, ##__VA_ARGS__)
 
 #define TST_EXP_PASS(SCALL, ...)                                               \
@@ -188,6 +210,18 @@ extern void *TST_RET_PTR;
 			TST_MSG_(TPASS, " passed", #SCALL, ##__VA_ARGS__);     \
 	} while (0)                                                            \
 
+#define TST_EXP_PASS_PTR_(SCALL, SSCALL, FAIL_PTR_VAL, ...)                    \
+	do {                                                                   \
+		TST_EXP_PASS_SILENT_PTR_(SCALL, SSCALL,                        \
+					FAIL_PTR_VAL, ##__VA_ARGS__);          \
+		                                                               \
+		if (TST_PASS)                                                  \
+			TST_MSG_(TPASS, " passed", #SCALL, ##__VA_ARGS__);     \
+	} while (0)
+
+#define TST_EXP_PASS_PTR_VOID(SCALL, ...)                                      \
+               TST_EXP_PASS_PTR_(SCALL, #SCALL, (void *)-1, ##__VA_ARGS__);
+
 /*
  * Returns true if err is in the exp_err array.
  */
@@ -301,10 +335,8 @@ const char *tst_errno_names(char *buf, const int *exp_errs, int exp_errs_cnt);
 	} while (0)
 
 #define TST_EXP_FAIL_PTR_NULL_ARR(SCALL, EXP_ERRS, EXP_ERRS_CNT, ...)      \
-	do {                                                                   \
 		TST_EXP_FAIL_PTR_(SCALL, #SCALL, NULL,                         \
-			EXP_ERRS, EXP_ERRS_CNT, ##__VA_ARGS__);        \
-	} while (0)
+			EXP_ERRS, EXP_ERRS_CNT, ##__VA_ARGS__);
 
 #define TST_EXP_FAIL_PTR_VOID(SCALL, EXP_ERR, ...)                         \
 	do {                                                                   \
@@ -314,10 +346,8 @@ const char *tst_errno_names(char *buf, const int *exp_errs, int exp_errs_cnt);
 	} while (0)
 
 #define TST_EXP_FAIL_PTR_VOID_ARR(SCALL, EXP_ERRS, EXP_ERRS_CNT, ...)      \
-	do {                                                                   \
 		TST_EXP_FAIL_PTR_(SCALL, #SCALL, (void *)-1,                   \
-			EXP_ERRS, EXP_ERRS_CNT, ##__VA_ARGS__);        \
-	} while (0)
+			EXP_ERRS, EXP_ERRS_CNT, ##__VA_ARGS__);
 
 #define TST_EXP_FAIL2(SCALL, EXP_ERR, ...)                                     \
 	do {                                                                   \
@@ -340,32 +370,120 @@ const char *tst_errno_names(char *buf, const int *exp_errs, int exp_errs_cnt);
 			&tst_exp_err__, 1, ##__VA_ARGS__);                     \
 	} while (0)
 
-#define TST_EXP_EXPR(EXPR, FMT, ...)						\
-	tst_res_(__FILE__, __LINE__, (EXPR) ? TPASS : TFAIL, "Expect: " FMT, ##__VA_ARGS__);
-
-#define TST_EXP_EQ_(VAL_A, SVAL_A, VAL_B, SVAL_B, TYPE, PFS) do {\
-	TYPE tst_tmp_a__ = VAL_A; \
-	TYPE tst_tmp_b__ = VAL_B; \
-	if (tst_tmp_a__ == tst_tmp_b__) { \
-		tst_res_(__FILE__, __LINE__, TPASS, \
-			SVAL_A " == " SVAL_B " (" PFS ")", tst_tmp_a__); \
-	} else { \
-		tst_res_(__FILE__, __LINE__, TFAIL, \
-			SVAL_A " (" PFS ") != " SVAL_B " (" PFS ")", \
-			tst_tmp_a__, tst_tmp_b__); \
-	} \
+#define TST_EXP_EXPR(EXPR, ...)                                              \
+       tst_res_(__FILE__, __LINE__, (EXPR) ? TPASS : TFAIL, "Expect: "       \
+                TST_FMT_(TST_2_(dummy, ##__VA_ARGS__, #EXPR), __VA_ARGS__));
+
+#define TST_EXP_EQ_SILENT_(VAL_A, SVAL_A, VAL_B, SVAL_B, TYPE, PFS) do {       \
+	TYPE tst_tmp_a__ = VAL_A;                                              \
+	TYPE tst_tmp_b__ = VAL_B;                                              \
+                                                                               \
+	TST_PASS = 0;                                                          \
+                                                                               \
+	if (tst_tmp_a__ != tst_tmp_b__) {                                      \
+		tst_res_(__FILE__, __LINE__, TFAIL,                            \
+			SVAL_A " (" PFS ") != " SVAL_B " (" PFS ")",           \
+			tst_tmp_a__, tst_tmp_b__);                             \
+	} else {                                                               \
+		TST_PASS = 1;                                                  \
+	}                                                                      \
 } while (0)
 
-#define TST_EXP_EQ_LI(VAL_A, VAL_B) \
-		TST_EXP_EQ_(VAL_A, #VAL_A, VAL_B, #VAL_B, long long, "%lli")
+#define TST_EXP_EQ_LI(VAL_A, VAL_B) do {                                       \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, long long, "%lli");   \
+								               \
+	if (TST_PASS) {                                                        \
+		tst_res_(__FILE__, __LINE__, TPASS,                            \
+			#VAL_A " == " #VAL_B " (%lli)",                        \
+			(long long)VAL_A);                                     \
+	}                                                                      \
+} while (0)
 
-#define TST_EXP_EQ_LU(VAL_A, VAL_B) \
-		TST_EXP_EQ_(VAL_A, #VAL_A, VAL_B, #VAL_B, unsigned long long, "%llu")
+#define TST_EXP_EQ_LI_SILENT(VAL_A, VAL_B) \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, long long, "%lli")
+
+#define TST_EXP_EQ_LU(VAL_A, VAL_B) do {                                       \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, unsigned long long, "%llu"); \
+								               \
+	if (TST_PASS) {                                                        \
+		tst_res_(__FILE__, __LINE__, TPASS,                            \
+			#VAL_A " == " #VAL_B " (%llu)",                        \
+			(unsigned long long)VAL_A);                            \
+	}                                                                      \
+} while (0)
 
-#define TST_EXP_EQ_SZ(VAL_A, VAL_B) \
-		TST_EXP_EQ_(VAL_A, #VAL_A, VAL_B, #VAL_B, size_t, "%zu")
+#define TST_EXP_EQ_LU_SILENT(VAL_A, VAL_B) \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, unsigned long long, "%llu")
+
+#define TST_EXP_EQ_SZ(VAL_A, VAL_B) do {                                       \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, size_t, "%zu");       \
+								               \
+	if (TST_PASS) {                                                        \
+		tst_res_(__FILE__, __LINE__, TPASS,                            \
+			#VAL_A " == " #VAL_B " (%zu)",                         \
+			(size_t)VAL_A);                                        \
+	}                                                                      \
+} while (0)
 
-#define TST_EXP_EQ_SSZ(VAL_A, VAL_B) \
-		TST_EXP_EQ_(VAL_A, #VAL_A, VAL_B, #VAL_B, ssize_t, "%zi")
+#define TST_EXP_EQ_SZ_SILENT(VAL_A, VAL_B) \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, size_t, "%zu")
+
+#define TST_EXP_EQ_SSZ(VAL_A, VAL_B) do {                                      \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, size_t, "%zi");       \
+								               \
+	if (TST_PASS) {                                                        \
+		tst_res_(__FILE__, __LINE__, TPASS,                            \
+			#VAL_A " == " #VAL_B " (%zi)",                         \
+			(ssize_t)VAL_A);                                        \
+	}                                                                      \
+} while (0)
+
+#define TST_EXP_EQ_SSZ_SILENT(VAL_A, VAL_B) \
+	TST_EXP_EQ_SILENT_(VAL_A, #VAL_A, VAL_B, #VAL_B, ssize_t, "%zi")
+
+#define TST_EXP_EQ_STR(STR_A, STR_B) do {                                      \
+	TST_PASS = strcmp(STR_A, STR_B) == 0;                                  \
+                                                                               \
+	if (TST_PASS) {                                                        \
+		tst_res_(__FILE__, __LINE__, TPASS,                            \
+			"%s == %s (%s)",                                       \
+			#STR_A, #STR_B, STR_B);                                \
+	} else {                                                               \
+		tst_res_(__FILE__, __LINE__, TFAIL,                            \
+			"%s (%s) != %s (%s)",                                  \
+			#STR_A, STR_A, #STR_B, STR_B);                         \
+	}                                                                      \
+} while (0)
+
+/**
+ * TST_EXP_EQ_STRN() - Compare two strings, providing length as well.
+ *
+ * @STR_A: string to compare.
+ * @STR_B: string to compare.
+ * @LEN: length of the string.
+ */
+#define TST_EXP_EQ_STRN(STR_A, STR_B, LEN) do {                                \
+	char str_a_cpy[LEN+1];                                                 \
+									       \
+	strncpy(str_a_cpy, STR_A, LEN);                                        \
+	str_a_cpy[LEN] = 0;                                                    \
+									       \
+	TST_PASS = strncmp(STR_A, STR_B, LEN) == 0;                            \
+									       \
+	if (TST_PASS) {                                                        \
+		tst_res_(__FILE__, __LINE__, TPASS,                            \
+			"%s == %s (%s)",                                       \
+			#STR_A, #STR_B, str_a_cpy);                            \
+	} else {                                                               \
+		char str_b_cpy[LEN+1];                                         \
+									       \
+		strncpy(str_b_cpy, STR_B, LEN);                                \
+		str_b_cpy[LEN] = 0;                                            \
+									       \
+		tst_res_(__FILE__, __LINE__, TFAIL,                            \
+			"%s (%s) != %s (%s)",                                  \
+			#STR_A, str_a_cpy, #STR_B, str_b_cpy);                 \
+	}                                                                      \
+} while (0)
 
 #endif	/* TST_TEST_MACROS_H__ */
diff --git a/include/tst_tmpdir.h b/include/tst_tmpdir.h
new file mode 100644
index 000000000..85d708233
--- /dev/null
+++ b/include/tst_tmpdir.h
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2017-2024 Cyril Hrubis <chrubis@suse.cz>
+ * Copyright (c) 2020 Martin Doucha <mdoucha@suse.cz>
+ */
+
+#ifndef TST_TMPDIR_H__
+#define TST_TMPDIR_H__
+
+/**
+ * tst_purge_dir - Wipe the content of given directory.
+ *
+ * Wipe the content of given directory but keep the directory itself.
+ *
+ * @path: Path of the directory to be wiped.
+ */
+void tst_purge_dir(const char *path);
+
+/**
+ * tst_tmpdir_path - Returns a pointer to a tmpdir path.
+ *
+ * The returned path is allocated and initialized the first time this function is
+ * called, each subsequent call will return the same pointer.
+ *
+ * return: A newly allocated path. The memory is freed automatically at the end
+ * of the test. If allocation fails the function calls tst_brk() and
+ * exits the test.
+ */
+char *tst_tmpdir_path(void);
+
+/**
+ * tst_tmpdir_genpath - Construct an absolute path pointing to a file inside tmpdir.
+ *
+ * Constructs a path inside tmpdir i.e. adds a prefix pointing to the current
+ * test tmpdir to the string build by the printf-like format.
+ *
+ * @fmt: A printf-like format string.
+ * @...: A printf-like parameter list.
+ *
+ * return: A newly allocated path. The memory is freed automatically at the end
+ * of the test. If allocation fails the function calls tst_brk() and exits the
+ * test.
+ */
+char *tst_tmpdir_genpath(const char *fmt, ...)
+	__attribute__((format(printf, 1, 2)));
+
+/*
+ * Make sure nobody uses old API functions in new code.
+ */
+#ifndef LTPLIB
+# define tst_get_tmpdir #error Use tst_tmpdir_path()!
+#endif
+
+#endif /* TST_TMPDIR_H__ */
diff --git a/include/ujson.h b/include/ujson.h
new file mode 100644
index 000000000..8faeb18f0
--- /dev/null
+++ b/include/ujson.h
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+#ifndef UJSON_H
+#define UJSON_H
+
+#include <ujson_common.h>
+#include <ujson_reader.h>
+#include <ujson_writer.h>
+
+#endif /* UJSON_H */
diff --git a/include/ujson_common.h b/include/ujson_common.h
new file mode 100644
index 000000000..ed31c090d
--- /dev/null
+++ b/include/ujson_common.h
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+/**
+ * @file ujson_common.h
+ * @brief Common JSON reader/writer definitions.
+ */
+
+#ifndef UJSON_COMMON_H
+#define UJSON_COMMON_H
+
+/** @brief Maximal error message length. */
+#define UJSON_ERR_MAX 128
+/** @brief Maximal id string lenght including terminating null element. */
+#define UJSON_ID_MAX 64
+/** @brief Maximal recursion depth allowed. */
+#define UJSON_RECURSION_MAX 128
+
+#define UJSON_ERR_PRINT ujson_err_handler
+#define UJSON_ERR_PRINT_PRIV stderr
+
+/**
+ * @brief A JSON data type.
+ */
+enum ujson_type {
+	/** @brief No type. Returned when parser finishes. */
+	UJSON_VOID = 0,
+	/** @brief An integer. */
+	UJSON_INT,
+	/** @brief A floating point. */
+	UJSON_FLOAT,
+	/** @brief A boolean. */
+	UJSON_BOOL,
+	/** @brief NULL */
+	UJSON_NULL,
+	/** @brief A string. */
+	UJSON_STR,
+	/** @brief A JSON object. */
+	UJSON_OBJ,
+	/** @brief A JSON array. */
+	UJSON_ARR,
+};
+
+/**
+ * @brief Returns type name.
+ *
+ * @param type A json type.
+ * @return A type name.
+ */
+const char *ujson_type_name(enum ujson_type type);
+
+/**
+ * @brief Default error print handler.
+ *
+ * @param print_priv A json buffer print_priv pointer.
+ * @param line A line of text to be printed.
+ */
+void ujson_err_handler(void *print_priv, const char *line);
+
+typedef struct ujson_reader ujson_reader;
+typedef struct ujson_writer ujson_writer;
+typedef struct ujson_val ujson_val;
+
+/** @brief An array size macro. */
+#define UJSON_ARRAY_SIZE(array) (sizeof(array) / sizeof(*array))
+
+#endif /* UJSON_COMMON_H */
diff --git a/include/ujson_reader.h b/include/ujson_reader.h
new file mode 100644
index 000000000..273fe624a
--- /dev/null
+++ b/include/ujson_reader.h
@@ -0,0 +1,543 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+/**
+ * @file ujson_reader.h
+ * @brief A recursive descend JSON parser.
+ *
+ * All the function that parse JSON return zero on success and non-zero on a
+ * failure. Once an error has happened all subsequent attempts to parse more
+ * return with non-zero exit status immediatelly. This is designed so that we
+ * can parse several values without checking each return value and only check
+ * if error has happened at the end of the sequence.
+ */
+
+#ifndef UJSON_READER_H
+#define UJSON_READER_H
+
+#include <stdio.h>
+#include <ujson_common.h>
+
+/**
+ * @brief An ujson_reader initializer with default values.
+ *
+ * @param buf A pointer to a buffer with JSON data.
+ * @param buf_len A JSON data buffer lenght.
+ * @param rflags enum ujson_reader_flags.
+ *
+ * @return An ujson_reader initialized with default values.
+ */
+#define UJSON_READER_INIT(buf, buf_len, rflags) { \
+	.max_depth = UJSON_RECURSION_MAX, \
+	.err_print = UJSON_ERR_PRINT, \
+	.err_print_priv = UJSON_ERR_PRINT_PRIV, \
+	.json = buf, \
+	.len = buf_len, \
+	.flags = rflags \
+}
+
+/** @brief Reader flags. */
+enum ujson_reader_flags {
+	/** @brief If set warnings are treated as errors. */
+	UJSON_READER_STRICT = 0x01,
+};
+
+/**
+ * @brief A JSON parser internal state.
+ */
+struct ujson_reader {
+	/** Pointer to a null terminated JSON string */
+	const char *json;
+	/** A length of the JSON string */
+	size_t len;
+	/** A current offset into the JSON string */
+	size_t off;
+	/** An offset to the start of the last array or object */
+	size_t sub_off;
+	/** Recursion depth increased when array/object is entered decreased on leave */
+	unsigned int depth;
+	/** Maximal recursion depth */
+	unsigned int max_depth;
+
+	/** Reader flags. */
+	enum ujson_reader_flags flags;
+
+	/** Handler to print errors and warnings */
+	void (*err_print)(void *err_print_priv, const char *line);
+	void *err_print_priv;
+
+	char err[UJSON_ERR_MAX];
+	char buf[];
+};
+
+/**
+ * @brief An ujson_val initializer.
+ *
+ * @param sbuf A pointer to a buffer used for string values.
+ * @param sbuf_size A length of the buffer used for string values.
+ *
+ * @return An ujson_val initialized with default values.
+ */
+#define UJSON_VAL_INIT(sbuf, sbuf_size) { \
+	.buf = sbuf, \
+	.buf_size = sbuf_size, \
+}
+
+/**
+ * @brief A parsed JSON key value pair.
+ */
+struct ujson_val {
+	/**
+	 * @brief A value type
+	 *
+	 * UJSON_VALUE_VOID means that no value was parsed.
+	 */
+	enum ujson_type type;
+
+	/** An user supplied buffer and size to store a string values to. */
+	char *buf;
+	size_t buf_size;
+
+	/**
+	 * @brief An index to attribute list.
+	 *
+	 * This is set by the ujson_obj_first_filter() and
+	 * ujson_obj_next_filter() functions.
+	 */
+	size_t idx;
+
+	/** An union to store the parsed value into. */
+	union {
+		/** @brief A boolean value. */
+		int val_bool;
+		/** @brief An integer value. */
+		long long val_int;
+		/** @brief A string value. */
+		const char *val_str;
+	};
+
+	/**
+	 * @brief A floating point value.
+	 *
+	 * Since integer values are subset of floating point values val_float
+	 * is always set when val_int was set.
+	 */
+	double val_float;
+
+	/** @brief An ID for object values */
+	char id[UJSON_ID_MAX];
+
+	char buf__[];
+};
+
+/**
+ * @brief Allocates a JSON value.
+ *
+ * @param buf_size A maximal buffer size for a string value, pass 0 for default.
+ * @return A newly allocated JSON value.
+ */
+ujson_val *ujson_val_alloc(size_t buf_size);
+
+/**
+ * @brief Frees a JSON value.
+ *
+ * @param self A JSON value previously allocated by ujson_val_alloc().
+ */
+void ujson_val_free(ujson_val *self);
+
+/**
+ * @brief Checks is result has valid type.
+ *
+ * @param res An ujson value.
+ * @return Zero if result is not valid, non-zero otherwise.
+ */
+static inline int ujson_val_valid(struct ujson_val *res)
+{
+	return !!res->type;
+}
+
+/**
+ * @brief Fills the reader error.
+ *
+ * Once buffer error is set all parsing functions return immediatelly with type
+ * set to UJSON_VOID.
+ *
+ * @param self An ujson_reader
+ * @param fmt A printf like format string
+ * @param ... A printf like parameters
+ */
+void ujson_err(ujson_reader *self, const char *fmt, ...)
+               __attribute__((format(printf, 2, 3)));
+
+/**
+ * @brief Prints error stored in the buffer.
+ *
+ * The error takes into consideration the current offset in the buffer and
+ * prints a few preceding lines along with the exact position of the error.
+ *
+ * The error is passed to the err_print() handler.
+ *
+ * @param self A ujson_reader
+ */
+void ujson_err_print(ujson_reader *self);
+
+/**
+ * @brief Prints a warning.
+ *
+ * Uses the print handler in the buffer to print a warning along with a few
+ * lines of context from the JSON at the current position.
+ *
+ * @param self A ujson_reader
+ * @param fmt A printf-like error string.
+ * @param ... A printf-like parameters.
+ */
+void ujson_warn(ujson_reader *self, const char *fmt, ...)
+               __attribute__((format(printf, 2, 3)));
+
+/**
+ * @brief Returns true if error was encountered.
+ *
+ * @param self A ujson_reader
+ * @return True if error was encountered false otherwise.
+ */
+static inline int ujson_reader_err(ujson_reader *self)
+{
+	return !!self->err[0];
+}
+
+/**
+ * @brief Returns the type of next element in buffer.
+ *
+ * @param self An ujson_reader
+ * @return A type of next element in the buffer.
+ */
+enum ujson_type ujson_next_type(ujson_reader *self);
+
+/**
+ * @brief Returns if first element in JSON is object or array.
+ *
+ * @param self A ujson_reader
+ * @return On success returns UJSON_OBJ or UJSON_ARR. On failure UJSON_VOID.
+ */
+enum ujson_type ujson_reader_start(ujson_reader *self);
+
+/**
+ * @brief Starts parsing of a JSON object.
+ *
+ * @param self An ujson_reader
+ * @param res An ujson_val to store the parsed value to.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_obj_first(ujson_reader *self, struct ujson_val *res);
+
+/**
+ * @brief Parses next value from a JSON object.
+ *
+ * If the res->type is UJSON_OBJ or UJSON_ARR it has to be parsed or skipped
+ * before next call to this function.
+ *
+ * @param self An ujson_reader.
+ * @param res A ujson_val to store the parsed value to.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_obj_next(ujson_reader *self, struct ujson_val *res);
+
+/**
+ * @brief A loop over a JSON object.
+ *
+ * @code
+ * UJSON_OBJ_FOREACH(reader, val) {
+ *	printf("Got value id '%s' type '%s'", val->id, ujson_type_name(val->type));
+ *	...
+ * }
+ * @endcode
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the next parsed value to.
+ */
+#define UJSON_OBJ_FOREACH(self, res) \
+	for (ujson_obj_first(self, res); ujson_val_valid(res); ujson_obj_next(self, res))
+
+/**
+ * @brief Utility function for log(n) lookup in a sorted array.
+ *
+ * @param list Analphabetically sorted array.
+ * @param list_len Array length.
+ *
+ * @return An array index or (size_t)-1 if key wasn't found.
+ */
+size_t ujson_lookup(const void *arr, size_t memb_size, size_t list_len,
+                    const char *key);
+
+/**
+ * @brief A JSON object attribute description i.e. key and type.
+ */
+typedef struct ujson_obj_attr {
+	/** @brief A JSON object key name. */
+	const char *key;
+	/**
+	 * @brief A JSON object value type.
+	 *
+	 * Note that because integer numbers are subset of floating point
+         * numbers if requested type was UJSON_FLOAT it will match if parsed
+         * type was UJSON_INT and the val_float will be set in addition to
+         * val_int.
+         */
+	enum ujson_type type;
+} ujson_obj_attr;
+
+/** @brief A JSON object description */
+typedef struct ujson_obj {
+	/**
+	 * @brief A list of attributes.
+	 *
+	 * Attributes we are looking for, the parser sets the val->idx for these.
+	 */
+	const ujson_obj_attr *attrs;
+	/** @brief A size of attrs array. */
+	size_t attr_cnt;
+} ujson_obj;
+
+static inline size_t ujson_obj_lookup(const ujson_obj *obj, const char *key)
+{
+	return ujson_lookup(obj->attrs, sizeof(*obj->attrs), obj->attr_cnt, key);
+}
+
+/** @brief An ujson_obj_attr initializer. */
+#define UJSON_OBJ_ATTR(keyv, typev) \
+	{.key = keyv, .type = typev}
+
+/** @brief An ujson_obj_attr intializer with an array index. */
+#define UJSON_OBJ_ATTR_IDX(key_idx, keyv, typev) \
+	[key_idx] = {.key = keyv, .type = typev}
+
+/**
+ * @brief Starts parsing of a JSON object with attribute lists.
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the parsed value to.
+ * @param obj An ujson_obj object description.
+ * @param ign A list of keys to ignore.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_obj_first_filter(ujson_reader *self, struct ujson_val *res,
+                           const struct ujson_obj *obj, const struct ujson_obj *ign);
+
+/**
+ * @brief An empty object attribute list.
+ *
+ * To be passed to UJSON_OBJ_FOREACH_FITLER() as ignore list.
+ */
+extern const struct ujson_obj *ujson_empty_obj;
+
+/**
+ * @brief Parses next value from a JSON object with attribute lists.
+ *
+ * If the res->type is UJSON_OBJ or UJSON_ARR it has to be parsed or skipped
+ * before next call to this function.
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the parsed value to.
+ * @param obj An ujson_obj object description.
+ * @param ign A list of keys to ignore. If set to NULL all unknown keys are
+ *            ignored, if set to ujson_empty_obj all unknown keys produce warnings.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_obj_next_filter(ujson_reader *self, struct ujson_val *res,
+                          const struct ujson_obj *obj, const struct ujson_obj *ign);
+
+/**
+ * @brief A loop over a JSON object with a pre-defined list of expected attributes.
+ *
+ * @code
+ * static struct ujson_obj_attr attrs[] = {
+ *	UJSON_OBJ_ATTR("bool", UJSON_BOOL),
+ *	UJSON_OBJ_ATTR("number", UJSON_INT),
+ * };
+ *
+ * static struct ujson_obj obj = {
+ *	.attrs = filter_attrs,
+ *	.attr_cnt = UJSON_ARRAY_SIZE(filter_attrs)
+ * };
+ *
+ * UJSON_OBJ_FOREACH_FILTER(reader, val, &obj, NULL) {
+ *	printf("Got value id '%s' type '%s'",
+ *	       attrs[val->idx].id, ujson_type_name(val->type));
+ *	...
+ * }
+ * @endcode
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the next parsed value to.
+ * @param obj An ujson_obj with a description of attributes to parse.
+ * @param ign An ujson_obj with a description of attributes to ignore.
+ */
+#define UJSON_OBJ_FOREACH_FILTER(self, res, obj, ign) \
+	for (ujson_obj_first_filter(self, res, obj, ign); \
+	     ujson_val_valid(res); \
+	     ujson_obj_next_filter(self, res, obj, ign))
+
+/**
+ * @brief Skips parsing of a JSON object.
+ *
+ * @param self An ujson_reader.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_obj_skip(ujson_reader *self);
+
+/**
+ * @brief Starts parsing of a JSON array.
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the parsed value to.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_arr_first(ujson_reader *self, struct ujson_val *res);
+
+/**
+ * @brief Parses next value from a JSON array.
+ *
+ * If the res->type is UJSON_OBJ or UJSON_ARR it has to be parsed or skipped
+ * before next call to this function.
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the parsed value to.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_arr_next(ujson_reader *self, struct ujson_val *res);
+
+/**
+ * @brief A loop over a JSON array.
+ *
+ * @code
+ * UJSON_ARR_FOREACH(reader, val) {
+ *	printf("Got value type '%s'", ujson_type_name(val->type));
+ *	...
+ * }
+ * @endcode
+ *
+ * @param self An ujson_reader.
+ * @param res An ujson_val to store the next parsed value to.
+ */
+#define UJSON_ARR_FOREACH(self, res) \
+	for (ujson_arr_first(self, res); ujson_val_valid(res); ujson_arr_next(self, res))
+
+/**
+ * @brief Skips parsing of a JSON array.
+ *
+ * @param self A ujson_reader.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_arr_skip(ujson_reader *self);
+
+/**
+ * @brief A JSON reader state.
+ */
+typedef struct ujson_reader_state {
+	size_t off;
+	unsigned int depth;
+} ujson_reader_state;
+
+/**
+ * @brief Returns a parser state at the start of current object/array.
+ *
+ * This function could be used for the parser to return to the start of the
+ * currently parsed object or array.
+ *
+ * @param self A ujson_reader
+ * @return A state that points to a start of the last object or array.
+ */
+static inline ujson_reader_state ujson_reader_state_save(ujson_reader *self)
+{
+	struct ujson_reader_state ret = {
+		.off = self->sub_off,
+		.depth = self->depth,
+	};
+
+	return ret;
+}
+
+/**
+ * @brief Returns the parser to a saved state.
+ *
+ * This function could be used for the parser to return to the start of
+ * object or array saved by t the ujson_reader_state_get() function.
+ *
+ * @param self A ujson_reader
+ * @param state An parser state as returned by the ujson_reader_state_get().
+ */
+static inline void ujson_reader_state_load(ujson_reader *self, ujson_reader_state state)
+{
+	if (ujson_reader_err(self))
+		return;
+
+	self->off = state.off;
+	self->sub_off = state.off;
+	self->depth = state.depth;
+}
+
+/**
+ * @brief Resets the parser to a start.
+ *
+ * @param self A ujson_reader
+ */
+static inline void ujson_reader_reset(ujson_reader *self)
+{
+	self->off = 0;
+	self->sub_off = 0;
+	self->depth = 0;
+	self->err[0] = 0;
+}
+
+/**
+ * @brief Loads a file into an ujson_reader buffer.
+ *
+ * The reader has to be later freed by ujson_reader_free().
+ *
+ * @param path A path to a file.
+ * @return A ujson_reader or NULL in a case of a failure.
+ */
+ujson_reader *ujson_reader_load(const char *path);
+
+/**
+ * @brief Frees an ujson_reader buffer.
+ *
+ * @param self A ujson_reader allocated by ujson_reader_load() function.
+ */
+void ujson_reader_free(ujson_reader *self);
+
+/**
+ * @brief Prints errors and warnings at the end of parsing.
+ *
+ * Checks if self->err is set and prints the error with ujson_reader_err()
+ *
+ * Checks if there is any text left after the parser has finished with
+ * ujson_reader_consumed() and prints a warning if there were any non-whitespace
+ * characters left.
+ *
+ * @param self A ujson_reader
+ */
+void ujson_reader_finish(ujson_reader *self);
+
+/**
+ * @brief Returns non-zero if whole buffer has been consumed.
+ *
+ * @param self A ujson_reader.
+ * @return Non-zero if whole buffer was consumed.
+ */
+static inline int ujson_reader_consumed(ujson_reader *self)
+{
+	return self->off >= self->len;
+}
+
+#endif /* UJSON_H */
diff --git a/include/ujson_utf.h b/include/ujson_utf.h
new file mode 100644
index 000000000..f939fbe8c
--- /dev/null
+++ b/include/ujson_utf.h
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2022-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+/**
+ * @file ujson_utf.h
+ * @brief Unicode helper macros and functions.
+ */
+
+#ifndef UJSON_UTF_H
+#define UJSON_UTF_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+/** Returns true if unicode byte is ASCII */
+#define UJSON_UTF8_IS_ASCII(ch) (!((ch) & 0x80))
+/** Returns true if we have first unicode byte of single byte sequence */
+#define UJSON_UTF8_IS_NBYTE(ch) (((ch) & 0xc0) == 0x80)
+/** Returns true if we have first unicode byte of two byte sequence */
+#define UJSON_UTF8_IS_2BYTE(ch) (((ch) & 0xe0) == 0xc0)
+/** Returns true if we have first unicode byte of three byte sequence */
+#define UJSON_UTF8_IS_3BYTE(ch) (((ch) & 0xf0) == 0xe0)
+/** Returns true if we have first unicode byte of four byte sequence */
+#define UJSON_UTF8_IS_4BYTE(ch) (((ch) & 0xf8) == 0xf0)
+
+#define UJSON_UTF8_NBYTE_MASK 0x3f
+
+/**
+ * @brief Parses next unicode character in UTF-8 string.
+ * @param str A pointer to the C string.
+ * @return A unicode character or 0 on error or end of the string.
+ */
+static inline uint32_t ujson_utf8_next(const char **str)
+{
+	uint32_t s0 = *str[0];
+
+	(*str)++;
+
+	if (UJSON_UTF8_IS_ASCII(s0))
+		return s0;
+
+	uint32_t s1 = *str[0];
+
+	if (!UJSON_UTF8_IS_NBYTE(s1))
+		return 0;
+
+	s1 &= UJSON_UTF8_NBYTE_MASK;
+
+	(*str)++;
+
+	if (UJSON_UTF8_IS_2BYTE(s0))
+		return (s0 & 0x1f)<<6 | s1;
+
+	uint32_t s2 = *str[0];
+
+	if (!UJSON_UTF8_IS_NBYTE(s2))
+		return 0;
+
+	s2 &= UJSON_UTF8_NBYTE_MASK;
+
+	(*str)++;
+
+	if (UJSON_UTF8_IS_3BYTE(s0))
+		return (s0 & 0x0f)<<12 | s1<<6 | s2;
+
+	(*str)++;
+
+	uint32_t s3 = *str[0];
+
+	if (!UJSON_UTF8_IS_NBYTE(s2))
+		return 0;
+
+	s3 &= UJSON_UTF8_NBYTE_MASK;
+
+	if (UJSON_UTF8_IS_4BYTE(s0))
+		return (s0 & 0x07)<<18 | s1<<12 | s2<<6 | s3;
+
+	return 0;
+}
+
+/**
+ * @brief Returns number of bytes next character is occupying in an UTF-8 string.
+ *
+ * @param str A pointer to a string.
+ * @param off An offset into the string, must point to a valid multibyte boundary.
+ * @return Number of bytes next character occupies, zero on string end and -1 on failure.
+ */
+int8_t ujson_utf8_next_chsz(const char *str, size_t off);
+
+/**
+ * @brief Returns number of bytes previous character is occupying in an UTF-8 string.
+ *
+ * @param str A pointer to a string.
+ * @param off An offset into the string, must point to a valid multibyte boundary.
+ * @return Number of bytes previous character occupies, and -1 on failure.
+ */
+int8_t ujson_utf8_prev_chsz(const char *str, size_t off);
+
+/**
+ * @brief Returns a number of characters in UTF-8 string.
+ *
+ * Returns number of characters in an UTF-8 string, which may be less or equal
+ * to what strlen() reports.
+ *
+ * @param str An UTF-8 string.
+ * @return Number of characters in the string.
+ */
+size_t ujson_utf8_strlen(const char *str);
+
+/**
+ * @brief Returns a number of bytes needed to store unicode character into UTF-8.
+ *
+ * @param unicode A unicode character.
+ * @return Number of utf8 bytes required to store a unicode character.
+ */
+static inline unsigned int ujson_utf8_bytes(uint32_t unicode)
+{
+	if (unicode < 0x0080)
+		return 1;
+
+	if (unicode < 0x0800)
+		return 2;
+
+	if (unicode < 0x10000)
+		return 3;
+
+	return 4;
+}
+
+/**
+ * @brief Writes an unicode character into a UTF-8 buffer.
+ *
+ * The buffer _must_ be large enough!
+ *
+ * @param unicode A unicode character.
+ * @param buf A byte buffer.
+ * @return A number of bytes written.
+ */
+static inline int ujson_to_utf8(uint32_t unicode, char *buf)
+{
+	if (unicode < 0x0080) {
+		buf[0] = unicode & 0x007f;
+		return 1;
+	}
+
+	if (unicode < 0x0800) {
+		buf[0] = 0xc0 | (0x1f & (unicode>>6));
+		buf[1] = 0x80 | (0x3f & unicode);
+		return 2;
+	}
+
+	if (unicode < 0x10000) {
+		buf[0] = 0xe0 | (0x0f & (unicode>>12));
+		buf[1] = 0x80 | (0x3f & (unicode>>6));
+		buf[2] = 0x80 | (0x3f & unicode);
+		return 3;
+	}
+
+	buf[0] = 0xf0 | (0x07 & (unicode>>18));
+	buf[1] = 0x80 | (0x3f & (unicode>>12));
+	buf[2] = 0x80 | (0x3f & (unicode>>6));
+	buf[3] = 0x80 | (0x3f & unicode);
+	return 4;
+}
+
+#endif /* UJSON_UTF_H */
diff --git a/include/ujson_writer.h b/include/ujson_writer.h
new file mode 100644
index 000000000..dfcc95053
--- /dev/null
+++ b/include/ujson_writer.h
@@ -0,0 +1,224 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+/**
+ * @file ujson_writer.h
+ * @brief A JSON writer.
+ *
+ * All the function that add values return zero on success and non-zero on a
+ * failure. Once an error has happened all subsequent attempts to add more
+ * values return with non-zero exit status immediatelly. This is designed
+ * so that we can add several values without checking each return value
+ * and only check if error has happened at the end of the sequence.
+ *
+ * Failures may occur:
+ * - if we call the functions out of order, e.g. attempt to finish array when
+ *   we are not writing out an array.
+ * - if we run out of recursion stack
+ * - may be propagated from the writer function, e.g. allocation failure, no
+ *   space on disk, etc.
+ */
+
+#ifndef UJSON_WRITER_H
+#define UJSON_WRITER_H
+
+#include <ujson_common.h>
+
+/** @brief A JSON writer */
+struct ujson_writer {
+	unsigned int depth;
+	char depth_type[UJSON_RECURSION_MAX/8];
+	char depth_first[UJSON_RECURSION_MAX/8];
+
+	/** Handler to print errors and warnings */
+	void (*err_print)(void *err_print_priv, const char *line);
+	void *err_print_priv;
+	char err[UJSON_ERR_MAX];
+
+	/** Handler to produce JSON output */
+	int (*out)(struct ujson_writer *self, const char *buf, size_t buf_size);
+	void *out_priv;
+};
+
+/**
+ * @brief An ujson_writer initializer with default values.
+ *
+ * @param vout A pointer to function to write out the data.
+ * @param vout_priv An user pointer passed to the out function.
+ *
+ * @return An ujson_writer initialized with default values.
+ */
+#define UJSON_WRITER_INIT(vout, vout_priv) { \
+	.err_print = UJSON_ERR_PRINT, \
+	.err_print_priv = UJSON_ERR_PRINT_PRIV, \
+	.out = vout, \
+	.out_priv = vout_priv \
+}
+
+/**
+ * @brief Allocates a JSON file writer.
+ *
+ * The call may fail either when file cannot be opened for writing or if
+ * allocation has failed. In all cases errno should be set correctly.
+ *
+ * @param path A path to the file, file is opened for writing and created if it
+ *             does not exist.
+ *
+ * @return A ujson_writer pointer or NULL in a case of failure.
+ */
+ujson_writer *ujson_writer_file_open(const char *path);
+
+/**
+ * @brief Closes and frees a JSON file writer.
+ *
+ * @param self A ujson_writer file writer.
+ *
+ * @return Zero on success, non-zero on a failure and errno is set.
+ */
+int ujson_writer_file_close(ujson_writer *self);
+
+/**
+ * @brief Returns true if writer error happened.
+ *
+ * @param self A JSON writer.
+ *
+ * @return True if error has happened.
+ */
+static inline int ujson_writer_err(ujson_writer *self)
+{
+	return !!self->err[0];
+}
+
+/**
+ * @brief Starts a JSON object.
+ *
+ * For a top level object the id must be NULL, every other object has to have
+ * non-NULL id. The call will also fail if maximal recursion depth
+ * UJSON_RECURSION_MAX has been reached.
+ *
+ * @param self A JSON writer.
+ * @param id An object name.
+ *
+ * @return Zero on a success, non-zero otherwise.
+ */
+int ujson_obj_start(ujson_writer *self, const char *id);
+
+/**
+ * @brief Finishes a JSON object.
+ *
+ * The call will fail if we are currenlty not writing out an object.
+ *
+ * @param self A JSON writer.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_obj_finish(ujson_writer *self);
+
+/**
+ * @brief Starts a JSON array.
+ *
+ * For a top level array the id must be NULL, every other array has to have
+ * non-NULL id. The call will also fail if maximal recursion depth
+ * UJSON_RECURSION_MAX has been reached.
+ *
+ * @param self A JSON writer.
+ * @param id An array name.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_arr_start(ujson_writer *self, const char *id);
+
+/**
+ * @brief Finishes a JSON array.
+ *
+ * The call will fail if we are currenlty not writing out an array.
+ *
+ * @param self A JSON writer.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_arr_finish(ujson_writer *self);
+
+/**
+ * @brief Adds a null value.
+ *
+ * The id must be NULL inside of an array, and must be non-NULL inside of an
+ * object.
+ *
+ * @param self A JSON writer.
+ * @param id A null value name.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_null_add(ujson_writer *self, const char *id);
+
+/**
+ * @brief Adds an integer value.
+ *
+ * The id must be NULL inside of an array, and must be non-NULL inside of an
+ * object.
+ *
+ * @param self A JSON writer.
+ * @param id An integer value name.
+ * @param val An integer value.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_int_add(ujson_writer *self, const char *id, long val);
+
+/**
+ * @brief Adds a bool value.
+ *
+ * The id must be NULL inside of an array, and must be non-NULL inside of an
+ * object.
+ *
+ * @param self A JSON writer.
+ * @param id An boolean value name.
+ * @param val A boolean value.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_bool_add(ujson_writer *self, const char *id, int val);
+
+/**
+ * @brief Adds a float value.
+ *
+ * The id must be NULL inside of an array, and must be non-NULL inside of an
+ * object.
+ *
+ * @param self A JSON writer.
+ * @param id A floating point value name.
+ * @param val A floating point value.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_float_add(ujson_writer *self, const char *id, double val);
+
+/**
+ * @brief Adds a string value.
+ *
+ * The id must be NULL inside of an array, and must be non-NULL inside of an
+ * object.
+ *
+ * @param self A JSON writer.
+ * @param id A string value name.
+ * @param str An UTF8 string value.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int ujson_str_add(ujson_writer *self, const char *id, const char *str);
+
+/**
+ * @brief Finalizes json writer.
+ *
+ * Finalizes the json writer, throws possible errors through the error printing
+ * function.
+ *
+ * @param self A JSON writer.
+ * @return Overall error value.
+ */
+int ujson_writer_finish(ujson_writer *self);
+
+#endif /* UJSON_WRITER_H */
diff --git a/lib/newlib_tests/runtest.sh b/lib/newlib_tests/runtest.sh
index 8f2a497b1..f2133d365 100755
--- a/lib/newlib_tests/runtest.sh
+++ b/lib/newlib_tests/runtest.sh
@@ -1,14 +1,46 @@
 #!/bin/sh
-# Copyright (c) 2021 Petr Vorel <pvorel@suse.cz>
-
-LTP_C_API_TESTS="${LTP_C_API_TESTS:-test05 test07 test09 test15 test_runtime01
-tst_needs_cmds01 tst_needs_cmds02 tst_needs_cmds03 tst_needs_cmds06
-tst_needs_cmds07 tst_bool_expr test_exec test_timer tst_res_hexd tst_strstatus
-tst_fuzzy_sync03 test_zero_hugepage.sh test_kconfig.sh test_kconfig03
-test_children_cleanup.sh}"
-
-LTP_SHELL_API_TESTS="${LTP_SHELL_API_TESTS:-shell/tst_check_driver.sh
-shell/tst_check_kconfig0[1-5].sh shell/tst_errexit.sh shell/net/*.sh}"
+# Copyright (c) 2021-2024 Petr Vorel <pvorel@suse.cz>
+
+# TODO "unknown failure, exit code": test_assert test08 tst_cgroup01 tst_cgroup02 tst_res_flags variant
+# TODO TFAIL: test_macros0[1-6] test23 test26
+# TODO TBROK: test_exec_child test_kconfig01 test_kconfig02 tst_needs_cmds04 tst_needs_cmds05 test_runtime02 test01 test02 test03 test04 test06 test11 test13 test22 test25 tst_safe_fileops
+# TODO TWARN: test_guarded_buf test14 tst_capability01 tst_print_result
+LTP_C_API_TESTS="${LTP_C_API_TESTS:-
+test_children_cleanup.sh
+test_kconfig.sh
+test_kconfig03
+test_parse_filesize
+test_runtime01
+test_timer
+test_zero_hugepage.sh
+test0[579]
+test1[59]
+test2[04]
+tst_bool_expr
+tst_capability02
+tst_device
+tst_expiration_timer
+tst_fuzzy_sync0[1-3]
+tst_needs_cmds0[1-36-8]
+tst_res_hexd
+tst_safe_sscanf
+tst_strstatus}"
+
+# TODO "unknown failure, exit code": shell/tst_res_flags.sh shell/timeout03.sh
+# TODO TBROK: shell/test_timeout.sh (sometimes) shell/timeout04.sh
+LTP_SHELL_API_TESTS="${LTP_SHELL_API_TESTS:-
+shell/timeout0[1-2].sh
+shell/tst_all_filesystems.sh
+shell/tst_all_filesystems_skip.sh
+shell/tst_device_size.sh
+shell/tst_errexit.sh
+shell/tst_format_device.sh
+shell/tst_check_driver.sh
+shell/tst_check_kconfig0[1-5].sh
+shell/tst_mount_device.sh
+shell/tst_mount_device_tmpfs.sh
+shell/tst_skip_filesystems.sh
+shell/net/*.sh}"
 
 cd $(dirname $0)
 PATH="$PWD/../../testcases/lib/:$PATH"
diff --git a/lib/newlib_tests/shell/tst_device_size.sh b/lib/newlib_tests/shell/tst_device_size.sh
new file mode 100755
index 000000000..751437972
--- /dev/null
+++ b/lib/newlib_tests/shell/tst_device_size.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024 Petr Vorel <pvorel@suse.cz>
+
+TST_NEEDS_DEVICE=1
+TST_DEVICE_SIZE=10
+TST_TESTFUNC=test
+
+test()
+{
+	tst_res TPASS "TST_DEVICE_SIZE=$TST_DEVICE_SIZE"
+	# overlayfs adds 1 MB
+	EXPECT_PASS "du -ms . | grep -qw -e $TST_DEVICE_SIZE -e $(($TST_DEVICE_SIZE + 1))"
+}
+
+. tst_test.sh
+tst_run
diff --git a/lib/newlib_tests/test_runtime01.c b/lib/newlib_tests/test_runtime01.c
index 5e027546d..169033850 100644
--- a/lib/newlib_tests/test_runtime01.c
+++ b/lib/newlib_tests/test_runtime01.c
@@ -25,6 +25,6 @@ static void run(void)
 
 static struct tst_test test = {
 	.test_all = run,
-	.max_runtime = 4,
+	.runtime = 4,
 	.test_variants = 2,
 };
diff --git a/lib/newlib_tests/test_runtime02.c b/lib/newlib_tests/test_runtime02.c
index 6d89cb531..dd8eaa4d3 100644
--- a/lib/newlib_tests/test_runtime02.c
+++ b/lib/newlib_tests/test_runtime02.c
@@ -24,5 +24,5 @@ static void run(void)
 
 static struct tst_test test = {
 	.test_all = run,
-	.max_runtime = 5,
+	.runtime = 5,
 };
diff --git a/lib/newlib_tests/tst_device.c b/lib/newlib_tests/tst_device.c
index 53099f9bc..a450b284d 100644
--- a/lib/newlib_tests/tst_device.c
+++ b/lib/newlib_tests/tst_device.c
@@ -28,11 +28,8 @@ static int set_block_size(int fd)
 static void setup(void)
 {
 	int fd;
-	int ret;
 
-	ret = asprintf(&mntpoint, "%s/mnt", tst_get_tmpdir());
-	if (ret < 0)
-		tst_brk(TBROK, "asprintf failure");
+	mntpoint = tst_tmpdir_genpath("mnt");
 
 	fd = SAFE_OPEN(tst_device->dev, O_RDONLY);
 
diff --git a/lib/newlib_tests/tst_fuzzy_sync01.c b/lib/newlib_tests/tst_fuzzy_sync01.c
index d0748958c..2d440df5b 100644
--- a/lib/newlib_tests/tst_fuzzy_sync01.c
+++ b/lib/newlib_tests/tst_fuzzy_sync01.c
@@ -2,7 +2,7 @@
 /*
  * Copyright (c) 2021 Richard Palethorpe <rpalethorpe@suse.com>
  */
-/*\
+/*
  * [Description]
  *
  * This verifies Fuzzy Sync's basic ability to reproduce a particular
@@ -10,7 +10,7 @@
  *
  * We make the simplifying assumptions that:
  * - Each thread contains a single contiguous critical section.
- * - The threads only interact through a single variable.
+ * - The threads only interact through a single variable(H: Hit).
  * - The various timings are constant except for variations introduced
  *   by the environment.
  *
@@ -50,9 +50,9 @@
  * range is required.
  *
  * When entering their critical sections, both threads increment the
- * 'c' counter variable atomically. They both also increment it when
- * leaving their critical sections. We record the value of 'c' when A
- * increments it. From the recorded values of 'c' we can deduce if the
+ * 'H' counter variable atomically. They both also increment it when
+ * leaving their critical sections. We record the value of 'H' when A
+ * increments it. From the recorded values of 'H' we can deduce if the
  * critical sections overlap and their ordering.
  *
  * 	Start (cs)	| End (ct)	| Ordering
@@ -62,7 +62,7 @@
  *
  * Any other combination of 'cs' and 'ct' means the critical sections
  * overlapped.
-\*/
+ */
 
 #include "tst_test.h"
 #include "tst_fuzzy_sync.h"
@@ -90,7 +90,7 @@ struct race {
 	const struct window b;
 };
 
-static int c;
+static int H;
 static struct tst_fzsync_pair pair;
 
 static const struct race races[] = {
@@ -162,15 +162,15 @@ static void *worker(void *v)
 	const struct window b = races[i].b;
 
 	while (tst_fzsync_run_b(&pair)) {
-		if (tst_atomic_load(&c))
+		if (tst_atomic_load(&H))
 			tst_brk(TBROK, "Counter should now be zero");
 
 		tst_fzsync_start_race_b(&pair);
 		delay(b.critical_s);
 
-		tst_atomic_add_return(1, &c);
+		tst_atomic_add_return(1, &H);
 		delay(b.critical_t);
-		tst_atomic_add_return(1, &c);
+		tst_atomic_add_return(1, &H);
 
 		delay(b.return_t);
 		tst_fzsync_end_race_b(&pair);
@@ -192,9 +192,9 @@ static void run(unsigned int i)
 		tst_fzsync_start_race_a(&pair);
 		delay(a.critical_s);
 
-		cs = tst_atomic_add_return(1, &c);
+		cs = tst_atomic_add_return(1, &H);
 		delay(a.critical_t);
-		ct = tst_atomic_add_return(1, &c);
+		ct = tst_atomic_add_return(1, &H);
 
 		delay(a.return_t);
 		tst_fzsync_end_race_a(&pair);
@@ -206,16 +206,37 @@ static void run(unsigned int i)
 		else
 			critical++;
 
-		r = tst_atomic_add_return(-4, &c);
+		r = tst_atomic_add_return(-4, &H);
 		if (r)
 			tst_brk(TBROK, "cs = %d, ct = %d, r = %d", cs, ct, r);
 
 		if (critical > 100) {
 			tst_fzsync_pair_cleanup(&pair);
+			tst_atomic_store(0, &pair.exit);
 			break;
 		}
 	}
 
+	/*
+	 * If `pair->exit` is true, the test may fail to meet expected
+	 * results due to resource constraints in shared CI environments
+	 * (e.g., GitHub Actions). Limited control over CPU allocation
+	 * can cause delays or interruptions in CPU time slices due to
+	 * contention with other jobs.
+	 *
+	 * Binding the test to a single CPU core (e.g., via `taskset -c 0`)
+	 * can worsen this by increasing contention, leading to performance
+	 * degradation and premature loop termination.
+	 *
+	 * To ensure valid and reliable results in scenarios (e.g., HW, VM, CI),
+	 * it is best to ignore test result when loop termination occurs,
+	 * avoiding unnecessary false positive.
+	 */
+	if (pair.exit) {
+		tst_res(TCONF, "Test may not be able to generate a valid result");
+		return;
+	}
+
 	tst_res(critical > 50 ? TPASS : TFAIL,
 		"acs:%-2d act:%-2d art:%-2d | =:%-4d -:%-4d +:%-4d",
 		a.critical_s, a.critical_t, a.return_t,
@@ -227,5 +248,5 @@ static struct tst_test test = {
 	.test = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 150,
+	.runtime = 150,
 };
diff --git a/lib/newlib_tests/tst_fuzzy_sync02.c b/lib/newlib_tests/tst_fuzzy_sync02.c
index afe4973b5..c81ebc7ea 100644
--- a/lib/newlib_tests/tst_fuzzy_sync02.c
+++ b/lib/newlib_tests/tst_fuzzy_sync02.c
@@ -2,7 +2,7 @@
 /*
  * Copyright (c) 2021 Richard Palethorpe <rpalethorpe@suse.com>
  */
-/*\
+/*
  * [Description]
  *
  * This verifies Fuzzy Sync's ability to reproduce a particular
@@ -11,7 +11,7 @@
  * We make the simplifying assumptions that:
  * - There is one data race we want to hit and one to avoid.
  * - Each thread contains two contiguous critical sections. One for each race.
- * - The threads only interact through two variables, one for each race.
+ * - The threads only interact through two variables(H: Hit, D: Avoid), one for each race.
  * - If we hit the race we want to avoid then it causes thread A to exit early.
  *
  * We don't consider more complicated dynamic interactions between the
@@ -22,7 +22,7 @@
  * threshold of complexity, increasing the complexity of the race is
  * no different from adding random noise.
  *
- * Emperically this appears to be true. So far we have seen in
+ * Empirically this appears to be true. So far we have seen in
  * reproducers that there are no more than two significant data
  * races. One we wish to reproduce and one we wish to avoid. It is
  * possible that the code contains multiple data races, but that they
@@ -35,7 +35,7 @@
  * Here we only test a bias to delay B. A delay of A would be
  * identical except that the necessary delay bias would be negative.
  *
-\*/
+ */
 
 #include "tst_test.h"
 #include "tst_fuzzy_sync.h"
@@ -63,14 +63,35 @@ struct race {
 	const struct window b;
 };
 
-static int c, d;
+static int H, D;
 static struct tst_fzsync_pair pair;
 
+/**
+ * Race 1:
+ *  Thread A:   |---(1)--|[1]|---(1)---|
+ *  Thread B:   |---(1)--|[1]|---(1)---|
+ *  ad (A):     |---(0)|[1]|(0)---|
+ *  bd (B):     |---(0)|[1]|(0)---|
+ *
+ * Race 2:
+ *  Thread A:   |------------------(30)------------------|[1]|---(1)---|
+ *  Thread B:   |---(1)--|[1]|---(1)---|
+ *  ad (A):     |---(0)|[1]|--(0)---|
+ *  bd (B):     |---(0)|[20]|--(0)---|
+ *
+ * Race 3:
+ *  Thread A:   |--------------------(40)--------------------|[1]|---(0)---|
+ *  Thread B:   |---(1)--|[1]|------------------(20)------------------|
+ *  ad (A):     |---(1)--|[10]|--(0)---|
+ *  bd (B):     |---(1)--|[10]|--(0)---|
+ */
 static const struct race races[] = {
 	{ .a =  { 1, 1, 1 }, .b =  { 1, 1, 1 },
 	  .ad = { 0, 1, 0 }, .bd = { 0, 1, 0 } },
+
 	{ .a =  { 30, 1, 1 }, .b =  { 1, 1,  1 },
 	  .ad = { 0,  1, 0 }, .bd = { 0, 20, 0 } },
+
 	{ .a =  { 40, 1,  0 }, .b =  { 1, 1,  20 },
 	  .ad = { 1,  10, 0 }, .bd = { 1, 10, 0 } },
 };
@@ -87,6 +108,20 @@ static void setup(void)
 	tst_fzsync_pair_init(&pair);
 }
 
+/**
+ * to_abs() - Convert relative time intervals to absolute time points
+ * @w: The input window structure containing relative time intervals
+ *
+ * This function converts relative time intervals (represented in the
+ * struct window) into absolute time points, where:
+ *
+ * - The start of the critical section is `critical_s`.
+ * - The end of the critical section is calculated as `critical_s + critical_t`.
+ * - The end of execution is calculated as `critical_s + critical_t + return_t`.
+ *
+ * Return:
+ * A new window structure (`wc`) with absolute time points.
+ */
 static struct window to_abs(const struct window w)
 {
 	const struct window wc = {
@@ -109,9 +144,9 @@ static void *worker(void *v)
 		tst_fzsync_start_race_b(&pair);
 		for (now = 0; now <= fin; now++) {
 			if (now == b.critical_s || now == b.critical_t)
-				tst_atomic_add_return(1, &c);
+				tst_atomic_add_return(1, &H);
 			if (now == bd.critical_s || now == bd.critical_t)
-				tst_atomic_add_return(1, &d);
+				tst_atomic_add_return(1, &D);
 
 			sched_yield();
 		}
@@ -132,19 +167,19 @@ static void run(unsigned int i)
 	SAFE_PTHREAD_CREATE(&pair.thread_b, 0, worker, &i);
 
 	while (tst_fzsync_run_a(&pair)) {
-		c = 0;
-		d = 0;
+		H = 0;
+		D = 0;
 		fin = a.return_t;
 
 		tst_fzsync_start_race_a(&pair);
 		for (now = 0; now <= fin; now++) {
 			if (now >= ad.critical_s &&
-			    now <= ad.critical_t && tst_atomic_load(&d) > 0)
+			    now <= ad.critical_t && tst_atomic_load(&D) > 0)
 				fin = ad.return_t;
 
 			if (now >= a.critical_s &&
-			    now <= a.critical_t && tst_atomic_load(&c) == 1) {
-				tst_atomic_add_return(1, &c);
+			    now <= a.critical_t && tst_atomic_load(&H) == 1) {
+				tst_atomic_add_return(1, &H);
 				critical++;
 			}
 
@@ -157,10 +192,31 @@ static void run(unsigned int i)
 
 		if (critical > 100) {
 			tst_fzsync_pair_cleanup(&pair);
+			tst_atomic_store(0, &pair.exit);
 			break;
 		}
 	}
 
+	/*
+	 * If `pair->exit` is true, the test may fail to meet expected
+	 * results due to resource constraints in shared CI environments
+	 * (e.g., GitHub Actions). Limited control over CPU allocation
+	 * can cause delays or interruptions in CPU time slices due to
+	 * contention with other jobs.
+	 *
+	 * Binding the test to a single CPU core (e.g., via `taskset -c 0`)
+	 * can worsen this by increasing contention, leading to performance
+	 * degradation and premature loop termination.
+	 *
+	 * To ensure valid and reliable results in scenarios (e.g., HW, VM, CI),
+	 * it is best to ignore test result when loop termination occurs,
+	 * avoiding unnecessary false positive.
+	 */
+	if (pair.exit) {
+		tst_res(TCONF, "Test may not be able to generate a valid result");
+		return;
+	}
+
 	tst_res(critical > 50 ? TPASS : TFAIL, "%d| =:%-4d", i, critical);
 }
 
@@ -169,5 +225,5 @@ static struct tst_test test = {
 	.test = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 150,
+	.runtime = 150,
 };
diff --git a/lib/newlib_tests/tst_fuzzy_sync03.c b/lib/newlib_tests/tst_fuzzy_sync03.c
index 47ce7675a..7468e79ea 100644
--- a/lib/newlib_tests/tst_fuzzy_sync03.c
+++ b/lib/newlib_tests/tst_fuzzy_sync03.c
@@ -99,5 +99,5 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = run,
-	.max_runtime = 150,
+	.runtime = 150,
 };
diff --git a/lib/safe_file_ops.c b/lib/safe_file_ops.c
index 63ae2dbbe..8314c4b1b 100644
--- a/lib/safe_file_ops.c
+++ b/lib/safe_file_ops.c
@@ -30,6 +30,7 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <utime.h>
+#include <errno.h>
 
 #include "test.h"
 #include "safe_file_ops_fn.h"
@@ -182,6 +183,9 @@ int file_lines_scanf(const char *file, const int lineno,
 
 	fp = fopen(path, "r");
 	if (fp == NULL) {
+		if (strict == 0 && errno == ENOENT)
+			return 1;
+
 		tst_brkm_(file, lineno, TBROK | TERRNO, cleanup_fn,
 			"Failed to open FILE '%s' for reading", path);
 		return 1;
diff --git a/lib/safe_macros.c b/lib/safe_macros.c
index 109268587..6946cc5bc 100644
--- a/lib/safe_macros.c
+++ b/lib/safe_macros.c
@@ -293,7 +293,7 @@ ssize_t safe_read(const char *file, const int lineno, void (*cleanup_fn) (void),
 
 	rval = read(fildes, buf, nbyte);
 
-	if (rval == -1 || (len_strict && (size_t)rval != nbyte)) {
+	if (rval == -1) {
 		tst_brkm_(file, lineno, TBROK | TERRNO, cleanup_fn,
 			"read(%d,%p,%zu) failed, returned %zd", fildes, buf,
 			nbyte, rval);
@@ -301,6 +301,10 @@ ssize_t safe_read(const char *file, const int lineno, void (*cleanup_fn) (void),
 		tst_brkm_(file, lineno, TBROK | TERRNO, cleanup_fn,
 			"Invalid read(%d,%p,%zu) return value %zd", fildes,
 			buf, nbyte, rval);
+	} else if (len_strict && (size_t)rval != nbyte) {
+		tst_brkm_(file, lineno, TBROK, cleanup_fn,
+			  "Short read(%d,%p,%zu) returned only %zd",
+			  fildes, buf, nbyte, rval);
 	}
 
 	return rval;
@@ -547,6 +551,14 @@ ssize_t safe_write(const char *file, const int lineno, void (cleanup_fn) (void),
 			tst_brkm_(file, lineno, TBROK | TERRNO,
 				cleanup_fn, "write(%d,%p,%zu) failed",
 				fildes, buf, nbyte);
+			return rval;
+		}
+
+		if (rval < 0) {
+			tst_brkm_(file, lineno, TBROK, cleanup_fn,
+			          "invalid write() return value %zi",
+				  rval);
+			return rval;
 		}
 
 		if (len_strict == SAFE_WRITE_ANY)
@@ -554,7 +566,7 @@ ssize_t safe_write(const char *file, const int lineno, void (cleanup_fn) (void),
 
 		if (len_strict == SAFE_WRITE_ALL) {
 			if ((size_t)rval != nbyte)
-				tst_brkm_(file, lineno, TBROK | TERRNO,
+				tst_brkm_(file, lineno, TBROK,
 					cleanup_fn, "short write(%d,%p,%zu) "
 					"return value %zd",
 					fildes, buf, nbyte, rval);
diff --git a/lib/tests/tst_strsig.c b/lib/tests/tst_strsig.c
index 9a5ca80aa..ed5be3f00 100644
--- a/lib/tests/tst_strsig.c
+++ b/lib/tests/tst_strsig.c
@@ -29,6 +29,7 @@ int TST_TOTAL = 1;
 
 int main(void)
 {
+	fprintf(stderr, "0 = %s\n", tst_strsig(0));
 	fprintf(stderr, "SIGKILL = %s\n", tst_strsig(SIGKILL));
 	fprintf(stderr, "SIGALRM = %s\n", tst_strsig(SIGALRM));
 	return 0;
diff --git a/lib/tst_af_alg.c b/lib/tst_af_alg.c
index f5437c5c5..a14f9865c 100644
--- a/lib/tst_af_alg.c
+++ b/lib/tst_af_alg.c
@@ -103,6 +103,7 @@ bool tst_have_alg(const char *algtype, const char *algname)
 	case 0:
 		return true;
 	case ENOENT:
+	case EINVAL:
 		tst_res(TCONF, "kernel doesn't have %s algorithm '%s'",
 			algtype, algname);
 		return false;
diff --git a/lib/tst_cgroup.c b/lib/tst_cgroup.c
index 6055015eb..aa13ac8ec 100644
--- a/lib/tst_cgroup.c
+++ b/lib/tst_cgroup.c
@@ -44,7 +44,7 @@ struct cgroup_dir {
 	 */
 	int dir_fd;
 
-	int we_created_it:1;
+	unsigned int we_created_it:1;
 };
 
 /* The root of a CGroup hierarchy/tree */
@@ -71,11 +71,11 @@ struct cgroup_root {
 	/* CGroup for current test. Which may have children. */
 	struct cgroup_dir test_dir;
 
-	int nsdelegate:1;
+	unsigned int nsdelegate:1;
 
-	int we_mounted_it:1;
+	unsigned int we_mounted_it:1;
 	/* cpuset is in compatability mode */
-	int no_cpuset_prefix:1;
+	unsigned int no_cpuset_prefix:1;
 };
 
 /* Controller sub-systems */
@@ -138,7 +138,7 @@ struct cgroup_ctrl {
 	/* Runtime; hierarchy the controller is attached to */
 	struct cgroup_root *ctrl_root;
 	/* Runtime; whether we required the controller */
-	int we_require_it:1;
+	unsigned int we_require_it:1;
 };
 
 struct tst_cg_group {
diff --git a/lib/tst_cmd.c b/lib/tst_cmd.c
index b3f8a95ab..82d60497a 100644
--- a/lib/tst_cmd.c
+++ b/lib/tst_cmd.c
@@ -34,16 +34,6 @@
 #define OPEN_MODE	(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
 #define OPEN_FLAGS	(O_WRONLY | O_APPEND | O_CREAT)
 
-enum cmd_op {
-	OP_GE, /* >= */
-	OP_GT, /* >  */
-	OP_LE, /* <= */
-	OP_LT, /* <  */
-	OP_EQ, /* == */
-	OP_NE, /* != */
-};
-
-
 int tst_cmd_fds_(void (cleanup_fn)(void),
 		const char *const argv[],
 		int stdout_fd,
@@ -210,7 +200,7 @@ static int mkfs_ext4_version_parser(void)
 	return major * 10000 +  minor * 100 + patch;
 }
 
-static int mkfs_ext4_version_table_get(char *version)
+static int mkfs_generic_version_table_get(char *version)
 {
 	int major, minor, patch;
 	int len;
@@ -228,23 +218,44 @@ static int mkfs_ext4_version_table_get(char *version)
 	return major * 10000 + minor * 100 + patch;
 }
 
+static int mkfs_xfs_version_parser(void)
+{
+	FILE *f;
+	int rc, major, minor, patch;
+
+	f = popen("mkfs.xfs -V 2>&1", "r");
+	if (!f) {
+		tst_resm(TWARN, "Could not run mkfs.xfs -V 2>&1 cmd");
+		return -1;
+	}
+
+	rc = fscanf(f, "mkfs.xfs version %d.%d.%d", &major, &minor, &patch);
+	pclose(f);
+	if (rc != 3) {
+		tst_resm(TWARN, "Unable to parse mkfs.xfs version");
+		return -1;
+	}
+
+	return major * 10000 +  minor * 100 + patch;
+}
+
 static struct version_parser {
 	const char *cmd;
 	int (*parser)(void);
 	int (*table_get)(char *version);
 } version_parsers[] = {
-	{"mkfs.ext4", mkfs_ext4_version_parser, mkfs_ext4_version_table_get},
+	{"mkfs.ext4", mkfs_ext4_version_parser, mkfs_generic_version_table_get},
+	{"mkfs.xfs", mkfs_xfs_version_parser, mkfs_generic_version_table_get},
 	{},
 };
 
-void tst_check_cmd(const char *cmd)
+int tst_check_cmd(const char *cmd, const int brk_nosupp)
 {
 	struct version_parser *p;
 	char *cmd_token, *op_token, *version_token, *next, *str;
 	char path[PATH_MAX];
 	char parser_cmd[100];
 	int ver_parser, ver_get;
-	int op_flag = 0;
 
 	strcpy(parser_cmd, cmd);
 
@@ -257,22 +268,7 @@ void tst_check_cmd(const char *cmd)
 		tst_brkm(TCONF, NULL, "Couldn't find '%s' in $PATH", cmd_token);
 
 	if (!op_token)
-		return;
-
-	if (!strcmp(op_token, ">="))
-		op_flag = OP_GE;
-	else if (!strcmp(op_token, ">"))
-		op_flag = OP_GT;
-	else if (!strcmp(op_token, "<="))
-		op_flag = OP_LE;
-	else if (!strcmp(op_token, "<"))
-		op_flag = OP_LT;
-	else if (!strcmp(op_token, "=="))
-		op_flag = OP_EQ;
-	else if (!strcmp(op_token, "!="))
-		op_flag = OP_NE;
-	else
-		tst_brkm(TCONF, NULL, "Invalid op(%s)", op_token);
+		return 0;
 
 	if (!version_token || str) {
 		tst_brkm(TCONF, NULL,
@@ -300,48 +296,37 @@ void tst_check_cmd(const char *cmd)
 	if (ver_get < 0)
 		tst_brkm(TBROK, NULL, "Failed to get %s version", p->cmd);
 
-	switch (op_flag) {
-	case OP_GE:
-		if (ver_parser < ver_get) {
-			tst_brkm(TCONF, NULL, "%s required >= %d, but got %d, "
-				"the version is required in order run the test.",
-				cmd, ver_get, ver_parser);
-		}
-		break;
-	case OP_GT:
-		if (ver_parser <= ver_get) {
-			tst_brkm(TCONF, NULL, "%s required > %d, but got %d, "
-				"the version is required in order run the test.",
-				cmd, ver_get, ver_parser);
-		}
-		break;
-	case OP_LE:
-		if (ver_parser > ver_get) {
-			tst_brkm(TCONF, NULL, "%s required <= %d, but got %d, "
-				"the version is required in order run the test.",
-				cmd, ver_get, ver_parser);
-		}
-		break;
-	case OP_LT:
-		if (ver_parser >= ver_get) {
-			tst_brkm(TCONF, NULL, "%s required < %d, but got %d, "
-				"the version is required in order run the test.",
-				cmd, ver_get, ver_parser);
-		}
-		break;
-	case OP_EQ:
-		if (ver_parser != ver_get) {
-			tst_brkm(TCONF, NULL, "%s required == %d, but got %d, "
-				"the version is required in order run the test.",
-				cmd, ver_get, ver_parser);
-		}
-		break;
-	case OP_NE:
-		if (ver_parser == ver_get) {
-			tst_brkm(TCONF, NULL, "%s required != %d, but got %d, "
-				"the version is required in order run the test.",
-				cmd, ver_get, ver_parser);
-		}
-		break;
+	if (!strcmp(op_token, ">=")) {
+		if (ver_parser < ver_get)
+			goto error;
+	} else if (!strcmp(op_token, ">")) {
+		if (ver_parser <= ver_get)
+			goto error;
+	} else if (!strcmp(op_token, "<=")) {
+		if (ver_parser > ver_get)
+			goto error;
+	} else if (!strcmp(op_token, "<")) {
+		if (ver_parser >= ver_get)
+			goto error;
+	} else if (!strcmp(op_token, "==")) {
+		if (ver_parser != ver_get)
+			goto error;
+	} else if (!strcmp(op_token, "!=")) {
+		if (ver_parser == ver_get)
+			goto error;
+	} else {
+		tst_brkm(TCONF, NULL, "Invalid op(%s)", op_token);
 	}
+
+	return 0;
+error:
+	if (brk_nosupp) {
+		tst_brkm(TCONF, NULL, "%s requires %s %d, but got %d",
+			cmd, op_token, ver_get, ver_parser);
+	} else {
+		tst_resm(TCONF, "%s requires %s %d, but got %d",
+			cmd, op_token, ver_get, ver_parser);
+	}
+
+	return 1;
 }
diff --git a/lib/tst_kconfig.c b/lib/tst_kconfig.c
index e16ca1400..9bcd57721 100644
--- a/lib/tst_kconfig.c
+++ b/lib/tst_kconfig.c
@@ -569,7 +569,7 @@ char tst_kconfig_get(const char *confname)
 
 void tst_kcmdline_parse(struct tst_kcmdline_var params[], size_t params_len)
 {
-	char buf[128], line[512];
+	char buf[256], line[1024];
 	size_t b_pos = 0,l_pos =0, i;
 	int var_id = -1;
 
@@ -606,7 +606,7 @@ void tst_kcmdline_parse(struct tst_kcmdline_var params[], size_t params_len)
 		break;
 		default:
 			if (b_pos + 1 >= sizeof(buf)) {
-				tst_res(TWARN, "Buffer overflowed while parsing /proc/cmdline");
+				tst_res(TINFO, "WARNING: Buffer overflowed while parsing /proc/cmdline");
 				while (line[l_pos] != '\0' && line[l_pos] != ' ' && line[l_pos] != '\n')
 					l_pos++;
 
@@ -631,3 +631,56 @@ void tst_kcmdline_parse(struct tst_kcmdline_var params[], size_t params_len)
 
 	SAFE_FCLOSE(f);
 }
+
+/*
+ * List of kernel config options that may degrade performance when enabled.
+ */
+static struct tst_kconfig_var slow_kconfigs[] = {
+	TST_KCONFIG_INIT("CONFIG_PROVE_LOCKING"),
+	TST_KCONFIG_INIT("CONFIG_LOCKDEP"),
+	TST_KCONFIG_INIT("CONFIG_DEBUG_SPINLOCK"),
+	TST_KCONFIG_INIT("CONFIG_DEBUG_RT_MUTEXES"),
+	TST_KCONFIG_INIT("CONFIG_DEBUG_MUTEXES"),
+	TST_KCONFIG_INIT("CONFIG_KASAN"),
+	TST_KCONFIG_INIT("CONFIG_SLUB_RCU_DEBUG"),
+	TST_KCONFIG_INIT("CONFIG_TRACE_IRQFLAGS"),
+	TST_KCONFIG_INIT("CONFIG_DEBUG_NET"),
+	TST_KCONFIG_INIT("CONFIG_EXT4_DEBUG"),
+	TST_KCONFIG_INIT("CONFIG_QUOTA_DEBUG"),
+	TST_KCONFIG_INIT("CONFIG_FAULT_INJECTION"),
+	TST_KCONFIG_INIT("CONFIG_DEBUG_OBJECTS")
+};
+
+static bool slow_kconfig_cached;
+static bool slow_kconfig_result;
+
+int tst_has_slow_kconfig(void)
+{
+	unsigned int i;
+	char path_buf[1024];
+
+	if (slow_kconfig_cached)
+		return slow_kconfig_result;
+
+	slow_kconfig_cached = 1;
+
+	if (!kconfig_path(path_buf, sizeof(path_buf))) {
+		slow_kconfig_result = 0;
+		return 0;
+	}
+
+	tst_kconfig_read(slow_kconfigs, ARRAY_SIZE(slow_kconfigs));
+
+	for (i = 0; i < ARRAY_SIZE(slow_kconfigs); i++) {
+		if (slow_kconfigs[i].choice == 'y') {
+			tst_res(TINFO,
+				"%s kernel option detected which might slow the execution",
+				slow_kconfigs[i].id);
+			slow_kconfig_result = 1;
+			return 1;
+		}
+	}
+
+	slow_kconfig_result = 0;
+	return 0;
+}
diff --git a/lib/tst_kernel.c b/lib/tst_kernel.c
index 8dabfeba2..9ab02e5d3 100644
--- a/lib/tst_kernel.c
+++ b/lib/tst_kernel.c
@@ -214,3 +214,13 @@ int tst_check_driver(const char *driver)
 
 	return -1;
 }
+
+int tst_check_preempt_rt(void)
+{
+	struct utsname uval;
+
+	uname(&uval);
+	if (strstr(uval.version, "PREEMPT_RT"))
+		return 1;
+	return 0;
+}
diff --git a/lib/tst_module.c b/lib/tst_module.c
index 9bd443623..cec20524f 100644
--- a/lib/tst_module.c
+++ b/lib/tst_module.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013 Oracle and/or its affiliates. All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2016-2024
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -23,8 +24,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <stdbool.h>
 
 #include "test.h"
+#include "tst_kconfig.h"
 #include "ltp_priv.h"
 #include "old_module.h"
 
@@ -122,3 +125,24 @@ void tst_module_unload_(void (cleanup_fn)(void), const char *mod_name)
 			 "could not unload %s module", mod_name);
 	}
 }
+
+bool tst_module_signature_enforced_(void)
+{
+	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
+	struct tst_kconfig_var kconfig = TST_KCONFIG_INIT("CONFIG_MODULE_SIG_FORCE");
+	int rc;
+
+	tst_kcmdline_parse(&params, 1);
+	tst_kconfig_read(&kconfig, 1);
+
+	rc = params.found || kconfig.choice == 'y';
+	tst_resm(TINFO, "module signature enforcement: %s", rc ? "on" : "off");
+
+	return rc;
+}
+
+void tst_requires_module_signature_disabled_(void)
+{
+	if (tst_module_signature_enforced_())
+		tst_brkm(TCONF, NULL, "module signature is enforced, skip test");
+}
diff --git a/lib/tst_res.c b/lib/tst_res.c
index 7c66d2f6c..f50c07271 100644
--- a/lib/tst_res.c
+++ b/lib/tst_res.c
@@ -141,11 +141,14 @@ struct pair {
 #define PAIR(def) [def] = {.name = #def, .val = def},
 #define STRPAIR(key, value) [key] = {.name = value, .val = key},
 
-#define PAIR_LOOKUP(pair_arr, idx) do {                       \
-	if (idx < 0 || (size_t)idx >= ARRAY_SIZE(pair_arr) || \
-	    pair_arr[idx].name == NULL)                       \
-		return "???";                                 \
-	return pair_arr[idx].name;                            \
+#define PAIR_LOOKUP(pair_arr, idx) do {                                      \
+	static char pair_str_buf__[16];                                      \
+	if (idx < 0 || (size_t)idx >= ARRAY_SIZE(pair_arr) ||                \
+	    pair_arr[idx].name == NULL) {                                    \
+		snprintf(pair_str_buf__, sizeof(pair_str_buf__), "%i", idx); \
+		return pair_str_buf__;                                       \
+	}                                                                    \
+	return pair_arr[idx].name;                                           \
 } while (0)
 
 const char *strttype(int ttype)
diff --git a/lib/tst_safe_macros.c b/lib/tst_safe_macros.c
index 39b8cc924..ba095a621 100644
--- a/lib/tst_safe_macros.c
+++ b/lib/tst_safe_macros.c
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <sched.h>
 #include <sys/ptrace.h>
+#include <sys/prctl.h>
 #include "config.h"
 #ifdef HAVE_SYS_FANOTIFY_H
 # include <sys/fanotify.h>
@@ -695,18 +696,117 @@ int safe_mprotect(const char *file, const int lineno,
 	tst_prot_to_str(prot, prot_buf);
 
 	tst_res_(file, lineno, TDEBUG,
-		"mprotect(%p, %ld, %s(%x))", addr, len, prot_buf, prot);
+		"mprotect(%p, %zi, %s(%x))", addr, len, prot_buf, prot);
 
 	rval = mprotect(addr, len, prot);
 
 	if (rval == -1) {
 		tst_brk_(file, lineno, TBROK | TERRNO,
-			"mprotect(%p, %ld, %s(%x))", addr, len, prot_buf, prot);
+			"mprotect(%p, %zi, %s(%x))", addr, len, prot_buf, prot);
 	} else if (rval) {
 		tst_brk_(file, lineno, TBROK | TERRNO,
-			"mprotect(%p, %ld, %s(%x)) return value %d",
+			"mprotect(%p, %zi, %s(%x)) return value %d",
 			addr, len, prot_buf, prot, rval);
 	}
 
 	return rval;
 }
+
+int safe_prctl(const char *file, const int lineno,
+	int option, unsigned long arg2, unsigned long arg3,
+	unsigned long arg4, unsigned long arg5)
+{
+	int rval;
+
+	rval = prctl(option, arg2, arg3, arg4, arg5);
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"prctl(%d, %lu, %lu, %lu, %lu)",
+			option, arg2, arg3, arg4, arg5);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid prctl(%d, %lu, %lu, %lu, %lu) return value %d",
+			option, arg2, arg3, arg4, arg5, rval);
+	}
+
+	return rval;
+}
+
+ssize_t safe_readv(const char *file, const int lineno, char len_strict,
+	int fildes, const struct iovec *iov, int iovcnt)
+{
+	ssize_t rval, nbyte;
+	int i;
+
+	for (i = 0, nbyte = 0; i < iovcnt; i++)
+		nbyte += iov[i].iov_len;
+
+	rval = readv(fildes, iov, iovcnt);
+
+	if (rval == -1 || (len_strict && rval != nbyte)) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"readv(%d,%p,%d) failed", fildes, iov, iovcnt);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid readv(%d,%p,%d) return value %zd",
+			fildes, iov, iovcnt, rval);
+	}
+
+	return rval;
+}
+
+int safe_symlinkat(const char *file, const int lineno,
+                 const char *oldpath, const int newdirfd, const char *newpath)
+{
+	int rval;
+
+	rval = symlinkat(oldpath, newdirfd, newpath);
+
+	if (rval == -1) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"symlinkat(%s,%d,%s) failed", oldpath, newdirfd, newpath);
+	} else if (rval) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid symlinkat(%s,%d,%s) return value %d", oldpath,
+			newdirfd, newpath, rval);
+	}
+
+	return rval;
+}
+
+ssize_t safe_writev(const char *file, const int lineno, char len_strict,
+	int fildes, const struct iovec *iov, int iovcnt)
+{
+	ssize_t rval, nbyte;
+	int i;
+
+	for (i = 0, nbyte = 0; i < iovcnt; i++)
+		nbyte += iov[i].iov_len;
+
+	rval = writev(fildes, iov, iovcnt);
+
+	if (rval == -1 || (len_strict && rval != nbyte)) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"writev(%d,%p,%d) failed", fildes, iov, iovcnt);
+	} else if (rval < 0) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"Invalid writev(%d,%p,%d) return value %zd",
+			fildes, iov, iovcnt, rval);
+	}
+
+	return rval;
+}
+
+char *safe_ptsname(const char *const file, const int lineno, int masterfd)
+{
+	char *name;
+
+	name = ptsname(masterfd);
+
+	if (!name) {
+		tst_brk_(file, lineno, TBROK | TERRNO,
+			"ptsname(%d) failed", masterfd);
+	}
+
+	return name;
+}
diff --git a/lib/tst_taint.c b/lib/tst_taint.c
index 58b96f6eb..94459523e 100644
--- a/lib/tst_taint.c
+++ b/lib/tst_taint.c
@@ -33,6 +33,7 @@ static const char *const taint_strings[] = {
 	"K (Live patched)",
 	"X (Auxilary)",
 	"T (Built with struct randomization)",
+	"N (In-kernel test has been run)",
 };
 
 static unsigned int tst_taint_read(void)
@@ -50,49 +51,17 @@ static int tst_taint_check_kver(unsigned int mask)
 	int r2;
 	int r3 = 0;
 
-	if (mask & TST_TAINT_X) {
+	if (mask & TST_TAINT_N) {
+		r1 = 6;
+		r2 = 0;
+	} else if (mask & TST_TAINT_X) {
 		r1 = 4;
 		r2 = 15;
 	} else if (mask & TST_TAINT_K) {
 		r1 = 4;
 		r2 = 0;
-	} else if (mask & TST_TAINT_L) {
-		r1 = 3;
-		r2 = 17;
-	} else if (mask & TST_TAINT_E) {
-		r1 = 3;
-		r2 = 15;
-	} else if (mask & TST_TAINT_O) {
-		r1 = 3;
-		r2 = 2;
-	} else if (mask & TST_TAINT_I) {
-		r1 = 2;
-		r2 = 6;
-		r3 = 35;
-	} else if (mask & TST_TAINT_C) {
-		r1 = 2;
-		r2 = 6;
-		r3 = 28;
-	} else if (mask & TST_TAINT_W) {
-		r1 = 2;
-		r2 = 6;
-		r3 = 26;
-	} else if (mask & TST_TAINT_A) {
-		r1 = 2;
-		r2 = 6;
-		r3 = 25;
-	} else if (mask & TST_TAINT_D) {
-		r1 = 2;
-		r2 = 6;
-		r3 = 23;
-	} else if (mask & TST_TAINT_U) {
-		r1 = 2;
-		r2 = 6;
-		r3 = 21;
 	} else {
-		r1 = 2;
-		r2 = 6;
-		r3 = 16;
+		return 1;
 	}
 
 	return tst_kvercmp(r1, r2, r3);
diff --git a/lib/tst_test.c b/lib/tst_test.c
index 0594cbaae..b204ad975 100644
--- a/lib/tst_test.c
+++ b/lib/tst_test.c
@@ -4,6 +4,8 @@
  * Copyright (c) Linux Test Project, 2016-2024
  */
 
+#define _GNU_SOURCE
+
 #include <limits.h>
 #include <stdio.h>
 #include <stdarg.h>
@@ -13,6 +15,7 @@
 #include <errno.h>
 #include <sys/mount.h>
 #include <sys/types.h>
+#include <sys/utsname.h>
 #include <sys/wait.h>
 #include <math.h>
 
@@ -68,8 +71,8 @@ struct results {
 	int failed;
 	int warnings;
 	int broken;
-	unsigned int timeout;
-	int max_runtime;
+	unsigned int runtime;
+	unsigned int overall_time;
 };
 
 static struct results *results;
@@ -173,6 +176,50 @@ void tst_reinit(void)
 	SAFE_CLOSE(fd);
 }
 
+extern char **environ;
+
+static unsigned int params_array_len(char *const array[])
+{
+	unsigned int ret = 0;
+
+	if (!array)
+		return 0;
+
+	while (*(array++))
+		ret++;
+
+	return ret;
+}
+
+int tst_run_script(const char *script_name, char *const params[])
+{
+	int pid;
+	unsigned int i, params_len = params_array_len(params);
+	char *argv[params_len + 2];
+
+	if (!tst_test->runs_script)
+		tst_brk(TBROK, "runs_script flag must be set!");
+
+	argv[0] = (char*)script_name;
+
+	if (params) {
+		for (i = 0; i < params_len; i++)
+			argv[i+1] = params[i];
+	}
+
+	argv[params_len+1] = NULL;
+
+	pid = SAFE_FORK();
+	if (pid)
+		return pid;
+
+	execvpe(script_name, argv, environ);
+
+	tst_brk(TBROK | TERRNO, "execvpe(%s, ...) failed!", script_name);
+
+	return -1;
+}
+
 static void update_results(int ttype)
 {
 	if (!results)
@@ -499,16 +546,13 @@ static void parse_mul(float *mul, const char *env_name, float min, float max)
 	}
 }
 
-static int multiply_runtime(int max_runtime)
+static int multiply_runtime(unsigned int runtime)
 {
 	static float runtime_mul = -1;
 
-	if (max_runtime <= 0)
-		return max_runtime;
-
 	parse_mul(&runtime_mul, "LTP_RUNTIME_MUL", 0.0099, 100);
 
-	return max_runtime * runtime_mul;
+	return runtime * runtime_mul;
 }
 
 static struct option {
@@ -546,21 +590,21 @@ static void print_help(void)
 	fprintf(stderr, "Timeout and runtime\n");
 	fprintf(stderr, "-------------------\n");
 
-	if (tst_test->max_runtime) {
-		runtime = multiply_runtime(tst_test->max_runtime);
+	if (tst_test->timeout == TST_UNLIMITED_TIMEOUT) {
+		fprintf(stderr, "Test timeout is not limited\n");
+	} else {
+		timeout = tst_multiply_timeout(DEFAULT_TIMEOUT + tst_test->timeout);
 
-		if (runtime == TST_UNLIMITED_RUNTIME) {
-			fprintf(stderr, "Test iteration runtime is not limited\n");
-		} else {
-			fprintf(stderr, "Test iteration runtime cap %ih %im %is\n",
-				runtime/3600, (runtime%3600)/60, runtime % 60);
-		}
+		fprintf(stderr, "Test timeout (not including runtime) %ih %im %is\n",
+				timeout/3600, (timeout%3600)/60, timeout % 60);
 	}
 
-	timeout = tst_multiply_timeout(DEFAULT_TIMEOUT);
+	if (tst_test->runtime) {
+		runtime = multiply_runtime(tst_test->runtime);
 
-	fprintf(stderr, "Test timeout (not including runtime) %ih %im %is\n",
-		timeout/3600, (timeout%3600)/60, timeout % 60);
+		fprintf(stderr, "Test iteration runtime cap %ih %im %is\n",
+				runtime/3600, (runtime%3600)/60, runtime % 60);
+	}
 
 	fprintf(stderr, "\n");
 
@@ -693,8 +737,8 @@ static void parse_opts(int argc, char *argv[])
 			iterations = SAFE_STRTOL(optarg, 0, INT_MAX);
 		break;
 		case 'I':
-			if (tst_test->max_runtime > 0)
-				tst_test->max_runtime = SAFE_STRTOL(optarg, 1, INT_MAX);
+			if (tst_test->runtime > 0)
+				tst_test->runtime = SAFE_STRTOL(optarg, 1, INT_MAX);
 			else
 				duration = SAFE_STRTOF(optarg, 0.1, HUGE_VALF);
 		break;
@@ -852,6 +896,8 @@ static void print_failure_hint(const char *tag, const char *hint,
 	}
 }
 
+static int show_failure_hints;
+
 /* update also docparse/testinfo.pl */
 static void print_failure_hints(void)
 {
@@ -862,6 +908,8 @@ static void print_failure_hints(void)
 	print_failure_hint("musl-git", "missing musl fixes", MUSL_GIT_URL);
 	print_failure_hint("CVE", "vulnerable to CVE(s)", CVE_DB_URL);
 	print_failure_hint("known-fail", "hit by known kernel failures", NULL);
+
+	show_failure_hints = 0;
 }
 
 static void do_exit(int ret)
@@ -872,7 +920,8 @@ static void do_exit(int ret)
 
 		if (results->failed) {
 			ret |= TFAIL;
-			print_failure_hints();
+			if (show_failure_hints)
+				print_failure_hints();
 		}
 
 		if (results->skipped && !results->passed)
@@ -883,7 +932,8 @@ static void do_exit(int ret)
 
 		if (results->broken) {
 			ret |= TBROK;
-			print_failure_hints();
+			if (show_failure_hints)
+				print_failure_hints();
 		}
 
 		fprintf(stderr, "\nSummary:\n");
@@ -899,20 +949,29 @@ static void do_exit(int ret)
 	exit(ret);
 }
 
-void check_kver(void)
+int check_kver(const char *min_kver, const int brk_nosupp)
 {
+	char *msg;
 	int v1, v2, v3;
 
-	if (tst_parse_kver(tst_test->min_kver, &v1, &v2, &v3)) {
+	if (tst_parse_kver(min_kver, &v1, &v2, &v3)) {
 		tst_res(TWARN,
 			"Invalid kernel version %s, expected %%d.%%d.%%d",
-			tst_test->min_kver);
+			min_kver);
 	}
 
 	if (tst_kvercmp(v1, v2, v3) < 0) {
-		tst_brk(TCONF, "The test requires kernel %s or newer",
-			tst_test->min_kver);
+		msg = "The test requires kernel %s or newer";
+
+		if (brk_nosupp)
+			tst_brk(TCONF, msg, min_kver);
+		else
+			tst_res(TCONF, msg, min_kver);
+
+		return 1;
 	}
+
+	return 0;
 }
 
 static int results_equal(struct results *a, struct results *b)
@@ -1039,7 +1098,7 @@ static void prepare_and_mount_hugetlb_fs(void)
 	mntpoint_mounted = 1;
 }
 
-int tst_creat_unlinked(const char *path, int flags)
+int tst_creat_unlinked(const char *path, int flags, mode_t mode)
 {
 	char template[PATH_MAX];
 	int len, c, range;
@@ -1058,7 +1117,7 @@ int tst_creat_unlinked(const char *path, int flags)
 	}
 
 	flags |= O_CREAT|O_EXCL|O_RDWR;
-	fd = SAFE_OPEN(template, flags);
+	fd = SAFE_OPEN(template, flags, mode);
 	SAFE_UNLINK(template);
 	return fd;
 }
@@ -1097,15 +1156,18 @@ static const char *get_device_name(const char *fs_type)
 		return tdev.dev;
 }
 
-static void prepare_device(void)
+static void prepare_device(struct tst_fs *fs)
 {
 	const char *mnt_data;
 	char buf[1024];
+	struct tst_fs dummy = {};
 
-	if (tst_test->format_device) {
-		SAFE_MKFS(tdev.dev, tdev.fs_type, tst_test->dev_fs_opts,
-			  tst_test->dev_extra_opts);
-	}
+	fs = fs ?: &dummy;
+
+	const char *const extra[] = {fs->mkfs_size_opt, NULL};
+
+	if (tst_test->format_device)
+		SAFE_MKFS(tdev.dev, tdev.fs_type, fs->mkfs_opts, extra);
 
 	if (tst_test->needs_rofs) {
 		prepare_and_mount_ro_fs(tdev.dev, tst_test->mntpoint,
@@ -1114,11 +1176,11 @@ static void prepare_device(void)
 	}
 
 	if (tst_test->mount_device) {
-		mnt_data = limit_tmpfs_mount_size(tst_test->mnt_data,
+		mnt_data = limit_tmpfs_mount_size(fs->mnt_data,
 				buf, sizeof(buf), tdev.fs_type);
 
 		SAFE_MOUNT(get_device_name(tdev.fs_type), tst_test->mntpoint,
-				tdev.fs_type, tst_test->mnt_flags, mnt_data);
+				tdev.fs_type, fs->mnt_flags, mnt_data);
 		mntpoint_mounted = 1;
 	}
 }
@@ -1154,12 +1216,45 @@ static void set_ulimit_(const char *file, const int lineno, const struct tst_uli
 	if (conf->rlim_cur > rlim.rlim_max)
 		rlim.rlim_max = conf->rlim_cur;
 
-	tst_res_(file, lineno, TINFO, "Set ulimit resource: %d rlim_cur: %lu rlim_max: %lu",
-		conf->resource, rlim.rlim_cur, rlim.rlim_max);
+	tst_res_(file, lineno, TINFO, "Set ulimit resource: %d rlim_cur: %llu rlim_max: %llu",
+		conf->resource, (long long unsigned int)rlim.rlim_cur,
+		(long long unsigned int)rlim.rlim_max);
 
 	safe_setrlimit(file, lineno, conf->resource, &rlim);
 }
 
+static unsigned int count_fs_descs(void)
+{
+	unsigned int ret = 0;
+
+	if (!tst_test->filesystems)
+		return 0;
+
+	/*
+	 * First entry is special, if it has zero type it's the default entry
+	 * and is either followed by a terminating entry or by filesystem
+	 * description(s) plus terminating entry.
+	 */
+	if (!tst_test->filesystems[0].type)
+		ret = 1;
+
+	while (tst_test->filesystems[ret].type)
+		ret++;
+
+	return ret;
+}
+
+static const char *default_fs_type(void)
+{
+	if (!tst_test->filesystems)
+		return tst_dev_fs_type();
+
+	if (tst_test->filesystems[0].type)
+		return tst_test->filesystems[0].type;
+
+	return tst_dev_fs_type();
+}
+
 static void do_setup(int argc, char *argv[])
 {
 	char *tdebug_env = getenv("LTP_ENABLE_DEBUG");
@@ -1167,9 +1262,14 @@ static void do_setup(int argc, char *argv[])
 	if (!tst_test)
 		tst_brk(TBROK, "No tests to run");
 
-	if (tst_test->max_runtime < -1) {
+	if (tst_test->timeout < -1) {
+		tst_brk(TBROK, "Invalid timeout value %i",
+			tst_test->timeout);
+	}
+
+	if (tst_test->runtime < 0) {
 		tst_brk(TBROK, "Invalid runtime value %i",
-			results->max_runtime);
+			results->runtime);
 	}
 
 	if (tst_test->tconf_msg)
@@ -1189,6 +1289,11 @@ static void do_setup(int argc, char *argv[])
 		tdebug = 1;
 	}
 
+	if (tst_test->runs_script) {
+		tst_test->child_needs_reinit = 1;
+		tst_test->forks_child = 1;
+	}
+
 	if (tst_test->needs_kconfigs && tst_kconfig_check(tst_test->needs_kconfigs))
 		tst_brk(TCONF, "Aborting due to unsuitable kernel config, see above!");
 
@@ -1196,7 +1301,7 @@ static void do_setup(int argc, char *argv[])
 		tst_brk(TCONF, "Test needs to be run as root");
 
 	if (tst_test->min_kver)
-		check_kver();
+		check_kver(tst_test->min_kver, 1);
 
 	if (tst_test->supported_archs && !tst_is_on_arch(tst_test->supported_archs))
 		tst_brk(TCONF, "This arch '%s' is not supported for test!", tst_arch.name);
@@ -1218,7 +1323,7 @@ static void do_setup(int argc, char *argv[])
 		int i;
 
 		for (i = 0; (cmd = tst_test->needs_cmds[i]); ++i)
-			tst_check_cmd(cmd);
+			tst_check_cmd(cmd, 1);
 	}
 
 	if (tst_test->needs_drivers) {
@@ -1321,13 +1426,17 @@ static void do_setup(int argc, char *argv[])
 
 		tst_device = &tdev;
 
-		if (tst_test->dev_fs_type)
-			tdev.fs_type = tst_test->dev_fs_type;
-		else
-			tdev.fs_type = tst_dev_fs_type();
+		tdev.fs_type = default_fs_type();
+
+		if (!tst_test->all_filesystems && count_fs_descs() <= 1) {
+			if (tst_test->filesystems && tst_test->filesystems->mkfs_ver)
+				tst_check_cmd(tst_test->filesystems->mkfs_ver, 1);
 
-		if (!tst_test->all_filesystems)
-			prepare_device();
+			if (tst_test->filesystems && tst_test->filesystems->min_kver)
+				check_kver(tst_test->filesystems->min_kver, 1);
+
+			prepare_device(tst_test->filesystems);
+		}
 	}
 
 	if (tst_test->needs_overlay && !tst_test->mount_device)
@@ -1555,7 +1664,7 @@ static void alarm_handler(int sig LTP_ATTRIBUTE_UNUSED)
 
 static void heartbeat_handler(int sig LTP_ATTRIBUTE_UNUSED)
 {
-	alarm(results->timeout);
+	alarm(results->overall_time);
 	sigkill_retries = 0;
 }
 
@@ -1572,18 +1681,15 @@ unsigned int tst_remaining_runtime(void)
 	static struct timespec now;
 	int elapsed;
 
-	if (results->max_runtime == TST_UNLIMITED_RUNTIME)
-		return UINT_MAX;
-
-	if (results->max_runtime == 0)
+	if (results->runtime == 0)
 		tst_brk(TBROK, "Runtime not set!");
 
 	if (tst_clock_gettime(CLOCK_MONOTONIC, &now))
 		tst_res(TWARN | TERRNO, "tst_clock_gettime() failed");
 
 	elapsed = tst_timespec_diff_ms(now, tst_start_time) / 1000;
-	if (results->max_runtime > elapsed)
-		return results->max_runtime - elapsed;
+	if (results->runtime > (unsigned int) elapsed)
+		return results->runtime - elapsed;
 
 	return 0;
 }
@@ -1596,36 +1702,47 @@ unsigned int tst_multiply_timeout(unsigned int timeout)
 	if (timeout < 1)
 		tst_brk(TBROK, "timeout must to be >= 1! (%d)", timeout);
 
+	if (tst_has_slow_kconfig())
+		timeout *= 4;
+
 	return timeout * timeout_mul;
 }
 
-static void set_timeout(void)
+static void set_overall_timeout(void)
 {
-	unsigned int timeout = DEFAULT_TIMEOUT;
+	unsigned int timeout = DEFAULT_TIMEOUT + tst_test->timeout;
 
-	if (results->max_runtime == TST_UNLIMITED_RUNTIME) {
-		tst_res(TINFO, "Timeout per run is disabled");
+	if (tst_test->timeout == TST_UNLIMITED_TIMEOUT) {
+		tst_res(TINFO, "Test timeout is not limited");
 		return;
 	}
 
-	if (results->max_runtime < 0) {
-		tst_brk(TBROK, "max_runtime must to be >= -1! (%d)",
-			results->max_runtime);
-	}
+	results->overall_time = tst_multiply_timeout(timeout) + results->runtime;
 
-	results->timeout = tst_multiply_timeout(timeout) + results->max_runtime;
+	tst_res(TINFO, "Overall timeout per run is %uh %02um %02us",
+		results->overall_time/3600, (results->overall_time%3600)/60,
+		results->overall_time % 60);
+}
+
+void tst_set_timeout(int timeout)
+{
+	int timeout_adj = DEFAULT_TIMEOUT + timeout;
+
+	results->overall_time = tst_multiply_timeout(timeout_adj) + results->runtime;
 
-	tst_res(TINFO, "Timeout per run is %uh %02um %02us",
-		results->timeout/3600, (results->timeout%3600)/60,
-		results->timeout % 60);
+	tst_res(TINFO, "Overall timeout per run is %uh %02um %02us",
+		results->overall_time/3600, (results->overall_time%3600)/60,
+		results->overall_time % 60);
+
+	heartbeat();
 }
 
-void tst_set_max_runtime(int max_runtime)
+void tst_set_runtime(int runtime)
 {
-	results->max_runtime = multiply_runtime(max_runtime);
-	tst_res(TINFO, "Updating max runtime to %uh %02um %02us",
-		max_runtime/3600, (max_runtime%3600)/60, max_runtime % 60);
-	set_timeout();
+	results->runtime = multiply_runtime(runtime);
+	tst_res(TINFO, "Updating runtime to %uh %02um %02us",
+		runtime/3600, (runtime%3600)/60, runtime % 60);
+	set_overall_timeout();
 	heartbeat();
 }
 
@@ -1636,7 +1753,9 @@ static int fork_testrun(void)
 	SAFE_SIGNAL(SIGINT, sigint_handler);
 	SAFE_SIGNAL(SIGTERM, sigint_handler);
 
-	alarm(results->timeout);
+	alarm(results->overall_time);
+
+	show_failure_hints = 1;
 
 	test_pid = fork();
 	if (test_pid < 0)
@@ -1680,6 +1799,58 @@ static int fork_testrun(void)
 	return 0;
 }
 
+static struct tst_fs *lookup_fs_desc(const char *fs_type, int all_filesystems)
+{
+	struct tst_fs *fs = tst_test->filesystems;
+	static struct tst_fs empty;
+
+	if (!fs)
+		goto ret;
+
+	for (; fs->type; fs++) {
+
+		if (!fs->type)
+			continue;
+
+		if (!strcmp(fs_type, fs->type))
+			return fs;
+	}
+
+ret:
+	if (!all_filesystems)
+		return NULL;
+
+	if (!tst_test->filesystems || tst_test->filesystems[0].type)
+		return &empty;
+
+	return &tst_test->filesystems[0];
+}
+
+static int run_tcase_on_fs(struct tst_fs *fs, const char *fs_type)
+{
+	int ret;
+
+	tst_res(TINFO, "=== Testing on %s ===", fs_type);
+	tdev.fs_type = fs_type;
+
+	if (fs->mkfs_ver && tst_check_cmd(fs->mkfs_ver, 0))
+		return TCONF;
+
+	if (fs->min_kver && check_kver(fs->min_kver, 0))
+		return TCONF;
+
+	prepare_device(fs);
+
+	ret = fork_testrun();
+
+	if (mntpoint_mounted) {
+		tst_umount(tst_test->mntpoint);
+		mntpoint_mounted = 0;
+	}
+
+	return ret;
+}
+
 static int run_tcases_per_fs(void)
 {
 	int ret = 0;
@@ -1690,18 +1861,12 @@ static int run_tcases_per_fs(void)
 		tst_brk(TCONF, "There are no supported filesystems");
 
 	for (i = 0; filesystems[i]; i++) {
+		struct tst_fs *fs = lookup_fs_desc(filesystems[i], tst_test->all_filesystems);
 
-		tst_res(TINFO, "=== Testing on %s ===", filesystems[i]);
-		tdev.fs_type = filesystems[i];
-
-		prepare_device();
-
-		ret = fork_testrun();
+		if (!fs)
+			continue;
 
-		if (mntpoint_mounted) {
-			tst_umount(tst_test->mntpoint);
-			mntpoint_mounted = 0;
-		}
+		ret = run_tcase_on_fs(fs, filesystems[i]);
 
 		if (ret == TCONF)
 			continue;
@@ -1721,6 +1886,7 @@ void tst_run_tcases(int argc, char *argv[], struct tst_test *self)
 {
 	int ret = 0;
 	unsigned int test_variants = 1;
+	struct utsname uval;
 
 	lib_pid = getpid();
 	tst_test = self;
@@ -1733,16 +1899,20 @@ void tst_run_tcases(int argc, char *argv[], struct tst_test *self)
 
 	tst_res(TINFO, "LTP version: "LTP_VERSION);
 
-	if (tst_test->max_runtime)
-		results->max_runtime = multiply_runtime(tst_test->max_runtime);
 
-	set_timeout();
+	uname(&uval);
+	tst_res(TINFO, "Tested kernel: %s %s %s", uval.release, uval.version, uval.machine);
+
+	if (tst_test->runtime)
+		results->runtime = multiply_runtime(tst_test->runtime);
+
+	set_overall_timeout();
 
 	if (tst_test->test_variants)
 		test_variants = tst_test->test_variants;
 
 	for (tst_variant = 0; tst_variant < test_variants; tst_variant++) {
-		if (tst_test->all_filesystems)
+		if (tst_test->all_filesystems || count_fs_descs() > 1)
 			ret |= run_tcases_per_fs();
 		else
 			ret |= fork_testrun();
diff --git a/lib/tst_timer_test.c b/lib/tst_timer_test.c
index 5a6f957e4..2744e25a0 100644
--- a/lib/tst_timer_test.c
+++ b/lib/tst_timer_test.c
@@ -461,7 +461,7 @@ static void parse_timer_opts(void)
 			runtime_us += tcases[i].usec * tcases[i].samples;
 	}
 
-	tst_set_max_runtime((runtime_us + runtime_us/10)/1000000);
+	tst_set_runtime((runtime_us + runtime_us/10)/1000000);
 }
 
 struct tst_test *tst_timer_test_setup(struct tst_test *timer_test)
diff --git a/lib/tst_tmpdir.c b/lib/tst_tmpdir.c
index b73b5c66f..6ed2367b9 100644
--- a/lib/tst_tmpdir.c
+++ b/lib/tst_tmpdir.c
@@ -71,7 +71,9 @@
 #include <fcntl.h>
 
 #include "test.h"
+#include "tst_buffers.h"
 #include "safe_macros.h"
+#include "tst_tmpdir.h"
 #include "ltp_priv.h"
 #include "lapi/futex.h"
 
@@ -92,7 +94,7 @@
  * Define global variables.
  */
 extern char *TCID;		/* defined/initialized in main() */
-static char *TESTDIR = NULL;	/* the directory created */
+static char *TESTDIR;	/* the directory created */
 
 static char test_start_work_dir[PATH_MAX];
 
@@ -310,6 +312,9 @@ void tst_tmpdir(void)
 
 		tst_exit();
 	}
+
+	tst_resm(TINFO, "Using %s as tmpdir (%s filesystem)", TESTDIR,
+			 tst_fs_type_name(tst_fs_type(NULL, TESTDIR)));
 }
 
 void tst_rmdir(void)
@@ -351,3 +356,47 @@ void tst_purge_dir(const char *path)
 	if (purge_dir(path, &err))
 		tst_brkm(TBROK, NULL, "%s: %s", __func__, err);
 }
+
+char *tst_tmpdir_path(void)
+{
+	static char *tmpdir;
+
+	if (!TESTDIR)
+		tst_brkm(TBROK, NULL, ".needs_tmpdir must be set!");
+
+	if (tmpdir)
+		return tmpdir;
+
+	tmpdir = tst_strdup(TESTDIR);
+
+	return tmpdir;
+}
+
+char *tst_tmpdir_genpath(const char *fmt, ...)
+{
+	size_t testdir_len, path_len;
+	va_list va, vac;
+	char *ret;
+
+	if (!TESTDIR)
+		tst_brkm(TBROK, NULL, ".needs_tmpdir must be set!");
+
+	testdir_len = strlen(TESTDIR);
+	path_len = testdir_len;
+
+	va_start(va, fmt);
+	va_copy(vac, va);
+	path_len += vsnprintf(NULL, 0, fmt, va) + 2;
+	va_end(va);
+
+	ret = tst_alloc(path_len);
+
+	strcpy(ret, TESTDIR);
+
+	ret[testdir_len] = '/';
+
+	vsprintf(ret + testdir_len + 1, fmt, vac);
+	va_end(vac);
+
+	return ret;
+}
diff --git a/libs/libltpipc/Makefile b/libs/ipc/Makefile
similarity index 100%
rename from libs/libltpipc/Makefile
rename to libs/ipc/Makefile
diff --git a/libs/libltpipc/libipc.c b/libs/ipc/libipc.c
similarity index 100%
rename from libs/libltpipc/libipc.c
rename to libs/ipc/libipc.c
diff --git a/libs/libltpipc/libmsgctl.c b/libs/ipc/libmsgctl.c
similarity index 100%
rename from libs/libltpipc/libmsgctl.c
rename to libs/ipc/libmsgctl.c
diff --git a/libs/libltpnewipc/Makefile b/libs/newipc/Makefile
similarity index 100%
rename from libs/libltpnewipc/Makefile
rename to libs/newipc/Makefile
diff --git a/libs/libltpnewipc/libnewipc.c b/libs/newipc/libnewipc.c
similarity index 100%
rename from libs/libltpnewipc/libnewipc.c
rename to libs/newipc/libnewipc.c
diff --git a/libs/libltpnuma/Makefile b/libs/numa/Makefile
similarity index 100%
rename from libs/libltpnuma/Makefile
rename to libs/numa/Makefile
diff --git a/libs/libltpnuma/tst_numa.c b/libs/numa/tst_numa.c
similarity index 100%
rename from libs/libltpnuma/tst_numa.c
rename to libs/numa/tst_numa.c
diff --git a/libs/libltpsigwait/Makefile b/libs/sigwait/Makefile
similarity index 100%
rename from libs/libltpsigwait/Makefile
rename to libs/sigwait/Makefile
diff --git a/libs/libltpsigwait/sigwait.c b/libs/sigwait/sigwait.c
similarity index 90%
rename from libs/libltpsigwait/sigwait.c
rename to libs/sigwait/sigwait.c
index 86899954d..a9fd62d73 100644
--- a/libs/libltpsigwait/sigwait.c
+++ b/libs/sigwait/sigwait.c
@@ -286,9 +286,7 @@ void test_bad_address(swi_func sigwaitinfo, int signo,
 	/* let's not get interrupted by our dying child */
 	SAFE_SIGADDSET(&sigs, SIGCHLD);
 
-	TEST(sigprocmask(SIG_SETMASK, &sigs, &oldmask));
-	if (TST_RET == -1)
-		tst_brk(TBROK | TTERRNO, "sigprocmask() failed");
+	SAFE_SIGPROCMASK(SIG_SETMASK, &sigs, &oldmask);
 
 	/* don't wait on a SIGCHLD */
 	SAFE_SIGDELSET(&sigs, SIGCHLD);
@@ -296,19 +294,8 @@ void test_bad_address(swi_func sigwaitinfo, int signo,
 	/* Run a child that will wake us up */
 	child = create_sig_proc(signo, 1, 0);
 
-	TEST(sigwaitinfo(&sigs, (void *)1, NULL));
-	if (TST_RET == -1) {
-		if (TST_ERR == EFAULT)
-			tst_res(TPASS, "Fault occurred while accessing the buffers");
-		else
-			tst_res(TFAIL | TTERRNO, "Expected error number EFAULT, got");
-	} else {
-		tst_res(TFAIL, "Expected return value -1, got: %ld", TST_RET);
-	}
-
-	TEST(sigprocmask(SIG_SETMASK, &oldmask, NULL));
-	if (TST_RET == -1)
-		tst_brk(TBROK | TTERRNO, "restoring original signal mask failed");
+	TST_EXP_FAIL(sigwaitinfo(&sigs, (void *)1, NULL), EFAULT);
+	SAFE_SIGPROCMASK(SIG_SETMASK, &oldmask, NULL);
 
 	SAFE_KILL(child, SIGTERM);
 	SAFE_WAIT(NULL);
@@ -359,17 +346,27 @@ void test_bad_address3(swi_func sigwaitinfo, int signo LTP_ATTRIBUTE_UNUSED,
 		       enum tst_ts_type type LTP_ATTRIBUTE_UNUSED)
 {
 	sigset_t sigs;
+	pid_t pid;
+	int status;
 
-	SAFE_SIGEMPTYSET(&sigs);
-	TEST(sigwaitinfo(&sigs, NULL, (void *)1));
-	if (TST_RET == -1) {
-		if (TST_ERR == EFAULT)
-			tst_res(TPASS, "Fault occurred while accessing the buffers");
-		else
-			tst_res(TFAIL | TTERRNO, "Expected error number EFAULT, got");
-	} else {
-		tst_res(TFAIL, "Expected return value -1, got: %ld", TST_RET);
+	pid = SAFE_FORK();
+	if (pid == 0) {
+		SAFE_SIGEMPTYSET(&sigs);
+		TST_EXP_FAIL(sigwaitinfo(&sigs, NULL, (void *)1), EFAULT);
+		_exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFEXITED(status) && !WEXITSTATUS(status))
+		return;
+
+	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
+		tst_res(TPASS, "Child killed by expected signal");
+		return;
 	}
+
+	tst_res(TFAIL, "Child %s", tst_strstatus(status));
 }
 
 static void empty_handler(int sig LTP_ATTRIBUTE_UNUSED)
diff --git a/libs/libltpswap/Makefile b/libs/swap/Makefile
similarity index 100%
rename from libs/libltpswap/Makefile
rename to libs/swap/Makefile
diff --git a/libs/libltpswap/libswap.c b/libs/swap/libswap.c
similarity index 97%
rename from libs/libltpswap/libswap.c
rename to libs/swap/libswap.c
index ee964c7e1..63a995f4e 100644
--- a/libs/libltpswap/libswap.c
+++ b/libs/swap/libswap.c
@@ -256,6 +256,12 @@ int tst_max_swapfiles(void)
 		{ NULL, NULL},
 	};
 
+	struct tst_kern_exv kvers_marker_migration2[] = {
+		/* RHEL9 kernel has patch ca92ea3dc5a since 5.14.0-441 */
+		{ "RHEL9", "5.14.0-441" },
+		{ NULL, NULL},
+	};
+
 	struct tst_kern_exv kvers_device[] = {
 		/* SLES12-SP4 has patch 5042db43cc26 since 4.12.14-5.5 */
 		{ "SLES", "4.12.14-5.5" },
@@ -286,7 +292,7 @@ int tst_max_swapfiles(void)
 
 	if ((marker.choice == 'y' &&
 	     tst_kvercmp2(5, 19, 0, kvers_marker_migration) >= 0)
-	    || tst_kvercmp(6, 2, 0) >= 0) {
+	    || tst_kvercmp2(6, 2, 0, kvers_marker_migration2) >= 0) {
 		swp_pte_marker_num = 1;
 	}
 
diff --git a/libs/libltpuinput/Makefile b/libs/uinput/Makefile
similarity index 100%
rename from libs/libltpuinput/Makefile
rename to libs/uinput/Makefile
diff --git a/libs/libltpuinput/tst_uinput.c b/libs/uinput/tst_uinput.c
similarity index 81%
rename from libs/libltpuinput/tst_uinput.c
rename to libs/uinput/tst_uinput.c
index 6dc8a7d4e..16e689153 100644
--- a/libs/libltpuinput/tst_uinput.c
+++ b/libs/uinput/tst_uinput.c
@@ -13,6 +13,7 @@
 #include "tst_test.h"
 
 #include "tst_uinput.h"
+#include "tst_safe_stdio.h"
 
 #define VIRTUAL_DEVICE "virtual-device-ltp"
 
@@ -127,6 +128,29 @@ void destroy_input_device(int fd)
 	SAFE_CLOSE(fd);
 }
 
+static void check_ui_get_sysname_ioctl(int fd)
+{
+	char sys_name[256];
+	char dev_name[256];
+	char *path;
+
+	SAFE_IOCTL(fd, UI_GET_SYSNAME(sizeof(sys_name)), sys_name, NULL);
+	SAFE_ASPRINTF(&path, "/sys/devices/virtual/input/%s/name", sys_name);
+
+	if (FILE_SCANF(path, "%s", dev_name)) {
+		free(path);
+		tst_brk(TBROK|TERRNO, "Failed to read '%s'", path);
+		return;
+	}
+
+	if (strcmp(VIRTUAL_DEVICE, dev_name)) {
+		free(path);
+		tst_brk(TBROK, "ioctl UI_GET_SYSNAME returned wrong name");
+	}
+
+	free(path);
+}
+
 void create_input_device(int fd)
 {
 	int nb;
@@ -144,8 +168,10 @@ void create_input_device(int fd)
 	SAFE_IOCTL(fd, UI_DEV_CREATE, NULL);
 
 	for (nb = 100; nb > 0; nb--) {
-		if (check_device())
+		if (check_device()) {
+			check_ui_get_sysname_ioctl(fd);
 			return;
+		}
 		usleep(10000);
 	}
 
diff --git a/libs/ujson/Makefile b/libs/ujson/Makefile
new file mode 100644
index 000000000..4c8508010
--- /dev/null
+++ b/libs/ujson/Makefile
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Copyright (C) Cyril Hrubis <chrubis@suse.cz>
+
+top_srcdir		?= ../..
+
+include $(top_srcdir)/include/mk/env_pre.mk
+
+INTERNAL_LIB		:= libujson.a
+
+include $(top_srcdir)/include/mk/lib.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/libs/ujson/ujson_common.c b/libs/ujson/ujson_common.c
new file mode 100644
index 000000000..639955229
--- /dev/null
+++ b/libs/ujson/ujson_common.c
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+#include <stdio.h>
+#include "ujson_common.h"
+
+void ujson_err_handler(void *err_print_priv, const char *line)
+{
+	fputs(line, err_print_priv);
+	putc('\n', err_print_priv);
+}
+
+const char *ujson_type_name(enum ujson_type type)
+{
+	switch (type) {
+	case UJSON_VOID:
+		return "void";
+	case UJSON_INT:
+		return "integer";
+	case UJSON_FLOAT:
+		return "float";
+	case UJSON_BOOL:
+		return "boolean";
+	case UJSON_NULL:
+		return "null";
+	case UJSON_STR:
+		return "string";
+	case UJSON_OBJ:
+		return "object";
+	case UJSON_ARR:
+		return "array";
+	default:
+		return "invalid";
+	}
+}
diff --git a/libs/ujson/ujson_reader.c b/libs/ujson/ujson_reader.c
new file mode 100644
index 000000000..9f86f25b7
--- /dev/null
+++ b/libs/ujson/ujson_reader.c
@@ -0,0 +1,1085 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdint.h>
+
+#include "ujson_utf.h"
+#include "ujson_reader.h"
+
+static const struct ujson_obj empty = {};
+const struct ujson_obj *ujson_empty_obj = &empty;
+
+static inline int buf_empty(ujson_reader *buf)
+{
+	return buf->off >= buf->len;
+}
+
+static int eatws(ujson_reader *buf)
+{
+	while (!buf_empty(buf)) {
+		switch (buf->json[buf->off]) {
+		case ' ':
+		case '\t':
+		case '\n':
+		case '\r':
+		break;
+		default:
+			goto ret;
+		}
+
+		buf->off += 1;
+	}
+ret:
+	return buf_empty(buf);
+}
+
+static char getb(ujson_reader *buf)
+{
+	if (buf_empty(buf))
+		return 0;
+
+	return buf->json[buf->off++];
+}
+
+static char peekb_off(ujson_reader *buf, size_t off)
+{
+	if (buf->off + off >= buf->len)
+		return 0;
+
+	return buf->json[buf->off + off];
+}
+
+static char peekb(ujson_reader *buf)
+{
+	if (buf_empty(buf))
+		return 0;
+
+	return buf->json[buf->off];
+}
+
+static int eatb(ujson_reader *buf, char ch)
+{
+	if (peekb(buf) != ch)
+		return 0;
+
+	getb(buf);
+	return 1;
+}
+
+static int eatb2(ujson_reader *buf, char ch1, char ch2)
+{
+	if (peekb(buf) != ch1 && peekb(buf) != ch2)
+		return 0;
+
+	getb(buf);
+	return 1;
+}
+
+static int eatstr(ujson_reader *buf, const char *str)
+{
+	while (*str) {
+		if (!eatb(buf, *str))
+			return 0;
+		str++;
+	}
+
+	return 1;
+}
+
+static int hex2val(unsigned char b)
+{
+	switch (b) {
+	case '0' ... '9':
+		return b - '0';
+	case 'a' ... 'f':
+		return b - 'a' + 10;
+	case 'A' ... 'F':
+		return b - 'A' + 10;
+	default:
+		return -1;
+	}
+}
+
+static int32_t parse_ucode_cp(ujson_reader *buf)
+{
+	int ret = 0, v, i;
+
+	for (i = 0; i < 4; i++) {
+		if ((v = hex2val(getb(buf))) < 0)
+			goto err;
+		ret *= 16;
+		ret += v;
+	}
+
+	return ret;
+err:
+	ujson_err(buf, "Expected four hexadecimal digits");
+	return -1;
+}
+
+static unsigned int parse_ucode_esc(ujson_reader *buf, char *str,
+                                    size_t off, size_t len)
+{
+	int32_t ucode = parse_ucode_cp(buf);
+
+	if (ucode < 0)
+		return 0;
+
+	if (!str)
+		return ucode;
+
+	if (ujson_utf8_bytes(ucode) + 1 >= len - off) {
+		ujson_err(buf, "String buffer too short!");
+		return 0;
+	}
+
+	return ujson_to_utf8(ucode, str+off);
+}
+
+static int copy_str(ujson_reader *buf, char *str, size_t len)
+{
+	size_t pos = 0;
+	int esc = 0;
+	unsigned int l;
+
+	eatb(buf, '"');
+
+	for (;;) {
+		if (buf_empty(buf)) {
+			ujson_err(buf, "Unterminated string");
+			return 1;
+		}
+
+		if (!esc && eatb(buf, '"')) {
+			if (str)
+				str[pos] = 0;
+			return 0;
+		}
+
+		unsigned char b = getb(buf);
+
+		if (b < 0x20) {
+			if (!peekb(buf))
+				ujson_err(buf, "Unterminated string");
+			else
+				ujson_err(buf, "Invalid string character 0x%02x", b);
+			return 1;
+		}
+
+		if (!esc && b == '\\') {
+			esc = 1;
+			continue;
+		}
+
+		if (esc) {
+			switch (b) {
+			case '"':
+			case '\\':
+			case '/':
+			break;
+			case 'b':
+				b = '\b';
+			break;
+			case 'f':
+				b = '\f';
+			break;
+			case 'n':
+				b = '\n';
+			break;
+			case 'r':
+				b = '\r';
+			break;
+			case 't':
+				b = '\t';
+			break;
+			case 'u':
+				if (!(l = parse_ucode_esc(buf, str, pos, len)))
+					return 1;
+				pos += l;
+				b = 0;
+			break;
+			default:
+				ujson_err(buf, "Invalid escape \\%c", b);
+				return 1;
+			}
+			esc = 0;
+		}
+
+		if (str && b) {
+			if (pos + 1 >= len) {
+				ujson_err(buf, "String buffer too short!");
+				return 1;
+			}
+
+			str[pos++] = b;
+		}
+	}
+
+	return 1;
+}
+
+static int copy_id_str(ujson_reader *buf, char *str, size_t len)
+{
+	size_t pos = 0;
+
+	if (eatws(buf))
+		goto err0;
+
+	if (!eatb(buf, '"'))
+		goto err0;
+
+	for (;;) {
+		if (buf_empty(buf)) {
+			ujson_err(buf, "Unterminated ID string");
+			return 1;
+		}
+
+		if (eatb(buf, '"')) {
+			str[pos] = 0;
+			break;
+		}
+
+		if (pos >= len-1) {
+			ujson_err(buf, "ID string too long");
+			return 1;
+		}
+
+		str[pos++] = getb(buf);
+	}
+
+	if (eatws(buf))
+		goto err1;
+
+	if (!eatb(buf, ':'))
+		goto err1;
+
+	return 0;
+err0:
+	ujson_err(buf, "Expected ID string");
+	return 1;
+err1:
+	ujson_err(buf, "Expected ':' after ID string");
+	return 1;
+}
+
+static int is_digit(char b)
+{
+	switch (b) {
+	case '0' ... '9':
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static int get_int(ujson_reader *buf, struct ujson_val *res)
+{
+	long val = 0;
+	int sign = 1;
+
+	if (eatb(buf, '-')) {
+		sign = -1;
+		if (!is_digit(peekb(buf))) {
+			ujson_err(buf, "Expected digit(s)");
+			return 1;
+		}
+	}
+
+	if (peekb(buf) == '0' && is_digit(peekb_off(buf, 1))) {
+		ujson_err(buf, "Leading zero in number!");
+		return 1;
+	}
+
+	while (is_digit(peekb(buf))) {
+		val *= 10;
+		val += getb(buf) - '0';
+		//TODO: overflow?
+	}
+
+	if (sign < 0)
+		val = -val;
+
+	res->val_int = val;
+	res->val_float = val;
+
+	return 0;
+}
+
+static int eat_digits(ujson_reader *buf)
+{
+	if (!is_digit(peekb(buf))) {
+		ujson_err(buf, "Expected digit(s)");
+		return 1;
+	}
+
+	while (is_digit(peekb(buf)))
+		getb(buf);
+
+	return 0;
+}
+
+static int get_float(ujson_reader *buf, struct ujson_val *res)
+{
+	off_t start = buf->off;
+
+	eatb(buf, '-');
+
+	if (peekb(buf) == '0' && is_digit(peekb_off(buf, 1))) {
+		ujson_err(buf, "Leading zero in float");
+		return 1;
+	}
+
+	if (eat_digits(buf))
+		return 1;
+
+	switch (getb(buf)) {
+	case '.':
+		if (eat_digits(buf))
+			return 1;
+
+		if (!eatb2(buf, 'e', 'E'))
+			break;
+
+		/* fallthrough */
+	case 'e':
+	case 'E':
+		eatb2(buf, '+', '-');
+
+		if (eat_digits(buf))
+			return 1;
+	break;
+	}
+
+	size_t len = buf->off - start;
+	char tmp[len+1];
+
+	memcpy(tmp, buf->json + start, len);
+
+	tmp[len] = 0;
+
+	res->val_float = strtod(tmp, NULL);
+
+	return 0;
+}
+
+static int get_bool(ujson_reader *buf, struct ujson_val *res)
+{
+	switch (peekb(buf)) {
+	case 'f':
+		if (!eatstr(buf, "false")) {
+			ujson_err(buf, "Expected 'false'");
+			return 1;
+		}
+
+		res->val_bool = 0;
+	break;
+	case 't':
+		if (!eatstr(buf, "true")) {
+			ujson_err(buf, "Expected 'true'");
+			return 1;
+		}
+
+		res->val_bool = 1;
+	break;
+	}
+
+	return 0;
+}
+
+static int get_null(ujson_reader *buf)
+{
+	if (!eatstr(buf, "null")) {
+		ujson_err(buf, "Expected 'null'");
+		return 1;
+	}
+
+	return 0;
+}
+
+int ujson_obj_skip(ujson_reader *buf)
+{
+	struct ujson_val res = {};
+
+	UJSON_OBJ_FOREACH(buf, &res) {
+		switch (res.type) {
+		case UJSON_OBJ:
+			if (ujson_obj_skip(buf))
+				return 1;
+		break;
+		case UJSON_ARR:
+			if (ujson_arr_skip(buf))
+				return 1;
+		break;
+		default:
+		break;
+		}
+	}
+
+	return 0;
+}
+
+int ujson_arr_skip(ujson_reader *buf)
+{
+	struct ujson_val res = {};
+
+	UJSON_ARR_FOREACH(buf, &res) {
+		switch (res.type) {
+		case UJSON_OBJ:
+			if (ujson_obj_skip(buf))
+				return 1;
+		break;
+		case UJSON_ARR:
+			if (ujson_arr_skip(buf))
+				return 1;
+		break;
+		default:
+		break;
+		}
+	}
+
+	return 0;
+}
+
+static enum ujson_type next_num_type(ujson_reader *buf)
+{
+	size_t off = 0;
+
+	for (;;) {
+		char b = peekb_off(buf, off++);
+
+		switch (b) {
+		case 0:
+		case ',':
+			return UJSON_INT;
+		case '.':
+		case 'e':
+		case 'E':
+			return UJSON_FLOAT;
+		}
+	}
+
+	return UJSON_VOID;
+}
+
+enum ujson_type ujson_next_type(ujson_reader *buf)
+{
+	if (eatws(buf)) {
+		ujson_err(buf, "Unexpected end");
+		return UJSON_VOID;
+	}
+
+	char b = peekb(buf);
+
+	switch (b) {
+	case '{':
+		return UJSON_OBJ;
+	case '[':
+		return UJSON_ARR;
+	case '"':
+		return UJSON_STR;
+	case '-':
+	case '0' ... '9':
+		return next_num_type(buf);
+	case 'f':
+	case 't':
+		return UJSON_BOOL;
+	break;
+	case 'n':
+		return UJSON_NULL;
+	break;
+	default:
+		ujson_err(buf, "Expected object, array, number or string");
+		return UJSON_VOID;
+	}
+}
+
+enum ujson_type ujson_reader_start(ujson_reader *buf)
+{
+	enum ujson_type type = ujson_next_type(buf);
+
+	switch (type) {
+	case UJSON_ARR:
+	case UJSON_OBJ:
+	case UJSON_VOID:
+	break;
+	default:
+		ujson_err(buf, "JSON can start only with array or object");
+		type = UJSON_VOID;
+	break;
+	}
+
+	return type;
+}
+
+static int get_value(ujson_reader *buf, struct ujson_val *res)
+{
+	int ret = 0;
+
+	res->type = ujson_next_type(buf);
+
+	switch (res->type) {
+	case UJSON_STR:
+		if (copy_str(buf, res->buf, res->buf_size)) {
+			res->type = UJSON_VOID;
+			return 0;
+		}
+		res->val_str = res->buf;
+		return 1;
+	case UJSON_INT:
+		ret = get_int(buf, res);
+	break;
+	case UJSON_FLOAT:
+		ret = get_float(buf, res);
+	break;
+	case UJSON_BOOL:
+		ret = get_bool(buf, res);
+	break;
+	case UJSON_NULL:
+		ret = get_null(buf);
+	break;
+	case UJSON_VOID:
+		return 0;
+	case UJSON_ARR:
+	case UJSON_OBJ:
+		buf->sub_off = buf->off;
+		return 1;
+	}
+
+	if (ret) {
+		res->type = UJSON_VOID;
+		return 0;
+	}
+
+	return 1;
+}
+
+static int pre_next(ujson_reader *buf, struct ujson_val *res)
+{
+	if (!eatb(buf, ',')) {
+		ujson_err(buf, "Expected ','");
+		res->type = UJSON_VOID;
+		return 1;
+	}
+
+	if (eatws(buf)) {
+		ujson_err(buf, "Unexpected end");
+		res->type = UJSON_VOID;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int check_end(ujson_reader *buf, struct ujson_val *res, char b)
+{
+	if (eatws(buf)) {
+		ujson_err(buf, "Unexpected end");
+		return 1;
+	}
+
+	if (eatb(buf, b)) {
+		res->type = UJSON_VOID;
+		eatws(buf);
+		eatb(buf, 0);
+		buf->depth--;
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * This is supposed to return a pointer to a string stored as a first member of
+ * a structure given an array.
+ *
+ * e.g.
+ *
+ *	struct foo {
+ *		const char *key;
+ *		...
+ *	};
+ *
+ *	const struct foo bar[10] = {...};
+ *
+ *      // Returns a pointer to the key string in a second structure in bar[].
+ *	const char *key = list_elem(bar, sizeof(struct foo), 1);
+ */
+static inline const char *list_elem(const void *arr, size_t memb_size, size_t idx)
+{
+	return *(const char**)(arr + idx * memb_size);
+}
+
+size_t ujson_lookup(const void *arr, size_t memb_size, size_t list_len,
+                    const char *key)
+{
+	size_t l = 0;
+	size_t r = list_len-1;
+	size_t mid = -1;
+
+	if (!list_len)
+		return (size_t)-1;
+
+	while (r - l > 1) {
+		mid = (l+r)/2;
+
+		int ret = strcmp(list_elem(arr, memb_size, mid), key);
+		if (!ret)
+			return mid;
+
+		if (ret < 0)
+			l = mid;
+		else
+			r = mid;
+	}
+
+	if (r != mid && !strcmp(list_elem(arr, memb_size, r), key))
+		return r;
+
+	if (l != mid && !strcmp(list_elem(arr, memb_size, l), key))
+		return l;
+
+	return -1;
+}
+
+static int skip_obj_val(ujson_reader *buf)
+{
+	struct ujson_val dummy = {};
+
+	if (!get_value(buf, &dummy))
+		return 0;
+
+	switch (dummy.type) {
+	case UJSON_OBJ:
+		return !ujson_obj_skip(buf);
+	case UJSON_ARR:
+		return !ujson_arr_skip(buf);
+	default:
+		return 1;
+	}
+}
+
+static int obj_next(ujson_reader *buf, struct ujson_val *res)
+{
+	if (copy_id_str(buf, res->id, sizeof(res->id)))
+		return 0;
+
+	return get_value(buf, res);
+}
+
+static int obj_pre_next(ujson_reader *buf, struct ujson_val *res)
+{
+	if (ujson_reader_err(buf))
+		return 1;
+
+	if (check_end(buf, res, '}'))
+		return 1;
+
+	if (pre_next(buf, res))
+		return 1;
+
+	return 0;
+}
+
+static int obj_next_filter(ujson_reader *buf, struct ujson_val *res,
+                           const struct ujson_obj *obj, const struct ujson_obj *ign)
+{
+	const struct ujson_obj_attr *attr;
+
+	for (;;) {
+		if (copy_id_str(buf, res->id, sizeof(res->id)))
+			return 0;
+
+		res->idx = obj ? ujson_obj_lookup(obj, res->id) : (size_t)-1;
+
+		if (res->idx != (size_t)-1) {
+			if (!get_value(buf, res))
+				return 0;
+
+			attr = &obj->attrs[res->idx];
+
+			if (attr->type == UJSON_VOID)
+				return 1;
+
+			if (attr->type == res->type)
+				return 1;
+
+			if (attr->type == UJSON_FLOAT &&
+			    res->type == UJSON_INT)
+				return 1;
+
+			ujson_warn(buf, "Wrong '%s' type expected %s",
+				     attr->key, ujson_type_name(attr->type));
+		} else {
+			if (!skip_obj_val(buf))
+				return 0;
+
+			if (ign && ujson_obj_lookup(ign, res->id) == (size_t)-1)
+				ujson_warn(buf, "Unexpected key '%s'", res->id);
+		}
+
+		if (obj_pre_next(buf, res))
+			return 0;
+	}
+}
+
+static int check_err(ujson_reader *buf, struct ujson_val *res)
+{
+	if (ujson_reader_err(buf)) {
+		res->type = UJSON_VOID;
+		return 1;
+	}
+
+	return 0;
+}
+
+int ujson_obj_next_filter(ujson_reader *buf, struct ujson_val *res,
+                            const struct ujson_obj *obj, const struct ujson_obj *ign)
+{
+	if (check_err(buf, res))
+		return 0;
+
+	if (obj_pre_next(buf, res))
+		return 0;
+
+	return obj_next_filter(buf, res, obj, ign);
+}
+
+int ujson_obj_next(ujson_reader *buf, struct ujson_val *res)
+{
+	if (check_err(buf, res))
+		return 0;
+
+	if (obj_pre_next(buf, res))
+		return 0;
+
+	return obj_next(buf, res);
+}
+
+static int any_first(ujson_reader *buf, char b)
+{
+	if (eatws(buf)) {
+		ujson_err(buf, "Unexpected end");
+		return 1;
+	}
+
+	if (!eatb(buf, b)) {
+		ujson_err(buf, "Expected '%c'", b);
+		return 1;
+	}
+
+	buf->depth++;
+
+	if (buf->depth > buf->max_depth) {
+		ujson_err(buf, "Recursion too deep");
+		return 1;
+	}
+
+	return 0;
+}
+
+int ujson_obj_first_filter(ujson_reader *buf, struct ujson_val *res,
+                             const struct ujson_obj *obj, const struct ujson_obj *ign)
+{
+	if (check_err(buf, res))
+		return 0;
+
+	if (any_first(buf, '{'))
+		return 0;
+
+	if (check_end(buf, res, '}'))
+		return 0;
+
+	return obj_next_filter(buf, res, obj, ign);
+}
+
+int ujson_obj_first(ujson_reader *buf, struct ujson_val *res)
+{
+	if (check_err(buf, res))
+		return 0;
+
+	if (any_first(buf, '{'))
+		return 0;
+
+	if (check_end(buf, res, '}'))
+		return 0;
+
+	return obj_next(buf, res);
+}
+
+static int arr_next(ujson_reader *buf, struct ujson_val *res)
+{
+	return get_value(buf, res);
+}
+
+int ujson_arr_first(ujson_reader *buf, struct ujson_val *res)
+{
+	if (check_err(buf, res))
+		return 0;
+
+	if (any_first(buf, '['))
+		return 0;
+
+	if (check_end(buf, res, ']'))
+		return 0;
+
+	return arr_next(buf, res);
+}
+
+int ujson_arr_next(ujson_reader *buf, struct ujson_val *res)
+{
+	if (check_err(buf, res))
+		return 0;
+
+	if (check_end(buf, res, ']'))
+		return 0;
+
+	if (pre_next(buf, res))
+		return 0;
+
+	return arr_next(buf, res);
+}
+
+static void ujson_err_va(ujson_reader *buf, const char *fmt, va_list va)
+{
+	vsnprintf(buf->err, UJSON_ERR_MAX, fmt, va);
+}
+
+void ujson_err(ujson_reader *buf, const char *fmt, ...)
+{
+	va_list va;
+
+	va_start(va, fmt);
+	ujson_err_va(buf, fmt, va);
+	va_end(va);
+}
+
+static void vprintf_line(ujson_reader *buf, const char *fmt, va_list va)
+{
+	char line[UJSON_ERR_MAX+1];
+
+	vsnprintf(line, sizeof(line), fmt, va);
+
+	line[UJSON_ERR_MAX] = 0;
+
+	buf->err_print(buf->err_print_priv, line);
+}
+
+static void printf_line(ujson_reader *buf, const char *fmt, ...)
+{
+	va_list va;
+
+	va_start(va, fmt);
+	vprintf_line(buf, fmt, va);
+	va_end(va);
+}
+
+static void printf_json_line(ujson_reader *buf, size_t line_nr, const char *buf_pos)
+{
+	char line[UJSON_ERR_MAX+1];
+	size_t plen, i;
+
+	plen = sprintf(line, "%03zu: ", line_nr);
+
+	for (i = 0; i < UJSON_ERR_MAX-plen && buf_pos[i] && buf_pos[i] != '\n'; i++)
+		line[i+plen] = buf_pos[i];
+
+	line[i+plen] = 0;
+
+	buf->err_print(buf->err_print_priv, line);
+}
+
+static void print_arrow(ujson_reader *buf, const char *buf_pos, size_t count)
+{
+	char line[count + 7];
+	size_t i;
+
+	/* The '000: ' prefix */
+	for (i = 0; i <= 5; i++)
+		line[i] = ' ';
+
+	for (i = 0; i < count; i++)
+		line[i+5] = buf_pos[i] == '\t' ? '\t' : ' ';
+
+	line[count+5] = '^';
+	line[count+6] = 0;
+
+	buf->err_print(buf->err_print_priv, line);
+}
+
+#define ERR_LINES 10
+
+#define MIN(A, B) ((A < B) ? (A) : (B))
+
+static void print_snippet(ujson_reader *buf, const char *type)
+{
+	ssize_t i;
+	const char *lines[ERR_LINES] = {};
+	size_t cur_line = 0;
+	size_t cur_off = 0;
+	size_t last_off = buf->off;
+
+	for (;;) {
+		lines[(cur_line++) % ERR_LINES] = buf->json + cur_off;
+
+		while (cur_off < buf->len && buf->json[cur_off] != '\n')
+			cur_off++;
+
+		if (cur_off >= buf->off)
+			break;
+
+		cur_off++;
+		last_off = buf->off - cur_off;
+	}
+
+	printf_line(buf, "%s at line %03zu", type, cur_line);
+	buf->err_print(buf->err_print_priv, "");
+
+	size_t idx = 0;
+
+	for (i = MIN(ERR_LINES, cur_line); i > 0; i--) {
+		idx = (cur_line - i) % ERR_LINES;
+		printf_json_line(buf, cur_line - i + 1, lines[idx]);
+	}
+
+	print_arrow(buf, lines[idx], last_off);
+}
+
+void ujson_err_print(ujson_reader *buf)
+{
+	if (!buf->err_print)
+		return;
+
+	print_snippet(buf, "Parse error");
+	buf->err_print(buf->err_print_priv, buf->err);
+}
+
+void ujson_warn(ujson_reader *buf, const char *fmt, ...)
+{
+	va_list va;
+
+	if (buf->flags & UJSON_READER_STRICT) {
+		va_start(va, fmt);
+		ujson_err_va(buf, fmt, va);
+		va_end(va);
+		return;
+	}
+
+	if (!buf->err_print)
+		return;
+
+	print_snippet(buf, "Warning");
+
+	va_start(va, fmt);
+	vprintf_line(buf, fmt, va);
+	va_end(va);
+}
+
+void ujson_print(void *err_print_priv, const char *line)
+{
+	fputs(line, err_print_priv);
+	putc('\n', err_print_priv);
+}
+
+ujson_reader *ujson_reader_load(const char *path)
+{
+	int fd = open(path, O_RDONLY);
+	ujson_reader *ret;
+	ssize_t res;
+	off_t len, off = 0;
+
+	if (fd < 0)
+		return NULL;
+
+	len = lseek(fd, 0, SEEK_END);
+	if (len == (off_t)-1) {
+		fprintf(stderr, "lseek() failed\n");
+		goto err0;
+	}
+
+	if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
+		fprintf(stderr, "lseek() failed\n");
+		goto err0;
+	}
+
+	ret = malloc(sizeof(ujson_reader) + len + 1);
+	if (!ret) {
+		fprintf(stderr, "malloc() failed\n");
+		goto err0;
+	}
+
+	memset(ret, 0, sizeof(*ret));
+
+	ret->buf[len] = 0;
+	ret->len = len;
+	ret->max_depth = UJSON_RECURSION_MAX;
+	ret->json = ret->buf;
+	ret->err_print = UJSON_ERR_PRINT;
+	ret->err_print_priv = UJSON_ERR_PRINT_PRIV;
+
+	while (off < len) {
+		res = read(fd, ret->buf + off, len - off);
+		if (res < 0) {
+			fprintf(stderr, "read() failed\n");
+			goto err1;
+		}
+
+		off += res;
+	}
+
+	close(fd);
+
+	return ret;
+err1:
+	free(ret);
+err0:
+	close(fd);
+	return NULL;
+}
+
+void ujson_reader_finish(ujson_reader *self)
+{
+	if (ujson_reader_err(self))
+		ujson_err_print(self);
+	else if (!ujson_reader_consumed(self)) {
+		ujson_warn(self, "Garbage after JSON string!");
+
+		if (ujson_reader_err(self))
+			ujson_err_print(self);
+	}
+}
+
+void ujson_reader_free(ujson_reader *buf)
+{
+	free(buf);
+}
+
+ujson_val *ujson_val_alloc(size_t buf_size)
+{
+	buf_size = buf_size == 0 ? 4096 : buf_size;
+	ujson_val *ret;
+
+	ret = malloc(sizeof(ujson_val) + buf_size);
+	if (!ret)
+		return NULL;
+
+	memset(ret, 0, sizeof(ujson_val) + buf_size);
+
+	ret->buf = ret->buf__;
+	ret->buf_size = buf_size;
+
+	return ret;
+}
+
+void ujson_val_free(ujson_val *self)
+{
+	free(self);
+}
diff --git a/libs/ujson/ujson_utf.c b/libs/ujson/ujson_utf.c
new file mode 100644
index 000000000..2c08a39a8
--- /dev/null
+++ b/libs/ujson/ujson_utf.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2022-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+#include <stddef.h>
+#include <ujson_utf.h>
+
+int8_t ujson_utf8_next_chsz(const char *str, size_t off)
+{
+	char ch = str[off];
+	uint8_t len = 0;
+
+	if (!ch)
+		return 0;
+
+	if (UJSON_UTF8_IS_ASCII(ch))
+		return 1;
+
+	if (UJSON_UTF8_IS_2BYTE(ch)) {
+		len = 2;
+		goto ret;
+	}
+
+	if (UJSON_UTF8_IS_3BYTE(ch)) {
+		len = 3;
+		goto ret;
+	}
+
+	if (UJSON_UTF8_IS_4BYTE(ch)) {
+		len = 4;
+		goto ret;
+	}
+
+	return -1;
+ret:
+	if (!UJSON_UTF8_IS_NBYTE(str[off+1]))
+		return -1;
+
+	if (len > 2 && !UJSON_UTF8_IS_NBYTE(str[off+2]))
+		return -1;
+
+	if (len > 3 && !UJSON_UTF8_IS_NBYTE(str[off+3]))
+		return -1;
+
+	return len;
+}
+
+int8_t ujson_utf8_prev_chsz(const char *str, size_t off)
+{
+	char ch;
+
+	if (!off)
+		return 0;
+
+	ch = str[--off];
+
+	if (UJSON_UTF8_IS_ASCII(ch))
+		return 1;
+
+	if (!UJSON_UTF8_IS_NBYTE(ch))
+		return -1;
+
+	if (off < 1)
+		return -1;
+
+	ch = str[--off];
+
+	if (UJSON_UTF8_IS_2BYTE(ch))
+		return 2;
+
+	if (!UJSON_UTF8_IS_NBYTE(ch))
+		return -1;
+
+	if (off < 1)
+		return -1;
+
+	ch = str[--off];
+
+	if (UJSON_UTF8_IS_3BYTE(ch))
+		return 3;
+
+	if (!UJSON_UTF8_IS_NBYTE(ch))
+		return -1;
+
+	if (off < 1)
+		return -1;
+
+	ch = str[--off];
+
+	if (UJSON_UTF8_IS_4BYTE(ch))
+		return 4;
+
+	return -1;
+}
+
+size_t ujson_utf8_strlen(const char *str)
+{
+	size_t cnt = 0;
+
+	while (ujson_utf8_next(&str))
+		cnt++;
+
+	return cnt;
+}
diff --git a/libs/ujson/ujson_writer.c b/libs/ujson/ujson_writer.c
new file mode 100644
index 000000000..c86a3b2af
--- /dev/null
+++ b/libs/ujson/ujson_writer.c
@@ -0,0 +1,489 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2021-2024 Cyril Hrubis <metan@ucw.cz>
+ */
+
+#include <string.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include "ujson_utf.h"
+#include "ujson_writer.h"
+
+static inline int get_depth_bit(ujson_writer *self, char *mask)
+{
+	int depth = self->depth - 1;
+
+	if (depth < 0)
+		return -1;
+
+	return !!(mask[depth/8] & (1<<(depth%8)));
+}
+
+static inline void set_depth_bit(ujson_writer *self, int val)
+{
+	if (val)
+		self->depth_type[self->depth/8] |= (1<<(self->depth%8));
+	else
+		self->depth_type[self->depth/8] &= ~(1<<(self->depth%8));
+
+	self->depth_first[self->depth/8] |= (1<<(self->depth%8));
+
+	self->depth++;
+}
+
+static inline void clear_depth_bit(ujson_writer *self)
+{
+	self->depth--;
+}
+
+static inline int in_arr(ujson_writer *self)
+{
+	return !get_depth_bit(self, self->depth_type);
+}
+
+static inline int in_obj(ujson_writer *self)
+{
+	return get_depth_bit(self, self->depth_type);
+}
+
+static inline void clear_depth_first(ujson_writer *self)
+{
+	int depth = self->depth - 1;
+
+	self->depth_first[depth/8] &= ~(1<<(depth%8));
+}
+
+static inline int is_first(ujson_writer *self)
+{
+	int ret = get_depth_bit(self, self->depth_first);
+
+	if (ret == 1)
+		clear_depth_first(self);
+
+	return ret;
+}
+
+static inline void err(ujson_writer *buf, const char *fmt, ...)
+{
+	va_list va;
+
+	va_start(va, fmt);
+	vsnprintf(buf->err, UJSON_ERR_MAX, fmt, va);
+	va_end(va);
+}
+
+static inline int is_err(ujson_writer *buf)
+{
+	return buf->err[0];
+}
+
+static inline int out(ujson_writer *self, const char *buf, size_t len)
+{
+	return self->out(self, buf, len);
+}
+
+static inline int out_str(ujson_writer *self, const char *str)
+{
+	return out(self, str, strlen(str));
+}
+
+static inline int out_ch(ujson_writer *self, char ch)
+{
+	return out(self, &ch, 1);
+}
+
+#define ESC_FLUSH(esc_char) do {\
+	out(self, val, i); \
+	val += i + 1; \
+	i = 0; \
+	out_str(self, esc_char); \
+} while (0)
+
+static inline int out_esc_str(ujson_writer *self, const char *val)
+{
+	if (out_ch(self, '"'))
+		return 1;
+
+	size_t i = 0;
+	int8_t next_chsz;
+
+	do {
+		next_chsz = ujson_utf8_next_chsz(val, i);
+
+		if (next_chsz == 1) {
+			switch (val[i]) {
+			case '\"':
+				ESC_FLUSH("\\\"");
+			break;
+			case '\\':
+				ESC_FLUSH("\\\\");
+			break;
+			case '/':
+				ESC_FLUSH("\\/");
+			break;
+			case '\b':
+				ESC_FLUSH("\\b");
+			break;
+			case '\f':
+				ESC_FLUSH("\\f");
+			break;
+			case '\n':
+				ESC_FLUSH("\\n");
+			break;
+			case '\r':
+				ESC_FLUSH("\\r");
+			break;
+			case '\t':
+				ESC_FLUSH("\\t");
+			break;
+			default:
+				i += next_chsz;
+			}
+		} else {
+			i += next_chsz;
+		}
+	} while (next_chsz);
+
+	if (i) {
+		if (out(self, val, i))
+			return 1;
+	}
+
+	if (out_ch(self, '"'))
+		return 1;
+
+	return 0;
+}
+
+static int do_padd(ujson_writer *self)
+{
+	unsigned int i;
+
+	for (i = 0; i < self->depth; i++) {
+		if (out_ch(self, ' '))
+			return 1;
+	}
+
+	return 0;
+}
+
+static int newline(ujson_writer *self)
+{
+	if (out_ch(self, '\n'))
+		return 0;
+
+	if (do_padd(self))
+		return 1;
+
+	return 0;
+}
+
+static int add_common(ujson_writer *self, const char *id)
+{
+	if (is_err(self))
+		return 1;
+
+	if (!self->depth) {
+		err(self, "Object/Array has to be started first");
+		return 1;
+	}
+
+	if (in_arr(self)) {
+		if (id) {
+			err(self, "Array entries can't have id");
+			return 1;
+		}
+	} else {
+		if (!id) {
+			err(self, "Object entries must have id");
+			return 1;
+		}
+	}
+
+	if (!is_first(self) && out_ch(self, ','))
+		return 1;
+
+	if (self->depth && newline(self))
+		return 1;
+
+	if (id) {
+		if (out_esc_str(self, id))
+			return 1;
+
+		if (out_str(self, ": "))
+			return 1;
+	}
+
+	return 0;
+}
+
+int ujson_obj_start(ujson_writer *self, const char *id)
+{
+	if (self->depth >= UJSON_RECURSION_MAX)
+		return 1;
+
+	if (!self->depth && id) {
+		err(self, "Top level object cannot have id");
+		return 1;
+	}
+
+	if (self->depth && add_common(self, id))
+		return 1;
+
+	if (out_ch(self, '{'))
+		return 1;
+
+	set_depth_bit(self, 1);
+
+	return 0;
+}
+
+int ujson_obj_finish(ujson_writer *self)
+{
+	if (is_err(self))
+		return 1;
+
+	if (!in_obj(self)) {
+		err(self, "Not in object!");
+		return 1;
+	}
+
+	int first = is_first(self);
+
+	clear_depth_bit(self);
+
+	if (!first)
+		newline(self);
+
+	return out_ch(self, '}');
+}
+
+int ujson_arr_start(ujson_writer *self, const char *id)
+{
+	if (self->depth >= UJSON_RECURSION_MAX) {
+		err(self, "Recursion too deep");
+		return 1;
+	}
+
+	if (!self->depth && id) {
+		err(self, "Top level array cannot have id");
+		return 1;
+	}
+
+	if (self->depth && add_common(self, id))
+		return 1;
+
+	if (out_ch(self, '['))
+		return 1;
+
+	set_depth_bit(self, 0);
+
+	return 0;
+}
+
+int ujson_arr_finish(ujson_writer *self)
+{
+	if (is_err(self))
+		return 1;
+
+	if (!in_arr(self)) {
+		err(self, "Not in array!");
+		return 1;
+	}
+
+	int first = is_first(self);
+
+	clear_depth_bit(self);
+
+	if (!first)
+		newline(self);
+
+	return out_ch(self, ']');
+}
+
+int ujson_null_add(ujson_writer *self, const char *id)
+{
+	if (add_common(self, id))
+		return 1;
+
+	return out_str(self, "null");
+}
+
+int ujson_int_add(ujson_writer *self, const char *id, long val)
+{
+	char buf[64];
+
+	if (add_common(self, id))
+		return 1;
+
+	snprintf(buf, sizeof(buf), "%li", val);
+
+	return out_str(self, buf);
+}
+
+int ujson_bool_add(ujson_writer *self, const char *id, int val)
+{
+	if (add_common(self, id))
+		return 1;
+
+	if (val)
+		return out_str(self, "true");
+	else
+		return out_str(self, "false");
+}
+
+int ujson_str_add(ujson_writer *self, const char *id, const char *val)
+{
+	if (add_common(self, id))
+		return 1;
+
+	if (out_esc_str(self, val))
+		return 1;
+
+	return 0;
+}
+
+int ujson_float_add(ujson_writer *self, const char *id, double val)
+{
+	char buf[64];
+
+	if (add_common(self, id))
+		return 1;
+
+	snprintf(buf, sizeof(buf), "%lg", val);
+
+	return out_str(self, buf);
+}
+
+int ujson_writer_finish(ujson_writer *self)
+{
+	if (is_err(self))
+		goto err;
+
+	if (self->depth) {
+		err(self, "Objects and/or Arrays not finished");
+		goto err;
+	}
+
+	if (newline(self))
+		return 1;
+
+	return 0;
+err:
+	if (self->err_print)
+		self->err_print(self->err_print_priv, self->err);
+
+	return 1;
+}
+
+struct json_writer_file {
+	int fd;
+	size_t buf_used;
+	char buf[1024];
+};
+
+static int out_writer_file_write(ujson_writer *self, int fd, const char *buf, ssize_t buf_len)
+{
+	do {
+		ssize_t ret = write(fd, buf, buf_len);
+		if (ret <= 0) {
+			err(self, "Failed to write to a file");
+			return 1;
+		}
+
+		if (ret > buf_len) {
+			err(self, "Wrote more bytes than requested?!");
+			return 1;
+		}
+
+		buf_len -= ret;
+	} while (buf_len);
+
+	return 0;
+}
+
+static int out_writer_file(ujson_writer *self, const char *buf, size_t buf_len)
+{
+	struct json_writer_file *writer_file = self->out_priv;
+	size_t buf_size = sizeof(writer_file->buf);
+	size_t buf_avail = buf_size - writer_file->buf_used;
+
+	if (buf_len > buf_size/4)
+		return out_writer_file_write(self, writer_file->fd, buf, buf_len);
+
+	if (buf_len >= buf_avail) {
+		if (out_writer_file_write(self, writer_file->fd,
+		                          writer_file->buf, writer_file->buf_used))
+			return 1;
+
+		memcpy(writer_file->buf, buf, buf_len);
+		writer_file->buf_used = buf_len;
+		return 0;
+	}
+
+	memcpy(writer_file->buf + writer_file->buf_used, buf, buf_len);
+	writer_file->buf_used += buf_len;
+
+	return 0;
+}
+
+int ujson_writer_file_close(ujson_writer *self)
+{
+	struct json_writer_file *writer_file = self->out_priv;
+	int saved_errno = 0;
+
+	if (writer_file->buf_used) {
+		if (out_writer_file_write(self, writer_file->fd,
+		                          writer_file->buf, writer_file->buf_used))
+
+			saved_errno = errno;
+	}
+
+	if (close(writer_file->fd)) {
+		if (!saved_errno)
+			saved_errno = errno;
+	}
+
+	free(self);
+
+	if (saved_errno) {
+		errno = saved_errno;
+		return 1;
+	}
+
+	return 0;
+}
+
+ujson_writer *ujson_writer_file_open(const char *path)
+{
+	ujson_writer *ret;
+	struct json_writer_file *writer_file;
+
+	ret = malloc(sizeof(ujson_writer) + sizeof(struct json_writer_file));
+	if (!ret)
+		return NULL;
+
+	writer_file = (void*)ret + sizeof(ujson_writer);
+
+	writer_file->fd = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0664);
+	if (!writer_file->fd) {
+		free(ret);
+		return NULL;
+	}
+
+	writer_file->buf_used = 0;
+
+	memset(ret, 0, sizeof(*ret));
+
+	ret->err_print = UJSON_ERR_PRINT;
+	ret->err_print_priv = UJSON_ERR_PRINT_PRIV;
+	ret->out = out_writer_file;
+	ret->out_priv = writer_file;
+
+	return ret;
+}
diff --git a/libs/libltpvdso/Makefile b/libs/vdso/Makefile
similarity index 100%
rename from libs/libltpvdso/Makefile
rename to libs/vdso/Makefile
diff --git a/libs/libltpvdso/README b/libs/vdso/README
similarity index 100%
rename from libs/libltpvdso/README
rename to libs/vdso/README
diff --git a/libs/libltpvdso/parse_vdso.c b/libs/vdso/parse_vdso.c
similarity index 100%
rename from libs/libltpvdso/parse_vdso.c
rename to libs/vdso/parse_vdso.c
diff --git a/libs/libltpvdso/vdso_helpers.c b/libs/vdso/vdso_helpers.c
similarity index 100%
rename from libs/libltpvdso/vdso_helpers.c
rename to libs/vdso/vdso_helpers.c
diff --git a/ltpmenu b/ltpmenu
deleted file mode 100755
index 38d38c0cd..000000000
--- a/ltpmenu
+++ /dev/null
@@ -1,548 +0,0 @@
-#!/bin/bash
-################################################################################
-##                                                                            ##
-## Copyright (c) International Business Machines  Corp., 2001                 ##
-##                                                                            ##
-## This program is free software;  you can redistribute it and#or modify      ##
-## it under the terms of the GNU General Public License as published by       ##
-## the Free Software Foundation; either version 2 of the License, or          ##
-## (at your option) any later version.                                        ##
-##                                                                            ##
-## This program is distributed in the hope that it will be useful, but        ##
-## WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY ##
-## or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   ##
-## for more details.                                                          ##
-##                                                                            ##
-## You should have received a copy of the GNU General Public License          ##
-## along with this program;  if not, write to the Free Software               ##
-## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA    ##
-##                                                                            ##
-################################################################################
-#
-# File:        runltp
-#
-# Description: This program is a Graphical User Interface (GUI)
-#              Control Centre for LTP. The Control Centre provides
-#              functionality to Compile, Execute and View Results of
-#              LTP test cases.
-#
-# Author:      Manoj Iyer - manjo@mail.utexas.edu
-#
-# Thanks:      Jim Choate - For suggesting the use of dialog command.
-#
-# History:     March 26 2003 - Created.
-#
-#	       March 28 2003 - Removed gauges and put make commands in foreground.
-#	                     Robbie Williamson - robbiew@us.ibm.com
-#
-#	       March 31 2003 - Made scenario menu creation dynamic and code
-#                              to pull the test descriptions from the scenario files.
-#                            Robbie Williamson - robbiew@us.ibm.com
-#
-#	       April 17 2003 - Added menu selection to list contents of selected
-#			       scenario file.
-#			     Robbie Williamson - robbiew@us.ibm.com
-#
-#	       April 23 2003 - Added PID to results filename.
-#			     - Added code to allow users to redirect output and
-#                              specify test execution duration.
-#			     Robbie Williamson - robbiew@us.ibm.com
-#
-#	       April 30, 2003 - Recoded results display to allow selection
-#				of results file.
-#			      - Created variable to hold results filename
-#		 	      - Added time to results filename.
-# Function:    cleanup
-#
-# Description: Remove all temporary files created by this program. Cleanup
-#              always called on program exit.
-#
-# Input:       NONE
-#
-# Output:      NONE
-cleanup()
-{
-    rm -f /tmp/runltp.*
-}
-
-
-# Function:    display_info_msg
-#
-# Description: Displays informational messages window. This window may
-#              may be used to display information like errors, instructions
-#              etc to the user. The window is dismissed when the user hits
-#              the [ENTER] key.
-#
-# Input:       $1 - Title the needs to be displayed on the window.
-#                   eg: ERROR: Compiling LTP
-#              $2 - Message text.
-#
-# Output:      Information message window.
-display_info_msg()
-{
-    dialog --backtitle "Linux Test Project Control Centre" \
-           --title " $1 " \
-           --msgbox " $2 " 10 70
-    return $?
-}
-
-
-# Function:    compile_ltp
-#
-# Description: Checks for commands that are pre-reqs for compiling and
-#              installing LTP. It displays a confirmation window inorder to
-#              confirm the choice made by the user.
-#
-# Calls:       do_make_clean()
-#              do_make()
-#              do_make_install()
-#
-# Input:       NONE
-#
-# Output:      Confirmation window.
-compile_ltp()
-{
-    dialog --backtitle "Linux Test Project Control Centre" \
-           --title "Compiling LTP testsuite"\
-           --yesno "This will compile all the test cases in\
-                    LTP test suite and place the executables\
-                    in testcases/bin directory. Do\
-                    you wish to continue ??" 7 70 || RC=$?
-    case $RC in
-        0) \
-            for cmd in cc make lex ;
-            do \
-                which $cmd >/tmp/runltp.err.$$ 2>&1 ;
-                if [ $? -ne 0 ] ;
-                    then \
-                        display_info_msg "Compiling LTP testsuite" \
-                                 "ERROR: command $cmd not found, $cmd is\
-                                  required to compile LTP test cases. Please\
-                                  install $cmd or export PATH correctly before\
-                                  running this program" ;
-                    return ;
-                fi ;
-            done ;
-            make clean;
-	    if [ $? -ne 0 ];then
-              echo "ERROR in \'make clean\' - exiting."
-	      exit
-	    fi
-            make ;
-	    if [ $? -ne 0 ];then
-              echo "ERROR in \'make all\' - exiting."
-	      exit
-	    fi
-            make install ;
-	    if [ $? -ne 0 ];then
-              echo "ERROR in \'make install\' - exiting."
-	      exit
-	    fi
-            return ;;
-
-        1)  return ;;
-
-        255) return ;;
-    esac
-}
-
-
-# Function:    disp_ltpres
-#
-# Description: The results generated after the ltp execution located under
-#              ltp-mmddyy/results/ directory in a text (ASCII) file called
-#              results.todaysdate. This function displays this file in a
-#              window. If the results file does not exit it displays an
-#              info message window notifing the user that LTP test cases
-#              need to be executed inorder to view results.
-#
-# Input:       ltp-mmddyy/results/results.todaysdate.time
-#
-# Output:      Window displaying results of testcases that were executed.
-disp_ltpres()
-{
-    RC=0
-
-    RESULTS_LIST=$(for i in `ls -1 -A -I "CVS" results`;do echo -n "$i [more...] "; done)
-    if ! [ -z $RESULTS_LIST ] ;then
-      while [ $RC -ne "1" ]
-      do
-        dialog --clear
-        dialog --backtitle "Linux Test Project Control Centre" \
-               --title "LTP Test Results" \
-               --menu "Move using[UP] [DOWN], Select using [ENTER]" 15 70 8 \
-                      $RESULTS_LIST \
-                      2>/tmp/runltp.results.$$ || RC=$?
-        results_item=$(cat /tmp/runltp.results.$$)
-        if ! [ -z $results_item ];then
-          dialog --clear
-          dialog --backtitle "Linux Test Project Control Centre" \
-                 --title "LTP Test Results" \
-                 --textbox results/$results_item 17 70
-
-          dialog --backtitle "Linux Test Project Control Centre" \
-                 --title "LTP Test Results." \
-                 --yesno "Would you like to share these results with the LTP \
-                          community by posting it to the LTP results mailing list?" \
-                          7 70 || RESPONSE=$?
-          case $RESPONSE in
-              0) \
-                  mail ltp-results@lists.sourceforge.net < \
-                          ./results/$results_item ;
-                  ;;
-
-              1)  ;;
-
-              255)  ;;
-          esac
-        fi
-      done
-    else
-      dialog --clear
-      dialog --backtitle "Linux Test Project Control Centre" \
-             --title "LTP Test Results" \
-             --msgbox "ERROR: No files to view in /results directory." 5 53
-    fi
-    return
-}
-
-
-# Function:    flags_prompt
-#
-# Description: Prompt for and record user options for run duration and
-#	       test output direction
-#
-# Input:       none
-#
-# Output:      none
-flags_prompt()
-{
-    dialog --backtitle "Linux Test Project Control Centre"\
-           --title "Output Direction" --clear\
-	   --yesno "Would you like test output recorded to a file, instead of STDOUT?" 7 80
-    RC=$?
-    if [ $RC -eq "0" ]
-    then
-	dialog --backtitle "Linux Test Project Control Centre"\
-               --title "Output Direction" --clear\
-               --inputbox " Please enter the full path and \
-                            name of the file where you wish \
-                            to redirect output to" 17 80 \
-                          2>/tmp/runltp.outdir.$$ ;
-        flags_outfile=$(cat /tmp/runltp.outdir.$$ | awk '{print $1}')
-        ./ver_linux > $flags_outfile 2>&1
-	RUNALL_FLAGS=" -o $flags_outfile"
-    fi
-
-    dialog --backtitle "Linux Test Project Control Centre"\
-           --title "Test Duration" --clear\
-	   --yesno "Would you like to specify test duration? \
-                    Default is the length of one loop." 7 80
-    RC=$?
-    if [ $RC -eq "0" ]
-    then
-	dialog --backtitle "Linux Test Project Control Centre"\
-	       --title "Test Duration - Interval Selection" --clear\
-               --menu "Move using[UP] [DOWN], Select using [ENTER]" 15 70 4 \
-                       s    "Seconds" \
-                       m    "Minutes" \
-                       h    "Hours" \
-                       d    "Days" \
-                  2>/tmp/runltp.interval.$$ ;
-	flags_interval=$(cat /tmp/runltp.interval.$$ | awk '{print $1}')
-	case $flags_interval in
-                s)	INTERVAL="seconds" ;;
-                m)      INTERVAL="minutes" ;;
-                h)      INTERVAL="hours"   ;;
-                d)      INTERVAL="days"    ;;
-        esac
-
-	echo $INTERVAL
-	WINDOW_MSG="Please enter the number of $INTERVAL to run"
-	dialog --backtitle "Linux Test Project Control Centre"\
-               --title "Test Duration - Length Specification" --clear\
-               --inputbox "$WINDOW_MSG" 7 80 \
-		          2>/tmp/runltp.length.$$ ;
-	flags_length=$(cat /tmp/runltp.length.$$ | awk '{print $1}')
-        flags_duration="$flags_length$flags_interval"
-	RUNALL_FLAGS=" $RUNALL_FLAGS -t $flags_duration"
-    fi
-}
-
-# Function:    exectest_screenout
-#
-# Description: Execute tests by calling runltp, display test status
-#              in a window.
-#
-# Input:       none
-#
-# Output:      messages printed by testcases.
-exectest_screenout()
-{
-    RC=0    # setting return code to 0, to loop in while
-
-    RESULTS_FILE=$(date +%Y-%m-%d.%H.%M.%S).$$
-
-    # execute runltp with user defined command file.
-    ./runltp -q -p $RUNALL_FLAGS -l results.$RESULTS_FILE \
-	-f /tmp/runltp.test.list.$$
-
-    sleep 2
-
-    return
-}
-
-
-# Function:    execute_ltp
-#
-# Description: This function provides a menu of testcases that can be
-#              selected for execution. If networking tests are selected,
-#              they require a remote machine and remote machines root
-#              users password. The user will be prompted to enter this
-#              information in a text box.
-#              The function checks to see if the ltp-mmddyy/testcases/bin
-#              directory was created, this directory is created when the
-#              testcases are compiled and installed, if it is not found
-#              an info message window will notify the user that LTP needs to
-#              be compiled before tests can be executed.
-#              This function creates the senatrio file based on the users
-#              choice of testcases and uses the runltp script to
-#              execute these tests.
-#              The messages printed by the testcases are displayed on this
-#              terminal.
-#
-# Input:       Users selection of testcases; scenario file.
-#
-# Output:      Test selection window, Message window,
-#              information message window
-execute_ltp()
-{
-    RC=0
-    host_name=" "
-    rhost_passwd=" "
-    run_net_test=" "
-
-    if ! [ -d ./testcases/bin ]
-    then
-	display_info_msg "Executing LTP testcases" \
-	    "The testcases must to be compiled inorder\
-       to execute them. Returning to main menu. \
-       Please select the Compile option."
-	return
-    fi
-
-    LIST=$(for i in `ls -1 -A -I "CVS" runtest`; do echo -n "$i "; j=$(head -n1 runtest/$i | cut -d: -f2|sed s/" "/_/g); echo -n "$j off "; done)
-    dialog --backtitle "Linux Test Project Control Centre"\
-           --title "Execute LTP" --clear\
-           --checklist "Select [SPACEBAR] tests to run" 20 80 5 \
-    	    $LIST \
-            2>/tmp/runltp.choice.$$ || RC=$?
-    size=`wc -m /tmp/runltp.choice.$$|awk '{print $1}'`
-    if [ $size -eq 0 ];then
-      tst_choice=$(echo "NULL")
-    else
-      tst_choice=$(cat /tmp/runltp.choice.$$)
-    fi
-    if [[ $tst_choice == NULL ]];then
-      RC=1
-    fi
-    case $RC in
-        0)    \
-            for i in $tst_choice ;
-            do \
-                cat ./runtest/$(echo $i | sed -e 's/"//g') \
-                   >> /tmp/runltp.test.list.$$ ;
-                if [[ $(echo $i | sed -e 's/"//g') == "tcp_cmds" || \
-		      $(echo $i | sed -e 's/"//g') == "tcp_cmds_noexpect" || \
-                      $(echo $i | sed -e 's/"//g') == "multicast" || \
-                      $(echo $i | sed -e 's/"//g') == "ipv6" || \
-                      $(echo $i | sed -e 's/"//g') == "ipv6_noexpect" || \
-                      $(echo $i | sed -e 's/"//g') == "nfs" || \
-                      $(echo $i | sed -e 's/"//g') == "multicast" ]] ;
-                then \
-                    run_net_test="Y" ;
-                fi ;
-
-            done ;
-            if ! [ -z $run_net_test ] ;
-            then \
-                dialog --backtitle "Linux Test Project Control Centre"\
-                       --title "Execute LTP test cases" \
-                       --clear \
-                       --inputbox "You have chosen to execute testcases \
-                                  that require a Remote Machine. \
-                                  Please enter the fully qualified host \
-                                  name" 17 80 $(hostname --long) \
-                                  2>/tmp/runltp.out.$$ ;
-                host_name=$(cat /tmp/runltp.out.$$ | awk '{print $1}') ;
-                unset $RHOST ;
-                RHOST=$host_name ;
-                export RHOST;
-
-                dialog --backtitle "Linux Test Project Control Centre"\
-                       --title "Execute LTP test cases" \
-                       --clear \
-                       --inputbox " Please enter the root password \
-                                     of this remote machine" 17 80 \
-                        2>/tmp/runltp.out.$$ ;
-                rhost_passwd=$(cat /tmp/runltp.out.$$ | awk '{print $1}') ;
-
-                PASSWD=$rhost_passwd ;
-                export PASSWD;
-            fi ;
-
-            if ! [ -d ./testcases/bin ] ;
-            then \
-                display_info_msg "Executing LTP testcases" \
-                    "The testcases must to be compiled inorder\
-                     to execute them. Returning to main menu. \
-                     Please select the Compile option." ;
-                return ;
-            fi ;
-
-            dialog --clear ;
-
-	    flags_prompt ;
-
-            exectest_screenout ;
-
-            return ;;
-        1)    \
-            # echo "Cancel pressed" ;
-            return ;;
-        255)    \
-            # echo "ESC pressed" ;
-            return ;;
-    esac
-}
-
-
-# Function:    about_ltpcc
-#
-# Description: This function displays a window containing a brief message
-#              describing this programs functionality, and credits the author.
-#
-# Input:       NONE
-#
-# Output:      Message window, description of LTP Control Center.
-about_ltpcc()
-{
-    display_info_msg "About LTP Control Centre" \
-                     "The LTP Control Centre can be used to\
-                     to compile, install and execute\
-                     The Linux Test Project test suite. Written by\
-                     Manoj Iyer <manjo@mail.utexas.edu>"
-    return
-}
-
-
-# Function:    ltp_scenarios
-#
-# Description: This function displays a list of scenario files located
-#              in /runtest.  Users can list the contents of each file.
-#
-# Input:       Files from /runtest
-#
-# Output:      1) Menu selection containing each file as an option to list.
-#              2) Contents of selected scenario.
-ltp_scenarios()
-{
-
-RC=0
-SCENARIOS=$(for i in `ls -1 -A -I "CVS" runtest`;do echo -n "$i [more...] "; done)
-
-while [ $RC -ne "1" ]
-do
-  dialog --clear
-  dialog --backtitle "Linux Test Project Control Centre" \
-         --title "LTP Scenario Files" \
-         --menu "Move using[UP] [DOWN], Select using [ENTER]" 15 70 8 \
-                $SCENARIOS \
-                2>/tmp/runltp.scenario.$$ || RC=$?
-  scenario_item=$(cat /tmp/runltp.scenario.$$)
-  if ! [ -z $scenario_item ];then
-    dialog --clear
-    dialog --backtitle "Linux Test Project Control Centre" \
-           --title "LTP Scenario Files" \
-           --textbox runtest/$scenario_item 17 70
-  fi
-done
-}
-
-
-
-# Function:    main
-#
-# Description: Displays the main menu to the LTP Control Centre. The menu
-#              provides options to Compile, Execute, and View test execution
-#              results.
-#
-# Calls:       about_ltpcc()
-#              compile_ltp()
-#              execute_ltp()
-#              disp_ltpres()
-#
-# Input:       NONE
-#
-# Output:      Menu selection of actions to perform.
-
-# Global variables.
-RC=0              # return code from commands and local functions
-mmenu_item=" "
-RHOST=" "
-PASSWD=" "
-RUNALL_FLAGS=" "
-RESULTS_FILE=" "
-
-# test for dialog program exist
-if [ ! -x /usr/bin/dialog ]; then
-       echo "Sorry, ltpmenu GUI not available, can't find dialog. Exiting...";
-       exit 1;
-fi
-
-# call cleanup function on program exit.
-trap "cleanup" 0
-
-
-# wait in a loop until user hits [Cancel] button on the main menu.
-while :
-do
-    RC=0
-    dialog --clear
-    dialog --backtitle "Linux Test Project Control Centre" \
-           --title "Main Menu" \
-           --menu "Move using[UP] [DOWN], Select using [ENTER]" 15 70 5 \
-                  About        "About LTP Control Centre" \
-                  Compile      "Compile LTP testsuite" \
-		  Details      "Details of scenario files" \
-                  Execute      "Execute LTP testsuite" \
-                  Results      "Display a summary of test results" \
-                  2>/tmp/runltp.mainmenu.$$ || RC=$?
-
-    case $RC in
-        0) mmenu_item=`cat /tmp/runltp.mainmenu.$$` ;
-           # echo "return code = $RC" ;
-           # echo "MENU ITEM = $mmenu_item" ;
-           case $mmenu_item in
-                About)        about_ltpcc    ;;
-                Compile)      compile_ltp    ;;
-		Details)      ltp_scenarios  ;;
-                Execute)      execute_ltp    ;;
-                Results)      disp_ltpres    ;;
-           esac ;;
-
-        1) display_info_msg "Good Bye!" \
-                            "Thank you for using Linux Test Project test suite.\
-                             Please visit our project website \
-                             http://ltp.sourceforge.net \
-                             for latest news on The Linux Test Project. "
-           exit ;;
-
-        255) display_info_msg "Good Bye!" \
-                            "Thank you for using Linux Test Project test suite.\
-                             Please visit our project website\
-                             http://ltp.sourceforge.net for latest news\
-                             on The Linux Test Project. "
-            exit;;
-    esac
-done
diff --git a/metadata/data_storage.h b/metadata/data_storage.h
index 91ea70a02..6427ea1ed 100644
--- a/metadata/data_storage.h
+++ b/metadata/data_storage.h
@@ -16,6 +16,7 @@ enum data_type {
 	DATA_HASH,
 	DATA_STRING,
 	DATA_INT,
+	DATA_NULL,
 };
 
 struct data_node_array {
@@ -68,6 +69,8 @@ static inline const char* data_type_name(enum data_type type)
 		return "string";
 	case DATA_INT:
 		return "int";
+	case DATA_NULL:
+		return "null";
 	default:
 		return "???";
 	}
@@ -100,6 +103,18 @@ static inline struct data_node *data_node_int(long i)
 	return node;
 }
 
+static inline struct data_node *data_node_null(void)
+{
+	struct data_node *node = malloc(sizeof(struct data_node));
+
+	if (!node)
+		return NULL;
+
+	node->type = DATA_NULL;
+
+	return node;
+}
+
 #define MAX_ELEMS 100
 
 static inline struct data_node *data_node_hash(void)
@@ -159,6 +174,7 @@ static inline void data_node_free(struct data_node *self)
 	switch (self->type) {
 	case DATA_STRING:
 	case DATA_INT:
+	case DATA_NULL:
 	break;
 	case DATA_HASH:
 		for (i = 0; i < self->hash.elems_used; i++) {
@@ -235,6 +251,34 @@ static inline unsigned int data_node_array_len(struct data_node *self)
 	return self->array.array_used;
 }
 
+
+static inline struct data_node *data_node_array_last(struct data_node *self)
+{
+	if (self->type != DATA_ARRAY)
+		return NULL;
+
+	unsigned int array_used = self->array.array_used;
+	if (!array_used)
+		return NULL;
+
+	return self->array.array[array_used-1];
+}
+
+static inline void data_node_array_last_rem(struct data_node *self)
+{
+	if (self->type != DATA_ARRAY)
+		return;
+
+	unsigned int array_used = self->array.array_used;
+	if (!array_used)
+		return;
+
+	data_node_free(self->array.array[array_used-1]);
+
+	self->array.array[array_used-1] = NULL;
+	self->array.array_used--;
+}
+
 static inline void data_print_padd(unsigned int i)
 {
 	while (i-- > 0)
@@ -254,6 +298,10 @@ static inline void data_node_print_(struct data_node *self, unsigned int padd)
 		data_print_padd(padd);
 		printf("'%s'\n", self->string.val);
 	break;
+	case DATA_NULL:
+		data_print_padd(padd);
+		printf("null\n");
+	break;
 	case DATA_HASH:
 		for (i = 0; i < self->hash.elems_used; i++) {
 			data_print_padd(padd);
@@ -297,7 +345,6 @@ static inline void data_fprintf(FILE *f, unsigned int padd, const char *fmt, ...
 	va_end(va);
 }
 
-
 static inline void data_fprintf_esc(FILE *f, unsigned int padd, const char *str)
 {
 	while (padd-- > 0)
@@ -344,6 +391,10 @@ static inline void data_to_json_(struct data_node *self, FILE *f, unsigned int p
 		padd = do_padd ? padd : 0;
 		data_fprintf_esc(f, padd, self->string.val);
 	break;
+	case DATA_NULL:
+		padd = do_padd ? padd : 0;
+		data_fprintf(f, padd, "null");
+	break;
 	case DATA_HASH:
 		for (i = 0; i < self->hash.elems_used; i++) {
 			data_fprintf(f, padd, "\"%s\": ", self->hash.elems[i].id);
diff --git a/metadata/metaparse.c b/metadata/metaparse.c
index 2384c73c8..2b96149dc 100644
--- a/metadata/metaparse.c
+++ b/metadata/metaparse.c
@@ -173,6 +173,10 @@ static char *next_token2(FILE *f, char *buf, size_t buf_len, struct data_node *d
 		case '[':
 		case ']':
 		case '#':
+		case '|':
+		case '+':
+		case '*':
+		case '%':
 			if (i) {
 				ungetc(c, f);
 				goto exit;
@@ -234,6 +238,20 @@ static FILE *open_file(const char *dir, const char *fname)
 	return f;
 }
 
+/**
+ * List of includes to be skipped.
+ *
+ * These define many macros or include many include files that are mostly
+ * useless to values expanded in tst_test structure. Or macros that shouldn't
+ * be expanded at all.
+ */
+static const char *skip_includes[] = {
+	"\"tst_test.h\"",
+	"\"config.h\"",
+	"\"tst_taint.h\"",
+	NULL
+};
+
 static FILE *open_include(FILE *f)
 {
 	char buf[256], *fname;
@@ -246,6 +264,20 @@ static FILE *open_include(FILE *f)
 	if (buf[0] != '"')
 		return NULL;
 
+	for (i = 0; skip_includes[i]; i++) {
+		if (!strcmp(skip_includes[i], buf)) {
+			if (verbose)
+				fprintf(stderr, "INCLUDE SKIP %s\n", buf);
+			return NULL;
+		}
+	}
+
+	if (!strncmp(buf, "\"lapi/", 6)) {
+		if (verbose)
+			fprintf(stderr, "INCLUDE SKIP %s\n", buf);
+		return NULL;
+	}
+
 	fname = buf + 1;
 
 	if (!buf[0])
@@ -286,9 +318,62 @@ static void close_include(FILE *inc)
 	fclose(inc);
 }
 
+static void try_apply_macro(char **res)
+{
+	ENTRY macro = {
+		.key = *res,
+	};
+
+	ENTRY *ret;
+
+	ret = hsearch(macro, FIND);
+
+	if (!ret)
+		return;
+
+	if (verbose)
+		fprintf(stderr, "APPLYING MACRO %s=%s\n", ret->key, (char*)ret->data);
+
+	*res = ret->data;
+}
+
+static void finalize_array_entry(char **entry, struct data_node *node)
+{
+	if (!*entry)
+		return;
+
+	data_node_array_add(node, data_node_string(*entry));
+
+	free(*entry);
+	*entry = NULL;
+}
+
+static void str_append(char **res, char *append)
+{
+	char *cur_str = *res;
+
+	if (!cur_str) {
+		*res = strdup(append);
+		if (!*res)
+			goto err;
+		return;
+	}
+
+	if (asprintf(res, "%s%s", cur_str, append) < 0)
+		goto err;
+
+	free(cur_str);
+	return;
+err:
+	fprintf(stderr, "Allocation failed :(\n");
+	exit(1);
+}
+
 static int parse_array(FILE *f, struct data_node *node)
 {
-	const char *token;
+	char *token;
+	char *entry = NULL;
+	int parent_cnt = 0;
 
 	for (;;) {
 		if (!(token = next_token(f, NULL)))
@@ -306,42 +391,42 @@ static int parse_array(FILE *f, struct data_node *node)
 			continue;
 		}
 
-		if (!strcmp(token, "}"))
+		if (!strcmp(token, "}")) {
+			struct data_node *arr_last;
+
+			finalize_array_entry(&entry, node);
+
+			/* Remove NULL terminating entry, if present. */
+			arr_last = data_node_array_last(node);
+			if (arr_last && arr_last->type == DATA_NULL)
+				data_node_array_last_rem(node);
+
 			return 0;
+		}
 
-		if (!strcmp(token, ","))
+		if (!strcmp(token, ",") && parent_cnt <= 0) {
+			finalize_array_entry(&entry, node);
 			continue;
+		}
 
-		if (!strcmp(token, "NULL"))
+		if (!strcmp(token, "NULL")) {
+			data_node_array_add(node, data_node_null());
 			continue;
+		}
+
+		if (!strcmp(token, "("))
+			parent_cnt++;
 
-		struct data_node *str = data_node_string(token);
+		if (!strcmp(token, ")"))
+			parent_cnt--;
 
-		data_node_array_add(node, str);
+		try_apply_macro(&token);
+		str_append(&entry, token);
 	}
 
 	return 0;
 }
 
-static void try_apply_macro(char **res)
-{
-	ENTRY macro = {
-		.key = *res,
-	};
-
-	ENTRY *ret;
-
-	ret = hsearch(macro, FIND);
-
-	if (!ret)
-		return;
-
-	if (verbose)
-		fprintf(stderr, "APPLYING MACRO %s=%s\n", ret->key, (char*)ret->data);
-
-	*res = ret->data;
-}
-
 static int parse_get_array_len(FILE *f)
 {
 	const char *token;
@@ -638,12 +723,20 @@ static void parse_macro(FILE *f)
 	hsearch(e, ENTER);
 }
 
-static void parse_include_macros(FILE *f)
+static void parse_include_macros(FILE *f, int level)
 {
 	FILE *inc;
 	const char *token;
 	int hash = 0;
 
+	/**
+	 * Allow only three levels of include indirection.
+	 *
+	 * Should be more than enough (TM).
+	 */
+	if (level >= 3)
+		return;
+
 	inc = open_include(f);
 	if (!inc)
 		return;
@@ -659,6 +752,8 @@ static void parse_include_macros(FILE *f)
 
 		if (!strcmp(token, "define"))
 			parse_macro(inc);
+		else if (!strcmp(token, "include"))
+			parse_include_macros(inc, level+1);
 
 		hash = 0;
 	}
@@ -666,6 +761,51 @@ static void parse_include_macros(FILE *f)
 	close_include(inc);
 }
 
+/* pre-defined macros that makes the output cleaner. */
+static const struct macro {
+	char *from;
+	char *to;
+} internal_macros[] = {
+	{"TST_CG_V2", "2"},
+	{"TST_CG_V1", "1"},
+	{"TST_KB", "1024"},
+	{"TST_MB", "1048576"},
+	{"TST_GB", "1073741824"},
+	{"TST_SR_TBROK", "TBROK"},
+	{"TST_SR_TCONF", "TCONF"},
+	{"TST_SR_SKIP", "SKIP"},
+	{"TST_SR_TBROK_MISSING", "TBROK_MISSING"},
+	{"TST_SR_TCONF_MISSING", "TCONF_MISSING"},
+	{"TST_SR_SKIP_MISSING", "SKIP_MISSING"},
+	{"TST_SR_TBROK_RO", "TBROK_RO"},
+	{"TST_SR_TCONF_RO", "TCONF_RO"},
+	{"TST_SR_SKIP_RO", "SKIP_RO"},
+	{}
+};
+
+static void load_internal_macros(void)
+{
+	unsigned int i;
+
+	if (verbose)
+		fprintf(stderr, "PREDEFINED MACROS\n");
+
+	for (i = 0; internal_macros[i].from; i++) {
+		ENTRY e = {
+			.key = internal_macros[i].from,
+			.data = internal_macros[i].to,
+		};
+
+		if (verbose)
+			fprintf(stderr, " MACRO %s=%s\n", e.key, (char*)e.data);
+
+		hsearch(e, ENTER);
+	}
+
+	if (verbose)
+		fprintf(stderr, "END PREDEFINED MACROS\n");
+}
+
 static struct data_node *parse_file(const char *fname)
 {
 	int state = 0, found = 0;
@@ -683,6 +823,8 @@ static struct data_node *parse_file(const char *fname)
 	struct data_node *res = data_node_hash();
 	struct data_node *doc = data_node_array();
 
+	load_internal_macros();
+
 	while ((token = next_token(f, doc))) {
 		if (state < 6 && !strcmp(tokens[state], token)) {
 			state++;
@@ -694,7 +836,7 @@ static struct data_node *parse_file(const char *fname)
 						parse_macro(f);
 
 					if (!strcmp(token, "include"))
-						parse_include_macros(f);
+						parse_include_macros(f, 0);
 				}
 			}
 
diff --git a/metadata/parse.sh b/metadata/parse.sh
index 69bf5db65..7db2e2415 100755
--- a/metadata/parse.sh
+++ b/metadata/parse.sh
@@ -30,7 +30,7 @@ echo ' "tests": {'
 first=1
 
 for test in `find testcases/ -name '*.c'|sort`; do
-	a=$($top_builddir/metadata/metaparse -Iinclude -Itestcases/kernel/syscalls/utils/ "$test")
+	a=$($top_builddir/metadata/metaparse -Iinclude -Itestcases/kernel/syscalls/utils/ -Itestcases/kernel/include "$test")
 	if [ -n "$a" ]; then
 		if [ -z "$first" ]; then
 			echo ','
diff --git a/runltp b/runltp
index 62ab66871..0d9062569 100755
--- a/runltp
+++ b/runltp
@@ -68,9 +68,19 @@
 #################################################################################
 
 
+deprecated()
+{
+    echo "-------------------------------------------" >&2
+    echo "INFO: runltp script is deprecated, try kirk" >&2
+    echo "https://github.com/linux-test-project/kirk" >&2
+    echo "-------------------------------------------" >&2
+}
+
 
 setup()
 {
+    deprecated
+
     cd `dirname $0` || \
     {
         echo "FATAL: unable to change directory to $(dirname $0)"
@@ -921,6 +931,9 @@ EOF
 
 	EOF
     }
+
+    deprecated
+
     exit $VALUE
 }
 
diff --git a/runtest/commands b/runtest/commands
index 5ec2c3b69..cfbaf214c 100644
--- a/runtest/commands
+++ b/runtest/commands
@@ -5,7 +5,6 @@ ldd01_sh ldd01.sh
 nm01_sh nm01.sh
 file01_sh file01.sh
 tar01_sh  tar_tests.sh
-logrotate_sh export TCdat=$LTPROOT/testcases/bin; logrotate_tests.sh
 cpio01_sh cpio_tests.sh
 unzip01_sh unzip01.sh
 gzip01_sh gzip_tests.sh
diff --git a/runtest/hugetlb b/runtest/hugetlb
index 299c07ac9..0896d3c94 100644
--- a/runtest/hugetlb
+++ b/runtest/hugetlb
@@ -35,6 +35,7 @@ hugemmap29 hugemmap29
 hugemmap30 hugemmap30
 hugemmap31 hugemmap31
 hugemmap32 hugemmap32
+hugemmap34 hugemmap34
 hugemmap05_1 hugemmap05 -m
 hugemmap05_2 hugemmap05 -s
 hugemmap05_3 hugemmap05 -s -m
@@ -55,3 +56,4 @@ hugeshmget01 hugeshmget01 -i 10
 hugeshmget02 hugeshmget02 -i 10
 hugeshmget03 hugeshmget03 -i 10
 hugeshmget05 hugeshmget05 -i 10
+hugeshmget06 hugeshmget06 -i 10
diff --git a/runtest/net.nfs b/runtest/net.nfs
index 929868a7b..fef993da8 100644
--- a/runtest/net.nfs
+++ b/runtest/net.nfs
@@ -94,6 +94,17 @@ nfs09_v40_ip6t nfs09.sh -6 -v 4 -t tcp
 nfs09_v41_ip6t nfs09.sh -6 -v 4.1 -t tcp
 nfs09_v42_ip6t nfs09.sh -6 -v 4.2 -t tcp
 
+nfs10_v30_ip4u nfs10.sh -v 3 -t udp
+nfs10_v30_ip4t nfs10.sh -v 3 -t tcp
+nfs10_v40_ip4t nfs10.sh -v 4 -t tcp
+nfs10_v41_ip4t nfs10.sh -v 4.1 -t tcp
+nfs10_v42_ip4t nfs10.sh -v 4.2 -t tcp
+nfs10_v30_ip6u nfs10.sh -6 -v 3 -t udp
+nfs10_v30_ip6t nfs10.sh -6 -v 3 -t tcp
+nfs10_v40_ip6t nfs10.sh -6 -v 4 -t tcp
+nfs10_v41_ip6t nfs10.sh -6 -v 4.1 -t tcp
+nfs10_v42_ip6t nfs10.sh -6 -v 4.2 -t tcp
+
 nfslock01_v30_ip4u nfslock01.sh -v 3 -t udp
 nfslock01_v30_ip4t nfslock01.sh -v 3 -t tcp
 nfslock01_v40_ip4t nfslock01.sh -v 4 -t tcp
@@ -116,6 +127,8 @@ nfsstat01_v40_ip6t nfsstat01.sh -6 -v 4 -t tcp
 nfsstat01_v41_ip6t nfsstat01.sh -6 -v 4.1 -t tcp
 nfsstat01_v42_ip6t nfsstat01.sh -6 -v 4.2 -t tcp
 
+nfsstat02 nfsstat02.sh
+
 fsx_v30_ip4u fsx.sh -v 3 -t udp
 fsx_v30_ip4t fsx.sh -v 3 -t tcp
 fsx_v40_ip4t fsx.sh -v 4 -t tcp
diff --git a/runtest/net.tcp_cmds b/runtest/net.tcp_cmds
index 248c7371d..aba02fb30 100644
--- a/runtest/net.tcp_cmds
+++ b/runtest/net.tcp_cmds
@@ -5,7 +5,6 @@
 ipneigh01_arp ipneigh01.sh -c arp
 ipneigh01_ip ipneigh01.sh -c ip
 arping01 arping01.sh
-ftp ftp01.sh
 netstat netstat01.sh
 ping01 ping01.sh
 ping02 ping02.sh
diff --git a/runtest/pty b/runtest/pty
index df2074153..4b1abe7a6 100644
--- a/runtest/pty
+++ b/runtest/pty
@@ -6,6 +6,13 @@ pty04 pty04
 pty05 pty05
 pty06 pty06
 pty07 pty07
+pty08 pty08
+pty09 pty09
 ptem01 ptem01
+ptem02 ptem02
+ptem03 ptem03
+ptem04 ptem04
+ptem05 ptem05
+ptem06 ptem06
 hangup01 hangup01
 
diff --git a/runtest/sched b/runtest/sched
index 5dab7a4c2..ecedd1a92 100644
--- a/runtest/sched
+++ b/runtest/sched
@@ -18,3 +18,5 @@ sched_cli_serv run_sched_cliserv.sh
 sched_stress sched_stress.sh
 
 autogroup01 autogroup01
+
+sched_football sched_football
diff --git a/runtest/smoketest b/runtest/smoketest
index f6f14fd2b..aeb74c9ee 100644
--- a/runtest/smoketest
+++ b/runtest/smoketest
@@ -8,9 +8,7 @@ time01 time01
 wait02 wait02
 write01 write01
 symlink01 symlink01
-stat04 symlink01 -T stat04
-utime07 utime07
-rename01A symlink01 -T rename01
+stat04 stat04
 splice02 splice02 -s 20
 df01_sh df01.sh
 shell_test01 echo "SUCCESS" | shell_pipe01.sh
diff --git a/runtest/syscalls b/runtest/syscalls
index 5fb1bf992..033b720c8 100644
--- a/runtest/syscalls
+++ b/runtest/syscalls
@@ -62,6 +62,11 @@ capset04 capset04
 
 cacheflush01 cacheflush01
 
+cachestat01 cachestat01
+cachestat02 cachestat02
+cachestat03 cachestat03
+cachestat04 cachestat04
+
 chdir01 chdir01
 chdir01A symlink01 -T chdir01
 chdir04 chdir04
@@ -72,6 +77,8 @@ chmod03 chmod03
 chmod05 chmod05
 chmod06 chmod06
 chmod07 chmod07
+chmod08 chmod08
+chmod09 chmod09
 
 chown01 chown01
 chown01_16 chown01_16
@@ -264,6 +271,9 @@ fchmod06 fchmod06
 fchmodat01 fchmodat01
 fchmodat02 fchmodat02
 
+fchmodat2_01 fchmodat2_01
+fchmodat2_02 fchmodat2_02
+
 fchown01 fchown01
 fchown01_16 fchown01_16
 fchown02 fchown02
@@ -439,6 +449,7 @@ futimesat01 futimesat01
 getcontext01 getcontext01
 
 getcpu01 getcpu01
+getcpu02 getcpu02
 
 getcwd01 getcwd01
 getcwd02 getcwd02
@@ -591,6 +602,12 @@ ioctl_ns07 ioctl_ns07
 
 ioctl_sg01 ioctl_sg01
 
+ioctl_ficlone01 ioctl_ficlone01
+ioctl_ficlone02 ioctl_ficlone02
+ioctl_ficlone03 ioctl_ficlone03
+ioctl_ficlonerange01 ioctl_ficlonerange01
+ioctl_ficlonerange02 ioctl_ficlonerange02
+
 inotify_init1_01 inotify_init1_01
 inotify_init1_02 inotify_init1_02
 
@@ -684,6 +701,15 @@ kill11 kill11
 kill12 kill12
 kill13 kill13
 
+landlock01 landlock01
+landlock02 landlock02
+landlock03 landlock03
+landlock04 landlock04
+landlock05 landlock05
+landlock06 landlock06
+landlock07 landlock07
+landlock08 landlock08
+
 lchown01 lchown01
 lchown01_16 lchown01_16
 lchown02  lchown02
@@ -706,6 +732,11 @@ linkat02 linkat02
 
 listen01 listen01
 
+listmount01 listmount01
+listmount02 listmount02
+listmount03 listmount03
+listmount04 listmount04
+
 listxattr01 listxattr01
 listxattr02 listxattr02
 listxattr03 listxattr03
@@ -725,12 +756,12 @@ lseek02 lseek02
 lseek07 lseek07
 lseek11 lseek11
 
-lstat01A symlink01 -T lstat01
-lstat01A_64 symlink01 -T lstat01_64
 lstat01 lstat01
 lstat01_64 lstat01_64
 lstat02 lstat02
 lstat02_64 lstat02_64
+lstat03 lstat03
+lstat03_64 lstat03_64
 
 mallinfo02 mallinfo02
 
@@ -862,6 +893,9 @@ mremap04 mremap04
 mremap05 mremap05
 mremap06 mremap06
 
+mseal01 mseal01
+mseal02 mseal02
+
 msgctl01 msgctl01
 msgctl02 msgctl02
 msgctl03 msgctl03
@@ -922,7 +956,6 @@ nice04 nice04
 nice05 nice05
 
 open01 open01
-open01A symlink01 -T open01
 open02 open02
 open03 open03
 open04 open04
@@ -935,6 +968,7 @@ open11 open11
 open12 open12
 open13 open13
 open14 open14
+open15 open15
 
 openat01 openat01
 openat02 openat02
@@ -966,6 +1000,7 @@ madvise08 madvise08
 madvise09 madvise09
 madvise10 madvise10
 madvise11 madvise11
+madvise12 madvise12
 
 newuname01 newuname01
 
@@ -1021,7 +1056,6 @@ ppoll01 ppoll01
 prctl01 prctl01
 prctl02 prctl02
 prctl03 prctl03
-prctl04 prctl04
 prctl05 prctl05
 prctl06 prctl06
 prctl07 prctl07
@@ -1171,6 +1205,7 @@ rename11 rename11
 rename12 rename12
 rename13 rename13
 rename14 rename14
+rename15 rename15
 
 #renameat test cases
 renameat01 renameat01
@@ -1183,6 +1218,7 @@ request_key02 request_key02
 request_key03 request_key03
 request_key04 request_key04
 request_key05 request_key05
+request_key06 request_key06
 
 rmdir01 rmdir01
 rmdir02 rmdir02
@@ -1196,6 +1232,7 @@ rt_sigpending02 rt_sigpending02
 rt_sigprocmask01 rt_sigprocmask01
 rt_sigprocmask02 rt_sigprocmask02
 rt_sigqueueinfo01 rt_sigqueueinfo01
+rt_sigqueueinfo02 rt_sigqueueinfo02
 rt_sigsuspend01 rt_sigsuspend01
 rt_sigtimedwait01 rt_sigtimedwait01
 rt_tgsigqueueinfo01 rt_tgsigqueueinfo01
@@ -1240,6 +1277,8 @@ sched_setattr01 sched_setattr01
 sched_getattr01 sched_getattr01
 sched_getattr02 sched_getattr02
 
+seccomp01 seccomp01
+
 select01 select01
 select01_SYS__newselect select01_SYS__newselect
 select01_SYS_select select01_SYS_select
@@ -1478,6 +1517,9 @@ shmget04 shmget04
 shmget05 shmget05
 shmget06 shmget06
 
+shutdown01 shutdown01
+shutdown02 shutdown02
+
 sigaction01 sigaction01
 sigaction02 sigaction02
 
@@ -1495,6 +1537,7 @@ signal05 signal05
 signal06 signal06
 
 signalfd01 signalfd01
+signalfd02 signalfd02
 
 signalfd4_01 signalfd4_01
 signalfd4_02 signalfd4_02
@@ -1506,6 +1549,7 @@ sigprocmask01 sigprocmask01
 sigrelse01 sigrelse01
 
 sigsuspend01 sigsuspend01
+sigsuspend02 sigsuspend02
 
 sigtimedwait01 sigtimedwait01
 
@@ -1545,8 +1589,17 @@ stat02 stat02
 stat02_64 stat02_64
 stat03 stat03
 stat03_64 stat03_64
-stat04 symlink01 -T stat04
-stat04_64 symlink01 -T stat04_64
+stat04 stat04
+stat04_64 stat04_64
+
+statmount01 statmount01
+statmount02 statmount02
+statmount03 statmount03
+statmount04 statmount04
+statmount05 statmount05
+statmount06 statmount06
+statmount07 statmount07
+statmount08 statmount08
 
 statfs01 statfs01
 statfs01_64 statfs01_64
@@ -1670,6 +1723,7 @@ unlink05 unlink05
 unlink07 unlink07
 unlink08 unlink08
 unlink09 unlink09
+unlink10 unlink10
 
 #unlinkat test cases
 unlinkat01 unlinkat01
diff --git a/scripts/calctimeouts.py b/scripts/calctimeouts.py
new file mode 100755
index 000000000..18886704f
--- /dev/null
+++ b/scripts/calctimeouts.py
@@ -0,0 +1,234 @@
+#!/usr/bin/env python3
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2025 Cyril Hrubis <chrubis@suse.cz>
+# Copyright (c) 2025 Andrea Cervesato <andrea.cervesato@suse.com>
+"""
+This script parses JSON results from kirk and LTP metadata in order to
+calculate timeouts for tests based on the results file.
+It can also patch tests automatically and replace the calculated timeout.
+"""
+
+import re
+import os
+import json
+import argparse
+
+# The test runtime is multiplied by this to get a timeout
+TIMEOUT_MUL = 1.2
+
+
+def _sed(fname, expr, replace):
+    """
+    Pythonic version of sed command.
+    """
+    content = []
+    matcher = re.compile(expr)
+
+    with open(fname, 'r', encoding="utf-8") as data:
+        for line in data:
+            match = matcher.search(line)
+            if not match:
+                content.append(line)
+            else:
+                content.append(replace)
+
+    with open(fname, 'w', encoding="utf-8") as data:
+        data.writelines(content)
+
+
+def _patch(ltp_dir, fname, new_timeout, override):
+    """
+    If `override` is True, it patches a test file, searching for timeout and
+    replacing it with `new_timeout`.
+    """
+    orig_timeout = None
+    file_path = os.path.join(ltp_dir, fname)
+
+    with open(file_path, 'r', encoding="utf-8") as c_source:
+        matcher = re.compile(r'\s*.timeout\s*=\s*(\d+).')
+        for line in c_source:
+            match = matcher.search(line)
+            if not match:
+                continue
+
+            timeout = match.group(1)
+            orig_timeout = int(timeout)
+
+    if orig_timeout:
+        if orig_timeout < new_timeout or override:
+            print(f"CHANGE {fname} timeout {orig_timeout} -> {new_timeout}")
+            _sed(file_path, r".timeout = [0-9]*,\n",
+                 f"\t.timeout = {new_timeout},\n")
+        else:
+            print(f"KEEP   {fname} timeout {orig_timeout} (new {new_timeout})")
+    else:
+        print(f"ADD    {fname} timeout {new_timeout}")
+        _sed(file_path,
+             "static struct tst_test test = {",
+             "static struct tst_test test = {\n"
+             f"\t.timeout = {new_timeout},\n")
+
+
+def _patch_all(ltp_dir, timeouts, override):
+    """
+    Patch all tests.
+    """
+    for timeout in timeouts:
+        if timeout['path']:
+            _patch(ltp_dir, timeout['path'], timeout['timeout'], override)
+
+
+def _print_table(timeouts):
+    """
+    Print the timeouts table.
+    """
+    timeouts.sort(key=lambda x: x['timeout'], reverse=True)
+
+    total = 0
+
+    print("Old library tests\n-----------------\n")
+    for timeout in timeouts:
+        if not timeout['newlib']:
+            print(f"{timeout['name']:30s} {timeout['timeout']}")
+            total += 1
+
+    print(f"\n\t{total} tests in total")
+
+    total = 0
+
+    print("\nNew library tests\n-----------------\n")
+    for timeout in timeouts:
+        if timeout['newlib']:
+            print(f"{timeout['name']:30s} {timeout['timeout']}")
+            total += 1
+
+    print(f"\n\t{total} tests in total")
+
+
+def _parse_data(ltp_dir, results_path):
+    """
+    Parse results data and metadata, then it generates timeouts data.
+    """
+    timeouts = []
+    results = None
+    metadata = None
+
+    with open(results_path, 'r', encoding="utf-8") as file:
+        results = json.load(file)
+
+    metadata_path = os.path.join(ltp_dir, 'metadata', 'ltp.json')
+    with open(metadata_path, 'r', encoding="utf-8") as file:
+        metadata = json.load(file)
+
+    for test in results['results']:
+        name = test['test_fqn']
+        duration = test['test']['duration']
+
+        # if test runs for all_filesystems, normalize runtime to one filesystem
+        filesystems = max(1, test['test']['log'].count('TINFO: Formatting /'))
+
+        # check if test is new library test
+        test_is_newlib = name in metadata['tests']
+
+        # store test file path
+        path = None
+        if test_is_newlib:
+            path = metadata['tests'][name]['fname']
+
+        test_has_runtime = False
+        if test_is_newlib:
+            # filter out tests with runtime
+            test_has_runtime = 'runtime' in metadata['tests'][name]
+
+            # timer tests define runtime dynamically in timer library
+            test_has_runtime = 'sample' in metadata['tests'][name]
+
+        # select tests that does not have runtime and which are executed
+        # for a long time
+        if not test_has_runtime and duration >= 0.5:
+            data = {}
+            data["name"] = name
+            data["timeout"] = int(TIMEOUT_MUL * duration/filesystems + 0.5)
+            data["newlib"] = test_is_newlib
+            data["path"] = path
+
+            timeouts.append(data)
+
+    return timeouts
+
+
+def _file_exists(filepath):
+    """
+    Check if the given file path exists.
+    """
+    if not os.path.isfile(filepath):
+        raise argparse.ArgumentTypeError(
+            f"The file '{filepath}' does not exist.")
+    return filepath
+
+
+def _dir_exists(dirpath):
+    """
+    Check if the given directory path exists.
+    """
+    if not os.path.isdir(dirpath):
+        raise argparse.ArgumentTypeError(
+            f"The directory '{dirpath}' does not exist.")
+    return dirpath
+
+
+def run():
+    """
+    Entry point of the script.
+    """
+    parser = argparse.ArgumentParser(
+        description="Script to calculate LTP tests timeouts")
+
+    parser.add_argument(
+        '-l',
+        '--ltp-dir',
+        type=_dir_exists,
+        help='LTP source code directory',
+        default='..')
+
+    parser.add_argument(
+        '-r',
+        '--results',
+        type=_file_exists,
+        required=True,
+        help='kirk results.json file location')
+
+    parser.add_argument(
+        '-o',
+        '--override',
+        default=False,
+        action='store_true',
+        help='Always override test timeouts')
+
+    parser.add_argument(
+        '-p',
+        '--patch',
+        default=False,
+        action='store_true',
+        help='Patch tests with updated timeout')
+
+    parser.add_argument(
+        '-t',
+        '--print-table',
+        default=True,
+        action='store_true',
+        help='Print table with suggested timeouts')
+
+    args = parser.parse_args()
+
+    timeouts = _parse_data(args.ltp_dir, args.results)
+
+    if args.print_table:
+        _print_table(timeouts)
+
+    if args.patch:
+        _patch_all(args.ltp_dir, timeouts, args.override)
+
+
+if __name__ == "__main__":
+    run()
diff --git a/testcases/Android.bp b/testcases/Android.bp
index 79d68e7d4..232f99153 100644
--- a/testcases/Android.bp
+++ b/testcases/Android.bp
@@ -17,87 +17,6 @@ package {
     default_applicable_licenses: ["external_ltp_license"],
 }
 
-sh_test {
-    name: "ltp_testcases_data_mc_member_ManyGroups",
-    src: "network/multicast/mc_member/datafiles/ManyGroups",
-    sub_dir: "vts_ltp_tests/testcases/data/mc_member",
-    filename: "ManyGroups",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_mc_member_TooManyGroups",
-    src: "network/multicast/mc_member/datafiles/TooManyGroups",
-    sub_dir: "vts_ltp_tests/testcases/data/mc_member",
-    filename: "TooManyGroups",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_ld01_d1.c",
-    src: "commands/ld/datafiles/d1.c",
-    sub_dir: "vts_ltp_tests/testcases/data/ld01",
-    filename: "d1.c",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_unzip01_dir.out",
-    src: "commands/unzip/datafiles/dir.out",
-    sub_dir: "vts_ltp_tests/testcases/data/unzip01",
-    filename: "dir.out",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_ld01_f1.c",
-    src: "commands/ld/datafiles/f1.c",
-    sub_dir: "vts_ltp_tests/testcases/data/ld01",
-    filename: "f1.c",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_rpc01_file.1",
-    src: "network/rpc/basic_tests/rpc01/datafiles/file.1",
-    sub_dir: "vts_ltp_tests/testcases/data/rpc01",
-    filename: "file.1",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_rpc01_file.2",
-    src: "network/rpc/basic_tests/rpc01/datafiles/file.2",
-    sub_dir: "vts_ltp_tests/testcases/data/rpc01",
-    filename: "file.2",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_binfmt_misc02_file.extension",
-    src: "kernel/fs/binfmt_misc/datafiles/file.extension",
-    sub_dir: "vts_ltp_tests/testcases/data/binfmt_misc02",
-    filename: "file.extension",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
-sh_test {
-    name: "ltp_testcases_data_binfmt_misc02_file.magic",
-    src: "kernel/fs/binfmt_misc/datafiles/file.magic",
-    sub_dir: "vts_ltp_tests/testcases/data/binfmt_misc02",
-    filename: "file.magic",
-    compile_multilib: "both",
-    auto_gen_config: false,
-}
-
 sh_test {
     name: "ltp_testcases_data_ar01_file1.in",
     src: "commands/ar/datafiles/file1.in",
@@ -143,6 +62,24 @@ sh_test {
     auto_gen_config: false,
 }
 
+sh_test {
+    name: "ltp_testcases_data_binfmt_misc02_file.extension",
+    src: "kernel/fs/binfmt_misc/datafiles/file.extension",
+    sub_dir: "vts_ltp_tests/testcases/data/binfmt_misc02",
+    filename: "file.extension",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_binfmt_misc02_file.magic",
+    src: "kernel/fs/binfmt_misc/datafiles/file.magic",
+    sub_dir: "vts_ltp_tests/testcases/data/binfmt_misc02",
+    filename: "file.magic",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
 sh_test {
     name: "ltp_testcases_data_file01_in.ar",
     src: "commands/file/datafiles/in.ar",
@@ -315,10 +252,10 @@ sh_test {
 }
 
 sh_test {
-    name: "ltp_testcases_data_ld01_main.c",
-    src: "commands/ld/datafiles/main.c",
-    sub_dir: "vts_ltp_tests/testcases/data/ld01",
-    filename: "main.c",
+    name: "ltp_testcases_data_ima_keys_x509_ima.der",
+    src: "kernel/security/integrity/ima/datafiles/ima_keys/x509_ima.der",
+    sub_dir: "vts_ltp_tests/testcases/data/ima_keys",
+    filename: "x509_ima.der",
     compile_multilib: "both",
     auto_gen_config: false,
 }
@@ -341,6 +278,42 @@ sh_test {
     auto_gen_config: false,
 }
 
+sh_test {
+    name: "ltp_testcases_data_ima_selinux_selinux.policy",
+    src: "kernel/security/integrity/ima/datafiles/ima_selinux/selinux.policy",
+    sub_dir: "vts_ltp_tests/testcases/data/ima_selinux",
+    filename: "selinux.policy",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_ld01_d1.c",
+    src: "commands/ld/datafiles/d1.c",
+    sub_dir: "vts_ltp_tests/testcases/data/ld01",
+    filename: "d1.c",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_ld01_f1.c",
+    src: "commands/ld/datafiles/f1.c",
+    sub_dir: "vts_ltp_tests/testcases/data/ld01",
+    filename: "f1.c",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_ld01_main.c",
+    src: "commands/ld/datafiles/main.c",
+    sub_dir: "vts_ltp_tests/testcases/data/ld01",
+    filename: "main.c",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
 sh_test {
     name: "ltp_testcases_data_ld01_rd1.c",
     src: "commands/ld/datafiles/rd1.c",
@@ -369,10 +342,46 @@ sh_test {
 }
 
 sh_test {
-    name: "ltp_testcases_data_ima_selinux_selinux.policy",
-    src: "kernel/security/integrity/ima/datafiles/ima_selinux/selinux.policy",
-    sub_dir: "vts_ltp_tests/testcases/data/ima_selinux",
-    filename: "selinux.policy",
+    name: "ltp_testcases_data_mc_member_ManyGroups",
+    src: "network/multicast/mc_member/datafiles/ManyGroups",
+    sub_dir: "vts_ltp_tests/testcases/data/mc_member",
+    filename: "ManyGroups",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_mc_member_TooManyGroups",
+    src: "network/multicast/mc_member/datafiles/TooManyGroups",
+    sub_dir: "vts_ltp_tests/testcases/data/mc_member",
+    filename: "TooManyGroups",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_rpc01_file.1",
+    src: "network/rpc/basic_tests/rpc01/datafiles/file.1",
+    sub_dir: "vts_ltp_tests/testcases/data/rpc01",
+    filename: "file.1",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_rpc01_file.2",
+    src: "network/rpc/basic_tests/rpc01/datafiles/file.2",
+    sub_dir: "vts_ltp_tests/testcases/data/rpc01",
+    filename: "file.2",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_data_unzip01_dir.out",
+    src: "commands/unzip/datafiles/dir.out",
+    sub_dir: "vts_ltp_tests/testcases/data/unzip01",
+    filename: "dir.out",
     compile_multilib: "both",
     auto_gen_config: false,
 }
@@ -387,10 +396,244 @@ sh_test {
 }
 
 sh_test {
-    name: "ltp_testcases_data_ima_keys_x509_ima.der",
-    src: "kernel/security/integrity/ima/datafiles/ima_keys/x509_ima.der",
-    sub_dir: "vts_ltp_tests/testcases/data/ima_keys",
-    filename: "x509_ima.der",
+    name: "ltp_testcases_realtime_func_async_handler_run_auto.sh",
+    src: "realtime/func/async_handler/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/async_handler",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_gtod_latency_run_auto.sh",
+    src: "realtime/func/gtod_latency/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/gtod_latency",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_hrtimer-prio_run_auto.sh",
+    src: "realtime/func/hrtimer-prio/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/hrtimer-prio",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_matrix_mult_run_auto.sh",
+    src: "realtime/func/matrix_mult/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/matrix_mult",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_measurement_run_auto.sh",
+    src: "realtime/func/measurement/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/measurement",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_periodic_cpu_load_run_auto.sh",
+    src: "realtime/func/periodic_cpu_load/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/periodic_cpu_load",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_pi-tests_parse-testpi1.py",
+    src: "realtime/func/pi-tests/parse-testpi1.py",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/pi-tests",
+    filename: "parse-testpi1.py",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_pi-tests_parse-testpi2.py",
+    src: "realtime/func/pi-tests/parse-testpi2.py",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/pi-tests",
+    filename: "parse-testpi2.py",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_pi-tests_run_auto.sh",
+    src: "realtime/func/pi-tests/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/pi-tests",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_pi_perf_run_auto.sh",
+    src: "realtime/func/pi_perf/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/pi_perf",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_prio-preempt_run_auto.sh",
+    src: "realtime/func/prio-preempt/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/prio-preempt",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_prio-wake_run_auto.sh",
+    src: "realtime/func/prio-wake/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/prio-wake",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_pthread_kill_latency_run_auto.sh",
+    src: "realtime/func/pthread_kill_latency/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/pthread_kill_latency",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_rt-migrate_run_auto.sh",
+    src: "realtime/func/rt-migrate/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/rt-migrate",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_sched_jitter_run_auto.sh",
+    src: "realtime/func/sched_jitter/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/sched_jitter",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_sched_latency_run_auto.sh",
+    src: "realtime/func/sched_latency/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/sched_latency",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_func_thread_clock_run_auto.sh",
+    src: "realtime/func/thread_clock/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/func/thread_clock",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_perf_latency_cpunoise.sh",
+    src: "realtime/perf/latency/cpunoise.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/perf/latency",
+    filename: "cpunoise.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_perf_latency_cpunoise2000.sh",
+    src: "realtime/perf/latency/cpunoise2000.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/perf/latency",
+    filename: "cpunoise2000.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_perf_latency_disknoise.sh",
+    src: "realtime/perf/latency/disknoise.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/perf/latency",
+    filename: "disknoise.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_perf_latency_run_auto.sh",
+    src: "realtime/perf/latency/run_auto.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/perf/latency",
+    filename: "run_auto.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_profiles_default",
+    src: "realtime/profiles/default",
+    sub_dir: "vts_ltp_tests/testcases/realtime/profiles",
+    filename: "default",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_run.sh",
+    src: "realtime/run.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime",
+    filename: "run.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_scripts___init__.py",
+    src: "realtime/scripts/__init__.py",
+    sub_dir: "vts_ltp_tests/testcases/realtime/scripts",
+    filename: "__init__.py",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_scripts_parser.py",
+    src: "realtime/scripts/parser.py",
+    sub_dir: "vts_ltp_tests/testcases/realtime/scripts",
+    filename: "parser.py",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_scripts_run_c_files.sh",
+    src: "realtime/scripts/run_c_files.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/scripts",
+    filename: "run_c_files.sh",
+    compile_multilib: "both",
+    auto_gen_config: false,
+}
+
+sh_test {
+    name: "ltp_testcases_realtime_scripts_setenv.sh",
+    src: "realtime/scripts/setenv.sh",
+    sub_dir: "vts_ltp_tests/testcases/realtime/scripts",
+    filename: "setenv.sh",
     compile_multilib: "both",
     auto_gen_config: false,
 }
diff --git a/testcases/Makefile b/testcases/Makefile
index 662d4b1ed..d98d79f3c 100644
--- a/testcases/Makefile
+++ b/testcases/Makefile
@@ -15,8 +15,4 @@ ifneq ($(WITH_OPEN_POSIX_TESTSUITE),yes)
 FILTER_OUT_DIRS		+= open_posix_testsuite
 endif
 
-ifneq ($(WITH_REALTIME_TESTSUITE),yes)
-FILTER_OUT_DIRS		+= realtime
-endif
-
 include $(top_srcdir)/include/mk/generic_trunk_target.mk
diff --git a/testcases/commands/insmod/.gitignore b/testcases/commands/insmod/.gitignore
index 0e19fb3fd..ba8fca18a 100644
--- a/testcases/commands/insmod/.gitignore
+++ b/testcases/commands/insmod/.gitignore
@@ -1,9 +1,6 @@
 *.ko
 *.mod.c
-*.ko.cmd
-*.mod.cmd
-*.mod.o.cmd
-*.o.cmd
-.built-in.a.cmd
+*.cmd
 Module.symvers
 modules.order
+modules.livepatch
diff --git a/testcases/commands/insmod/insmod01.sh b/testcases/commands/insmod/insmod01.sh
index 992b4a05a..bc4f50e05 100755
--- a/testcases/commands/insmod/insmod01.sh
+++ b/testcases/commands/insmod/insmod01.sh
@@ -30,6 +30,11 @@ cleanup()
 
 do_test()
 {
+	tst_check_kconfigs "CONFIG_MODULE_SIG_FORCE=y"
+	if [ $? -eq 0 ] || grep module.sig_enforce -qw /proc/cmdline; then
+		tst_brk TCONF "module signature is enforced, skipping test"
+	fi
+
 	insmod "$TST_MODPATH"
 	if [ $? -ne 0 ]; then
 		tst_res TFAIL "insmod failed"
diff --git a/testcases/commands/logrotate/00_Descriptions.txt b/testcases/commands/logrotate/00_Descriptions.txt
deleted file mode 100644
index 07ffcd3e6..000000000
--- a/testcases/commands/logrotate/00_Descriptions.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-logrotate01
-	test basic functionality of logrotate. use logrotate -f <config> to force rotation. 1. rotate /var/log/tst_logfile file. 2. compresses it.
diff --git a/testcases/commands/logrotate/Makefile b/testcases/commands/logrotate/Makefile
deleted file mode 100644
index c3a701b87..000000000
--- a/testcases/commands/logrotate/Makefile
+++ /dev/null
@@ -1,31 +0,0 @@
-#
-#    commands/logrotate testcases Makefile.
-#
-#    Copyright (C) 2009, Cisco Systems Inc.
-#
-#    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
-#    the Free Software Foundation; either version 2 of the License, or
-#    (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU General Public License for more details.
-#
-#    You should have received a copy of the GNU General Public License along
-#    with this program; if not, write to the Free Software Foundation, Inc.,
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Ngie Cooper, July 2009
-#
-
-top_srcdir		?= ../../..
-
-include $(top_srcdir)/include/mk/env_pre.mk
-
-INSTALL_TARGETS		:= logrotate_tests.sh
-
-MAKE_TARGETS		:=
-
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/commands/logrotate/logrotate_tests.sh b/testcases/commands/logrotate/logrotate_tests.sh
deleted file mode 100755
index 1f3e61294..000000000
--- a/testcases/commands/logrotate/logrotate_tests.sh
+++ /dev/null
@@ -1,132 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-or-later
-# Copyright (c) International Business Machines Corp., 2001
-# Copyright (c) Linux Test Project, 2002-2024
-# Author: Manoj Iyer <manjo@mail.utexas.edu>
-#
-# Test Basic functionality of logrotate command.
-#
-# Test #1
-# Test that logrotate logrotate will rotate the logfile according to the
-# specifications in the config file.
-# - Create a config file that will rotate the /var/log/tst_logfile file.
-# - Use force option to force logrotate to cause the log file to be rotated.
-# - Compress the file after rotation.
-#
-# Test #2
-# Test that logrotate logrotate will rotate the logfile if the logfile
-# exceeds a certain size.
-# - Create a config file that will rotate the /var/log/tst_largelogfile.
-# - Run logrotate in a cron job that runs every minute.
-# - Add messages to the logfile until it gets rotated when a re-dittermined size
-#   is reached.
-
-TST_NEEDS_CMDS="crontab file grep logrotate"
-TST_TESTFUNC=test
-TST_NEEDS_TMPDIR=1
-TST_CNT=2
-TST_CLEANUP=cleanup
-
-cleanup()
-{
-	(crontab -l | grep -v tst_largelog) | crontab -
-	rm -rf /var/log/tst_logfile*
-	rm -rf /var/log/tst_largelogfile*
-}
-
-check_log()
-{
-	local file="$1"
-
-	EXPECT_PASS [ -f "$file" ]
-
-	if ! file "$file" | grep -q "gzip compressed data"; then
-		tst_res TFAIL "Failed to create a compressed file"
-	fi
-}
-
-test1()
-{
-	local group="syslog"
-
-	grep -q $group /etc/group || group="root"
-
-	cat >tst_logrotate.conf <<-EOF
-        #****** Begin Config file *******
-        # create new (empty) log files after rotating old ones
-        create
-
-        # compress the log files
-        compress
-
-        /var/log/tst_logfile {
-                su root $group
-                rotate 5
-                weekly
-        }
-        #****** End Config file *******
-	EOF
-
-	cat >/var/log/tst_logfile <<-EOF
-        #****** Begin Log File ********
-        # This is a dummy log file.
-        #****** End Log File ********
-	EOF
-
-	for i in $(seq 10); do
-		echo "This a dummy log file used to test logrotate command." >> /var/log/tst_logfile
-	done
-
-	ROD rm -f /var/log/tst_logfile.*
-	ROD chmod 644 tst_logrotate.conf
-	ROD logrotate -fv tst_logrotate.conf > tst_logrotate.out 2>&1
-
-	EXPECT_PASS grep -q "reading config file tst_logrotate.conf" tst_logrotate.out
-	EXPECT_PASS grep -q "forced from command line (5 rotations)" tst_logrotate.out
-	EXPECT_PASS grep -E -q "compressing new|log with" tst_logrotate.out
-
-	check_log /var/log/tst_logfile.1.gz
-}
-
-test2()
-{
-	cat >tst_largelog.conf <<-EOF
-        # create new (empty) log files after rotating old ones
-        create
-        # compress the log files
-        compress
-        # RPM packages drop log rotation information into this directory
-        include /etc/logrotate.d
-        /var/log/tst_largelogfile {
-            rotate 5
-            size=2k
-        }
-	EOF
-
-	ROD chmod 644 tst_largelog.conf
-
-	cat >/var/log/tst_largelogfile <<-EOF
-        # This is a psuedo-log file. This file will grow to a 2k size before
-        # getting rotated.
-	EOF
-
-	for i in $(seq 75); do
-		echo "Some text for testing rotation" >> /var/log/tst_largelogfile
-	done
-
-	# cron job for logrotating
-	(crontab -l 2>/dev/null; echo \
-		"* * * * * $(command -v logrotate) $(pwd)/tst_largelog.conf") | crontab -
-	if [ $? -ne 0 ]; then
-		tst_brk TBROK "Failed to create a cron job"
-	fi
-
-	# 5 sec for cron job to start, 1 min for logrotate to rotate the logs
-	tst_res TINFO "sleep 1 min to wait for rotating logs"
-	tst_sleep 65s
-
-	check_log /var/log/tst_largelogfile.1.gz
-}
-
-. tst_test.sh
-tst_run
diff --git a/testcases/commands/lsmod/.gitignore b/testcases/commands/lsmod/.gitignore
index 0e19fb3fd..ba8fca18a 100644
--- a/testcases/commands/lsmod/.gitignore
+++ b/testcases/commands/lsmod/.gitignore
@@ -1,9 +1,6 @@
 *.ko
 *.mod.c
-*.ko.cmd
-*.mod.cmd
-*.mod.o.cmd
-*.o.cmd
-.built-in.a.cmd
+*.cmd
 Module.symvers
 modules.order
+modules.livepatch
diff --git a/testcases/cve/cve-2014-0196.c b/testcases/cve/cve-2014-0196.c
index 9d20a3986..cd68e596c 100644
--- a/testcases/cve/cve-2014-0196.c
+++ b/testcases/cve/cve-2014-0196.c
@@ -3,7 +3,13 @@
  * Copyright (c) 2017 Richard Palethorpe <rpalethorpe@suse.com>
  * Original POC by Matthew Daley <mattd@bugfuzz.com>
  */
-/*
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2014-0196, which was fixed in kernel v3.15:
+ * 4291086b1f08 ("n_tty: Fix n_tty_write crash when echoing in raw mode").
+ *
  * This test attempts to cause a buffer overflow using the race condition
  * described in CVE-2014-0196. If the test is successful in causing an
  * overflow it will most likely result in an immediate Oops, restart or
@@ -17,9 +23,8 @@
  * have been kept even though they are not strictly necessary to reproduce the
  * bug.
  *
- * Further details:
- * see linux commit 4291086b1f081b869c6d79e5b7441633dc3ace00
- * privilege escalation POC https://www.exploit-db.com/exploits/33516/
+ * Further details see privilege escalation POC
+ * https://www.exploit-db.com/exploits/33516/.
  */
 
 #include <pty.h>
@@ -141,7 +146,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = run,
-	.max_runtime = 60,
+	.runtime = 60,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "4291086b1f08"},
 		{"CVE", "2014-0196"},
diff --git a/testcases/cve/cve-2015-3290.c b/testcases/cve/cve-2015-3290.c
index a2a8fcedd..63e5d92c9 100644
--- a/testcases/cve/cve-2015-3290.c
+++ b/testcases/cve/cve-2015-3290.c
@@ -177,7 +177,11 @@ static greg_t *csptr(ucontext_t *ctx)
 }
 #endif
 
+#define LDT_SS 0x7
+#define MAX_FAILS 1000
+
 static volatile long expected_rsp;
+static volatile int fail_count;
 static int running = 1;
 
 static void set_ldt(void)
@@ -195,18 +199,33 @@ static void set_ldt(void)
 		.useable	 = 0
 	};
 
-	TEST((int)tst_syscall(__NR_modify_ldt, 1, &data_desc,
-		sizeof(data_desc)));
-	if (TST_RET == -EINVAL) {
-		tst_brk(TCONF | TRERRNO,
+	TEST(tst_syscall(__NR_modify_ldt, 1, &data_desc, sizeof(data_desc)));
+
+	/*
+	 * The kernel intentionally casts modify_ldt() return value
+	 * to unsigned int to prevent sign extension to 64 bits. This may
+	 * result in syscall() returning the value as is instead of setting
+	 * errno and returning -1.
+	 */
+	if (TST_RET > 0 && ((int)TST_RET) < 0) {
+		tst_res(TINFO,
+			"WARNING: Libc mishandled modify_ldt() return value");
+		TST_ERR = -(int)TST_RET;
+		TST_RET = -1;
+	}
+
+	if (TST_RET == -1 && TST_ERR == EINVAL) {
+		tst_brk(TCONF | TTERRNO,
 			"modify_ldt: 16-bit data segments are probably disabled");
 	} else if (TST_RET != 0) {
-		tst_brk(TBROK | TRERRNO, "modify_ldt");
+		tst_brk(TBROK | TTERRNO, "modify_ldt");
 	}
 }
 
-static void try_corrupt_stack(unsigned short orig_ss)
+static void try_corrupt_stack(unsigned short *orig_ss)
 {
+	unsigned long flags = 0, new_ss = 0;
+
 #ifdef __x86_64__
 	asm volatile (
 	      /* A small puzzle for the curious reader. */
@@ -214,11 +233,13 @@ static void try_corrupt_stack(unsigned short orig_ss)
 
 	      /* Save rsp for diagnostics */
 	      "mov    %%rsp, %[expected_rsp] \n\t"
+	      "xorq   %%rax, %%rax    \n\t"
 
 	      /*
 	       * Let 'er rip.
 	       */
-	      "mov    %[ss], %%ss \n\t"   /* begin corruption */
+	      "mov    %[ss], %%edx \n\t"
+	      "mov    %%edx, %%ss \n\t"   /* begin corruption */
 	      "movl   $1000, %%edx    \n\t"
 	      "1:  decl   %%edx       \n\t"
 	      "jnz    1b      \n\t"
@@ -237,20 +258,18 @@ static void try_corrupt_stack(unsigned short orig_ss)
 	       * Stop further corruption.  We need to check CPL
 	       * first because we need RPL == CPL.
 	       */
-	      "mov    %[orig_ss], %%ss \n\t"  /* end corruption */
+	      "mov    (%[orig_ss]), %%ss \n\t"  /* end corruption */
 
 	      "subq   $128, %%rsp \n\t"
 	      "pushfq	 \n\t"
-	      "testl  $(1<<9),(%%rsp)   \n\t"
+	      "movq   (%%rsp),%%rdx	 \n\t"
 	      "addq   $136, %%rsp \n\t"
-	      "jz 3f      \n\t"
-	      "cmpl   %[ss], %%eax    \n\t"
-	      "je 4f      \n\t"
+	      "jmp    4f      \n\t"
 	      "3:  int3	   \n\t"
 	      "4:	     \n\t"
-	      : [expected_rsp] "=m" (expected_rsp)
-	      : [ss] "r" (0x7), [orig_ss] "m" (orig_ss)
-		 : "rax", "rcx", "rdx", "rbp", "r11", "flags"
+	      : [expected_rsp] "=m" (expected_rsp), "+d" (flags), "+a" (new_ss)
+	      : [ss] "n" (LDT_SS), [orig_ss] "r" (orig_ss)
+		 : "rcx", "rbp", "r11", "flags"
 	);
 #else
 	asm volatile (
@@ -260,11 +279,13 @@ static void try_corrupt_stack(unsigned short orig_ss)
 
 	      /* Save rsp for diagnostics */
 	      "mov    %%esp, %[expected_rsp] \n\t"
+	      "xorl   %%eax, %%eax    \n\t"
 
 	      /*
 	       * Let 'er rip.
 	       */
-	      "mov    %[ss], %%ss \n\t"   /* begin corruption */
+	      "mov    %[ss], %%edx \n\t"
+	      "mov    %%edx, %%ss \n\t"   /* begin corruption */
 	      "movl   $1000, %%edx    \n\t"
 	      "1:  .byte 0xff, 0xca   \n\t"   /* decl %edx */
 	      "jnz    1b      \n\t"
@@ -285,21 +306,30 @@ static void try_corrupt_stack(unsigned short orig_ss)
 	       * Stop further corruption.  We need to check CPL
 	       * first because we need RPL == CPL.
 	       */
-	      "mov    %[orig_ss], %%ss \n\t"  /* end corruption */
+	      "mov    (%[orig_ss]), %%ss \n\t"  /* end corruption */
 
 	      "pushf	  \n\t"
-	      "testl  $(1<<9),(%%esp)   \n\t"
+	      "movl   (%%esp), %%edx \n\t"
 	      "addl   $4, %%esp   \n\t"
-	      "jz 3f      \n\t"
-	      "cmpl   %[ss], %%eax    \n\t"
-	      "je 4f      \n\t"
+	      "jmp    4f      \n\t"
 	      "3:  int3	   \n\t"
 	      "4:  mov %%esi, %%ebp   \n\t"
-	      : [expected_rsp] "=m" (expected_rsp)
-	      : [ss] "r" (0x7), [orig_ss] "m" (orig_ss)
-		 : "eax", "ecx", "edx", "esi", "flags"
+	      : [expected_rsp] "=m" (expected_rsp), "+d" (flags), "+a" (new_ss)
+	      : [ss] "n" (LDT_SS), [orig_ss] "r" (orig_ss)
+		 : "ecx", "esi", "ebp", "flags"
 	);
 #endif
+
+	if (!(flags & (1 << 9))) {
+		tst_res(TFAIL, "Interrupt flag is disabled (0x%lx)", flags);
+		fail_count++;
+	}
+
+	if (new_ss != LDT_SS) {
+		tst_res(TFAIL, "Wrong stack selector 0x%lx, expected 0x%x",
+			new_ss, LDT_SS);
+		fail_count++;
+	}
 }
 
 static int perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
@@ -315,10 +345,14 @@ static int perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
 static int event_mlock_kb;
 static int max_sample_rate;
 
-static void *child_thread(void *arg LTP_ATTRIBUTE_UNUSED)
+static void *child_thread(void *arg)
 {
+	/*
+	 * orig_ss must not be accessed via address relative to %esp,
+	 * otherwise mov %[orig_ss], %%ss above will always segfault
+	 */
+	unsigned short *orig_ss = arg;
 	long niter = 0;
-	unsigned short orig_ss;
 
 	struct perf_event_attr pe = {
 		.size = sizeof(struct perf_event_attr),
@@ -375,7 +409,7 @@ static void *child_thread(void *arg LTP_ATTRIBUTE_UNUSED)
 		SAFE_CLOSE(fd);
 	}
 
-	asm volatile ("mov %%ss, %0" : "=rm" (orig_ss));
+	asm volatile ("mov %%ss, (%0)" :: "r" (orig_ss));
 
 	for (niter = 0; running && niter < 1000*1000*1000L; niter++) {
 
@@ -387,6 +421,12 @@ static void *child_thread(void *arg LTP_ATTRIBUTE_UNUSED)
 		 * the system.
 		 */
 		syscall(0x3fffffff);
+
+		if (fail_count >= MAX_FAILS) {
+			tst_res(TINFO, "Too many failures, exiting");
+			running = 0;
+			break;
+		}
 	}
 
 	for (i = 0; i < ARRAY_SIZE(perf_events); i++)
@@ -401,6 +441,7 @@ static void do_child(void)
 	int i, ncpus;
 	pthread_t *threads;
 	long iter, total_iter = 0;
+	unsigned short *orig_ss;
 
 	tst_res(TINFO, "attempting to corrupt nested NMI stack state");
 
@@ -408,19 +449,28 @@ static void do_child(void)
 
 	ncpus = tst_ncpus();
 	threads = SAFE_MALLOC(sizeof(*threads) * ncpus);
+	orig_ss = SAFE_MALLOC(sizeof(unsigned short) * ncpus);
 
-	for (i = 0; i < ncpus; i++)
-		SAFE_PTHREAD_CREATE(&threads[i], NULL, child_thread, NULL);
+	for (i = 0; i < ncpus; i++) {
+		SAFE_PTHREAD_CREATE(&threads[i], NULL, child_thread,
+			&orig_ss[i]);
+	}
+
+	while (running && tst_remaining_runtime())
+		sleep(1);
 
-	sleep(tst_remaining_runtime());
 	running = 0;
 
 	for (i = 0; i < ncpus; i++) {
 		SAFE_PTHREAD_JOIN(threads[i], (void **)&iter);
 		total_iter += iter;
 	}
+	free(orig_ss);
 	free(threads);
 
+	if (fail_count)
+		exit(1);
+
 	tst_res(TPASS, "can't corrupt nested NMI state after %ld iterations",
 		total_iter);
 }
@@ -454,10 +504,14 @@ static void run(void)
 	}
 
 	SAFE_WAITPID(pid, &status, 0);
-	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV)
+	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
 		tst_res(TFAIL, "corrupted NMI stack");
-	else if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
-		tst_res(WEXITSTATUS(status), "Propogate child status");
+	} else if (WIFSIGNALED(status)) {
+		tst_res(TFAIL, "Child killed by unexpected signal %s",
+			tst_strsig(WTERMSIG(status)));
+	} else if (WIFEXITED(status) && WEXITSTATUS(status) != 0) {
+		tst_res(WEXITSTATUS(status), "Propagate child status");
+	}
 }
 
 static struct tst_test test = {
@@ -465,7 +519,7 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.needs_checkpoints = 1,
 	.setup = setup,
-	.max_runtime = 180,
+	.runtime = 180,
 	.test_all = run,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "9b6e6a8334d5"},
diff --git a/testcases/cve/cve-2016-10044.c b/testcases/cve/cve-2016-10044.c
index 6a8c77f3e..31c73f534 100644
--- a/testcases/cve/cve-2016-10044.c
+++ b/testcases/cve/cve-2016-10044.c
@@ -3,9 +3,12 @@
  * Copyright (c) 2017 Richard Palethorpe <rpalethorpe@suse.com>
  * Copyright (c) 2016 Jan Horn <jann@thejh.net>
  */
-/*
- * Test for CVE-2016-10044, which was fixed in commit
- * 22f6b4d34fcf039c aio: mark AIO pseudo-fs noexec.
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2016-10044, which was fixed in kernel v4.8:
+ * 22f6b4d34fcf ("aio: mark AIO pseudo-fs noexec").
  *
  * The test checks that we can not implicitly mark AIO mappings as
  * executable using the READ_IMPLIES_EXEC personality.
diff --git a/testcases/cve/cve-2016-7042.c b/testcases/cve/cve-2016-7042.c
index 4434265dd..7611f6638 100644
--- a/testcases/cve/cve-2016-7042.c
+++ b/testcases/cve/cve-2016-7042.c
@@ -4,15 +4,12 @@
  * Author: Guangwen Feng <fenggw-fnst@cn.fujitsu.com>
  */
 
-/*
- * Test for CVE-2016-7042, this regression test can crash the buggy kernel
- * when the stack-protector is enabled, and the bug was fixed in:
+/*\
+ * [Description]
  *
- *  commit 03dab869b7b239c4e013ec82aea22e181e441cfc
- *  Author: David Howells <dhowells@redhat.com>
- *  Date:   Wed Oct 26 15:01:54 2016 +0100
- *
- *  KEYS: Fix short sprintf buffer in /proc/keys show function
+ * Test for CVE-2016-7042, this regression test can crash the buggy kernel
+ * when the stack-protector is enabled, and the bug was fixed in kernel v4.9:
+ * 03dab869b7b2 ("KEYS: Fix short sprintf buffer in /proc/keys show function").
  */
 
 #include <errno.h>
diff --git a/testcases/cve/cve-2016-7117.c b/testcases/cve/cve-2016-7117.c
index 109333985..119eb2f9a 100644
--- a/testcases/cve/cve-2016-7117.c
+++ b/testcases/cve/cve-2016-7117.c
@@ -2,13 +2,17 @@
 /*
  * Copyright (c) 2017 Richard Palethorpe <rpalethorpe@suse.com>
  */
-/*
- * CVE-2016-7117
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2016-7117, which was fixed in kernel v4.6:
+ * 34b88a68f26a ("net: Fix use after free in the recvmmsg exit path").
  *
- * This tests for a use after free caused by a race between recvmmsg() and
- * close(). The exit path for recvmmsg() in (a2e2725541f: net: Introduce
- * recvmmsg socket syscall) called fput() on the active file descriptor before
- * checking the error state and setting the socket's error field.
+ * Tests for a use after free caused by a race between recvmmsg() and close().
+ * The exit path for recvmmsg() in (a2e2725541f: net: Introduce recvmmsg socket
+ * syscall) called fput() on the active file descriptor before checking the
+ * error state and setting the socket's error field.
  *
  * If one or more messages are received by recvmmsg() followed by one which
  * fails, the socket's error field will be set. If just after recvmmsg() calls
@@ -149,9 +153,9 @@ static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 60,
+	.runtime = 60,
 	.tags = (const struct tst_tag[]) {
-		{"linux-git", "a2e2725541fa"},
+		{"linux-git", "34b88a68f26a"},
 		{"CVE", "2016-7117"},
 		{}
 	}
diff --git a/testcases/cve/cve-2017-16939.c b/testcases/cve/cve-2017-16939.c
index 187473986..ec23f10c6 100644
--- a/testcases/cve/cve-2017-16939.c
+++ b/testcases/cve/cve-2017-16939.c
@@ -2,14 +2,17 @@
 /*
  * Copyright (c) 2018 Michael Moese <mmoese@suse.de>
  */
-/* Regression test for commit:
- * 1137b5e2529a ipsec: Fix aborted xfrm policy dump crash aka CVE-2017-16939
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-16939, which was fixed in kernel v4.14:
+ * 1137b5e2529a ("ipsec: Fix aborted xfrm policy dump crash").
  *
  * Based on the reproducing code from Mohammed Ghannam, published on
  * https://blogs.securiteam.com/index.php/archives/3535
  *
- * CAUTION! If your system is vulnerable to this CVE, the kernel
- * WILL DIE!
+ * CAUTION! If your system is vulnerable to this CVE, the crashes kernel.
  */
 
 #include <unistd.h>
diff --git a/testcases/cve/cve-2017-17052.c b/testcases/cve/cve-2017-17052.c
index b97815708..598cd9b52 100644
--- a/testcases/cve/cve-2017-17052.c
+++ b/testcases/cve/cve-2017-17052.c
@@ -1,15 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2018 Michael Moese <mmoese@suse.com>
+ * Based on the reproducer from Eric Biggers.
  */
-/*
- * Test for CVE-2017-17052, original reproducer taken from kernel commit:
- * 2b7e8665b4ff51c034c55df3cff76518d1a9ee3a
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-17052, which was fixed in kernel v4.13:
+ * 2b7e8665b4ff ("fork: fix incorrect fput of ->exe_file causing use-after-free").
  *
- * CAUTION!!
- * This test will crash unpatched kernels!
- * Use at your own risk!
+ * Based on the reproducer taken from fixing kernel commit.
  *
+ * CAUTION! If your system is vulnerable to this CVE, the crashes kernel.
  */
 
 #include <unistd.h>
diff --git a/testcases/cve/cve-2017-17053.c b/testcases/cve/cve-2017-17053.c
index a4c418986..a6cf2551e 100644
--- a/testcases/cve/cve-2017-17053.c
+++ b/testcases/cve/cve-2017-17053.c
@@ -1,12 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2018 Michael Moese <mmoese@suse.com>
+ * Based on the reproducer from Eric Biggers.
  */
-/* Regression test for CVE-2017-17053, original reproducer can be found
- * here:
- * https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ccd5b3235180eef3cfec337df1c8554ab151b5cc
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-17053, which was fixed in kernel 4.13:
+ * ccd5b3235180 ("x86/mm: Fix use-after-free of ldt_struct").
+ *
+ * Based on the reproducer taken from fixing kernel commit.
  *
- * Be careful! This test may crash your kernel!
+ * Test may crash the kernel.
  */
 
 #include "config.h"
diff --git a/testcases/cve/cve-2017-2618.c b/testcases/cve/cve-2017-2618.c
index 4ab3cfb8f..7d1aca15c 100644
--- a/testcases/cve/cve-2017-2618.c
+++ b/testcases/cve/cve-2017-2618.c
@@ -4,15 +4,13 @@
  * Author: Guangwen Feng <fenggw-fnst@cn.fujitsu.com>
  */
 
-/*
- * Test for CVE-2017-2618, this regression test can crash
- * the buggy kernel, and the bug was fixed in:
+/*\
+ * [Description]
  *
- *  commit 0c461cb727d146c9ef2d3e86214f498b78b7d125
- *  Author: Stephen Smalley <sds@tycho.nsa.gov>
- *  Date:   Tue Jan 31 11:54:04 2017 -0500
+ * Test for CVE-2017-2618, which was fixed in kernel v4.10:
+ * 0c461cb727d1 ("selinux: fix off-by-one in setprocattr").
  *
- *  selinux: fix off-by-one in setprocattr
+ * Test may crash the kernel.
  */
 
 #include <errno.h>
diff --git a/testcases/cve/cve-2017-2671.c b/testcases/cve/cve-2017-2671.c
index 9092481de..3c28317e2 100644
--- a/testcases/cve/cve-2017-2671.c
+++ b/testcases/cve/cve-2017-2671.c
@@ -3,8 +3,12 @@
  * Copyright (c) 2017 Richard Palethorpe <rpalethorpe@suse.com>
  * Original POC by Daniel Jiang
  */
-/*
- * Test for CVE-2017-2671 faulty locking on ping socket
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-2671 faulty locking on ping socket fixed in kernel v4.11:
+ * 43a6684519ab ("ping: implement proper locking").
  *
  * When sys_connect() is called with sockaddr.sin_family set to AF_UNSPEC on a
  * ping socket; __udp_disconnect() gets called, which in turn calls the buggy
@@ -13,8 +17,6 @@
  * underneath it in the time between calling sk_hashed() and gaining the write
  * lock.
  *
- * Fixed in commit 43a6684519ab0a6c52024b5e25322476cabad893
- *
  * This test repeatedly 'connects' a ping socket correctly then calls
  * connect() with AF_UNSPEC in two seperate threads to trigger the race
  * condition. If the bug is present, then the test will most likely crash the
@@ -109,7 +111,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.cleanup = cleanup,
 	.needs_root = 1,
-	.max_runtime = 40,
+	.runtime = 40,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "43a6684519ab"},
 		{"CVE", "2017-2671"},
diff --git a/testcases/cve/cve-2022-4378.c b/testcases/cve/cve-2022-4378.c
index 402fa3330..95c0fa517 100644
--- a/testcases/cve/cve-2022-4378.c
+++ b/testcases/cve/cve-2022-4378.c
@@ -4,16 +4,13 @@
  */
 
 /*\
- * CVE 2022-4378
+ * [Description]
  *
- * Check that writing several pages worth of whitespace into /proc/sys files
- * does not cause kernel stack overflow. Kernel bug fixed in:
- *
- * commit bce9332220bd677d83b19d21502776ad555a0e73
- * Author: Linus Torvalds <torvalds@linux-foundation.org>
- * Date:   Mon Dec 5 12:09:06 2022 -0800
+ * Test for CVE-2022-4378 fixed in kernel v6.1:
+ * bce9332220bd ("proc: proc_skip_spaces() shouldn't think it is working on C strings").
  *
- * proc: proc_skip_spaces() shouldn't think it is working on C strings
+ * Check that writing several pages worth of whitespace into /proc/sys files
+ * does not cause kernel stack overflow.
  */
 
 #include <stdlib.h>
diff --git a/testcases/cve/icmp_rate_limit01.c b/testcases/cve/icmp_rate_limit01.c
index 8ee50a276..f71be0e08 100644
--- a/testcases/cve/icmp_rate_limit01.c
+++ b/testcases/cve/icmp_rate_limit01.c
@@ -6,21 +6,16 @@
  */
 
 /*\
- * CVE-2020-25705
+ * [Description]
+ *
+ * Test for CVE-2020-25705 fixed in kernel v5.10:
+ * b38e7819cae9 ("icmp: randomize the global rate limiter").
  *
  * Test of ICMP rate limiting behavior that may be abused for DNS cache
  * poisoning attack. Send a few batches of 100 packets to a closed UDP port
  * and count the ICMP errors. If the number of errors is always the same
  * for each batch (not randomized), the system is vulnerable. Send packets
  * from multiple IP addresses to bypass per-address ICMP throttling.
- *
- * Fixed in:
- *
- *  commit b38e7819cae946e2edf869e604af1e65a5d241c5
- *  Author: Eric Dumazet <edumazet@google.com>
- *  Date:   Thu Oct 15 11:42:00 2020 -0700
- *
- *  icmp: randomize the global rate limiter
  */
 
 #include <time.h>
diff --git a/testcases/cve/meltdown.c b/testcases/cve/meltdown.c
index 398e496a9..c2145291d 100644
--- a/testcases/cve/meltdown.c
+++ b/testcases/cve/meltdown.c
@@ -3,6 +3,14 @@
  * Copyright (c) 2018 Pavel Boldin <pboldin@cloudlinux.com>
  */
 
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-5754 (Meltdown).
+ *
+ * https://meltdownattack.com/
+ */
+
 #include "config.h"
 #include "tst_test.h"
 
diff --git a/testcases/cve/tcindex01.c b/testcases/cve/tcindex01.c
index e9c8a9a90..4e4a62fdb 100644
--- a/testcases/cve/tcindex01.c
+++ b/testcases/cve/tcindex01.c
@@ -6,18 +6,15 @@
  */
 
 /*\
+ * [Description]
+ *
  * CVE-2023-1829
  *
  * Test for use-after-free after removing tcindex traffic filter with certain
  * parameters.
  *
- * Tcindex filter removed in:
- *
- *  commit 8c710f75256bb3cf05ac7b1672c82b92c43f3d28
- *  Author: Jamal Hadi Salim <jhs@mojatatu.com>
- *  Date:   Tue Feb 14 08:49:14 2023 -0500
- *
- *  net/sched: Retire tcindex classifier
+ * Tcindex filter was removed in kernel v6.3:
+ * 8c710f75256b ("net/sched: Retire tcindex classifier")
  */
 
 #include <linux/netlink.h>
diff --git a/testcases/kernel/controllers/cgroup/cgroup_core02.c b/testcases/kernel/controllers/cgroup/cgroup_core02.c
index 733e88ee7..b19bf2e58 100644
--- a/testcases/kernel/controllers/cgroup/cgroup_core02.c
+++ b/testcases/kernel/controllers/cgroup/cgroup_core02.c
@@ -32,6 +32,8 @@
 #include "tst_safe_file_at.h"
 #include "lapi/sched.h"
 
+#define STACK_SIZE 65536
+
 static struct tst_cg_group *cg_child_a, *cg_child_b;
 static uid_t nobody_uid;
 
@@ -51,7 +53,7 @@ static int lesser_ns_open_thread_fn(void *arg)
 static void test_lesser_ns_open(void)
 {
 	int i;
-	static char stack[65536];
+	char *stack;
 	pid_t pid;
 	int status;
 	struct lesser_ns_open_thread_arg targ = { .fds = {0}, .loops = -1};
@@ -63,14 +65,19 @@ static void test_lesser_ns_open(void)
 		SAFE_CG_PRINT(cg_child_a, "cgroup.procs", "0");
 		SAFE_CG_FCHOWN(cg_child_a, "cgroup.procs",  nobody_uid, -1);
 		SAFE_CG_FCHOWN(cg_child_b, "cgroup.procs",  nobody_uid, -1);
+		stack = SAFE_MMAP(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,
+			MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
 		pid  = ltp_clone(CLONE_NEWCGROUP | CLONE_FILES | CLONE_VM | SIGCHLD,
-					lesser_ns_open_thread_fn, &targ, 65536, stack);
+					lesser_ns_open_thread_fn, &targ, STACK_SIZE, stack);
+
 		if (pid < 0)  {
 			tst_res(TFAIL, "unexpected negative pid %d", pid);
 			exit(1);
 		}
 
 		SAFE_WAITPID(pid, &status, 0);
+		SAFE_MUNMAP(stack, STACK_SIZE);
+
 		for (i = 0; i < targ.loops; i++) {
 			if (targ.fds[i] < 1) {
 				tst_res(TFAIL, "unexpected negative fd %d", targ.fds[i]);
diff --git a/testcases/kernel/controllers/cgroup/cgroup_core03.c b/testcases/kernel/controllers/cgroup/cgroup_core03.c
index 7d40d47f9..c0c3485e6 100644
--- a/testcases/kernel/controllers/cgroup/cgroup_core03.c
+++ b/testcases/kernel/controllers/cgroup/cgroup_core03.c
@@ -124,7 +124,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.forks_child = 1,
-	.max_runtime = 20,
+	.timeout = 20,
 	.needs_cgroup_ctrls = (const char *const []){ "base", NULL },
 	.needs_cgroup_ver = TST_CG_V2,
 	.needs_checkpoints = 1,
diff --git a/testcases/kernel/controllers/cgroup_fj/cgroup_fj_common.sh b/testcases/kernel/controllers/cgroup_fj/cgroup_fj_common.sh
index 6d5586534..153d351d7 100755
--- a/testcases/kernel/controllers/cgroup_fj/cgroup_fj_common.sh
+++ b/testcases/kernel/controllers/cgroup_fj/cgroup_fj_common.sh
@@ -76,6 +76,14 @@ common_cleanup()
     [ -d "$start_path" ] && find "$start_path" -depth -type d -exec rmdir '{}' \;
 
     cgroup_cleanup
+
+    if [ "$cgroup_version" = "2" ]; then
+        case "$subsystem" in
+        cpu|io|memory|pids)
+            :;;
+        *) ROD echo "-$subsystem" \> "/sys/fs/cgroup/cgroup.subtree_control";;
+        esac
+    fi
 }
 
 . cgroup_lib.sh
diff --git a/testcases/kernel/controllers/cgroup_xattr/cgroup_xattr.c b/testcases/kernel/controllers/cgroup_xattr/cgroup_xattr.c
index a870118f5..0d016b583 100644
--- a/testcases/kernel/controllers/cgroup_xattr/cgroup_xattr.c
+++ b/testcases/kernel/controllers/cgroup_xattr/cgroup_xattr.c
@@ -151,11 +151,8 @@ void setup(int argc, char *argv[])
 		tst_brkm(TCONF, NULL, "Kernel doesn't support cgroups");
 
 	for (i = 0; i < ARRAY_SIZE(tkeys); ++i) {
-		if (!strcmp(tkeys[i].name, "security.")) {
-			tkeys[i].good = tst_kvercmp(3, 15, 0) < 0;
-		} else if (!strcmp(tkeys[i].name, "trusted.")) {
+		if (!strcmp(tkeys[i].name, "trusted."))
 			tkeys[i].good = tst_kvercmp(4, 5, 0) < 0;
-		}
 	}
 
 	int value_size = DEFAULT_VALUE_SIZE;
@@ -269,12 +266,7 @@ int mount_cgroup(void)
 		 * additional "xattr" option. In that case, mount will succeed,
 		 * but xattr won't be supported in the new mount anyway.
 		 * Should be removed as soon as a fix committed to upstream.
-		 *
-		 * But not applicable for kernels >= 3.15 where xattr supported
-		 * natively.
 		 */
-		if (hier != 0 && tst_kvercmp(3, 15, 0) < 0)
-			continue;
 
 		int i, found = 0;
 		for (i = 0; i < cgrp_opt_num; ++i) {
diff --git a/testcases/kernel/controllers/cpuset/cpuset_regression_test.sh b/testcases/kernel/controllers/cpuset/cpuset_regression_test.sh
index bedc48110..38eb28820 100755
--- a/testcases/kernel/controllers/cpuset/cpuset_regression_test.sh
+++ b/testcases/kernel/controllers/cpuset/cpuset_regression_test.sh
@@ -15,7 +15,6 @@ TST_CLEANUP=cleanup
 TST_TESTFUNC=do_test
 TST_NEEDS_ROOT=1
 TST_NEEDS_TMPDIR=1
-TST_MIN_KVER="3.18"
 
 LOCAL_MOUNTPOINT="cpuset_test"
 BACKUP_DIRECTORY="cpuset_backup"
diff --git a/testcases/kernel/crypto/af_alg01.c b/testcases/kernel/crypto/af_alg01.c
index 7cefe5946..2100b3698 100644
--- a/testcases/kernel/crypto/af_alg01.c
+++ b/testcases/kernel/crypto/af_alg01.c
@@ -21,6 +21,7 @@ static void test_with_hash_alg(const char *hash_algname)
 {
 	char hmac_algname[64];
 	char key[4096] = { 0 };
+	int ret;
 
 	if (!tst_have_alg("hash", hash_algname))
 		return;
@@ -30,7 +31,9 @@ static void test_with_hash_alg(const char *hash_algname)
 		return;
 
 	sprintf(hmac_algname, "hmac(hmac(%s))", hash_algname);
-	if (tst_try_alg("hash", hmac_algname) != ENOENT) {
+
+	ret = tst_try_alg("hash", hmac_algname);
+	if (ret != ENOENT && ret != EINVAL) {
 		int algfd;
 
 		tst_res(TFAIL, "instantiated nested hmac algorithm ('%s')!",
diff --git a/testcases/kernel/crypto/af_alg02.c b/testcases/kernel/crypto/af_alg02.c
index 40d07ca90..0fc241146 100644
--- a/testcases/kernel/crypto/af_alg02.c
+++ b/testcases/kernel/crypto/af_alg02.c
@@ -77,7 +77,7 @@ static void run(void)
 
 static struct tst_test test = {
 	.test_all = run,
-	.max_runtime = 20,
+	.runtime = 20,
 	.needs_checkpoints = 1,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "ecaaab564978"},
diff --git a/testcases/kernel/crypto/af_alg03.c b/testcases/kernel/crypto/af_alg03.c
index bb8d480e2..161515ad5 100644
--- a/testcases/kernel/crypto/af_alg03.c
+++ b/testcases/kernel/crypto/af_alg03.c
@@ -15,10 +15,13 @@
 
 static void run(void)
 {
+	int ret;
+
 	tst_require_alg("aead", "rfc7539(chacha20,poly1305)");
 	tst_require_alg("hash", "sha256");
 
-	if (tst_try_alg("aead", "rfc7539(chacha20,sha256)") != ENOENT) {
+	ret = tst_try_alg("aead", "rfc7539(chacha20,sha256)");
+	if (ret != ENOENT && ret != EINVAL) {
 		tst_res(TFAIL,
 			"instantiated rfc7539 template with wrong digest size");
 	} else {
diff --git a/testcases/kernel/crypto/af_alg07.c b/testcases/kernel/crypto/af_alg07.c
index 9c2516632..b18d40a6f 100644
--- a/testcases/kernel/crypto/af_alg07.c
+++ b/testcases/kernel/crypto/af_alg07.c
@@ -125,7 +125,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.min_kver = "4.10.0",
 	.min_cpus = 2,
-	.max_runtime = 150,
+	.runtime = 150,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "ff7b11aa481f"},
diff --git a/testcases/kernel/crypto/pcrypt_aead01.c b/testcases/kernel/crypto/pcrypt_aead01.c
index 3979f317a..3dc2b604e 100644
--- a/testcases/kernel/crypto/pcrypt_aead01.c
+++ b/testcases/kernel/crypto/pcrypt_aead01.c
@@ -75,7 +75,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.cleanup = cleanup,
 	.needs_root = 1,
-	.max_runtime = 300,
+	.runtime = 300,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "d76c68109f37"},
 		{"CVE", "2017-18075"},
diff --git a/testcases/kernel/device-drivers/acpi/ltp_acpi.c b/testcases/kernel/device-drivers/acpi/ltp_acpi.c
index 7dba04552..2c0cc562b 100644
--- a/testcases/kernel/device-drivers/acpi/ltp_acpi.c
+++ b/testcases/kernel/device-drivers/acpi/ltp_acpi.c
@@ -130,11 +130,10 @@ int main(int argc, char *argv[])
 	int acpi_disabled;
 
 	tst_parse_opts(argc, argv, NULL, NULL);
-
 	tst_require_root();
-
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
+	tst_requires_module_signature_disabled();
 	tst_module_load(NULL, module_name, NULL);
 	module_loaded = 1;
 
diff --git a/testcases/kernel/device-drivers/block/block_dev_kernel/ltp_block_dev.c b/testcases/kernel/device-drivers/block/block_dev_kernel/ltp_block_dev.c
index 17047c0d5..0fd278981 100644
--- a/testcases/kernel/device-drivers/block/block_dev_kernel/ltp_block_dev.c
+++ b/testcases/kernel/device-drivers/block/block_dev_kernel/ltp_block_dev.c
@@ -12,8 +12,10 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/fs.h>
-#include <linux/genhd.h>
 #include <linux/blkdev.h>
+#ifndef DISK_NAME_LEN
+# include <linux/genhd.h>
+#endif
 
 MODULE_AUTHOR("Mrton Nmeth <nm127@freemail.hu>");
 MODULE_AUTHOR("Copyright (c) 2013 Oracle and/or its affiliates");
diff --git a/testcases/kernel/device-drivers/block/block_dev_user/block_dev.c b/testcases/kernel/device-drivers/block/block_dev_user/block_dev.c
index 543c36795..38ec1d6d6 100644
--- a/testcases/kernel/device-drivers/block/block_dev_user/block_dev.c
+++ b/testcases/kernel/device-drivers/block/block_dev_user/block_dev.c
@@ -1,21 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2013 Oracle and/or its affiliates. All Rights Reserved.
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
  * Author: Alexey Kodanev <alexey.kodanev@oracle.com>
+ */
+
+/*\
+ * [Description]
  *
  * Test checks block device kernel API.
  */
@@ -26,74 +17,60 @@
 #include <unistd.h>
 #include <string.h>
 
-#include "test.h"
-#include "safe_macros.h"
-#include "old_module.h"
+#include "tst_test.h"
+#include "tst_module.h"
 
-char *TCID = "block_dev";
-int TST_TOTAL = 9;
+#define MODULE_NAME "ltp_block_dev"
+#define MODULE_NAME_KO	MODULE_NAME ".ko"
 
-static const char module_name[]	= "ltp_block_dev.ko";
 static const char dev_result[]	= "/sys/devices/ltp_block_dev/result";
 static const char dev_tcase[]	= "/sys/devices/ltp_block_dev/tcase";
-static int module_loaded;
 
-static int run_all_testcases;
-static const option_t options[] = {
-	{"a", &run_all_testcases, NULL},
-	{NULL, NULL, NULL}
+static int module_loaded;
+static char *run_all_testcases;
+static struct tst_option options[] = {
+	{"a",  &run_all_testcases, "-a\tRun all test-cases (can crash the kernel)"},
+	{}
 };
 
 static void cleanup(void)
 {
 	if (module_loaded)
-		tst_module_unload(NULL, module_name);
+		tst_module_unload(MODULE_NAME_KO);
 }
 
-static void help(void)
+static void run(unsigned int n)
 {
-	printf("  -a      Run all test-cases (can crash the kernel)\n");
-}
-
-void setup(int argc, char *argv[])
-{
-	tst_parse_opts(argc, argv, options, help);
-
-	tst_require_root();
+	tst_requires_module_signature_disabled();
 
-	tst_sig(FORK, DEF_HANDLER, cleanup);
-}
-
-static void test_run(void)
-{
-	int off = 0;
 	/*
 	 * test-cases #8 and #9 can crash the kernel.
 	 * We have to wait for kernel fix where register_blkdev() &
 	 * unregister_blkdev() checks the input device name parameter
 	 * against NULL pointer.
 	 */
-	if (!run_all_testcases)
-		off = 2;
-
-	tst_module_load(cleanup, module_name, NULL);
-	module_loaded = 1;
-
-	int i, pass = 0;
-	for (i = 0; i < TST_TOTAL - off; ++i) {
-		SAFE_FILE_PRINTF(cleanup, dev_tcase, "%d", i + 1);
-		SAFE_FILE_SCANF(cleanup, dev_result, "%d", &pass);
-		tst_resm((pass) ? TPASS : TFAIL, "Test-case '%d'", i + 1);
+	n++;
+	if (!run_all_testcases && (n == 8 || n == 9)) {
+		tst_res(TCONF, "Skipped n = %d", n);
+		return;
 	}
-}
 
-int main(int argc, char *argv[])
-{
-	setup(argc, argv);
-
-	test_run();
+	if (!module_loaded) {
+		tst_module_load(MODULE_NAME_KO, NULL);
+		module_loaded = 1;
+	}
 
-	cleanup();
+	int pass = 0;
 
-	tst_exit();
+	SAFE_FILE_PRINTF(dev_tcase, "%d", n);
+	SAFE_FILE_SCANF(dev_result, "%d", &pass);
+	tst_res((pass) ? TPASS : TFAIL, "Test-case '%d'", n);
 }
+
+static struct tst_test test = {
+	.needs_root = 1,
+	.cleanup = cleanup,
+	.test = run,
+	.tcnt = 9,
+	.options = options,
+};
diff --git a/testcases/kernel/device-drivers/pci/tpci_kernel/.gitignore b/testcases/kernel/device-drivers/pci/tpci_kernel/.gitignore
index 3e100ad5e..ed4712e3a 100644
--- a/testcases/kernel/device-drivers/pci/tpci_kernel/.gitignore
+++ b/testcases/kernel/device-drivers/pci/tpci_kernel/.gitignore
@@ -5,3 +5,4 @@
 /.*.ko
 /.*.cmd
 /Module.symvers
+modules.livepatch
diff --git a/testcases/kernel/device-drivers/pci/tpci_user/tpci.c b/testcases/kernel/device-drivers/pci/tpci_user/tpci.c
index 96018f18c..5d241fb42 100644
--- a/testcases/kernel/device-drivers/pci/tpci_user/tpci.c
+++ b/testcases/kernel/device-drivers/pci/tpci_user/tpci.c
@@ -50,8 +50,8 @@ static void cleanup(void)
 void setup(void)
 {
 	tst_require_root();
-
 	tst_sig(FORK, DEF_HANDLER, cleanup);
+	tst_requires_module_signature_disabled();
 }
 
 static void run_pci_testcases(int bus, int slot)
diff --git a/testcases/kernel/device-drivers/uaccess/.gitignore b/testcases/kernel/device-drivers/uaccess/.gitignore
index cf59b68df..c42a3fbe5 100644
--- a/testcases/kernel/device-drivers/uaccess/.gitignore
+++ b/testcases/kernel/device-drivers/uaccess/.gitignore
@@ -6,3 +6,4 @@
 /.*.ko
 /.*.cmd
 /Module.symvers
+modules.livepatch
diff --git a/testcases/kernel/device-drivers/uaccess/uaccess.c b/testcases/kernel/device-drivers/uaccess/uaccess.c
index f682ff7f6..ab6fa58a7 100644
--- a/testcases/kernel/device-drivers/uaccess/uaccess.c
+++ b/testcases/kernel/device-drivers/uaccess/uaccess.c
@@ -95,9 +95,9 @@ int main(int argc, char *argv[])
 	tst_parse_opts(argc, argv, NULL, NULL);
 
 	tst_require_root();
-
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
+	tst_requires_module_signature_disabled();
 	tst_module_load(NULL, module_name, NULL);
 	module_loaded = 1;
 
diff --git a/testcases/kernel/firmware/fw_load_kernel/.gitignore b/testcases/kernel/firmware/fw_load_kernel/.gitignore
index 180072a72..6fc82952c 100644
--- a/testcases/kernel/firmware/fw_load_kernel/.gitignore
+++ b/testcases/kernel/firmware/fw_load_kernel/.gitignore
@@ -4,3 +4,4 @@
 /Module.symvers
 /ltp_fw_load.mod.c
 /.tmp_versions/
+modules.livepatch
diff --git a/testcases/kernel/firmware/fw_load_user/fw_load.c b/testcases/kernel/firmware/fw_load_user/fw_load.c
index 83648b625..b2ed09e6f 100644
--- a/testcases/kernel/firmware/fw_load_user/fw_load.c
+++ b/testcases/kernel/firmware/fw_load_user/fw_load.c
@@ -102,7 +102,6 @@ static void help(void)
 
 void setup(int argc, char *argv[])
 {
-	
 	tst_parse_opts(argc, argv, options, help);
 
 	if (nflag) {
@@ -113,6 +112,7 @@ void setup(int argc, char *argv[])
 	}
 
 	tst_require_root();
+	tst_requires_module_signature_disabled();
 
 	char fw_size_param[19];
 	snprintf(fw_size_param, 19, "fw_size=%d", fw_size);
diff --git a/testcases/kernel/fs/fs_bind/fs_bind_lib.sh b/testcases/kernel/fs/fs_bind/fs_bind_lib.sh
index 52190a7ca..723374737 100644
--- a/testcases/kernel/fs/fs_bind/fs_bind_lib.sh
+++ b/testcases/kernel/fs/fs_bind/fs_bind_lib.sh
@@ -7,7 +7,6 @@
 
 TST_NEEDS_TMPDIR=1
 TST_NEEDS_ROOT=1
-TST_MIN_KVER=2.6.15
 TST_SETUP="${TST_SETUP:-fs_bind_setup}"
 TST_CLEANUP="${TST_CLEANUP:-fs_bind_cleanup}"
 TST_TESTFUNC=fs_bind_test
diff --git a/testcases/kernel/fs/fs_fill/fs_fill.c b/testcases/kernel/fs/fs_fill/fs_fill.c
index 3b4ee1ae9..1662cdb50 100644
--- a/testcases/kernel/fs/fs_fill/fs_fill.c
+++ b/testcases/kernel/fs/fs_fill/fs_fill.c
@@ -121,7 +121,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
-	.max_runtime = 300,
+	.timeout = 300,
 	.needs_root = 1,
 	.dev_min_size = 1024,
 	.mount_device = 1,
diff --git a/testcases/kernel/fs/fsplough/.gitignore b/testcases/kernel/fs/fsplough/.gitignore
new file mode 100644
index 000000000..34fee75c7
--- /dev/null
+++ b/testcases/kernel/fs/fsplough/.gitignore
@@ -0,0 +1 @@
+/fsplough
diff --git a/testcases/kernel/fs/fsplough/Makefile b/testcases/kernel/fs/fsplough/Makefile
new file mode 100644
index 000000000..6504e9f8d
--- /dev/null
+++ b/testcases/kernel/fs/fsplough/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024 Linux Test Project
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/fs/fsplough/fsplough.c b/testcases/kernel/fs/fsplough/fsplough.c
new file mode 100644
index 000000000..66aa37c47
--- /dev/null
+++ b/testcases/kernel/fs/fsplough/fsplough.c
@@ -0,0 +1,279 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC <mdoucha@suse.cz>
+ */
+
+/*\
+ * [Description]
+ *
+ * Write data into a test file using various methods and verify that file
+ * contents match what was written.
+ */
+
+#define _GNU_SOURCE
+#include <fcntl.h>
+#include <sys/statvfs.h>
+#include "tst_test.h"
+#include "tst_safe_prw.h"
+
+#define MAX_VEC 8
+#define TEST_FILENAME "fsplough.dat"
+
+typedef void (*io_func)(void *buf, size_t offset, size_t size);
+
+static char *workdir_arg;
+static char *directwr_flag;
+static char *directrd_flag;
+static char *loop_arg;
+static int loop_count = 4096;
+
+static int read_fd = -1, write_fd = -1;
+static char *writebuf, *filedata;
+static size_t blocksize, bufsize, filesize;
+
+static void do_write(void *buf, size_t offset, size_t size);
+static void do_pwrite(void *buf, size_t offset, size_t size);
+static void do_writev(void *buf, size_t offset, size_t size);
+static void do_pwritev(void *buf, size_t offset, size_t size);
+static void do_read(void *buf, size_t offset, size_t size);
+static void do_pread(void *buf, size_t offset, size_t size);
+static void do_readv(void *buf, size_t offset, size_t size);
+static void do_preadv(void *buf, size_t offset, size_t size);
+
+static const io_func write_funcs[] = {
+	do_write,
+	do_pwrite,
+	do_writev,
+	do_pwritev
+};
+
+static const io_func read_funcs[] = {
+	do_read,
+	do_pread,
+	do_readv,
+	do_preadv
+};
+
+static size_t fill_buffer(char *buf, size_t size)
+{
+	size_t i, ret = MAX_VEC + 1 + rand() % (size - MAX_VEC);
+
+	/* Align buffer size to block size */
+	if (directwr_flag || directrd_flag)
+		ret = MAX(LTP_ALIGN(ret, blocksize), MAX_VEC * blocksize);
+
+	for (i = 0; i < ret; i++)
+		buf[i] = rand();
+
+	return ret;
+}
+
+static void vectorize_buffer(struct iovec *vec, size_t vec_size, char *buf,
+	size_t buf_size, int align)
+{
+	size_t i, len, chunk = align ? blocksize : 1;
+
+	memset(vec, 0, vec_size * sizeof(struct iovec));
+	buf_size /= chunk;
+
+	for (i = 0; buf_size && i < vec_size; i++) {
+		len = 1 + rand() % (buf_size + i + 1 - vec_size);
+		vec[i].iov_base = buf;
+		vec[i].iov_len = len * chunk;
+		buf += vec[i].iov_len;
+		buf_size -= len;
+	}
+
+	vec[vec_size - 1].iov_len += buf_size * chunk;
+}
+
+static void update_filedata(const void *buf, size_t offset, size_t size)
+{
+	memcpy(filedata + offset, buf, size * sizeof(char));
+}
+
+static void do_write(void *buf, size_t offset, size_t size)
+{
+	SAFE_LSEEK(write_fd, offset, SEEK_SET);
+	SAFE_WRITE(1, write_fd, buf, size);
+}
+
+static void do_pwrite(void *buf, size_t offset, size_t size)
+{
+	SAFE_PWRITE(1, write_fd, buf, size, offset);
+}
+
+static void do_writev(void *buf, size_t offset, size_t size)
+{
+	struct iovec vec[MAX_VEC] = {};
+
+	vectorize_buffer(vec, MAX_VEC, buf, size, !!directwr_flag);
+	SAFE_LSEEK(write_fd, offset, SEEK_SET);
+	SAFE_WRITEV(1, write_fd, vec, MAX_VEC);
+}
+
+static void do_pwritev(void *buf, size_t offset, size_t size)
+{
+	struct iovec vec[MAX_VEC] = {};
+
+	vectorize_buffer(vec, MAX_VEC, buf, size, !!directwr_flag);
+	SAFE_PWRITEV(1, write_fd, vec, MAX_VEC, offset);
+}
+
+static void do_read(void *buf, size_t offset, size_t size)
+{
+	SAFE_LSEEK(read_fd, offset, SEEK_SET);
+	SAFE_READ(1, read_fd, buf, size);
+}
+
+static void do_pread(void *buf, size_t offset, size_t size)
+{
+	SAFE_PREAD(1, read_fd, buf, size, offset);
+}
+
+static void do_readv(void *buf, size_t offset, size_t size)
+{
+	struct iovec vec[MAX_VEC] = {};
+
+	vectorize_buffer(vec, MAX_VEC, buf, size, !!directrd_flag);
+	SAFE_LSEEK(read_fd, offset, SEEK_SET);
+	SAFE_READV(1, read_fd, vec, MAX_VEC);
+}
+
+static void do_preadv(void *buf, size_t offset, size_t size)
+{
+	struct iovec vec[MAX_VEC] = {};
+
+	vectorize_buffer(vec, MAX_VEC, buf, size, !!directrd_flag);
+	SAFE_PREADV(1, read_fd, vec, MAX_VEC, offset);
+}
+
+static int open_testfile(int flags)
+{
+	if ((flags & O_WRONLY) && directwr_flag)
+		flags |= O_DIRECT;
+
+	if ((flags & O_RDONLY) && directrd_flag)
+		flags |= O_DIRECT;
+
+	return SAFE_OPEN(TEST_FILENAME, flags, 0644);
+}
+
+static void setup(void)
+{
+	struct statvfs statbuf;
+	size_t pagesize;
+
+	srand(time(0));
+	pagesize = SAFE_SYSCONF(_SC_PAGESIZE);
+
+	if (workdir_arg)
+		SAFE_CHDIR(workdir_arg);
+
+	if (tst_parse_int(loop_arg, &loop_count, 0, INT_MAX))
+		tst_brk(TBROK, "Invalid write loop count: %s", loop_arg);
+
+	write_fd = open_testfile(O_WRONLY | O_CREAT | O_TRUNC);
+	read_fd = open_testfile(O_RDONLY);
+	TEST(fstatvfs(write_fd, &statbuf));
+
+	if (TST_RET == -1)
+		tst_brk(TBROK | TTERRNO, "fstatvfs() failed");
+	else if (TST_RET)
+		tst_brk(TBROK | TTERRNO, "Invalid fstatvfs() return value");
+
+	blocksize = statbuf.f_bsize;
+	tst_res(TINFO, "Block size: %zu", blocksize);
+	bufsize = 4 * MAX_VEC * MAX(pagesize, blocksize);
+	filesize = 1024 * MAX(pagesize, blocksize);
+	writebuf = SAFE_MMAP(NULL, bufsize, PROT_READ | PROT_WRITE,
+		MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	filedata = SAFE_MALLOC(filesize);
+
+	tst_set_timeout(bufsize * loop_count / (8 * 1024 * 1024));
+}
+
+static void run(void)
+{
+	size_t start, length;
+	int i, f, fails = 0;
+
+	/* Test data consistency between random writes */
+	for (i = 0; i < loop_count; i++) {
+		length = fill_buffer(writebuf, bufsize);
+		start = rand() % (filesize + 1 - length);
+
+		/* Align offset to blocksize if needed */
+		if (directrd_flag || directwr_flag)
+			start = (start + blocksize / 2) & ~(blocksize - 1);
+
+		update_filedata(writebuf, start, length);
+		f = rand() % ARRAY_SIZE(write_funcs);
+		write_funcs[f](writebuf, start, length);
+
+		memset(writebuf, 0, length);
+		f = rand() % ARRAY_SIZE(read_funcs);
+		read_funcs[f](writebuf, start, length);
+
+		if (memcmp(writebuf, filedata + start, length)) {
+			tst_res(TFAIL, "Partial data mismatch at [%zu:%zu]",
+				start, start + length);
+			fails++;
+		}
+	}
+
+	if (!fails)
+		tst_res(TPASS, "Partial data are consistent");
+
+	/* Ensure that the testfile has the expected size */
+	do_write(writebuf, filesize - blocksize, blocksize);
+	update_filedata(writebuf, filesize - blocksize, blocksize);
+
+	/* Sync the testfile and clear cache */
+	SAFE_CLOSE(read_fd);
+	SAFE_FSYNC(write_fd);
+	SAFE_FILE_PRINTF("/proc/sys/vm/drop_caches", "1");
+	read_fd = open_testfile(O_RDONLY);
+
+	/* Check final file contents */
+	for (start = 0; start < filesize; start += bufsize) {
+		length = MIN(bufsize, filesize - start);
+		SAFE_READ(1, read_fd, writebuf, length);
+
+		if (memcmp(writebuf, filedata + start, length)) {
+			tst_res(TFAIL, "Final data mismatch at [%zu:%zu]",
+				start, start + length);
+			return;
+		}
+	}
+
+	tst_res(TPASS, "Final data are consistent");
+}
+
+static void cleanup(void)
+{
+	SAFE_MUNMAP(writebuf, bufsize);
+	free(filedata);
+
+	if (read_fd >= 0)
+		SAFE_CLOSE(read_fd);
+
+	if (write_fd >= 0)
+		SAFE_CLOSE(write_fd);
+
+	SAFE_UNLINK(TEST_FILENAME);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+	.options = (struct tst_option[]) {
+		{"c:", &loop_arg, "Number of write loops (default: 4096)"},
+		{"d:", &workdir_arg, "Path to working directory"},
+		{"W", &directwr_flag, "Use direct I/O for writing"},
+		{"R", &directrd_flag, "Use direct I/O for reading"},
+		{}
+	}
+};
diff --git a/testcases/kernel/fs/fsx-linux/fsx-linux.c b/testcases/kernel/fs/fsx-linux/fsx-linux.c
index ba1e21bbc..ac3b06ff7 100644
--- a/testcases/kernel/fs/fsx-linux/fsx-linux.c
+++ b/testcases/kernel/fs/fsx-linux/fsx-linux.c
@@ -367,7 +367,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = run,
-	.max_runtime = 1800,
+	.timeout = 1800,
 	.options = (struct tst_option[]) {
 		{ "l:", &str_file_max_size, "Maximum size in MB of the test file(s) (default 262144)" },
 		{ "o:", &str_op_max_size, "Maximum size for single operation (default 65536)" },
diff --git a/testcases/kernel/fs/iso9660/isofs.sh b/testcases/kernel/fs/iso9660/isofs.sh
index d1a362d97..088e062d6 100755
--- a/testcases/kernel/fs/iso9660/isofs.sh
+++ b/testcases/kernel/fs/iso9660/isofs.sh
@@ -13,10 +13,19 @@ TST_NEEDS_CMDS="mount umount"
 TST_NEEDS_TMPDIR=1
 TST_TESTFUNC=do_test
 TST_CNT=3
+TST_SETUP="setup"
 
 MAX_DEPTH=3
 MAX_DIRS=4
 
+TEST_USER='nobody'
+
+setup()
+{
+	TEST_GROUP="$(id -g -n $TEST_USER)"
+	[ "$TEST_GROUP" ] || TEST_GROUP="$TEST_USER"
+}
+
 gen_fs_tree()
 {
 	local cur_path="$1"
@@ -92,8 +101,8 @@ do_test()
 			"loop,block=512,unhide" \
 			"loop,block=1024,cruft" \
 			"loop,block=2048,nocompress" \
-			"loop,check=strict,map=off,gid=bin,uid=bin" \
-			"loop,check=strict,map=acorn,gid=bin,uid=bin" \
+			"loop,check=strict,map=off,gid=$TEST_GROUP,uid=$TEST_USER" \
+			"loop,check=strict,map=acorn,gid=$TEST_GROUP,uid=$TEST_USER" \
 			"loop,check=relaxed,map=normal" \
 			"loop,block=512,unhide,session=2"
 		do
diff --git a/testcases/kernel/fs/quota_remount/quota_remount_test01.sh b/testcases/kernel/fs/quota_remount/quota_remount_test01.sh
index 7e20b3608..3d087ab3e 100755
--- a/testcases/kernel/fs/quota_remount/quota_remount_test01.sh
+++ b/testcases/kernel/fs/quota_remount/quota_remount_test01.sh
@@ -12,7 +12,6 @@ TST_NEEDS_TMPDIR=1
 TST_SETUP=do_setup
 TST_CLEANUP=do_clean
 TST_TESTFUNC=do_test
-TST_MIN_KVER="2.6.26"
 
 do_setup()
 {
diff --git a/testcases/kernel/fs/read_all/read_all.c b/testcases/kernel/fs/read_all/read_all.c
index 266678ea7..14588a829 100644
--- a/testcases/kernel/fs/read_all/read_all.c
+++ b/testcases/kernel/fs/read_all/read_all.c
@@ -94,11 +94,17 @@ static int worker_timeout;
 static int timeout_warnings_left = 15;
 
 static char *blacklist[] = {
-	NULL, /* reserved for -e parameter */
+	"/reserved/", /* reserved for -e parameter */
 	"/sys/kernel/debug/*",
 	"/sys/devices/platform/*/eeprom",
 	"/sys/devices/platform/*/nvmem",
 	"/sys/*/cpu??*(?)/*",	/* cpu* entries with 2 or more digits */
+	NULL
+};
+
+static char *ratelimit_list[] = {
+	"/sys/devices/*/tpm*",
+	NULL,
 };
 
 static long long epoch;
@@ -193,19 +199,43 @@ static void sanitize_str(char *buf, ssize_t count)
 		strcpy(buf + MAX_DISPLAY, "...");
 }
 
-static int is_blacklisted(const char *path)
+static int is_onlist(const char *path, char *list[])
 {
-	unsigned int i;
+	unsigned int i = 0;
+
+	while (1) {
+		const char *pattern = list[i++];
 
-	for (i = 0; i < ARRAY_SIZE(blacklist); i++) {
-		if (blacklist[i] && !fnmatch(blacklist[i], path, FNM_EXTMATCH)) {
-			if (verbose)
-				tst_res(TINFO, "Ignoring %s", path);
+		if (!pattern)
+			break;
+		if (!fnmatch(pattern, path, FNM_EXTMATCH))
 			return 1;
-		}
 	}
 
 	return 0;
+
+}
+
+static int is_blacklisted(const char *path)
+{
+	int ret;
+
+	ret = is_onlist(path, blacklist);
+	if (ret && verbose)
+		tst_res(TINFO, "Ignoring %s", path);
+
+	return ret;
+}
+
+static int is_ratelimitted(const char *path)
+{
+	int ret;
+
+	ret = is_onlist(path, ratelimit_list);
+	if (ret && verbose)
+		tst_res(TINFO, "Limiting to single worker %s", path);
+
+	return ret;
 }
 
 static void worker_heartbeat(const int worker)
@@ -503,6 +533,9 @@ static int sched_work(const int first_worker,
 	int min_ttl = worker_timeout, sleep_time = 1;
 	int pushed, workers_pushed = 0;
 
+	if (is_ratelimitted(path))
+		repetitions = 1;
+
 	for (i = 0, j = first_worker; i < repetitions; j++) {
 		if (j >= worker_count)
 			j = 0;
@@ -565,7 +598,7 @@ static void setup(void)
 			worker_timeout);
 	} else {
 		worker_timeout = 10 * tst_remaining_runtime();
-		tst_res(TINFO, "Worker timeout set to 10%% of max_runtime: %dms",
+		tst_res(TINFO, "Worker timeout set to 10%% of runtime: %dms",
 			worker_timeout);
 	}
 	worker_timeout *= 1000;
@@ -713,5 +746,5 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.test_all = run,
 	.forks_child = 1,
-	.max_runtime = 100,
+	.runtime = 100,
 };
diff --git a/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug05.txt b/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug05.txt
index 26fd59612..67f8198d9 100644
--- a/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug05.txt
+++ b/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug05.txt
@@ -1,35 +1,29 @@
-# Test Case 5 - Pseudocode
+Testcase 05
+-----------
 
-# This test looks for memory leaks or deadlocks
+It's been found that sometimes onlining and offlining CPUs confuse some
+of the various system tools.  We found that sar wouldn't register the change
+in newly available cpus that weren't there when it started. This
+test case seeks to exercise this known error cases and verify that
+they behave correctly now.
 
-# "mm_struct slab leak (affected only some architectures)"
+Algorithm - Sar
+===============
+Given a CPU to test that exists
 
-INTERVAL=30
-THRESHHOLD='xxx'
+Make sure the specified cpu is offline
 
-# TODO:  Start monitoring memory usage via vmstat and sar
+Loop until done:
+  Start up sar writing to a temp log and give it a little time to run
 
-# TODO:  Start dbt2, running for at least 4 hours
+  Verify that SAR has correctly displayed all fields of CPU statistics
+  as '0.00' for the offlined CPU or just not displayed it in its tmp log
 
-while [ 1 ]; do
-    last if workload has completed
+  Online the specified cpu
 
-    select a cpu at random
-    if cpu is online
-        offline it
-    else
-        online it
-    fi
+  Take another timestamp and another count of offlined CPUs
 
-    measure current throughput
-    # TODO:  Mary and Mark will better define how to detect
-    # the threshhold and what to do in response
-    if [ throughput falls below $THRESHHOLD ]; then
-        echo "Throughput has fallen below threshhold."
-    fi
+  Verify SAR registered the change in CPU online/offline states
 
-    sleep $INTERVAL
-done
-
-# Analyze system statistics to determine memory leaks
-# Analyze drops in activities
+When exiting:
+  Kill the sar process
diff --git a/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug06.txt b/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug06.txt
index 0cccc871c..d7d6c1814 100644
--- a/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug06.txt
+++ b/testcases/kernel/hotplug/cpu_hotplug/doc/hotplug06.txt
@@ -2,11 +2,9 @@ Testcase 06
 -----------
 
 It's been found that sometimes onlining and offlining CPUs confuse some
-of the various system tools.  In particular, we found it caused top to
-crash, and found that sar wouldn't register newly available cpus that
-weren't there when it started.  This test case seeks to exercise these
-known error cases and verify that they behave correctly now.
-
+of the various system tools.  We found it caused top to
+crash.  This test case seeks to exercise this known error cases and
+verify that they behave correctly now.
 
 Algorithm - Top
 ===============
@@ -29,28 +27,3 @@ When exiting:
   Restore all CPUs to their initial state
 
 
-Algorithm - Sar
-===============
-Given a CPU to test that exists
-
-Make sure the specified cpu is offline
-
-Loop until done:
-  Start up sar writing to a temp log and give it a little time to run
-
-  Verify that SAR has correctly listed the missing CPU as 'nan' in its
-  tmp log
-
-  Take a timestamp and count how many CPUs sar is reporting to be
-  offline
-
-  Online the specified cpu
-
-  Take another timestamp and another count of offlined CPUs.
-
-  Verify that the number of CPUs offline has changed
-
-When exiting:
-  Kill the sar process
-
-
diff --git a/testcases/kernel/input/Makefile b/testcases/kernel/input/Makefile
index 032254444..945299a13 100644
--- a/testcases/kernel/input/Makefile
+++ b/testcases/kernel/input/Makefile
@@ -3,10 +3,10 @@
 
 top_srcdir			?= ../../..
 
+LTPLIBS = uinput
+
 include $(top_srcdir)/include/mk/testcases.mk
 
-FILTER_OUT_MAKE_TARGETS		:= input_helper
+LDLIBS += -lltpuinput
 
 include $(top_srcdir)/include/mk/generic_leaf_target.mk
-
-$(MAKE_TARGETS): %: input_helper.o
diff --git a/testcases/kernel/input/input01.c b/testcases/kernel/input/input01.c
index 95db3f43f..5e8513302 100644
--- a/testcases/kernel/input/input01.c
+++ b/testcases/kernel/input/input01.c
@@ -1,187 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
- /*
-  *  Create a virtual device (mouse), send events to /dev/uinput
-  *  and check that the events are well received in /dev/input/eventX
-  */
-
-#include <linux/input.h>
-
-#include "input_helper.h"
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/fcntl.h"
-
-#define NB_TEST 20
-
-static void setup(void);
-static void send_events(void);
-static int verify_data(struct input_event *iev, int nb);
-static int check_events(void);
-static void cleanup(void);
-
-static int fd;
-static int fd2;
+/*\
+ * [Description]
+ *
+ * Verify that /dev/input/eventX receive events sent from a virtual device,
+ * that in our case is a mouse.
+ */
 
-char *TCID = "input01";
+#include "input_common.h"
 
-int main(int ac, char **av)
-{
-	int lc;
-	int pid;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		pid = tst_fork();
-
-		switch (pid) {
-		case 0:
-			send_events();
-			exit(0);
-		case -1:
-			tst_brkm(TBROK | TERRNO, cleanup, "fork() failed");
-		default:
-			if (check_events())
-				tst_resm(TFAIL, "Wrong data read from eventX");
-			else
-				tst_resm(TPASS, "Data received from eventX");
-		break;
-		}
-
-		SAFE_WAITPID(NULL, pid, NULL, 0);
-	}
+#define NUM_EVENTS 20
+#define MOVE_X 10
+#define MOVE_Y 1
 
-	cleanup();
-	tst_exit();
-}
+static int fd_send = -1;
+static int fd_recv = -1;
 
-static void setup(void)
+static void run(void)
 {
-	tst_require_root();
+	struct input_event iev[3];
 
-	fd = open_uinput();
-	setup_mouse_events(fd);
-	create_device(fd);
-
-	fd2 = open_device();
-}
-
-static void send_events(void)
-{
-	int nb;
+	tst_res(TINFO, "Sending relative move: (%i, %i)", MOVE_X, MOVE_Y);
 
-	for (nb = 0; nb < NB_TEST; ++nb) {
-		send_rel_move(fd, 10, 1);
+	for (int i = 0; i < NUM_EVENTS; i++) {
+		send_relative_move(fd_send, MOVE_X, MOVE_Y);
 		usleep(1000);
 	}
-}
-
-static int check_events(void)
-{
-	int nb, rd;
-	unsigned int i;
-	struct input_event iev[64];
 
-	nb = 0;
+	tst_res(TINFO, "Reading events back");
 
-	while (nb < NB_TEST * 3) {
-		rd = read(fd2, iev, sizeof(iev));
+	for (int i = 0; i < NUM_EVENTS; i++) {
+		SAFE_READ(0, fd_recv, iev, 3 * sizeof(struct input_event));
 
-		if (rd < 0)
-			tst_brkm(TBROK | TERRNO, cleanup, "read()");
+		TST_EXP_EQ_LI(iev[0].type, EV_REL);
+		TST_EXP_EQ_LI(iev[0].code, REL_X);
+		TST_EXP_EQ_LI(iev[0].value, MOVE_X);
 
-		if (rd == 0 || rd % sizeof(struct input_event)) {
-			tst_resm(TINFO, "read() returned unexpected %i", rd);
-			return 1;
-		}
+		TST_EXP_EQ_LI(iev[1].type, EV_REL);
+		TST_EXP_EQ_LI(iev[1].code, REL_Y);
+		TST_EXP_EQ_LI(iev[1].value, MOVE_Y);
 
-		for (i = 0; i < rd / sizeof(struct input_event); i++) {
-			if (verify_data(&iev[i], nb++))
-				return 1;
-		}
+		TST_EXP_EQ_LI(iev[2].type, EV_SYN);
+		TST_EXP_EQ_LI(iev[2].code, 0);
+		TST_EXP_EQ_LI(iev[2].value, 0);
 	}
-
-	return 0;
 }
 
-static int verify_data(struct input_event *iev, int nb)
+static void setup(void)
 {
-	if (nb % 3 == 0) {
-		if (iev->type != EV_REL) {
-			tst_resm(TINFO,
-			         "%i: Unexpected event type %i expected %i",
-			         nb, iev->type, EV_REL);
-			return 1;
-		}
-
-		if (iev->code != REL_X)
-			return 1;
-
-		if (iev->value != 10)
-			return 1;
-
-		return 0;
-	}
+	fd_send = open_uinput();
+	if (fd_send == -1)
+		tst_brk(TCONF, "Virtual device is not available");
 
-	if (nb % 3 == 1) {
-		if (iev->type != EV_REL) {
-			tst_resm(TINFO,
-			         "%i: Unexpected event type %i expected %i",
-			         nb, iev->type, EV_REL);
-			return 1;
-		}
+	setup_mouse_events(fd_send);
+	create_input_device(fd_send);
 
-		if (iev->code != REL_Y)
-			return 1;
-
-		if (iev->value != 1)
-			return 1;
-
-		return 0;
-	}
-
-	if (nb % 3 == 2) {
-		if (iev->type != EV_SYN) {
-			tst_resm(TINFO,
-			         "%i: Unexpected event type %i expected %i",
-			         nb, iev->type, EV_SYN);
-			return 1;
-		}
-
-		if (iev->code != 0)
-			return 1;
-
-		if (iev->value != 0)
-			return 1;
-
-		return 0;
-	}
-	return 1;
+	fd_recv = open_event_device();
 }
 
 static void cleanup(void)
 {
-	if (fd2 > 0 && close(fd2))
-		tst_resm(TWARN | TERRNO, "close(fd2)");
+	if (fd_send != -1)
+		destroy_input_device(fd_send);
 
-	destroy_device(fd);
+	if (fd_recv != -1)
+		SAFE_CLOSE(fd_recv);
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+};
diff --git a/testcases/kernel/input/input02.c b/testcases/kernel/input/input02.c
index 6964ed703..8e48f12d9 100644
--- a/testcases/kernel/input/input02.c
+++ b/testcases/kernel/input/input02.c
@@ -1,106 +1,81 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Verify that /dev/input/eventX won't receive any event sent from a virtual
+ * device, that in our case is a mouse, when the event device has been grabbed
+ * by an another process.
  */
 
- /*
-  *  Create a virtual device (mouse), send events to /dev/uinput
-  *  and check that the events are not received in /dev/input/eventX
-  *  because the device is grabbed by another process
-  */
+#include "input_common.h"
 
-#include <linux/input.h>
+#define MOVE_X 10
+#define MOVE_Y 1
 
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/fcntl.h"
-#include "input_helper.h"
+static int fd_send = -1;
+static int fd_recv = -1;
 
-#define NB_TEST 20
+static void send_events(void)
+{
+	int fd;
 
-static void setup(void);
-static void send_information(void);
-static void cleanup(void);
+	fd = open_event_device();
 
-static int fd;
-static int fd2;
+	SAFE_IOCTL(fd, EVIOCGRAB, 1);
+	tst_res(TINFO, "The virtual device was grabbed");
 
-char *TCID = "input02";
+	send_relative_move(fd_send, MOVE_X, MOVE_Y);
 
-int main(int ac, char **av)
-{
-	int lc;
-	int pid;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		pid = tst_fork();
-
-		fd2 = open_device();
-
-		switch (pid) {
-		case 0:
-			send_information();
-			exit(0);
-		case -1:
-			tst_brkm(TBROK | TERRNO, cleanup, "fork() failed");
-		default:
-			if (no_events_queued(fd2, 0))
-				tst_resm(TPASS, "No data received in eventX");
-			else
-				tst_resm(TFAIL, "Data received in eventX");
-			SAFE_CLOSE(NULL, fd2);
-		break;
-		}
-
-		SAFE_WAITPID(NULL, pid, NULL, 0);
-	}
+	TST_CHECKPOINT_WAKE_AND_WAIT(0);
 
-	cleanup();
-	tst_exit();
+	SAFE_CLOSE(fd);
 }
 
-static void setup(void)
+static void run(void)
 {
-	tst_require_root();
+	if (!SAFE_FORK()) {
+		send_events();
+		exit(0);
+	}
+
+	TST_CHECKPOINT_WAIT(0);
 
-	fd = open_uinput();
-	setup_mouse_events(fd);
-	create_device(fd);
+	verify_no_events_queued(fd_recv);
+
+	TST_CHECKPOINT_WAKE(0);
 }
 
-static void send_information(void)
+static void setup(void)
 {
-	int nb;
+	fd_send = open_uinput();
+	if (fd_send == -1)
+		tst_brk(TCONF, "Virtual device is not available");
 
-	SAFE_IOCTL(NULL, fd2, EVIOCGRAB, 1);
-	tst_resm(TINFO, "The virtual device was grabbed");
+	setup_mouse_events(fd_send);
+	create_input_device(fd_send);
 
-	for (nb = 0; nb < NB_TEST; ++nb) {
-		send_rel_move(fd, 10, 1);
-		usleep(1000);
-	}
-
-	SAFE_CLOSE(NULL, fd2);
+	fd_recv = open_event_device();
 }
 
 static void cleanup(void)
 {
-	destroy_device(fd);
+	if (fd_send != -1)
+		destroy_input_device(fd_send);
+
+	if (fd_recv != -1)
+		SAFE_CLOSE(fd_recv);
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.forks_child = 1,
+	.needs_root = 1,
+	.needs_checkpoints = 1,
+};
diff --git a/testcases/kernel/input/input03.c b/testcases/kernel/input/input03.c
index 6cd753d0b..2e6161bee 100644
--- a/testcases/kernel/input/input03.c
+++ b/testcases/kernel/input/input03.c
@@ -1,145 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
- /*
-  *  Create a virtual device (mouse), send events to /dev/uinput
-  *  and check that the events are well received in /dev/input/mice
-  */
+/*\
+ * [Description]
+ *
+ * Verify that /dev/input/mice receive events sent from a virtual device,
+ * that in our case is a mouse. The events are a sequence of mouse right click.
+ */
 
-#include <linux/input.h>
 #include <linux/uinput.h>
 
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/fcntl.h"
-#include "input_helper.h"
+#include "input_common.h"
 
-#define NB_TEST 10
+#define NUM_EVENTS 10
 #define PS2_RIGHT_BTN 0x02
+#define MOUSE_DEV "/dev/input/mice"
 
-static void setup(void);
-static void send_events(void);
-static int check_events(void);
-static void cleanup(void);
+static int fd_send = -1;
+static int fd_recv = -1;
 
-static int fd, fd2;
-
-char *TCID = "input03";
-
-int main(int ac, char **av)
+static void recv_data(void)
 {
-	int lc;
-	int pid;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		pid = tst_fork();
-
-		switch (pid) {
-		case 0:
-			send_events();
-			exit(0);
-		case -1:
-			tst_brkm(TBROK | TERRNO, cleanup, "fork() failed");
-		default:
-			if (check_events())
-				tst_resm(TFAIL, "Wrong data received");
-			else
-				tst_resm(TPASS,
-					"Data received in /dev/input/mice");
-		break;
-		}
+	tst_res(TINFO, "Reading events back");
 
-		SAFE_WAITPID(NULL, pid, NULL, 0);
-	}
+	char buf[30];
+	int events = 0;
+	int pressed = 0;
+	int num_bytes = 0;
 
-	cleanup();
-	tst_exit();
-}
+	TST_CHECKPOINT_WAKE(0);
 
-static void setup(void)
-{
-	tst_require_root();
+	while (events < NUM_EVENTS) {
+		memset(buf, 0, sizeof(buf));
 
-	fd = open_uinput();
+		num_bytes = SAFE_READ(0, fd_recv, buf, sizeof(buf));
 
-	setup_mouse_events(fd);
-	SAFE_IOCTL(NULL, fd, UI_SET_EVBIT, EV_KEY);
-	SAFE_IOCTL(NULL, fd, UI_SET_KEYBIT, BTN_RIGHT);
+		for (int i = 0; i < num_bytes / 3; i++) {
+			if (buf[3*i] & PS2_RIGHT_BTN)
+				pressed = 1;
 
-	create_device(fd);
+			if (pressed == 1 && !(buf[3*i] & PS2_RIGHT_BTN)) {
+				pressed = 0;
+				events++;
+			}
+		}
+	}
 
-	fd2 = SAFE_OPEN(NULL, "/dev/input/mice", O_RDONLY);
+	TST_EXP_EQ_LI(events, NUM_EVENTS);
 }
 
-static void send_events(void)
+static void send_mouse_events(void)
 {
-	int nb;
+	tst_res(TINFO, "Sending right click");
+
+	TST_CHECKPOINT_WAIT(0);
 
-	for (nb = 0; nb < NB_TEST; ++nb) {
-		send_event(fd, EV_KEY, BTN_RIGHT, 1);
-		send_event(fd, EV_SYN, 0, 0);
+	for (int i = 0; i < NUM_EVENTS; i++) {
+		send_event(fd_send, EV_KEY, BTN_RIGHT, 1);
+		send_event(fd_send, EV_SYN, 0, 0);
 		usleep(1000);
-		send_event(fd, EV_KEY, BTN_RIGHT, 0);
-		send_event(fd, EV_SYN, 0, 0);
+
+		send_event(fd_send, EV_KEY, BTN_RIGHT, 0);
+		send_event(fd_send, EV_SYN, 0, 0);
 		usleep(1000);
 	}
 }
 
-static int check_events(void)
+static void run(void)
 {
-	int nb, rd, i, pressed = 0;
-	char buf[30];
-
-	nb = 0;
-
-	while (nb < NB_TEST) {
-		rd = read(fd2, buf, sizeof(buf));
+	if (!SAFE_FORK()) {
+		send_mouse_events();
+		exit(0);
+	}
 
-		if (rd < 0)
-			tst_brkm(TBROK | TERRNO, NULL, "read() failed");
+	recv_data();
+}
 
-		if (rd % 3) {
-			tst_resm(TINFO, "read() returned %i", rd);
-			return 1;
-		}
+static void setup(void)
+{
+	fd_send = open_uinput();
+	if (fd_send == -1)
+		tst_brk(TCONF, "Virtual device is not available");
 
-		for (i = 0; i < rd / 3; i++) {
-			if (buf[3*i] & PS2_RIGHT_BTN)
-				pressed = 1;
+	setup_mouse_events(fd_send);
+	SAFE_IOCTL(fd_send, UI_SET_EVBIT, EV_KEY);
+	SAFE_IOCTL(fd_send, UI_SET_KEYBIT, BTN_RIGHT);
 
-			if (pressed == 1 && !(buf[3*i] & PS2_RIGHT_BTN)) {
-				pressed = 0;
-				nb++;
-			}
-		}
-	}
+	create_input_device(fd_send);
 
-	return nb != NB_TEST;
+	fd_recv = SAFE_OPEN(MOUSE_DEV, O_RDONLY);
 }
 
 static void cleanup(void)
 {
-	if (fd2 > 0 && close(fd2))
-		tst_resm(TWARN, "close(fd2) failed");
+	if (fd_send != -1)
+		destroy_input_device(fd_send);
 
-	destroy_device(fd);
+	if (fd_recv != -1)
+		SAFE_CLOSE(fd_recv);
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.forks_child = 1,
+	.needs_root = 1,
+	.needs_checkpoints = 1,
+};
diff --git a/testcases/kernel/input/input04.c b/testcases/kernel/input/input04.c
index e57b76b0b..fb13500fe 100644
--- a/testcases/kernel/input/input04.c
+++ b/testcases/kernel/input/input04.c
@@ -1,103 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
- /*
-  *  Create a virtual device (mouse), send empty events to /dev/uinput
-  *  and check that the events are not received in /dev/inputX
-  */
-
-#include <linux/input.h>
-
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/fcntl.h"
-#include "input_helper.h"
-
-#define NB_TEST 20
+/*\
+ * [Description]
+ *
+ * Verify that /dev/input/eventX doesn't receive any event sent from a virtual
+ * device, that in our case is a mouse, when relative move is (0, 0)
+ */
 
-static void setup(void);
-static void send_events(void);
-static void cleanup(void);
+#include "input_common.h"
 
-static int fd, fd2;
+#define NUM_EVENTS 20
 
-char *TCID = "input04";
+static int fd_send = -1;
+static int fd_recv = -1;
 
-int main(int ac, char **av)
+static void run(void)
 {
-	int lc;
-	int pid;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
+	tst_res(TINFO, "Sending empty relative move");
 
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		pid = tst_fork();
-
-		switch (pid) {
-		case 0:
-			send_events();
-			exit(0);
-		case -1:
-			tst_brkm(TBROK | TERRNO, cleanup, "fork() failed");
-		default:
-			if (no_events_queued(fd2, 1))
-				tst_resm(TPASS,
-					"No data received in /dev/inputX");
-			else
-				tst_resm(TFAIL,
-					"Data received /dev/inputX");
-		break;
-		}
-
-		SAFE_WAITPID(NULL, pid, NULL, 0);
+	for (int i = 0; i < NUM_EVENTS; i++) {
+		send_relative_move(fd_send, 0, 0);
+		usleep(1000);
 	}
 
-	cleanup();
-	tst_exit();
+	verify_no_events_queued(fd_recv);
 }
 
 static void setup(void)
 {
-	tst_require_root();
-
-	fd = open_uinput();
-	setup_mouse_events(fd);
-	create_device(fd);
-
-	fd2 = open_device();
-}
+	fd_send = open_uinput();
+	if (fd_send == -1)
+		tst_brk(TCONF, "Virtual device is not available");
 
-static void send_events(void)
-{
-	int nb;
+	setup_mouse_events(fd_send);
+	create_input_device(fd_send);
 
-	for (nb = 0; nb < NB_TEST; ++nb) {
-		send_rel_move(fd, 0, 0);
-		usleep(1000);
-	}
+	fd_recv = open_event_device();
 }
 
 static void cleanup(void)
 {
-	if (fd2 > 0 && close(fd2))
-		tst_resm(TWARN | TERRNO, "close(fd2)");
+	if (fd_send != -1)
+		destroy_input_device(fd_send);
 
-	destroy_device(fd);
+	if (fd_recv != -1)
+		SAFE_CLOSE(fd_recv);
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+};
diff --git a/testcases/kernel/input/input05.c b/testcases/kernel/input/input05.c
index 46b4fe8b2..fa37ac7ac 100644
--- a/testcases/kernel/input/input05.c
+++ b/testcases/kernel/input/input05.c
@@ -1,107 +1,65 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
- /*
-  *  Create a virtual device (mouse), send events to /dev/uinput
-  *  and Check that events not advertised in the input device bits
-  *  are filtered.
-  */
+/*\
+ * [Description]
+ *
+ * Verify that /dev/input/eventX doesn't receive any event sent from a virtual
+ * device, that in our case is a mouse, when events not advertised in the input
+ * device bits are filtered.
+ */
 
-#include <linux/input.h>
 #include <linux/uinput.h>
 
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/fcntl.h"
-#include "input_helper.h"
-
-#define X_VALUE 10
-#define Y_VALUE 10
+#include "input_common.h"
 
-#define NB_TEST 20
+#define NUM_EVENTS 20
+#define MOVE_X 10
+#define MOVE_Y 10
 
-static void setup(void);
-static void send_events(void);
-static void cleanup(void);
+static int fd_send = -1;
+static int fd_recv = -1;
 
-static int fd;
-static int fd2;
-
-char *TCID = "input05";
-
-int main(int ac, char **av)
+static void run(void)
 {
-	int lc;
-	int pid;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		pid = tst_fork();
+	tst_res(TINFO, "Sending relative mouse move (%i, %i)", MOVE_X, MOVE_Y);
 
-		switch (pid) {
-		case 0:
-			send_events();
-			exit(0);
-		case -1:
-			tst_brkm(TBROK | TERRNO, cleanup, "fork() failed");
-		default:
-			if (no_events_queued(fd2, 1))
-				tst_resm(TPASS, "No data received in eventX");
-			else
-				tst_resm(TFAIL, "Data received in eventX");
-		break;
-		}
-
-		SAFE_WAITPID(NULL, pid, NULL, 0);
+	for (int i = 0; i < NUM_EVENTS; i++) {
+		send_relative_move(fd_send, MOVE_X, MOVE_Y);
+		usleep(1000);
 	}
 
-	cleanup();
-	tst_exit();
+	verify_no_events_queued(fd_recv);
 }
 
 static void setup(void)
 {
-	tst_require_root();
-
-	fd = open_uinput();
+	fd_send = open_uinput();
+	if (fd_send == -1)
+		tst_brk(TCONF, "Virtual device is not available");
 
-	SAFE_IOCTL(NULL, fd, UI_SET_EVBIT, EV_KEY);
-	SAFE_IOCTL(NULL, fd, UI_SET_KEYBIT, BTN_LEFT);
+	SAFE_IOCTL(fd_send, UI_SET_EVBIT, EV_KEY);
+	SAFE_IOCTL(fd_send, UI_SET_KEYBIT, BTN_LEFT);
+	create_input_device(fd_send);
 
-	create_device(fd);
-
-	fd2 = open_device();
+	fd_recv = open_event_device();
 }
 
-static void send_events(void)
+static void cleanup(void)
 {
-	int nb;
+	if (fd_send != -1)
+		destroy_input_device(fd_send);
 
-	for (nb = 0; nb < NB_TEST; ++nb) {
-		send_rel_move(fd, X_VALUE, Y_VALUE);
-		usleep(1000);
-	}
+	if (fd_recv != -1)
+		SAFE_CLOSE(fd_recv);
 }
 
-static void cleanup(void)
-{
-	destroy_device(fd);
-}
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+};
diff --git a/testcases/kernel/input/input06.c b/testcases/kernel/input/input06.c
index b698c277d..d3584a2b0 100644
--- a/testcases/kernel/input/input06.c
+++ b/testcases/kernel/input/input06.c
@@ -1,102 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
- /*
-  *  Create a virtual device, activate auto-repeat and
-  *  and check that auto repeat is working
-  */
+/*\
+ * [Description]
+ *
+ * Verify that auto-repeat is working on a virtual device, that in our case
+ * it's a keyboard.
+ */
 
-#include <linux/input.h>
 #include <linux/uinput.h>
-#include <linux/kd.h>
-
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/fcntl.h"
-#include "input_helper.h"
 
-static void setup(void);
-static void send_events(void);
-static int check_events(void);
-static void cleanup(void);
+#include "input_common.h"
 
-static int fd;
-static int fd2;
 struct input_event events[64];
 static int num_events;
 static int ev_iter;
-
-char *TCID = "input06";
-
-int main(int ac, char **av)
-{
-	int lc;
-	int pid;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		pid = tst_fork();
-
-		switch (pid) {
-		case 0:
-			send_events();
-			exit(0);
-		case -1:
-			tst_brkm(TBROK | TERRNO, cleanup, "fork() failed");
-		default:
-			if (!check_events())
-				tst_resm(TFAIL,
-					"Wrong data received in eventX");
-			else
-				tst_resm(TPASS, "Data received in eventX");
-		break;
-		}
-
-		SAFE_WAITPID(NULL, pid, NULL, 0);
-	}
-
-	cleanup();
-	tst_exit();
-}
-
-static void setup(void)
-{
-	tst_require_root();
-
-	fd = open_uinput();
-
-	SAFE_IOCTL(NULL, fd, UI_SET_EVBIT, EV_KEY);
-	SAFE_IOCTL(NULL, fd, UI_SET_EVBIT, EV_REP);
-	SAFE_IOCTL(NULL, fd, UI_SET_KEYBIT, KEY_X);
-
-	create_device(fd);
-
-	fd2 = open_device();
-	SAFE_IOCTL(NULL, fd2, EVIOCGRAB, 1);
-}
+static int fd_send = -1;
+static int fd_recv = -1;
 
 static void send_events(void)
 {
-	send_event(fd, EV_KEY, KEY_X, 1);
-	send_event(fd, EV_SYN, 0, 0);
+	send_event(fd_send, EV_KEY, KEY_X, 1);
+	send_event(fd_send, EV_SYN, 0, 0);
 
 	/*
 	 * Sleep long enough to keep the key pressed for some time
@@ -106,8 +34,8 @@ static void send_events(void)
 	 */
 	usleep(500000);
 
-	send_event(fd, EV_KEY, KEY_X, 0);
-	send_event(fd, EV_SYN, 0, 0);
+	send_event(fd_send, EV_KEY, KEY_X, 0);
+	send_event(fd_send, EV_SYN, 0, 0);
 }
 
 static int check_event(struct input_event *iev, int event, int code, int value)
@@ -117,20 +45,18 @@ static int check_event(struct input_event *iev, int event, int code, int value)
 
 static void read_events(void)
 {
-	int rd = read(fd2, events, sizeof(events));
-	if (rd < 0)
-		tst_brkm(TBROK | TERRNO, cleanup, "read() failed");
+	int num_bytes = SAFE_READ(0, fd_recv, events, sizeof(events));
 
-	if (rd == 0)
-		tst_brkm(TBROK, cleanup, "Failed to read events");
+	if (!num_bytes)
+		tst_brk(TBROK, "Failed to read events");
 
-	if (rd % sizeof(struct input_event) != 0) {
-		tst_brkm(TBROK, cleanup, "read size %i not multiple of %zu",
-		         rd, sizeof(struct input_event));
+	if (num_bytes % sizeof(struct input_event) != 0) {
+		tst_brk(TBROK, "Read size %i is not multiple of %zu",
+			num_bytes, sizeof(struct input_event));
 	}
 
 	ev_iter = 0;
-	num_events = rd / sizeof(struct input_event);
+	num_events = num_bytes / sizeof(struct input_event);
 }
 
 static int have_events(void)
@@ -146,29 +72,37 @@ static struct input_event *next_event(void)
 	return &events[ev_iter++];
 }
 
+static int check_event_code(struct input_event *iev, int event, int code)
+{
+	return iev->type == event && iev->code == code;
+}
+
 static int parse_autorepeat_config(struct input_event *iev)
 {
 	if (!check_event_code(iev, EV_REP, REP_DELAY)) {
-		tst_resm(TFAIL,
-			 "Didn't get EV_REP configuration with code REP_DELAY");
+		tst_res(TFAIL, "Didn't get EV_REP type with REP_DELAY code");
 		return 0;
 	}
 
 	if (!check_event_code(next_event(), EV_REP, REP_PERIOD)) {
-		tst_resm(TFAIL,
-			 "Didn't get EV_REP configuration with code REP_PERIOD");
+		tst_res(TFAIL, "Didn't get EV_REP type with REP_PERIOD code");
 		return 0;
 	}
 
 	return 1;
 }
 
+static int check_sync_event(struct input_event *iev)
+{
+	return check_event_code(iev, EV_SYN, SYN_REPORT);
+}
+
 static int parse_key(struct input_event *iev)
 {
 	int autorep_count = 0;
 
 	if (!check_event(iev, EV_KEY, KEY_X, 1) || !check_sync_event(next_event())) {
-		tst_resm(TFAIL, "Didn't get expected key press for KEY_X");
+		tst_res(TFAIL, "Didn't get expected key press for KEY_X");
 		return 0;
 	}
 
@@ -180,19 +114,16 @@ static int parse_key(struct input_event *iev)
 
 	/* make sure we have at least one auto-repeated key event */
 	if (!autorep_count) {
-		tst_resm(TFAIL,
-			 "Didn't get autorepeat events for the key - KEY_X");
+		tst_res(TFAIL, "Didn't get autorepeat events for the key - KEY_X");
 		return 0;
 	}
 
 	if (!check_event(iev, EV_KEY, KEY_X, 0) || !check_sync_event(next_event())) {
-		tst_resm(TFAIL,
-			 "Didn't get expected key release for KEY_X");
+		tst_res(TFAIL, "Didn't get expected key release for KEY_X");
 		return 0;
 	}
 
-	tst_resm(TINFO,
-		 "Received %d repititions for KEY_X", autorep_count);
+	tst_res(TINFO, "Received %d repetitions for KEY_X", autorep_count);
 
 	return 1;
 }
@@ -218,8 +149,7 @@ static int check_events(void)
 			rep_keys_done = 1;
 			break;
 		default:
-			tst_resm(TFAIL,
-				 "Unexpected event type '0x%04x' received",
+			tst_res(TFAIL, "Unexpected event type '0x%04x' received",
 				iev->type);
 			ret = 0;
 			break;
@@ -232,10 +162,48 @@ static int check_events(void)
 	return ret;
 }
 
+static void run(void)
+{
+	if (!SAFE_FORK()) {
+		send_events();
+		exit(0);
+	}
+
+	if (!check_events())
+		tst_res(TFAIL, "Wrong data received from input device");
+	else
+		tst_res(TPASS, "Data received from input device");
+}
+
+static void setup(void)
+{
+	fd_send = open_uinput();
+	if (fd_send == -1)
+		tst_brk(TCONF, "Virtual device is not available");
+
+	SAFE_IOCTL(fd_send, UI_SET_EVBIT, EV_KEY);
+	SAFE_IOCTL(fd_send, UI_SET_EVBIT, EV_REP);
+	SAFE_IOCTL(fd_send, UI_SET_KEYBIT, KEY_X);
+
+	create_input_device(fd_send);
+
+	fd_recv = open_event_device();
+	SAFE_IOCTL(fd_recv, EVIOCGRAB, 1);
+}
+
 static void cleanup(void)
 {
-	if (fd2 > 0 && close(fd2))
-		tst_resm(TWARN | TERRNO, "close(fd2) failed");
+	if (fd_send != -1)
+		destroy_input_device(fd_send);
 
-	destroy_device(fd);
+	if (fd_recv != -1)
+		SAFE_CLOSE(fd_recv);
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+	.forks_child = 1,
+};
diff --git a/testcases/kernel/input/input_common.h b/testcases/kernel/input/input_common.h
new file mode 100644
index 000000000..5b1755771
--- /dev/null
+++ b/testcases/kernel/input/input_common.h
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef INPUT_COMMON_H__
+#define INPUT_COMMON_H__
+
+#include <linux/input.h>
+#include <poll.h>
+
+#include "tst_test.h"
+#include "tst_uinput.h"
+
+static inline int open_event_device(void)
+{
+	int fd;
+	char path[1024];
+	char *device;
+	char *handlers;
+
+	memset(path, 0, sizeof(path));
+
+	handlers = get_input_field_value('H');
+	device = strtok(handlers, " ");
+
+	while (device) {
+		if (strstr(device, "event") != NULL) {
+			memset(path, 0, sizeof(path));
+			snprintf(path, sizeof(path), "/dev/input/%s", device);
+
+			if (!TST_RETRY_FUNC(access(path, F_OK), TST_RETVAL_EQ0)) {
+				tst_res(TINFO, "Found event device: %s", path);
+				break;
+			}
+		}
+
+		device = strtok(NULL, " ");
+	}
+
+	free(handlers);
+
+	if (path[0] == '\0')
+		tst_brk(TBROK, "Can't find event device");
+
+	fd = SAFE_OPEN(path, O_RDONLY);
+
+	return fd;
+}
+
+static inline void send_event(
+	const int fd, const int event,
+	const int code, const int value)
+{
+	struct input_event ev = {
+		.type = event,
+		.code = code,
+		.value = value,
+	};
+
+	SAFE_WRITE(SAFE_WRITE_ALL, fd, &ev, sizeof(ev));
+}
+
+static inline void send_relative_move(const int fd, const int x, const int y)
+{
+	send_event(fd, EV_REL, REL_X, x);
+	send_event(fd, EV_REL, REL_Y, y);
+	send_event(fd, EV_SYN, 0, 0);
+}
+
+static inline void verify_no_events_queued(const int fd_recv)
+{
+	int num_bytes;
+	int num_events;
+	struct input_event ev;
+	struct pollfd fds = {
+		.fd = fd_recv,
+		.events = POLLIN
+	};
+
+	num_events = poll(&fds, 1, 30);
+
+	TST_EXP_EQ_LI(num_events, 0);
+	if (!num_events)
+		return;
+
+	num_bytes = SAFE_READ(0, fd_recv, &ev, sizeof(ev));
+	if (!num_bytes)
+		return;
+
+	tst_res(TFAIL, "Received unexpected event: "
+		"type=%i, code=%i, value=%i",
+		ev.type,
+		ev.code,
+		ev.value);
+}
+#endif
diff --git a/testcases/kernel/input/input_helper.c b/testcases/kernel/input/input_helper.c
deleted file mode 100644
index 6ea8b66e4..000000000
--- a/testcases/kernel/input/input_helper.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <linux/input.h>
-#include <linux/uinput.h>
-#include <fnmatch.h>
-#include <errno.h>
-#include <poll.h>
-
-#include "test.h"
-#include "safe_macros.h"
-#include "input_helper.h"
-#include "lapi/uinput.h"
-
-#define VIRTUAL_DEVICE "virtual-device-ltp"
-
-#define VIRTUAL_DEVICE_REGEX "*virtual-device-ltp*"
-
-static int uinput_loaded;
-static int check_device(void);
-
-static int try_open_device(void)
-{
-	char path[256];
-	char name[256];
-	int ret, fd = -1;
-	unsigned int i;
-
-	for (i = 0; i < 1024; i++) {
-		snprintf(path, sizeof(path), "/dev/input/event%i", i);
-
-		fd = open(path, O_RDONLY);
-
-		if (fd < 0 && errno == ENOENT)
-			continue;
-
-		if (fd < 0) {
-			tst_resm(TINFO | TERRNO, "failed to open %s", path);
-			break;
-		}
-
-		ret = ioctl(fd, EVIOCGNAME(sizeof(name)), name);
-		if (ret < 0) {
-			tst_resm(TINFO | TERRNO,
-				"ioctl(%s, EVIOCGNAME(256), ...) failed",
-				path);
-			break;
-		}
-
-		if (strcmp(name, VIRTUAL_DEVICE) == 0)
-			return fd;
-		close(fd);
-	}
-
-	return -1;
-}
-
-int open_device(void)
-{
-	int fd;
-	int retries = 10;
-
-	while (retries--) {
-		fd = try_open_device();
-		if (fd > 0)
-			return fd;
-		tst_resm(TINFO, "Device not found, retrying...");
-		usleep(10000);
-	}
-
-	tst_brkm(TBROK, NULL, "Unable to find the input device");
-}
-
-static int try_load_uinput(void)
-{
-	const char *argv[] = {"modprobe", "uinput", NULL};
-	int ret;
-
-	tst_resm(TINFO, "Trying to load uinput kernel module");
-
-	ret = tst_cmd(NULL, argv, NULL, NULL, TST_CMD_PASS_RETVAL);
-	if (ret) {
-		tst_resm(TINFO, "Failed to load the uinput module");
-		return 0;
-	}
-
-	return 1;
-}
-
-static void unload_uinput(void)
-{
-	const char *argv[] = {"modprobe", "-r", "uinput", NULL};
-	int ret;
-
-	tst_resm(TINFO, "Unloading uinput kernel module");
-
-	ret = tst_cmd(NULL, argv, NULL, NULL, TST_CMD_PASS_RETVAL);
-	if (ret)
-		tst_resm(TWARN, "Failed to unload uinput module");
-}
-
-static const char *uinput_paths[] = {
-	"/dev/input/uinput",
-	"/dev/uinput",
-};
-
-static int try_open_uinput(void)
-{
-	unsigned int i;
-	int fd;
-
-	for (i = 0; i < ARRAY_SIZE(uinput_paths); i++) {
-		fd = open(uinput_paths[i], O_WRONLY | O_NONBLOCK);
-
-		if (fd > 0) {
-			tst_resm(TINFO, "Found uinput dev at %s",
-			         uinput_paths[i]);
-			return fd;
-		}
-
-		if (fd < 0 && errno != ENOENT) {
-			tst_brkm(TBROK | TERRNO, NULL,
-			         "open(%s)", uinput_paths[i]);
-		}
-	}
-
-	return -1;
-}
-
-int open_uinput(void)
-{
-	int fd;
-	int retries = 10;
-
-	fd = try_open_uinput();
-	if (fd > 0)
-		return fd;
-
-	if (try_load_uinput()) {
-		while (retries--) {
-			fd = try_open_uinput();
-			if (fd > 0) {
-				uinput_loaded = 1;
-				return fd;
-			}
-			tst_resm(TINFO, "Uinput dev not found, retrying...");
-			usleep(10000);
-		}
-
-		unload_uinput();
-	}
-
-	tst_brkm(TCONF, NULL, "Unable to find and open uinput");
-}
-
-void send_event(int fd, int event, int code, int value)
-{
-	struct input_event ev = {
-		.type = event,
-		.code = code,
-		.value = value,
-	};
-
-	SAFE_WRITE(NULL, SAFE_WRITE_ALL, fd, &ev, sizeof(ev));
-}
-
-void send_rel_move(int fd, int x, int y)
-{
-	send_event(fd, EV_REL, REL_X, x);
-	send_event(fd, EV_REL, REL_Y, y);
-	send_event(fd, EV_SYN, 0, 0);
-}
-
-static void check_ui_get_sysname_ioctl(int fd)
-{
-	char sys_name[256];
-	char dev_name[256];
-	char *path;
-
-	SAFE_IOCTL(NULL, fd, UI_GET_SYSNAME(sizeof(sys_name)), sys_name, NULL);
-	SAFE_ASPRINTF(NULL, &path, "/sys/devices/virtual/input/%s/name", sys_name);
-
-	if (FILE_SCANF(path, "%s", dev_name)) {
-		tst_resm(TFAIL|TERRNO, "Failed to read '%s'", path);
-		free(path);
-		return;
-	}
-
-	if (!strcmp(VIRTUAL_DEVICE, dev_name))
-		tst_resm(TPASS, "ioctl UI_GET_SYSNAME returned correct name");
-	else
-		tst_resm(TFAIL, "ioctl UI_GET_SYSNAME returned wrong name");
-
-	free(path);
-}
-
-void create_device(int fd)
-{
-	int nb;
-	struct uinput_user_dev uidev = {
-		.name = VIRTUAL_DEVICE,
-		.id = {
-			.bustype = BUS_USB,
-			.vendor = 0x1,
-			.product = 0x1,
-			.version = 1,
-		}
-	};
-
-	SAFE_WRITE(NULL, SAFE_WRITE_ALL, fd, &uidev, sizeof(uidev));
-	SAFE_IOCTL(NULL, fd, UI_DEV_CREATE, NULL);
-
-	for (nb = 100; nb > 0; nb--) {
-		if (check_device()) {
-			check_ui_get_sysname_ioctl(fd);
-			return;
-		}
-		usleep(10000);
-	}
-
-	destroy_device(fd);
-	tst_brkm(TBROK, NULL, "Failed to create device");
-}
-
-void setup_mouse_events(int fd)
-{
-	SAFE_IOCTL(NULL, fd, UI_SET_EVBIT, EV_KEY);
-	SAFE_IOCTL(NULL, fd, UI_SET_KEYBIT, BTN_LEFT);
-	SAFE_IOCTL(NULL, fd, UI_SET_EVBIT, EV_REL);
-	SAFE_IOCTL(NULL, fd, UI_SET_RELBIT, REL_X);
-	SAFE_IOCTL(NULL, fd, UI_SET_RELBIT, REL_Y);
-}
-
-void destroy_device(int fd)
-{
-	SAFE_IOCTL(NULL, fd, UI_DEV_DESTROY, NULL);
-	SAFE_CLOSE(NULL, fd);
-
-	if (uinput_loaded)
-		unload_uinput();
-}
-
-int check_event_code(struct input_event *iev, int event, int code)
-{
-	return iev->type == event && iev->code == code;
-}
-
-int check_sync_event(struct input_event *iev)
-{
-	return check_event_code(iev, EV_SYN, SYN_REPORT);
-}
-
-/*
- * the value of stray_sync_event:
- * 0: EV_SYN/SYN_REPORT events should not be received in /dev/input/eventX
- * 1: EV_SYN/SYN_REPORT events may be received in /dev/input/eventX
- * On an old kernel(before v3.7.0), EV_SYN/SYN_REPORT events are always
- * received even though we send empty moves.
- */
-int no_events_queued(int fd, int stray_sync_event)
-{
-	struct pollfd fds = {.fd = fd, .events = POLLIN};
-	int ret, res;
-	struct input_event ev;
-
-	ret = poll(&fds, 1, 30);
-
-	if (ret > 0) {
-		res = read(fd, &ev, sizeof(ev));
-
-		if (res == sizeof(ev)) {
-			tst_resm(TINFO,
-				"Unexpected ev type=%i code=%i value=%i",
-				ev.type, ev.code, ev.value);
-		}
-	}
-
-	return ret == 0;
-}
-
-static int check_device(void)
-{
-	FILE *file;
-	char line[256];
-
-	file = fopen("/proc/bus/input/devices", "r");
-	if (!file)
-		return 0;
-
-	while (fgets(line, 256, file)) {
-		if (fnmatch(VIRTUAL_DEVICE_REGEX, line, 0) == 0)
-			return 1;
-	}
-
-	fclose(file);
-
-	return 0;
-}
diff --git a/testcases/kernel/input/input_helper.h b/testcases/kernel/input/input_helper.h
deleted file mode 100644
index 7f61be1e9..000000000
--- a/testcases/kernel/input/input_helper.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it would be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write the Free Software Foundation,
- * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef INPUT_HELPER_H
-#define INPUT_HELPER_H
-
-#include <sys/types.h>
-#include <dirent.h>
-
-int open_device(void);
-void send_rel_move(int fd, int x, int y);
-void send_event(int fd, int event, int code, int value);
-int open_uinput(void);
-void create_device(int fd);
-void setup_mouse_events(int fd);
-void destroy_device(int fd);
-int check_event_code(struct input_event *iev, int event, int code);
-int check_sync_event(struct input_event *iev);
-int no_events_queued(int fd, int stray_sync_event);
-
-#endif /* INPUT_HELPER_H */
diff --git a/testcases/kernel/io/ltp-aiodio/aio-stress.c b/testcases/kernel/io/ltp-aiodio/aio-stress.c
index c29ede671..419fc2cd2 100644
--- a/testcases/kernel/io/ltp-aiodio/aio-stress.c
+++ b/testcases/kernel/io/ltp-aiodio/aio-stress.c
@@ -1347,7 +1347,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.needs_tmpdir = 1,
 	.needs_root = 1,
-	.max_runtime = 1800,
+	.timeout = 1800,
 	.options = (struct tst_option[]){
 		{ "a:", &str_iterations, "Total number of ayncs I/O the program will run (default 500)" },
 		{ "b:", &str_max_io_submit, "Max number of iocbs to give io_submit at once" },
diff --git a/testcases/kernel/io/ltp-aiodio/aiocp.c b/testcases/kernel/io/ltp-aiodio/aiocp.c
index 6212d8ee8..c201505ae 100644
--- a/testcases/kernel/io/ltp-aiodio/aiocp.c
+++ b/testcases/kernel/io/ltp-aiodio/aiocp.c
@@ -322,7 +322,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.needs_tmpdir = 1,
-	.max_runtime = 1800,
+	.runtime = 1800,
 	.needs_root = 1,
 	.options = (struct tst_option[]) {
 		{"b:", &str_aio_blksize, "Size of writing blocks (default 1K)"},
diff --git a/testcases/kernel/io/ltp-aiodio/aiodio_append.c b/testcases/kernel/io/ltp-aiodio/aiodio_append.c
index 45e96879e..e6280d3e8 100644
--- a/testcases/kernel/io/ltp-aiodio/aiodio_append.c
+++ b/testcases/kernel/io/ltp-aiodio/aiodio_append.c
@@ -190,7 +190,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
-	.max_runtime = 1800,
+	.runtime = 1800,
 	.options = (struct tst_option[]) {
 		{"n:", &str_numchildren, "Number of threads (default 16)"},
 		{"s:", &str_writesize, "Size of the file to write (default 64K)"},
diff --git a/testcases/kernel/io/ltp-aiodio/aiodio_sparse.c b/testcases/kernel/io/ltp-aiodio/aiodio_sparse.c
index 595c76226..8f41fdbe1 100644
--- a/testcases/kernel/io/ltp-aiodio/aiodio_sparse.c
+++ b/testcases/kernel/io/ltp-aiodio/aiodio_sparse.c
@@ -244,7 +244,7 @@ static struct tst_test test = {
 		"tmpfs",
 		NULL
 	},
-	.max_runtime = 1800,
+	.runtime = 1800,
 };
 #else
 TST_TEST_TCONF("test requires libaio and its development packages");
diff --git a/testcases/kernel/io/ltp-aiodio/dio_append.c b/testcases/kernel/io/ltp-aiodio/dio_append.c
index 0ecb76e2f..16bed5db2 100644
--- a/testcases/kernel/io/ltp-aiodio/dio_append.c
+++ b/testcases/kernel/io/ltp-aiodio/dio_append.c
@@ -96,7 +96,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
-	.max_runtime = 1800,
+	.runtime = 1800,
 	.options = (struct tst_option[]) {
 		{"n:", &str_numchildren, "Number of processes (default 16)"},
 		{"w:", &str_writesize, "Write size for each append (default 64K)"},
diff --git a/testcases/kernel/io/ltp-aiodio/dio_read.c b/testcases/kernel/io/ltp-aiodio/dio_read.c
index 54a0bc5c2..e6d1b7438 100644
--- a/testcases/kernel/io/ltp-aiodio/dio_read.c
+++ b/testcases/kernel/io/ltp-aiodio/dio_read.c
@@ -178,7 +178,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
-	.max_runtime = 1800,
+	.runtime = 1800,
 	.options = (struct tst_option[]) {
 		{"n:", &str_numchildren, "Number of threads (default 8)"},
 		{"w:", &str_writesize, "Size of writing blocks (default 32M)"},
diff --git a/testcases/kernel/io/ltp-aiodio/dio_sparse.c b/testcases/kernel/io/ltp-aiodio/dio_sparse.c
index 04b93ff2b..755668220 100644
--- a/testcases/kernel/io/ltp-aiodio/dio_sparse.c
+++ b/testcases/kernel/io/ltp-aiodio/dio_sparse.c
@@ -135,5 +135,5 @@ static struct tst_test test = {
 		"tmpfs",
 		NULL
 	},
-	.max_runtime = 1800,
+	.runtime = 1800,
 };
diff --git a/testcases/kernel/io/ltp-aiodio/dio_truncate.c b/testcases/kernel/io/ltp-aiodio/dio_truncate.c
index 2c54f8981..69799e6a2 100644
--- a/testcases/kernel/io/ltp-aiodio/dio_truncate.c
+++ b/testcases/kernel/io/ltp-aiodio/dio_truncate.c
@@ -170,7 +170,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
-	.max_runtime = 1800,
+	.runtime = 1800,
 	.options = (struct tst_option[]) {
 		{"n:", &str_numchildren, "Number of threads (default 16)"},
 		{"s:", &str_filesize, "Size of file (default 64K)"},
diff --git a/testcases/kernel/kvm/kvm_pagefault01.c b/testcases/kernel/kvm/kvm_pagefault01.c
index 91891848a..16b3137c0 100644
--- a/testcases/kernel/kvm/kvm_pagefault01.c
+++ b/testcases/kernel/kvm/kvm_pagefault01.c
@@ -193,16 +193,14 @@ static void reload_module(const char *module, char *arg)
 
 static void disable_tdp(void)
 {
-	if (!access(TDP_MMU_SYSFILE, F_OK)) {
-		/* FIXME: Is setting tdp_mmu=0 sufficient to disable TDP? */
-		return;
-	}
-
 	if (read_bool_sys_param(TDP_AMD_SYSFILE) > 0)
 		reload_module("kvm_amd", "npt=0");
 
 	if (read_bool_sys_param(TDP_INTEL_SYSFILE) > 0)
 		reload_module("kvm_intel", "ept=0");
+
+	if (read_bool_sys_param(TDP_MMU_SYSFILE) > 0)
+		tst_res(TINFO, "WARNING: tdp_mmu is enabled, beware of false negatives");
 }
 
 static void setup(void)
@@ -216,11 +214,6 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = tst_kvm_cleanup,
 	.needs_root = 1,
-	.save_restore = (const struct tst_path_val[]) {
-		{"/sys/module/kvm/parameters/tdp_mmu", "0",
-			TST_SR_SKIP_MISSING | TST_SR_TCONF_RO},
-		{}
-	},
 	.supported_archs = (const char *const []) {
 		"x86_64",
 		NULL
diff --git a/testcases/kernel/mem/.gitignore b/testcases/kernel/mem/.gitignore
index c96fe8bfc..699e022fb 100644
--- a/testcases/kernel/mem/.gitignore
+++ b/testcases/kernel/mem/.gitignore
@@ -34,6 +34,7 @@
 /hugetlb/hugemmap/hugemmap30
 /hugetlb/hugemmap/hugemmap31
 /hugetlb/hugemmap/hugemmap32
+/hugetlb/hugemmap/hugemmap34
 /hugetlb/hugeshmat/hugeshmat01
 /hugetlb/hugeshmat/hugeshmat02
 /hugetlb/hugeshmat/hugeshmat03
@@ -47,6 +48,7 @@
 /hugetlb/hugeshmget/hugeshmget02
 /hugetlb/hugeshmget/hugeshmget03
 /hugetlb/hugeshmget/hugeshmget05
+/hugetlb/hugeshmget/hugeshmget06
 /ksm/ksm01
 /ksm/ksm02
 /ksm/ksm03
diff --git a/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate01.c b/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate01.c
index e4bb21e40..b7ab4e035 100644
--- a/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate01.c
+++ b/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate01.c
@@ -33,7 +33,7 @@ static void run_test(void)
 	int err;
 	unsigned long free_initial, free_after, free_after_delete;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 
 	free_initial = SAFE_READ_MEMINFO(MEMINFO_HPAGE_FREE);
 
diff --git a/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate02.c b/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate02.c
index 4a25666ac..d03f43d67 100644
--- a/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate02.c
+++ b/testcases/kernel/mem/hugetlb/hugefallocate/hugefallocate02.c
@@ -36,7 +36,7 @@ static void run_test(void)
 	free_initial = SAFE_READ_MEMINFO(MEMINFO_HPAGE_FREE);
 	max_iterations = MIN(free_initial, MAX_PAGES_TO_USE);
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 
 	/* First preallocate file with max_iterations pages */
 	err = fallocate(fd, 0, 0, hpage_size * max_iterations);
diff --git a/testcases/kernel/mem/hugetlb/hugefork/hugefork01.c b/testcases/kernel/mem/hugetlb/hugefork/hugefork01.c
index 90cefdba2..2404ffad1 100644
--- a/testcases/kernel/mem/hugetlb/hugefork/hugefork01.c
+++ b/testcases/kernel/mem/hugetlb/hugefork/hugefork01.c
@@ -66,7 +66,7 @@ static void run_test(void)
 static void setup(void)
 {
 	hpage_size = SAFE_READ_MEMINFO("Hugepagesize:")*1024;
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap01.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap01.c
index 3fc730002..de5133381 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap01.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap01.c
@@ -75,7 +75,7 @@ void setup(void)
 		tst_brk(TCONF, "Not enough hugepages for testing.");
 
 	if (!Hopt)
-		Hopt = tst_get_tmpdir();
+		Hopt = tst_tmpdir_path();
 	SAFE_MOUNT("none", Hopt, "hugetlbfs", 0, NULL);
 
 	snprintf(TEMPFILE, sizeof(TEMPFILE), "%s/mmapfile%d", Hopt, getpid());
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap02.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap02.c
index e818cd5a3..b788aeafb 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap02.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap02.c
@@ -122,7 +122,7 @@ static void setup(void)
 		tst_brk(TCONF, "Not enough hugepages for testing.");
 
 	if (!Hopt)
-		Hopt = tst_get_tmpdir();
+		Hopt = tst_tmpdir_path();
 	SAFE_MOUNT("none", Hopt, "hugetlbfs", 0, NULL);
 
 	snprintf(TEMPFILE, sizeof(TEMPFILE), "%s/mmapfile%d", Hopt, getpid());
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap04.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap04.c
index 6af032aa5..f52747e68 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap04.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap04.c
@@ -93,7 +93,7 @@ void setup(void)
 		tst_brk(TCONF, "Not enough hugepages for testing!");
 
 	if (!Hopt)
-		Hopt = tst_get_tmpdir();
+		Hopt = tst_tmpdir_path();
 	SAFE_MOUNT("none", Hopt, "hugetlbfs", 0, NULL);
 
 	snprintf(TEMPFILE, sizeof(TEMPFILE), "%s/mmapfile%d", Hopt, getpid());
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap07.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap07.c
index 846d22ff2..663d925f4 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap07.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap07.c
@@ -112,7 +112,7 @@ cleanup:
 static void setup(void)
 {
 	hpage_size = SAFE_READ_MEMINFO(MEMINFO_HPAGE_SIZE)*1024;
-	huge_fd = tst_creat_unlinked(MNTPOINT, 0);
+	huge_fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap08.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap08.c
index f01a9f365..e3dd43087 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap08.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap08.c
@@ -117,7 +117,7 @@ static void run_test(unsigned int test_type)
 static void setup(void)
 {
 	hpage_size = SAFE_READ_MEMINFO(MEMINFO_HPAGE_SIZE)*1024;
-	huge_fd = tst_creat_unlinked(MNTPOINT, 0);
+	huge_fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap09.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap09.c
index 336ccdf65..2a80edca9 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap09.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap09.c
@@ -59,7 +59,7 @@ static void run_test(void)
 static void setup(void)
 {
 	hpage_size = SAFE_READ_MEMINFO(MEMINFO_HPAGE_SIZE)*1024;
-	huge_fd = tst_creat_unlinked(MNTPOINT, 0);
+	huge_fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap10.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap10.c
index 0e1b64541..f918d5e2e 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap10.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap10.c
@@ -58,7 +58,7 @@ static int kernel_has_private_reservations(void)
 	void *p;
 
 	read_meminfo_huge(&t, &f, &r, &s);
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 
 	p = SAFE_MMAP(NULL, hpage_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
 
@@ -182,7 +182,7 @@ static int map_(int s, int hpages, int flags, char *desc, int line)
 {
 	long et, ef, er, es;
 
-	map_fd[s] = tst_creat_unlinked(MNTPOINT, 0);
+	map_fd[s] = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	map_size[s] = hpages * hpage_size;
 	map_addr[s] = SAFE_MMAP(NULL, map_size[s], PROT_READ|PROT_WRITE, flags,
 				map_fd[s], 0);
@@ -449,8 +449,8 @@ static struct tst_test test = {
 	.mntpoint = MNTPOINT,
 	.needs_hugetlbfs = 1,
 	.save_restore = (const struct tst_path_val[]) {
-		{PATH_OC_HPAGES, NULL},
-		{PATH_NR_HPAGES, NULL},
+		{PATH_OC_HPAGES, NULL, TST_SR_TCONF},
+		{PATH_NR_HPAGES, NULL, TST_SR_TCONF},
 		{}
 	},
 	.setup = setup,
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap11.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap11.c
index 496a814b5..a98594af6 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap11.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap11.c
@@ -23,7 +23,7 @@
 
 #define P0 "ffffffff"
 #define IOSZ 4096
-#define NORMAL_PATH ""
+#define NORMAL_PATH "./"
 #define MNTPOINT "hugetlbfs/"
 
 static long hpage_size;
@@ -34,8 +34,8 @@ static void run_test(void)
 	void *p;
 	char buf[IOSZ] __attribute__((aligned(IOSZ)));
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
-	nfd = tst_creat_unlinked(NORMAL_PATH, O_DIRECT);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
+	nfd = tst_creat_unlinked(NORMAL_PATH, O_DIRECT, 0600);
 	p = SAFE_MMAP(NULL, hpage_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
 	memcpy(p, P0, 8);
 
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap12.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap12.c
index 81367c513..848986cea 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap12.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap12.c
@@ -33,7 +33,7 @@ static void run_test(void)
 	void *p;
 	unsigned long initial_rsvd, map_rsvd, fadvise_rsvd, end_rsvd;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 
 	initial_rsvd = SAFE_READ_MEMINFO(MEMINFO_HPAGE_RSVD);
 	tst_res(TINFO, "Reserve count before map: %lu", initial_rsvd);
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap13.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap13.c
index 42b80064e..06b5f8e08 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap13.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap13.c
@@ -102,7 +102,7 @@ static void setup(void)
 		tst_brk(TCONF, "Machine must be >32 bit");
 	if (hpage_size > FOURGB)
 		tst_brk(TCONF, "Huge page size is too large");
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap14.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap14.c
index c54a746b3..d262b65b2 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap14.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap14.c
@@ -134,7 +134,7 @@ static void setup(void)
 		tst_brk(TCONF, "Machine must be >32 bit");
 	if (hpage_size > FOURGB)
 		tst_brk(TCONF, "Huge page size is too large");
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap15.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap15.c
index a84ba6476..ecfd51d0c 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap15.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap15.c
@@ -204,7 +204,7 @@ static void run_test(void)
 	SAFE_SIGACTION(SIGBUS, &sa, NULL);
 	SAFE_SIGACTION(SIGSEGV, &sa, NULL);
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 
 	for (i = 0; i < NUM_REPETITIONS; i++)
 		if (test_once(fd))
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap16.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap16.c
index 2003e7013..e0238636b 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap16.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap16.c
@@ -33,7 +33,7 @@ static void run_test(void)
 	void *p;
 	unsigned long initial_rsvd, map_rsvd, madvise_rsvd, end_rsvd;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 
 	initial_rsvd = SAFE_READ_MEMINFO(MEMINFO_HPAGE_RSVD);
 	tst_res(TINFO, "Reserve count before map: %lu", initial_rsvd);
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap17.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap17.c
index b8105bbf3..cca0291ad 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap17.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap17.c
@@ -79,7 +79,7 @@ static void setup(void)
 		tst_brk(TCONF, "Huge page size is too large");
 	if (TRUNCATE_POINT % hpage_size)
 		tst_brk(TCONF, "Truncation point is not aligned to huge page size");
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap18.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap18.c
index 607072937..afd7ad3f7 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap18.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap18.c
@@ -129,7 +129,7 @@ static void setup(void)
 {
 	hpage_size = SAFE_READ_MEMINFO("Hugepagesize:")*1024;
 	page_size = getpagesize();
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap19.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap19.c
index 11060125b..c0e41dfa3 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap19.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap19.c
@@ -123,7 +123,7 @@ static void setup(void)
 {
 	page_size = getpagesize();
 	hpage_size = SAFE_READ_MEMINFO("Hugepagesize:")*1024;
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap20.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap20.c
index e6b6bda76..3d3a95866 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap20.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap20.c
@@ -35,7 +35,7 @@ static void run_test(unsigned int i)
 	void *p;
 	struct tcase *tc = &tcases[i];
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	p = SAFE_MMAP(0, hpage_size, PROT_READ|PROT_WRITE, tc->flags, fd, 0);
 
 	ret = mlock(p, hpage_size);
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap21.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap21.c
index 7abfda92d..faebbd228 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap21.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap21.c
@@ -94,7 +94,7 @@ static void run_test(void)
 static void setup(void)
 {
 	hpage_size = tst_get_hugepage_size();
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap22.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap22.c
index c2deab477..d9be8113e 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap22.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap22.c
@@ -29,7 +29,7 @@ static void run_test(unsigned int iter)
 	char pattern = 'A';
 	size_t size = NR_HUGEPAGES*hpage_size;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	m = SAFE_MMAP(NULL, size, (PROT_READ|PROT_WRITE), MAP_SHARED, fd, 0);
 
 	for (i = 0; i < NR_HUGEPAGES; i++) {
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap23.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap23.c
index d755161c9..3bcba0580 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap23.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap23.c
@@ -197,7 +197,7 @@ static void setup(void)
 	hpage_size = tst_get_hugepage_size();
 	SAFE_SIGACTION(SIGSEGV, &sa, NULL);
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	addr = SAFE_MMAP(NULL, 2*hpage_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
 	memset(addr, 0, hpage_size);
 	SAFE_MUNMAP(addr, hpage_size);
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap24.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap24.c
index 3ba0985dc..ab6a3310a 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap24.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap24.c
@@ -85,7 +85,7 @@ static void run_test(void)
 	long p_size, q_size;
 	int ret;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	ret = init_slice_boundary(fd);
 	if (ret)
 		goto cleanup;
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap25.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap25.c
index 71beb90d3..1ad8a4141 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap25.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap25.c
@@ -76,7 +76,7 @@ static void run_test(void)
 	void *p;
 	int ret;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	p = map_align(3*hpage_size, hpage_size);
 
 	SAFE_MUNMAP(p, hpage_size);
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap26.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap26.c
index 609f2b63b..21be2d376 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap26.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap26.c
@@ -55,7 +55,7 @@ static void run_test(void)
 	void *p;
 	int ret;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	p = SAFE_MMAP(NULL, 3*hpage_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
 
 	SAFE_MUNMAP(p, hpage_size);
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap27.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap27.c
index 218d9e190..bafae1ca8 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap27.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap27.c
@@ -99,8 +99,8 @@ cleanup:
 static void setup(void)
 {
 	hpage_size = tst_get_hugepage_size();
-	fd1 = tst_creat_unlinked(MNTPOINT, 0);
-	fd2 = tst_creat_unlinked(MNTPOINT, 0);
+	fd1 = tst_creat_unlinked(MNTPOINT, 0, 0600);
+	fd2 = tst_creat_unlinked(MNTPOINT, 0, 0600);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap28.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap28.c
index 060d1c858..660c93953 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap28.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap28.c
@@ -26,7 +26,7 @@ static void run_test(void)
 
 	initial_resv = SAFE_READ_MEMINFO(MEMINFO_HPAGE_RSVD);
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	p = SAFE_MMAP(NULL, hpage_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
 
 	q = SAFE_MMAP(NULL, hpage_size,
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap29.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap29.c
index 6bff2c8e6..67857615a 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap29.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap29.c
@@ -29,7 +29,7 @@ static void run_test(void)
 	unsigned int *pl, *ql;
 	unsigned long i;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	p = SAFE_MMAP(NULL, hpage_size, PROT_READ|PROT_WRITE, MAP_SHARED,
 		 fd, 0);
 
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap30.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap30.c
index 7ed9046f3..61b28c781 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap30.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap30.c
@@ -27,7 +27,7 @@ static void run_test(void)
 	void *p;
 	unsigned long initial_rsvd, map_rsvd, readahead_rsvd, end_rsvd;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	initial_rsvd = SAFE_READ_MEMINFO(MEMINFO_HPAGE_RSVD);
 
 	p = SAFE_MMAP(NULL, hpage_size, PROT_READ|PROT_WRITE, MAP_SHARED,
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap31.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap31.c
index 9072e9de4..171dbb070 100644
--- a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap31.c
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap31.c
@@ -26,7 +26,7 @@ static void run_test(void)
 	unsigned long *pl, *ql;
 	unsigned long i;
 
-	fd = tst_creat_unlinked(MNTPOINT, 0);
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
 	p = SAFE_MMAP(NULL, hpage_size, PROT_READ|PROT_WRITE, MAP_SHARED,
 		 fd, 0);
 
diff --git a/testcases/kernel/mem/hugetlb/hugemmap/hugemmap34.c b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap34.c
new file mode 100644
index 000000000..3b92c9565
--- /dev/null
+++ b/testcases/kernel/mem/hugetlb/hugemmap/hugemmap34.c
@@ -0,0 +1,216 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2005-2006 IBM Corporation
+ * Author: David Gibson & Adam Litke
+ */
+
+/*\
+ * [Description]
+ *
+ * On PowerPC, the address space is divided into segments.  These segments can
+ * contain either huge pages or normal pages, but not both.  All segments are
+ * initially set up to map normal pages.  When a huge page mapping is created
+ * within a set of empty segments, they are "enabled" for huge pages at that
+ * time.  Once enabled for huge pages, they can not be used again for normal
+ * pages for the remaining lifetime of the process.
+ *
+ * If the segment immediately preceeding the segment containing the stack is
+ * converted to huge pages and the stack is made to grow into the this
+ * preceeding segment, some kernels may attempt to map normal pages into the
+ * huge page-only segment -- resulting in bugs.
+ */
+
+#define _GNU_SOURCE
+#include "lapi/mmap.h"
+#include "hugetlb.h"
+#include <errno.h>
+#include <inttypes.h>
+#include <sched.h>
+
+#ifdef __LP64__
+#define STACK_ALLOCATION_SIZE	(256*1024*1024)
+#else
+#define STACK_ALLOCATION_SIZE	(16*1024*1024)
+#endif
+#define MNTPOINT "hugetlbfs/"
+#define PATH_HUGEPAGE "/sys/kernel/mm/hugepages"
+
+#define STACKS_MAX 64
+
+static int  fd = -1;
+static uintptr_t hpage_size, stacks[STACKS_MAX];
+static int stacks_num;
+static void *hpage_addr, *stack_addr;
+static void **shared_area;
+
+int do_child(void *stop_address)
+{
+	volatile char *x;
+
+	/* corefile from this process is not interesting and limiting
+	 * its size can save a lot of time. '1' is a special value,
+	 * that will also abort dumping via pipe, which by default
+	 * sets limit to RLIM_INFINITY.
+	 */
+	tst_no_corefile(1);
+	tst_res(TINFO, "Child process starting with top of stack at %p", &x);
+
+	do {
+		x = alloca(STACK_ALLOCATION_SIZE);
+		*shared_area = (void *)x;
+		*x = 1;
+	} while ((void *)x >= stop_address);
+	exit(0);
+}
+
+static void run_test(void)
+{
+	int pid, status;
+
+	pid = ltp_clone(CLONE_VM | CLONE_VFORK | SIGCHLD, do_child,
+		hpage_addr, hpage_size, stack_addr);
+	if (pid == 0)
+		do_child(hpage_addr);
+
+	SAFE_WAITPID(pid, &status, 0);
+	tst_res(TINFO, "Child process extended stack up to %p, hasn't reached %p",
+		*shared_area, *shared_area - STACK_ALLOCATION_SIZE);
+	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV)
+		tst_res(TPASS, "Child killed by %s as expected", tst_strsig(SIGSEGV));
+	else
+		tst_res(TFAIL, "Child: %s", tst_strstatus(status));
+}
+
+/* Return start address of next mapping or 0 */
+static uintptr_t  get_next_mapping_start(uintptr_t addr)
+{
+	FILE *fp = fopen("/proc/self/maps", "r");
+
+	if (fp == NULL)
+		tst_brk(TBROK | TERRNO, "Failed to open /proc/self/maps.");
+
+	while (!feof(fp)) {
+		uintptr_t start, end;
+		int ret;
+
+		ret = fscanf(fp, "%"PRIxPTR"-%"PRIxPTR" %*[^\n]\n", &start, &end);
+		if (ret != 2) {
+			fclose(fp);
+			tst_brk(TBROK | TERRNO, "Couldn't parse /proc/self/maps line.");
+		}
+
+		if (start > addr) {
+			fclose(fp);
+			return start;
+		}
+	}
+	fclose(fp);
+	return 0;
+}
+
+static int is_addr_in_stacks(uintptr_t addr)
+{
+	int i;
+
+	for (i = 0; i < stacks_num; i++) {
+		if (addr == stacks[i])
+			return 1;
+	}
+	return 0;
+}
+
+void setup(void)
+{
+	struct rlimit r;
+	int i;
+
+	hpage_size = tst_get_hugepage_size();
+	/*
+	 * Setting the stack size to unlimited.
+	 */
+	r.rlim_cur = RLIM_INFINITY;
+	r.rlim_max = RLIM_INFINITY;
+	SAFE_SETRLIMIT(RLIMIT_STACK, &r);
+	SAFE_GETRLIMIT(RLIMIT_STACK, &r);
+	if (r.rlim_cur != RLIM_INFINITY)
+		tst_brk(TCONF, "Stack rlimit must be 'unlimited'");
+
+	fd = tst_creat_unlinked(MNTPOINT, 0, 0600);
+
+	/* shared memory to pass a (void *) from child process */
+	shared_area = SAFE_MMAP(0, getpagesize(), PROT_READ|PROT_WRITE,
+		MAP_SHARED|MAP_ANONYMOUS, -1, 0);
+
+	/*
+	 * We search for potential stack addresses by looking at
+	 * places where kernel would map next huge page and occupying that
+	 * address as potential stack. When huge page lands in such place
+	 * that next mapping is one of our stack mappings, we use those
+	 * two for the test. We try to map huge pages in child process so that
+	 * slices in parent are not affected.
+	 */
+	tst_res(TINFO, "searching for huge page and child stack placement");
+	for (i = 0; i < STACKS_MAX; i++) {
+		uintptr_t next_start;
+		int pid, status;
+
+		pid = SAFE_FORK();
+		if (pid == 0) {
+			*shared_area = SAFE_MMAP(0, hpage_size, PROT_READ|PROT_WRITE,
+				MAP_PRIVATE, fd, 0);
+			SAFE_MUNMAP(*shared_area, hpage_size);
+			exit(0);
+		}
+		SAFE_WAITPID(pid, &status, 0);
+		if (status != 0)
+			tst_brk(TFAIL, "Child: %s", tst_strstatus(status));
+
+		next_start = get_next_mapping_start((uintptr_t)*shared_area);
+		if (is_addr_in_stacks(next_start)) {
+			stack_addr = (void *)next_start;
+			hpage_addr = *shared_area;
+			break;
+		}
+
+		tst_res(TINFO, "potential stack at address %p", *shared_area);
+		stacks[stacks_num++] = (uintptr_t) SAFE_MMAP(*shared_area, hpage_size,
+			PROT_READ|PROT_WRITE,
+			MAP_ANONYMOUS|MAP_PRIVATE|MAP_GROWSDOWN, -1, 0);
+	}
+
+	if (!stack_addr)
+		tst_brk(TCONF, "failed to find good place for huge page and stack");
+
+	hpage_addr = mmap(hpage_addr, hpage_size, PROT_READ|PROT_WRITE,
+		MAP_SHARED|MAP_FIXED, fd, 0);
+	if (hpage_addr == MAP_FAILED) {
+		if (errno == ENOMEM)
+			tst_brk(TCONF, "Not enough memory.");
+		tst_brk(TBROK|TERRNO, "mmap failed");
+	}
+	tst_res(TINFO, "stack = %p-%p, hugepage = %p-%p", stack_addr, stack_addr+hpage_size,
+			hpage_addr, hpage_addr+hpage_size);
+}
+
+void cleanup(void)
+{
+	if (fd > 0)
+		SAFE_CLOSE(fd);
+}
+
+static struct tst_test test = {
+	.tags = (struct tst_tag[]) {
+		{"linux-git", "0d59a01bc461"},
+		{}
+	},
+	.needs_root = 1,
+	.mntpoint = MNTPOINT,
+	.needs_hugetlbfs = 1,
+	.needs_tmpdir = 1,
+	.setup = setup,
+	.cleanup = cleanup,
+	.test_all = run_test,
+	.hugepages = {1, TST_NEEDS},
+	.forks_child = 1,
+	.supported_archs = (const char *const []){"ppc", "ppc64", NULL},
+};
diff --git a/testcases/kernel/mem/hugetlb/hugeshmget/hugeshmget06.c b/testcases/kernel/mem/hugetlb/hugeshmget/hugeshmget06.c
new file mode 100644
index 000000000..998b85e9c
--- /dev/null
+++ b/testcases/kernel/mem/hugetlb/hugeshmget/hugeshmget06.c
@@ -0,0 +1,76 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2005-2006, IBM Corporation.
+ * Author: David Gibson & Adam Litke
+ */
+
+/*\
+ * [Description]
+ *
+ * This testcase creates shared memory segments backed by hugepages,
+ * writes specific patterns to each segment, verifies pattern,
+ * and detaches a shared memory segments in a loop.
+ * It ensures that the hugepage backed shared memory functionalities
+ * works correctly by validating the data written to segment.
+ */
+
+#include "hugetlb.h"
+#include "tst_safe_sysv_ipc.h"
+
+#define NR_HUGEPAGES 4
+
+static long hpage_size;
+static int shmid = -1;
+
+static void run_test(void)
+{
+	size_t i, j;
+	char pattern;
+	char *shmaddr;
+
+	shmaddr = SAFE_SHMAT(shmid, 0, SHM_RND);
+	tst_res(TINFO, "shmaddr: %p", shmaddr);
+
+	for (i = 0; i < NR_HUGEPAGES; i++) {
+		pattern = 65 + (i % 26);
+		tst_res(TDEBUG, "Touching %p with %c",
+		shmaddr + (i * hpage_size), pattern);
+		memset(shmaddr + (i * hpage_size), pattern, hpage_size);
+	}
+
+	for (i = 0; i < NR_HUGEPAGES; i++) {
+		pattern = 65 + (i % 26);
+		tst_res(TDEBUG, "Verifying %p", (shmaddr + (i * hpage_size)));
+		for (j = 0; j < (size_t)hpage_size; j++)
+			if (*(shmaddr + (i * hpage_size) + j) != pattern) {
+				tst_res(TFAIL, "Got wrong byte 0x%02x expected 0x%02x",
+						*(shmaddr + (i * hpage_size) + j),
+						pattern);
+				return;
+			}
+	}
+	SAFE_SHMDT((const void *)shmaddr);
+	tst_res(TPASS, "shm hugepages works correctly");
+}
+
+static void setup(void)
+{
+	hpage_size = tst_get_hugepage_size();
+	tst_res(TINFO, "hugepage size is %ld", hpage_size);
+	shmid = SAFE_SHMGET(IPC_PRIVATE, NR_HUGEPAGES * hpage_size, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);
+	tst_res(TINFO, "shmid: 0x%x", shmid);
+}
+
+static void cleanup(void)
+{
+	if (shmid >= 0)
+		SAFE_SHMCTL(shmid, IPC_RMID, NULL);
+}
+
+static struct tst_test test = {
+	.needs_root = 1,
+	.setup = setup,
+	.cleanup = cleanup,
+	.test_all = run_test,
+	.hugepages = {NR_HUGEPAGES, TST_NEEDS},
+};
diff --git a/testcases/kernel/mem/hugetlb/lib/hugetlb.h b/testcases/kernel/mem/hugetlb/lib/hugetlb.h
index 34fe08c24..a694514d2 100644
--- a/testcases/kernel/mem/hugetlb/lib/hugetlb.h
+++ b/testcases/kernel/mem/hugetlb/lib/hugetlb.h
@@ -17,7 +17,6 @@
 #include <errno.h>
 #include <sys/wait.h>
 #include "tst_test.h"
-#include "old_tmpdir.h"
 #include "mem.h"
 
 #define PALIGN(p, a) ((void *)LTP_ALIGN((unsigned long)(p), (a)))
diff --git a/testcases/kernel/mem/ksm/Makefile b/testcases/kernel/mem/ksm/Makefile
index 236625690..6aba73e61 100644
--- a/testcases/kernel/mem/ksm/Makefile
+++ b/testcases/kernel/mem/ksm/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpnuma
+LTPLIBS = numa
 ksm06: LTPLDLIBS = -lltpnuma
 
 include $(top_srcdir)/include/mk/testcases.mk
diff --git a/testcases/kernel/mem/ksm/ksm02.c b/testcases/kernel/mem/ksm/ksm02.c
index 3707de95d..ab0725303 100644
--- a/testcases/kernel/mem/ksm/ksm02.c
+++ b/testcases/kernel/mem/ksm/ksm02.c
@@ -87,7 +87,7 @@ static void setup(void)
 	parse_ksm_options(opt_sizestr, &size, opt_numstr, &num, opt_unitstr, &unit);
 
 	if (opt_sizestr && size > DEFAULT_MEMSIZE)
-		tst_set_max_runtime(32 * (size / DEFAULT_MEMSIZE));
+		tst_set_timeout(32 * (size / DEFAULT_MEMSIZE));
 }
 
 static struct tst_test test = {
@@ -116,7 +116,7 @@ static struct tst_test test = {
 		NULL
 	},
 	.test_all = verify_ksm,
-	.max_runtime = 32,
+	.timeout = 32,
 	.needs_cgroup_ctrls = (const char *const []){ "cpuset", NULL },
 };
 
diff --git a/testcases/kernel/mem/ksm/ksm04.c b/testcases/kernel/mem/ksm/ksm04.c
index f558b23be..7b478c46d 100644
--- a/testcases/kernel/mem/ksm/ksm04.c
+++ b/testcases/kernel/mem/ksm/ksm04.c
@@ -74,7 +74,7 @@ static void setup(void)
 	SAFE_CG_PRINTF(tst_cg, "cgroup.procs", "%d", getpid());
 
 	if (opt_sizestr && size > DEFAULT_MEMSIZE)
-		tst_set_max_runtime(32 * (size / DEFAULT_MEMSIZE));
+		tst_set_timeout(32 * (size / DEFAULT_MEMSIZE));
 }
 
 static struct tst_test test = {
@@ -103,7 +103,7 @@ static struct tst_test test = {
 		NULL
 	},
 	.test_all = verify_ksm,
-	.max_runtime = 32,
+	.timeout = 32,
 	.needs_cgroup_ctrls = (const char *const []){
 		"memory", "cpuset", NULL
 	},
diff --git a/testcases/kernel/mem/mmapstress/mmapstress01.c b/testcases/kernel/mem/mmapstress/mmapstress01.c
index 9189f113e..5ba09208d 100644
--- a/testcases/kernel/mem/mmapstress/mmapstress01.c
+++ b/testcases/kernel/mem/mmapstress/mmapstress01.c
@@ -362,7 +362,7 @@ static struct tst_test test = {
 		{},
 	},
 	.cleanup = cleanup,
-	.max_runtime = 12,
+	.runtime = 12,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
 };
diff --git a/testcases/kernel/mem/mtest01/mtest01.c b/testcases/kernel/mem/mtest01/mtest01.c
index fb991ce8b..04fde9590 100644
--- a/testcases/kernel/mem/mtest01/mtest01.c
+++ b/testcases/kernel/mem/mtest01/mtest01.c
@@ -235,7 +235,7 @@ static struct tst_test test = {
 		{"v",  &verbose,     	"Verbose"},
 		{}
 	},
-	.max_runtime = 300,
+	.runtime = 300,
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = mem_test,
diff --git a/testcases/kernel/mem/mtest06/mmap1.c b/testcases/kernel/mem/mtest06/mmap1.c
index 907597d16..4e67f5fb9 100644
--- a/testcases/kernel/mem/mtest06/mmap1.c
+++ b/testcases/kernel/mem/mtest06/mmap1.c
@@ -249,6 +249,6 @@ static void run(void)
 static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
-	.max_runtime = 180,
+	.runtime = 180,
 	.needs_tmpdir = 1,
 };
diff --git a/testcases/kernel/mem/mtest06/mmap3.c b/testcases/kernel/mem/mtest06/mmap3.c
index 19f4e33df..6cebc6fbe 100644
--- a/testcases/kernel/mem/mtest06/mmap3.c
+++ b/testcases/kernel/mem/mtest06/mmap3.c
@@ -182,5 +182,5 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = test_mmap,
-	.max_runtime = 60,
+	.runtime = 60,
 };
diff --git a/testcases/kernel/mem/mtest07/mallocstress.c b/testcases/kernel/mem/mtest07/mallocstress.c
index 2d047cf6f..f5b4f3016 100644
--- a/testcases/kernel/mem/mtest07/mallocstress.c
+++ b/testcases/kernel/mem/mtest07/mallocstress.c
@@ -194,7 +194,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
-	.max_runtime = 600,
+	.runtime = 600,
 	.needs_checkpoints = 1,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/mem/oom/oom01.c b/testcases/kernel/mem/oom/oom01.c
index 903785f93..ddb904459 100644
--- a/testcases/kernel/mem/oom/oom01.c
+++ b/testcases/kernel/mem/oom/oom01.c
@@ -36,7 +36,7 @@ static void verify_oom(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = TST_UNLIMITED_RUNTIME,
+	.timeout = TST_UNLIMITED_TIMEOUT,
 	.test_all = verify_oom,
 	.skip_in_compat = 1,
 	.save_restore = (const struct tst_path_val[]) {
diff --git a/testcases/kernel/mem/oom/oom02.c b/testcases/kernel/mem/oom/oom02.c
index 087d61abe..50b514cb4 100644
--- a/testcases/kernel/mem/oom/oom02.c
+++ b/testcases/kernel/mem/oom/oom02.c
@@ -45,7 +45,7 @@ static void setup(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = TST_UNLIMITED_RUNTIME,
+	.timeout = TST_UNLIMITED_TIMEOUT,
 	.setup = setup,
 	.test_all = verify_oom,
 	.skip_in_compat = 1,
diff --git a/testcases/kernel/mem/oom/oom03.c b/testcases/kernel/mem/oom/oom03.c
index 1041a6a1d..873a6d84c 100644
--- a/testcases/kernel/mem/oom/oom03.c
+++ b/testcases/kernel/mem/oom/oom03.c
@@ -71,7 +71,7 @@ static void setup(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = TST_UNLIMITED_RUNTIME,
+	.timeout = TST_UNLIMITED_TIMEOUT,
 	.setup = setup,
 	.test_all = verify_oom,
 	.needs_cgroup_ctrls = (const char *const []){ "memory", NULL },
diff --git a/testcases/kernel/mem/oom/oom04.c b/testcases/kernel/mem/oom/oom04.c
index 3f0bcf7e2..94e70f3c5 100644
--- a/testcases/kernel/mem/oom/oom04.c
+++ b/testcases/kernel/mem/oom/oom04.c
@@ -67,7 +67,7 @@ static void setup(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = TST_UNLIMITED_RUNTIME,
+	.timeout = TST_UNLIMITED_TIMEOUT,
 	.setup = setup,
 	.test_all = verify_oom,
 	.needs_cgroup_ctrls = (const char *const []){ "cpuset", NULL },
diff --git a/testcases/kernel/mem/oom/oom05.c b/testcases/kernel/mem/oom/oom05.c
index 74f0f78b3..16e4018cf 100644
--- a/testcases/kernel/mem/oom/oom05.c
+++ b/testcases/kernel/mem/oom/oom05.c
@@ -88,7 +88,7 @@ void setup(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = TST_UNLIMITED_RUNTIME,
+	.timeout = TST_UNLIMITED_TIMEOUT,
 	.setup = setup,
 	.test_all = verify_oom,
 	.needs_cgroup_ctrls = (const char *const []){
diff --git a/testcases/kernel/mem/swapping/swapping01.c b/testcases/kernel/mem/swapping/swapping01.c
index 79dd2b4d5..df1dcdf56 100644
--- a/testcases/kernel/mem/swapping/swapping01.c
+++ b/testcases/kernel/mem/swapping/swapping01.c
@@ -174,7 +174,7 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
 	.min_mem_avail = 10,
-	.max_runtime = 600,
+	.runtime = 600,
 	.test_all = test_swapping,
 	.skip_in_compat = 1,
 	.needs_kconfigs = (const char *[]) {
diff --git a/testcases/kernel/mem/thp/thp04.c b/testcases/kernel/mem/thp/thp04.c
index b5f518ac5..16d766c34 100644
--- a/testcases/kernel/mem/thp/thp04.c
+++ b/testcases/kernel/mem/thp/thp04.c
@@ -161,7 +161,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "a8f97366452e"},
 		{"linux-git", "8310d48b125d"},
diff --git a/testcases/kernel/mem/tunable/min_free_kbytes.c b/testcases/kernel/mem/tunable/min_free_kbytes.c
index 19da409e8..65b467d60 100644
--- a/testcases/kernel/mem/tunable/min_free_kbytes.c
+++ b/testcases/kernel/mem/tunable/min_free_kbytes.c
@@ -221,7 +221,7 @@ static void setup(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = TST_UNLIMITED_RUNTIME,
+	.timeout = TST_UNLIMITED_TIMEOUT,
 	.setup = setup,
 	.test_all = min_free_kbytes_test,
 	.save_restore = (const struct tst_path_val[]) {
diff --git a/testcases/kernel/mem/vma/vma05.sh b/testcases/kernel/mem/vma/vma05.sh
index e1ef1014e..17e262f16 100755
--- a/testcases/kernel/mem/vma/vma05.sh
+++ b/testcases/kernel/mem/vma/vma05.sh
@@ -1,6 +1,13 @@
 #!/bin/sh
 # SPDX-License-Identifier: GPL-2.0-or-later
 # Copyright (C) 2017 Red Hat, Inc.
+# Copyright (C) 2024 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# doc
+#
+# [Description]
+#
 # Regression test if the vsyscall and vdso VMA regions are reported correctly.
 #
 # While [vsyscall] is mostly deprecated with newer systems, there is
@@ -15,58 +22,51 @@
 # VM_ALWAYSDUMP)). As a consequence of this bug, VMAs were not included
 # in core dumps which resulted in eg. incomplete backtraces and invalid
 # core dump files created by gdb.
+# ---
+#
+# ---
+# env
+# {
+#  "needs_root": true,
+#  "needs_tmpdir": true,
+#  "needs_cmds": ["gdb", "uname"],
+#  "save_restore": [
+#   ["/proc/sys/kernel/core_pattern", "core", "TBROK"],
+#   ["/proc/sys/kernel/core_uses_pid", "0", "TBROK"]
+#  ],
+#  "tags": [
+#   ["linux-git", "103efcd9aac1"],
+#   ["linux-git", "b6558c4a2378"],
+#   ["linux-git", "e5b97dde514f"]
+#  ]
+# }
+# ---
 
-TST_SETUP=setup
-TST_CLEANUP=cleanup
-TST_TESTFUNC=vma_report_check
-TST_NEEDS_ROOT=1
-TST_NEEDS_TMPDIR=1
-TST_NEEDS_CMDS="gdb"
-
-CORE_LIMIT=$(ulimit -c)
-CORE_PATTERN=$(cat /proc/sys/kernel/core_pattern)
-CORE_USES_PID=$(cat /proc/sys/kernel/core_uses_pid)
-
-setup()
-{
-	ulimit -c unlimited
-	echo "core" > /proc/sys/kernel/core_pattern
-	echo 0 > /proc/sys/kernel/core_uses_pid
-	unset DEBUGINFOD_URLS
-}
+. tst_loader.sh
 
-cleanup()
-{
-	ulimit -c "$CORE_LIMIT"
-	echo "$CORE_PATTERN" > /proc/sys/kernel/core_pattern
-	echo $CORE_USES_PID > /proc/sys/kernel/core_uses_pid
-}
+ulimit -c unlimited
+unset DEBUGINFOD_URLS
 
-vma_report_check()
-{
-	if [ $(uname -m) = "x86_64" ]; then
-		if LINE=$(grep "vsyscall" /proc/self/maps); then
-			RIGHT="ffffffffff600000-ffffffffff601000[[:space:]][r-]-xp"
-			if echo "$LINE" | grep -q "$RIGHT"; then
-				tst_res TPASS "[vsyscall] reported correctly"
-			else
-				tst_res TFAIL "[vsyscall] reporting wrong"
-			fi
+if [ $(uname -m) = "x86_64" ]; then
+	if LINE=$(grep "vsyscall" /proc/self/maps); then
+		RIGHT="ffffffffff600000-ffffffffff601000[[:space:]][r-]-xp"
+		if echo "$LINE" | grep -q "$RIGHT"; then
+			tst_res TPASS "[vsyscall] reported correctly"
+		else
+			tst_res TFAIL "[vsyscall] reporting wrong"
 		fi
 	fi
+fi
 
-	rm -rf core*
-	{ vma05_vdso; } > /dev/null 2>&1
-	[ -f core ] || tst_brk TBROK "missing core file"
+rm -rf core*
+{ vma05_vdso; } > /dev/null 2>&1
+[ -f core ] || tst_brk TBROK "missing core file"
 
-	TRACE=$(gdb -silent -ex="thread apply all backtrace" -ex="quit"\
-		vma05_vdso ./core* 2> /dev/null)
-	if echo "$TRACE" | grep -qF "??"; then
-		tst_res TFAIL "[vdso] bug not patched"
-	else
-		tst_res TPASS "[vdso] backtrace complete"
-	fi
-}
+TRACE=$(gdb -silent -ex="thread apply all backtrace" -ex="quit"\
+	vma05_vdso ./core* 2> /dev/null)
 
-. tst_test.sh
-tst_run
+if echo "$TRACE" | grep -qF "??"; then
+	tst_res TFAIL "[vdso] bug not patched"
+else
+	tst_res TPASS "[vdso] backtrace complete"
+fi
diff --git a/testcases/kernel/pty/.gitignore b/testcases/kernel/pty/.gitignore
index acca3db9a..2d0c8bb6f 100644
--- a/testcases/kernel/pty/.gitignore
+++ b/testcases/kernel/pty/.gitignore
@@ -1,5 +1,10 @@
 /hangup01
 /ptem01
+/ptem02
+/ptem03
+/ptem04
+/ptem05
+/ptem06
 /pty01
 /pty02
 /pty03
@@ -7,3 +12,5 @@
 /pty05
 /pty06
 /pty07
+/pty08
+/pty09
diff --git a/testcases/kernel/pty/common.h b/testcases/kernel/pty/common.h
new file mode 100644
index 000000000..51760b1d3
--- /dev/null
+++ b/testcases/kernel/pty/common.h
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef PTEM_H
+#define PTEM_H
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+
+#define MASTERCLONE "/dev/ptmx"
+
+static inline int open_master(void)
+{
+	int masterfd;
+
+	if (access(MASTERCLONE, F_OK))
+		tst_brk(TCONF, "%s device doesn't exist", MASTERCLONE);
+
+	tst_res(TINFO, "opening master %s", MASTERCLONE);
+
+	masterfd = SAFE_OPEN(MASTERCLONE, O_RDWR);
+
+	if (grantpt(masterfd) == -1)
+		tst_brk(TBROK | TERRNO, "grantpt() error");
+
+	if (unlockpt(masterfd) == -1)
+		tst_brk(TBROK | TERRNO, "unlockpt() error");
+
+	return masterfd;
+}
+
+static inline int open_slave(const int masterfd)
+{
+	int slavefd;
+	char *slavename;
+
+	slavename = SAFE_PTSNAME(masterfd);
+
+	tst_res(TINFO, "opening slave %s", slavename);
+
+#ifndef __BIONIC__
+	/* grantpt() is a no-op in bionic. */
+	struct stat st;
+
+	SAFE_STAT(slavename, &st);
+
+	uid_t uid = getuid();
+
+	if (st.st_uid != uid) {
+		tst_brk(TBROK, "uid mismatch st.st_uid(%d) != getuid(%d)",
+			st.st_uid, uid);
+	}
+
+	if (st.st_mode != (S_IFCHR | 0620)) {
+		tst_brk(TBROK, "unexpected slave device permission: %o",
+			st.st_mode);
+	}
+#endif
+
+	slavefd = SAFE_OPEN(slavename, O_RDWR);
+
+	return slavefd;
+}
+
+#endif
diff --git a/testcases/kernel/pty/ptem01.c b/testcases/kernel/pty/ptem01.c
index 20ef5d0a7..6040ee9bc 100644
--- a/testcases/kernel/pty/ptem01.c
+++ b/testcases/kernel/pty/ptem01.c
@@ -1,441 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *   Copyright (c) International Business Machines  Corp., 2002
- *   Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
-/* 12/23/2002   Port to LTP     robbiew@us.ibm.com */
-/* 06/30/2001   Port to Linux   nsharoff@us.ibm.com */
+/*\
+ * [Description]
+ *
+ * Verify that it's possible to open a pseudo-terminal via /dev/ptmx, obtain a
+ * slave device and configure termos/termios ioctls.
+ */
 
 #define _GNU_SOURCE
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <termios.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <sys/poll.h>
-#include <sys/types.h>
 
-#include "test.h"
-#include "safe_macros.h"
+#include <termios.h>
+#include "common.h"
 #include "lapi/ioctl.h"
 
-char *TCID = "ptem01";		/* Test program identifier.    */
-int TST_TOTAL = 6;		/* Total number of test cases. */
-/**************/
+static int masterfd = -1;
 
-/*
- * pty master clone device
- */
-#define MASTERCLONE "/dev/ptmx"
-
-#define BUFSZ 4096
-
-/*
- * test termio/termios ioctls
- */
-int test1(void)
+static void run(void)
 {
-	int masterfd, slavefd;
-	char *slavename;
+	int slavefd;
 	struct termio termio;
 	struct termios termios;
 
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
-
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
-
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "unlockpt() call failed");
-	}
-
-	if ((slavefd = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TFAIL, NULL, "Could not open %s", slavename);
-	}
-
-	if (ioctl(slavefd, TCGETS, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCGETS");
-	}
-
-	if (ioctl(slavefd, TCSETS, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETS");
-	}
-
-	if (ioctl(slavefd, TCSETSW, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETSW");
-	}
-
-	if (ioctl(slavefd, TCSETSF, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETSF");
-	}
-
-	if (ioctl(slavefd, TCSETS, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETS");
-	}
-
-	if (ioctl(slavefd, TCGETA, &termio) != 0) {
-		tst_brkm(TFAIL, NULL, "TCGETA");
-	}
-
-	if (ioctl(slavefd, TCSETA, &termio) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETA");
-	}
-
-	if (ioctl(slavefd, TCSETAW, &termio) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETAW");
-	}
-
-	if (ioctl(slavefd, TCSETAF, &termio) != 0) {
-		tst_brkm(TFAIL, NULL, "TCSETAF");
-	}
-
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK, NULL, "close slave");
-	}
-
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "close master");
-	}
-	tst_resm(TPASS, "test1");
-
-	/** NOT REACHED **/
-	return 0;
-}
-
-/*
- * test window size setting and getting
- */
-int test2(void)
-{
-	int masterfd, slavefd;
-	char *slavename;
-	struct winsize wsz;
-	struct winsize wsz1 = { 24, 80, 5, 10 };
-	struct winsize wsz2 = { 60, 100, 11, 777 };
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
-
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
-
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "unlockpt() call failed");
-	}
-
-	if ((slavefd = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TBROK, NULL, "Could not open %s", slavename);
-	}
-
-	if (ioctl(masterfd, TIOCSWINSZ, &wsz1) != 0) {
-		tst_brkm(TFAIL, NULL, "TIOCSWINSZ");
-	}
-
-	if (ioctl(slavefd, TIOCGWINSZ, &wsz) != 0) {
-		tst_brkm(TFAIL, NULL, "TIOCGWINSZ");
-	}
-
-	if (wsz.ws_row != wsz1.ws_row || wsz.ws_col != wsz1.ws_col ||
-	    wsz.ws_xpixel != wsz1.ws_xpixel ||
-	    wsz.ws_ypixel != wsz1.ws_ypixel) {
-		tst_brkm(TFAIL, NULL, "unexpected window size returned");
-	}
-
-	if (ioctl(masterfd, TIOCGWINSZ, &wsz) != 0) {
-		tst_brkm(TFAIL, NULL, "TIOCGWINSZ");
-	}
-
-	if (wsz.ws_row != wsz1.ws_row || wsz.ws_col != wsz1.ws_col ||
-	    wsz.ws_xpixel != wsz1.ws_xpixel ||
-	    wsz.ws_ypixel != wsz1.ws_ypixel) {
-		tst_brkm(TFAIL, NULL, "unexpected window size returned");
-	}
-
-	if (ioctl(slavefd, TIOCSWINSZ, &wsz2) != 0) {
-		tst_brkm(TFAIL, NULL, "TIOCSWINSZ");
-	}
-
-	if (ioctl(slavefd, TIOCGWINSZ, &wsz) != 0) {
-		tst_brkm(TFAIL, NULL, "TIOCGWINSZ");
-	}
-
-	if (wsz.ws_row != wsz2.ws_row || wsz.ws_col != wsz2.ws_col ||
-	    wsz.ws_xpixel != wsz2.ws_xpixel ||
-	    wsz.ws_ypixel != wsz2.ws_ypixel) {
-		tst_brkm(TFAIL, NULL, "unexpected window size returned");
-	}
-
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK, NULL, "close");
-	}
-
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "close");
-	}
-	tst_resm(TPASS, "test2");
-
-	/** NOT REACHED **/
-	return 0;
-}
-
-/*
- * test sending a break
- */
-int test3(void)
-{
-	int masterfd, slavefd;
-	char *slavename;
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
-
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
-
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "unlockpt() call failed");
-	}
-
-	if ((slavefd = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TBROK, NULL, "Could not open %s", slavename);
-	}
-
-	if (tcsendbreak(masterfd, 10) != 0) {
-		tst_brkm(TFAIL, NULL, "tcsendbreak");
-	}
-
-	if (tcsendbreak(slavefd, 10) != 0) {
-		tst_brkm(TFAIL, NULL, "tcsendbreak");
-	}
-
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK, NULL, "close slave");
-	}
-
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "close master");
-	}
-	tst_resm(TPASS, "test3");
-
-	/** NOT REACHED **/
-	return 0;
-}
-
-/*
- * test multiple opens of slave side
- */
-int test4(void)
-{
-	int masterfd, slavefd, slavefd2, slavefd3;
-	char *slavename;
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
+	slavefd = open_slave(masterfd);
 
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
+	TST_EXP_PASS(ioctl(slavefd, TCGETS, &termios));
+	TST_EXP_PASS(ioctl(slavefd, TCSETS, &termios));
+	TST_EXP_PASS(ioctl(slavefd, TCSETSW, &termios));
+	TST_EXP_PASS(ioctl(slavefd, TCSETSF, &termios));
+	TST_EXP_PASS(ioctl(slavefd, TCSETS, &termios));
+	TST_EXP_PASS(ioctl(slavefd, TCGETA, &termio));
+	TST_EXP_PASS(ioctl(slavefd, TCSETA, &termio));
+	TST_EXP_PASS(ioctl(slavefd, TCSETAW, &termio));
+	TST_EXP_PASS(ioctl(slavefd, TCSETAF, &termio));
 
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "unlockpt() call failed");
-	}
-
-	if ((slavefd = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TBROK, NULL, "Could not open %s", slavename);
-	}
-
-	if ((slavefd2 = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TFAIL, NULL, "Could not open %s (again)", slavename);
-	}
-
-	if ((slavefd3 = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TFAIL, NULL, "Could not open %s (once more)",
-			 slavename);
-	}
-
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK, NULL, "close slave");
-	}
-	if (close(slavefd2) != 0) {
-		tst_brkm(TBROK, NULL, "close slave again");
-	}
-	if (close(slavefd3) != 0) {
-		tst_brkm(TBROK, NULL, "close slave once more");
-	}
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "close master");
-	}
-	tst_resm(TPASS, "test4");
-
-	/** NOT REACHED **/
-	return 0;
+	SAFE_CLOSE(slavefd);
 }
 
-#define NUMOPENS 6
-
-/*
- * test several simultaneous opens
- */
-int test5(void)
+static void setup(void)
 {
-	static int masterfd[NUMOPENS];
-	static int slavefd[NUMOPENS];
-	char *slavename;
-	int i;
-
-	for (i = 0; i < NUMOPENS; ++i) {
-		masterfd[i] = open(MASTERCLONE, O_RDWR);
-		if (masterfd[i] < 0) {
-			tst_resm(TBROK, "%s", MASTERCLONE);
-			tst_resm(TBROK, "out of ptys");
-			for (i = 0; i < NUMOPENS; ++i) {
-				if (masterfd[i] != 0) {
-					(void)close(masterfd[i]);
-				}
-				if (slavefd[i] != 0) {
-					(void)close(slavefd[i]);
-				}
-			}
-			tst_exit();
-		}
-
-		slavename = ptsname(masterfd[i]);
-		if (slavename == NULL) {
-			tst_brkm(TBROK | TERRNO, NULL,
-				 "ptsname() call failed");
-		}
-
-		if (grantpt(masterfd[i]) != 0) {
-			tst_brkm(TBROK | TERRNO, NULL,
-				 "grantpt() call failed");
-		}
-
-		if (unlockpt(masterfd[i]) != 0) {
-			tst_brkm(TBROK, NULL, "unlockpt() call failed");
-		}
-
-		if ((slavefd[i] = open(slavename, O_RDWR)) < 0) {
-			tst_brkm(TFAIL, NULL,
-				 "Iteration %d: Could not open %s", i,
-				 slavename);
-		}
-
-	}
-
-	for (i = 0; i < NUMOPENS; ++i) {
-		if (close(slavefd[i]) != 0) {
-			tst_brkm(TBROK, NULL, "Iteration %d: close slave", i);
-		}
-		if (close(masterfd[i]) != 0) {
-			tst_brkm(TBROK, NULL, "close master");
-		}
-	}
-	tst_resm(TPASS, "test5");
-
-	/** NOT REACHED **/
-	return 0;
+	masterfd = open_master();
 }
 
-/*
- * test hangup semantics
- */
-int test6(void)
+static void cleanup(void)
 {
-	static int masterfd;
-	static int slavefd;
-	char *slavename;
-	struct termios termios;
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
-
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
-
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "unlockpt() call failed");
-	}
-
-	if ((slavefd = open(slavename, O_RDWR)) < 0) {
-		tst_brkm(TBROK, NULL, "Could not open %s", slavename);
-	}
-
-	if (ioctl(slavefd, TCGETS, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCGETS");
-	}
-
-	termios.c_cflag &= ~CBAUD;
-	termios.c_cflag |= B0 & CBAUD;
-	if (ioctl(slavefd, TCSETS, &termios) != 0) {
-		tst_brkm(TFAIL, NULL, "TCGETS");
-	}
-
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK, NULL, "close");
-	}
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "close");
-	}
-	tst_resm(TPASS, "test6");
-
-	/** NOT REACHED **/
-	return 0;
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
 }
 
-/*
- * main test driver
- */
-int main(void)
-{
-	test1();
-	test2();
-	test3();
-	test4();
-	test5();
-	test6();
-	/*
-	 * all done
-	 */
-	tst_exit();
-}
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/ptem02.c b/testcases/kernel/pty/ptem02.c
new file mode 100644
index 000000000..0fc69aa1d
--- /dev/null
+++ b/testcases/kernel/pty/ptem02.c
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that it's possible to open a pseudo-terminal via /dev/ptmx, obtain a
+ * slave device and set/get window size.
+ */
+
+#define _GNU_SOURCE
+
+#include "common.h"
+
+static int masterfd = -1;
+
+static void run(void)
+{
+	int slavefd;
+	struct winsize wsz;
+	struct winsize wsz1 = { 24, 80, 5, 10 };
+	struct winsize wsz2 = { 60, 100, 11, 777 };
+
+	slavefd = open_slave(masterfd);
+
+	TST_EXP_PASS(ioctl(masterfd, TIOCSWINSZ, &wsz1));
+	TST_EXP_PASS(ioctl(slavefd, TIOCGWINSZ, &wsz));
+
+	TST_EXP_EQ_LI(wsz.ws_row, wsz1.ws_row);
+	TST_EXP_EQ_LI(wsz.ws_col, wsz1.ws_col);
+	TST_EXP_EQ_LI(wsz.ws_xpixel, wsz1.ws_xpixel);
+	TST_EXP_EQ_LI(wsz.ws_ypixel, wsz1.ws_ypixel);
+
+	TST_EXP_PASS(ioctl(masterfd, TIOCGWINSZ, &wsz));
+
+	TST_EXP_EQ_LI(wsz.ws_row, wsz1.ws_row);
+	TST_EXP_EQ_LI(wsz.ws_col, wsz1.ws_col);
+	TST_EXP_EQ_LI(wsz.ws_xpixel, wsz1.ws_xpixel);
+	TST_EXP_EQ_LI(wsz.ws_ypixel, wsz1.ws_ypixel);
+
+	TST_EXP_PASS(ioctl(slavefd, TIOCSWINSZ, &wsz2));
+	TST_EXP_PASS(ioctl(slavefd, TIOCGWINSZ, &wsz));
+
+	TST_EXP_EQ_LI(wsz.ws_row, wsz2.ws_row);
+	TST_EXP_EQ_LI(wsz.ws_col, wsz2.ws_col);
+	TST_EXP_EQ_LI(wsz.ws_xpixel, wsz2.ws_xpixel);
+	TST_EXP_EQ_LI(wsz.ws_ypixel, wsz2.ws_ypixel);
+
+	SAFE_CLOSE(slavefd);
+}
+
+static void setup(void)
+{
+	masterfd = open_master();
+}
+
+static void cleanup(void)
+{
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/ptem03.c b/testcases/kernel/pty/ptem03.c
new file mode 100644
index 000000000..fb0fdf661
--- /dev/null
+++ b/testcases/kernel/pty/ptem03.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that it's possible to open a pseudo-terminal via /dev/ptmx, obtain a
+ * slave device and to send a break to both master and slave.
+ */
+
+#define _GNU_SOURCE
+
+#include <termios.h>
+#include "common.h"
+
+static int masterfd = -1;
+
+static void run(void)
+{
+	int slavefd;
+
+	slavefd = open_slave(masterfd);
+
+	TST_EXP_PASS(tcsendbreak(masterfd, 10));
+	TST_EXP_PASS(tcsendbreak(slavefd, 10));
+
+	SAFE_CLOSE(slavefd);
+}
+
+static void setup(void)
+{
+	masterfd = open_master();
+}
+
+static void cleanup(void)
+{
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/ptem04.c b/testcases/kernel/pty/ptem04.c
new file mode 100644
index 000000000..675e6b816
--- /dev/null
+++ b/testcases/kernel/pty/ptem04.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that it's possible to open a pseudo-terminal via /dev/ptmx, obtain a
+ * slave device and to check if it's possible to open it multiple times.
+ */
+
+#define _GNU_SOURCE
+
+#include "common.h"
+
+#define NUM_SLAVES 10
+
+static int masterfd = -1;
+
+static void run(void)
+{
+	int slavefd[NUM_SLAVES];
+
+	for (int i = 0; i < NUM_SLAVES; i++)
+		slavefd[i] = TST_EXP_FD(open_slave(masterfd));
+
+	for (int i = 0; i < NUM_SLAVES; i++)
+		SAFE_CLOSE(slavefd[i]);
+}
+
+static void setup(void)
+{
+	masterfd = open_master();
+}
+
+static void cleanup(void)
+{
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/ptem05.c b/testcases/kernel/pty/ptem05.c
new file mode 100644
index 000000000..9357c469c
--- /dev/null
+++ b/testcases/kernel/pty/ptem05.c
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that it's possible to open a pseudo-terminal via /dev/ptmx, to obtain
+ * a master + slave pair and to open them multiple times.
+ */
+
+#define _GNU_SOURCE
+
+#include "common.h"
+
+#define NUM_OPENS 10
+
+static int masterfd[NUM_OPENS];
+
+static void run(void)
+{
+	int slavefd[NUM_OPENS];
+
+	for (int i = 0; i < NUM_OPENS; i++)
+		slavefd[i] = TST_EXP_FD(open_slave(masterfd[i]));
+
+	for (int i = 0; i < NUM_OPENS; i++)
+		SAFE_CLOSE(slavefd[i]);
+}
+
+static void setup(void)
+{
+	for (int i = 0; i < NUM_OPENS; i++)
+		masterfd[i] = -1;
+
+	for (int i = 0; i < NUM_OPENS; i++)
+		masterfd[i] = open_master();
+}
+
+static void cleanup(void)
+{
+	for (int i = 0; i < NUM_OPENS; i++) {
+		if (masterfd[i] != -1)
+			SAFE_CLOSE(masterfd[i]);
+	}
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/ptem06.c b/testcases/kernel/pty/ptem06.c
new file mode 100644
index 000000000..810b7c1d6
--- /dev/null
+++ b/testcases/kernel/pty/ptem06.c
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (c) 2020 Petr Vorel <pvorel@suse.cz>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that it's possible to open a pseudo-terminal via /dev/ptmx, to obtain
+ * a slave device and to set baudrate to B0 (which means hang up).
+ */
+
+#define _GNU_SOURCE
+
+#include <termios.h>
+#include "common.h"
+
+static int masterfd = -1;
+
+static void run(void)
+{
+	int slavefd;
+	struct termios termios;
+
+	slavefd = open_slave(masterfd);
+
+	TST_EXP_PASS(ioctl(slavefd, TCGETS, &termios));
+	termios.c_cflag &= ~CBAUD;
+	termios.c_cflag |= B0 & CBAUD;
+	TST_EXP_PASS(ioctl(slavefd, TCSETS, &termios));
+
+	SAFE_CLOSE(slavefd);
+}
+
+static void setup(void)
+{
+	masterfd = open_master();
+}
+
+static void cleanup(void)
+{
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/pty01.c b/testcases/kernel/pty/pty01.c
index 666b221b0..d804a8d63 100644
--- a/testcases/kernel/pty/pty01.c
+++ b/testcases/kernel/pty/pty01.c
@@ -1,395 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *
- *   Copyright (c) International Business Machines  Corp., 2002
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
-/* 12/23/2002	Port to LTP	robbiew@us.ibm.com */
-/* 06/30/2001	Port to Linux	nsharoff@us.ibm.com */
+/*\
+ * [Description]
+ *
+ * Verify that write/read is properly working when master and slave
+ * pseudo terminals communicate with each other.
+ */
 
 #define _GNU_SOURCE
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <termios.h>
-#include <unistd.h>
-
-#include "test.h"
-#include "safe_macros.h"
-#include "lapi/ioctl.h"
-
-char *TCID = "pty01";		/* Test program identifier.    */
-int TST_TOTAL = 5;		/* Total number of test cases. */
-/**************/
 
-/*
- * pty master clone device
- */
-#define MASTERCLONE "/dev/ptmx"
+#include "common.h"
 
-/*
- * string for testing read/write on ptys
- */
 #define STRING "Linux Test Project\n"
 
-/*
- * test buffer size
- */
-#define TESTSIZE 1024
-
-/*
- * mode we expect grantpt() to leave pty as
- */
-#define PTY_MODE 020622
-
-/*
- * number of procs for parallel test
- */
-#define NUMPROCS 15
-
-/*
- * test slave locking
- */
-static int test1(void)
-{
-	int masterfd;		/* master pty fd */
-	int slavefd;		/* slave pty fd */
-	char *slavename;
-	struct stat st;
-	char buf[TESTSIZE];
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
-
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
-
-	if (stat(slavename, &st) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "stat(%s) failed", slavename);
-	}
-	if (st.st_uid != getuid()) {
-		tst_brkm(TBROK, NULL, "uid mismatch");
-	}
-
-	 /* grantpt() is a no-op in bionic. */
-#ifndef __BIONIC__
-	if (st.st_mode != (S_IFCHR | S_IRUSR | S_IWUSR | S_IWGRP)) {
-		tst_brkm(TBROK, NULL, "mode mismatch (mode=%o)", st.st_mode);
-	}
-#endif
-
-	slavefd = open(slavename, O_RDWR);
-	if (slavefd >= 0) {
-		tst_brkm(TBROK, NULL, "open didn't fail as expected!");
-	}
-
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "unlockpt() failed");
-	}
-
-	slavefd = SAFE_OPEN(NULL, slavename, O_RDWR);
-
-	/*
-	 * test writing to the master / reading from the slave
-	 */
-	if (write(masterfd, STRING, strlen(STRING)) != strlen(STRING)) {
-		/*
-		 * XXX: the errno printout might be garbage, but better to be
-		 * safe than sorry..
-		 */
-		tst_brkm(TFAIL | TERRNO, NULL, "write to master");
-	}
-
-	if (read(slavefd, buf, strlen(STRING)) != strlen(STRING)) {
-		/* XXX: Same as write above.. */
-		tst_brkm(TFAIL | TERRNO, NULL, "read from slave");
-	}
-	if (strncmp(STRING, buf, strlen(STRING) - 1) != 0) {
-		tst_brkm(TFAIL, NULL,
-			 "strings are different (STRING = '%s' != buf = '%s')",
-			 STRING, buf);
-	}
-
-	/*
-	 * test writing to the slave / reading from the master
-	 */
-	if (write(slavefd, STRING, strlen(STRING)) != strlen(STRING)) {
-		/* XXX: Same as write above.. */
-		tst_brkm(TFAIL | TERRNO, NULL, "write to slave");
-	}
-
-	if (read(masterfd, buf, strlen(STRING)) != strlen(STRING)) {
-		/* XXX: Same as write above.. */
-		tst_brkm(TFAIL | TERRNO, NULL, "read from master");
-	}
-	if (strncmp(STRING, buf, strlen(STRING) - 1) != 0) {
-		tst_brkm(TFAIL, NULL,
-			 "strings are different (STRING = '%s' != buf = '%s').",
-			 STRING, buf);
-	}
-
-	/*
-	 * try an invalid ioctl on the slave...
-	 */
-	if (ioctl(slavefd, TIOCGWINSZ, NULL) == 0) {
-		tst_brkm(TFAIL, NULL,
-			 "invalid slave TIOCGWINSZ ioctl succeeded.. it should "
-			 "have failed");
-	}
-
-	/*
-	 * try an invalid ioctl on the master...
-	 */
-	if (ioctl(masterfd, TIOCGWINSZ, NULL) == 0) {
-		tst_brkm(TFAIL, NULL,
-			 "invalid master TIOCGWINSZ ioctl succeeded.. it should "
-			 "have failed");
-	}
-
-	/*
-	 * close pty fds
-	 */
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "close of slave");
-	}
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "close of master");
-	}
-	tst_resm(TPASS, "test1");
-	/** NOTREACHED **/
-	return 0;
-}
+static size_t string_len;
+static int masterfd = -1;
+static int slavefd = -1;
 
-/*
- * test slave operations with closed master
- */
-static void test2(void)
+static void run(void)
 {
-	int masterfd;		/* master pty fd */
-	int slavefd;		/* slave pty fd */
-	int i;
-	char *slavename;
-	char c;
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
+	char buf[BUFSIZ];
 
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK | TERRNO, NULL, "ptsname() call failed");
-	}
+	tst_res(TINFO, "Send message to master and read it from slave");
 
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "grantpt() call failed");
-	}
+	memset(buf, 0, BUFSIZ);
+	SAFE_WRITE(SAFE_WRITE_ALL, masterfd, STRING, string_len);
+	SAFE_READ(0, slavefd, buf, string_len);
+	TST_EXP_EQ_STRN(STRING, buf, string_len - 1);
 
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "unlockpt() call failed");
-	}
+	tst_res(TINFO, "Send message to slave and read it from master");
 
-	slavefd = SAFE_OPEN(NULL, slavename, O_RDWR);
+	memset(buf, 0, BUFSIZ);
+	SAFE_WRITE(SAFE_WRITE_ALL, slavefd, STRING, string_len);
 
-	/*
-	 * close pty fds.  See what happens when we close the master
-	 * first.
+	/* we need to write string_len + 1, because kernel converts newline
+	 * into carriage return + newline
 	 */
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "close()");
-	}
-
-	errno = 0;
-	if ((i = read(slavefd, &c, 1)) == 1) {
-		tst_brkm(TFAIL, NULL,
-			 "reading from slave fd should have failed, but didn't"
-			 "(read '%c')", c);
-	}
-
-	if ((i = write(slavefd, &c, 1)) == 1) {
-		tst_brkm(TFAIL, NULL,
-			 "writing to slave fd should have failed, but didn't");
-	}
-
-	if (ioctl(slavefd, TIOCGWINSZ, NULL) == 0) {
-		tst_brkm(TFAIL, NULL,
-			 "trying TIOCGWINSZ on slave fd should have failed, "
-			 "but didn't");
-	}
-
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK, NULL, "close");
-	}
-	tst_resm(TPASS, "test2");
-}
-
-/*
- * test operations on master with closed slave
- */
-static void test3(void)
-{
-	int masterfd;		/* master pty fd */
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	if (ioctl(masterfd, TIOCGWINSZ, NULL) == 0) {
-		tst_brkm(TFAIL | TERRNO, NULL,
-			 "trying TIOCGWINSZ on master with no open slave "
-			 "succeeded unexpectedly");
-	}
-	tst_resm(TPASS, "test3");
+	SAFE_READ(0, masterfd, buf, string_len + 1);
+	TST_EXP_EQ_STRN(STRING, buf, string_len - 1);
 }
 
-/*
- * test multiple opens on slave side of pty
- */
-static void test4(void)
+static void setup(void)
 {
-	int masterfd;		/* master pty fd */
-	int slavefd;		/* slave pty fd */
-	int slavefd2;
-	int slavefd3;
-	char *slavename;
-
-	masterfd = SAFE_OPEN(NULL, MASTERCLONE, O_RDWR);
-
-	slavename = ptsname(masterfd);
-	if (slavename == NULL) {
-		tst_brkm(TBROK, NULL, "ptsname() call failed");
-	}
-
-	if (grantpt(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "grantpt() call failed");
-	}
-
-	if (unlockpt(masterfd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "unlockpt() call failed");
-	}
-
-	slavefd = SAFE_OPEN(NULL, slavename, O_RDWR);
-
-	slavefd2 = open(slavename, O_RDWR);
-	if (slavefd < 0) {
-		tst_brkm(TFAIL | TERRNO, NULL, "Could not open %s (again)",
-			 slavename);
-	}
-
-	slavefd3 = open(slavename, O_RDWR);
-	if (slavefd < 0) {
-		tst_brkm(TFAIL | TERRNO, NULL, "Could not open %s (once more)",
-			 slavename);
-	}
-
-	/*
-	 * close pty fds.
-	 */
-	if (close(slavefd) != 0) {
-		tst_brkm(TBROK | TERRNO, NULL, "close slave");
-	}
+	masterfd = open_master();
+	slavefd = open_slave(masterfd);
 
-	if (close(slavefd2) != 0) {
-		tst_brkm(TBROK, NULL, "close slave again");
-	}
-
-	if (close(slavefd3) != 0) {
-		tst_brkm(TBROK, NULL, "close slave once more");
-	}
-
-	if (close(masterfd) != 0) {
-		tst_brkm(TBROK, NULL, "close master");
-	}
-	tst_resm(TPASS, "test4");
+	string_len = strlen(STRING);
 }
 
-/*
- * test opening/closing lots of ptys in parallel.  We may run out
- * of ptys for this test depending on how the system is configured,
- * but that's not a fatal error.
- */
-static void test5(void)
+static void cleanup(void)
 {
-	int masterfd;		/* master pty fd */
-	char *slavename;
-	int status;
-	int i;
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
 
-	for (i = 0; i < NUMPROCS; ++i) {
-		switch (fork()) {
-		case -1:
-			tst_brkm(TBROK, NULL, "fork()");
-			break;
-		case 0:
-			masterfd = open(MASTERCLONE, O_RDWR);
-			if (masterfd < 0) {
-				printf("proc %d: opening %s failed: %s",
-				       i, MASTERCLONE, strerror(errno));
-				exit(1);
-			}
-			if (grantpt(masterfd) != 0) {
-				printf("proc %d: grantpt() call failed: %s",
-				       i, strerror(errno));
-				exit(1);
-			}
-			slavename = ptsname(masterfd);
-			if (slavename == NULL) {
-				printf("proc %d: ptsname() call failed: %s",
-				       i, strerror(errno));
-				exit(1);
-			}
-			sleep(10);
-			if (close(masterfd) != 0) {
-				printf("proc %d: close failed: %s",
-				       i, strerror(errno));
-				exit(1);
-			}
-			exit(0);
-		default:
-			break;
-		}
-	}
-	while (wait(&status) > 0) {
-		if (status) {
-			tst_brkm(TFAIL, NULL,
-				 "child exited with non-zero status %d",
-				 status);
-		}
-	}
-	tst_resm(TPASS, "test5");
+	if (slavefd != -1)
+		SAFE_CLOSE(slavefd);
 }
 
-/*
- * main test driver
- */
-int main(void)
-{
-	test1();
-	test2();
-	test3();
-	test4();
-	test5();
-
-	/*
-	 * all done
-	 */
-	tst_exit();
-}
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/pty/pty03.c b/testcases/kernel/pty/pty03.c
index 6324bc876..883a539d5 100644
--- a/testcases/kernel/pty/pty03.c
+++ b/testcases/kernel/pty/pty03.c
@@ -152,7 +152,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.needs_root = 1,
-	.max_runtime = 30,
+	.runtime = 30,
 	.needs_kconfigs = (const char *const[]){
 		"CONFIG_SERIO_SERPORT",
 		NULL
diff --git a/testcases/kernel/pty/pty05.c b/testcases/kernel/pty/pty05.c
index 925ce3854..6f6a9bce7 100644
--- a/testcases/kernel/pty/pty05.c
+++ b/testcases/kernel/pty/pty05.c
@@ -97,7 +97,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "82f2341c94d27"},
 		{"CVE", "2017-2636"},
diff --git a/testcases/kernel/pty/pty06.c b/testcases/kernel/pty/pty06.c
index cc95eb1a8..430916355 100644
--- a/testcases/kernel/pty/pty06.c
+++ b/testcases/kernel/pty/pty06.c
@@ -97,7 +97,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.needs_root = 1,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 	    {"CVE", "2020-36557"},
 	    {"linux-git", "ca4463bf8438"},
diff --git a/testcases/kernel/pty/pty07.c b/testcases/kernel/pty/pty07.c
index cc3df55cb..ebd5b1607 100644
--- a/testcases/kernel/pty/pty07.c
+++ b/testcases/kernel/pty/pty07.c
@@ -114,7 +114,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.needs_root = 1,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 		{ "linux-git", "6cd1ed50efd8"},
 		{}
diff --git a/testcases/kernel/pty/pty08.c b/testcases/kernel/pty/pty08.c
new file mode 100644
index 000000000..45e99d18b
--- /dev/null
+++ b/testcases/kernel/pty/pty08.c
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that slave pseudo-terminal fails reading/writing if master has been
+ * closed.
+ */
+
+#define _GNU_SOURCE
+
+#include "common.h"
+
+static void run(void)
+{
+	int slavefd;
+	int masterfd;
+	char buf;
+
+	masterfd = open_master();
+	slavefd = open_slave(masterfd);
+
+	tst_res(TINFO, "Closing master communication");
+	SAFE_CLOSE(masterfd);
+
+	TST_EXP_EQ_LI(read(slavefd, &buf, 1), 0);
+	TST_EXP_FAIL(write(slavefd, &buf, 1), EIO);
+
+	SAFE_CLOSE(slavefd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+};
diff --git a/testcases/kernel/pty/pty09.c b/testcases/kernel/pty/pty09.c
new file mode 100644
index 000000000..1e477869b
--- /dev/null
+++ b/testcases/kernel/pty/pty09.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) International Business Machines  Corp., 2002
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that slave pseudo-terminal can be opened multiple times in parallel.
+ */
+
+#define _GNU_SOURCE
+
+#include "common.h"
+
+static int masterfd = -1;
+
+static unsigned int count_avail_pid(void)
+{
+	DIR *dir;
+	struct dirent *ent;
+	struct rlimit limit;
+	unsigned int count = 0;
+	unsigned int max_pid_num;
+
+	SAFE_GETRLIMIT(RLIMIT_NOFILE, &limit);
+
+	dir = SAFE_OPENDIR("/proc/self/fd");
+	while ((ent = SAFE_READDIR(dir)))
+		count++;
+
+	SAFE_CLOSEDIR(dir);
+
+	max_pid_num = limit.rlim_cur - count;
+
+	tst_res(TINFO, "Available number of pids: %u", max_pid_num);
+
+	return max_pid_num;
+}
+
+static void run(void)
+{
+	unsigned int max_pid_num;
+
+	max_pid_num = count_avail_pid();
+
+	int slavefd[max_pid_num];
+
+	for (uint32_t i = 0; i < max_pid_num; i++)
+		slavefd[i] = open_slave(masterfd);
+
+	tst_res(TPASS, "pty has been opened %d times", max_pid_num);
+
+	for (uint32_t i = 0; i < max_pid_num; i++)
+		SAFE_CLOSE(slavefd[i]);
+}
+
+static void setup(void)
+{
+	masterfd = open_master();
+}
+
+static void cleanup(void)
+{
+	if (masterfd != -1)
+		SAFE_CLOSE(masterfd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/sched/cfs-scheduler/cfs_bandwidth01.c b/testcases/kernel/sched/cfs-scheduler/cfs_bandwidth01.c
index 27fc0fc5d..aa137eb67 100644
--- a/testcases/kernel/sched/cfs-scheduler/cfs_bandwidth01.c
+++ b/testcases/kernel/sched/cfs-scheduler/cfs_bandwidth01.c
@@ -174,7 +174,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.forks_child = 1,
 	.needs_checkpoints = 1,
-	.max_runtime = 20,
+	.timeout = 20,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_CFS_BANDWIDTH",
diff --git a/testcases/kernel/sched/cfs-scheduler/starvation.c b/testcases/kernel/sched/cfs-scheduler/starvation.c
index e707e0865..27bf77f39 100644
--- a/testcases/kernel/sched/cfs-scheduler/starvation.c
+++ b/testcases/kernel/sched/cfs-scheduler/starvation.c
@@ -21,6 +21,7 @@
 #include <sched.h>
 
 #include "tst_test.h"
+#include "tst_kconfig.h"
 #include "tst_safe_clocks.h"
 #include "tst_timer.h"
 
@@ -79,6 +80,9 @@ static void setup(void)
 	int cpu = 0;
 	long ncpus = tst_ncpus_conf();
 
+	if (tst_check_preempt_rt())
+		tst_brk(TCONF, "This test is not designed for the RT kernel");
+
 	CPU_ZERO(&mask);
 
 	/* Restrict test to a single cpu */
@@ -108,7 +112,10 @@ static void setup(void)
 	else
 		timeout = callibrate() / 1000;
 
-	tst_set_max_runtime(timeout);
+	if (tst_has_slow_kconfig())
+		tst_brk(TCONF, "Skip test due to slow kernel configuration");
+
+	tst_set_runtime(timeout);
 }
 
 static void handler(int sig LTP_ATTRIBUTE_UNUSED)
@@ -145,9 +152,9 @@ static void do_test(void)
 	SAFE_KILL(child_pid, SIGTERM);
 
 	if (!tst_remaining_runtime())
-		tst_res(TFAIL, "Scheduller starvation reproduced.");
+		tst_res(TFAIL, "Scheduler starvation reproduced");
 	else
-		tst_res(TPASS, "Haven't reproduced scheduller starvation.");
+		tst_res(TPASS, "Haven't reproduced scheduler starvation");
 
 	TST_EXP_PASS_SILENT(wait_for_pid(child_pid));
 }
diff --git a/testcases/kernel/sched/hyperthreading/ht_affinity/ht_affinity.c b/testcases/kernel/sched/hyperthreading/ht_affinity/ht_affinity.c
index f6e9f2745..3c2fe1bf1 100644
--- a/testcases/kernel/sched/hyperthreading/ht_affinity/ht_affinity.c
+++ b/testcases/kernel/sched/hyperthreading/ht_affinity/ht_affinity.c
@@ -67,7 +67,7 @@ int HT_SetAffinity(void)
 		tst_resm(TINFO, "Set test process affinity.");
 		printf("mask: %x\n", mask);
 
-		sched_setaffinity(pid, sizeof(unsigned long), &mask);
+		sched_setaffinity(pid, sizeof(mask), &mask);
 
 		for (j = 0; j < 10; j++) {
 			for (k = 0; k < 10; k++) {
@@ -95,7 +95,7 @@ int HT_SetAffinity(void)
 		tst_resm(TINFO, "Set test process affinity.");
 		printf("mask: %x\n", mask);
 
-		sched_setaffinity(pid, sizeof(unsigned long), &mask);
+		sched_setaffinity(pid, sizeof(mask), &mask);
 
 		for (j = 0; j < 10; j++) {
 			for (k = 0; k < 10; k++) {
diff --git a/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem.c b/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem.c
index 82f2399e6..9767f4186 100644
--- a/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem.c
+++ b/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem.c
@@ -109,7 +109,7 @@ static struct tst_test test = {
 	.needs_checkpoints = 1,
 	.forks_child = 1,
 	.needs_root = 1,
-	.max_runtime = 120,
+	.runtime = 120,
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = dirtyc0w_shmem_test,
diff --git a/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem_child.c b/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem_child.c
index 2a982347c..c568db977 100644
--- a/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem_child.c
+++ b/testcases/kernel/security/dirtyc0w_shmem/dirtyc0w_shmem_child.c
@@ -139,6 +139,11 @@ retry:
 				goto retry;
 			}
 		}
+		if (TST_ERR == EOPNOTSUPP) {
+			/* TODO: b/384985178 - userfaultfd is not supported when emulating 16k pages */
+			tst_brk(TCONF | TTERRNO,
+				"userfaultfd not supported when emulating 16k pages");
+		}
 		tst_brk(TBROK | TTERRNO,
 			"Could not create userfault file descriptor");
 	}
diff --git a/testcases/kernel/security/integrity/ima/src/ima_boot_aggregate.c b/testcases/kernel/security/integrity/ima/src/ima_boot_aggregate.c
index 62468e0d1..420b0c736 100644
--- a/testcases/kernel/security/integrity/ima/src/ima_boot_aggregate.c
+++ b/testcases/kernel/security/integrity/ima/src/ima_boot_aggregate.c
@@ -24,6 +24,7 @@
 
 #if HAVE_LIBCRYPTO
 #include <openssl/sha.h>
+#include <openssl/evp.h>
 
 #define MAX_EVENT_SIZE (1024*1024)
 #define EVENT_HEADER_SIZE 32
@@ -61,7 +62,11 @@ static void display_sha1_digest(unsigned char *pcr)
 static void do_test(void)
 {
 	FILE *fp;
+#if OPENSSL_VERSION_NUMBER > 0x030000000L
+	EVP_MD_CTX *c = NULL;
+#else
 	SHA_CTX c;
+#endif
 	int i;
 
 	if (!file)
@@ -85,12 +90,24 @@ static void do_test(void)
 		}
 
 		if (event.header.pcr < NUM_PCRS) {
+#if OPENSSL_VERSION_NUMBER > 0x030000000L
+			if ((c = EVP_MD_CTX_new()) == NULL)
+				tst_brk(TBROK, "can't get new context");
+
+			EVP_DigestInit_ex(c, EVP_sha1(), NULL);
+			EVP_DigestUpdate(c, pcr[event.header.pcr].digest,
+					 SHA_DIGEST_LENGTH);
+			EVP_DigestUpdate(c, event.header.digest, SHA_DIGEST_LENGTH);
+			EVP_DigestFinal_ex(c, pcr[event.header.pcr].digest, NULL);
+			EVP_MD_CTX_free(c);
+#else
 			SHA1_Init(&c);
 			SHA1_Update(&c, pcr[event.header.pcr].digest,
 				    SHA_DIGEST_LENGTH);
 			SHA1_Update(&c, event.header.digest,
 				    SHA_DIGEST_LENGTH);
 			SHA1_Final(pcr[event.header.pcr].digest, &c);
+#endif
 		}
 
 #if MAX_EVENT_DATA_SIZE < USHRT_MAX
@@ -99,7 +116,8 @@ static void do_test(void)
 			break;
 		}
 #endif
-		fread(event.data, event.header.len, 1, fp);
+		if (fread(event.data, event.header.len, 1, fp) != 1)
+			tst_brk(TBROK, "failed to read 1 byte");
 	}
 
 	SAFE_FCLOSE(fp);
@@ -107,15 +125,30 @@ static void do_test(void)
 
 	/* Extend the boot aggregate with the pseudo PCR digest values */
 	memset(&boot_aggregate, 0, SHA_DIGEST_LENGTH);
+
+#if OPENSSL_VERSION_NUMBER > 0x030000000L
+	EVP_DigestInit_ex(c, EVP_sha1(), NULL);
+#else
 	SHA1_Init(&c);
+#endif
+
 	for (i = 0; i < NUM_PCRS; i++) {
 		if (debug) {
 			printf("PCR-%2.2x: ", i);
 			display_sha1_digest(pcr[i].digest);
 		}
+#if OPENSSL_VERSION_NUMBER > 0x030000000L
+		EVP_DigestUpdate(c, pcr[i].digest, SHA_DIGEST_LENGTH);
+#else
 		SHA1_Update(&c, pcr[i].digest, SHA_DIGEST_LENGTH);
+#endif
 	}
+
+#if OPENSSL_VERSION_NUMBER > 0x030000000L
+	EVP_MD_CTX_free(c);
+#else
 	SHA1_Final(boot_aggregate, &c);
+#endif
 
 	printf("sha1:");
 	display_sha1_digest(boot_aggregate);
diff --git a/testcases/kernel/security/integrity/ima/tests/ima_kexec.sh b/testcases/kernel/security/integrity/ima/tests/ima_kexec.sh
index 62f05f536..3446bc24b 100755
--- a/testcases/kernel/security/integrity/ima/tests/ima_kexec.sh
+++ b/testcases/kernel/security/integrity/ima/tests/ima_kexec.sh
@@ -11,6 +11,7 @@
 TST_NEEDS_CMDS="grep kexec sed"
 TST_CNT=3
 TST_SETUP="setup"
+TST_MIN_KVER="5.3"
 
 IMA_KEXEC_IMAGE="${IMA_KEXEC_IMAGE:-/boot/vmlinuz-$(uname -r)}"
 REQUIRED_POLICY='^measure.*func=KEXEC_CMDLINE'
diff --git a/testcases/kernel/security/integrity/ima/tests/ima_keys.sh b/testcases/kernel/security/integrity/ima/tests/ima_keys.sh
index 793908d44..ff32eb6c4 100755
--- a/testcases/kernel/security/integrity/ima/tests/ima_keys.sh
+++ b/testcases/kernel/security/integrity/ima/tests/ima_keys.sh
@@ -10,6 +10,7 @@ TST_NEEDS_CMDS="cmp cut grep sed"
 TST_CNT=2
 TST_SETUP=setup
 TST_CLEANUP=cleanup
+TST_MIN_KVER="5.6"
 
 FUNC_KEYCHECK='func=KEY_CHECK'
 REQUIRED_POLICY="^measure.*$FUNC_KEYCHECK"
diff --git a/testcases/kernel/security/integrity/ima/tests/ima_selinux.sh b/testcases/kernel/security/integrity/ima/tests/ima_selinux.sh
index f6e392822..75f9ba84e 100755
--- a/testcases/kernel/security/integrity/ima/tests/ima_selinux.sh
+++ b/testcases/kernel/security/integrity/ima/tests/ima_selinux.sh
@@ -12,6 +12,7 @@
 TST_NEEDS_CMDS="awk cut grep tail"
 TST_CNT=2
 TST_SETUP="setup"
+TST_MIN_KVER="5.12"
 
 FUNC_CRITICAL_DATA='func=CRITICAL_DATA'
 REQUIRED_POLICY="^measure.*$FUNC_CRITICAL_DATA"
diff --git a/testcases/kernel/security/integrity/ima/tests/ima_setup.sh b/testcases/kernel/security/integrity/ima/tests/ima_setup.sh
index 9a90329ce..b93789405 100644
--- a/testcases/kernel/security/integrity/ima/tests/ima_setup.sh
+++ b/testcases/kernel/security/integrity/ima/tests/ima_setup.sh
@@ -121,7 +121,7 @@ require_ima_policy_cmdline()
 	local policy="$1"
 
 	check_ima_policy_cmdline $policy || \
-		tst_brk TCONF "IMA measurement tests require builtin IMA $policy policy (e.g. ima_policy=$policy kernel parameter)"
+		tst_brk TCONF "test requires builtin IMA $policy policy (e.g. ima_policy=$policy kernel command line parameter)"
 }
 
 mount_helper()
@@ -218,8 +218,10 @@ set_digest_index()
 		done
 	esac
 
-	[ -z "$DIGEST_INDEX" ] && tst_brk TCONF \
-		"Cannot find digest index (template: '$template')"
+	if [ -z "$DIGEST_INDEX" ]; then
+		tst_res TWARN "Cannot find digest index (template: '$template')"
+		return 1
+	fi
 }
 
 get_algorithm_digest()
@@ -233,7 +235,13 @@ get_algorithm_digest()
 		return 1
 	fi
 
-	[ -z "$DIGEST_INDEX" ] && set_digest_index
+	if [ -z "$DIGEST_INDEX" ]; then
+		set_digest_index
+	fi
+	if [ -z "$DIGEST_INDEX" ]; then
+		return 1
+	fi
+
 	digest=$(echo "$line" | cut -d' ' -f $DIGEST_INDEX)
 	if [ -z "$digest" ]; then
 		echo "digest not found (index: $DIGEST_INDEX, line: '$line')"
@@ -267,18 +275,18 @@ get_algorithm_digest()
 ima_check()
 {
 	local test_file="$1"
-	local algorithm digest expected_digest line tmp
+	local algorithm digest expected_digest line
 
 	# need to read file to get updated $ASCII_MEASUREMENTS
 	cat $test_file > /dev/null
 
 	line="$(grep $test_file $ASCII_MEASUREMENTS | tail -1)"
 
-	if tmp=$(get_algorithm_digest "$line"); then
-		algorithm=$(echo "$tmp" | cut -d'|' -f1)
-		digest=$(echo "$tmp" | cut -d'|' -f2)
+	if get_algorithm_digest "$line" > tmp; then
+		algorithm=$(cat tmp | cut -d'|' -f1)
+		digest=$(cat tmp | cut -d'|' -f2)
 	else
-		tst_res TBROK "failed to get algorithm/digest for '$test_file': $tmp"
+		tst_brk TBROK "failed to get algorithm/digest for '$test_file'"
 	fi
 
 	tst_res TINFO "computing digest for $algorithm algorithm"
diff --git a/testcases/kernel/security/integrity/ima/tests/ima_tpm.sh b/testcases/kernel/security/integrity/ima/tests/ima_tpm.sh
index 2a28562e6..5d34d8679 100755
--- a/testcases/kernel/security/integrity/ima/tests/ima_tpm.sh
+++ b/testcases/kernel/security/integrity/ima/tests/ima_tpm.sh
@@ -17,14 +17,14 @@ ERRMSG_TPM="TPM hardware support not enabled in kernel or no TPM chip found"
 setup()
 {
 	local config="${KCONFIG_PATH:-/boot/config-$(uname -r)}"
-	local line tmp
+	local line
 
 	read line < $ASCII_MEASUREMENTS
-	if tmp=$(get_algorithm_digest "$line"); then
-		ALGORITHM=$(echo "$tmp" | cut -d'|' -f1)
-		DIGEST=$(echo "$tmp" | cut -d'|' -f2)
+	if get_algorithm_digest "$line" > tmp; then
+		ALGORITHM=$(cat tmp | cut -d'|' -f1)
+		DIGEST=$(cat tmp | cut -d'|' -f2)
 	else
-		tst_brk TBROK "failed to get algorithm/digest: $tmp"
+		tst_brk TBROK "failed to get algorithm/digest"
 	fi
 	tst_res TINFO "used algorithm: $ALGORITHM"
 
diff --git a/testcases/kernel/security/kallsyms/kallsyms.c b/testcases/kernel/security/kallsyms/kallsyms.c
index ad3a9265a..cf1390fb4 100644
--- a/testcases/kernel/security/kallsyms/kallsyms.c
+++ b/testcases/kernel/security/kallsyms/kallsyms.c
@@ -50,10 +50,17 @@ struct kallsym {
 	char name[128];
 };
 
+struct range_struct {
+	unsigned long start, end;
+
+};
+
 static struct kallsym *sym_table;
 static unsigned int nr_symbols;
 static sigjmp_buf jmpbuf;
 volatile sig_atomic_t segv_caught;
+static struct range_struct *ranges;
+static int ranges_size, ranges_len;
 
 static void segv_handler(int sig)
 {
@@ -89,6 +96,49 @@ static unsigned int read_kallsyms(struct kallsym *table, unsigned int table_size
 	return nr_syms;
 }
 
+static void read_proc_self_maps(void)
+{
+	FILE *fp;
+
+	ranges_len = 0;
+	fp = fopen("/proc/self/maps", "r");
+	if (fp == NULL)
+		tst_brk(TBROK | TERRNO, "Failed to open /proc/self/maps.");
+
+	while (!feof(fp)) {
+		unsigned long start, end;
+		int ret;
+
+		ret = fscanf(fp, "%lx-%lx %*[^\n]\n", &start, &end);
+		if (ret != 2) {
+			fclose(fp);
+			tst_brk(TBROK | TERRNO, "Couldn't parse /proc/self/maps line.");
+		}
+
+		if (ranges_size < ranges_len + 1) {
+			ranges_size += 128;
+			ranges = SAFE_REALLOC(ranges,
+				ranges_size*sizeof(struct range_struct));
+		}
+		ranges[ranges_len].start = start;
+		ranges[ranges_len].end = end;
+		ranges_len++;
+	}
+
+	fclose(fp);
+}
+
+static int is_address_mapped(unsigned long addr)
+{
+	int i;
+
+	for (i = 0; i < ranges_len; i++) {
+		if (ranges[i].start <= addr && addr < ranges[i].end)
+			return 1;
+	}
+	return 0;
+}
+
 static void setup(void)
 {
 	struct sigaction sa;
@@ -117,17 +167,30 @@ static void access_ksymbols_address(struct kallsym *table)
 	}
 }
 
+
 static void test_access_kernel_address(void)
 {
-	segv_caught = 0;
+	int skipped = 0;
 
-	for (unsigned int i = 0; i < nr_symbols; i++)
+	segv_caught = 0;
+	read_proc_self_maps();
+
+	for (unsigned int i = 0; i < nr_symbols; i++) {
+		if (is_address_mapped(sym_table[i].addr)) {
+			tst_res(TDEBUG, "Skipping userspace mapped address 0x%lx",
+				sym_table[i].addr);
+			skipped++;
+			continue;
+		}
 		access_ksymbols_address(&sym_table[i]);
+	}
 
-	if (segv_caught == (sig_atomic_t)nr_symbols)
-		tst_res(TPASS, "Caught %d SIGSEGV in access ksymbols addr", segv_caught);
+	if (segv_caught == (sig_atomic_t)nr_symbols - skipped)
+		tst_res(TPASS, "Caught %d SIGSEGV in access ksymbols addr, skipped %d",
+			segv_caught, skipped);
 	else
-		tst_res(TFAIL, "Caught %d SIGSEGV but expected %d", segv_caught, nr_symbols);
+		tst_res(TFAIL, "Caught %d SIGSEGV but expected %d, skipped %d",
+			segv_caught, nr_symbols-skipped, skipped);
 }
 
 static void cleanup(void)
@@ -140,6 +203,10 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 60,
+	.timeout = 60,
+	.needs_kconfigs = (const char *const[]){
+		"CONFIG_KALLSYMS=y",
+		NULL
+	},
 	.test_all = test_access_kernel_address,
 };
diff --git a/testcases/kernel/sound/snd_seq01.c b/testcases/kernel/sound/snd_seq01.c
index 31038b937..a23fdb34e 100644
--- a/testcases/kernel/sound/snd_seq01.c
+++ b/testcases/kernel/sound/snd_seq01.c
@@ -123,7 +123,7 @@ static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(testfunc_list),
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 60,
+	.runtime = 60,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "d15d662e89fc"},
diff --git a/testcases/kernel/sound/snd_timer01.c b/testcases/kernel/sound/snd_timer01.c
index 310169b0f..bbc5f72a4 100644
--- a/testcases/kernel/sound/snd_timer01.c
+++ b/testcases/kernel/sound/snd_timer01.c
@@ -136,7 +136,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "d11662f4f798"},
 		{"linux-git", "ba3021b2c79b"},
diff --git a/testcases/kernel/syscalls/access/access01.c b/testcases/kernel/syscalls/access/access01.c
index 391c8d44b..1c32c6d04 100644
--- a/testcases/kernel/syscalls/access/access01.c
+++ b/testcases/kernel/syscalls/access/access01.c
@@ -314,6 +314,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.needs_tmpdir = 1,
 	.needs_root = 1,
 	.forks_child = 1,
diff --git a/testcases/kernel/syscalls/acct/acct01.c b/testcases/kernel/syscalls/acct/acct01.c
index a05ed2ea9..781d62261 100644
--- a/testcases/kernel/syscalls/acct/acct01.c
+++ b/testcases/kernel/syscalls/acct/acct01.c
@@ -25,8 +25,7 @@
 
 #include "tst_test.h"
 
-#define DIR_MODE	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP| \
-			 S_IXGRP|S_IROTH|S_IXOTH)
+#define DIR_MODE	0755
 #define FILE_EISDIR		"."
 #define FILE_EACCESS		"/dev/null"
 #define FILE_ENOENT		"/tmp/does/not/exist"
@@ -34,6 +33,7 @@
 #define FILE_TMPFILE		"./tmpfile"
 #define FILE_ELOOP		"test_file_eloop1"
 #define FILE_EROFS		"ro_mntpoint/file"
+#define FILE_EFAULT		"invalid/file/name"
 
 static struct passwd *ltpuser;
 
@@ -46,6 +46,7 @@ static char *file_eloop;
 static char *file_enametoolong;
 static char *file_erofs;
 static char *file_null;
+static char *file_efault;
 
 static void setup_euid(void)
 {
@@ -57,12 +58,22 @@ static void cleanup_euid(void)
 	SAFE_SETEUID(0);
 }
 
+static void setup_emem(void)
+{
+	file_efault = SAFE_MMAP(NULL, 1, PROT_NONE,
+			MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
+}
+static void cleanup_emem(void)
+{
+	SAFE_MUNMAP(file_efault, 1);
+}
+
 static struct test_case {
 	char **filename;
 	char *desc;
 	int exp_errno;
-	void (*setupfunc) ();
-	void (*cleanfunc) ();
+	void (*setupfunc)();
+	void (*cleanfunc)();
 } tcases[] = {
 	{&file_eisdir,  FILE_EISDIR,  EISDIR,  NULL,   NULL},
 	{&file_eaccess, FILE_EACCESS, EACCES,  NULL,   NULL},
@@ -73,6 +84,7 @@ static struct test_case {
 	{&file_eloop,   FILE_ELOOP,   ELOOP,        NULL, NULL},
 	{&file_enametoolong, "aaaa...", ENAMETOOLONG, NULL, NULL},
 	{&file_erofs,   FILE_EROFS,   EROFS,        NULL, NULL},
+	{&file_efault,	"Invalid address",  EFAULT,  setup_emem, cleanup_emem},
 };
 
 static void setup(void)
@@ -80,8 +92,6 @@ static void setup(void)
 	int fd;
 
 	TEST(acct(NULL));
-	if (TST_RET == -1 && TST_ERR == ENOSYS)
-		tst_brk(TCONF, "acct() system call isn't configured in kernel");
 
 	ltpuser = SAFE_GETPWNAM("nobody");
 
@@ -113,7 +123,7 @@ static void verify_acct(unsigned int nr)
 		tcase->setupfunc();
 
 	TST_EXP_FAIL(acct(*tcase->filename), tcase->exp_errno,
-	             "acct(%s)", tcase->desc);
+		"acct(%s)", tcase->desc);
 
 	if (tcase->cleanfunc)
 		tcase->cleanfunc();
@@ -136,5 +146,9 @@ static struct tst_test test = {
 		{&file_enametoolong, .size = PATH_MAX+2},
 		{&file_erofs, .str = FILE_EROFS},
 		{}
+	},
+	.needs_kconfigs = (const char *[]) {
+		"CONFIG_BSD_PROCESS_ACCT=y",
+		NULL,
 	}
 };
diff --git a/testcases/kernel/syscalls/acct/acct02.c b/testcases/kernel/syscalls/acct/acct02.c
index d3f3d9d04..74019f430 100644
--- a/testcases/kernel/syscalls/acct/acct02.c
+++ b/testcases/kernel/syscalls/acct/acct02.c
@@ -186,7 +186,7 @@ static void run(void)
 
 		if (read_bytes != acct_size) {
 			tst_res(TFAIL, "incomplete read %i bytes, expected %i",
-			        read_bytes, acct_size);
+					read_bytes, acct_size);
 			goto exit;
 		}
 
diff --git a/testcases/kernel/syscalls/add_key/add_key01.c b/testcases/kernel/syscalls/add_key/add_key01.c
index 1983e2538..d46d57e3a 100644
--- a/testcases/kernel/syscalls/add_key/add_key01.c
+++ b/testcases/kernel/syscalls/add_key/add_key01.c
@@ -23,7 +23,7 @@ static char *logon_buf, *logon_buf1;
 static char *big_key_buf, *big_key_buf1;
 static unsigned int logon_nsup, big_key_nsup;
 
-struct tcase {
+static struct tcase {
 	const char *type;
 	const char *desc;
 	char **buf;
diff --git a/testcases/kernel/syscalls/add_key/add_key02.c b/testcases/kernel/syscalls/add_key/add_key02.c
index 98dd5b905..4d5a4ef77 100644
--- a/testcases/kernel/syscalls/add_key/add_key02.c
+++ b/testcases/kernel/syscalls/add_key/add_key02.c
@@ -23,7 +23,7 @@
 #include "tst_test.h"
 #include "lapi/keyctl.h"
 
-struct tcase {
+static struct tcase {
 	const char *type;
 	size_t plen;
 } tcases[] = {
diff --git a/testcases/kernel/syscalls/add_key/add_key05.c b/testcases/kernel/syscalls/add_key/add_key05.c
index 74b0b54dd..c9a2f840e 100644
--- a/testcases/kernel/syscalls/add_key/add_key05.c
+++ b/testcases/kernel/syscalls/add_key/add_key05.c
@@ -144,7 +144,7 @@ static void verify_max_bytes(void)
 static void verify_max_keys(void)
 {
 	int i, used_key, max_key;
-	char desc[10];
+	char desc[15];
 
 	tst_res(TINFO, "test max keys under unprivileged user");
 	parse_proc_key_users(&used_key, &max_key, NULL, NULL);
@@ -203,8 +203,6 @@ static void do_test(unsigned int n)
 
 	tst_reap_children();
 	useri++;
-
-	return;
 }
 
 static void cleanup(void)
@@ -214,6 +212,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 2,
 	.test = do_test,
 	.tcnt = 2,
 	.needs_root = 1,
diff --git a/testcases/kernel/syscalls/alarm/alarm05.c b/testcases/kernel/syscalls/alarm/alarm05.c
index 2eeb1c22f..82bff69cb 100644
--- a/testcases/kernel/syscalls/alarm/alarm05.c
+++ b/testcases/kernel/syscalls/alarm/alarm05.c
@@ -44,6 +44,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 2,
 	.test_all = run,
 	.setup = setup,
 };
diff --git a/testcases/kernel/syscalls/alarm/alarm06.c b/testcases/kernel/syscalls/alarm/alarm06.c
index 82c0d44bd..2cfa26207 100644
--- a/testcases/kernel/syscalls/alarm/alarm06.c
+++ b/testcases/kernel/syscalls/alarm/alarm06.c
@@ -41,6 +41,7 @@ static void verify_alarm(void)
 }
 
 static struct tst_test test = {
+	.timeout = 4,
 	.setup = setup,
 	.test_all = verify_alarm,
 };
diff --git a/testcases/kernel/syscalls/alarm/alarm07.c b/testcases/kernel/syscalls/alarm/alarm07.c
index 64aed507d..c04745f9d 100644
--- a/testcases/kernel/syscalls/alarm/alarm07.c
+++ b/testcases/kernel/syscalls/alarm/alarm07.c
@@ -47,6 +47,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 4,
 	.test_all = verify_alarm,
 	.setup = setup,
 	.forks_child = 1,
diff --git a/testcases/kernel/syscalls/bind/bind01.c b/testcases/kernel/syscalls/bind/bind01.c
index 68a1e48f6..118255469 100644
--- a/testcases/kernel/syscalls/bind/bind01.c
+++ b/testcases/kernel/syscalls/bind/bind01.c
@@ -99,9 +99,14 @@ static void test_setup(void)
 
 static void test_cleanup(void)
 {
-	SAFE_CLOSE(inet_socket);
-	SAFE_CLOSE(dev_null);
-	SAFE_CLOSE(fd_enotdir);
+	if (inet_socket > 0)
+		SAFE_CLOSE(inet_socket);
+
+	if (dev_null > 0)
+		SAFE_CLOSE(dev_null);
+
+	if (fd_enotdir > 0)
+		SAFE_CLOSE(fd_enotdir);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/bind/bind02.c b/testcases/kernel/syscalls/bind/bind02.c
index a997157d6..9f5f940e9 100644
--- a/testcases/kernel/syscalls/bind/bind02.c
+++ b/testcases/kernel/syscalls/bind/bind02.c
@@ -6,9 +6,10 @@
  *   Copyright (c) 2019 Martin Doucha <mdoucha@suse.cz>
  */
 
-/*
- * Test Description:
- *  Make sure bind() of privileged port gives EACCESS error for non-root users.
+/*\
+ * [Description]
+ *
+ * Make sure bind() of privileged port gives EACCESS error for non-root users.
  */
 
 #include <string.h>
@@ -37,7 +38,7 @@ static void run(void)
 	servaddr.sin_port = htons(TCP_PRIVILEGED_PORT);
 	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	TST_EXP_FAIL(bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)),
-	             EACCES, "bind()");
+				 EACCES, "bind()");
 	SAFE_CLOSE(sockfd);
 }
 
diff --git a/testcases/kernel/syscalls/bind/bind03.c b/testcases/kernel/syscalls/bind/bind03.c
index 8c95cd799..3b1fd9afe 100644
--- a/testcases/kernel/syscalls/bind/bind03.c
+++ b/testcases/kernel/syscalls/bind/bind03.c
@@ -29,14 +29,14 @@ static void run(void)
 	 * rebound.
 	 */
 	TST_EXP_FAIL(bind(sock1, (struct sockaddr *)&sun2, sizeof(sun2)),
-	             EINVAL, "re-bind() socket");
+		     EINVAL, "re-bind() socket");
 
 	/*
 	 * Since a socket is already bound to the pathname, it can't be bound
 	 * to a second socket. Expected error is EADDRINUSE.
 	 */
 	TST_EXP_FAIL(bind(sock2, (struct sockaddr *)&sun1, sizeof(sun1)),
-	             EADDRINUSE, "bind() with bound pathname");
+		     EADDRINUSE, "bind() with bound pathname");
 
 	/*
 	 * Kernel is buggy since it creates the node in fileystem first, then
@@ -74,8 +74,11 @@ static void setup(void)
 
 static void cleanup(void)
 {
-	SAFE_CLOSE(sock1);
-	SAFE_CLOSE(sock2);
+	if (sock1 > 0)
+		SAFE_CLOSE(sock1);
+
+	if (sock2 > 0)
+		SAFE_CLOSE(sock2);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/bind/bind04.c b/testcases/kernel/syscalls/bind/bind04.c
index d8456e739..2a46559de 100644
--- a/testcases/kernel/syscalls/bind/bind04.c
+++ b/testcases/kernel/syscalls/bind/bind04.c
@@ -161,6 +161,7 @@ static void test_bind(unsigned int n)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test = test_bind,
 	.tcnt = ARRAY_SIZE(testcase_list),
 	.needs_tmpdir = 1,
diff --git a/testcases/kernel/syscalls/bind/bind06.c b/testcases/kernel/syscalls/bind/bind06.c
index 7c3300c42..4e7a8d11f 100644
--- a/testcases/kernel/syscalls/bind/bind06.c
+++ b/testcases/kernel/syscalls/bind/bind06.c
@@ -92,7 +92,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 300,
+	.runtime = 300,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_USER_NS=y",
diff --git a/testcases/kernel/syscalls/bind/libbind.h b/testcases/kernel/syscalls/bind/libbind.h
index 58f1bb7e1..aeb1ab3c3 100644
--- a/testcases/kernel/syscalls/bind/libbind.h
+++ b/testcases/kernel/syscalls/bind/libbind.h
@@ -1,6 +1,5 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- *   Copyright (c) 2019 Martin Doucha <mdoucha@suse.cz>
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright (c) 2019 Martin Doucha <mdoucha@suse.cz>
  */
 
 /*
diff --git a/testcases/kernel/syscalls/bpf/bpf_map01.c b/testcases/kernel/syscalls/bpf/bpf_map01.c
index 94f9b7873..7f2264bf5 100644
--- a/testcases/kernel/syscalls/bpf/bpf_map01.c
+++ b/testcases/kernel/syscalls/bpf/bpf_map01.c
@@ -1,13 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
+ */
+
+/*\
+ * [Description]
  *
  * Trivial Extended Berkeley Packet Filter (eBPF) test.
  *
  * Sanity check creating and updating maps.
  */
-/*
- * If test is executed in a loop and limit for locked memory (ulimit -l) is
+
+ /*
+ * If the test is executed in a loop and limit for locked memory (ulimit -l) is
  * too low bpf() call can fail with EPERM due to deffered freeing.
  */
 
@@ -142,7 +147,6 @@ static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(map_types),
 	.test = run,
 	.setup = setup,
-	.min_kver = "3.19",
 	.bufs = (struct tst_buffers []) {
 		{&key4, .size = 4},
 		{&key8, .size = 8},
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog01.c b/testcases/kernel/syscalls/bpf/bpf_prog01.c
index de4f68cef..b3846cb62 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog01.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog01.c
@@ -1,21 +1,27 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
+ */
+
+/*\
+ * [Description]
  *
  * Trivial Extended Berkeley Packet Filter (eBPF) test.
  *
  * Sanity check loading and running bytecode.
  *
- * Test flow:
- * 1. Create array map
- * 2. Load eBPF program
- * 3. Attach program to socket
- * 4. Send packet on socket
- * 5. This should trigger eBPF program which writes to array map
- * 6. Verify array map was written to
+ * [Algorithm]
+ *
+ * - Create array map
+ * - Load eBPF program
+ * - Attach program to socket
+ * - Send packet on socket
+ * - This should trigger eBPF program which writes to array map
+ * - Verify array map was written to
  */
+
 /*
- * If test is executed in a loop and limit for locked memory (ulimit -l) is
+ * If the test is executed in a loop and limit for locked memory (ulimit -l) is
  * too low bpf() call can fail with EPERM due to deffered freeing.
  */
 
@@ -101,7 +107,6 @@ void run(void)
 static struct tst_test test = {
 	.setup = setup,
 	.test_all = run,
-	.min_kver = "3.19",
 	.bufs = (struct tst_buffers []) {
 		{&log, .size = BUFSIZ},
 		{&attr, .size = sizeof(*attr)},
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog02.c b/testcases/kernel/syscalls/bpf/bpf_prog02.c
index fd3e535c1..69314aea7 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog02.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog02.c
@@ -1,13 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
+ */
+
+/*\
+ * [Description]
  *
  * Check if eBPF can do arithmetic with 64bits. This targets a specific
  * regression which only effects unprivileged users who are subject to extra
  * pointer arithmetic checks during verification.
  *
- * Fixed by commit 3612af783cf52c74a031a2f11b82247b2599d3cd.
- * https://new.blog.cloudflare.com/ebpf-cant-count/
+ * Fixed by kernel commit
+ * 3612af783cf5 ("bpf: fix sanitation rewrite in case of non-pointers")
+ *
+ * https://blog.cloudflare.com/ebpf-cant-count/
  *
  * This test is very similar in structure to bpf_prog01 which is better
  * annotated.
@@ -109,7 +115,6 @@ static void run(void)
 static struct tst_test test = {
 	.setup = setup,
 	.test_all = run,
-	.min_kver = "3.18",
 	.caps = (struct tst_cap []) {
 		TST_CAP(TST_CAP_DROP, CAP_SYS_ADMIN),
 		{}
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog03.c b/testcases/kernel/syscalls/bpf/bpf_prog03.c
index 35bb841c7..62432cc3f 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog03.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog03.c
@@ -1,19 +1,24 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
- * Original byte code was provided by jannh@google.com
+ * Original byte code was provided by Jann Horn <jannh@google.com>
+ */
+
+/*\
+ * [Description]
  *
- * Check for the bug fixed by 95a762e2c8c942780948091f8f2a4f32fce1ac6f
- * "bpf: fix incorrect sign extension in check_alu_op()"
  * CVE-2017-16995
  *
- * This test is very similar to the reproducer found here:
+ * Test for the bug fixed by kernel commit
+ * 95a762e2c8c9 ("bpf: fix incorrect sign extension in check_alu_op()")
+ *
+ * The test is very similar to the original reproducer:
  * https://bugs.chromium.org/p/project-zero/issues/detail?id=1454
  *
  * However it has been modified to try to corrupt the map struct instead of
  * writing to a noncanonical pointer. This appears to be more reliable at
  * producing stack traces and confirms we would be able to overwrite the ops
- * function pointers, as suggested by Jan.
+ * function pointers, as suggested by Jan Horn.
  *
  * If the eBPF code is loaded then this is considered a failure regardless of
  * whether it is able to cause any visible damage.
@@ -147,7 +152,6 @@ exit:
 static struct tst_test test = {
 	.setup = setup,
 	.test_all = run,
-	.min_kver = "3.18",
 	.caps = (struct tst_cap []) {
 		TST_CAP(TST_CAP_DROP, CAP_SYS_ADMIN),
 		{}
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog04.c b/testcases/kernel/syscalls/bpf/bpf_prog04.c
index cf3bb1254..5c61d34b4 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog04.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog04.c
@@ -4,19 +4,16 @@
  * Copyright (c) 2020 SUSE LLC <mdoucha@suse.cz>
  */
 
-/*
+/*\
+ * [Description]
+ *
  * CVE 2018-18445
  *
  * Check that eBPF verifier correctly handles 32-bit arithmetic, in particular
  * the right bit shift instruction. It is an error if the BPF program passes
  * verification regardless of whether it then causes any actual damage. Kernel
  * bug fixed in:
- *
- *  commit b799207e1e1816b09e7a5920fbb2d5fcf6edd681
- *  Author: Jann Horn <jannh@google.com>
- *  Date:   Fri Oct 5 18:17:59 2018 +0200
- *
- *  bpf: 32-bit RSH verification must truncate input before the ALU op
+ * b799207e1e18 ("bpf: 32-bit RSH verification must truncate input before the ALU op")
  */
 
 #include <stdio.h>
@@ -108,7 +105,6 @@ static void run(void)
 static struct tst_test test = {
 	.setup = setup,
 	.test_all = run,
-	.min_kver = "3.18",
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.caps = (struct tst_cap []) {
 		TST_CAP(TST_CAP_DROP, CAP_SYS_ADMIN),
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog05.c b/testcases/kernel/syscalls/bpf/bpf_prog05.c
index 742beab0b..050081712 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog05.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog05.c
@@ -190,9 +190,9 @@ static void run(void)
 }
 
 static struct tst_test test = {
+	.timeout = 20,
 	.setup = setup,
 	.test_all = run,
-	.min_kver = "3.18",
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.caps = (struct tst_cap []) {
 		TST_CAP(TST_CAP_DROP, CAP_SYS_ADMIN),
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog06.c b/testcases/kernel/syscalls/bpf/bpf_prog06.c
index cee9616cf..87fdd8060 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog06.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog06.c
@@ -131,6 +131,7 @@ static void run(void)
 }
 
 static struct tst_test test = {
+	.timeout = 20,
 	.setup = setup,
 	.test_all = run,
 	.min_kver = "5.8",
diff --git a/testcases/kernel/syscalls/bpf/bpf_prog07.c b/testcases/kernel/syscalls/bpf/bpf_prog07.c
index dab5bb8ad..29dfbf2ca 100644
--- a/testcases/kernel/syscalls/bpf/bpf_prog07.c
+++ b/testcases/kernel/syscalls/bpf/bpf_prog07.c
@@ -139,6 +139,7 @@ static void run(void)
 }
 
 static struct tst_test test = {
+	.timeout = 20,
 	.setup = setup,
 	.test_all = run,
 	.min_kver = "5.8",
diff --git a/testcases/kernel/syscalls/cachestat/.gitignore b/testcases/kernel/syscalls/cachestat/.gitignore
new file mode 100644
index 000000000..a3611a533
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/.gitignore
@@ -0,0 +1,4 @@
+cachestat01
+cachestat02
+cachestat03
+cachestat04
diff --git a/testcases/kernel/syscalls/cachestat/Makefile b/testcases/kernel/syscalls/cachestat/Makefile
new file mode 100644
index 000000000..62b00d2f4
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+
+LDLIBS += -lrt
+
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/cachestat/cachestat.h b/testcases/kernel/syscalls/cachestat/cachestat.h
new file mode 100644
index 000000000..efce6dc7f
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/cachestat.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef CACHESTAT_H__
+#define CACHESTAT_H__
+
+#include "tst_test.h"
+#include "lapi/mman.h"
+
+static inline void print_cachestat(struct cachestat *cs)
+{
+	tst_res(TDEBUG,
+		"nr_cache=%lu "
+		"nr_dirty=%lu "
+		"nr_writeback=%lu "
+		"nr_evicted=%lu "
+		"nr_recently_evicted=%lu",
+		cs->nr_cache,
+		cs->nr_dirty,
+		cs->nr_writeback,
+		cs->nr_evicted,
+		cs->nr_recently_evicted);
+}
+
+#endif
diff --git a/testcases/kernel/syscalls/cachestat/cachestat01.c b/testcases/kernel/syscalls/cachestat/cachestat01.c
new file mode 100644
index 000000000..22f0071d1
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/cachestat01.c
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that cachestat() syscall is properly counting cached pages
+ * written inside a file. If storage device synchronization is requested, test
+ * will check if the number of dirty pages is zero.
+ *
+ * [Algorithm]
+ *
+ * - create a file with specific amount of pages
+ * - synchronize storage device, if needed
+ * - monitor file with cachestat()
+ * - check if the right amount of pages have been moved into cache
+ * - if storage device synchronization is requested, check that dirty pages is
+ *    zero
+ */
+
+#include <stdlib.h>
+#include "cachestat.h"
+
+#define MNTPOINT "mntpoint"
+#define FILENAME MNTPOINT "/myfile.bin"
+
+static int page_size, num_shift;
+static char *page_data;
+static struct cachestat *cs;
+static struct cachestat_range *cs_range;
+
+static void test_cached_pages(const unsigned int use_sync, const int num_pages)
+{
+	int fd;
+
+	tst_res(TINFO, "%s file synchronization", use_sync ? "Enable" : "Disable");
+	tst_res(TINFO, "Number of pages: %d", num_pages);
+
+	memset(cs, 0, sizeof(struct cachestat));
+
+	fd = SAFE_OPEN(FILENAME, O_RDWR | O_CREAT, 0600);
+
+	for (int i = 0; i < num_pages; i++)
+		SAFE_WRITE(0, fd, page_data, page_size);
+
+	if (use_sync)
+		fsync(fd);
+
+	cs_range->off = 0;
+	cs_range->len = page_size * num_pages;
+
+	memset(cs, 0xff, sizeof(*cs));
+
+	TST_EXP_PASS(cachestat(fd, cs_range, cs, 0));
+	print_cachestat(cs);
+
+	TST_EXP_EQ_LI(cs->nr_cache + cs->nr_evicted, num_pages);
+
+	if (use_sync)
+		TST_EXP_EQ_LI(cs->nr_dirty, 0);
+
+	SAFE_CLOSE(fd);
+	SAFE_UNLINK(FILENAME);
+}
+
+static void run(unsigned int use_sync)
+{
+	for (int i = 0; i < num_shift; i++)
+		test_cached_pages(use_sync, 1 << i);
+}
+
+static void setup(void)
+{
+	page_size = (int)sysconf(_SC_PAGESIZE);
+	num_shift = MIN(tst_device->size*1024*2.5/page_size, 15);
+	page_data = SAFE_MALLOC(page_size);
+	memset(page_data, 'a', page_size);
+}
+
+static void cleanup(void)
+{
+	free(page_data);
+}
+
+static struct tst_test test = {
+	.timeout = 13,
+	.test = run,
+	.tcnt = 2,
+	.setup = setup,
+	.cleanup = cleanup,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *const []) {
+		"fuse",
+		"tmpfs",
+		NULL
+	},
+	.bufs = (struct tst_buffers []) {
+		{&cs, .size = sizeof(struct cachestat)},
+		{&cs_range, .size = sizeof(struct cachestat_range)},
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/cachestat/cachestat02.c b/testcases/kernel/syscalls/cachestat/cachestat02.c
new file mode 100644
index 000000000..e168de5a5
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/cachestat02.c
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that cachestat() syscall is properly counting cached pages
+ * written inside a shared memory.
+ *
+ * [Algorithm]
+ *
+ * - create a shared memory with a specific amount of pages
+ * - monitor file with cachestat()
+ * - check if the right amount of pages have been moved into cache
+ */
+
+#include <stdlib.h>
+#include "cachestat.h"
+
+#define FILENAME "myfile.bin"
+
+static int page_size;
+static char *page_data;
+static struct cachestat *cs;
+static struct cachestat_range *cs_range;
+
+static void test_cached_pages(const int num_pages)
+{
+	int fd, file_size;
+
+	tst_res(TINFO, "Number of pages: %d", num_pages);
+
+	memset(cs, 0, sizeof(struct cachestat));
+
+	fd = shm_open(FILENAME, O_RDWR | O_CREAT, 0600);
+	if (fd < 0)
+		tst_brk(TBROK | TERRNO, "shm_open error");
+
+	file_size = page_size * num_pages;
+
+	cs_range->off = 0;
+	cs_range->len = file_size;
+
+	SAFE_FTRUNCATE(fd, file_size);
+	for (int i = 0; i < num_pages; i++)
+		SAFE_WRITE(0, fd, page_data, page_size);
+
+	memset(cs, 0xff, sizeof(*cs));
+
+	TST_EXP_PASS(cachestat(fd, cs_range, cs, 0));
+	print_cachestat(cs);
+
+	TST_EXP_EQ_LI(cs->nr_cache + cs->nr_evicted, num_pages);
+
+	SAFE_CLOSE(fd);
+	shm_unlink(FILENAME);
+}
+
+static void run(void)
+{
+	for (int i = 0; i < 10; i++)
+		test_cached_pages(1 << i);
+}
+
+static void setup(void)
+{
+	page_size = (int)sysconf(_SC_PAGESIZE);
+
+	page_data = SAFE_MALLOC(page_size);
+	memset(page_data, 'a', page_size);
+}
+
+static void cleanup(void)
+{
+	free(page_data);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+	.bufs = (struct tst_buffers []) {
+		{&cs, .size = sizeof(struct cachestat)},
+		{&cs_range, .size = sizeof(struct cachestat_range)},
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/cachestat/cachestat03.c b/testcases/kernel/syscalls/cachestat/cachestat03.c
new file mode 100644
index 000000000..139745c34
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/cachestat03.c
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that cachestat() syscall is properly failing with relative
+ * error codes according to input parameters.
+ *
+ * - EFAULT: cstat or cstat_range points to an illegal address
+ * - EINVAL: invalid flags
+ * - EBADF: invalid file descriptor
+ * - EOPNOTSUPP: file descriptor is of a hugetlbfs file
+ */
+
+#define MNTPOINT "mnt"
+
+#include "cachestat.h"
+
+static int fd;
+static int fd_hugepage;
+static int invalid_fd = -1;
+static struct cachestat *cs;
+static struct cachestat *cs_null;
+static struct cachestat_range *cs_range;
+static struct cachestat_range *cs_range_null;
+
+static struct tcase {
+	int *fd;
+	struct cachestat_range **range;
+	struct cachestat **data;
+	int flags;
+	int exp_errno;
+	char *msg;
+} tcases[] = {
+	{&invalid_fd, &cs_range, &cs, 0, EBADF, "Invalid fd (-1)"},
+	{&fd, &cs_range_null, &cs, 0, EFAULT, "Invalid range (NULL)"},
+	{&fd, &cs_range, &cs_null, 0, EFAULT, "Invalid data (NULL)"},
+	{&fd, &cs_range, &cs, -1, EINVAL, "Invalid args (-1)"},
+	{&fd_hugepage, &cs_range, &cs, 0, EOPNOTSUPP, "Unsupported hugetlbfs"},
+};
+
+static void run(unsigned int i)
+{
+	struct tcase *tc = &tcases[i];
+
+	TST_EXP_FAIL(cachestat(*tc->fd, *tc->range, *tc->data, tc->flags),
+		tc->exp_errno, "%s", tc->msg);
+}
+
+static void setup(void)
+{
+	fd = SAFE_OPEN("test", O_CREAT | O_RDWR, 0700);
+	fd_hugepage = SAFE_OPEN(MNTPOINT"/test", O_CREAT | O_RDWR, 0700);
+}
+
+static void cleanup(void)
+{
+	SAFE_CLOSE(fd);
+	SAFE_CLOSE(fd_hugepage);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.mntpoint = MNTPOINT,
+	.needs_hugetlbfs = 1,
+	.hugepages = {1, TST_NEEDS},
+	.tcnt = ARRAY_SIZE(tcases),
+	.needs_tmpdir = 1,
+	.bufs = (struct tst_buffers []) {
+		{&cs, .size = sizeof(struct cachestat)},
+		{&cs_range, .size = sizeof(struct cachestat_range)},
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/cachestat/cachestat04.c b/testcases/kernel/syscalls/cachestat/cachestat04.c
new file mode 100644
index 000000000..7cef9897d
--- /dev/null
+++ b/testcases/kernel/syscalls/cachestat/cachestat04.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies cachestat() for all the possible file descriptors,
+ * checking that cache statistics are always zero, except for unsupported file
+ * descriptors which cause EBADF to be raised.
+ */
+
+#include "tst_test.h"
+#include "lapi/mman.h"
+
+#define MNTPOINT "mnt"
+
+static struct cachestat *cs;
+static struct cachestat_range *cs_range;
+
+static void check_cachestat(struct tst_fd *fd_in)
+{
+	int ret;
+
+	memset(cs, 0xff, sizeof(*cs));
+
+	ret = cachestat(fd_in->fd, cs_range, cs, 0);
+	if (ret == -1) {
+		TST_EXP_EQ_LI(errno, EBADF);
+		return;
+	}
+
+	TST_EXP_EQ_LI(cs->nr_cache, 0);
+	TST_EXP_EQ_LI(cs->nr_dirty, 0);
+	TST_EXP_EQ_LI(cs->nr_writeback, 0);
+	TST_EXP_EQ_LI(cs->nr_evicted, 0);
+	TST_EXP_EQ_LI(cs->nr_recently_evicted, 0);
+}
+
+static void run(void)
+{
+	TST_FD_FOREACH(fd) {
+		tst_res(TINFO, "%s -> ...", tst_fd_desc(&fd));
+		check_cachestat(&fd);
+	}
+}
+
+static struct tst_test test = {
+	.timeout = 2,
+	.test_all = run,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.bufs = (struct tst_buffers []) {
+		{&cs, .size = sizeof(struct cachestat)},
+		{&cs_range, .size = sizeof(struct cachestat_range)},
+		{}
+	},
+};
+
diff --git a/testcases/kernel/syscalls/chdir/chdir01.c b/testcases/kernel/syscalls/chdir/chdir01.c
index d50a8f50c..1c1299332 100644
--- a/testcases/kernel/syscalls/chdir/chdir01.c
+++ b/testcases/kernel/syscalls/chdir/chdir01.c
@@ -149,6 +149,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.needs_root = 1,
 	.mount_device = 1,
 	.mntpoint = MNTPOINT,
diff --git a/testcases/kernel/syscalls/chmod/.gitignore b/testcases/kernel/syscalls/chmod/.gitignore
index 27ddfce16..22e6c7bcd 100644
--- a/testcases/kernel/syscalls/chmod/.gitignore
+++ b/testcases/kernel/syscalls/chmod/.gitignore
@@ -3,3 +3,5 @@
 /chmod05
 /chmod06
 /chmod07
+/chmod08
+/chmod09
diff --git a/testcases/kernel/syscalls/chmod/chmod06.c b/testcases/kernel/syscalls/chmod/chmod06.c
index d6b86af75..93dd924c8 100644
--- a/testcases/kernel/syscalls/chmod/chmod06.c
+++ b/testcases/kernel/syscalls/chmod/chmod06.c
@@ -5,25 +5,20 @@
  * Copyright (c) 2014-2018 Cyril Hrubis <chrubis@suse.cz>
  */
 
-/*
- * Test Name: chmod06
+/*\
+ * [Description]
+ *
+ * Verify that, chmod(2) returns -1 and sets errno to
  *
- * Test Description:
- *   Verify that,
- *   1) chmod(2) returns -1 and sets errno to EPERM if the effective user id
- *	of process does not match the owner of the file and the process is
- *	not super user.
- *   2) chmod(2) returns -1 and sets errno to EACCES if search permission is
- *	denied on a component of the path prefix.
- *   3) chmod(2) returns -1 and sets errno to EFAULT if pathname points
- *	outside user's accessible address space.
- *   4) chmod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
- *	component is too long.
- *   5) chmod(2) returns -1 and sets errno to ENOTDIR if the directory
- *	component in pathname is not a directory.
- *   6) chmod(2) returns -1 and sets errno to ENOENT if the specified file
- *	does not exists.
+ * 1. EPERM if the effective user id of process does not match the owner of the
+ * file and the process is not super user
+ * 2. EACCES if search permission is denied on a component of the path prefix
+ * 3. EFAULT if pathname points outside user's accessible address space
+ * 4. ENAMETOOLONG if the pathname component is too long
+ * 5. ENOTDIR if the directory component in pathname is not a directory
+ * 6. ENOENT if the specified file does not exists
  */
+
 #include <pwd.h>
 #include <errno.h>
 #include "tst_test.h"
diff --git a/testcases/kernel/syscalls/chmod/chmod08.c b/testcases/kernel/syscalls/chmod/chmod08.c
new file mode 100644
index 000000000..ec448b409
--- /dev/null
+++ b/testcases/kernel/syscalls/chmod/chmod08.c
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ * Authors: David Fenner, Jon Hendrickson
+ * Copyright (C) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Test verifies that chmod() is working correctly on symlink()
+ * generated files.
+ */
+
+#include "tst_test.h"
+
+#define PERMS 01777
+#define TESTFILE "myobject"
+#define SYMBNAME "my_symlink0"
+
+static void run(void)
+{
+	struct stat oldsym_stat;
+	struct stat newsym_stat;
+
+	SAFE_TOUCH(TESTFILE, 0644, NULL);
+	SAFE_SYMLINK(TESTFILE, SYMBNAME);
+	SAFE_STAT(SYMBNAME, &oldsym_stat);
+
+	TST_EXP_PASS(chmod(SYMBNAME, PERMS));
+	SAFE_STAT(SYMBNAME, &newsym_stat);
+
+	TST_EXP_EQ_LI(newsym_stat.st_mode & PERMS, PERMS);
+	TST_EXP_EXPR(oldsym_stat.st_mode != newsym_stat.st_mode,
+		"file mode has changed");
+
+	SAFE_UNLINK(SYMBNAME);
+	SAFE_UNLINK(TESTFILE);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.needs_tmpdir = 1,
+};
diff --git a/testcases/kernel/syscalls/chmod/chmod09.c b/testcases/kernel/syscalls/chmod/chmod09.c
new file mode 100644
index 000000000..898922513
--- /dev/null
+++ b/testcases/kernel/syscalls/chmod/chmod09.c
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 Wei Gao <wegao@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Test for kernel commit
+ * 5d1f903f75a8 ("attr: block mode changes of symlinks")
+ */
+
+#include "lapi/fcntl.h"
+#include "tst_test.h"
+
+#define MODE 0644
+#define TESTFILE "testfile"
+#define TESTFILE_SYMLINK "testfile_symlink"
+
+static void run(void)
+{
+	struct stat stat_file, stat_sym;
+	int mode = 0;
+	char fd_path[100];
+
+	int fd = SAFE_OPEN(TESTFILE_SYMLINK, O_PATH | O_NOFOLLOW);
+
+	sprintf(fd_path, "/proc/self/fd/%d", fd);
+
+	TST_EXP_FAIL(chmod(fd_path, mode), ENOTSUP, "chmod(%s, %04o)",
+			TESTFILE_SYMLINK, mode);
+
+	SAFE_STAT(TESTFILE, &stat_file);
+	SAFE_LSTAT(TESTFILE_SYMLINK, &stat_sym);
+
+	stat_file.st_mode &= ~S_IFREG;
+	stat_sym.st_mode &= ~S_IFLNK;
+
+	TST_EXP_EXPR(stat_file.st_mode != (unsigned int)mode,
+			"stat(%s) mode=%04o", TESTFILE, stat_file.st_mode);
+
+	TST_EXP_EXPR(stat_sym.st_mode != (unsigned int)mode,
+			"stat(%s) mode=%04o", TESTFILE, stat_sym.st_mode);
+
+	SAFE_CLOSE(fd);
+}
+
+static void setup(void)
+{
+	SAFE_TOUCH(TESTFILE, MODE, NULL);
+	SAFE_SYMLINK(TESTFILE, TESTFILE_SYMLINK);
+}
+
+static void cleanup(void)
+{
+	remove(TESTFILE);
+	remove(TESTFILE_SYMLINK);
+}
+
+static struct tst_test test = {
+	.setup = setup,
+	.cleanup = cleanup,
+	.test_all = run,
+	.min_kver = "6.6",
+	.mntpoint = "mntpoint",
+	.all_filesystems = 1,
+	.tags = (const struct tst_tag[]) {
+		{"linux-git", "5d1f903f75a8"},
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/chroot/chroot01.c b/testcases/kernel/syscalls/chroot/chroot01.c
index febf064db..60f3f609c 100644
--- a/testcases/kernel/syscalls/chroot/chroot01.c
+++ b/testcases/kernel/syscalls/chroot/chroot01.c
@@ -27,18 +27,12 @@ static void setup(void)
 {
 	struct passwd *ltpuser;
 
-	path = tst_get_tmpdir();
+	path = tst_tmpdir_path();
 	ltpuser = SAFE_GETPWNAM("nobody");
 	SAFE_SETEUID(ltpuser->pw_uid);
 }
 
-static void cleanup(void)
-{
-	free(path);
-}
-
 static struct tst_test test = {
-	.cleanup = cleanup,
 	.setup = setup,
 	.test_all = verify_chroot,
 	.needs_root = 1,
diff --git a/testcases/kernel/syscalls/chroot/chroot02.c b/testcases/kernel/syscalls/chroot/chroot02.c
index ad33abdcc..b01a87660 100644
--- a/testcases/kernel/syscalls/chroot/chroot02.c
+++ b/testcases/kernel/syscalls/chroot/chroot02.c
@@ -37,17 +37,11 @@ static void verify_chroot(void)
 
 static void setup(void)
 {
-	path = tst_get_tmpdir();
+	path = tst_tmpdir_path();
 	SAFE_TOUCH(TMP_FILENAME, 0666, NULL);
 }
 
-static void cleanup(void)
-{
-	free(path);
-}
-
 static struct tst_test test = {
-	.cleanup = cleanup,
 	.setup = setup,
 	.test_all = verify_chroot,
 	.needs_root = 1,
diff --git a/testcases/kernel/syscalls/clock_gettime/Makefile b/testcases/kernel/syscalls/clock_gettime/Makefile
index e7f5e9e75..2d9144602 100644
--- a/testcases/kernel/syscalls/clock_gettime/Makefile
+++ b/testcases/kernel/syscalls/clock_gettime/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpvdso
+LTPLIBS = vdso
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/clock_gettime/leapsec01.c b/testcases/kernel/syscalls/clock_gettime/leapsec01.c
index e623b4107..4cd469dc2 100644
--- a/testcases/kernel/syscalls/clock_gettime/leapsec01.c
+++ b/testcases/kernel/syscalls/clock_gettime/leapsec01.c
@@ -196,6 +196,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 40,
 	.test_all = run_leapsec,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/clock_nanosleep/clock_nanosleep01.c b/testcases/kernel/syscalls/clock_nanosleep/clock_nanosleep01.c
index eef8a5992..55e7b294e 100644
--- a/testcases/kernel/syscalls/clock_nanosleep/clock_nanosleep01.c
+++ b/testcases/kernel/syscalls/clock_nanosleep/clock_nanosleep01.c
@@ -219,6 +219,7 @@ static void do_test(unsigned int i)
 }
 
 static struct tst_test test = {
+	.timeout = 3,
 	.tcnt = ARRAY_SIZE(tcase),
 	.test = do_test,
 	.test_variants = ARRAY_SIZE(variants),
diff --git a/testcases/kernel/syscalls/clock_settime/clock_settime03.c b/testcases/kernel/syscalls/clock_settime/clock_settime03.c
index f196a257c..692e63788 100644
--- a/testcases/kernel/syscalls/clock_settime/clock_settime03.c
+++ b/testcases/kernel/syscalls/clock_settime/clock_settime03.c
@@ -104,6 +104,7 @@ static void run(void)
 }
 
 static struct tst_test test = {
+	.timeout = 4,
 	.test_all = run,
 	.test_variants = ARRAY_SIZE(variants),
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/clone/clone02.c b/testcases/kernel/syscalls/clone/clone02.c
index 821adc2d9..fd3ee1aed 100644
--- a/testcases/kernel/syscalls/clone/clone02.c
+++ b/testcases/kernel/syscalls/clone/clone02.c
@@ -59,6 +59,7 @@
 #include <sched.h>
 #include "test.h"
 #include "safe_macros.h"
+#include "tst_clone.h"
 
 #define FLAG_ALL (CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|SIGCHLD)
 #define FLAG_NONE SIGCHLD
diff --git a/testcases/kernel/syscalls/close_range/close_range01.c b/testcases/kernel/syscalls/close_range/close_range01.c
index adeb2e918..941f3e403 100644
--- a/testcases/kernel/syscalls/close_range/close_range01.c
+++ b/testcases/kernel/syscalls/close_range/close_range01.c
@@ -48,7 +48,7 @@ static inline void do_close_range(unsigned int fd, unsigned int max_fd,
 			tst_brk(TCONF | TERRNO, "No CLOSE_RANGE_CLOEXEC");
 	}
 
-	tst_brk(TBROK | TERRNO, "close_range(%d, %d, %d)", fd, max_fd, flags);
+	tst_brk(TBROK | TERRNO, "close_range(%u, %u, %u)", fd, max_fd, flags);
 }
 
 static void setup(void)
@@ -191,6 +191,7 @@ static void run(unsigned int n)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.tcnt = 4,
 	.forks_child = 1,
 	.mount_device = 1,
diff --git a/testcases/kernel/syscalls/connect/connect02.c b/testcases/kernel/syscalls/connect/connect02.c
index e20214e24..087b514bf 100644
--- a/testcases/kernel/syscalls/connect/connect02.c
+++ b/testcases/kernel/syscalls/connect/connect02.c
@@ -126,6 +126,7 @@ static void run(void)
 }
 
 static struct tst_test test = {
+	.timeout = 3,
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/copy_file_range/copy_file_range01.c b/testcases/kernel/syscalls/copy_file_range/copy_file_range01.c
index bbcb0ca3b..2390a32da 100644
--- a/testcases/kernel/syscalls/copy_file_range/copy_file_range01.c
+++ b/testcases/kernel/syscalls/copy_file_range/copy_file_range01.c
@@ -232,5 +232,5 @@ static struct tst_test test = {
 	.all_filesystems = 1,
 	.test = copy_file_range_verify,
 	.test_variants = TEST_VARIANTS,
-	.max_runtime = 5
+	.timeout = 5
 };
diff --git a/testcases/kernel/syscalls/creat/creat05.c b/testcases/kernel/syscalls/creat/creat05.c
index bf4099439..32074a449 100644
--- a/testcases/kernel/syscalls/creat/creat05.c
+++ b/testcases/kernel/syscalls/creat/creat05.c
@@ -74,6 +74,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test_all = verify_creat,
 	.needs_tmpdir = 1,
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/creat/creat08.c b/testcases/kernel/syscalls/creat/creat08.c
index 91581dbf8..011753ac5 100644
--- a/testcases/kernel/syscalls/creat/creat08.c
+++ b/testcases/kernel/syscalls/creat/creat08.c
@@ -29,7 +29,6 @@
 #define NOSETGID_B	DIR_B "/nosetgid"
 #define ROOT_SETGID	DIR_B "/root_setgid"
 
-static char *tmpdir;
 static uid_t orig_uid, nobody_uid;
 static gid_t nobody_gid, free_gid;
 static int fd = -1;
@@ -44,7 +43,6 @@ static void setup(void)
 	tst_res(TINFO, "User nobody: uid = %d, gid = %d", (int)nobody_uid,
 		(int)nobody_gid);
 	free_gid = tst_get_free_gid(nobody_gid);
-	tmpdir = tst_get_tmpdir();
 }
 
 static void file_test(const char *name, mode_t mode, int sgid, gid_t gid)
@@ -125,15 +123,13 @@ static void run(void)
 	file_test(ROOT_SETGID, MODE_SGID, 1, free_gid);
 
 	/* Cleanup between loops */
-	tst_purge_dir(tmpdir);
+	tst_purge_dir(tst_tmpdir_path());
 }
 
 static void cleanup(void)
 {
 	if (fd >= 0)
 		SAFE_CLOSE(fd);
-
-	free(tmpdir);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/creat/creat09.c b/testcases/kernel/syscalls/creat/creat09.c
index a5d3740ac..d18165772 100644
--- a/testcases/kernel/syscalls/creat/creat09.c
+++ b/testcases/kernel/syscalls/creat/creat09.c
@@ -138,6 +138,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test = run,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/delete_module/.gitignore b/testcases/kernel/syscalls/delete_module/.gitignore
index 1a774a6d5..e08f20d17 100644
--- a/testcases/kernel/syscalls/delete_module/.gitignore
+++ b/testcases/kernel/syscalls/delete_module/.gitignore
@@ -3,10 +3,7 @@
 /delete_module03
 /*.ko
 /*.mod.c
-/*.ko.cmd
-/*.mod.cmd
-/*.mod.o.cmd
-/*.o.cmd
-/.built-in.a.cmd
+/*.cmd
 /Module.symvers
 /modules.order
+modules.livepatch
diff --git a/testcases/kernel/syscalls/delete_module/delete_module01.c b/testcases/kernel/syscalls/delete_module/delete_module01.c
index 11c4eae58..bcaa0763d 100644
--- a/testcases/kernel/syscalls/delete_module/delete_module01.c
+++ b/testcases/kernel/syscalls/delete_module/delete_module01.c
@@ -17,7 +17,6 @@
 #include <stdlib.h>
 #include "tst_test.h"
 #include "tst_module.h"
-#include "tst_kconfig.h"
 #include "lapi/syscalls.h"
 
 #define MODULE_NAME	"dummy_del_mod"
@@ -27,11 +26,7 @@ static int module_loaded;
 
 static void do_delete_module(void)
 {
-	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
-
-	tst_kcmdline_parse(&params, 1);
-	if (atoi(params.value) == 1)
-		tst_brk(TCONF, "module signature is enforced, skip test");
+	tst_requires_module_signature_disabled();
 
 	if (!module_loaded) {
 		tst_module_load(MODULE_NAME_KO, NULL);
diff --git a/testcases/kernel/syscalls/delete_module/delete_module03.c b/testcases/kernel/syscalls/delete_module/delete_module03.c
index fdf0c293d..e36b8efec 100644
--- a/testcases/kernel/syscalls/delete_module/delete_module03.c
+++ b/testcases/kernel/syscalls/delete_module/delete_module03.c
@@ -16,7 +16,6 @@
 #include <errno.h>
 #include "tst_test.h"
 #include "tst_module.h"
-#include "tst_kconfig.h"
 #include "lapi/syscalls.h"
 
 #define DUMMY_MOD		"dummy_del_mod"
@@ -52,11 +51,7 @@ static void do_delete_module(void)
 
 static void setup(void)
 {
-	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
-
-	tst_kcmdline_parse(&params, 1);
-	if (atoi(params.value) == 1)
-		tst_brk(TCONF, "module signature is enforced, skip test");
+	tst_requires_module_signature_disabled();
 
 	/* Load first kernel module */
 	tst_module_load(DUMMY_MOD_KO, NULL);
diff --git a/testcases/kernel/syscalls/delete_module/dummy_del_mod.c b/testcases/kernel/syscalls/delete_module/dummy_del_mod.c
index 0ca7bea37..4257bb504 100644
--- a/testcases/kernel/syscalls/delete_module/dummy_del_mod.c
+++ b/testcases/kernel/syscalls/delete_module/dummy_del_mod.c
@@ -14,6 +14,8 @@
 #include <linux/proc_fs.h>
 #include <linux/kernel.h>
 
+#define DIRNAME "dummy_delmod"
+
 /* Dummy function called by dependent module */
 int dummy_func_test(void)
 {
@@ -25,13 +27,13 @@ static int __init dummy_init(void)
 {
 	struct proc_dir_entry *proc_dummy;
 
-	proc_dummy = proc_mkdir("dummy", 0);
+	proc_dummy = proc_mkdir(DIRNAME, 0);
 	return 0;
 }
 
 static void __exit dummy_exit(void)
 {
-	remove_proc_entry("dummy", 0);
+	remove_proc_entry(DIRNAME, 0);
 }
 
 module_init(dummy_init);
diff --git a/testcases/kernel/syscalls/delete_module/dummy_del_mod_dep.c b/testcases/kernel/syscalls/delete_module/dummy_del_mod_dep.c
index 85b327911..8c891cf49 100644
--- a/testcases/kernel/syscalls/delete_module/dummy_del_mod_dep.c
+++ b/testcases/kernel/syscalls/delete_module/dummy_del_mod_dep.c
@@ -16,20 +16,22 @@
 #include <linux/proc_fs.h>
 #include <linux/kernel.h>
 
+#define DIRNAME "dummy_dep"
+
 extern int dummy_func_test(void);
 
 static int __init dummy_init(void)
 {
 	struct proc_dir_entry *proc_dummy;
 
-	proc_dummy = proc_mkdir("dummy_dep", 0);
+	proc_dummy = proc_mkdir(DIRNAME, 0);
 	dummy_func_test();
 	return 0;
 }
 
 static void __exit dummy_exit(void)
 {
-	remove_proc_entry("dummy_dep", 0);
+	remove_proc_entry(DIRNAME, 0);
 }
 
 module_init(dummy_init);
diff --git a/testcases/kernel/syscalls/eventfd/eventfd06.c b/testcases/kernel/syscalls/eventfd/eventfd06.c
index 7339dd471..46d7f73d3 100644
--- a/testcases/kernel/syscalls/eventfd/eventfd06.c
+++ b/testcases/kernel/syscalls/eventfd/eventfd06.c
@@ -136,6 +136,8 @@ static void test_poll(void)
 static void setup(void)
 {
 	TEST(io_setup(MAXEVENTS, &ctx));
+	if (TST_RET == -ENOSYS)
+		tst_brk(TCONF | TRERRNO, "io_setup(): AIO not supported by kernel");
 	if (TST_RET < 0)
 		tst_brk(TBROK, "io_setup() failed: %s", tst_strerrno(-TST_RET));
 
diff --git a/testcases/kernel/syscalls/execve/execve05.c b/testcases/kernel/syscalls/execve/execve05.c
index d87d7446d..530c7cc89 100644
--- a/testcases/kernel/syscalls/execve/execve05.c
+++ b/testcases/kernel/syscalls/execve/execve05.c
@@ -62,6 +62,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 3,
 	.test_all = verify_execve,
 	.options = (struct tst_option[]) {
 		{"n:", &opt_nchild, "Numbers of children"},
diff --git a/testcases/kernel/syscalls/execveat/execveat03.c b/testcases/kernel/syscalls/execveat/execveat03.c
index 057d83278..684f0d0c6 100644
--- a/testcases/kernel/syscalls/execveat/execveat03.c
+++ b/testcases/kernel/syscalls/execveat/execveat03.c
@@ -68,6 +68,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.needs_root = 1,
 	.mount_device = 1,
 	.needs_overlay = 1,
diff --git a/testcases/kernel/syscalls/faccessat/faccessat01.c b/testcases/kernel/syscalls/faccessat/faccessat01.c
index 557d7eb4c..6be2b4bb7 100644
--- a/testcases/kernel/syscalls/faccessat/faccessat01.c
+++ b/testcases/kernel/syscalls/faccessat/faccessat01.c
@@ -55,10 +55,7 @@ static void verify_faccessat(unsigned int i)
 
 static void setup(void)
 {
-	char *tmpdir_path = tst_get_tmpdir();
-
-	abs_path = tst_aprintf("%s/%s", tmpdir_path, FILEPATH);
-	free(tmpdir_path);
+	abs_path = tst_tmpdir_genpath(FILEPATH);
 
 	SAFE_MKDIR(TESTDIR, 0700);
 	dir_fd = SAFE_OPEN(TESTDIR, O_DIRECTORY);
diff --git a/testcases/kernel/syscalls/faccessat2/faccessat201.c b/testcases/kernel/syscalls/faccessat2/faccessat201.c
index 012091752..1be6e9aa0 100644
--- a/testcases/kernel/syscalls/faccessat2/faccessat201.c
+++ b/testcases/kernel/syscalls/faccessat2/faccessat201.c
@@ -56,10 +56,7 @@ static void verify_faccessat2(unsigned int i)
 
 static void setup(void)
 {
-	char *tmpdir_path = tst_get_tmpdir();
-
-	abs_path = tst_aprintf("%s/%s", tmpdir_path, RELPATH);
-	free(tmpdir_path);
+	abs_path = tst_tmpdir_genpath(RELPATH);
 
 	SAFE_MKDIR(TESTDIR, 0777);
 	dir_fd = SAFE_OPEN(TESTDIR, O_DIRECTORY);
diff --git a/testcases/kernel/syscalls/fallocate/fallocate04.c b/testcases/kernel/syscalls/fallocate/fallocate04.c
index ff372a9bf..3a8ea5fa7 100644
--- a/testcases/kernel/syscalls/fallocate/fallocate04.c
+++ b/testcases/kernel/syscalls/fallocate/fallocate04.c
@@ -148,11 +148,6 @@ static void test03(void)
 {
 	tst_res(TINFO, "zeroing file space with FALLOC_FL_ZERO_RANGE");
 
-	if (tst_kvercmp(3, 15, 0) < 0) {
-		tst_brk(TCONF,
-			"FALLOC_FL_ZERO_RANGE needs Linux 3.15 or newer");
-	}
-
 	size_t alloc_size0 = get_allocsize();
 
 	tst_res(TINFO, "read current allocated file size '%zu'", alloc_size0);
@@ -287,6 +282,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.options = (struct tst_option[]) {
 		{"v", &verbose, "Turns on verbose mode"},
 		{}
diff --git a/testcases/kernel/syscalls/fallocate/fallocate05.c b/testcases/kernel/syscalls/fallocate/fallocate05.c
index af6bf9e8c..f17cc993e 100644
--- a/testcases/kernel/syscalls/fallocate/fallocate05.c
+++ b/testcases/kernel/syscalls/fallocate/fallocate05.c
@@ -55,7 +55,7 @@ static void setup(void)
 static void run(void)
 {
 	int fd;
-	long extsize, tmp;
+	long extsize, holesize, tmp;
 
 	fd = SAFE_OPEN(MNTPOINT "/test_file", O_WRONLY | O_CREAT | O_TRUNC,
 		0644);
@@ -114,12 +114,14 @@ static void run(void)
 	tst_res(TPASS, "fallocate() on full FS");
 
 	/* Btrfs deallocates only complete extents, not individual blocks */
-	if (!strcmp(tst_device->fs_type, "btrfs"))
-		tmp = bufsize + extsize;
+	if (!strcmp(tst_device->fs_type, "btrfs") ||
+		!strcmp(tst_device->fs_type, "bcachefs"))
+		holesize = bufsize + extsize;
 	else
-		tmp = DEALLOCATE_BLOCKS * blocksize;
+		holesize = DEALLOCATE_BLOCKS * blocksize;
 
-	TEST(fallocate(fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, tmp));
+	TEST(fallocate(fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0,
+		holesize));
 
 	if (TST_RET == -1) {
 		if (TST_ERR == ENOTSUP)
@@ -135,6 +137,31 @@ static void run(void)
 	else
 		tst_res(TPASS, "write()");
 
+	/* Check that the deallocated file range is marked as a hole */
+	TEST(lseek(fd, 0, SEEK_HOLE));
+
+	if (TST_RET == 0) {
+		tst_res(TPASS, "Test file contains hole at offset 0");
+	} else if (TST_RET == -1) {
+		tst_res(TFAIL | TTERRNO, "lseek(SEEK_HOLE) failed");
+	} else {
+		tst_res(TFAIL | TTERRNO,
+			"Unexpected lseek(SEEK_HOLE) return value %ld",
+			TST_RET);
+	}
+
+	TEST(lseek(fd, 0, SEEK_DATA));
+
+	if (TST_RET == holesize) {
+		tst_res(TPASS, "Test file data start at offset %ld", TST_RET);
+	} else if (TST_RET == -1) {
+		tst_res(TFAIL | TTERRNO, "lseek(SEEK_DATA) failed");
+	} else {
+		tst_res(TFAIL | TTERRNO,
+			"Unexpected lseek(SEEK_DATA) return value %ld",
+			TST_RET);
+	}
+
 	SAFE_CLOSE(fd);
 	tst_purge_dir(MNTPOINT);
 }
@@ -145,6 +172,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 42,
 	.needs_root = 1,
 	.mount_device = 1,
 	.mntpoint = MNTPOINT,
diff --git a/testcases/kernel/syscalls/fallocate/fallocate06.c b/testcases/kernel/syscalls/fallocate/fallocate06.c
index 24f98e271..0e1509ace 100644
--- a/testcases/kernel/syscalls/fallocate/fallocate06.c
+++ b/testcases/kernel/syscalls/fallocate/fallocate06.c
@@ -261,7 +261,7 @@ static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(testcase_list),
 	.needs_root = 1,
 	.dev_min_size = 1024,
-	.max_runtime = 120,
+	.timeout = 150,
 	.mount_device = 1,
 	.mntpoint = MNTPOINT,
 	.all_filesystems = 1,
diff --git a/testcases/kernel/syscalls/fanotify/fanotify01.c b/testcases/kernel/syscalls/fanotify/fanotify01.c
index 5d18fe851..c7e759166 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify01.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify01.c
@@ -387,6 +387,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.test = test_fanotify,
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/fanotify/fanotify03.c b/testcases/kernel/syscalls/fanotify/fanotify03.c
index 3ed78e5fa..64c933c19 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify03.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify03.c
@@ -343,6 +343,7 @@ static const char *const resource_files[] = {
 };
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test = test_fanotify,
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/fanotify/fanotify05.c b/testcases/kernel/syscalls/fanotify/fanotify05.c
index 12c240881..435a91c49 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify05.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify05.c
@@ -208,6 +208,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 13,
 	.test = test_fanotify,
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/fanotify/fanotify06.c b/testcases/kernel/syscalls/fanotify/fanotify06.c
index 8779e34d9..b4992afa0 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify06.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify06.c
@@ -236,6 +236,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test = test_fanotify,
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/fanotify/fanotify09.c b/testcases/kernel/syscalls/fanotify/fanotify09.c
index f61c4e45a..45303c31e 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify09.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify09.c
@@ -29,7 +29,6 @@
  *      7372e79c9eb9 fanotify: fix logic of reporting name info with watched parent
  *
  * Test cases #6-#7 are regression tests for commit:
- * (from v5.19, unlikely to be backported thus not in .tags):
  *
  *      e730558adffb fanotify: consistent behavior for parent not watching children
  */
@@ -380,9 +379,9 @@ static void test_fanotify(unsigned int n)
 		return;
 	}
 
-	if (tc->ignore && tst_kvercmp(5, 19, 0) < 0) {
+	if (tc->ignore && tst_kvercmp(5, 10, 0) < 0) {
 		tst_res(TCONF, "ignored mask on parent dir has undefined "
-				"behavior on kernel < 5.19");
+				"behavior on kernel < 5.10");
 		return;
 	}
 
@@ -508,6 +507,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test = test_fanotify,
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
@@ -520,6 +520,7 @@ static struct tst_test test = {
 		{"linux-git", "b469e7e47c8a"},
 		{"linux-git", "55bf882c7f13"},
 		{"linux-git", "7372e79c9eb9"},
+		{"linux-git", "e730558adffb"},
 		{}
 	}
 };
diff --git a/testcases/kernel/syscalls/fanotify/fanotify10.c b/testcases/kernel/syscalls/fanotify/fanotify10.c
index c6d8ec922..23e9554b3 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify10.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify10.c
@@ -515,6 +515,12 @@ static void drop_caches(void)
 	if (syncfs(fd_syncfs) < 0)
 		tst_brk(TBROK | TERRNO, "Unexpected error when syncing filesystem");
 
+	/*
+	 * In order to ensure that the inode can be released in the two-tier
+	 * directory structure, drop_cache is required three times.
+	 */
+	SAFE_FILE_PRINTF(DROP_CACHES_FILE, "3");
+	SAFE_FILE_PRINTF(DROP_CACHES_FILE, "3");
 	SAFE_FILE_PRINTF(DROP_CACHES_FILE, "3");
 }
 
@@ -953,6 +959,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.test = test_fanotify,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test_variants = 2,
diff --git a/testcases/kernel/syscalls/fanotify/fanotify22.c b/testcases/kernel/syscalls/fanotify/fanotify22.c
index a654e8912..d9df35d8c 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify22.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify22.c
@@ -318,9 +318,13 @@ static struct tst_test test = {
 	.mount_device = 1,
 	.mntpoint = MOUNT_PATH,
 	.needs_root = 1,
-	.dev_fs_type = "ext4",
+	.filesystems = (struct tst_fs []){
+		{.type = "ext4"},
+		{}
+	},
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "124e7c61deb2"},
+		{"linux-git", "76486b104168"},
 		{}
 	},
 	.needs_cmds = (const char *[]) {
diff --git a/testcases/kernel/syscalls/fanotify/fanotify23.c b/testcases/kernel/syscalls/fanotify/fanotify23.c
index 35a613fea..957eba19a 100644
--- a/testcases/kernel/syscalls/fanotify/fanotify23.c
+++ b/testcases/kernel/syscalls/fanotify/fanotify23.c
@@ -256,7 +256,10 @@ static struct tst_test test = {
 	.mount_device = 1,
 	.mntpoint = MOUNT_PATH,
 	/* Shrinkers on other fs do not work reliably enough to guarantee mark eviction on drop_caches */
-	.dev_fs_type = "ext2",
+	.filesystems = (struct tst_fs []){
+		{.type = "ext2"},
+		{}
+	},
 };
 
 #else
diff --git a/testcases/kernel/syscalls/fchmod/fchmod01.c b/testcases/kernel/syscalls/fchmod/fchmod01.c
index 05b566791..417ea0a70 100644
--- a/testcases/kernel/syscalls/fchmod/fchmod01.c
+++ b/testcases/kernel/syscalls/fchmod/fchmod01.c
@@ -2,9 +2,12 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
  * Author: Wayne Boyer and William Roske
+ */
+
+/*\
+ * [Description]
  *
- * Test Description:
- * fchmod() will succeed to change the mode permissions of a file specified
+ * Verify that fchmod() can succeed to change the mode permissions of a file specified
  * by file descriptor.
  */
 
diff --git a/testcases/kernel/syscalls/fchmod/fchmod05.c b/testcases/kernel/syscalls/fchmod/fchmod05.c
index 0c731d601..9b29cea20 100644
--- a/testcases/kernel/syscalls/fchmod/fchmod05.c
+++ b/testcases/kernel/syscalls/fchmod/fchmod05.c
@@ -2,18 +2,18 @@
 /*
  * Copyright (c) International Business Machines  Corp., 2001
  * Author: Wayne Boyer
+ */
+
+/*\
+ * [Description]
  *
- * Test Description:
- *  Verify that, fchmod(2) will succeed to change the mode of a directory
- *  but fails to set the setgid bit on it if invoked by non-root (uid != 0)
- *  process with the following constraints,
- *	- the process is the owner of the directory.
- *	- the effective group ID or one of the supplementary group ID's of the
- *	  process is not equal to the group ID of the directory.
+ * Verify that, fchmod(2) will succeed to change the mode of a directory
+ * but fails to set the setgid bit on it if invoked by non-root (uid != 0)
+ * process with the following constraints:
  *
- * Expected Result:
- *  fchmod() should return value 0 on success and though succeeds to change
- *  the mode of a directory but fails to set setgid bit on it.
+ * - The process is the owner of the directory.
+ * - The effective group ID or one of the supplementary group ID's of the
+ *   process is not equal to the group ID of the directory.
  */
 
 #include <pwd.h>
diff --git a/testcases/kernel/syscalls/fchmodat/fchmodat01.c b/testcases/kernel/syscalls/fchmodat/fchmodat01.c
index bf3812738..7ca65648f 100644
--- a/testcases/kernel/syscalls/fchmodat/fchmodat01.c
+++ b/testcases/kernel/syscalls/fchmodat/fchmodat01.c
@@ -60,10 +60,7 @@ static void verify_fchmodat(unsigned int i)
 
 static void setup(void)
 {
-	char *tmpdir_path = tst_get_tmpdir();
-
-	abs_path = tst_aprintf("%s/%s", tmpdir_path, FILEPATH);
-	free(tmpdir_path);
+	abs_path = tst_tmpdir_genpath(FILEPATH);
 
 	SAFE_MKDIR(TESTDIR, 0700);
 	dir_fd = SAFE_OPEN(TESTDIR, O_DIRECTORY);
diff --git a/testcases/kernel/syscalls/fchmodat2/.gitignore b/testcases/kernel/syscalls/fchmodat2/.gitignore
new file mode 100644
index 000000000..9f713198c
--- /dev/null
+++ b/testcases/kernel/syscalls/fchmodat2/.gitignore
@@ -0,0 +1,2 @@
+fchmodat2_01
+fchmodat2_02
diff --git a/testcases/kernel/syscalls/fchmodat2/Makefile b/testcases/kernel/syscalls/fchmodat2/Makefile
new file mode 100644
index 000000000..8cf1b9024
--- /dev/null
+++ b/testcases/kernel/syscalls/fchmodat2/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/fchmodat2/fchmodat2_01.c b/testcases/kernel/syscalls/fchmodat2/fchmodat2_01.c
new file mode 100644
index 000000000..e58be31c4
--- /dev/null
+++ b/testcases/kernel/syscalls/fchmodat2/fchmodat2_01.c
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that fchmodat2() syscall is properly working with
+ * regular files, symbolic links and directories. AT_SYMLINK_NOFOLLOW is a
+ * special feature that is blocked by VFS since 5d1f903f75a8 and any of its
+ * usage on symlinks will raise EOPNOTSUPP.
+ */
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "tst_safe_file_at.h"
+#include "lapi/fcntl.h"
+#include "lapi/stat.h"
+
+#define MNTPOINT "mntpoint"
+#define FNAME "myfile"
+#define SNAME "symlink"
+#define DNAME "mydir"
+#define DNAME_PATH MNTPOINT"/"DNAME
+
+static int fd_dir = -1;
+
+static void verify_mode(int dirfd, const char *path, mode_t mode)
+{
+	struct stat st;
+
+	SAFE_FSTATAT(dirfd, path, &st, AT_SYMLINK_NOFOLLOW);
+	TST_EXP_EQ_LI(st.st_mode, mode);
+}
+
+static void test_regular_file(void)
+{
+	tst_res(TINFO, "Using regular files");
+
+	SAFE_CHMOD(MNTPOINT"/"FNAME, 0640);
+
+	SAFE_FCHMODAT2(fd_dir, FNAME, 0700, 0);
+	verify_mode(fd_dir, FNAME, S_IFREG | 0700);
+
+	SAFE_FCHMODAT2(fd_dir, FNAME, 0700, AT_SYMLINK_NOFOLLOW);
+	verify_mode(fd_dir, FNAME, S_IFREG | 0700);
+}
+
+static void test_symbolic_link(void)
+{
+	tst_res(TINFO, "Using symbolic link");
+
+	SAFE_FCHMODAT2(fd_dir, SNAME, 0700, 0);
+	verify_mode(fd_dir, FNAME, S_IFREG | 0700);
+	verify_mode(fd_dir, SNAME, S_IFLNK | 0777);
+
+	TST_EXP_FAIL(tst_syscall(__NR_fchmodat2,
+		fd_dir, SNAME, 0640, AT_SYMLINK_NOFOLLOW),
+		EOPNOTSUPP);
+}
+
+static void test_empty_folder(void)
+{
+	tst_res(TINFO, "Using empty folder");
+
+	int fd;
+
+	SAFE_CHMOD(DNAME_PATH, 0640);
+	fd = SAFE_OPEN(DNAME_PATH, O_PATH | O_DIRECTORY, 0640);
+
+	SAFE_FCHMODAT2(fd, "", 0777, AT_EMPTY_PATH);
+	verify_mode(fd_dir, DNAME, S_IFDIR | 0777);
+
+	SAFE_CLOSE(fd);
+}
+
+static void run(void)
+{
+	test_regular_file();
+	test_empty_folder();
+	test_symbolic_link();
+}
+
+static void setup(void)
+{
+	fd_dir = SAFE_OPEN(MNTPOINT, O_PATH | O_DIRECTORY, 0640);
+
+	if (access(DNAME_PATH, F_OK) == -1)
+		SAFE_MKDIR(DNAME_PATH, 0640);
+
+	SAFE_TOUCH(MNTPOINT"/"FNAME, 0640, NULL);
+	SAFE_SYMLINKAT(FNAME, fd_dir, SNAME);
+}
+
+static void cleanup(void)
+{
+	SAFE_UNLINKAT(fd_dir, SNAME, 0);
+	SAFE_RMDIR(DNAME_PATH);
+
+	if (fd_dir != -1)
+		SAFE_CLOSE(fd_dir);
+}
+
+static struct tst_test test = {
+	.timeout = 9,
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+	.mntpoint = MNTPOINT,
+	.format_device = 1,
+	.all_filesystems = 1,
+	.tags = (const struct tst_tag[]) {
+		{"linux-git", "5d1f903f75a8"},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/fchmodat2/fchmodat2_02.c b/testcases/kernel/syscalls/fchmodat2/fchmodat2_02.c
new file mode 100644
index 000000000..f8497d8a8
--- /dev/null
+++ b/testcases/kernel/syscalls/fchmodat2/fchmodat2_02.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that fchmodat2() syscall properly raises errors with
+ * invalid values.
+ */
+
+#include "tst_test.h"
+#include "lapi/fcntl.h"
+#include "lapi/syscalls.h"
+#include "tst_tmpdir.h"
+
+#define FILENAME "file.bin"
+
+static char *tmpdir;
+static int fd;
+static int fd_invalid = -1;
+
+static struct tcase {
+	int *fd;
+	char *fname;
+	int mode;
+	int flag;
+	int exp_errno;
+	char *msg;
+} tcases[] = {
+	{&fd_invalid, FILENAME, 0777, 0, EBADF, "bad file descriptor"},
+	{&fd, "doesnt_exist.txt", 0777, 0, ENOENT, "unexisting file"},
+	{&fd, FILENAME, 0777, -1, EINVAL, "invalid flags"},
+};
+
+static void run(unsigned int i)
+{
+	struct tcase *tc = &tcases[i];
+
+	TST_EXP_FAIL(tst_syscall(__NR_fchmodat2,
+		*tc->fd, tc->fname, tc->mode, tc->flag),
+		tc->exp_errno,
+		"Test %s", tc->msg);
+}
+
+static void setup(void)
+{
+	tmpdir = tst_tmpdir_path();
+
+	SAFE_TOUCH(FILENAME, 0640, NULL);
+	fd = SAFE_OPEN(tmpdir, O_PATH | O_DIRECTORY, 0640);
+}
+
+static void cleanup(void)
+{
+	if (fd != -1)
+		SAFE_CLOSE(fd);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+};
+
diff --git a/testcases/kernel/syscalls/fcntl/fcntl14.c b/testcases/kernel/syscalls/fcntl/fcntl14.c
index d38220951..21dbede5c 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl14.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl14.c
@@ -1,1115 +1,281 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *
- *   Copyright (c) International Business Machines  Corp., 2001
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Copyright (c) International Business Machines  Corp., 2001
+ *     07/2001 Ported by Wayne Boyer
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
  */
 
-/*
- * NAME
- *	fcntl14.c
+/*\
+ * [Description]
  *
- * DESCRIPTION
- *	File locking test cases for fcntl. In Linux, S_ENFMT is not implemented
- *	in the kernel. However all standard Unix kernels define S_ENFMT as
- *	S_ISGID. So this test defines S_ENFMT as S_ISGID.
- *
- * ALGORITHM
- *	Various test cases are used to lock a file opened without mandatory
- *	locking, with mandatory locking and mandatory locking with NOBLOCK
- *
- * USAGE
- *	fcntl14
- *
- * HISTORY
- *	07/2001 Ported by Wayne Boyer
- *
- * RESTRICTIONS
- *	None
+ * This test is checking fcntl() syscall locking mechanism between two
+ * processes.
+ * The test sets a random starting position on file using lseek(), it randomly
+ * generates fcntl() parameters for parent and child and it verifies that
+ * fcntl() will raise a blocking error on child when it's supposed to.
  */
-#define _GNU_SOURCE 1
+
 #include <fcntl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <signal.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <inttypes.h>
-#include "test.h"
-#include "safe_macros.h"
+#include <stdlib.h>
+#include "tst_test.h"
 
-#define SKIP 0x0c00
-#if SKIP == F_RDLCK || SKIP== F_WRLCK
-#error invalid value for SKIP, must be distinct from F_RDLCK and F_WRLCK
-#endif
 #ifndef S_ENFMT
-#define S_ENFMT S_ISGID
+# define S_ENFMT S_ISGID
 #endif
 
-/* NOBLOCK - immediate success */
-#define NOBLOCK 2
-
-/* WILLBLOCK - blocks, then succeeds (parent must unlock records) */
-#define WILLBLOCK 3
-
-#define TIME_OUT 60
-
-typedef struct {
-	short a_type;
-	short a_whence;
-	long a_start;
-	long a_len;
-	short b_type;		/* SKIP means suppress fcntl call */
-	short b_whence;
-	long b_start;
-	long b_len;
-	short c_type;
-	int c_whence;
-	long c_start;
-	long c_len;
-	short c_flag;
-} testcase;
-
-static testcase testcases[] = {
-	/* Test cases: entire boundary */
-	/* #1 Parent making a write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock on entire file */
-	 F_RDLCK, 0, 0L, 0L, WILLBLOCK},
-
-	/* #2 Parent making a write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock on entire file */
-	 F_WRLCK, 0, 0L, 0L, WILLBLOCK},
-
-	/* #3 Parent making a read lock on entire file */
-	{F_RDLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock on entire file */
-	 F_RDLCK, 0, 0L, 0L, NOBLOCK},
-
-	/* #4 Parent making a read lock on entire file */
-	{F_RDLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock on entire file */
-	 F_WRLCK, 0, 0L, 0L, WILLBLOCK},
-
-	/* Test case: start boundary */
-	/* #5 Parent making a write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a read lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_RDLCK, 0, 0L, 5L, WILLBLOCK},
-
-	/* #6 Parent making a write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a write lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_WRLCK, 0, 0L, 5L, WILLBLOCK},
-
-	/* #7 Parent making a read lock on entire file */
-	{F_RDLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a read lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_RDLCK, 0, 0L, 5L, NOBLOCK},
-
-	/* #8 Parent making a read lock on entire file */
-	{F_RDLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a write lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_WRLCK, 0, 0L, 5L, WILLBLOCK},
-
-	/* Test cases: end boundary */
-	/* #9 Parent making a write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 7 to end of file */
-	 F_RDLCK, 0, 7L, 0L, WILLBLOCK},
-
-	/* #10 Parent making a write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 7 to end of file */
-	 F_WRLCK, 0, 7L, 0L, WILLBLOCK},
-
-	/* #11 Parent making a read lock on entire file */
-	{F_RDLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 7 to end of file */
-	 F_RDLCK, 0, 7L, 0L, NOBLOCK},
-
-	/* #12 Parent making a read lock on entire file */
-	{F_RDLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 7 to end of file */
-	 F_WRLCK, 0, 7L, 0L, WILLBLOCK},
-
-	/* Test cases: entire boundary ( less than entire file) */
-	/*
-	 * #13 Parent making a write lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a read lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_RDLCK, 0, 0L, 5L, WILLBLOCK},
-
-	/*
-	 * #14 Parent making a write lock from beginning of file
-	 * for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a write lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_WRLCK, 0, 0L, 5L, WILLBLOCK},
-
-	/*
-	 * #15 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a read lock from beginning of
-	  * file for 5 bytes
-	  */
-	 F_RDLCK, 0, 0L, 5L, NOBLOCK},
-
-	/*
-	 * #16 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /*
-	  * Child attempting a write lock from beginning
-	  * of file for 5 bytes
-	  */
-	 F_WRLCK, 0, 0L, 5L, WILLBLOCK},
-
-	/* Test cases: inside boundary */
-	/*
-	 * #17 Parent making a write lock from beginning
-	 * of file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 2 to byte 4 */
-	 F_RDLCK, 0, 1L, 3L, WILLBLOCK},
-
-	/*
-	 * #18 Parent making a write lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 2 to byte 4 */
-	 F_WRLCK, 0, 1L, 3L, WILLBLOCK},
-
-	/*
-	 * #19 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 2 to byte 4 */
-	 F_RDLCK, 0, 1L, 3L, NOBLOCK},
-
-	/*
-	 * #20 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 2 to byte 4 */
-	 F_WRLCK, 0, 1L, 3L, WILLBLOCK},
-
-	/* Test cases: cross boundary (inside to after) */
-	/*
-	 * #21 Parent making a write lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 3 to byte 7 */
-	 F_RDLCK, 0, 2L, 5L, WILLBLOCK},
-
-	/*
-	 * #22 Parent making a write lock from beginning
-	 * of file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 3 to byte 7 */
-	 F_WRLCK, 0, 2L, 5L, WILLBLOCK},
-
-	/*
-	 * #23 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 3 to byte 7 */
-	 F_RDLCK, 0, 2L, 5L, NOBLOCK},
-
-	/*
-	 * #24 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 3 to byte 7 */
-	 F_WRLCK, 0, 2L, 5L, WILLBLOCK},
-
-	/* Test cases: outside boundary (after) */
-
-	/*
-	 * #25 Parent making a write lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /*  Child attempting a read lock from byte 7 to end of file */
-	 F_RDLCK, 0, 6L, 0L, NOBLOCK},
-
-	/*
-	 * #26 Parent making a write lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_WRLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 7 to end of file */
-	 F_WRLCK, 0, 6L, 0L, NOBLOCK},
-
-	/*
-	 * #27 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 7 to end of file */
-	 F_RDLCK, 0, 6L, 0L, NOBLOCK},
-
-	/*
-	 * #28 Parent making a read lock from beginning of
-	 * file for 5 bytes
-	 */
-	{F_RDLCK, 0, 0L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 7 to end of file */
-	 F_WRLCK, 0, 6L, 0L, NOBLOCK},
-
-	/* Test cases: outside boundary (before) */
-
-	/* #29 Parent making a write lock from byte 3 to byte 7 */
-	{F_WRLCK, 0, 2L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from beginning of file to byte 2 */
-	 F_RDLCK, 0, 0L, 2L, NOBLOCK},
-
-	/* #30 Parent making a write lock from byte 3 to byte 7 */
-	{F_WRLCK, 0, 2L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from beginning of file to byte 2 */
-	 F_WRLCK, 0, 0L, 2L, NOBLOCK},
-
-	/* #31 Parent making a write lock from byte 3 to byte 7 */
-	{F_RDLCK, 0, 2L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from beginning of file to byte 2 */
-	 F_RDLCK, 0, 0L, 2L, NOBLOCK},
-
-	/* #32 Parent making a write lock from byte 3 to byte 7 */
-	{F_RDLCK, 0, 2L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from beginning of file to byte 2 */
-	 F_WRLCK, 0, 0L, 2L, NOBLOCK},
-
-	/* Test cases: cross boundary (before to inside) */
-	/* #33 Parent making a write lock from byte 5 to end of file */
-	{F_WRLCK, 0, 4L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 3 to byte 7 */
-	 F_RDLCK, 0, 2L, 5L, WILLBLOCK},
-
-	/* #34 Parent making a write lock from byte 5 to end of file */
-	{F_WRLCK, 0, 4L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 3 to byte 7 */
-	 F_WRLCK, 0, 2L, 5L, WILLBLOCK},
-
-	/* #35 Parent making a read lock from byte 5 to end of file */
-	{F_RDLCK, 0, 4L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a read lock from byte 3 to byte 7 */
-	 F_RDLCK, 0, 2L, 5L, NOBLOCK},
-
-	/* #36 Parent making a read lock from byte 5 to end of file */
-	{F_RDLCK, 0, 4L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting a write lock from byte 3 to byte 7 */
-	 F_WRLCK, 0, 2L, 5L, WILLBLOCK},
-
-	/* Start of negative L_start and L_len test cases */
-	/*
-	 * #37 Parent making write lock from byte 2 to byte 3
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 1 */
-	 F_WRLCK, 0, 1L, 1L, NOBLOCK},
-
-	/*
-	 * #38 Parent making write lock from byte 2 to byte 3
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 4 */
-	 F_WRLCK, 0, 4L, 1L, NOBLOCK},
-
-	/*
-	 * #39 Parent making write lock from byte 2 to byte 3
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 2 */
-	 F_WRLCK, 0, 2L, 1L, WILLBLOCK},
+#define CHECK_FAILURE(VAL_A, VAL_B) do { \
+	TST_EXP_EQ_LI_SILENT(VAL_A, VAL_B); \
+	if (!TST_PASS) \
+		results->last_failed = 1; \
+} while (0)
+
+struct file_conf {
+	short type;
+	short whence;
+	long start;
+	long len;
+};
 
-	/*
-	 * #40 Parent making write lock from byte 2 to byte 3
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 3 */
-	 F_WRLCK, 0, 3L, 1L, WILLBLOCK},
+struct testcase {
+	struct flock flock;
+	struct file_conf parent;           /* parent parameters for fcntl() */
+	struct file_conf child;            /* child parameters for fcntl() */
+	short blocking;                    /* blocking/non-blocking flag */
+	long pos;                          /* starting file position */
+};
 
-	/*
-	 * #41 Parent making write lock from byte 2 to byte 6
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 1 */
-	 F_WRLCK, 0, 1L, 1L, NOBLOCK},
+struct tc_results {
+	int num_pass;
+	int last_failed;
+};
 
-	/*
-	 * #42 Parent making write lock from byte 2 to byte 6
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 7 */
-	 F_WRLCK, 0, 1L, 1L, NOBLOCK},
+static const char filepath[] = "unlocked.txt";
+static const char filedata[] = "Here some bytes!";
+static char *str_op_nums;
+static int op_nums = 5000;
+static int file_mode = 0777;
+static struct tc_results *results;
 
-	/*
-	 * #43 Parent making write lock from byte 2 to byte 6
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 2 */
-	 F_WRLCK, 0, 2L, 1L, WILLBLOCK},
+static void dochild(struct testcase *tc, const int fd, const pid_t parent_pid)
+{
+	struct flock flock = tc->flock;
 
-	/*
-	 * #44 Parent making write lock from byte 2 to byte 6
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 5 */
-	 F_WRLCK, 0, 5L, 1L, WILLBLOCK},
+	results->last_failed = 0;
 
-	/*
-	 * #45 Parent making write lock from byte 2 to byte 6
-	 * with L_start = -3
-	 */
-	{F_WRLCK, 1, -3L, 5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 6 */
-	 F_WRLCK, 0, 6L, 1L, WILLBLOCK},
+	flock.l_type = tc->child.type;
+	flock.l_whence = tc->child.whence;
+	flock.l_start = tc->child.start;
+	flock.l_len = tc->child.len;
+	flock.l_pid = 0;
 
-	/*
-	 * #46 Parent making write lock from byte 2 to byte 3 with
-	 * L_start = -2 and L_len = -2
-	 */
-	{F_WRLCK, 1, 2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 1 */
-	 F_WRLCK, 0, 1L, 1L, NOBLOCK},
+	SAFE_FCNTL(fd, F_GETLK, &flock);
 
-	/*
-	 * #47 Parent making write lock from byte 2 to byte 3 with
-	 * L_start = -2 and L_len = -2
-	 */
-	{F_WRLCK, 1, -2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 4 */
-	 F_WRLCK, 0, 4L, 1L, NOBLOCK},
+	if (tc->blocking) {
+		tst_res(TDEBUG, "Child: expecting blocked file by parent");
 
-	/*
-	 * #48 Parent making write lock from byte 2 to byte 3 with
-	 * L_start = -2 and L_len = -2
-	 */
-	{F_WRLCK, 1, -2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 2 */
-	 F_WRLCK, 0, 2L, 1L, WILLBLOCK},
+		CHECK_FAILURE(flock.l_pid, parent_pid);
+		CHECK_FAILURE(flock.l_type, tc->parent.type);
 
-	/*
-	 * #49 Parent making write lock from byte 2 to byte 3 with
-	 * L_start = -2 and L_len = -2
-	 */
-	{F_WRLCK, 1, -2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 3 */
-	 F_WRLCK, 0, 3L, 1L, WILLBLOCK},
+		flock.l_type = tc->child.type;
+		flock.l_whence = tc->child.whence;
+		flock.l_start = tc->child.start;
+		flock.l_len = tc->child.len;
+		flock.l_pid = 0;
 
-	/*
-	 * #50 Parent making write lock from byte 6 to byte 7 with
-	 * L_start = 2 and L_len = -2
-	 */
-	{F_WRLCK, 1, 2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 5 */
-	 F_WRLCK, 0, 5L, 1L, NOBLOCK},
+		TST_EXP_FAIL_SILENT(fcntl(fd, F_SETLK, &flock), EWOULDBLOCK);
+	} else {
+		tst_res(TDEBUG, "Child: expecting no blocking errors");
 
-	/*
-	 * #51 Parent making write lock from byte 6 to byte 7 with
-	 * L_start = 2 and L_len = -2
-	 */
-	{F_WRLCK, 1, 2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 8 */
-	 F_WRLCK, 0, 8L, 1L, NOBLOCK},
+		CHECK_FAILURE(flock.l_type, F_UNLCK);
+		CHECK_FAILURE(flock.l_whence, tc->child.whence);
+		CHECK_FAILURE(flock.l_start, tc->child.start);
+		CHECK_FAILURE(flock.l_len, tc->child.len);
+		CHECK_FAILURE(flock.l_pid, 0);
 
-	/*
-	 * #52 Parent making write lock from byte 6 to byte 7 with
-	 * L_start = 2 and L_len = -2
-	 */
-	{F_WRLCK, 1, 2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 6 */
-	 F_WRLCK, 0, 6L, 1L, WILLBLOCK},
+		TST_EXP_PASS_SILENT(fcntl(fd, F_SETLK, &flock));
+	}
+}
 
-	/*
-	 * #53 Parent making write lock from byte 6 to byte 7 with
-	 * L_start = 2 and L_len = -2
-	 */
-	{F_WRLCK, 1, 2L, -2L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 7 */
-	 F_WRLCK, 0, 7L, 1L, WILLBLOCK},
+static void run_testcase(struct testcase *tc, const int file_mode)
+{
+	struct flock flock = tc->flock;
+	pid_t parent_pid;
+	pid_t child_pid;
+	int fd;
+
+	tst_res(TDEBUG, "Parent: locking file");
+
+	/* open file and move cursor according with the test */
+	fd = SAFE_OPEN(filepath, O_RDWR, file_mode);
+	SAFE_LSEEK(fd, tc->pos, 0);
+
+	/* set the initial parent lock on the file */
+	flock.l_type = tc->parent.type;
+	flock.l_whence = tc->parent.whence;
+	flock.l_start = tc->parent.start;
+	flock.l_len = tc->parent.len;
+	flock.l_pid = 0;
 
-	/*
-	 * #54 Parent making write lock from byte 3 to byte 7 with
-	 * L_start = 2 and L_len = -5
-	 */
-	{F_WRLCK, 1, 2L, -5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 2 */
-	 F_WRLCK, 0, 2L, 1L, NOBLOCK},
+	SAFE_FCNTL(fd, F_SETLK, &flock);
 
-	/*
-	 * #55 Parent making write lock from byte 3 to byte 7 with
-	 * L_start = 2 and L_len = -5
-	 */
-	{F_WRLCK, 1, 2L, -5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 8 */
-	 F_WRLCK, 0, 8L, 1L, NOBLOCK},
+	/* set the child lock on the file */
+	parent_pid = getpid();
+	child_pid = SAFE_FORK();
 
-	/*
-	 * #56 Parent making write lock from byte 3 to byte 7 with
-	 * L_start = 2 and L_len = -5
-	 */
-	{F_WRLCK, 1, 2L, -5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 3 */
-	 F_WRLCK, 0, 3L, 1L, WILLBLOCK},
+	if (!child_pid) {
+		dochild(tc, fd, parent_pid);
+		exit(0);
+	}
 
-	/*
-	 * #57 Parent making write lock from byte 3 to byte 7 with
-	 * L_start = 2 and L_len = -5
-	 */
-	{F_WRLCK, 1, 2L, -5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 5 */
-	 F_WRLCK, 0, 5L, 1L, WILLBLOCK},
+	tst_reap_children();
 
-	/*
-	 * #58 Parent making write lock from byte 3 to byte 7 with
-	 * L_start = 2 and L_len = -5
-	 */
-	{F_WRLCK, 1, 2L, -5L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 7 */
-	 F_WRLCK, 0, 7L, 1L, WILLBLOCK},
+	flock.l_type = F_UNLCK;
+	flock.l_whence = 0;
+	flock.l_start = 0;
+	flock.l_len = 0;
+	flock.l_pid = 0;
 
-	/* Test case for block 4 */
-	/* #59 Parent making write lock on entire file */
-	{F_WRLCK, 0, 0L, 0L, SKIP, 0, 0L, 0L,
-	 /* Child attempting write lock on byte 15 to end of file */
-	 F_WRLCK, 0, 15L, 0L, WILLBLOCK},
-};
+	SAFE_CLOSE(fd);
+}
 
-static testcase *thiscase;
-static struct flock flock;
-static int parent, child, status, fail = 0;
-static int got1 = 0;
-static int fd;
-static int test;
-static char tmpname[40];
+static void genconf(struct file_conf *conf, const int size, const long pos)
+{
+	conf->type = rand() % 2 ? F_RDLCK : F_WRLCK;
+	conf->whence = SEEK_CUR;
+	conf->start = rand() % (size - 1);
+	conf->len = rand() % (size - conf->start - 1) + 1;
+	conf->start -= pos;
+}
 
-#define FILEDATA	"ten bytes!"
+static short fcntl_overlap(
+	struct file_conf *parent,
+	struct file_conf *child)
+{
+	short overlap;
 
-void catch1(int sig);
-void catch_alarm(int sig);
+	if (child->start < parent->start)
+		overlap = parent->start < (child->start + child->len);
+	else
+		overlap = child->start < (parent->start + parent->len);
 
-char *TCID = "fcntl14";
-int TST_TOTAL = 1;
-int NO_NFS = 1;
+	if (overlap)
+		tst_res(TDEBUG, "child/parent fcntl() configurations overlap");
 
-void cleanup(void)
-{
-	tst_rmdir();
+	return overlap;
 }
 
-void setup(void)
+static void gentestcase(struct testcase *tc)
 {
-	struct sigaction act;
+	struct file_conf *parent = &tc->parent;
+	struct file_conf *child = &tc->child;
+	int size;
 
-	tst_sig(FORK, DEF_HANDLER, cleanup);
-	signal(SIGHUP, SIG_IGN);
-	umask(0);
-	TEST_PAUSE;
-	tst_tmpdir();
-	parent = getpid();
+	memset(&tc->flock, 0, sizeof(struct flock));
 
-	sprintf(tmpname, "fcntl2.%d", parent);
+	size = strlen(filedata);
+	tc->pos = rand() % size;
 
-	/* setup signal handler for signal from child */
-	memset(&act, 0, sizeof(act));
-	act.sa_handler = catch1;
-	sigemptyset(&act.sa_mask);
-	sigaddset(&act.sa_mask, SIGUSR1);
-	if ((sigaction(SIGUSR1, &act, NULL)) < 0) {
-		tst_resm(TFAIL, "SIGUSR1 signal setup failed, errno = %d",
-			 errno);
-		cleanup();
-	}
+	genconf(parent, size, tc->pos);
+	genconf(child, size, tc->pos);
 
-	memset(&act, 0, sizeof(act));
-	act.sa_handler = catch_alarm;
-	sigemptyset(&act.sa_mask);
-	sigaddset(&act.sa_mask, SIGALRM);
-	if ((sigaction(SIGALRM, &act, NULL)) < 0) {
-		tst_resm(TFAIL, "SIGALRM signal setup failed");
-		cleanup();
-	}
-}
+	tc->blocking = fcntl_overlap(parent, child);
 
-void wake_parent(void)
-{
-	if ((kill(parent, SIGUSR1)) < 0) {
-		tst_resm(TFAIL, "Attempt to send signal to parent " "failed");
-		tst_resm(TFAIL, "Test case %d, errno = %d", test + 1, errno);
-		fail = 1;
-	}
+	if (parent->type == F_RDLCK && child->type == F_RDLCK)
+		tc->blocking = 0;
 }
 
-void do_usleep_child(void)
+static void print_testcase(struct testcase *tc)
 {
-	usleep(100000);		/* XXX how long is long enough? */
-	wake_parent();
-	exit(0);
+	tst_res(TDEBUG, "Starting read/write position: %ld", tc->pos);
+
+	tst_res(TDEBUG,
+		"Parent: type=%s whence=%s start=%ld len=%ld",
+		tc->parent.type == F_RDLCK ? "F_RDLCK" : "F_WRLCK",
+		tc->parent.whence == SEEK_SET ? "SEEK_SET" : "SEEK_CUR",
+		tc->parent.start,
+		tc->parent.len);
+
+	tst_res(TDEBUG,
+		"Child: type=%s whence=%s start=%ld len=%ld",
+		tc->child.type == F_RDLCK ? "F_RDLCK" : "F_WRLCK",
+		tc->child.whence == SEEK_SET ? "SEEK_SET" : "SEEK_CUR",
+		tc->child.start,
+		tc->child.len);
+
+	tst_res(TDEBUG, "Expencted %s test",
+		tc->blocking ? "blocking" : "non-blocking");
 }
 
-void dochild(void)
+static void run(void)
 {
-	int rc;
-	pid_t pid;
-
-	flock.l_type = thiscase->c_type;
-	flock.l_whence = thiscase->c_whence;
-	flock.l_start = thiscase->c_start;
-	flock.l_len = thiscase->c_len;
-	flock.l_pid = 0;
-	fail = 0;
-
-	/*
-	 * Check to see if child lock will succeed. If it will, FLOCK
-	 * structure will return with l_type changed to F_UNLCK. If it will
-	 * not, the parent pid will be returned in l_pid and the type of
-	 * lock that will block it in l_type.
-	 */
-	if ((rc = fcntl(fd, F_GETLK, &flock)) < 0) {
-		tst_resm(TFAIL, "Attempt to check lock status failed");
-		tst_resm(TFAIL, "Test case %d, errno = %d", test + 1, errno);
-		fail = 1;
-	} else {
-
-		if ((thiscase->c_flag) == NOBLOCK) {
-			if (flock.l_type != F_UNLCK) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: type = %d, "
-					 "%d was expected", test + 1,
-					 flock.l_type, F_UNLCK);
-				fail = 1;
-			}
+	struct testcase tc;
 
-			if (flock.l_whence != thiscase->c_whence) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: whence = %d, "
-					 "should have remained %d", test + 1,
-					 flock.l_whence, thiscase->c_whence);
-				fail = 1;
-			}
+	results->num_pass = 0;
 
-			if (flock.l_start != thiscase->c_start) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: start = %" PRId64
-					 ", " "should have remained %" PRId64,
-					 test + 1, (int64_t) flock.l_start,
-					 (int64_t) thiscase->c_start);
-				fail = 1;
-			}
+	for (int i = 0; i < op_nums; i++) {
+		gentestcase(&tc);
+		print_testcase(&tc);
 
-			if (flock.l_len != thiscase->c_len) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: len = %" PRId64
-					 ", " "should have remained %" PRId64,
-					 test + 1, (int64_t) flock.l_len,
-					 (int64_t) thiscase->c_len);
-				fail = 1;
-			}
+		tst_res(TDEBUG, "Running test #%u", i);
+		run_testcase(&tc, file_mode);
 
-			if (flock.l_pid != 0) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: pid = %d, "
-					 "should have remained 0", test + 1,
-					 flock.l_pid);
-				fail = 1;
-			}
-		} else {
-			if (flock.l_pid != parent) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: pid = %d, "
-					 "should be parent's id of %d",
-					 test + 1, flock.l_pid, parent);
-				fail = 1;
-			}
+		if (results->last_failed)
+			return;
 
-			if (flock.l_type != thiscase->a_type) {
-				tst_resm(TFAIL,
-					 "Test case %d, GETLK: type = %d, "
-					 "should be parent's first lock type of %d",
-					 test + 1, flock.l_type,
-					 thiscase->a_type);
-				fail = 1;
-			}
-		}
+		results->num_pass++;
 	}
 
-	/*
-	 * now try to set the lock, nonblocking
-	 * This will succeed for NOBLOCK,
-	 * fail for WILLBLOCK
-	 */
-	flock.l_type = thiscase->c_type;
-	flock.l_whence = thiscase->c_whence;
-	flock.l_start = thiscase->c_start;
-	flock.l_len = thiscase->c_len;
-	flock.l_pid = 0;
-
-	if ((rc = fcntl(fd, F_SETLK, &flock)) < 0) {
-		if ((thiscase->c_flag) == NOBLOCK) {
-			tst_resm(TFAIL, "Attempt to set child NONBLOCKING "
-				 "lock failed");
-			tst_resm(TFAIL, "Test case %d, errno = %d",
-				 test + 1, errno);
-			fail = 1;
-		}
-	}
-
-	if ((thiscase->c_flag) == WILLBLOCK) {
-		if (rc != -1 || (errno != EACCES && errno != EAGAIN)) {
-			tst_resm(TFAIL,
-				 "SETLK: rc = %d, errno = %d, -1/EAGAIN or EACCES "
-				 "was expected", rc, errno);
-			fail = 1;
-		}
-		if (rc == 0) {
-			/* accidentally got the lock */
-			/* XXX how to clean up? */
-			(void)fcntl(fd, F_UNLCK, &flock);
-		}
-		/*
-		 * Lock should succeed after blocking and parent releases
-		 * lock, tell the parent to release the locks.
-		 * Do the lock in this process, send the signal in a child
-		 * process, so that the SETLKW actually uses the blocking
-		 * mechanism in the kernel.
-		 *
-		 * XXX inherent race: we want to wait until the
-		 * F_SETLKW has started, but we don't have a way to
-		 * check that reliably in the child.  (We'd
-		 * need some way to have fcntl() atomically unblock a
-		 * signal and wait for the lock.)
-		 */
-		pid = tst_fork();
-		switch (pid) {
-		case -1:
-			tst_resm(TFAIL, "Fork failed");
-			fail = 1;
-			break;
-		case 0:
-			do_usleep_child();
-			break;
-
-		default:
-			if ((rc = fcntl(fd, F_SETLKW, &flock)) < 0) {
-				tst_resm(TFAIL, "Attempt to set child BLOCKING "
-					 "lock failed");
-				tst_resm(TFAIL, "Test case %d, errno = %d",
-					 test + 1, errno);
-				fail = 1;
-			}
-			waitpid(pid, &status, 0);
-			break;
-		}
-	}
-	if (fail) {
-		exit(1);
-	} else {
-		exit(0);
-	}
+	if (results->num_pass == op_nums)
+		tst_res(TPASS, "All %d test file operations passed", op_nums);
 }
 
-void run_test(int file_flag, int file_mode, int seek, int start, int end)
+static void setup(void)
 {
-	fail = 0;
+	int fd;
 
-	for (test = start; test < end; test++) {
-		fd = SAFE_OPEN(cleanup, tmpname, file_flag, file_mode);
+	if (tst_parse_int(str_op_nums, &op_nums, 1, INT_MAX))
+		tst_brk(TBROK, "Invalid number of operations '%s'", str_op_nums);
 
-		if (write(fd, FILEDATA, 10) < 0)
-			tst_brkm(TBROK, cleanup, "write() failed");
+	if (tst_variant == 1) {
+		tst_res(TINFO, "Requested mandatory locking");
 
-		if (seek) {
-			SAFE_LSEEK(cleanup, fd, seek, 0);
-		}
-
-		thiscase = &testcases[test];
-		flock.l_type = thiscase->a_type;
-		flock.l_whence = thiscase->a_whence;
-		flock.l_start = thiscase->a_start;
-		flock.l_len = thiscase->a_len;
-
-		/* set the initial parent lock on the file */
-		if ((fcntl(fd, F_SETLK, &flock)) < 0) {
-			tst_resm(TFAIL, "First parent lock failed");
-			tst_resm(TFAIL, "Test case %d, errno = %d",
-				 test + 1, errno);
-			fail = 1;
-		}
-
-		if ((thiscase->b_type) != SKIP) {
-			flock.l_type = thiscase->b_type;
-			flock.l_whence = thiscase->b_whence;
-			flock.l_start = thiscase->b_start;
-			flock.l_len = thiscase->b_len;
-
-			/* set the second parent lock */
-			if ((fcntl(fd, F_SETLK, &flock)) < 0) {
-				tst_resm(TFAIL, "Second parent lock failed");
-				tst_resm(TFAIL, "Test case %d, errno = %d",
-					 test + 1, errno);
-				fail = 1;
-			}
-		}
-		if ((thiscase->c_type) == SKIP) {
-			close(fd);
-			tst_resm(TINFO, "skipping test %d", test + 1);
-			continue;
-		}
-
-		/* Mask SIG_USR1 before forking child, to avoid race */
-		(void)sighold(SIGUSR1);
-
-		/* flush the stdout to avoid garbled output */
-		fflush(stdout);
-
-		if ((child = tst_fork()) == 0)
-			dochild();
-
-		if (child < 0)
-			tst_brkm(TBROK|TERRNO, cleanup, "Fork failed");
-
-		if ((thiscase->c_flag) == WILLBLOCK) {
-			/*
-			 * Wait for a signal from the child then remove
-			 * blocking lock. Set a 60 second alarm to break the
-			 * pause just in case the child never signals us.
-			 */
-			alarm(TIME_OUT);
-			sigpause(SIGUSR1);
-
-			/* turn off the alarm timer */
-			alarm((unsigned)0);
-			if (got1 != 1)
-				tst_resm(TINFO, "Pause terminated without "
-					 "signal SIGUSR1 from child");
-			got1 = 0;
-
-			/*
-			 * setup lock structure for parent to delete
-			 * blocking lock then wait for child to exit
-			 */
-			flock.l_type = F_UNLCK;
-			flock.l_whence = 0;
-			flock.l_start = 0L;
-			flock.l_len = 0L;
-			if ((fcntl(fd, F_SETLK, &flock)) < 0) {
-				tst_resm(TFAIL, "Attempt to release parent "
-					 "lock failed");
-				tst_resm(TFAIL, "Test case %d, errno = %d",
-					 test + 1, errno);
-				fail = 1;
-			}
-		}
-		/*
-		 * set a 60 second alarm to break the wait just in case the
-		 * child doesn't terminate on its own accord
-		 */
-		alarm(TIME_OUT);
-
-		/* wait for the child to terminate and close the file */
-		waitpid(child, &status, 0);
-		/* turn off the alarm clock */
-		alarm((unsigned)0);
-		if (status != 0) {
-			tst_resm(TFAIL, "tchild returned status 0x%x", status);
-			fail = 1;
-		}
-		close(fd);
-		if (fail)
-			tst_resm(TFAIL, "testcase:%d FAILED", test + 1);
-		else
-			tst_resm(TPASS, "testcase:%d PASSED", test + 1);
+		file_mode = S_ENFMT | 0600;
 	}
-	unlink(tmpname);
-}
 
-void catch_alarm(int sig)
-{
-	/*
-	 * Timer has runout and child has not signaled, need
-	 * to kill off the child as it appears it will not
-	 * on its own accord. Check that it is still around
-	 * as it may have terminated abnormally while parent
-	 * was waiting for SIGUSR1 signal from it.
-	 */
-	if (kill(child, 0) == 0) {
-		kill(child, SIGKILL);
-		perror("The child didnot terminate on its own accord");
-	}
-}
+	fd = SAFE_OPEN(filepath, O_CREAT | O_RDWR | O_TRUNC, 0777);
+	SAFE_WRITE(SAFE_WRITE_ALL, fd, filedata, strlen(filedata));
+	SAFE_CLOSE(fd);
 
-void catch1(int sig)
-{
-	struct sigaction act;
+	srand(time(0));
 
-	/*
-	 * Set flag to let parent know that child is ready to have lock
-	 * removed
-	 */
-	memset(&act, 0, sizeof(act));
-	act.sa_handler = catch1;
-	sigemptyset(&act.sa_mask);
-	sigaddset(&act.sa_mask, SIGUSR1);
-	sigaction(SIGUSR1, &act, NULL);
-	got1++;
+	results = SAFE_MMAP(
+		NULL,
+		sizeof(struct tc_results),
+	    PROT_READ | PROT_WRITE,
+		MAP_ANONYMOUS | MAP_SHARED,
+		-1, 0);
 }
 
-static void testcheck_end(int check_fail, char *msg)
+static void cleanup(void)
 {
-	if (check_fail)
-		tst_resm(TFAIL, "%s FAILED", msg);
-	else
-		tst_resm(TPASS, "%s PASSED", msg);
+	if (results)
+		SAFE_MUNMAP(results, sizeof(struct tc_results));
 }
 
-int main(int ac, char **av)
-{
-	int lc;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC)
-		NO_NFS = 0;
-
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		tst_count = 0;
-
-/* //block1: */
-		tst_resm(TINFO, "Enter block 1: without mandatory locking");
-		fail = 0;
-		/*
-		 * try various file locks on an ordinary file without
-		 * mandatory locking
-		 */
-		(void)run_test(O_CREAT | O_RDWR | O_TRUNC, 0777, 0, 0, 36);
-		testcheck_end(fail, "Block 1, test 1");
-
-		/* Now try with negative values for L_start and L_len */
-		(void)run_test(O_CREAT | O_RDWR | O_TRUNC, 0777, 5, 36, 45);
-		testcheck_end(fail, "Block 1, test 2");
-
-		tst_resm(TINFO, "Exit block 1");
-
-/* //block2: */
-		/*
-		 * Skip block2 if test on NFS, since NFS does not support
-		 * mandatory locking
-		 */
-		tst_resm(TINFO, "Enter block 2: with mandatory locking");
-		if (NO_NFS) {
-			fail = 0;
-			/*
-			 * Try various locks on a file with mandatory
-			 * record locking this should behave the same
-			 * as an ordinary file
-			 */
-			(void)run_test(O_CREAT | O_RDWR | O_TRUNC,
-				S_ENFMT | S_IRUSR | S_IWUSR, 0, 0, 36);
-			testcheck_end(fail, "Block 2, test 1");
-
-			/* Now try negative values for L_start and L_len */
-			(void)run_test(O_CREAT | O_RDWR | O_TRUNC,
-				S_ENFMT | S_IRUSR | S_IWUSR, 5, 36, 45);
-			testcheck_end(fail, "Block 2, test 2");
-		} else {
-			tst_resm(TCONF, "Skip block 2 as NFS does not"
-				" support mandatory locking");
-		}
-
-		tst_resm(TINFO, "Exit block 2");
-
-/* //block3: */
-		tst_resm(TINFO, "Enter block 3");
-		fail = 0;
-		/*
-		 * Check that proper error status is returned when invalid
-		 * argument used for WHENCE (negative value)
-		 */
-
-		fd = SAFE_OPEN(cleanup, tmpname, O_CREAT | O_RDWR | O_TRUNC,
-			       0777);
-
-		if (write(fd, FILEDATA, 10) < 0)
-			tst_brkm(TBROK, cleanup, "write failed");
-
-		flock.l_type = F_WRLCK;
-		flock.l_whence = -1;
-		flock.l_start = 0L;
-		flock.l_len = 0L;
-
-		if ((fcntl(fd, F_SETLK, &flock)) < 0) {
-			if (errno != EINVAL) {
-				tst_resm(TFAIL, "Expected %d got %d",
-					 EINVAL, errno);
-				fail = 1;
-			}
-		} else {
-			tst_resm(TFAIL, "Lock succeeded when it should have "
-				 "failed");
-			fail = 1;
-		}
-
-		close(fd);
-		unlink(tmpname);
-
-		testcheck_end(fail, "Test with negative whence locking");
-		tst_resm(TINFO, "Exit block 3");
-
-/* //block4: */
-		tst_resm(TINFO, "Enter block 4");
-		fail = 0;
-		/*
-		 * Check that a lock on end of file is still valid when
-		 * additional data is appended to end of file and a new
-		 * process attempts to lock new data
-		 */
-		fd = SAFE_OPEN(cleanup, tmpname, O_CREAT | O_RDWR | O_TRUNC,
-			       0777);
-
-		if (write(fd, FILEDATA, 10) < 0)
-			tst_brkm(TBROK, cleanup, "write failed");
-
-		thiscase = &testcases[58];
-		flock.l_type = thiscase->a_type;
-		flock.l_whence = thiscase->a_whence;
-		flock.l_start = thiscase->a_start;
-		flock.l_len = thiscase->a_len;
-
-		/* Set the initial parent lock on the file */
-		if ((fcntl(fd, F_SETLK, &flock)) < 0) {
-			tst_resm(TFAIL, "First parent lock failed");
-			tst_resm(TFAIL, "Test case %d, errno = %d", 58, errno);
-			fail = 1;
-		}
-
-		/* Write some additional data to end of file */
-		if (write(fd, FILEDATA, 10) < 0)
-			tst_brkm(TBROK, cleanup, "write failed");
-
-		/* Mask signal to avoid race */
-		if (sighold(SIGUSR1) < 0)
-			tst_brkm(TBROK, cleanup, "sighold failed");
-
-		if ((child = tst_fork()) == 0)
-			dochild();
-
-		if (child < 0)
-			tst_brkm(TBROK|TERRNO, cleanup, "Fork failed");
-
-		/*
-		 * Wait for a signal from the child then remove blocking lock.
-		 * Set a 60 sec alarm to break the pause just in case the
-		 * child doesn't terminate on its own accord
-		 */
-		(void)alarm(TIME_OUT);
-
-		(void)sigpause(SIGUSR1);
-
-		/* turn off the alarm timer */
-		(void)alarm((unsigned)0);
-		if (got1 != 1) {
-			tst_resm(TINFO, "Pause terminated without signal "
-				 "SIGUSR1 from child");
-		}
-		got1 = 0;
-
-		/*
-		 * Set up lock structure for parent to delete
-		 * blocking lock then wait for child to exit
-		 */
-		flock.l_type = F_UNLCK;
-		flock.l_whence = 0;
-		flock.l_start = 0L;
-		flock.l_len = 0L;
-		if ((fcntl(fd, F_SETLK, &flock)) < 0) {
-			tst_resm(TFAIL, "Attempt to release parent lock "
-				 "failed");
-			tst_resm(TFAIL, "Test case %d, errno = %d", test + 1,
-				 errno);
-			fail = 1;
-		}
-
-		/*
-		 * set a 60 sec alarm to break the wait just in case the
-		 * child doesn't terminate on its own accord
-		 */
-		(void)alarm(TIME_OUT);
-
-		waitpid(child, &status, 0);
-		if (WEXITSTATUS(status) != 0) {
-			fail = 1;
-			tst_resm(TFAIL, "child returned bad exit status");
-		}
-
-		/* turn off the alarm clock */
-		(void)alarm((unsigned)0);
-		if (status != 0) {
-			tst_resm(TFAIL, "child returned status 0x%x", status);
-			fail = 1;
-		}
-		close(fd);
-		unlink(tmpname);
-
-		testcheck_end(fail, "Test of locks on file");
-		tst_resm(TINFO, "Exit block 4");
-	}
-	cleanup();
-	tst_exit();
-}
+static struct tst_test test = {
+	.timeout = 8,
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.test_variants = 2,
+	.forks_child = 1,
+	.needs_tmpdir = 1,
+	.options = (struct tst_option[]) {
+		{ "n:", &str_op_nums, "Total # operations to do (default 5000)" },
+		{},
+	},
+	.skip_filesystems = (const char *const []) {
+		"nfs",
+		NULL
+	},
+};
diff --git a/testcases/kernel/syscalls/fcntl/fcntl34.c b/testcases/kernel/syscalls/fcntl/fcntl34.c
index 45e693fe6..7c3cea05f 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl34.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl34.c
@@ -125,7 +125,6 @@ static void test01(void)
 }
 
 static struct tst_test test = {
-	.min_kver = "3.15.0",
 	.needs_tmpdir = 1,
 	.test_all = test01,
 	.setup = setup
diff --git a/testcases/kernel/syscalls/fcntl/fcntl36.c b/testcases/kernel/syscalls/fcntl/fcntl36.c
index e84b7ed0c..19a5a0303 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl36.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl36.c
@@ -387,7 +387,7 @@ static void tests(unsigned int i)
 }
 
 static struct tst_test test = {
-	.min_kver = "3.15",
+	.timeout = 9,
 	.needs_tmpdir = 1,
 	.test = tests,
 	.tcnt = ARRAY_SIZE(tcases),
diff --git a/testcases/kernel/syscalls/fdatasync/fdatasync03.c b/testcases/kernel/syscalls/fdatasync/fdatasync03.c
index 5f3e0c96f..f1b5f0fb8 100644
--- a/testcases/kernel/syscalls/fdatasync/fdatasync03.c
+++ b/testcases/kernel/syscalls/fdatasync/fdatasync03.c
@@ -53,6 +53,7 @@ static void verify_fdatasync(void)
 }
 
 static struct tst_test test = {
+	.timeout = 15,
 	.needs_root = 1,
 	.mount_device = 1,
 	.all_filesystems = 1,
diff --git a/testcases/kernel/syscalls/fgetxattr/fgetxattr01.c b/testcases/kernel/syscalls/fgetxattr/fgetxattr01.c
index 52e6e44ab..eefddd829 100644
--- a/testcases/kernel/syscalls/fgetxattr/fgetxattr01.c
+++ b/testcases/kernel/syscalls/fgetxattr/fgetxattr01.c
@@ -134,6 +134,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.setup = setup,
 	.test = verify_fgetxattr,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/finit_module/.gitignore b/testcases/kernel/syscalls/finit_module/.gitignore
index 5fcafdb37..3aebad337 100644
--- a/testcases/kernel/syscalls/finit_module/.gitignore
+++ b/testcases/kernel/syscalls/finit_module/.gitignore
@@ -1,3 +1,8 @@
 /finit_module01
 /finit_module02
 /*.ko
+/*.cmd
+/*.order
+/*.mod.c
+/Module.symvers
+modules.livepatch
diff --git a/testcases/kernel/syscalls/finit_module/finit_module.c b/testcases/kernel/syscalls/finit_module/finit_module.c
index 78d03b899..a7b1e43c5 100644
--- a/testcases/kernel/syscalls/finit_module/finit_module.c
+++ b/testcases/kernel/syscalls/finit_module/finit_module.c
@@ -13,6 +13,8 @@
 #include <linux/proc_fs.h>
 #include <linux/kernel.h>
 
+#define DIRNAME "dummy_finit"
+
 static char status[20];
 module_param_string(status, status, 20, 0444);
 
@@ -23,14 +25,14 @@ static int dummy_init(void)
 	if (!strcmp(status, "invalid"))
 		return -EINVAL;
 
-	proc_dummy = proc_mkdir("dummy", 0);
+	proc_dummy = proc_mkdir(DIRNAME, 0);
 	return 0;
 }
 module_init(dummy_init);
 
 static void dummy_exit(void)
 {
-	remove_proc_entry("dummy", 0);
+	remove_proc_entry(DIRNAME, 0);
 }
 module_exit(dummy_exit);
 
diff --git a/testcases/kernel/syscalls/finit_module/finit_module01.c b/testcases/kernel/syscalls/finit_module/finit_module01.c
index 1546d4fb7..ea00e4835 100644
--- a/testcases/kernel/syscalls/finit_module/finit_module01.c
+++ b/testcases/kernel/syscalls/finit_module/finit_module01.c
@@ -17,7 +17,6 @@
 #include <errno.h>
 #include "lapi/init_module.h"
 #include "tst_module.h"
-#include "tst_kconfig.h"
 
 #define MODULE_NAME	"finit_module.ko"
 
@@ -27,11 +26,8 @@ static char *mod_path;
 
 static void setup(void)
 {
-	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
-
-	tst_kcmdline_parse(&params, 1);
-	if (params.found)
-		sig_enforce = atoi(params.value);
+	if (tst_module_signature_enforced())
+		sig_enforce = 1;
 
 	tst_module_exists(MODULE_NAME, &mod_path);
 
@@ -41,7 +37,6 @@ static void setup(void)
 static void run(void)
 {
 	if (sig_enforce == 1) {
-		tst_res(TINFO, "module signature is enforced");
 		TST_EXP_FAIL(finit_module(fd, "status=valid", 0), EKEYREJECTED);
 		return;
 	}
diff --git a/testcases/kernel/syscalls/finit_module/finit_module02.c b/testcases/kernel/syscalls/finit_module/finit_module02.c
index 2fe70af4d..e16164ee2 100644
--- a/testcases/kernel/syscalls/finit_module/finit_module02.c
+++ b/testcases/kernel/syscalls/finit_module/finit_module02.c
@@ -18,7 +18,6 @@
 #include <errno.h>
 #include "lapi/init_module.h"
 #include "tst_module.h"
-#include "tst_kconfig.h"
 #include "tst_capability.h"
 
 #define MODULE_NAME	"finit_module.ko"
@@ -77,11 +76,9 @@ static struct tcase tcases[] = {
 static void setup(void)
 {
 	unsigned long int i;
-	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
 
-	tst_kcmdline_parse(&params, 1);
-	if (params.found)
-		sig_enforce = atoi(params.value);
+	if (tst_module_signature_enforced())
+		sig_enforce = 1;
 
 	tst_module_exists(MODULE_NAME, &mod_path);
 
diff --git a/testcases/kernel/syscalls/flock/flock01.c b/testcases/kernel/syscalls/flock/flock01.c
index 6b651c901..4c37e07f9 100644
--- a/testcases/kernel/syscalls/flock/flock01.c
+++ b/testcases/kernel/syscalls/flock/flock01.c
@@ -1,9 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /* Copyright (c) Wipro Technologies Ltd, 2002.  All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2007-2018
  * Author: Vatsal Avasthi
+ */
+
+/*\
+ * [Description]
  *
- * Test Description:
- *  This test verifies that flock() succeeds with all kind of locks.
+ * Basic test for flock(2), uses LOCK_SH, LOCK_UN, LOCK_EX locks.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/flock/flock02.c b/testcases/kernel/syscalls/flock/flock02.c
index 07f11ec3c..b8c7eee68 100644
--- a/testcases/kernel/syscalls/flock/flock02.c
+++ b/testcases/kernel/syscalls/flock/flock02.c
@@ -1,15 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) Wipro Technologies Ltd, 2002.  All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2002-2018
  * Author: Vatsal Avasthi
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify flock(2) returns -1 and set proper errno:
  *
- * Test Description:
- *  1) flock() returns -1 and sets error number to EBADF if the file descriptor
- *     is invalid.
- *  2) flock() returns -1 and sets error number to EINVAL if the argument
- *     operation does not include LOCK_SH,LOCK_EX,LOCK_UN.
- *  3) flock() returns -1 and sets error number to EINVAL if an invalid
- *     combination of locking modes is used i.e LOCK_SH with LOCK_EX
+ * - EBADF if the file descriptor is invalid
+ * - EINVAL if the argument operation does not include LOCK_SH,LOCK_EX,LOCK_UN
+ * - EINVAL if an invalid combination of locking modes is used i.e LOCK_SH with LOCK_EX
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/flock/flock03.c b/testcases/kernel/syscalls/flock/flock03.c
index 92e21a6a1..dec6e7344 100644
--- a/testcases/kernel/syscalls/flock/flock03.c
+++ b/testcases/kernel/syscalls/flock/flock03.c
@@ -1,18 +1,20 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) International Business Machines  Corp., 2002
- * Author: Cyril Hrubis
+ * Copyright (c) 2012-2015 Cyril Hrubis <chrubis@suse.cz>
+ * Copyright (c) Linux Test Project, 2002-2018
+ */
+
+/*\
+ * [Description]
  *
- * Test Description:
- *  This test verifies that flock() cannot unlock a file locked by another
- *  task.
+ * Verify that flock(2) cannot unlock a file locked by another task.
  *
- * Test Steps:
- *  Fork a child processes The parent flocks a file with LOCK_EX Child waits
- *  for that to happen, then checks to make sure it is locked.  Child then
- *  tries to unlock the file. If the unlock succeeds, the child attempts to
- *  lock the file with LOCK_EX. The test passes if the child is able to lock
- *  the file.
+ * Fork a child processes. The parent flocks a file with LOCK_EX. Child waits
+ * for that to happen, then checks to make sure it is locked.  Child then
+ * tries to unlock the file. If the unlock succeeds, the child attempts to
+ * lock the file with LOCK_EX. The test passes if the child is able to lock
+ * the file.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/flock/flock04.c b/testcases/kernel/syscalls/flock/flock04.c
index 89d1949cf..1649b45c2 100644
--- a/testcases/kernel/syscalls/flock/flock04.c
+++ b/testcases/kernel/syscalls/flock/flock04.c
@@ -1,14 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /* Copyright (c) Wipro Technologies Ltd, 2002.  All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2003-2021
  * Author: Vatsal Avasthi
+ */
+
+/*\
+ * [Description]
+ *
+ * Test verifies that flock() behavior with different locking combinations along
+ * with LOCK_SH and LOCK_EX:
  *
- * Test Description:
- *  This test verifies that flock() behavior with different locking
- *  combinations along with LOCK_SH and LOCK_EX:
- *	1) flock() succeeded in acquiring shared lock on shared lock file.
- *	2) flock() failed to acquire exclusive lock on shared lock file.
- *	3) flock() failed to acquire shared lock on exclusive lock file.
- *	4) flock() failed to acquire exclusive lock on exclusive lock file.
+ * - flock() succeeded in acquiring shared lock on shared lock file.
+ * - flock() failed to acquire exclusive lock on shared lock file.
+ * - flock() failed to acquire shared lock on exclusive lock file.
+ * - flock() failed to acquire exclusive lock on exclusive lock file.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/flock/flock06.c b/testcases/kernel/syscalls/flock/flock06.c
index f5d469a34..7e9da8acd 100644
--- a/testcases/kernel/syscalls/flock/flock06.c
+++ b/testcases/kernel/syscalls/flock/flock06.c
@@ -1,17 +1,20 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /* Copyright (c) Matthew Wilcox for Hewlett Packard 2003
+ * Copyright (c) Linux Test Project, 2007-2018
  * Author: Matthew Wilcox
+ */
+
+/*\
+ * [Description]
  *
- * Test Description:
- *  This test verifies that flock locks held on one fd conflict with flock
- *  locks held on a different fd.
+ * Test verifies that flock locks held on one file descriptor conflict with
+ * flock locks held on a different file descriptor.
  *
- * Test Steps:
- *  The process opens two file descriptors on the same file.  It acquires
- *  an exclusive flock on the first descriptor, checks that attempting to
- *  acquire an flock on the second descriptor fails.  Then it removes the
- *  first descriptor's lock and attempts to acquire an exclusive lock on
- *  the second descriptor.
+ * The process opens two file descriptors on the same file.  It acquires
+ * an exclusive flock on the first descriptor, checks that attempting to
+ * acquire an flock on the second descriptor fails.  Then it removes the
+ * first descriptor's lock and attempts to acquire an exclusive lock on
+ * the second descriptor.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/fork/fork04.c b/testcases/kernel/syscalls/fork/fork04.c
index b0c6bebe0..413cd5eb4 100644
--- a/testcases/kernel/syscalls/fork/fork04.c
+++ b/testcases/kernel/syscalls/fork/fork04.c
@@ -29,7 +29,7 @@ static void run_child(void)
 
 	TST_EXP_EXPR(strcmp(ENV_VAL0, val) == 0,
 		"%s environ variable has been inherited by the child",
-		ENV_KEY)
+		ENV_KEY);
 
 	tst_res(TINFO, "Unset %s environ variable inside child", ENV_KEY);
 
@@ -72,7 +72,7 @@ static void run(void)
 	} else {
 		TST_EXP_EXPR(strcmp(ENV_VAL0, val) == 0,
 			"%s environ variable is still present inside parent",
-			ENV_KEY)
+			ENV_KEY);
 	}
 
 	TST_CHECKPOINT_WAKE_AND_WAIT(0);
@@ -85,7 +85,7 @@ static void run(void)
 	else {
 		TST_EXP_EXPR(strcmp(ENV_VAL0, val) == 0,
 			"%s environ variable didn't change inside parent",
-			ENV_KEY)
+			ENV_KEY);
 	}
 }
 
diff --git a/testcases/kernel/syscalls/fork/fork05.c b/testcases/kernel/syscalls/fork/fork05.c
index 9a99cff1d..b5146d27b 100644
--- a/testcases/kernel/syscalls/fork/fork05.c
+++ b/testcases/kernel/syscalls/fork/fork05.c
@@ -1,150 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * Portions Copyright (c) 2000 Ulrich Drepper
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it would be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * Further, this software is distributed without any warranty that it is
- * free of the rightful claim of any third person regarding infringement
- * or the like.  Any license provided herein, whether implied or
- * otherwise, applies only to this software file.  Patent licenses, if
- * any, provided herein do not apply to combinations of this program with
- * other software, or any other product whatsoever.
+ *     Author: Ulrich Drepper / Nate Straz , Red Hat
+ * Copyright (C) 2023 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * This test verifies that LDT is propagated correctly from parent process to
+ * the child process.
  *
- * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
- * Mountain View, CA  94043, or:
+ * On Friday, May 2, 2003 at 09:47:00AM MST, Ulrich Drepper wrote:
  *
- * http://www.sgi.com$
+ *  Robert Williamson wrote:
  *
- * For further information regarding this notice, see:$
+ *  I'm getting a SIGSEGV with one of our tests, fork05.c, that apparently
+ *  you wrote (attached below).  The test passes on my 2.5.68 machine running
+ *  SuSE 8.0 (glibc 2.2.5 and Linuxthreads), however it segmentation faults on
+ *  RedHat 9 running 2.5.68.  The test seems to "break" when it attempts to run
+ *  the assembly code....could you take a look at it?
  *
- * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
+ *  There is no need to look at it, I know it cannot work anymore on recent
+ *  systems.  Either change all uses of %gs to %fs or skip the entire patch
+ *  if %gs has a nonzero value.
  *
+ * On Sat, Aug 12, 2000 at 12:47:31PM -0700, Ulrich Drepper wrote:
  *
- *    Linux Test Project - Silicon Graphics, Inc.
- *    TEST IDENTIFIER	: fork05
- *    EXECUTED BY	: anyone
- *    TEST TITLE	: Make sure LDT is propagated correctly
- *    TEST CASE TOTAL	: 1
- *    CPU TYPES		: i386
- *    AUTHORS		: Ulrich Drepper
- *			  Nate Straz
+ *  Ever since the %gs handling was fixed in the 2.3.99 series the
+ *  appended test program worked.  Now with 2.4.0-test6 it's not working
+ *  again.  Looking briefly over the patch from test5 to test6 I haven't
+ *  seen an immediate candidate for the breakage.  It could be missing
+ *  propagation of the LDT to the new process (and therefore an invalid
+ *  segment descriptor) or simply clearing %gs.
  *
- *On Friday, May 2, 2003 at 09:47:00AM MST, Ulrich Drepper wrote:
- *>Robert Williamson wrote:
- *>
- *>>   I'm getting a SIGSEGV with one of our tests, fork05.c, that apparently
- *>> you wrote (attached below).  The test passes on my 2.5.68 machine running
- *>> SuSE 8.0 (glibc 2.2.5 and Linuxthreads), however it segmentation faults on
- *>> RedHat 9 running 2.5.68.  The test seems to "break" when it attempts to run
- *>> the assembly code....could you take a look at it?
- *>
- *>There is no need to look at it, I know it cannot work anymore on recent
- *>systems.  Either change all uses of %gs to %fs or skip the entire patch
- *>if %gs has a nonzero value.
- *>
- *>- --
- *>- --------------.                        ,-.            444 Castro Street
- *>Ulrich Drepper \    ,-----------------'   \ Mountain View, CA 94041 USA
- *>Red Hat         `--' drepper at redhat.com `---------------------------
+ *  Anyway, this is what you should see and what you get with test5:
  *
+ *  a = 42
+ *  %gs = 0x0007
+ *  %gs = 0x0007
+ *  a = 99
  *
+ *  This is what you get with test6:
  *
- *On Sat, Aug 12, 2000 at 12:47:31PM -0700, Ulrich Drepper wrote:
- *> Ever since the %gs handling was fixed in the 2.3.99 series the
- *> appended test program worked.  Now with 2.4.0-test6 it's not working
- *> again.  Looking briefly over the patch from test5 to test6 I haven't
- *> seen an immediate candidate for the breakage.  It could be missing
- *> propagation of the LDT to the new process (and therefore an invalid
- *> segment descriptor) or simply clearing %gs.
- *>
- *> Anyway, this is what you should see and what you get with test5:
- *>
- *> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *> a = 42
- *> %gs = 0x0007
- *> %gs = 0x0007
- *> a = 99
- *> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *>
- *> This is what you get with test6:
- *>
- *> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *> a = 42
- *> %gs = 0x0007
- *> %gs = 0x0000
- *> <SEGFAULT>
- *> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *>
- *> If somebody is actually creating a test suite for the kernel, please
- *> add this program.  It's mostly self-contained.  The correct handling
- *> of %gs is really important since glibc 2.2 will make heavy use of it.
- *>
- *> - --
- *> - ---------------.                          ,-.   1325 Chesapeake Terrace
- *> Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
- *> Red Hat          `--' drepper at redhat.com   `------------------------
- *>
- *> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  a = 42
+ *  %gs = 0x0007
+ *  %gs = 0x0000
+ *  <SEGFAULT>
  *
+ *  If somebody is actually creating a test suite for the kernel, please
+ *  add this program.  It's mostly self-contained.  The correct handling
+ *  of %gs is really important since glibc 2.2 will make heavy use of it.
  */
 
-#include <stdio.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <sys/wait.h>
-#include "lapi/syscalls.h"
-#include "test.h"
-
-char *TCID = "fork05";
+#include "tst_test.h"
 
-static char *environ_list[] = { "TERM", "NoTSetzWq", "TESTPROG" };
+#if defined(__i386__)
 
-#define NUMBER_OF_ENVIRON (sizeof(environ_list)/sizeof(char *))
-int TST_TOTAL = NUMBER_OF_ENVIRON;
-
-#if defined(linux) && defined(__i386__)
-
-struct modify_ldt_ldt_s {
-	unsigned int entry_number;
-	unsigned long int base_addr;
-	unsigned int limit;
-	unsigned int seg_32bit:1;
-	unsigned int contents:2;
-	unsigned int read_exec_only:1;
-	unsigned int limit_in_pages:1;
-	unsigned int seg_not_present:1;
-	unsigned int useable:1;
-	unsigned int empty:25;
-};
-
-static int a = 42;
-
-static void modify_ldt(int func, struct modify_ldt_ldt_s *ptr, int bytecount)
-{
-	tst_syscall(__NR_modify_ldt, func, ptr, bytecount);
-}
+#include "lapi/syscalls.h"
+#include <asm/ldt.h>
 
-int main(void)
+static void run(void)
 {
-	struct modify_ldt_ldt_s ldt0;
-	int lo;
+	struct user_desc ldt0;
+	int base_addr = 42;
+	int status;
 	pid_t pid;
-	int res;
+	int lo;
 
 	ldt0.entry_number = 0;
-	ldt0.base_addr = (long)&a;
+	ldt0.base_addr = (long)&base_addr;
 	ldt0.limit = 4;
 	ldt0.seg_32bit = 1;
 	ldt0.contents = 0;
@@ -152,51 +77,44 @@ int main(void)
 	ldt0.limit_in_pages = 0;
 	ldt0.seg_not_present = 0;
 	ldt0.useable = 1;
-	ldt0.empty = 0;
 
-	modify_ldt(1, &ldt0, sizeof(ldt0));
+	tst_syscall(__NR_modify_ldt, 1, &ldt0, sizeof(ldt0));
 
 	asm volatile ("movw %w0, %%fs"::"q" (7));
-
 	asm volatile ("movl %%fs:0, %0":"=r" (lo));
-	tst_resm(TINFO, "a = %d", lo);
+	tst_res(TINFO, "a = %d", lo);
 
 	asm volatile ("pushl %%fs; popl %0":"=q" (lo));
-	tst_resm(TINFO, "%%fs = %#06hx", lo);
+	tst_res(TINFO, "%%fs = %#06hx", lo);
 
 	asm volatile ("movl %0, %%fs:0"::"r" (99));
 
-	pid = fork();
-
-	if (pid == 0) {
+	pid = SAFE_FORK();
+	if (!pid) {
 		asm volatile ("pushl %%fs; popl %0":"=q" (lo));
-		tst_resm(TINFO, "%%fs = %#06hx", lo);
+		tst_res(TINFO, "%%fs = %#06hx", lo);
 
 		asm volatile ("movl %%fs:0, %0":"=r" (lo));
-		tst_resm(TINFO, "a = %d", lo);
-
-		if (lo != 99)
-			tst_resm(TFAIL, "Test failed");
-		else
-			tst_resm(TPASS, "Test passed");
-		exit(lo != 99);
-	} else {
-		waitpid(pid, &res, 0);
-	}
+		tst_res(TINFO, "a = %d", lo);
 
-	return WIFSIGNALED(res);
-}
+		TST_EXP_EQ_LI(lo, 99);
 
-#else /* if defined(linux) && defined(__i386__) */
+		exit(0);
+	}
 
-int main(void)
-{
-	tst_resm(TINFO, "%%fs test only for ix86");
+	SAFE_WAITPID(pid, &status, 0);
 
-	/*
-	 * should be successful on all non-ix86 platforms.
-	 */
-	tst_exit();
+	if (WIFEXITED(status) && !WEXITSTATUS(status))
+		tst_res(TPASS, "Child did exit with 0");
+	else
+		tst_res(TFAIL, "Child %s", tst_strstatus(status));
 }
 
-#endif /* if defined(linux) && defined(__i386__) */
+static struct tst_test test = {
+	.test_all = run,
+	.forks_child = 1,
+};
+
+#else
+	TST_TEST_TCONF("Test only supports Intel 32 bits");
+#endif
diff --git a/testcases/kernel/syscalls/fork/fork13.c b/testcases/kernel/syscalls/fork/fork13.c
index 4923d8a91..3e96d0d42 100644
--- a/testcases/kernel/syscalls/fork/fork13.c
+++ b/testcases/kernel/syscalls/fork/fork13.c
@@ -110,7 +110,7 @@ static void check(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.forks_child = 1,
-	.max_runtime = 600,
+	.runtime = 600,
 	.test_all = check,
 	.save_restore = (const struct tst_path_val[]) {
 		{"/proc/sys/kernel/pid_max", PID_MAX_STR, TST_SR_TBROK},
diff --git a/testcases/kernel/syscalls/fremovexattr/fremovexattr01.c b/testcases/kernel/syscalls/fremovexattr/fremovexattr01.c
index 907d210d1..aca2fce7c 100644
--- a/testcases/kernel/syscalls/fremovexattr/fremovexattr01.c
+++ b/testcases/kernel/syscalls/fremovexattr/fremovexattr01.c
@@ -83,6 +83,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 12,
 	.setup = setup,
 	.test_all = verify_fremovexattr,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/fremovexattr/fremovexattr02.c b/testcases/kernel/syscalls/fremovexattr/fremovexattr02.c
index eb106a8fa..78af8be32 100644
--- a/testcases/kernel/syscalls/fremovexattr/fremovexattr02.c
+++ b/testcases/kernel/syscalls/fremovexattr/fremovexattr02.c
@@ -105,6 +105,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.setup = setup,
 	.test = verify_fremovexattr,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/fsconfig/fsconfig01.c b/testcases/kernel/syscalls/fsconfig/fsconfig01.c
index a585daa6d..678d21815 100644
--- a/testcases/kernel/syscalls/fsconfig/fsconfig01.c
+++ b/testcases/kernel/syscalls/fsconfig/fsconfig01.c
@@ -82,6 +82,7 @@ static void run(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.test_all = run,
 	.setup = fsopen_supported_by_kernel,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/fsconfig/fsconfig03.c b/testcases/kernel/syscalls/fsconfig/fsconfig03.c
index 0ba5355d3..503753636 100644
--- a/testcases/kernel/syscalls/fsconfig/fsconfig03.c
+++ b/testcases/kernel/syscalls/fsconfig/fsconfig03.c
@@ -80,6 +80,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/fsetxattr/fsetxattr01.c b/testcases/kernel/syscalls/fsetxattr/fsetxattr01.c
index b65b27bdf..73e1fcfb7 100644
--- a/testcases/kernel/syscalls/fsetxattr/fsetxattr01.c
+++ b/testcases/kernel/syscalls/fsetxattr/fsetxattr01.c
@@ -214,6 +214,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.setup = setup,
 	.test = verify_fsetxattr,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/fsmount/fsmount01.c b/testcases/kernel/syscalls/fsmount/fsmount01.c
index 5f755863f..6dafe25a8 100644
--- a/testcases/kernel/syscalls/fsmount/fsmount01.c
+++ b/testcases/kernel/syscalls/fsmount/fsmount01.c
@@ -88,6 +88,7 @@ static void run(unsigned int n)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = run,
 	.setup = fsopen_supported_by_kernel,
diff --git a/testcases/kernel/syscalls/fsmount/fsmount02.c b/testcases/kernel/syscalls/fsmount/fsmount02.c
index a4f42dc18..55f0e2f28 100644
--- a/testcases/kernel/syscalls/fsmount/fsmount02.c
+++ b/testcases/kernel/syscalls/fsmount/fsmount02.c
@@ -68,6 +68,7 @@ static void run(unsigned int n)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = run,
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/fsopen/fsopen01.c b/testcases/kernel/syscalls/fsopen/fsopen01.c
index c2c719c96..9dd87b99f 100644
--- a/testcases/kernel/syscalls/fsopen/fsopen01.c
+++ b/testcases/kernel/syscalls/fsopen/fsopen01.c
@@ -69,6 +69,7 @@ out:
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = run,
 	.setup = fsopen_supported_by_kernel,
diff --git a/testcases/kernel/syscalls/fspick/fspick01.c b/testcases/kernel/syscalls/fspick/fspick01.c
index d3309a912..d03cacd3d 100644
--- a/testcases/kernel/syscalls/fspick/fspick01.c
+++ b/testcases/kernel/syscalls/fspick/fspick01.c
@@ -56,6 +56,7 @@ out:
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = run,
 	.setup = fsopen_supported_by_kernel,
diff --git a/testcases/kernel/syscalls/fspick/fspick02.c b/testcases/kernel/syscalls/fspick/fspick02.c
index f9a3697c1..89bdd2cc8 100644
--- a/testcases/kernel/syscalls/fspick/fspick02.c
+++ b/testcases/kernel/syscalls/fspick/fspick02.c
@@ -43,6 +43,7 @@ static void run(unsigned int n)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = run,
 	.setup = fsopen_supported_by_kernel,
diff --git a/testcases/kernel/syscalls/fstatfs/fstatfs01.c b/testcases/kernel/syscalls/fstatfs/fstatfs01.c
index 9d3909ace..044ab6548 100644
--- a/testcases/kernel/syscalls/fstatfs/fstatfs01.c
+++ b/testcases/kernel/syscalls/fstatfs/fstatfs01.c
@@ -56,6 +56,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.setup = setup,
 	.cleanup = cleanup,
 	.tcnt = ARRAY_SIZE(tcases),
diff --git a/testcases/kernel/syscalls/fsync/fsync01.c b/testcases/kernel/syscalls/fsync/fsync01.c
index 072245fc8..7ae5296c7 100644
--- a/testcases/kernel/syscalls/fsync/fsync01.c
+++ b/testcases/kernel/syscalls/fsync/fsync01.c
@@ -44,6 +44,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.cleanup = cleanup,
 	.setup = setup,
 	.test_all = verify_fsync,
diff --git a/testcases/kernel/syscalls/fsync/fsync02.c b/testcases/kernel/syscalls/fsync/fsync02.c
index c9de5c729..3293415f3 100644
--- a/testcases/kernel/syscalls/fsync/fsync02.c
+++ b/testcases/kernel/syscalls/fsync/fsync02.c
@@ -115,5 +115,5 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.needs_tmpdir = 1,
-	.max_runtime = 300,
+	.timeout = 300,
 };
diff --git a/testcases/kernel/syscalls/fsync/fsync04.c b/testcases/kernel/syscalls/fsync/fsync04.c
index 9aa1584c1..f7553ff58 100644
--- a/testcases/kernel/syscalls/fsync/fsync04.c
+++ b/testcases/kernel/syscalls/fsync/fsync04.c
@@ -53,6 +53,7 @@ static void verify_fsync(void)
 }
 
 static struct tst_test test = {
+	.timeout = 17,
 	.needs_root = 1,
 	.mount_device = 1,
 	.all_filesystems = 1,
diff --git a/testcases/kernel/syscalls/ftruncate/ftruncate01.c b/testcases/kernel/syscalls/ftruncate/ftruncate01.c
index 5ffdd0513..ea97edb1d 100644
--- a/testcases/kernel/syscalls/ftruncate/ftruncate01.c
+++ b/testcases/kernel/syscalls/ftruncate/ftruncate01.c
@@ -4,11 +4,13 @@
  * Copyright (c) 2019 FUJITSU LIMITED. All rights reserved.
  * Author: Wayne Boyer
  */
-/*
- * Test Description:
- *  Verify that, ftruncate() succeeds to truncate a file to a certain length,
- *  if the file previously is smaller than the truncated size, ftruncate()
- *  shall increase the size of the file.
+
+/*\
+ * [Description]
+ *
+ * Verify that, ftruncate() succeeds to truncate a file to a certain length,
+ * if the file previously is smaller than the truncated size, ftruncate()
+ * shall increase the size of the file.
  */
 
 #include <sys/types.h>
diff --git a/testcases/kernel/syscalls/futex/futex_cmp_requeue01.c b/testcases/kernel/syscalls/futex/futex_cmp_requeue01.c
index 872704467..bf4c3813a 100644
--- a/testcases/kernel/syscalls/futex/futex_cmp_requeue01.c
+++ b/testcases/kernel/syscalls/futex/futex_cmp_requeue01.c
@@ -1,12 +1,16 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2019 Xiao Yang <ice_yangxiao@163.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify the basic functionality of futex(FUTEX_CMP_REQUEUE).
  *
- * Description:
- * Testcase to check the basic functionality of futex(FUTEX_CMP_REQUEUE).
  * futex(FUTEX_CMP_REQUEUE) can wake up the number of waiters specified
  * by val argument and then requeue the number of waiters limited by val2
- * argument(i.e. move some remaining waiters from uaddr to uaddr2 address).
+ * argument (i.e. move some remaining waiters from uaddr to uaddr2 address).
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/get_mempolicy/Makefile b/testcases/kernel/syscalls/get_mempolicy/Makefile
index a108d8209..517838f43 100644
--- a/testcases/kernel/syscalls/get_mempolicy/Makefile
+++ b/testcases/kernel/syscalls/get_mempolicy/Makefile
@@ -4,7 +4,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpnuma
+LTPLIBS = numa
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/getcpu/.gitignore b/testcases/kernel/syscalls/getcpu/.gitignore
index 31fec5d35..cd3022bbb 100644
--- a/testcases/kernel/syscalls/getcpu/.gitignore
+++ b/testcases/kernel/syscalls/getcpu/.gitignore
@@ -1 +1,2 @@
 /getcpu01
+/getcpu02
diff --git a/testcases/kernel/syscalls/getcpu/getcpu01.c b/testcases/kernel/syscalls/getcpu/getcpu01.c
index 9842c8999..152f91d32 100644
--- a/testcases/kernel/syscalls/getcpu/getcpu01.c
+++ b/testcases/kernel/syscalls/getcpu/getcpu01.c
@@ -1,11 +1,16 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright  International Business Machines  Corp., 2007, 2008
+ * Copyright (c) Linux Test Project, 2009-2024
  *
- * Test Description:
- *  The test process is affined to a CPU. It then calls getcpu and
- *  checks that the CPU and node (if supported) match the expected
- *  values.
+ */
+
+/*\
+ * [Description]
+ *
+ * The test process is affined to a CPU. It then calls getcpu and
+ * checks that the CPU and node (if supported) match the expected
+ * values.
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/getcpu/getcpu02.c b/testcases/kernel/syscalls/getcpu/getcpu02.c
new file mode 100644
index 000000000..048758b3d
--- /dev/null
+++ b/testcases/kernel/syscalls/getcpu/getcpu02.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2024
+ * Author: Ma Xinjian <maxj.fnst@fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that getcpu(2) fails with EFAULT if cpu_id or node_id points outside
+ * the calling process address space.
+ */
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "lapi/sched.h"
+
+static unsigned int cpu_id, node_id;
+
+static struct tcase {
+	unsigned int *cpu_id;
+	unsigned int *node_id;
+	char *desc;
+} tcases[] = {
+	{NULL, &node_id, "cpu_id"},
+	{&cpu_id, NULL, "node_id"},
+};
+
+static void check_getcpu(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+	int status;
+	pid_t pid;
+
+	tst_res(TINFO, "Test %s outside process address space", tc->desc);
+
+	if (!tc->cpu_id)
+		tc->cpu_id = tst_get_bad_addr(NULL);
+
+	if (!tc->node_id)
+		tc->node_id = tst_get_bad_addr(NULL);
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		TST_EXP_FAIL(getcpu(tc->cpu_id, tc->node_id), EFAULT);
+
+		exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
+		tst_res(TPASS, "getcpu() caused SIGSEGV");
+		return;
+	}
+
+	if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
+		return;
+
+	tst_res(TFAIL, "child %s", tst_strstatus(status));
+}
+
+static struct tst_test test = {
+	.test = check_getcpu,
+	.tcnt = ARRAY_SIZE(tcases),
+	.forks_child = 1,
+};
diff --git a/testcases/kernel/syscalls/getdents/getdents.h b/testcases/kernel/syscalls/getdents/getdents.h
index 560df4126..02c3bc509 100644
--- a/testcases/kernel/syscalls/getdents/getdents.h
+++ b/testcases/kernel/syscalls/getdents/getdents.h
@@ -64,9 +64,9 @@ tst_dirp_size(void)
 {
 	switch (tst_variant) {
 	case 0:
-		return sizeof(struct linux_dirent);
+		return sizeof(struct linux_dirent) + NAME_MAX;
 	case 1:
-		return sizeof(struct linux_dirent64);
+		return sizeof(struct linux_dirent64) + NAME_MAX;
 #if HAVE_GETDENTS
 	case 2:
 		return sizeof(struct dirent);
diff --git a/testcases/kernel/syscalls/getdents/getdents01.c b/testcases/kernel/syscalls/getdents/getdents01.c
index e5e4689ee..d6c4b4979 100644
--- a/testcases/kernel/syscalls/getdents/getdents01.c
+++ b/testcases/kernel/syscalls/getdents/getdents01.c
@@ -22,6 +22,9 @@
 
 #include <stdlib.h>
 
+#define MNTPOINT "mntpoint"
+#define WORKDIR MNTPOINT "/workdir"
+
 static void reset_flags(void);
 static void check_flags(void);
 static void set_flag(const char *name);
@@ -61,7 +64,7 @@ static void run(void)
 {
 	int rval;
 
-	fd = SAFE_OPEN(".", O_RDONLY|O_DIRECTORY);
+	fd = SAFE_OPEN(WORKDIR, O_RDONLY|O_DIRECTORY);
 
 	rval = tst_getdents(fd, dirp, BUFSIZE);
 
@@ -147,31 +150,37 @@ static void set_flag(const char *name)
 static void setup(void)
 {
 	size_t i;
+	char path[255];
 
 	getdents_info();
 
-	if (!tst_variant) {
-		for (i = 0; i < ARRAY_SIZE(testcases); i++) {
-			if (!testcases[i].create)
-				continue;
-
-			switch (testcases[i].type) {
-			case ENTRY_DIR:
-				SAFE_MKDIR(testcases[i].name, 0777);
-			break;
-			case ENTRY_FILE:
-				SAFE_FILE_PRINTF(testcases[i].name, " ");
-			break;
-			case ENTRY_SYMLINK:
-				SAFE_SYMLINK("nonexistent", testcases[i].name);
-			break;
-			}
+	/*
+	 * Work in a subdirectory because some filesystems add special files
+	 * or directories to their root.
+	 */
+	SAFE_MKDIR(WORKDIR, 0777);
+
+	for (i = 0; i < ARRAY_SIZE(testcases); i++) {
+		if (!testcases[i].create)
+			continue;
+
+		sprintf(path, "%s/%s", WORKDIR, testcases[i].name);
+
+		switch (testcases[i].type) {
+		case ENTRY_DIR:
+			SAFE_MKDIR(path, 0777);
+		break;
+		case ENTRY_FILE:
+			SAFE_FILE_PRINTF(path, " ");
+		break;
+		case ENTRY_SYMLINK:
+			SAFE_SYMLINK("nonexistent", path);
+		break;
 		}
 	}
 }
 
 static struct tst_test test = {
-	.needs_tmpdir = 1,
 	.test_all = run,
 	.setup = setup,
 	.bufs = (struct tst_buffers []) {
@@ -179,4 +188,13 @@ static struct tst_test test = {
 		{},
 	},
 	.test_variants = TEST_VARIANTS,
+	.needs_root = 1,
+	.all_filesystems = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.skip_filesystems = (const char *const[]) {
+		"vfat",
+		"exfat",
+		NULL
+	}
 };
diff --git a/testcases/kernel/syscalls/getdents/getdents02.c b/testcases/kernel/syscalls/getdents/getdents02.c
index ade1c9476..71c3332f4 100644
--- a/testcases/kernel/syscalls/getdents/getdents02.c
+++ b/testcases/kernel/syscalls/getdents/getdents02.c
@@ -15,6 +15,7 @@
  *   - getdents() fails with EINVAL if result buffer is too small
  *   - getdents() fails with ENOTDIR if file descriptor does not refer to a directory
  *   - getdents() fails with ENOENT if directory was unlinked()
+ *   - getdents() fails with EFAULT if argument points outside the calling process's address space
  */
 
 #define _GNU_SOURCE
@@ -23,17 +24,17 @@
 #include "tst_test.h"
 #include "getdents.h"
 
-#define DIR_MODE	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP| \
-			 S_IXGRP|S_IROTH|S_IXOTH)
-#define TEST_DIR	"test_dir"
-
-char *TCID = "getdents02";
+#define DIR_MODE	0755
+#define MNTPOINT	"mntpoint"
+#define TEST_DIR	MNTPOINT "/test_dir"
+#define TEST_FILE	MNTPOINT "/test"
 
 static char *dirp;
 static size_t size;
 
 static char dirp1_arr[1];
 static char *dirp1 = dirp1_arr;
+static char *dirp_bad;
 static size_t size1 = 1;
 
 static int fd_inv = -5;
@@ -51,6 +52,7 @@ static struct tcase {
 	{ &fd, &dirp1, &size1, EINVAL },
 	{ &fd_file, &dirp, &size, ENOTDIR },
 	{ &fd_unlinked, &dirp, &size, ENOENT },
+	{ &fd, &dirp_bad, &size, EFAULT },
 };
 
 static void setup(void)
@@ -60,8 +62,10 @@ static void setup(void)
 	size = tst_dirp_size();
 	dirp = tst_alloc(size);
 
-	fd = SAFE_OPEN(".", O_RDONLY);
-	fd_file = SAFE_OPEN("test", O_CREAT | O_RDWR, 0644);
+	fd = SAFE_OPEN(MNTPOINT, O_RDONLY);
+	fd_file = SAFE_OPEN(TEST_FILE, O_CREAT | O_RDWR, 0644);
+
+	dirp_bad = tst_get_bad_addr(NULL);
 
 	SAFE_MKDIR(TEST_DIR, DIR_MODE);
 	fd_unlinked = SAFE_OPEN(TEST_DIR, O_DIRECTORY);
@@ -72,26 +76,18 @@ static void run(unsigned int i)
 {
 	struct tcase *tc = tcases + i;
 
-	TEST(tst_getdents(*tc->fd, *tc->dirp, *tc->size));
-
-	if (TST_RET != -1) {
-		tst_res(TFAIL, "getdents() returned %ld", TST_RET);
-		return;
-	}
-
-	if (TST_ERR == tc->exp_errno) {
-		tst_res(TPASS | TTERRNO, "getdents failed as expected");
-	} else if (errno == ENOSYS) {
-		tst_res(TCONF, "syscall not implemented");
-	} else {
-		tst_res(TFAIL | TTERRNO, "getdents failed unexpectedly");
-	}
+	TST_EXP_FAIL2(tst_getdents(*tc->fd, *tc->dirp, *tc->size),
+		      tc->exp_errno, "fd=%i dirp=%p size=%zu",
+		      *tc->fd, *tc->dirp, *tc->size);
 }
 
 static struct tst_test test = {
-	.needs_tmpdir = 1,
 	.test = run,
 	.setup = setup,
 	.tcnt = ARRAY_SIZE(tcases),
 	.test_variants = TEST_VARIANTS,
+	.needs_root = 1,
+	.all_filesystems = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT
 };
diff --git a/testcases/kernel/syscalls/gethostname/gethostname02.c b/testcases/kernel/syscalls/gethostname/gethostname02.c
index 250e5f2fd..f792371ed 100644
--- a/testcases/kernel/syscalls/gethostname/gethostname02.c
+++ b/testcases/kernel/syscalls/gethostname/gethostname02.c
@@ -16,7 +16,7 @@
 
 static void verify_gethostname(void)
 {
-	char hostname[HOST_NAME_MAX];
+	char hostname[HOST_NAME_MAX + 1];
 	int real_length;
 
 	SAFE_GETHOSTNAME(hostname, sizeof(hostname));
diff --git a/testcases/kernel/syscalls/getpid/getpid01.c b/testcases/kernel/syscalls/getpid/getpid01.c
index 495002037..314c45d09 100644
--- a/testcases/kernel/syscalls/getpid/getpid01.c
+++ b/testcases/kernel/syscalls/getpid/getpid01.c
@@ -43,6 +43,7 @@ static void verify_getpid(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.setup = setup,
 	.forks_child = 1,
 	.test_all = verify_getpid,
diff --git a/testcases/kernel/syscalls/getrandom/getrandom05.c b/testcases/kernel/syscalls/getrandom/getrandom05.c
index 92098deb7..c4886b886 100644
--- a/testcases/kernel/syscalls/getrandom/getrandom05.c
+++ b/testcases/kernel/syscalls/getrandom/getrandom05.c
@@ -16,6 +16,7 @@
 
 #include "tst_test.h"
 #include "lapi/getrandom.h"
+#include "getrandom_var.h"
 
 static char buff_efault[64];
 static char buff_einval[64];
@@ -32,15 +33,28 @@ static struct test_case_t {
 	{buff_einval, sizeof(buff_einval), -1, EINVAL, "flag is invalid"},
 };
 
+static void setup(void)
+{
+	getrandom_info();
+}
+
 static void verify_getrandom(unsigned int i)
 {
 	struct test_case_t *tc = &tcases[i];
 
-	TST_EXP_FAIL2(getrandom(tc->buff, tc->size, tc->flag),
+	/* EFAULT test can segfault on recent glibc, skip it */
+	if (tst_variant == 1 && tc->expected_errno == EFAULT) {
+		tst_res(TCONF, "Skipping EFAULT test for libc getrandom()");
+		return;
+	}
+
+	TST_EXP_FAIL2(do_getrandom(tc->buff, tc->size, tc->flag),
 		tc->expected_errno, "%s", tc->desc);
 }
 
 static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = verify_getrandom,
+	.test_variants = TEST_VARIANTS,
+	.setup = setup,
 };
diff --git a/testcases/kernel/syscalls/getrandom/getrandom_var.h b/testcases/kernel/syscalls/getrandom/getrandom_var.h
new file mode 100644
index 000000000..b19b0ebc0
--- /dev/null
+++ b/testcases/kernel/syscalls/getrandom/getrandom_var.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 Jan Stancek <jstancek@redhat.com>
+ */
+
+#ifndef GETRANDOM_VAR__
+#define GETRANDOM_VAR__
+
+#include "lapi/syscalls.h"
+
+static inline int do_getrandom(void *buf, size_t buflen, unsigned int flags)
+{
+	switch (tst_variant) {
+	case 0:
+		return tst_syscall(__NR_getrandom, buf, buflen, flags);
+	case 1:
+		return getrandom(buf, buflen, flags);
+	}
+	return -1;
+}
+
+static void getrandom_info(void)
+{
+	switch (tst_variant) {
+	case 0:
+		tst_res(TINFO, "Testing SYS_getrandom syscall");
+		break;
+	case 1:
+		tst_res(TINFO, "Testing libc getrandom()");
+		break;
+	}
+}
+
+/* if we don't have libc getrandom() test only syscall version */
+#ifdef HAVE_SYS_RANDOM_H
+# define TEST_VARIANTS 2
+#else
+# define TEST_VARIANTS 1
+#endif
+
+#endif /* GETRANDOM_VAR__ */
diff --git a/testcases/kernel/syscalls/getrusage/getrusage03.h b/testcases/kernel/syscalls/getrusage/getrusage03.h
index 8bee0b9e5..58a98b430 100644
--- a/testcases/kernel/syscalls/getrusage/getrusage03.h
+++ b/testcases/kernel/syscalls/getrusage/getrusage03.h
@@ -6,10 +6,19 @@
 #ifndef LTP_GETRUSAGE03_H
 #define LTP_GETRUSAGE03_H
 
+#include <sched.h>
 #include "tst_test.h"
 
 #define DELTA_MAX 20480
 
+static void force_context_switches(int iterations)
+{
+	tst_res(TINFO, "Forcing context switch %d times", iterations);
+
+	for (int i = 0; i < iterations; i++)
+		sched_yield();
+}
+
 static void consume_mb(int consume_nr)
 {
 	void *ptr;
@@ -22,6 +31,8 @@ static void consume_mb(int consume_nr)
 	ptr = SAFE_MALLOC(size);
 	memset(ptr, 0, size);
 
+	force_context_switches(10);
+
 	SAFE_FILE_LINES_SCANF("/proc/self/status", "VmSwap: %lu", &vmswap_size);
 	if (vmswap_size > 0)
 		tst_brk(TBROK, "VmSwap is not zero");
diff --git a/testcases/kernel/syscalls/gettimeofday/gettimeofday02.c b/testcases/kernel/syscalls/gettimeofday/gettimeofday02.c
index 84bf1f773..a58a3cb4f 100644
--- a/testcases/kernel/syscalls/gettimeofday/gettimeofday02.c
+++ b/testcases/kernel/syscalls/gettimeofday/gettimeofday02.c
@@ -72,6 +72,6 @@ static void setup(void)
 
 static struct tst_test test = {
 	.setup = setup,
-	.max_runtime = 10,
+	.runtime = 10,
 	.test_all = verify_gettimeofday,
 };
diff --git a/testcases/kernel/syscalls/getxattr/getxattr02.c b/testcases/kernel/syscalls/getxattr/getxattr02.c
index 5a84d876c..593ad7b8c 100644
--- a/testcases/kernel/syscalls/getxattr/getxattr02.c
+++ b/testcases/kernel/syscalls/getxattr/getxattr02.c
@@ -105,6 +105,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 10,
 	.all_filesystems = 1,
 	.needs_root = 1,
 	.mntpoint = MNTPOINT,
diff --git a/testcases/kernel/syscalls/getxattr/getxattr03.c b/testcases/kernel/syscalls/getxattr/getxattr03.c
index 1fe4ba48f..85f26402a 100644
--- a/testcases/kernel/syscalls/getxattr/getxattr03.c
+++ b/testcases/kernel/syscalls/getxattr/getxattr03.c
@@ -37,6 +37,7 @@ static void setup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 14,
 	.all_filesystems = 1,
 	.needs_root = 1,
 	.mntpoint = MNTPOINT,
diff --git a/testcases/kernel/syscalls/getxattr/getxattr04.c b/testcases/kernel/syscalls/getxattr/getxattr04.c
index 61c8826c9..27059fef0 100644
--- a/testcases/kernel/syscalls/getxattr/getxattr04.c
+++ b/testcases/kernel/syscalls/getxattr/getxattr04.c
@@ -105,7 +105,10 @@ static void setup(void)
 static struct tst_test test = {
 	.needs_root = 1,
 	.mount_device = 1,
-	.dev_fs_type = "xfs",
+	.filesystems = (struct tst_fs []){
+		{.type = "xfs"},
+		{}
+	},
 	.mntpoint = MNTPOINT,
 	.forks_child = 1,
 	.test_all = verify_getxattr,
diff --git a/testcases/kernel/syscalls/init_module/.gitignore b/testcases/kernel/syscalls/init_module/.gitignore
index 23baeb651..bb9f98258 100644
--- a/testcases/kernel/syscalls/init_module/.gitignore
+++ b/testcases/kernel/syscalls/init_module/.gitignore
@@ -2,10 +2,7 @@
 /init_module02
 /*.ko
 /*.mod.c
-/*.ko.cmd
-/*.mod.cmd
-/*.mod.o.cmd
-/*.o.cmd
-/.built-in.a.cmd
+/*.cmd
 /Module.symvers
 /modules.order
+modules.livepatch
diff --git a/testcases/kernel/syscalls/init_module/init_module.c b/testcases/kernel/syscalls/init_module/init_module.c
index 78d03b899..f14cd80b6 100644
--- a/testcases/kernel/syscalls/init_module/init_module.c
+++ b/testcases/kernel/syscalls/init_module/init_module.c
@@ -13,6 +13,8 @@
 #include <linux/proc_fs.h>
 #include <linux/kernel.h>
 
+#define DIRNAME "dummy_init"
+
 static char status[20];
 module_param_string(status, status, 20, 0444);
 
@@ -23,14 +25,14 @@ static int dummy_init(void)
 	if (!strcmp(status, "invalid"))
 		return -EINVAL;
 
-	proc_dummy = proc_mkdir("dummy", 0);
+	proc_dummy = proc_mkdir(DIRNAME, 0);
 	return 0;
 }
 module_init(dummy_init);
 
 static void dummy_exit(void)
 {
-	remove_proc_entry("dummy", 0);
+	remove_proc_entry(DIRNAME, 0);
 }
 module_exit(dummy_exit);
 
diff --git a/testcases/kernel/syscalls/init_module/init_module01.c b/testcases/kernel/syscalls/init_module/init_module01.c
index 27a1fc627..850f826e6 100644
--- a/testcases/kernel/syscalls/init_module/init_module01.c
+++ b/testcases/kernel/syscalls/init_module/init_module01.c
@@ -17,7 +17,6 @@
 #include <errno.h>
 #include "lapi/init_module.h"
 #include "tst_module.h"
-#include "tst_kconfig.h"
 
 #define MODULE_NAME	"init_module.ko"
 
@@ -28,11 +27,9 @@ static int sig_enforce;
 static void setup(void)
 {
 	int fd;
-	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
 
-	tst_kcmdline_parse(&params, 1);
-	if (params.found)
-		sig_enforce = atoi(params.value);
+	if (tst_module_signature_enforced())
+		sig_enforce = 1;
 
 	tst_module_exists(MODULE_NAME, NULL);
 
@@ -45,7 +42,6 @@ static void setup(void)
 static void run(void)
 {
 	if (sig_enforce == 1) {
-		tst_res(TINFO, "module signature is enforced");
 		TST_EXP_FAIL(init_module(buf, sb.st_size, "status=valid"), EKEYREJECTED);
 		return;
 	}
diff --git a/testcases/kernel/syscalls/init_module/init_module02.c b/testcases/kernel/syscalls/init_module/init_module02.c
index 68d9ff16b..c3979c08a 100644
--- a/testcases/kernel/syscalls/init_module/init_module02.c
+++ b/testcases/kernel/syscalls/init_module/init_module02.c
@@ -17,7 +17,6 @@
 #include <stdlib.h>
 #include <errno.h>
 #include "lapi/init_module.h"
-#include "tst_kconfig.h"
 #include "tst_module.h"
 #include "tst_capability.h"
 
@@ -53,11 +52,9 @@ static void setup(void)
 {
 	struct stat sb;
 	int fd;
-	struct tst_kcmdline_var params = TST_KCMDLINE_INIT("module.sig_enforce");
 
-	tst_kcmdline_parse(&params, 1);
-	if (params.found)
-		sig_enforce = atoi(params.value);
+	if (tst_module_signature_enforced())
+		sig_enforce = 1;
 
 	tst_module_exists(MODULE_NAME, NULL);
 
diff --git a/testcases/kernel/syscalls/inotify/inotify03.c b/testcases/kernel/syscalls/inotify/inotify03.c
index ff025b360..4ee5e9461 100644
--- a/testcases/kernel/syscalls/inotify/inotify03.c
+++ b/testcases/kernel/syscalls/inotify/inotify03.c
@@ -166,6 +166,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.needs_root = 1,
 	.format_device = 1,
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/inotify/inotify05.c b/testcases/kernel/syscalls/inotify/inotify05.c
index a1597217f..38b30878c 100644
--- a/testcases/kernel/syscalls/inotify/inotify05.c
+++ b/testcases/kernel/syscalls/inotify/inotify05.c
@@ -148,6 +148,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.needs_tmpdir = 1,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/inotify/inotify06.c b/testcases/kernel/syscalls/inotify/inotify06.c
index 7452ee47d..b0eb8cafb 100644
--- a/testcases/kernel/syscalls/inotify/inotify06.c
+++ b/testcases/kernel/syscalls/inotify/inotify06.c
@@ -116,7 +116,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
-	.max_runtime = 600,
+	.runtime = 600,
 	.needs_root = 1,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
diff --git a/testcases/kernel/syscalls/inotify/inotify07.c b/testcases/kernel/syscalls/inotify/inotify07.c
index 08ea1e06a..bcfc569a8 100644
--- a/testcases/kernel/syscalls/inotify/inotify07.c
+++ b/testcases/kernel/syscalls/inotify/inotify07.c
@@ -182,6 +182,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.needs_root = 1,
 	.mount_device = 1,
 	.needs_overlay = 1,
diff --git a/testcases/kernel/syscalls/inotify/inotify08.c b/testcases/kernel/syscalls/inotify/inotify08.c
index 9c2ecdabd..149a0a1f8 100644
--- a/testcases/kernel/syscalls/inotify/inotify08.c
+++ b/testcases/kernel/syscalls/inotify/inotify08.c
@@ -176,6 +176,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.needs_root = 1,
 	.mount_device = 1,
 	.needs_overlay = 1,
diff --git a/testcases/kernel/syscalls/inotify/inotify09.c b/testcases/kernel/syscalls/inotify/inotify09.c
index 62d529d04..e999dac39 100644
--- a/testcases/kernel/syscalls/inotify/inotify09.c
+++ b/testcases/kernel/syscalls/inotify/inotify09.c
@@ -97,7 +97,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = verify_inotify,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "d90a10e2444b"},
 		{}
diff --git a/testcases/kernel/syscalls/inotify/inotify11.c b/testcases/kernel/syscalls/inotify/inotify11.c
index b750e6c04..2e571f3a0 100644
--- a/testcases/kernel/syscalls/inotify/inotify11.c
+++ b/testcases/kernel/syscalls/inotify/inotify11.c
@@ -49,7 +49,7 @@ static void churn(void)
 	char path[10];
 	int i;
 
-	for (i = 0; i <= CHURN_FILES; ++i) {
+	for (i = 0; i < CHURN_FILES; ++i) {
 		snprintf(path, sizeof(path), "%d", i);
 		SAFE_FILE_PRINTF(path, "1");
 		SAFE_UNLINK(path);
@@ -119,6 +119,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 12,
 	.needs_tmpdir = 1,
 	.forks_child = 1,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/inotify/inotify12.c b/testcases/kernel/syscalls/inotify/inotify12.c
index 2eef545cf..208263b17 100644
--- a/testcases/kernel/syscalls/inotify/inotify12.c
+++ b/testcases/kernel/syscalls/inotify/inotify12.c
@@ -153,7 +153,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
-	.max_runtime = 10,
+	.timeout = 10,
 	.needs_tmpdir = 1,
 	.cleanup = cleanup,
 	.test = verify_inotify,
diff --git a/testcases/kernel/syscalls/io_uring/io_uring02.c b/testcases/kernel/syscalls/io_uring/io_uring02.c
index c9d4bbcb1..50206cf1f 100644
--- a/testcases/kernel/syscalls/io_uring/io_uring02.c
+++ b/testcases/kernel/syscalls/io_uring/io_uring02.c
@@ -64,13 +64,12 @@ static struct msghdr beef_header = {
 
 static void setup(void)
 {
-	char *tmpdir = tst_get_tmpdir();
+	char *tmpdir = tst_tmpdir_path();
 	int ret;
 
 	addr.sun_family = AF_UNIX;
 	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), "%s/%s", tmpdir,
 		SOCK_NAME);
-	free(tmpdir);
 
 	if (ret >= (int)sizeof(addr.sun_path))
 		tst_brk(TBROK, "Tempdir path is too long");
diff --git a/testcases/kernel/syscalls/ioctl/.gitignore b/testcases/kernel/syscalls/ioctl/.gitignore
index 5fff7a61d..1f099ff95 100644
--- a/testcases/kernel/syscalls/ioctl/.gitignore
+++ b/testcases/kernel/syscalls/ioctl/.gitignore
@@ -22,3 +22,9 @@
 /ioctl_ns06
 /ioctl_ns07
 /ioctl_sg01
+/ioctl_ficlone01
+/ioctl_ficlone02
+/ioctl_ficlone03
+/ioctl_ficlone04
+/ioctl_ficlonerange01
+/ioctl_ficlonerange02
diff --git a/testcases/kernel/syscalls/ioctl/ioctl01.c b/testcases/kernel/syscalls/ioctl/ioctl01.c
index c84a72b9a..d7886f358 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl01.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl01.c
@@ -2,7 +2,7 @@
 /*
  * Copyright (c) International Business Machines Corp., 2001
  * Copyright (c) 2020 Petr Vorel <petr.vorel@gmail.com>
- * Copyright (c) Linux Test Project, 2002-2023
+ * Copyright (c) Linux Test Project, 2002-2024
  * 07/2001 Ported by Wayne Boyer
  * 04/2002 Fixes by wjhuie
  */
@@ -59,8 +59,42 @@ static struct tcase {
 
 static void verify_ioctl(unsigned int i)
 {
-	TST_EXP_FAIL(ioctl(*(tcases[i].fd), tcases[i].request, tcases[i].s_tio),
-		     tcases[i].error, "%s", tcases[i].desc);
+	struct tcase *tc = &tcases[i];
+
+	TST_EXP_FAIL(ioctl(*(tc->fd), tc->request, tc->s_tio), tc->error, "%s",
+		     tc->desc);
+}
+
+static void test_bad_addr(unsigned int i)
+{
+	pid_t pid;
+	int status;
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		verify_ioctl(i);
+		exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFEXITED(status) && !WEXITSTATUS(status))
+		return;
+
+	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
+		tst_res(TPASS, "Child killed by expected signal");
+		return;
+	}
+
+	tst_res(TFAIL, "Child %s", tst_strstatus(status));
+}
+
+static void do_test(unsigned int i)
+{
+	if (tcases[i].error == EFAULT)
+		test_bad_addr(i);
+	else
+		verify_ioctl(i);
 }
 
 static void setup(void)
@@ -86,6 +120,7 @@ static struct tst_test test = {
 	.needs_tmpdir = 1,
 	.setup = setup,
 	.cleanup = cleanup,
-	.test = verify_ioctl,
-	.tcnt = ARRAY_SIZE(tcases)
+	.test = do_test,
+	.tcnt = ARRAY_SIZE(tcases),
+	.forks_child = 1,
 };
diff --git a/testcases/kernel/syscalls/ioctl/ioctl02.c b/testcases/kernel/syscalls/ioctl/ioctl02.c
index f3bfb239a..9337da384 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl02.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl02.c
@@ -242,6 +242,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 9,
 	.needs_root = 1,
 	.needs_checkpoints = 1,
 	.forks_child = 1,
diff --git a/testcases/kernel/syscalls/ioctl/ioctl04.c b/testcases/kernel/syscalls/ioctl/ioctl04.c
index 262c06e97..f96b22f0c 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl04.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl04.c
@@ -84,6 +84,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.format_device = 1,
 	.needs_root = 1,
 	.setup = setup,
diff --git a/testcases/kernel/syscalls/ioctl/ioctl08.c b/testcases/kernel/syscalls/ioctl/ioctl08.c
index 1fb195797..14f9354c9 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl08.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl08.c
@@ -118,6 +118,7 @@ static void setup(void)
 
 
 static struct tst_test test = {
+	.timeout = 1,
 	.test = verify_ioctl,
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
@@ -126,7 +127,10 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.mount_device = 1,
 	.mntpoint = MNTPOINT,
-	.dev_fs_type = "btrfs",
+	.filesystems = (struct tst_fs []) {
+		{.type = "btrfs"},
+		{}
+	},
 	.needs_drivers = (const char *const[]) {
 		"btrfs",
 		NULL,
diff --git a/testcases/kernel/syscalls/ioctl/ioctl09.c b/testcases/kernel/syscalls/ioctl/ioctl09.c
index 9c7921086..0d1f1072d 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl09.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl09.c
@@ -110,6 +110,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = verify_ioctl,
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_ficlone01.c b/testcases/kernel/syscalls/ioctl/ioctl_ficlone01.c
new file mode 100644
index 000000000..2574bb6a2
--- /dev/null
+++ b/testcases/kernel/syscalls/ioctl/ioctl_ficlone01.c
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that ioctl() FICLONE feature clones file content from
+ * one file to an another.
+ *
+ * [Algorithm]
+ *
+ * - populate source file
+ * - clone source content inside destination file
+ * - verify that source content has been cloned inside destination file
+ * - write a single byte inside destination file
+ * - verify that source content didn't change while destination did
+ */
+
+#include "tst_test.h"
+#include "lapi/ficlone.h"
+
+#define MNTPOINT "mnt"
+#define SRCPATH MNTPOINT "/file0"
+#define DSTPATH MNTPOINT "/file1"
+
+#define FILEDATA "qwerty"
+#define FILESIZE sizeof(FILEDATA)
+
+static int src_fd = -1;
+static int dst_fd = -1;
+
+static void run(void)
+{
+	char buff[FILESIZE];
+	struct stat src_stat;
+	struct stat dst_stat;
+
+	src_fd = SAFE_OPEN(SRCPATH, O_CREAT | O_RDWR, 0640);
+	dst_fd = SAFE_OPEN(DSTPATH, O_CREAT | O_RDWR, 0640);
+
+	tst_res(TINFO, "Writing data inside src file");
+
+	SAFE_WRITE(1, src_fd, FILEDATA, FILESIZE);
+	SAFE_FSYNC(src_fd);
+
+	TST_EXP_PASS(ioctl(dst_fd, FICLONE, src_fd));
+	if (TST_RET == -1)
+		return;
+
+	SAFE_FSYNC(dst_fd);
+
+	tst_res(TINFO, "Verifing that data is cloned between files");
+
+	SAFE_FSTAT(src_fd, &src_stat);
+	SAFE_FSTAT(dst_fd, &dst_stat);
+
+	TST_EXP_EXPR(src_stat.st_ino != dst_stat.st_ino,
+		"inode is different. %lu != %lu",
+		src_stat.st_ino,
+		dst_stat.st_ino);
+
+	TST_EXP_EQ_LI(src_stat.st_size, dst_stat.st_size);
+
+	SAFE_READ(0, dst_fd, buff, FILESIZE);
+
+	TST_EXP_EXPR(!strncmp(buff, FILEDATA, FILESIZE),
+		"dst file has the src file content (\"%s\" - %ld bytes)",
+		buff,
+		FILESIZE);
+
+	tst_res(TINFO, "Writing a byte inside dst file");
+
+	SAFE_LSEEK(dst_fd, 0, SEEK_SET);
+	SAFE_WRITE(SAFE_WRITE_ALL, dst_fd, "+", 1);
+	SAFE_FSYNC(dst_fd);
+
+	tst_res(TINFO, "Verifing that src file content didn't change");
+
+	SAFE_FSTAT(src_fd, &src_stat);
+	SAFE_FSTAT(dst_fd, &dst_stat);
+
+	TST_EXP_EQ_LI(dst_stat.st_size, src_stat.st_size);
+
+	SAFE_READ(0, src_fd, buff, FILESIZE);
+
+	TST_EXP_EXPR(!strncmp(buff, FILEDATA, FILESIZE),
+		"src file content didn't change");
+
+	SAFE_CLOSE(src_fd);
+	SAFE_CLOSE(dst_fd);
+
+	SAFE_UNLINK(SRCPATH);
+	SAFE_UNLINK(DSTPATH);
+}
+
+static void cleanup(void)
+{
+	if (src_fd != -1)
+		SAFE_CLOSE(src_fd);
+
+	if (dst_fd != -1)
+		SAFE_CLOSE(dst_fd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.cleanup = cleanup,
+	.min_kver = "4.5",
+	.needs_root = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.filesystems = (struct tst_fs []) {
+		{.type = "btrfs"},
+		{.type = "bcachefs"},
+		{
+			.type = "xfs",
+			.min_kver = "4.16",
+			.mkfs_ver = "mkfs.xfs >= 1.5.0",
+			.mkfs_opts = (const char *const []) {"-m", "reflink=1", NULL},
+		},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_ficlone02.c b/testcases/kernel/syscalls/ioctl/ioctl_ficlone02.c
new file mode 100644
index 000000000..e5d4be96f
--- /dev/null
+++ b/testcases/kernel/syscalls/ioctl/ioctl_ficlone02.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that ioctl() FICLONE/FICLONERANGE feature correctly raises
+ * EOPNOTSUPP when an unsupported filesystem is used. In particular, filesystems
+ * which don't support copy-on-write.
+ */
+
+#include "tst_test.h"
+#include "lapi/ficlone.h"
+
+#define MNTPOINT "mnt"
+#define SRCPATH MNTPOINT "/file0"
+#define DSTPATH MNTPOINT "/file1"
+
+static struct file_clone_range *clone_range;
+
+static void run(void)
+{
+	int src_fd;
+	int dst_fd;
+
+	src_fd = SAFE_OPEN(SRCPATH, O_CREAT | O_RDWR, 0640);
+	dst_fd = SAFE_OPEN(DSTPATH, O_CREAT | O_RDWR, 0640);
+
+	clone_range->src_fd = src_fd;
+
+	TST_EXP_FAIL(ioctl(dst_fd, FICLONE, src_fd), EOPNOTSUPP);
+	TST_EXP_FAIL(ioctl(dst_fd, FICLONERANGE, clone_range), EOPNOTSUPP);
+
+	SAFE_CLOSE(src_fd);
+	SAFE_CLOSE(dst_fd);
+}
+
+static void setup(void)
+{
+	struct stat sb;
+
+	SAFE_STAT(MNTPOINT, &sb);
+
+	tst_fill_file(SRCPATH, 0x00, sb.st_blksize, 1);
+
+	clone_range->src_offset = 0;
+	clone_range->src_length = sb.st_blksize;
+	clone_range->dest_offset = 0;
+}
+
+static struct tst_test test = {
+	.timeout = 10,
+	.test_all = run,
+	.setup = setup,
+	.min_kver = "4.5",
+	.needs_root = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *[]) {
+		"bcachefs",
+		"btrfs",
+		"overlayfs",
+		"nfs",
+		"xfs",
+		NULL,
+	},
+	.bufs = (struct tst_buffers []) {
+		{&clone_range, .size = sizeof(struct file_clone_range)},
+		{},
+	}
+};
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_ficlone03.c b/testcases/kernel/syscalls/ioctl/ioctl_ficlone03.c
new file mode 100644
index 000000000..b0a0f8d63
--- /dev/null
+++ b/testcases/kernel/syscalls/ioctl/ioctl_ficlone03.c
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that ioctl() FICLONE/FICLONERANGE feature correctly raises
+ * exceptions when it's supposed to.
+ */
+
+#include "tst_test.h"
+#include "lapi/ficlone.h"
+
+#define MNTPOINT "mnt"
+
+static struct file_clone_range *clone_range;
+
+static int invalid_fd = -1;
+static int rw_file = -1;
+static int ro_file = -1;
+static int wo_file = -1;
+static int dir_fd = -1;
+static int immut_fd = -1;
+static int mnt_file = -1;
+
+static struct tcase {
+	int *src_fd;
+	int *dst_fd;
+	int errno_exp;
+	char *msg;
+} tcases[] = {
+	{&invalid_fd, &rw_file, EBADF, "invalid source"},
+	{&rw_file, &invalid_fd, EBADF, "invalid destination"},
+	{&rw_file, &ro_file, EBADF, "read-only destination"},
+	{&wo_file, &rw_file, EBADF, "write-only source"},
+	{&rw_file, &dir_fd, EISDIR, "source is a directory"},
+	{&dir_fd, &rw_file, EISDIR, "destination is a directory"},
+	{&mnt_file, &immut_fd, EPERM, "destination is immutable"},
+	{&rw_file, &mnt_file, EXDEV, "destination is on a different mount"},
+	{&mnt_file, &rw_file, EXDEV, "source is on a different mount"},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+
+	TST_EXP_FAIL(ioctl(*tc->dst_fd, FICLONE, *tc->src_fd),
+		tc->errno_exp,
+		"%s", tc->msg);
+
+	clone_range->src_fd = *tc->src_fd;
+
+	TST_EXP_FAIL(ioctl(*tc->dst_fd, FICLONERANGE, clone_range),
+		tc->errno_exp,
+		"%s", tc->msg);
+}
+
+static void setup(void)
+{
+	int attr;
+	struct stat sb;
+
+	rw_file = SAFE_OPEN("ok_only", O_CREAT | O_RDWR, 0640);
+	ro_file = SAFE_OPEN("rd_only", O_CREAT | O_RDONLY, 0640);
+	wo_file = SAFE_OPEN("rw_only", O_CREAT | O_WRONLY, 0640);
+
+	if (access("mydir", F_OK) == -1)
+		SAFE_MKDIR("mydir", 0640);
+
+	dir_fd = SAFE_OPEN("mydir", O_DIRECTORY, 0640);
+
+	attr = FS_IMMUTABLE_FL;
+	immut_fd = SAFE_OPEN(MNTPOINT"/immutable", O_CREAT | O_RDWR, 0640);
+	SAFE_IOCTL(immut_fd, FS_IOC_SETFLAGS, &attr);
+
+	mnt_file = SAFE_OPEN(MNTPOINT"/file", O_CREAT | O_RDWR, 0640);
+
+	SAFE_STAT(MNTPOINT, &sb);
+
+	clone_range->src_offset = 0;
+	clone_range->src_length = sb.st_blksize;
+	clone_range->dest_offset = 0;
+}
+
+static void cleanup(void)
+{
+	int attr;
+
+	SAFE_IOCTL(immut_fd, FS_IOC_GETFLAGS, &attr);
+	attr &= ~FS_IMMUTABLE_FL;
+	SAFE_IOCTL(immut_fd, FS_IOC_SETFLAGS, &attr);
+	SAFE_CLOSE(immut_fd);
+
+	SAFE_CLOSE(rw_file);
+	SAFE_CLOSE(ro_file);
+	SAFE_CLOSE(wo_file);
+	SAFE_CLOSE(dir_fd);
+	SAFE_CLOSE(mnt_file);
+}
+
+static struct tst_test test = {
+	.timeout = 1,
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "4.5",
+	.needs_root = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.filesystems = (struct tst_fs []) {
+		{.type = "btrfs"},
+		{.type = "bcachefs"},
+		{
+			.type = "xfs",
+			.min_kver = "4.16",
+			.mkfs_ver = "mkfs.xfs >= 1.5.0",
+			.mkfs_opts = (const char *const []) {"-m", "reflink=1", NULL},
+		},
+		{}
+	},
+	.bufs = (struct tst_buffers []) {
+		{&clone_range, .size = sizeof(struct file_clone_range)},
+		{},
+	}
+};
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_ficlone04.c b/testcases/kernel/syscalls/ioctl/ioctl_ficlone04.c
new file mode 100644
index 000000000..1dcf4f05c
--- /dev/null
+++ b/testcases/kernel/syscalls/ioctl/ioctl_ficlone04.c
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that ioctl() FICLONE/FICLONERANGE feature raises the right
+ * error according with bad file descriptors.
+ */
+
+#include "tst_test.h"
+#include "lapi/ficlone.h"
+
+static void test_bad_fd(struct tst_fd *fd_src, struct tst_fd *fd_dst)
+{
+	if (fd_src->type == TST_FD_FILE && fd_src->type == fd_dst->type) {
+		tst_res(TINFO, "Skipping file: SUCCESS");
+		return;
+	}
+
+	int exp_errnos[] = {
+		EOPNOTSUPP,
+		EPERM,
+		EISDIR,
+		EBADF,
+		EINVAL,
+		EXDEV,
+	};
+
+	TST_EXP_FAIL2_ARR(ioctl(fd_dst->fd, FICLONE, fd_src->fd),
+		exp_errnos, ARRAY_SIZE(exp_errnos),
+		"ioctl(%s, FICLONE, %s)",
+		tst_fd_desc(fd_src),
+		tst_fd_desc(fd_dst));
+}
+
+static void run(void)
+{
+	TST_FD_FOREACH(fd_src) {
+		TST_FD_FOREACH(fd_dst)
+			test_bad_fd(&fd_src, &fd_dst);
+	}
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.min_kver = "4.5",
+	.needs_root = 1,
+	.needs_tmpdir = 1,
+};
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_ficlonerange01.c b/testcases/kernel/syscalls/ioctl/ioctl_ficlonerange01.c
new file mode 100644
index 000000000..707270765
--- /dev/null
+++ b/testcases/kernel/syscalls/ioctl/ioctl_ficlonerange01.c
@@ -0,0 +1,163 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that ioctl() FICLONERANGE feature clones file content from
+ * one file to an another.
+ *
+ * [Algorithm]
+ *
+ * - populate source file
+ * - clone a portion of source content inside destination file
+ * - verify that source content portion has been cloned inside destination file
+ * - write a single byte inside destination file
+ * - verify that source content didn't change while destination did
+ */
+
+#include "tst_test.h"
+#include "lapi/ficlone.h"
+
+#define MNTPOINT "mnt"
+#define SRCPATH MNTPOINT "/file0"
+#define DSTPATH MNTPOINT "/file1"
+#define CHUNKS 64
+
+static struct file_clone_range *clone_range;
+static int filesize;
+static int offset;
+static int leftsize;
+static int src_fd = -1;
+static int dst_fd = -1;
+static char *data;
+static char *buff;
+
+static void run(void)
+{
+	struct stat src_stat;
+	struct stat dst_stat;
+
+	for (int i = 0; i < filesize; i++)
+		data[i] = 'a' + (rand() % 21);
+
+	src_fd = SAFE_OPEN(SRCPATH, O_CREAT | O_RDWR, 0640);
+	dst_fd = SAFE_OPEN(DSTPATH, O_CREAT | O_RDWR, 0640);
+
+	tst_res(TINFO, "Writing data inside src file");
+
+	SAFE_WRITE(SAFE_WRITE_ALL, src_fd, data, filesize);
+	SAFE_FSYNC(src_fd);
+
+	clone_range->src_fd = src_fd;
+	TST_EXP_PASS(ioctl(dst_fd, FICLONERANGE, clone_range));
+	if (TST_RET == -1)
+		return;
+
+	SAFE_FSYNC(dst_fd);
+
+	tst_res(TINFO, "Verifing that data is cloned between files");
+
+	SAFE_FSTAT(src_fd, &src_stat);
+	SAFE_FSTAT(dst_fd, &dst_stat);
+
+	TST_EXP_EXPR(src_stat.st_ino != dst_stat.st_ino,
+		"inode is different. %lu != %lu",
+		src_stat.st_ino,
+		dst_stat.st_ino);
+
+	TST_EXP_EQ_LI(src_stat.st_size, filesize);
+	TST_EXP_EQ_LI(dst_stat.st_size, leftsize);
+
+	SAFE_READ(0, dst_fd, buff, leftsize);
+
+	TST_EXP_EXPR(!strncmp(buff, data + offset, leftsize),
+		"dst file has been cloned (%d bytes)",
+		leftsize);
+
+	tst_res(TINFO, "Writing a byte inside dst file");
+
+	SAFE_LSEEK(dst_fd, 0, SEEK_SET);
+	SAFE_WRITE(SAFE_WRITE_ALL, dst_fd, "!", 1);
+	SAFE_FSYNC(dst_fd);
+
+	tst_res(TINFO, "Verifing that src file content didn't change");
+
+	SAFE_FSTAT(src_fd, &src_stat);
+	SAFE_FSTAT(dst_fd, &dst_stat);
+
+	TST_EXP_EQ_LI(src_stat.st_size, filesize);
+	TST_EXP_EQ_LI(dst_stat.st_size, leftsize);
+
+	SAFE_LSEEK(src_fd, 0, SEEK_SET);
+	SAFE_READ(0, src_fd, buff, filesize);
+
+	TST_EXP_EXPR(!strncmp(buff, data, filesize),
+		"src file content didn't change");
+
+	SAFE_CLOSE(src_fd);
+	SAFE_CLOSE(dst_fd);
+
+	SAFE_UNLINK(SRCPATH);
+	SAFE_UNLINK(DSTPATH);
+}
+
+static void setup(void)
+{
+	struct stat sb;
+
+	SAFE_STAT(MNTPOINT, &sb);
+
+	filesize = sb.st_blksize * CHUNKS;
+	offset = filesize / 4;
+	leftsize = filesize - offset;
+
+	clone_range->src_offset = offset;
+	clone_range->src_length = leftsize;
+	clone_range->dest_offset = 0;
+
+	data = SAFE_MALLOC(filesize);
+	buff = SAFE_MALLOC(filesize);
+
+	srand(time(NULL));
+}
+
+static void cleanup(void)
+{
+	free(buff);
+	free(data);
+
+	if (src_fd != -1)
+		SAFE_CLOSE(src_fd);
+
+	if (dst_fd != -1)
+		SAFE_CLOSE(dst_fd);
+}
+
+static struct tst_test test = {
+	.timeout = 1,
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "4.5",
+	.needs_root = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.filesystems = (struct tst_fs []) {
+		{.type = "btrfs"},
+		{.type = "bcachefs"},
+		{
+			.type = "xfs",
+			.min_kver = "4.16",
+			.mkfs_ver = "mkfs.xfs >= 1.5.0",
+			.mkfs_opts = (const char *const []) {"-m", "reflink=1", NULL},
+		},
+		{}
+	},
+	.bufs = (struct tst_buffers []) {
+		{&clone_range, .size = sizeof(struct file_clone_range)},
+		{},
+	}
+};
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_ficlonerange02.c b/testcases/kernel/syscalls/ioctl/ioctl_ficlonerange02.c
new file mode 100644
index 000000000..cc1d0e031
--- /dev/null
+++ b/testcases/kernel/syscalls/ioctl/ioctl_ficlonerange02.c
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that ioctl() FICLONERANGE feature correctly raises
+ * EINVAL when:
+ * - filesystem does not support overlapping reflink ranges in the same file
+ * - filesystem does not support reflinking on bad blocks alignment
+ */
+
+#include "tst_test.h"
+#include "lapi/ficlone.h"
+
+#define MNTPOINT "mnt"
+#define SRCPATH MNTPOINT "/file0"
+#define DSTPATH MNTPOINT "/file1"
+#define CHUNKS 10
+
+static struct file_clone_range *clone_range;
+static int filesize;
+static int alignment;
+static char *data;
+
+static void run(void)
+{
+	int src_fd;
+	int dst_fd;
+
+	src_fd = SAFE_OPEN(SRCPATH, O_CREAT | O_RDWR, 0640);
+	SAFE_WRITE(SAFE_WRITE_ALL, src_fd, data, filesize);
+	SAFE_FSYNC(src_fd);
+
+	dst_fd = SAFE_OPEN(DSTPATH, O_CREAT | O_RDWR, 0640);
+
+	clone_range->src_fd = dst_fd;
+	clone_range->src_offset = 0;
+	clone_range->src_length = filesize;
+	clone_range->dest_offset = 0;
+
+	TST_EXP_FAIL(ioctl(dst_fd, FICLONERANGE, clone_range), EINVAL,
+		"overlapping reflink ranges in the same file");
+
+	clone_range->src_fd = src_fd;
+	clone_range->src_offset = 0;
+	clone_range->src_length = alignment - 1;
+	clone_range->dest_offset = 0;
+
+	TST_EXP_FAIL(ioctl(dst_fd, FICLONERANGE, clone_range), EINVAL,
+		"bad blocks alignment");
+
+	SAFE_CLOSE(src_fd);
+	SAFE_CLOSE(dst_fd);
+}
+
+static void setup(void)
+{
+	struct stat sb;
+
+	SAFE_STAT(MNTPOINT, &sb);
+
+	alignment = sb.st_blksize;
+	filesize = alignment * CHUNKS;
+
+	data = SAFE_MALLOC(filesize);
+}
+
+static void cleanup(void)
+{
+	free(data);
+}
+
+static struct tst_test test = {
+	.timeout = 4,
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "4.5",
+	.needs_root = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.filesystems = (struct tst_fs []) {
+		{.type = "btrfs"},
+		{.type = "bcachefs"},
+		{
+			.type = "xfs",
+			.min_kver = "4.16",
+			.mkfs_ver = "mkfs.xfs >= 1.5.0",
+			.mkfs_opts = (const char *const []) {"-m", "reflink=1", NULL},
+		},
+		{}
+	},
+	.bufs = (struct tst_buffers []) {
+		{&clone_range, .size = sizeof(struct file_clone_range)},
+		{},
+	}
+};
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_loop01.c b/testcases/kernel/syscalls/ioctl/ioctl_loop01.c
index 6e259fb15..c3fb9f583 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl_loop01.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl_loop01.c
@@ -27,7 +27,8 @@
 #include "lapi/loop.h"
 #include "tst_test.h"
 
-static char dev_path[1024], backing_path[1024], backing_file_path[1024];
+static char dev_path[1024], backing_path[1024];
+static char *backing_file_path;
 static int dev_num, attach_flag, dev_fd, parted_sup;
 
 /*
@@ -125,7 +126,7 @@ static void setup(void)
 	sprintf(autoclear_path, "/sys/block/loop%d/loop/autoclear", dev_num);
 	sprintf(backing_path, "/sys/block/loop%d/loop/backing_file", dev_num);
 	sprintf(sys_loop_partpath, "/sys/block/loop%d/loop%dp1", dev_num, dev_num);
-	sprintf(backing_file_path, "%s/test.img", tst_get_tmpdir());
+	backing_file_path = tst_tmpdir_genpath("test.img");
 	sprintf(loop_partpath, "%sp1", dev_path);
 	dev_fd = SAFE_OPEN(dev_path, O_RDWR);
 }
@@ -139,6 +140,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
+	.timeout = 1,
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_all = verify_ioctl_loop,
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_loop02.c b/testcases/kernel/syscalls/ioctl/ioctl_loop02.c
index ce50c2ec5..dc983ac5f 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl_loop02.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl_loop02.c
@@ -27,7 +27,9 @@
 #include "tst_test.h"
 
 static int file_fd, file_change_fd, file_fd_invalid;
-static char backing_path[1024], backing_file_path[1024], backing_file_change_path[1024];
+static char backing_path[1024];
+static char *backing_file_path;
+static char *backing_file_change_path;
 static int attach_flag, dev_fd, loop_configure_sup = 1;
 static char loop_ro_path[1024], dev_path[1024];
 static struct loop_config loopconfig;
@@ -110,7 +112,6 @@ static void setup(void)
 	int dev_num;
 	int ret;
 
-	char *tmpdir = tst_get_tmpdir();
 	dev_num = tst_find_free_loopdev(dev_path, sizeof(dev_path));
 	if (dev_num < 0)
 		tst_brk(TBROK, "Failed to find free loop device");
@@ -120,12 +121,10 @@ static void setup(void)
 	tst_fill_file("test2.img", 0, 2048, 20);
 
 	sprintf(backing_path, "/sys/block/loop%d/loop/backing_file", dev_num);
-	sprintf(backing_file_path, "%s/test.img", tmpdir);
-	sprintf(backing_file_change_path, "%s/test1.img", tmpdir);
+	backing_file_path = tst_tmpdir_genpath("test.img");
+	backing_file_change_path = tst_tmpdir_genpath("test1.img");
 	sprintf(loop_ro_path, "/sys/block/loop%d/ro", dev_num);
 
-	free(tmpdir);
-
 	file_change_fd = SAFE_OPEN("test1.img", O_RDWR);
 	file_fd_invalid = SAFE_OPEN("test2.img", O_RDWR);
 
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_loop05.c b/testcases/kernel/syscalls/ioctl/ioctl_loop05.c
index 3a5d5afef..184462464 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl_loop05.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl_loop05.c
@@ -37,7 +37,8 @@
 #define DIO_MESSAGE "In dio mode"
 #define NON_DIO_MESSAGE "In non dio mode"
 
-static char dev_path[1024], sys_loop_diopath[1024], backing_file_path[1024];
+static char dev_path[1024], sys_loop_diopath[1024];
+static char *backing_file_path;
 static int dev_num, dev_fd, block_devfd, attach_flag, logical_block_size;
 
 static void check_dio_value(int flag)
@@ -124,7 +125,7 @@ static void setup(void)
 	 *   size of loop is bigger than the backing device's and the loop
 	 *   needn't transform transfer.
 	 */
-	sprintf(backing_file_path, "%s/test.img", tst_get_tmpdir());
+	backing_file_path = tst_tmpdir_genpath("test.img");
 	tst_find_backing_dev(backing_file_path, bd_path, sizeof(bd_path));
 	block_devfd = SAFE_OPEN(bd_path, O_RDWR);
 	SAFE_IOCTL(block_devfd, BLKSSZGET, &logical_block_size);
diff --git a/testcases/kernel/syscalls/ioctl/ioctl_sg01.c b/testcases/kernel/syscalls/ioctl/ioctl_sg01.c
index d130e7130..1c5039cf0 100644
--- a/testcases/kernel/syscalls/ioctl/ioctl_sg01.c
+++ b/testcases/kernel/syscalls/ioctl/ioctl_sg01.c
@@ -128,7 +128,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 3600,
+	.timeout = 3600,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "a45b599ad808"},
 		{"CVE", "2018-1000204"},
diff --git a/testcases/kernel/syscalls/ipc/msgctl/Makefile b/testcases/kernel/syscalls/ipc/msgctl/Makefile
index 6b2b26d05..baa2a48e6 100644
--- a/testcases/kernel/syscalls/ipc/msgctl/Makefile
+++ b/testcases/kernel/syscalls/ipc/msgctl/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/msgget/Makefile b/testcases/kernel/syscalls/ipc/msgget/Makefile
index 6b2b26d05..baa2a48e6 100644
--- a/testcases/kernel/syscalls/ipc/msgget/Makefile
+++ b/testcases/kernel/syscalls/ipc/msgget/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/msgrcv/Makefile b/testcases/kernel/syscalls/ipc/msgrcv/Makefile
index 6b2b26d05..baa2a48e6 100644
--- a/testcases/kernel/syscalls/ipc/msgrcv/Makefile
+++ b/testcases/kernel/syscalls/ipc/msgrcv/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/msgsnd/Makefile b/testcases/kernel/syscalls/ipc/msgsnd/Makefile
index 63aee01d4..0b7b7bd40 100644
--- a/testcases/kernel/syscalls/ipc/msgsnd/Makefile
+++ b/testcases/kernel/syscalls/ipc/msgsnd/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/msgsnd/msgsnd01.c b/testcases/kernel/syscalls/ipc/msgsnd/msgsnd01.c
index 8232f0cac..e6b659f15 100644
--- a/testcases/kernel/syscalls/ipc/msgsnd/msgsnd01.c
+++ b/testcases/kernel/syscalls/ipc/msgsnd/msgsnd01.c
@@ -1,11 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) International Business Machines Corp., 2001
+ * Copyright (c) Linux Test Project, 2002-2024
  */
 
-/*
- * DESCRIPTION
- * test that msgsnd() enqueues a message correctly.
+/*\
+ * [Description]
+ *
+ * Verify that msgsnd(2) enqueues a message correctly.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/ipc/msgsnd/msgsnd05.c b/testcases/kernel/syscalls/ipc/msgsnd/msgsnd05.c
index f048fa698..13db01c8a 100644
--- a/testcases/kernel/syscalls/ipc/msgsnd/msgsnd05.c
+++ b/testcases/kernel/syscalls/ipc/msgsnd/msgsnd05.c
@@ -1,15 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) International Business Machines Corp., 2001
+ * Copyright (c) Linux Test Project, 2002-2024
  */
 
-/*
- * DESCRIPTION
- * 1) msgsnd(2) fails and sets errno to EAGAIN if the message can't be
- *    sent due to the msg_qbytes limit for the queue and IPC_NOWAIT is
- *    specified.
- * 2) msgsnd(2) fails and sets errno to EINTR if msgsnd(2) sleeps on a
- *    full message queue condition and the process catches a signal.
+/*\
+ * [Description]
+ *
+ * Verify that msgsnd(2) fails and sets correct errno:
+ *
+ * - EAGAIN if the message can't be sent due to the msg_qbytes limit for the
+ *   queue and IPC_NOWAIT is specified
+ * - EINTR if msgsnd(2) sleeps on a full message queue condition and the process
+ *   catches a signal
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/ipc/msgstress/msgstress01.c b/testcases/kernel/syscalls/ipc/msgstress/msgstress01.c
index b6a64cf4f..2ceea5846 100644
--- a/testcases/kernel/syscalls/ipc/msgstress/msgstress01.c
+++ b/testcases/kernel/syscalls/ipc/msgstress/msgstress01.c
@@ -214,7 +214,7 @@ static void run(void)
 			break;
 
 		if (!tst_remaining_runtime()) {
-			tst_res(TWARN, "Out of runtime during forking...");
+			tst_res(TCONF, "Out of runtime during forking...");
 			*stop = 1;
 			break;
 		}
@@ -243,7 +243,7 @@ static void run(void)
 	remove_queues();
 
 	if (!(*fail))
-		tst_res(TPASS, "Test passed. All messages have been received");
+		tst_res(TPASS, "Some messages received");
 }
 
 static void setup(void)
@@ -260,7 +260,7 @@ static void setup(void)
 	free_msgs = total_msg - get_used_sysvipc();
 
 	/* We remove 10% of free pids, just to be sure
-	 * we won't saturate the sysyem with processes.
+	 * we won't saturate the system with processes.
 	 */
 	free_pids = tst_get_free_pids() / 2.1;
 
@@ -311,7 +311,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.forks_child = 1,
-	.max_runtime = 180,
+	.runtime = 180,
 	.options = (struct tst_option[]) {
 		{"n:", &str_num_messages, "Number of messages to send (default: 1000)"},
 		{"l:", &str_num_iterations, "Number iterations per message (default: "
diff --git a/testcases/kernel/syscalls/ipc/semctl/Makefile b/testcases/kernel/syscalls/ipc/semctl/Makefile
index 42d00f1cd..aa11e7003 100644
--- a/testcases/kernel/syscalls/ipc/semctl/Makefile
+++ b/testcases/kernel/syscalls/ipc/semctl/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpipc ltpnewipc
+LTPLIBS = ipc newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/semget/Makefile b/testcases/kernel/syscalls/ipc/semget/Makefile
index b1201281d..d1e778f98 100644
--- a/testcases/kernel/syscalls/ipc/semget/Makefile
+++ b/testcases/kernel/syscalls/ipc/semget/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/semget/semget05.c b/testcases/kernel/syscalls/ipc/semget/semget05.c
index dd9a6285d..b49e5653c 100644
--- a/testcases/kernel/syscalls/ipc/semget/semget05.c
+++ b/testcases/kernel/syscalls/ipc/semget/semget05.c
@@ -43,7 +43,7 @@ static void setup(void)
 	SAFE_FILE_SCANF("/proc/sys/kernel/sem", "%*d %*d %*d %d", &maxsems);
 
 	/* Prevent timeout due to high semaphore array limit */
-	tst_set_max_runtime(maxsems / 200);
+	tst_set_runtime(maxsems / 200);
 
 	sem_id_arr = SAFE_MALLOC((maxsems - used_cnt) * sizeof(int));
 	for (num = 0; num < maxsems - used_cnt; num++) {
diff --git a/testcases/kernel/syscalls/ipc/semop/Makefile b/testcases/kernel/syscalls/ipc/semop/Makefile
index 43afffb3f..5d082e912 100644
--- a/testcases/kernel/syscalls/ipc/semop/Makefile
+++ b/testcases/kernel/syscalls/ipc/semop/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/shmat/Makefile b/testcases/kernel/syscalls/ipc/shmat/Makefile
index 6b2b26d05..baa2a48e6 100644
--- a/testcases/kernel/syscalls/ipc/shmat/Makefile
+++ b/testcases/kernel/syscalls/ipc/shmat/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/shmctl/Makefile b/testcases/kernel/syscalls/ipc/shmctl/Makefile
index f79ffa6dc..d4278dcd7 100644
--- a/testcases/kernel/syscalls/ipc/shmctl/Makefile
+++ b/testcases/kernel/syscalls/ipc/shmctl/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 shmctl05: CFLAGS += -pthread
 shmctl05: LDLIBS += -lrt
diff --git a/testcases/kernel/syscalls/ipc/shmctl/shmctl05.c b/testcases/kernel/syscalls/ipc/shmctl/shmctl05.c
index ca668aaf7..6d9a53b9b 100644
--- a/testcases/kernel/syscalls/ipc/shmctl/shmctl05.c
+++ b/testcases/kernel/syscalls/ipc/shmctl/shmctl05.c
@@ -106,7 +106,7 @@ static void cleanup(void)
 }
 
 static struct tst_test test = {
-	.max_runtime = 10,
+	.runtime = 10,
 	.setup = setup,
 	.test_all = do_test,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/ipc/shmdt/Makefile b/testcases/kernel/syscalls/ipc/shmdt/Makefile
index b1201281d..d1e778f98 100644
--- a/testcases/kernel/syscalls/ipc/shmdt/Makefile
+++ b/testcases/kernel/syscalls/ipc/shmdt/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/ipc/shmget/Makefile b/testcases/kernel/syscalls/ipc/shmget/Makefile
index b1201281d..d1e778f98 100644
--- a/testcases/kernel/syscalls/ipc/shmget/Makefile
+++ b/testcases/kernel/syscalls/ipc/shmget/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir              ?= ../../../../..
 
-LTPLIBS = ltpnewipc
+LTPLIBS = newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/kcmp/kcmp01.c b/testcases/kernel/syscalls/kcmp/kcmp01.c
index 0e7cc7a22..c8fd48466 100644
--- a/testcases/kernel/syscalls/kcmp/kcmp01.c
+++ b/testcases/kernel/syscalls/kcmp/kcmp01.c
@@ -1,14 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
+ * Copyright (c) Linux Test Project, 2015-2024
  */
 
- /* Description:
- *   Verify that:
- *		1) kcmp returns 0 with two process and two fd refering to the
- *			same open file
- *		2) kcmp doesn't return 0 with two process and two fd not
- *		   refering to the same open file
+/*\
+ * [Description]
+ *
+ * Verify that
+ *
+ * 1. kcmp() returns 0 with two process and two file descriptors refering to the
+ * same open file
+ * 2. kcmp() doesn't return 0 with two process and two file descriptors not
+ * refering to the same open file
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/kcmp/kcmp02.c b/testcases/kernel/syscalls/kcmp/kcmp02.c
index 076b4a723..d5696b70c 100644
--- a/testcases/kernel/syscalls/kcmp/kcmp02.c
+++ b/testcases/kernel/syscalls/kcmp/kcmp02.c
@@ -1,16 +1,20 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2015 Cedric Hnyda <chnyda@suse.com>
+ * Copyright (c) Linux Test Project, 2015-2024
  */
 
- /* Description:
- *   Verify that:
- *		1) kcmp fails with bad pid
- *		2) kcmp fails with invalid flag
- *		3) kcmp fails with invalid flag
- *		4) kcmp fails with invalid flag
- *		5) kcmp fails with invalid flag
- *		6) kcmp fails with invalid fd
+/*\
+ * [Description]
+ *
+ * Verify that, kcmp() returns -1 and sets errno to
+ *
+ * 1. ESRCH if pid does not exist
+ * 2. EINVAL if type is invalid (KCMP_TYPES + 1)
+ * 3. EINVAL if type is invalid (-1)
+ * 4. EINVAL if type is invalid (INT_MIN)
+ * 5. EINVAL if type is invalid (INT_MAX)
+ * 6. EBADF if file descriptor is invalid
  */
 
 #define _GNU_SOURCE
@@ -33,20 +37,22 @@ static int fd_fake = -1;
 #include <sys/wait.h>
 #include <limits.h>
 
+#define TYPE_DESC(x) .type = x, .desc = #x
 static struct test_case {
 	int *pid1;
 	int *pid2;
 	int type;
+	char *desc;
 	int *fd1;
 	int *fd2;
 	int exp_errno;
 } test_cases[] = {
-	{&pid1, &pid_unused, KCMP_FILE, &fd1, &fd2, ESRCH},
-	{&pid1, &pid1, KCMP_TYPES + 1, &fd1, &fd2, EINVAL},
-	{&pid1, &pid1, -1, &fd1, &fd2, EINVAL},
-	{&pid1, &pid1, INT_MIN, &fd1, &fd2, EINVAL},
-	{&pid1, &pid1, INT_MAX, &fd1, &fd2, EINVAL},
-	{&pid1, &pid1, KCMP_FILE, &fd1, &fd_fake, EBADF}
+	{&pid1, &pid_unused, TYPE_DESC(KCMP_FILE), &fd1, &fd2, ESRCH},
+	{&pid1, &pid1, TYPE_DESC(KCMP_TYPES + 1), &fd1, &fd2, EINVAL},
+	{&pid1, &pid1, TYPE_DESC(-1), &fd1, &fd2, EINVAL},
+	{&pid1, &pid1, TYPE_DESC(INT_MIN), &fd1, &fd2, EINVAL},
+	{&pid1, &pid1, TYPE_DESC(INT_MAX), &fd1, &fd2, EINVAL},
+	{&pid1, &pid1, TYPE_DESC(KCMP_FILE), &fd1, &fd_fake, EBADF}
 };
 
 static void setup(void)
@@ -69,24 +75,11 @@ static void cleanup(void)
 
 static void verify_kcmp(unsigned int n)
 {
-	struct test_case *test = &test_cases[n];
+	struct test_case *tc = &test_cases[n];
 
-	TEST(kcmp(*(test->pid1), *(test->pid2), test->type,
-		  *(test->fd1), *(test->fd2)));
-
-	if (TST_RET != -1) {
-		tst_res(TFAIL, "kcmp() succeeded unexpectedly");
-		return;
-	}
-
-	if (test->exp_errno == TST_ERR) {
-		tst_res(TPASS | TTERRNO, "kcmp() returned the expected value");
-		return;
-	}
-
-	tst_res(TFAIL | TTERRNO,
-		"kcmp() got unexpected return value: expected: %d - %s",
-			test->exp_errno, tst_strerrno(test->exp_errno));
+	TST_EXP_FAIL(kcmp(*(tc->pid1), *(tc->pid2), tc->type,
+		  *(tc->fd1), *(tc->fd2)), tc->exp_errno, "kcmp(%d,%d,%s,%d,%d)",
+				 *tc->pid1, *tc->pid2, tc->desc, *tc->fd1, *tc->fd2);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/kcmp/kcmp03.c b/testcases/kernel/syscalls/kcmp/kcmp03.c
index 7af5cb150..37d5118d5 100644
--- a/testcases/kernel/syscalls/kcmp/kcmp03.c
+++ b/testcases/kernel/syscalls/kcmp/kcmp03.c
@@ -1,17 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2016 Xiao Yang <yangx.jy@cn.fujitsu.com>
+ * Copyright (c) Linux Test Project, 2016-2024
  */
 
- /*
- * Testname: kcmp03.c
+/*\
+ * [Description]
  *
- * Description:
- * 1) kcmp() returns 0 if the processes share the same file system information.
- * 2) kcmp() returns 0 if the processes share I/O context.
- * 3) kcmp() returns 0 if the processes share the same list of System V
- *    semaphore undo operations.
- * 4) kcmp() returns 0 if the processes share the same address space.
+ * Verify that, kcmp() returns 0 if the processes
+ *
+ * 1. share the same file system information
+ * 2. share I/O context
+ * 3. share the same list of System V semaphore undo operations
+ * 4. share the same address space
  */
 
 #define _GNU_SOURCE
@@ -29,14 +30,16 @@ static int pid1;
 static int pid2;
 static void *stack;
 
+#define ARGS(x, y) .clone_type = x, .kcmp_type = y, .desc = #x ", " #y
 static struct tcase {
 	int clone_type;
 	int kcmp_type;
+	char *desc;
 } tcases[] = {
-	{CLONE_VM, KCMP_VM},
-	{CLONE_FS, KCMP_FS},
-	{CLONE_IO, KCMP_IO},
-	{CLONE_SYSVSEM, KCMP_SYSVSEM}
+	{ARGS(CLONE_VM, KCMP_VM)},
+	{ARGS(CLONE_FS, KCMP_FS)},
+	{ARGS(CLONE_IO, KCMP_IO)},
+	{ARGS(CLONE_SYSVSEM, KCMP_SYSVSEM)}
 };
 
 static void setup(void)
@@ -52,28 +55,17 @@ static void cleanup(void)
 static int do_child(void *arg)
 {
 	pid2 = getpid();
-
-	TEST(kcmp(pid1, pid2, *(int *)arg, 0, 0));
-	if (TST_RET == -1) {
-		tst_res(TFAIL | TTERRNO, "kcmp() failed unexpectedly");
-		return 0;
-	}
-
-	if (TST_RET == 0)
-		tst_res(TPASS, "kcmp() returned the expected value");
-	else
-		tst_res(TFAIL, "kcmp() returned the unexpected value");
-
+	TST_EXP_PASS(kcmp(pid1, pid2, *(int *)arg, 0, 0));
 	return 0;
 }
 
 static void verify_kcmp(unsigned int n)
 {
 	int res;
-
 	struct tcase *tc = &tcases[n];
 
 	pid1 = getpid();
+	tst_res(TINFO, "Testing %s", tc->desc);
 
 	res = ltp_clone(tc->clone_type | SIGCHLD, do_child, &tc->kcmp_type,
 			STACK_SIZE, stack);
diff --git a/testcases/kernel/syscalls/keyctl/keyctl02.c b/testcases/kernel/syscalls/keyctl/keyctl02.c
index fd3f86bbc..788e9657c 100644
--- a/testcases/kernel/syscalls/keyctl/keyctl02.c
+++ b/testcases/kernel/syscalls/keyctl/keyctl02.c
@@ -160,7 +160,7 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 60,
+	.runtime = 60,
 	.test_all = do_test,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "b4a1b4f5047e"},
diff --git a/testcases/kernel/syscalls/kill/Makefile b/testcases/kernel/syscalls/kill/Makefile
index 0cc064b32..369eec8f2 100644
--- a/testcases/kernel/syscalls/kill/Makefile
+++ b/testcases/kernel/syscalls/kill/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpipc ltpnewipc
+LTPLIBS = ipc newipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/landlock/.gitignore b/testcases/kernel/syscalls/landlock/.gitignore
new file mode 100644
index 000000000..fc7317394
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/.gitignore
@@ -0,0 +1,9 @@
+landlock_exec
+landlock01
+landlock02
+landlock03
+landlock04
+landlock05
+landlock06
+landlock07
+landlock08
diff --git a/testcases/kernel/syscalls/landlock/Makefile b/testcases/kernel/syscalls/landlock/Makefile
new file mode 100644
index 000000000..3734d1034
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+
+landlock07: LDLIBS += $(KEYUTILS_LIBS)
+
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/landlock/landlock01.c b/testcases/kernel/syscalls/landlock/landlock01.c
new file mode 100644
index 000000000..d0d68c8e4
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock01.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that landlock_create_ruleset syscall fails with the right
+ * error codes:
+ *
+ * - EINVAL Unknown flags, or unknown access, or too small size
+ * - E2BIG size is too big
+ * - EFAULT attr was not a valid address
+ * - ENOMSG Empty accesses (i.e., attr->handled_access_fs is 0)
+ */
+
+#include "landlock_common.h"
+
+static struct tst_landlock_ruleset_attr_abi1 *ruleset_attr;
+static struct tst_landlock_ruleset_attr_abi1 *null_attr;
+static size_t rule_size;
+static size_t rule_small_size;
+static size_t rule_big_size;
+
+static struct tcase {
+	struct tst_landlock_ruleset_attr_abi1 **attr;
+	uint64_t access_fs;
+	size_t *size;
+	uint32_t flags;
+	int exp_errno;
+	char *msg;
+} tcases[] = {
+	{&ruleset_attr, -1, &rule_size, 0, EINVAL, "Unknown access"},
+	{&ruleset_attr, 0, &rule_small_size, 0, EINVAL, "Size is too small"},
+	{&ruleset_attr, 0, &rule_size, -1, EINVAL, "Unknown flags"},
+	{&ruleset_attr, 0, &rule_big_size, 0, E2BIG, "Size is too big"},
+	{&null_attr,    0, &rule_size, 0, EFAULT, "Invalid attr address"},
+	{&ruleset_attr, 0, &rule_size, 0, ENOMSG, "Empty accesses"},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+
+	if (*tc->attr)
+		(*tc->attr)->handled_access_fs = tc->access_fs;
+
+	TST_EXP_FAIL(tst_syscall(__NR_landlock_create_ruleset,
+			*tc->attr, *tc->size, tc->flags),
+		tc->exp_errno,
+		"%s",
+		tc->msg);
+
+	if (TST_RET >= 0)
+		SAFE_CLOSE(TST_RET);
+}
+
+static void setup(void)
+{
+	verify_landlock_is_enabled();
+
+	rule_size = sizeof(struct tst_landlock_ruleset_attr_abi1);
+	rule_small_size = rule_size - 1;
+
+	rule_big_size = SAFE_SYSCONF(_SC_PAGESIZE) + 1;
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.needs_root = 1,
+	.bufs = (struct tst_buffers []) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock02.c b/testcases/kernel/syscalls/landlock/landlock02.c
new file mode 100644
index 000000000..e1e3228b5
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock02.c
@@ -0,0 +1,184 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that landlock_add_rule syscall fails with the right
+ * error codes:
+ *
+ * - EINVAL flags is not 0, or the rule accesses are inconsistent
+ * - ENOMSG Empty accesses (i.e., rule_attr->allowed_access is 0)
+ * - EBADF ruleset_fd  is  not  a  file  descriptor  for  the  current  thread,
+ *   or a member of rule_attr is not a file descriptor as expected
+ * - EBADFD ruleset_fd is not a ruleset file descriptor, or a member of
+ *   rule_attr is not the expected file descriptor type
+ * - EFAULT rule_attr was not a valid address
+ */
+
+#include "landlock_common.h"
+
+static struct tst_landlock_ruleset_attr_abi1 *attr_abi1;
+static struct tst_landlock_ruleset_attr_abi4 *attr_abi4;
+static struct landlock_path_beneath_attr *path_beneath_attr;
+static struct landlock_path_beneath_attr *rule_null;
+static struct landlock_net_port_attr *net_port_attr;
+static int ruleset_fd;
+static int invalid_fd = -1;
+static int abi_current;
+
+static struct tcase {
+	int *fd;
+	int rule_type;
+	struct landlock_path_beneath_attr **path_attr;
+	struct landlock_net_port_attr **net_attr;
+	int access;
+	int parent_fd;
+	int net_port;
+	uint32_t flags;
+	int exp_errno;
+	int abi_ver;
+	char *msg;
+} tcases[] = {
+	{
+		.fd = &ruleset_fd,
+		.path_attr = &path_beneath_attr,
+		.access = LANDLOCK_ACCESS_FS_EXECUTE,
+		.flags = 1,
+		.exp_errno = EINVAL,
+		.abi_ver = 1,
+		.msg = "Invalid flags"
+	},
+	{
+		.fd = &ruleset_fd,
+		.path_attr = &path_beneath_attr,
+		.access = LANDLOCK_ACCESS_FS_EXECUTE,
+		.exp_errno = EINVAL,
+		.abi_ver = 1,
+		.msg = "Invalid rule type"
+	},
+	{
+		.fd = &ruleset_fd,
+		.rule_type = LANDLOCK_RULE_PATH_BENEATH,
+		.path_attr = &path_beneath_attr,
+		.exp_errno = ENOMSG,
+		.abi_ver = 1,
+		.msg = "Empty accesses"
+	},
+	{
+		.fd = &invalid_fd,
+		.path_attr = &path_beneath_attr,
+		.access = LANDLOCK_ACCESS_FS_EXECUTE,
+		.exp_errno = EBADF,
+		.abi_ver = 1,
+		.msg = "Invalid file descriptor"
+	},
+	{
+		.fd = &ruleset_fd,
+		.rule_type = LANDLOCK_RULE_PATH_BENEATH,
+		.path_attr = &path_beneath_attr,
+		.access = LANDLOCK_ACCESS_FS_EXECUTE,
+		.parent_fd = -1,
+		.exp_errno = EBADF,
+		.abi_ver = 1,
+		.msg = "Invalid parent fd"
+	},
+	{
+		.fd = &ruleset_fd,
+		.rule_type = LANDLOCK_RULE_PATH_BENEATH,
+		.path_attr = &rule_null,
+		.exp_errno = EFAULT,
+		.abi_ver = 1,
+		.msg = "Invalid rule attr"
+	},
+	{
+		.fd = &ruleset_fd,
+		.rule_type = LANDLOCK_RULE_NET_PORT,
+		.net_attr = &net_port_attr,
+		.access = LANDLOCK_ACCESS_FS_EXECUTE,
+		.net_port = 448,
+		.exp_errno = EINVAL,
+		.abi_ver = 4,
+		.msg = "Invalid access rule for network type"
+	},
+	{
+		.fd = &ruleset_fd,
+		.rule_type = LANDLOCK_RULE_NET_PORT,
+		.net_attr = &net_port_attr,
+		.access = LANDLOCK_ACCESS_NET_BIND_TCP,
+		.net_port = INT16_MAX + 1,
+		.exp_errno = EINVAL,
+		.abi_ver = 4,
+		.msg = "Socket port greater than 65535"
+	},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+	void *attr = NULL;
+
+	if (tc->abi_ver > abi_current) {
+		tst_res(TCONF, "Minimum ABI required: %d", tc->abi_ver);
+		return;
+	}
+
+	if (tc->path_attr && *tc->path_attr) {
+		(*tc->path_attr)->allowed_access = tc->access;
+		(*tc->path_attr)->parent_fd = tc->parent_fd;
+
+		attr = *tc->path_attr;
+	} else if (tc->net_attr && *tc->net_attr) {
+		(*tc->net_attr)->allowed_access = tc->access;
+		(*tc->net_attr)->port = tc->net_port;
+
+		attr = *tc->net_attr;
+	}
+
+	TST_EXP_FAIL(tst_syscall(__NR_landlock_add_rule,
+		*tc->fd, tc->rule_type, attr, tc->flags),
+		tc->exp_errno, "%s", tc->msg);
+}
+
+static void setup(void)
+{
+	abi_current = verify_landlock_is_enabled();
+
+	attr_abi1->handled_access_fs =
+		attr_abi4->handled_access_fs = LANDLOCK_ACCESS_FS_EXECUTE;
+
+	if (abi_current < 4) {
+		ruleset_fd = TST_EXP_FD_SILENT(tst_syscall(__NR_landlock_create_ruleset,
+			attr_abi1, sizeof(struct tst_landlock_ruleset_attr_abi1), 0));
+	} else {
+		ruleset_fd = TST_EXP_FD_SILENT(tst_syscall(__NR_landlock_create_ruleset,
+			attr_abi4, sizeof(struct tst_landlock_ruleset_attr_abi4), 0));
+	}
+}
+
+static void cleanup(void)
+{
+	if (ruleset_fd != -1)
+		SAFE_CLOSE(ruleset_fd);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+	.bufs = (struct tst_buffers []) {
+		{&attr_abi1, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{&attr_abi4, .size = sizeof(struct tst_landlock_ruleset_attr_abi4)},
+		{&path_beneath_attr, .size = sizeof(struct landlock_path_beneath_attr)},
+		{&net_port_attr, .size = sizeof(struct landlock_net_port_attr)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock03.c b/testcases/kernel/syscalls/landlock/landlock03.c
new file mode 100644
index 000000000..150c8cc4e
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock03.c
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that landlock_restrict_self syscall fails with the right
+ * error codes:
+ *
+ * - EINVAL flags is not 0
+ * - EBADF ruleset_fd is not a file descriptor for the current thread
+ * - EBADFD ruleset_fd is not a ruleset file descriptor
+ * - EPERM ruleset doesn't have CAP_SYS_ADMIN in its namespace
+ * - E2BIG The maximum number of stacked rulesets is reached for the current
+ *   thread
+ */
+
+#include "landlock_common.h"
+
+#define MAX_STACKED_RULESETS 16
+
+static struct tst_landlock_ruleset_attr_abi1 *ruleset_attr;
+static int ruleset_fd = -1;
+static int ruleset_invalid = -1;
+static int file_fd = -1;
+
+#define ID_NAME(x) .id = x, .name = #x
+static struct tst_cap dropadmin = {
+	.action = TST_CAP_DROP,
+	ID_NAME(CAP_SYS_ADMIN),
+};
+
+static struct tst_cap needadmin = {
+	.action = TST_CAP_REQ,
+	ID_NAME(CAP_SYS_ADMIN),
+};
+
+static struct tcase {
+	int *fd;
+	uint32_t flags;
+	int exp_errno;
+	char *msg;
+} tcases[] = {
+	{&ruleset_fd, -1, EINVAL, "Invalid flags"},
+	{&ruleset_invalid, 0, EBADF, "Invalid file descriptor"},
+	{&file_fd, 0, EBADFD, "Not a ruleset file descriptor"},
+	{&ruleset_fd, 0, EPERM, "File descriptor doesn't have CAP_SYS_ADMIN"},
+	{&ruleset_fd, 0, E2BIG, "Maximum number of stacked rulesets is reached"},
+};
+
+static void run_child(struct tcase *tc)
+{
+	if (tc->exp_errno == EPERM)
+		tst_cap_action(&dropadmin);
+
+	if (tc->exp_errno == E2BIG) {
+		for (int i = 0; i < MAX_STACKED_RULESETS; i++) {
+			TST_EXP_PASS_SILENT(tst_syscall(__NR_landlock_restrict_self,
+				*tc->fd, tc->flags));
+			if (TST_RET == -1)
+				return;
+		}
+	}
+
+	TST_EXP_FAIL(tst_syscall(__NR_landlock_restrict_self, *tc->fd, tc->flags),
+		tc->exp_errno,
+		"%s", tc->msg);
+
+	if (tc->exp_errno == EPERM)
+		tst_cap_action(&needadmin);
+}
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+
+	if (!SAFE_FORK()) {
+		run_child(tc);
+		_exit(0);
+	}
+}
+
+static void setup(void)
+{
+	verify_landlock_is_enabled();
+
+	ruleset_attr->handled_access_fs = LANDLOCK_ACCESS_FS_EXECUTE;
+
+	ruleset_fd = TST_EXP_FD_SILENT(tst_syscall(__NR_landlock_create_ruleset,
+		ruleset_attr, sizeof(struct tst_landlock_ruleset_attr_abi1), 0));
+
+	file_fd = SAFE_OPEN("junk.bin", O_CREAT, 0777);
+}
+
+static void cleanup(void)
+{
+	if (ruleset_fd != -1)
+		SAFE_CLOSE(ruleset_fd);
+
+	if (file_fd != -1)
+		SAFE_CLOSE(file_fd);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+	.needs_root = 1,
+	.forks_child = 1,
+	.bufs = (struct tst_buffers []) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		{}
+	},
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock04.c b/testcases/kernel/syscalls/landlock/landlock04.c
new file mode 100644
index 000000000..2faba7a2b
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock04.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that all landlock filesystem rules are working properly.
+ * The way we do it is to verify that all disabled syscalls are not working but
+ * the one we enabled via specifc landlock rules.
+ */
+
+#include "landlock_common.h"
+#include "landlock_tester.h"
+#include "tst_safe_stdio.h"
+
+static struct tst_landlock_ruleset_attr_abi1 *ruleset_attr;
+static struct landlock_path_beneath_attr *path_beneath_attr;
+static int ruleset_fd = -1;
+
+static struct tvariant {
+	int access;
+	char *desc;
+} tvariants[] = {
+	{
+		LANDLOCK_ACCESS_FS_READ_FILE | LANDLOCK_ACCESS_FS_EXECUTE,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_EXECUTE)
+	},
+	{
+		LANDLOCK_ACCESS_FS_WRITE_FILE,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_WRITE_FILE)
+	},
+	{
+		LANDLOCK_ACCESS_FS_READ_FILE,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_READ_FILE)
+	},
+	{
+		LANDLOCK_ACCESS_FS_READ_DIR,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_READ_DIR)
+	},
+	{
+		LANDLOCK_ACCESS_FS_REMOVE_DIR,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_REMOVE_DIR)
+	},
+	{
+		LANDLOCK_ACCESS_FS_REMOVE_FILE,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_REMOVE_FILE)
+	},
+	{
+		LANDLOCK_ACCESS_FS_MAKE_CHAR,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_MAKE_CHAR)
+	},
+	{
+		LANDLOCK_ACCESS_FS_MAKE_BLOCK,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_MAKE_BLOCK)
+	},
+	{
+		LANDLOCK_ACCESS_FS_MAKE_REG,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_MAKE_REG)
+	},
+	{
+		LANDLOCK_ACCESS_FS_MAKE_SOCK,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_MAKE_SOCK)
+	},
+	{
+		LANDLOCK_ACCESS_FS_MAKE_FIFO,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_MAKE_FIFO)
+	},
+	{
+		LANDLOCK_ACCESS_FS_MAKE_SYM,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_MAKE_SYM)
+	},
+	{
+		LANDLOCK_ACCESS_FS_WRITE_FILE | LANDLOCK_ACCESS_FS_TRUNCATE,
+		TST_TO_STR_(LANDLOCK_ACCESS_FS_TRUNCATE)
+	},
+};
+
+static void run(void)
+{
+	struct tvariant  variant = tvariants[tst_variant];
+
+	tester_setup_files();
+
+	if (!SAFE_FORK()) {
+		enforce_ruleset(ruleset_fd);
+		tester_run_all_fs_rules(variant.access);
+
+		_exit(0);
+	}
+
+	tst_reap_children();
+	tester_cleanup_files();
+}
+
+static void enable_exec_libs(const int ruleset_fd)
+{
+	FILE *fp;
+	char line[1024];
+	char path[PATH_MAX];
+	char dependency[8][PATH_MAX];
+	int count = 0;
+	int duplicate = 0;
+
+	fp = SAFE_FOPEN("/proc/self/maps", "r");
+
+	while (fgets(line, sizeof(line), fp)) {
+		if (strstr(line, ".so") == NULL)
+			continue;
+
+		SAFE_SSCANF(line, "%*x-%*x %*s %*x %*s %*d %s", path);
+
+		for (int i = 0; i < count; i++) {
+			if (strcmp(path, dependency[i]) == 0) {
+				duplicate = 1;
+				break;
+			}
+		}
+
+		if (duplicate) {
+			duplicate = 0;
+			continue;
+		}
+
+		strncpy(dependency[count], path, PATH_MAX);
+		count++;
+
+		tst_res(TINFO, "Enable read/exec permissions for %s", path);
+
+		path_beneath_attr->allowed_access =
+			LANDLOCK_ACCESS_FS_READ_FILE |
+			LANDLOCK_ACCESS_FS_EXECUTE;
+		path_beneath_attr->parent_fd = SAFE_OPEN(path, O_PATH | O_CLOEXEC);
+
+		SAFE_LANDLOCK_ADD_RULE(
+			ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,	path_beneath_attr, 0);
+
+		SAFE_CLOSE(path_beneath_attr->parent_fd);
+	}
+
+	SAFE_FCLOSE(fp);
+}
+
+static void setup(void)
+{
+	struct tvariant variant = tvariants[tst_variant];
+
+	verify_landlock_is_enabled();
+
+	tst_res(TINFO, "Testing %s", variant.desc);
+
+	ruleset_attr->handled_access_fs = tester_get_all_fs_rules();
+
+	ruleset_fd = SAFE_LANDLOCK_CREATE_RULESET(
+		ruleset_attr, sizeof(struct tst_landlock_ruleset_attr_abi1), 0);
+
+	/* since our binary is dynamically linked, we need to enable dependences
+	 * to be read and executed
+	 */
+	enable_exec_libs(ruleset_fd);
+
+	/* sandbox folder has to exist before creating the rule */
+	if (access(SANDBOX_FOLDER, F_OK) == -1)
+		SAFE_MKDIR(SANDBOX_FOLDER, PERM_MODE);
+
+	path_beneath_attr->allowed_access = variant.access;
+	path_beneath_attr->parent_fd = SAFE_OPEN(
+		SANDBOX_FOLDER, O_PATH | O_CLOEXEC);
+
+	SAFE_LANDLOCK_ADD_RULE(
+		ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,	path_beneath_attr, 0);
+
+	SAFE_CLOSE(path_beneath_attr->parent_fd);
+}
+
+static void cleanup(void)
+{
+	if (ruleset_fd != -1)
+		SAFE_CLOSE(ruleset_fd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.forks_child = 1,
+	.needs_root = 1,
+	.test_variants = ARRAY_SIZE(tvariants),
+	.resource_files = (const char *[]) {
+		TESTAPP,
+		NULL,
+	},
+	.bufs = (struct tst_buffers []) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{&path_beneath_attr, .size = sizeof(struct landlock_path_beneath_attr)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		TST_CAP(TST_CAP_REQ, CAP_MKNOD),
+		{}
+	},
+	.mount_device = 1,
+	.mntpoint = SANDBOX_FOLDER,
+	.all_filesystems = 1,
+	.timeout = 360,
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock05.c b/testcases/kernel/syscalls/landlock/landlock05.c
new file mode 100644
index 000000000..3d5048f0a
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock05.c
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies LANDLOCK_ACCESS_FS_REFER access in the
+ * landlock sandbox.
+ *
+ * [Algorithm]
+ *
+ * - apply LANDLOCK_ACCESS_FS_REFER in the folder1
+ * - apply LANDLOCK_ACCESS_FS_REFER in the folder2
+ * - create folder3
+ * - verify that file can be moved from folder1 to folder2
+ * - verify that file can't be moved from folder1 to folder3
+ */
+
+#include "landlock_common.h"
+
+#define MNTPOINT "sandbox"
+#define DIR1 MNTPOINT"/folder1"
+#define DIR2 MNTPOINT"/folder2"
+#define DIR3 MNTPOINT"/folder3"
+#define FILENAME1 DIR1"/file"
+#define FILENAME2 DIR2"/file"
+#define FILENAME3 DIR3"/file"
+
+static struct tst_landlock_ruleset_attr_abi1 *ruleset_attr;
+static struct landlock_path_beneath_attr *path_beneath_attr;
+
+static void run(void)
+{
+	if (SAFE_FORK())
+		return;
+
+	TST_EXP_PASS(rename(FILENAME1, FILENAME2));
+	if (TST_RET == -1)
+		return;
+
+	TST_EXP_FAIL(rename(FILENAME2, FILENAME3), EXDEV);
+	TST_EXP_PASS(rename(FILENAME2, FILENAME1));
+
+	_exit(0);
+}
+
+static void setup(void)
+{
+	int abi;
+	int ruleset_fd;
+
+	abi = verify_landlock_is_enabled();
+	if (abi < 2)
+		tst_brk(TCONF, "LANDLOCK_ACCESS_FS_REFER is unsupported on ABI < 2");
+
+	SAFE_MKDIR(DIR1, 0640);
+	SAFE_MKDIR(DIR2, 0640);
+	SAFE_MKDIR(DIR3, 0640);
+	SAFE_TOUCH(FILENAME1, 0640, NULL);
+
+	tst_res(TINFO, "Applying LANDLOCK_ACCESS_FS_REFER");
+
+	ruleset_attr->handled_access_fs =
+		LANDLOCK_ACCESS_FS_READ_FILE |
+		LANDLOCK_ACCESS_FS_WRITE_FILE |
+		LANDLOCK_ACCESS_FS_REFER;
+
+	ruleset_fd = SAFE_LANDLOCK_CREATE_RULESET(
+		ruleset_attr, sizeof(struct tst_landlock_ruleset_attr_abi1), 0);
+
+	apply_landlock_fs_rule(
+		path_beneath_attr,
+		ruleset_fd,
+		LANDLOCK_ACCESS_FS_REFER,
+		DIR1);
+
+	apply_landlock_fs_rule(
+		path_beneath_attr,
+		ruleset_fd,
+		LANDLOCK_ACCESS_FS_REFER,
+		DIR2);
+
+	enforce_ruleset(ruleset_fd);
+
+	SAFE_CLOSE(ruleset_fd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.needs_root = 1,
+	.forks_child = 1,
+	.bufs = (struct tst_buffers []) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{&path_beneath_attr, .size = sizeof(struct landlock_path_beneath_attr)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		{}
+	},
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *[]) {
+		"vfat",
+		"exfat",
+		NULL
+	},
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock06.c b/testcases/kernel/syscalls/landlock/landlock06.c
new file mode 100644
index 000000000..74237d116
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock06.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies LANDLOCK_ACCESS_FS_IOCTL_DEV access in the
+ * landlock sandbox by creating a pipe and testing that ioctl() can be executed
+ * on it. The test is also verifying that some of the I/O operations can be
+ * always executed no matter the sandbox rules.
+ */
+
+#include "landlock_common.h"
+#include <sys/ioctl.h>
+
+#define MNTPOINT "sandbox"
+#define FILENAME MNTPOINT"/fifo"
+
+static struct tst_landlock_ruleset_attr_abi1 *ruleset_attr;
+static struct landlock_path_beneath_attr *path_beneath_attr;
+static int file_fd = -1;
+static int dev_fd = -1;
+
+static void run(void)
+{
+	if (SAFE_FORK())
+		return;
+
+	int flag = 0;
+	size_t sz = 0;
+
+	TST_EXP_PASS(ioctl(file_fd, FIONREAD, &sz));
+	TST_EXP_PASS(ioctl(dev_fd, FIOCLEX));
+	TST_EXP_PASS(ioctl(dev_fd, FIONCLEX));
+	TST_EXP_PASS(ioctl(dev_fd, FIONBIO, &flag));
+	TST_EXP_PASS(ioctl(dev_fd, FIOASYNC, &flag));
+
+	_exit(0);
+}
+
+static void setup(void)
+{
+	if (verify_landlock_is_enabled() < 5)
+		tst_brk(TCONF, "LANDLOCK_ACCESS_FS_IOCTL_DEV is not supported");
+
+	SAFE_TOUCH(FILENAME, 0640, NULL);
+
+	file_fd = SAFE_OPEN(FILENAME, O_RDONLY | O_NONBLOCK, 0640);
+	dev_fd = SAFE_OPEN("/dev/zero", O_RDONLY | O_NONBLOCK, 0640);
+
+	tst_res(TINFO, "Applying LANDLOCK_ACCESS_FS_IOCTL_DEV");
+
+	ruleset_attr->handled_access_fs = LANDLOCK_ACCESS_FS_IOCTL_DEV;
+
+	apply_landlock_fs_layer(
+		ruleset_attr,
+		sizeof(struct tst_landlock_ruleset_attr_abi1),
+		path_beneath_attr,
+		MNTPOINT,
+		LANDLOCK_ACCESS_FS_IOCTL_DEV
+	);
+}
+
+static void cleanup(void)
+{
+	if (dev_fd != -1)
+		SAFE_CLOSE(dev_fd);
+
+	if (file_fd != -1)
+		SAFE_CLOSE(file_fd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+	.forks_child = 1,
+	.bufs = (struct tst_buffers []) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{&path_beneath_attr, .size = sizeof(struct landlock_path_beneath_attr)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		{}
+	},
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *[]) {
+		"vfat",
+		NULL
+	},
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock07.c b/testcases/kernel/syscalls/landlock/landlock07.c
new file mode 100644
index 000000000..8ee614856
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock07.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/**
+ * [Description]
+ *
+ * CVE-2024-42318
+ *
+ * Test to check if system is affected by Landlock Houdini bug:
+ * https://www.suse.com/security/cve/CVE-2024-42318.html
+ *
+ * Kernel bug fixed in:
+ *
+ *  commit 39705a6c29f8a2b93cf5b99528a55366c50014d1
+ *  Author: Jann Horn <jannh@google.com>
+ *  Date:   Wed Jul 24 14:49:01 2024 +0200
+ *
+ *  landlock: Don't lose track of restrictions on cred_transfer
+ */
+
+#include "tst_test.h"
+#include "lapi/keyctl.h"
+#include "lapi/prctl.h"
+#include "landlock_common.h"
+
+static struct tst_landlock_ruleset_attr_abi1 *ruleset_attr;
+static int ruleset_fd;
+
+static pid_t spawn_houdini(void)
+{
+	pid_t pid;
+
+	SAFE_KEYCTL(KEYCTL_JOIN_SESSION_KEYRING, 0, 0, 0, 0);
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		SAFE_KEYCTL(KEYCTL_JOIN_SESSION_KEYRING, 0, 0, 0, 0);
+		SAFE_KEYCTL(KEYCTL_SESSION_TO_PARENT, 0, 0, 0, 0);
+		exit(0);
+	}
+
+	return pid;
+}
+
+static void run(void)
+{
+	pid_t pid_houdini;
+
+	if (SAFE_FORK())
+		return;
+
+	SAFE_PRCTL(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+	SAFE_LANDLOCK_RESTRICT_SELF(ruleset_fd, 0);
+
+	TST_EXP_FAIL(open("/dev/null", O_WRONLY), EACCES);
+	if (TST_RET != -1) {
+		SAFE_CLOSE(TST_RET);
+		return;
+	}
+
+	pid_houdini = spawn_houdini();
+	SAFE_WAITPID(pid_houdini, NULL, 0);
+
+	TST_EXP_FAIL(open("/dev/null", O_WRONLY), EACCES);
+	if (TST_RET != -1)
+		SAFE_CLOSE(TST_RET);
+
+	exit(0);
+}
+
+static void setup(void)
+{
+	verify_landlock_is_enabled();
+
+	ruleset_attr->handled_access_fs = LANDLOCK_ACCESS_FS_WRITE_FILE;
+	ruleset_fd = SAFE_LANDLOCK_CREATE_RULESET(
+		ruleset_attr,
+		sizeof(struct tst_landlock_ruleset_attr_abi1),
+		0);
+}
+
+static void cleanup(void)
+{
+	if (ruleset_fd != -1)
+		SAFE_CLOSE(ruleset_fd);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.forks_child = 1,
+	.bufs = (struct tst_buffers []) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi1)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		{}
+	},
+	.tags = (const struct tst_tag[]) {
+		{"linux-git", "39705a6c29f8"},
+		{"CVE", "2024-42318"},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock08.c b/testcases/kernel/syscalls/landlock/landlock08.c
new file mode 100644
index 000000000..c3c320c34
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock08.c
@@ -0,0 +1,209 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify the landlock support for bind()/connect() syscalls in IPV4 and IPV6
+ * protocols. In particular, check that bind() is assigning the address only on
+ * the TCP port enforced by LANDLOCK_ACCESS_NET_BIND_TCP and check that
+ * connect() is connecting only to a specific TCP port enforced by
+ * LANDLOCK_ACCESS_NET_CONNECT_TCP.
+ *
+ * [Algorithm]
+ *
+ * Repeat the following procedure for IPV4 and IPV6:
+ *
+ * - create a socket on PORT1, bind() it and check if it passes
+ * - enforce the current sandbox with LANDLOCK_ACCESS_NET_BIND_TCP on PORT1
+ * - create a socket on PORT1, bind() it and check if it passes
+ * - create a socket on PORT2, bind() it and check if it fails
+ *
+ * - create a server listening on PORT1
+ * - create a socket on PORT1, connect() to it and check if it passes
+ * - enforce the current sandbox with LANDLOCK_ACCESS_NET_CONNECT_TCP on PORT1
+ * - create a socket on PORT1, connect() to it and check if it passes
+ * - create a socket on PORT2, connect() to it and check if it fails
+ */
+
+#include "landlock_common.h"
+
+static int variants[] = {
+	AF_INET,
+	AF_INET6,
+};
+
+static struct tst_landlock_ruleset_attr_abi4 *ruleset_attr;
+static struct landlock_net_port_attr *net_port_attr;
+static in_port_t *server_port;
+static int addr_port;
+
+static void create_server(const int addr_family)
+{
+	struct socket_data socket;
+	struct sockaddr *addr = NULL;
+
+	create_socket(&socket, addr_family, 0);
+	getsocket_addr(&socket, addr_family, &addr);
+
+	SAFE_BIND(socket.fd, addr, socket.address_size);
+	SAFE_LISTEN(socket.fd, 1);
+
+	*server_port = getsocket_port(&socket, addr_family);
+
+	tst_res(TDEBUG, "Server listening on port %u", *server_port);
+
+	TST_CHECKPOINT_WAKE_AND_WAIT(0);
+
+	SAFE_CLOSE(socket.fd);
+}
+
+static void test_bind(const int addr_family, const in_port_t port,
+	const int exp_err)
+{
+	struct socket_data socket;
+	struct sockaddr *addr = NULL;
+
+	create_socket(&socket, addr_family, port);
+	getsocket_addr(&socket, addr_family, &addr);
+
+	if (exp_err) {
+		TST_EXP_FAIL(
+			bind(socket.fd, addr, socket.address_size),
+			exp_err, "bind() access on port %u", port);
+	} else {
+		TST_EXP_PASS(
+			bind(socket.fd, addr, socket.address_size),
+			"bind() access on port %u", port);
+	}
+
+	SAFE_CLOSE(socket.fd);
+}
+
+static void test_connect(const int addr_family, const in_port_t port,
+	const int exp_err)
+{
+	struct socket_data socket;
+	struct sockaddr *addr = NULL;
+
+	create_socket(&socket, addr_family, port);
+	getsocket_addr(&socket, addr_family, &addr);
+
+	if (exp_err) {
+		TST_EXP_FAIL(
+			connect(socket.fd, addr, socket.address_size),
+			exp_err, "connect() on port %u", port);
+	} else {
+		TST_EXP_PASS(
+			connect(socket.fd, addr, socket.address_size),
+			"connect() on port %u", port);
+	}
+
+	SAFE_CLOSE(socket.fd);
+}
+
+static void run(void)
+{
+	int addr_family = variants[tst_variant];
+
+	tst_res(TINFO, "Using %s protocol",
+		addr_family == AF_INET ? "IPV4" : "IPV6");
+
+	if (!SAFE_FORK()) {
+		create_server(addr_family);
+		exit(0);
+	}
+
+	TST_CHECKPOINT_WAIT(0);
+
+	/* verify bind() syscall accessibility */
+	if (!SAFE_FORK()) {
+		ruleset_attr->handled_access_net =
+			LANDLOCK_ACCESS_NET_BIND_TCP;
+
+		test_bind(addr_family, addr_port, 0);
+
+		tst_res(TINFO, "Enable bind() access only for port %u",
+			addr_port);
+
+		apply_landlock_net_layer(
+			ruleset_attr,
+			sizeof(struct tst_landlock_ruleset_attr_abi4),
+			net_port_attr,
+			addr_port,
+			LANDLOCK_ACCESS_NET_BIND_TCP);
+
+		test_bind(addr_family, addr_port, 0);
+		test_bind(addr_family, addr_port + 0x80, EACCES);
+
+		exit(0);
+	}
+
+	/* verify connect() syscall accessibility */
+	if (!SAFE_FORK()) {
+		ruleset_attr->handled_access_net =
+			LANDLOCK_ACCESS_NET_CONNECT_TCP;
+
+		test_connect(addr_family, *server_port, 0);
+
+		tst_res(TINFO, "Enable connect() access only on port %u",
+			*server_port);
+
+		apply_landlock_net_layer(
+			ruleset_attr,
+			sizeof(struct tst_landlock_ruleset_attr_abi4),
+			net_port_attr,
+			*server_port,
+			LANDLOCK_ACCESS_NET_CONNECT_TCP);
+
+		test_connect(addr_family, *server_port, 0);
+		test_connect(addr_family, *server_port + 0x80, EACCES);
+
+		TST_CHECKPOINT_WAKE(0);
+
+		exit(0);
+	}
+}
+
+static void setup(void)
+{
+	if (verify_landlock_is_enabled() < 4)
+		tst_brk(TCONF, "Landlock network is not supported");
+
+	addr_port = TST_GET_UNUSED_PORT(AF_INET, SOCK_STREAM);
+
+	server_port = SAFE_MMAP(NULL, sizeof(in_port_t), PROT_READ | PROT_WRITE,
+		MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+}
+
+static void cleanup(void)
+{
+	if (server_port)
+		SAFE_MUNMAP(server_port, sizeof(in_port_t));
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+	.needs_checkpoints = 1,
+	.forks_child = 1,
+	.test_variants = ARRAY_SIZE(variants),
+	.bufs = (struct tst_buffers[]) {
+		{&ruleset_attr, .size = sizeof(struct tst_landlock_ruleset_attr_abi4)},
+		{&net_port_attr, .size = sizeof(struct landlock_net_port_attr)},
+		{},
+	},
+	.caps = (struct tst_cap []) {
+		TST_CAP(TST_CAP_REQ, CAP_SYS_ADMIN),
+		TST_CAP(TST_CAP_REQ, CAP_NET_BIND_SERVICE),
+		{}
+	},
+	.needs_kconfigs = (const char *[]) {
+		"CONFIG_INET=y",
+		NULL
+	},
+};
diff --git a/testcases/kernel/syscalls/landlock/landlock_common.h b/testcases/kernel/syscalls/landlock/landlock_common.h
new file mode 100644
index 000000000..4aa11b7d2
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock_common.h
@@ -0,0 +1,199 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef LANDLOCK_COMMON_H__
+#define LANDLOCK_COMMON_H__
+
+#include "tst_test.h"
+#include "lapi/prctl.h"
+#include "lapi/fcntl.h"
+#include "lapi/landlock.h"
+
+#define IPV4_LOCALHOST "127.0.0.1"
+#define IPV6_LOCALHOST "::1"
+
+struct socket_data {
+	struct sockaddr_in addr_ipv4;
+	struct sockaddr_in6 addr_ipv6;
+	size_t address_size;
+	int fd;
+};
+
+static inline int verify_landlock_is_enabled(void)
+{
+	int abi;
+
+	abi = tst_syscall(__NR_landlock_create_ruleset,
+		NULL, 0, LANDLOCK_CREATE_RULESET_VERSION);
+
+	if (abi < 0) {
+		if (errno == EOPNOTSUPP) {
+			tst_brk(TCONF, "Landlock is currently disabled. "
+				"Please enable it either via CONFIG_LSM or "
+				"'lsm' kernel parameter.");
+		}
+
+		tst_brk(TBROK | TERRNO, "landlock_create_ruleset error");
+	}
+
+	tst_res(TINFO, "Landlock ABI v%d", abi);
+
+	return abi;
+}
+
+static inline void apply_landlock_fs_rule(
+	struct landlock_path_beneath_attr *path_beneath_attr,
+	const int ruleset_fd,
+	const int access,
+	const char *path)
+{
+	path_beneath_attr->allowed_access = access;
+	path_beneath_attr->parent_fd = SAFE_OPEN(path, O_PATH | O_CLOEXEC);
+
+	SAFE_LANDLOCK_ADD_RULE(
+		ruleset_fd,
+		LANDLOCK_RULE_PATH_BENEATH,
+		path_beneath_attr,
+		0);
+
+	SAFE_CLOSE(path_beneath_attr->parent_fd);
+}
+
+static inline void apply_landlock_net_rule(
+	struct landlock_net_port_attr *net_attr,
+	const int ruleset_fd,
+	const uint64_t port,
+	const uint64_t access)
+{
+	net_attr->port = port;
+	net_attr->allowed_access = access;
+
+	SAFE_LANDLOCK_ADD_RULE(
+		ruleset_fd,
+		LANDLOCK_RULE_NET_PORT,
+		net_attr,
+		0);
+}
+
+static inline void enforce_ruleset(const int ruleset_fd)
+{
+	SAFE_PRCTL(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+	SAFE_LANDLOCK_RESTRICT_SELF(ruleset_fd, 0);
+}
+
+static inline void apply_landlock_fs_layer(
+	void *ruleset_attr, size_t attr_size,
+	struct landlock_path_beneath_attr *path_beneath_attr,
+	const char *path,
+	const int access)
+{
+	int ruleset_fd;
+
+	ruleset_fd = SAFE_LANDLOCK_CREATE_RULESET(ruleset_attr, attr_size, 0);
+
+	apply_landlock_fs_rule(path_beneath_attr, ruleset_fd, access, path);
+	enforce_ruleset(ruleset_fd);
+
+	SAFE_CLOSE(ruleset_fd);
+}
+
+static inline void apply_landlock_net_layer(
+	void *ruleset_attr, size_t attr_size,
+	struct landlock_net_port_attr *net_port_attr,
+	const in_port_t port,
+	const uint64_t access)
+{
+	int ruleset_fd;
+
+	ruleset_fd = SAFE_LANDLOCK_CREATE_RULESET(ruleset_attr, attr_size, 0);
+
+	apply_landlock_net_rule(net_port_attr, ruleset_fd, port, access);
+	enforce_ruleset(ruleset_fd);
+
+	SAFE_CLOSE(ruleset_fd);
+}
+
+static inline in_port_t getsocket_port(struct socket_data *socket,
+	const int addr_family)
+{
+	struct sockaddr_in addr_ipv4;
+	struct sockaddr_in6 addr_ipv6;
+	socklen_t len;
+	in_port_t port = 0;
+
+	switch (addr_family) {
+	case AF_INET:
+		len = sizeof(addr_ipv4);
+		memset(&addr_ipv4, 0, len);
+
+		SAFE_GETSOCKNAME(socket->fd, (struct sockaddr *)&addr_ipv4, &len);
+		port = ntohs(addr_ipv4.sin_port);
+		break;
+	case AF_INET6:
+		len = sizeof(addr_ipv6);
+		memset(&addr_ipv6, 0, len);
+
+		SAFE_GETSOCKNAME(socket->fd, (struct sockaddr *)&addr_ipv6, &len);
+		port = ntohs(addr_ipv6.sin6_port);
+		break;
+	default:
+		tst_brk(TBROK, "Unsupported protocol");
+		break;
+	};
+
+	return port;
+}
+
+static inline void create_socket(struct socket_data *socket,
+	const int addr_family, const in_port_t port)
+{
+	memset(socket, 0, sizeof(struct socket_data));
+
+	switch (addr_family) {
+	case AF_INET:
+		if (!port) {
+			tst_init_sockaddr_inet_bin(&socket->addr_ipv4,
+				INADDR_ANY, 0);
+		} else {
+			tst_init_sockaddr_inet(&socket->addr_ipv4,
+				IPV4_LOCALHOST, port);
+		}
+
+		socket->address_size = sizeof(struct sockaddr_in);
+		break;
+	case AF_INET6:
+		if (!port) {
+			tst_init_sockaddr_inet6_bin(&socket->addr_ipv6,
+				&in6addr_any, 0);
+		} else {
+			tst_init_sockaddr_inet6(&socket->addr_ipv6,
+				IPV6_LOCALHOST, port);
+		}
+
+		socket->address_size = sizeof(struct sockaddr_in6);
+		break;
+	default:
+		tst_brk(TBROK, "Unsupported protocol");
+		return;
+	};
+
+	socket->fd = SAFE_SOCKET(addr_family, SOCK_STREAM | SOCK_CLOEXEC, 0);
+}
+
+static inline void getsocket_addr(struct socket_data *socket,
+	const int addr_family, struct sockaddr **addr)
+{
+	switch (addr_family) {
+	case AF_INET:
+		*addr = (struct sockaddr *)&socket->addr_ipv4;
+		break;
+	case AF_INET6:
+		*addr = (struct sockaddr *)&socket->addr_ipv6;
+		break;
+	default:
+		break;
+	};
+}
+#endif /* LANDLOCK_COMMON_H__ */
diff --git a/testcases/kernel/syscalls/landlock/landlock_exec.c b/testcases/kernel/syscalls/landlock/landlock_exec.c
new file mode 100644
index 000000000..aae5c76b2
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock_exec.c
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+int main(void)
+{
+	return 0;
+}
diff --git a/testcases/kernel/syscalls/landlock/landlock_tester.h b/testcases/kernel/syscalls/landlock/landlock_tester.h
new file mode 100644
index 000000000..dcebc45cd
--- /dev/null
+++ b/testcases/kernel/syscalls/landlock/landlock_tester.h
@@ -0,0 +1,393 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef LANDLOCK_TESTER_H__
+
+#include "tst_test.h"
+#include "lapi/landlock.h"
+#include <sys/sysmacros.h>
+
+#define PERM_MODE 0700
+
+#define SANDBOX_FOLDER	"sandbox"
+#define TESTAPP			"landlock_exec"
+
+#define FILE_EXEC		SANDBOX_FOLDER"/"TESTAPP
+#define FILE_READ		SANDBOX_FOLDER"/file_read"
+#define FILE_WRITE		SANDBOX_FOLDER"/file_write"
+#define FILE_REMOVE		SANDBOX_FOLDER"/file_remove"
+#define FILE_UNLINK		SANDBOX_FOLDER"/file_unlink"
+#define FILE_UNLINKAT	SANDBOX_FOLDER"/file_unlinkat"
+#define FILE_TRUNCATE	SANDBOX_FOLDER"/file_truncate"
+#define FILE_REGULAR	SANDBOX_FOLDER"/regular0"
+#define FILE_SOCKET		SANDBOX_FOLDER"/socket0"
+#define FILE_FIFO		SANDBOX_FOLDER"/fifo0"
+#define FILE_SYM0		SANDBOX_FOLDER"/symbolic0"
+#define FILE_SYM1		SANDBOX_FOLDER"/symbolic1"
+#define DIR_READDIR		SANDBOX_FOLDER"/dir_readdir"
+#define DIR_RMDIR		SANDBOX_FOLDER"/dir_rmdir"
+#define DEV_CHAR0		SANDBOX_FOLDER"/chardev0"
+#define DEV_BLK0		SANDBOX_FOLDER"/blkdev0"
+
+#define ALL_RULES (\
+	LANDLOCK_ACCESS_FS_EXECUTE | \
+	LANDLOCK_ACCESS_FS_WRITE_FILE | \
+	LANDLOCK_ACCESS_FS_READ_FILE | \
+	LANDLOCK_ACCESS_FS_READ_DIR | \
+	LANDLOCK_ACCESS_FS_REMOVE_DIR | \
+	LANDLOCK_ACCESS_FS_REMOVE_FILE | \
+	LANDLOCK_ACCESS_FS_MAKE_CHAR | \
+	LANDLOCK_ACCESS_FS_MAKE_DIR | \
+	LANDLOCK_ACCESS_FS_MAKE_REG | \
+	LANDLOCK_ACCESS_FS_MAKE_SOCK | \
+	LANDLOCK_ACCESS_FS_MAKE_FIFO | \
+	LANDLOCK_ACCESS_FS_MAKE_BLOCK | \
+	LANDLOCK_ACCESS_FS_MAKE_SYM | \
+	LANDLOCK_ACCESS_FS_REFER | \
+	LANDLOCK_ACCESS_FS_TRUNCATE | \
+	LANDLOCK_ACCESS_FS_IOCTL_DEV)
+
+static char *readdir_files[] = {
+	DIR_READDIR"/file0",
+	DIR_READDIR"/file1",
+	DIR_READDIR"/file2",
+};
+
+static int dev_chr;
+static int dev_blk;
+
+static int tester_get_all_fs_rules(void)
+{
+	int abi;
+	int all_rules = ALL_RULES;
+
+	abi = SAFE_LANDLOCK_CREATE_RULESET(
+		NULL, 0, LANDLOCK_CREATE_RULESET_VERSION);
+
+	if (abi < 2)
+		all_rules &= ~LANDLOCK_ACCESS_FS_REFER;
+
+	if (abi < 3)
+		all_rules &= ~LANDLOCK_ACCESS_FS_TRUNCATE;
+
+	if (abi < 5)
+		all_rules &= ~LANDLOCK_ACCESS_FS_IOCTL_DEV;
+
+	return all_rules;
+}
+
+/* This function setup the sandbox folder before running the test.
+ * Run it __before__ enforcing the sandbox rules and ensure that SANDBOX_FOLDER
+ * has been created already.
+ */
+static void tester_setup_files(void)
+{
+	/* folders */
+	SAFE_MKDIR(DIR_RMDIR, PERM_MODE);
+	SAFE_MKDIR(DIR_READDIR, PERM_MODE);
+	for (size_t i = 0; i < ARRAY_SIZE(readdir_files); i++)
+		SAFE_TOUCH(readdir_files[i], PERM_MODE, NULL);
+
+	/* files */
+	tst_fill_file(FILE_READ, 'a', getpagesize(), 1);
+	SAFE_TOUCH(FILE_WRITE, PERM_MODE, NULL);
+	SAFE_TOUCH(FILE_REMOVE, PERM_MODE, NULL);
+	SAFE_TOUCH(FILE_UNLINK, PERM_MODE, NULL);
+	SAFE_TOUCH(FILE_UNLINKAT, PERM_MODE, NULL);
+	SAFE_TOUCH(FILE_TRUNCATE, PERM_MODE, NULL);
+	SAFE_TOUCH(FILE_SYM0, PERM_MODE, NULL);
+	SAFE_CP(TESTAPP, FILE_EXEC);
+
+	/* devices */
+	dev_chr = makedev(1, 3);
+	dev_blk = makedev(7, 0);
+}
+
+static void _remove_file(const char *path)
+{
+	if (access(path, F_OK) != -1)
+		SAFE_UNLINK(path);
+}
+
+/* This function cleanup the sandbox folder after running the tests.
+ * Run it after getting out from the sandbox.
+ */
+static void tester_cleanup_files(void)
+{
+	if (access(DIR_RMDIR, F_OK) != -1)
+		SAFE_RMDIR(DIR_RMDIR);
+
+	for (size_t i = 0; i < ARRAY_SIZE(readdir_files); i++)
+		_remove_file(readdir_files[i]);
+
+	if (access(DIR_READDIR, F_OK) != -1)
+		SAFE_RMDIR(DIR_READDIR);
+
+	struct stat st;
+
+	if (lstat(FILE_SYM1, &st) != -1)
+		SAFE_UNLINK(FILE_SYM1);
+
+	_remove_file(FILE_READ);
+	_remove_file(FILE_WRITE);
+	_remove_file(FILE_REMOVE);
+	_remove_file(FILE_UNLINK);
+	_remove_file(FILE_UNLINKAT);
+	_remove_file(FILE_TRUNCATE);
+	_remove_file(FILE_SYM0);
+	_remove_file(FILE_EXEC);
+
+	_remove_file(DEV_BLK0);
+	_remove_file(DEV_CHAR0);
+	_remove_file(FILE_FIFO);
+	_remove_file(FILE_SOCKET);
+	_remove_file(FILE_REGULAR);
+}
+
+static void _test_exec(const int result)
+{
+	int status;
+	pid_t pid;
+	char *const args[] = {(char *)FILE_EXEC, NULL};
+
+	tst_res(TINFO, "Test binary execution");
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		int rval;
+
+		if (result == TPASS) {
+			rval = execve(FILE_EXEC, args, NULL);
+			if (rval == -1)
+				tst_res(TFAIL | TERRNO, "Failed to execute test binary");
+		} else {
+			TST_EXP_FAIL(execve(FILE_EXEC, args, NULL), EACCES);
+		}
+
+		_exit(1);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+		return;
+
+	tst_res(result, "Test binary has been executed");
+}
+
+static void _test_write(const int result)
+{
+	tst_res(TINFO, "Test writing file");
+
+	if (result == TPASS)
+		TST_EXP_FD(open(FILE_WRITE, O_WRONLY, PERM_MODE));
+	else
+		TST_EXP_FAIL(open(FILE_WRITE, O_WRONLY, PERM_MODE), EACCES);
+
+	if (TST_RET != -1)
+		SAFE_CLOSE(TST_RET);
+}
+
+static void _test_read(const int result)
+{
+	tst_res(TINFO, "Test reading file");
+
+	if (result == TPASS)
+		TST_EXP_FD(open(FILE_READ, O_RDONLY, PERM_MODE));
+	else
+		TST_EXP_FAIL(open(FILE_READ, O_RDONLY, PERM_MODE), EACCES);
+
+	if (TST_RET != -1)
+		SAFE_CLOSE(TST_RET);
+}
+
+static void _test_readdir(const int result)
+{
+	tst_res(TINFO, "Test reading directory");
+
+	DIR *dir;
+	struct dirent *de;
+	int files_counted = 0;
+
+	dir = opendir(DIR_READDIR);
+	if (!dir) {
+		tst_res(result == TPASS ? TFAIL : TPASS,
+			"Can't read '%s' directory", DIR_READDIR);
+
+		return;
+	}
+
+	tst_res(result, "Can read '%s' directory", DIR_READDIR);
+	if (result == TFAIL)
+		return;
+
+	while ((de = readdir(dir)) != NULL) {
+		if (de->d_type != DT_REG)
+			continue;
+
+		for (size_t i = 0; i < ARRAY_SIZE(readdir_files); i++) {
+			if (readdir_files[i] == NULL)
+				continue;
+
+			if (strstr(readdir_files[i], de->d_name) != NULL)
+				files_counted++;
+		}
+	}
+
+	SAFE_CLOSEDIR(dir);
+
+	TST_EXP_EQ_LI(files_counted, ARRAY_SIZE(readdir_files));
+}
+
+static void _test_rmdir(const int result)
+{
+	tst_res(TINFO, "Test removing directory");
+
+	if (result == TPASS)
+		TST_EXP_PASS(rmdir(DIR_RMDIR));
+	else
+		TST_EXP_FAIL(rmdir(DIR_RMDIR), EACCES);
+}
+
+static void _test_rmfile(const int result)
+{
+	tst_res(TINFO, "Test removing file");
+
+	if (result == TPASS) {
+		TST_EXP_PASS(unlink(FILE_UNLINK));
+		TST_EXP_PASS(remove(FILE_REMOVE));
+	} else {
+		TST_EXP_FAIL(unlink(FILE_UNLINK), EACCES);
+		TST_EXP_FAIL(remove(FILE_REMOVE), EACCES);
+	}
+}
+
+static void _test_make(
+	const char *path,
+	const int type,
+	const int dev,
+	const int result)
+{
+	tst_res(TINFO, "Test normal or special files creation");
+
+	if (result == TPASS)
+		TST_EXP_PASS(mknod(path, type | 0400, dev));
+	else
+		TST_EXP_FAIL(mknod(path, type | 0400, dev), EACCES);
+}
+
+static void _test_symbolic(const int result)
+{
+	tst_res(TINFO, "Test symbolic links");
+
+	if (result == TPASS)
+		TST_EXP_PASS(symlink(FILE_SYM0, FILE_SYM1));
+	else
+		TST_EXP_FAIL(symlink(FILE_SYM0, FILE_SYM1), EACCES);
+}
+
+static void _test_truncate(const int result)
+{
+	int fd;
+
+	tst_res(TINFO, "Test truncating file");
+
+	if (result == TPASS) {
+		TST_EXP_PASS(truncate(FILE_TRUNCATE, 10));
+
+		fd = SAFE_OPEN(FILE_TRUNCATE, O_WRONLY, PERM_MODE);
+		if (fd != -1) {
+			TST_EXP_PASS(ftruncate(fd, 10));
+			SAFE_CLOSE(fd);
+		}
+
+		fd = TST_EXP_FD(open(FILE_TRUNCATE, O_WRONLY | O_TRUNC, PERM_MODE));
+		if (fd != -1)
+			SAFE_CLOSE(fd);
+	} else {
+		TST_EXP_FAIL(truncate(FILE_TRUNCATE, 10), EACCES);
+
+		fd = open(FILE_TRUNCATE, O_WRONLY, PERM_MODE);
+		if (fd != -1) {
+			TST_EXP_FAIL(ftruncate(fd, 10), EACCES);
+			SAFE_CLOSE(fd);
+		}
+
+		TST_EXP_FAIL(open(FILE_TRUNCATE, O_WRONLY | O_TRUNC, PERM_MODE),
+			EACCES);
+
+		if (TST_RET != -1)
+			SAFE_CLOSE(TST_RET);
+	}
+}
+
+static void tester_run_fs_rules(const int rules, const int result)
+{
+	if (rules & LANDLOCK_ACCESS_FS_EXECUTE)
+		_test_exec(result);
+
+	if (rules & LANDLOCK_ACCESS_FS_WRITE_FILE)
+		_test_write(result);
+
+	if (rules & LANDLOCK_ACCESS_FS_READ_FILE)
+		_test_read(result);
+
+	if (rules & LANDLOCK_ACCESS_FS_READ_DIR)
+		_test_readdir(result);
+
+	if (rules & LANDLOCK_ACCESS_FS_REMOVE_DIR)
+		_test_rmdir(result);
+
+	if (rules & LANDLOCK_ACCESS_FS_REMOVE_FILE)
+		_test_rmfile(result);
+
+	if (rules & LANDLOCK_ACCESS_FS_MAKE_REG)
+		_test_make(FILE_REGULAR, S_IFREG, 0, result);
+
+	if (strcmp(tst_device->fs_type, "vfat") &&
+		strcmp(tst_device->fs_type, "exfat")) {
+		if (rules & LANDLOCK_ACCESS_FS_MAKE_CHAR)
+			_test_make(DEV_CHAR0, S_IFCHR, dev_chr, result);
+
+		if (rules & LANDLOCK_ACCESS_FS_MAKE_BLOCK)
+			_test_make(DEV_BLK0, S_IFBLK, dev_blk, result);
+
+		if (rules & LANDLOCK_ACCESS_FS_MAKE_SOCK)
+			_test_make(FILE_SOCKET, S_IFSOCK, 0, result);
+
+		if (rules & LANDLOCK_ACCESS_FS_MAKE_FIFO)
+			_test_make(FILE_FIFO, S_IFIFO, 0, result);
+
+		if (rules & LANDLOCK_ACCESS_FS_MAKE_SYM)
+			_test_symbolic(result);
+	}
+
+	if (rules & LANDLOCK_ACCESS_FS_TRUNCATE) {
+		int abi;
+
+		abi = SAFE_LANDLOCK_CREATE_RULESET(
+			NULL, 0, LANDLOCK_CREATE_RULESET_VERSION);
+
+		if (abi < 3) {
+			tst_res(TINFO, "Skip truncate test. Minimum ABI version is 3");
+			return;
+		}
+
+		_test_truncate(result);
+	}
+}
+
+static inline void tester_run_all_fs_rules(const int pass_rules)
+{
+	int fail_rules;
+	int all_rules;
+
+	all_rules = tester_get_all_fs_rules();
+	fail_rules = all_rules & ~pass_rules;
+
+	tester_run_fs_rules(pass_rules, TPASS);
+	tester_run_fs_rules(fail_rules, TFAIL);
+}
+
+#endif
diff --git a/testcases/kernel/syscalls/lgetxattr/lgetxattr01.c b/testcases/kernel/syscalls/lgetxattr/lgetxattr01.c
index 5c92d2317..221f9157a 100644
--- a/testcases/kernel/syscalls/lgetxattr/lgetxattr01.c
+++ b/testcases/kernel/syscalls/lgetxattr/lgetxattr01.c
@@ -1,18 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
-* Copyright (c) 2016 Fujitsu Ltd.
-* Author: Jinbao Huang <huangjb.jy@cn.fujitsu.com>
-*/
-
-/*
-* Test Name: lgetxattr01
-*
-* Description:
-* The testcase checks the basic functionality of the lgetxattr(2).
-* In the case of a symbolic link, we only get the value of the
-* extended attribute related to the link itself by name.
-*
-*/
+ * Copyright (c) 2016 Fujitsu Ltd.
+ * Author: Jinbao Huang <huangjb.jy@cn.fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Check the basic functionality of the lgetxattr(2).
+ *
+ * In the case of a symbolic link, lgetxattr(2) only gets the value of the
+ * extended attribute related to the link itself by name.
+ */
 
 #include "config.h"
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/lgetxattr/lgetxattr02.c b/testcases/kernel/syscalls/lgetxattr/lgetxattr02.c
index 183239a26..db94890c4 100644
--- a/testcases/kernel/syscalls/lgetxattr/lgetxattr02.c
+++ b/testcases/kernel/syscalls/lgetxattr/lgetxattr02.c
@@ -1,23 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
-* Copyright (c) 2016 Fujitsu Ltd.
-* Author: Jinbao Huang <huangjb.jy@cn.fujitsu.com>
-*/
+ * Copyright (c) 2016 Fujitsu Ltd.
+ * Author: Jinbao Huang <huangjb.jy@cn.fujitsu.com>
+ */
 
-/*
-* Test Name: lgetxattr02
-*
-* Description:
-* 1) lgetxattr(2) fails if the named attribute does not exist.
-* 2) lgetxattr(2) fails if the size of the value buffer is too small
-*    to hold the result.
-* 3) lgetxattr(2) fails when attemptes to read from a invalid address.
-*
-* Expected Result:
-* 1) lgetxattr(2) should return -1 and set errno to ENODATA.
-* 2) lgetxattr(2) should return -1 and set errno to ERANGE.
-* 3) lgetxattr(2) should return -1 and set errno to EFAULT.
-*/
+/*\
+ * [Description]
+ *
+ * Verify that, lgetxattr(2) returns -1 and sets errno to
+ *
+ * 1. ENODATA if the named attribute does not exist.
+ * 2. ERANGE if the size of the value buffer is too small to hold the result.
+ * 3. EFAULT when reading from an invalid address.
+ */
 
 #include "config.h"
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/listmount/.gitignore b/testcases/kernel/syscalls/listmount/.gitignore
new file mode 100644
index 000000000..4d709bae5
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/.gitignore
@@ -0,0 +1,4 @@
+listmount01
+listmount02
+listmount03
+listmount04
diff --git a/testcases/kernel/syscalls/listmount/Makefile b/testcases/kernel/syscalls/listmount/Makefile
new file mode 100644
index 000000000..8cf1b9024
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/listmount/listmount.h b/testcases/kernel/syscalls/listmount/listmount.h
new file mode 100644
index 000000000..aad927f71
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/listmount.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef LISTMOUNT_H
+#define LISTMOUNT_H
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "lapi/mount.h"
+#include "lapi/syscalls.h"
+
+static inline ssize_t listmount(uint64_t mnt_id, uint64_t last_mnt_id,
+			 uint64_t list[], size_t num, unsigned int flags)
+{
+	struct mnt_id_req req = {
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = mnt_id,
+		.param = last_mnt_id,
+	};
+
+	return tst_syscall(__NR_listmount, &req, list, num, flags);
+}
+
+#endif
diff --git a/testcases/kernel/syscalls/listmount/listmount01.c b/testcases/kernel/syscalls/listmount/listmount01.c
new file mode 100644
index 000000000..604e5ce92
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/listmount01.c
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that listmount() is properly recognizing a mounted
+ * root directory using LSMT_ROOT flag.
+ *
+ * [Algorithm]
+ *
+ * - move into a new unshared namespace
+ * - mount() a root inside temporary folder and get its mount ID
+ * - get list of mounted IDs using listmount(LSMT_ROOT, ..)
+ * - verify that the root mount ID is the only mount ID present inside the list
+ */
+
+#define _GNU_SOURCE
+
+#include "listmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+
+#define MNTPOINT "mntpoint"
+#define LISTSIZE 32
+
+static uint64_t root_id;
+
+static void run(void)
+{
+	uint64_t list[LISTSIZE];
+
+	TST_EXP_POSITIVE(listmount(LSMT_ROOT, 0, list, LISTSIZE, 0));
+	if (!TST_PASS)
+		return;
+
+	TST_EXP_EQ_LI(TST_RET, 1);
+	TST_EXP_EQ_LI(list[0], root_id);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+
+	SAFE_UNSHARE(CLONE_NEWNS);
+
+	SAFE_CHROOT(MNTPOINT);
+	SAFE_MOUNT("", "/", NULL, MS_REC | MS_PRIVATE, NULL);
+	SAFE_STATX(AT_FDCWD, "/", 0, STATX_MNT_ID_UNIQUE, &sx);
+
+	root_id = sx.data.stx_mnt_id;
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.forks_child = 1,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+};
diff --git a/testcases/kernel/syscalls/listmount/listmount02.c b/testcases/kernel/syscalls/listmount/listmount02.c
new file mode 100644
index 000000000..4b831b615
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/listmount02.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that listmount() is properly reading groups of mount IDs,
+ * checking that both oneshoot and iterator API for listmount() return the same
+ * array.
+ *
+ * [Algorithm]
+ *
+ * - move into a new unshared namespace
+ * - mount() our new root inside temporary folder
+ * - generate a full mounts tree inside root folder, doubling the number of
+ *   mounted filesystems each bind mount
+ * - read the full list of mounted IDs using listmount(LSMT_ROOT, ..)
+ * - read the list of mounted IDs using groups of fixed size
+ * - compare the first mount list with the second mount list
+ */
+
+#include "listmount.h"
+#include "lapi/sched.h"
+
+#define MNTPOINT "mntpoint"
+#define BIND_MOUNTS 7
+#define GROUPS_SIZE 3
+#define LISTSIZE (1 << BIND_MOUNTS)
+
+static void run(void)
+{
+	ssize_t ret;
+	size_t id, tot_ids, count = 0;
+	uint64_t mount_ids[LISTSIZE];
+	uint64_t list[LISTSIZE];
+
+	for (int i = 0; i < BIND_MOUNTS; i++)
+		SAFE_MOUNT("/", "/", NULL, MS_BIND, NULL);
+
+	tst_res(TINFO, "Reading all %d mount IDs in once", LISTSIZE);
+
+	TST_EXP_POSITIVE(listmount(LSMT_ROOT, 0, mount_ids, LISTSIZE, 0));
+	if (!TST_PASS)
+		goto end;
+
+	tot_ids = (size_t)TST_RET;
+
+	if (tot_ids != LISTSIZE) {
+		tst_res(TFAIL, "listmount() returned %lu but %d was expected",
+			tot_ids, LISTSIZE);
+		goto end;
+	}
+
+	tst_res(TINFO, "Reading groups of %d mount IDs", GROUPS_SIZE);
+
+	while (count < LISTSIZE) {
+		id = count ? list[count - 1] : 0;
+		ret = listmount(LSMT_ROOT, id, list + count, GROUPS_SIZE, 0);
+
+		tst_res(TDEBUG, "listmount(LSMT_ROOT, %lu, list + %lu, %d, 0)",
+			id, count, GROUPS_SIZE);
+
+		if (ret == -1) {
+			tst_res(TFAIL, "listmount() failed with %s", tst_strerrno(errno));
+			goto end;
+		}
+
+		count += ret;
+
+		if (TST_RET < GROUPS_SIZE)
+			break;
+	}
+
+	for (size_t i = 0; i < LISTSIZE; i++) {
+		if (mount_ids[i] != list[i]) {
+			tst_res(TFAIL, "Mount ID differs at %ld index", i);
+			goto end;
+		}
+	}
+
+	tst_res(TPASS, "All mount IDs have been correctly read");
+
+end:
+	for (int i = 0; i < BIND_MOUNTS; i++)
+		SAFE_UMOUNT("/");
+}
+
+static void setup(void)
+{
+	SAFE_UNSHARE(CLONE_NEWNS);
+	SAFE_CHROOT(MNTPOINT);
+
+	SAFE_MOUNT("", "/", NULL, MS_REC | MS_SHARED, NULL);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.forks_child = 1,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+};
diff --git a/testcases/kernel/syscalls/listmount/listmount03.c b/testcases/kernel/syscalls/listmount/listmount03.c
new file mode 100644
index 000000000..befe0edaf
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/listmount03.c
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that listmount() raises EPERM when mount point is not accessible.
+ */
+
+#define _GNU_SOURCE
+
+#include <pwd.h>
+#include "listmount.h"
+#include "lapi/stat.h"
+
+#define LISTSIZE 32
+
+static uint64_t root_id;
+static gid_t nobody_gid;
+static uid_t nobody_uid;
+
+static void run(void)
+{
+	if (SAFE_FORK())
+		return;
+
+	uint64_t list[LISTSIZE];
+
+	SAFE_SETEGID(nobody_gid);
+	SAFE_SETEUID(nobody_uid);
+
+	TST_EXP_FAIL(listmount(root_id, 0, list, LISTSIZE, 0), EPERM);
+
+	exit(0);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+	struct passwd *pw;
+
+	pw = SAFE_GETPWNAM("nobody");
+	nobody_gid = pw->pw_gid;
+	nobody_uid = pw->pw_uid;
+
+	SAFE_STATX(AT_FDCWD, "/", 0, STATX_MNT_ID_UNIQUE, &sx);
+	root_id = sx.data.stx_mnt_id;
+
+	SAFE_CHROOT(tst_tmpdir_path());
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.needs_root = 1,
+	.needs_tmpdir = 1,
+	.forks_child = 1,
+	.min_kver = "6.8",
+};
+
diff --git a/testcases/kernel/syscalls/listmount/listmount04.c b/testcases/kernel/syscalls/listmount/listmount04.c
new file mode 100644
index 000000000..d38408d2c
--- /dev/null
+++ b/testcases/kernel/syscalls/listmount/listmount04.c
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that listmount() raises the correct errors according with
+ * invalid data:
+ *
+ * - EFAULT: req or mnt_id are unaccessible memories
+ * - EINVAL: invalid flags or mnt_id request
+ * - ENOENT: non-existent mount point
+ */
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "lapi/mount.h"
+#include "lapi/syscalls.h"
+
+#define MNT_SIZE 32
+
+static struct mnt_id_req *request;
+static uint64_t mnt_ids[MNT_SIZE];
+
+static struct tcase {
+	int req_usage;
+	uint32_t size;
+	uint32_t spare;
+	uint64_t mnt_id;
+	uint64_t param;
+	uint64_t *mnt_ids;
+	size_t nr_mnt_ids;
+	uint64_t flags;
+	int exp_errno;
+	char *msg;
+} tcases[] = {
+	{
+		.req_usage = 0,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = EFAULT,
+		.msg = "request points to unaccessible memory",
+	},
+	{
+		.req_usage = 1,
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = LSMT_ROOT,
+		.mnt_ids = NULL,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = EFAULT,
+		.msg = "mnt_ids points to unaccessible memory",
+	},
+	{
+		.req_usage = 1,
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = LSMT_ROOT,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.flags = -1,
+		.exp_errno = EINVAL,
+		.msg = "invalid flags",
+	},
+	{
+		.req_usage = 1,
+		.size = 0,
+		.mnt_id = LSMT_ROOT,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = EINVAL,
+		.msg = "insufficient mnt_id_req.size",
+	},
+	{
+		.req_usage = 1,
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.spare = -1,
+		.mnt_id = LSMT_ROOT,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = EINVAL,
+		.msg = "invalid mnt_id_req.spare",
+	},
+	{
+		.req_usage = 1,
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = LSMT_ROOT,
+		.param = STATMOUNT_PROPAGATE_FROM + 1,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = EINVAL,
+		.msg = "invalid mnt_id_req.param",
+	},
+	{
+		.req_usage = 1,
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = 0,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = EINVAL,
+		.msg = "invalid mnt_id_req.mnt_id",
+	},
+	{
+		.req_usage = 1,
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = LSMT_ROOT - 1,
+		.mnt_ids = mnt_ids,
+		.nr_mnt_ids = MNT_SIZE,
+		.exp_errno = ENOENT,
+		.msg = "non-existant mnt_id",
+	},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+	struct mnt_id_req *req = NULL;
+
+	memset(mnt_ids, 0, sizeof(mnt_ids));
+
+	if (tc->req_usage) {
+		req = request;
+		req->mnt_id = tc->mnt_id;
+		req->param = tc->param;
+		req->size = tc->size;
+		req->spare = tc->spare;
+	}
+
+	TST_EXP_FAIL(tst_syscall(__NR_listmount, req, tc->mnt_ids,
+		tc->nr_mnt_ids, tc->flags), tc->exp_errno,
+		"%s", tc->msg);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.min_kver = "6.8",
+	.bufs = (struct tst_buffers []) {
+		{ &request, .size = sizeof(struct mnt_id_req) },
+		{},
+	},
+};
diff --git a/testcases/kernel/syscalls/llistxattr/llistxattr01.c b/testcases/kernel/syscalls/llistxattr/llistxattr01.c
index f59413265..5002fe96f 100644
--- a/testcases/kernel/syscalls/llistxattr/llistxattr01.c
+++ b/testcases/kernel/syscalls/llistxattr/llistxattr01.c
@@ -1,18 +1,15 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
-* Copyright (c) 2016 Fujitsu Ltd.
-* Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
-*/
-
-/*
-* Test Name: llistxattr01
-*
-* Description:
-* The testcase checks the basic functionality of the llistxattr(2).
-* llistxattr(2) retrieves the list of extended attribute names
-* associated with the link itself in the filesystem.
-*
-*/
+ * Copyright (c) 2016 Fujitsu Ltd.
+ * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Basic test for llistxattr(2), retrieves the list of extended attribute names
+ * associated with the link itself in the filesystem.
+ */
 
 #include "config.h"
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/llistxattr/llistxattr02.c b/testcases/kernel/syscalls/llistxattr/llistxattr02.c
index 6974f013b..c91d05f35 100644
--- a/testcases/kernel/syscalls/llistxattr/llistxattr02.c
+++ b/testcases/kernel/syscalls/llistxattr/llistxattr02.c
@@ -1,25 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
-* Copyright (c) 2016 Fujitsu Ltd.
-* Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
-*/
-
-/*
-* Test Name: llistxattr02
-*
-* Description:
-* 1) llistxattr(2) fails if the size of the list buffer is too small
-* to hold the result.
-* 2) llistxattr(2) fails if path is an empty string.
-* 3) llistxattr(2) fails when attempted to read from a invalid address.
-* 4) llistxattr(2) fails if path is longer than allowed.
-*
-* Expected Result:
-* 1) llistxattr(2) should return -1 and set errno to ERANGE.
-* 2) llistxattr(2) should return -1 and set errno to ENOENT.
-* 3) llistxattr(2) should return -1 and set errno to EFAULT.
-* 4) llistxattr(2) should return -1 and set errno to ENAMETOOLONG.
-*/
+ * Copyright (c) 2016 Fujitsu Ltd.
+ * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify llistxattr(2) returns -1 and set proper errno:
+ *
+ * - ERANGE if the size of the list buffer is too small to hold the result
+ * - ENOENT if path is an empty string
+ * - EFAULT when attempted to read from a invalid address
+ * - ENAMETOOLONG if path is longer than allowed
+ */
 
 #include "config.h"
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/llistxattr/llistxattr03.c b/testcases/kernel/syscalls/llistxattr/llistxattr03.c
index 940851f40..cbf8da026 100644
--- a/testcases/kernel/syscalls/llistxattr/llistxattr03.c
+++ b/testcases/kernel/syscalls/llistxattr/llistxattr03.c
@@ -1,17 +1,16 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
-* Copyright (c) 2016 Fujitsu Ltd.
-* Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
-*/
-
-/*
-* Test Name: llistxattr03
-*
-* Description:
-* llistxattr is identical to listxattr. an empty buffer of size zero
-* can return the current size of the list of extended attribute names,
-* which can be used to estimate a suitable buffer.
-*/
+ * Copyright (c) 2016 Fujitsu Ltd.
+ * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that llistxattr(2) call with zero size returns the current size of the
+ * list of extended attribute names, which can be used to determine the size of
+ * the buffer that should be supplied in a subsequent llistxattr(2) call.
+ */
 
 #include "config.h"
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/lremovexattr/lremovexattr01.c b/testcases/kernel/syscalls/lremovexattr/lremovexattr01.c
index 590f5a6f3..ec27bbbc7 100644
--- a/testcases/kernel/syscalls/lremovexattr/lremovexattr01.c
+++ b/testcases/kernel/syscalls/lremovexattr/lremovexattr01.c
@@ -4,10 +4,9 @@
  * Author: Rafael David Tinoco <rafael.tinoco@linaro.org>
  */
 
-/*
- * Test Name: lremovexattr01
+/*\
+ * [Description]
  *
- * Description:
  * lremovexattr(2) removes the extended attribute identified by a name and
  * associated with a given path in the filesystem. Unlike removexattr(2),
  * lremovexattr(2) removes the attribute from the symbolic link only, and not
diff --git a/testcases/kernel/syscalls/lstat/.gitignore b/testcases/kernel/syscalls/lstat/.gitignore
index a497a445f..72cba871f 100644
--- a/testcases/kernel/syscalls/lstat/.gitignore
+++ b/testcases/kernel/syscalls/lstat/.gitignore
@@ -2,3 +2,5 @@
 /lstat01_64
 /lstat02
 /lstat02_64
+/lstat03
+/lstat03_64
diff --git a/testcases/kernel/syscalls/lstat/lstat03.c b/testcases/kernel/syscalls/lstat/lstat03.c
new file mode 100644
index 000000000..d48af180b
--- /dev/null
+++ b/testcases/kernel/syscalls/lstat/lstat03.c
@@ -0,0 +1,98 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ * Author: David Fenner, Jon Hendrickson
+ * Copyright (C) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that lstat() provides correct information according
+ * with device, access time, block size, ownership, etc.
+ * The implementation provides a set of tests which are specific for each one
+ * of the `struct stat` used to read file and symlink information.
+ */
+
+#include "tst_test.h"
+
+#define FILENAME "file.txt"
+#define MNTPOINT "mntpoint"
+#define SYMBNAME MNTPOINT"/file_symlink"
+
+static struct stat *file_stat;
+static struct stat *symb_stat;
+
+static void run(void)
+{
+	SAFE_LSTAT(FILENAME, file_stat);
+	SAFE_LSTAT(SYMBNAME, symb_stat);
+
+	TST_EXP_EXPR(file_stat->st_dev != symb_stat->st_dev);
+	TST_EXP_EXPR(file_stat->st_mode != symb_stat->st_mode);
+	TST_EXP_EXPR(file_stat->st_nlink != symb_stat->st_nlink);
+	TST_EXP_EXPR(file_stat->st_ino != symb_stat->st_ino);
+	TST_EXP_EXPR(file_stat->st_uid != symb_stat->st_uid);
+	TST_EXP_EXPR(file_stat->st_gid != symb_stat->st_gid);
+	TST_EXP_EXPR(file_stat->st_size != symb_stat->st_size);
+	TST_EXP_EXPR(file_stat->st_blocks != symb_stat->st_blocks);
+	TST_EXP_EXPR(file_stat->st_blksize != symb_stat->st_blksize);
+	TST_EXP_EXPR(file_stat->st_atime != symb_stat->st_atime);
+	TST_EXP_EXPR(file_stat->st_mtime != symb_stat->st_mtime);
+	TST_EXP_EXPR(file_stat->st_ctime != symb_stat->st_ctime);
+}
+
+static void setup(void)
+{
+	char opt_bsize[32];
+	const char *const fs_opts[] = {opt_bsize, NULL};
+	struct stat sb;
+	int pagesize;
+	int fd;
+
+	/* change st_blksize / st_dev */
+	SAFE_STAT(".", &sb);
+	pagesize = sb.st_blksize == 4096 ? 1024 : 4096;
+
+	snprintf(opt_bsize, sizeof(opt_bsize), "-b %i", pagesize);
+	SAFE_MKFS(tst_device->dev, tst_device->fs_type, fs_opts, NULL);
+	SAFE_MOUNT(tst_device->dev, MNTPOINT, tst_device->fs_type, 0, 0);
+
+	SAFE_TOUCH(FILENAME, 0777, NULL);
+
+	/* change st_nlink */
+	SAFE_LINK(FILENAME, "linked_file");
+
+	/* change st_uid and st_gid */
+	SAFE_CHOWN(FILENAME, 1000, 1000);
+
+	/* change st_size */
+	fd = SAFE_OPEN(FILENAME, O_WRONLY, 0777);
+	tst_fill_fd(fd, 'a', TST_KB, 500);
+	SAFE_CLOSE(fd);
+
+	/* change st_atime / st_mtime / st_ctime */
+	usleep(1001000);
+
+	SAFE_SYMLINK(FILENAME, SYMBNAME);
+}
+
+static void cleanup(void)
+{
+	if (tst_is_mounted(MNTPOINT))
+		SAFE_UMOUNT(MNTPOINT);
+}
+
+static struct tst_test test = {
+	.setup = setup,
+	.cleanup = cleanup,
+	.test_all = run,
+	.needs_root = 1,
+	.needs_device = 1,
+	.mntpoint = MNTPOINT,
+	.bufs = (struct tst_buffers []) {
+		{&file_stat, .size = sizeof(struct stat)},
+		{&symb_stat, .size = sizeof(struct stat)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/madvise/.gitignore b/testcases/kernel/syscalls/madvise/.gitignore
index 722ac3c34..758e601a9 100644
--- a/testcases/kernel/syscalls/madvise/.gitignore
+++ b/testcases/kernel/syscalls/madvise/.gitignore
@@ -8,3 +8,4 @@
 /madvise09
 /madvise10
 /madvise11
+/madvise12
diff --git a/testcases/kernel/syscalls/madvise/madvise06.c b/testcases/kernel/syscalls/madvise/madvise06.c
index b227840df..9cc64ceb5 100644
--- a/testcases/kernel/syscalls/madvise/madvise06.c
+++ b/testcases/kernel/syscalls/madvise/madvise06.c
@@ -242,7 +242,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.needs_tmpdir = 1,
 	.needs_root = 1,
-	.max_runtime = 60,
+	.timeout = 60,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.save_restore = (const struct tst_path_val[]) {
 		{"/proc/sys/vm/swappiness", NULL,
diff --git a/testcases/kernel/syscalls/madvise/madvise11.c b/testcases/kernel/syscalls/madvise/madvise11.c
index fe27a18d8..cfe9d7f17 100644
--- a/testcases/kernel/syscalls/madvise/madvise11.c
+++ b/testcases/kernel/syscalls/madvise/madvise11.c
@@ -432,7 +432,7 @@ static struct tst_test test = {
 		"CONFIG_MEMORY_FAILURE=y",
 		NULL
 	},
-	.max_runtime = 30,
+	.runtime = 30,
 	.needs_checkpoints = 1,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/madvise/madvise12.c b/testcases/kernel/syscalls/madvise/madvise12.c
new file mode 100644
index 000000000..19f9f9d10
--- /dev/null
+++ b/testcases/kernel/syscalls/madvise/madvise12.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that MADV_GUARD_INSTALL is causing SIGSEGV when someone is accessing
+ * memory advised with it.
+ *
+ * This is a test for feature implemented in
+ * 662df3e5c376 ("mm: madvise: implement lightweight guard page mechanism")
+ *
+ * [Algorithm]
+ *
+ * - allocate a certain amount of memory
+ * - advise memory with MADV_GUARD_INSTALL
+ * - access to memory from within a child and verify it gets killed by SIGSEGV
+ * - release memory with MADV_GUARD_REMOVE
+ * - verify that memory has not been modified before child got killed
+ * - modify memory within a new child
+ * - verify that memory is accessable and child was not killed by SIGSEGV
+ */
+
+#include "tst_test.h"
+#include "lapi/mmap.h"
+
+#define MAP_SIZE (8 * TST_KB)
+
+static char *addr;
+
+static void run(void)
+{
+	pid_t pid;
+	int status;
+
+	memset(addr, 0, MAP_SIZE);
+
+	TST_EXP_PASS(madvise(addr, MAP_SIZE, MADV_GUARD_INSTALL));
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		tst_res(TINFO, "Modifying memory content");
+
+		memset(addr, 'a', MAP_SIZE);
+		exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV)
+		tst_res(TPASS, "Child ended by SIGSEGV as expected");
+	else
+		tst_res(TFAIL, "Child: %s", tst_strstatus(status));
+
+	TST_EXP_PASS(madvise(addr, MAP_SIZE, MADV_GUARD_REMOVE));
+
+	for (int i = 0; i < MAP_SIZE; i++) {
+		if (addr[i] == 'a') {
+			tst_res(TFAIL, "Memory content has been modified");
+			return;
+		}
+	}
+
+	tst_res(TPASS, "Memory content didn't change");
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		tst_res(TINFO, "Modifying memory content");
+
+		memset(addr, 'b', MAP_SIZE);
+		exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (!WIFSIGNALED(status))
+		tst_res(TPASS, "Child ended without being signaled");
+	else
+		tst_res(TFAIL, "Child ended with %s", tst_strstatus(status));
+}
+
+static void setup(void)
+{
+	addr = SAFE_MMAP(NULL, MAP_SIZE,
+			PROT_READ | PROT_WRITE,
+			MAP_PRIVATE | MAP_ANONYMOUS,
+			-1, 0);
+}
+
+static void cleanup(void)
+{
+	if (addr)
+		SAFE_MUNMAP(addr, MAP_SIZE);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_root = 1,
+	.forks_child = 1,
+	.min_kver = "6.13",
+};
diff --git a/testcases/kernel/syscalls/mbind/Makefile b/testcases/kernel/syscalls/mbind/Makefile
index ed7d4375c..2a7d35693 100644
--- a/testcases/kernel/syscalls/mbind/Makefile
+++ b/testcases/kernel/syscalls/mbind/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS=ltpnuma
+LTPLIBS = numa
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/migrate_pages/migrate_pages03.c b/testcases/kernel/syscalls/migrate_pages/migrate_pages03.c
index 4d3299b61..59d7e79db 100644
--- a/testcases/kernel/syscalls/migrate_pages/migrate_pages03.c
+++ b/testcases/kernel/syscalls/migrate_pages/migrate_pages03.c
@@ -139,7 +139,7 @@ static void migrate_test(void)
 }
 
 static struct tst_test test = {
-	.max_runtime = 300,
+	.runtime = 300,
 	.needs_root = 1,
 	.setup = setup,
 	.cleanup = cleanup,
diff --git a/testcases/kernel/syscalls/mincore/mincore03.c b/testcases/kernel/syscalls/mincore/mincore03.c
index c3ef2d203..774fce98b 100644
--- a/testcases/kernel/syscalls/mincore/mincore03.c
+++ b/testcases/kernel/syscalls/mincore/mincore03.c
@@ -16,7 +16,6 @@
 #include <unistd.h>
 #include <sys/mman.h>
 #include "tst_test.h"
-#include "pgsize_helpers.h"
 
 #define NUM_PAGES 3
 
@@ -47,7 +46,7 @@ static void setup(void)
 static void test_mincore(unsigned int test_nr)
 {
 	const struct tcase *tc = &tcases[test_nr];
-	DECLARE_MINCORE_VECTOR(vec, NUM_PAGES);
+	unsigned char vec[NUM_PAGES];
 	int locked_pages;
 	int count, mincore_ret;
 
@@ -59,10 +58,9 @@ static void test_mincore(unsigned int test_nr)
 	if (mincore_ret == -1)
 		tst_brk(TBROK | TERRNO, "mincore failed");
 	locked_pages = 0;
-	for (count = 0; count < nr_pgs_to_nr_kernel_pgs(NUM_PAGES); count++)
+	for (count = 0; count < NUM_PAGES; count++)
 		if (vec[count] & 1)
 			locked_pages++;
-	locked_pages = nr_kernel_pgs_to_nr_pgs(locked_pages);
 
 	if (locked_pages == tc->expected_pages)
 		tst_res(TPASS, "mincore() reports %s", tc->desc);
diff --git a/testcases/kernel/syscalls/mincore/mincore04.c b/testcases/kernel/syscalls/mincore/mincore04.c
index f718301fb..ed0ab7dfa 100644
--- a/testcases/kernel/syscalls/mincore/mincore04.c
+++ b/testcases/kernel/syscalls/mincore/mincore04.c
@@ -20,7 +20,6 @@
 #include <fcntl.h>
 #include <stdlib.h>
 #include "tst_test.h"
-#include "pgsize_helpers.h"
 
 #define NUM_PAGES 3
 
@@ -65,18 +64,17 @@ static int count_pages_in_cache(void)
 {
 	int locked_pages = 0;
 	int count, ret;
-	DECLARE_MINCORE_VECTOR(vec, NUM_PAGES);
+	unsigned char vec[NUM_PAGES];
 
 	TST_CHECKPOINT_WAIT(0);
 
 	ret = mincore(ptr, size, vec);
 	if (ret == -1)
 		tst_brk(TBROK | TERRNO, "mincore failed");
-	for (count = 0; count < nr_pgs_to_nr_kernel_pgs(NUM_PAGES); count++) {
+	for (count = 0; count < NUM_PAGES; count++) {
 		if (vec[count] & 1)
 			locked_pages++;
 	}
-	locked_pages = nr_kernel_pgs_to_nr_pgs(locked_pages);
 
 	TST_CHECKPOINT_WAKE(1);
 	return locked_pages;
diff --git a/testcases/kernel/syscalls/mkdir/mkdir03.c b/testcases/kernel/syscalls/mkdir/mkdir03.c
index 20089c9c9..85d46801e 100644
--- a/testcases/kernel/syscalls/mkdir/mkdir03.c
+++ b/testcases/kernel/syscalls/mkdir/mkdir03.c
@@ -85,10 +85,8 @@ static void verify_mkdir(unsigned int n)
 static void setup(void)
 {
 	unsigned int i;
-	char *tmpdir = tst_get_tmpdir();
 
-	SAFE_SYMLINK(tmpdir, TST_SYMLINK);
-	free(tmpdir);
+	SAFE_SYMLINK(tst_tmpdir_path(), TST_SYMLINK);
 
 	SAFE_MKFIFO(TST_PIPE, 0777);
 	SAFE_MKDIR(TST_FOLDER, 0777);
diff --git a/testcases/kernel/syscalls/mlock/mlock03.c b/testcases/kernel/syscalls/mlock/mlock03.c
index 202a9063d..602bb65d8 100644
--- a/testcases/kernel/syscalls/mlock/mlock03.c
+++ b/testcases/kernel/syscalls/mlock/mlock03.c
@@ -31,18 +31,16 @@
 #include "tst_test.h"
 #include "tst_safe_stdio.h"
 
-#define KB 1024
-
 static void verify_mlock(void)
 {
 	long from, to;
 	long first = -1, last = -1;
-	char b[KB];
+	char b[TST_KB];
 	FILE *fp;
 
 	fp = SAFE_FOPEN("/proc/self/maps", "r");
 	while (!feof(fp)) {
-		if (!fgets(b, KB - 1, fp))
+		if (!fgets(b, TST_KB - 1, fp))
 			break;
 		b[strlen(b) - 1] = '\0';
 		if (sscanf(b, "%lx-%lx", &from, &to) != 2) {
@@ -53,7 +51,7 @@ static void verify_mlock(void)
 
 		/* Record the initial stack size. */
 		if (strstr(b, "[stack]") != NULL)
-			first = (to - from) / KB;
+			first = (to - from) / TST_KB;
 
 		tst_res(TINFO, "mlock [%lx,%lx]", from, to);
 		if (mlock((const void *)from, to - from) == -1)
@@ -65,7 +63,7 @@ static void verify_mlock(void)
 
 		/* Record the final stack size. */
 		if (strstr(b, "[stack]") != NULL)
-			last = (to - from) / KB;
+			last = (to - from) / TST_KB;
 	}
 	SAFE_FCLOSE(fp);
 
diff --git a/testcases/kernel/syscalls/mlock2/mlock201.c b/testcases/kernel/syscalls/mlock2/mlock201.c
index 1994a119d..b0e5f12b7 100644
--- a/testcases/kernel/syscalls/mlock2/mlock201.c
+++ b/testcases/kernel/syscalls/mlock2/mlock201.c
@@ -25,19 +25,17 @@
 #include "tst_test.h"
 #include "lapi/syscalls.h"
 #include "lapi/mlock2.h"
-#include "pgsize_helpers.h"
 
 #define PAGES	8
 #define HPAGES	(PAGES / 2)
 
 static size_t pgsz;
-
-static DECLARE_MINCORE_VECTOR(vec, PAGES+1);
+static unsigned char vec[PAGES+1];
 
 static struct tcase {
 	size_t populate_pages;
 	size_t lock_pages;
-	ssize_t offset; /* Can be negative */
+	size_t offset;
 	size_t exp_vmlcks;
 	size_t exp_present_pages;
 	int flag;
@@ -80,12 +78,12 @@ static size_t check_locked_pages(char *addr, size_t len, size_t num_pgs)
 
 	SAFE_MINCORE(addr, len, vec);
 
-	for (n = 0; n < nr_pgs_to_nr_kernel_pgs(num_pgs); n++) {
+	for (n = 0; n < num_pgs; n++) {
 		if (vec[n] & 1)
 			act_pages++;
 	}
 
-	return nr_kernel_pgs_to_nr_pgs(act_pages);
+	return act_pages;
 }
 
 static void verify_mlock2(unsigned int n)
@@ -139,7 +137,6 @@ end2:
 static void setup(void)
 {
 	pgsz = getpagesize();
-	MLOCK_PAGE_SIZE_EMULATION_OFFSET(tcases);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/mmap/mmap01.c b/testcases/kernel/syscalls/mmap/mmap01.c
index 99266b57f..05802bceb 100644
--- a/testcases/kernel/syscalls/mmap/mmap01.c
+++ b/testcases/kernel/syscalls/mmap/mmap01.c
@@ -1,194 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) International Business Machines  Corp., 2001
- *
- * This program is free software;  you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY;  without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- * the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program;  if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Copyright (c) 2024 Ricardo B. Marliere <rbm@suse.com>
+ * 07/2001 Ported by Wayne Boyer
  */
 
-/*
- * Test Description:
- *  Verify that, mmap() succeeds when used to map a file where size of the
- *  file is not a multiple of the page size, the memory area beyond the end
- *  of the file to the end of the page is accessible. Also, verify that
- *  this area is all zeroed and the modifications done to this area are
- *  not written to the file.
+/*\
+ * [Description]
  *
- * Expected Result:
- *  mmap() should succeed returning the address of the mapped region.
- *  The memory area beyond the end of file to the end of page should be
- *  filled with zero.
- *  The changes beyond the end of file should not get written to the file.
+ * Verify that mmap() succeeds when used to map a file where size of the
+ * file is not a multiple of the page size, the memory area beyond the end
+ * of the file to the end of the page is accessible. Also, verify that
+ * this area is all zeroed and the modifications done to this area are
+ * not written to the file.
  *
- * HISTORY
- *	07/2001 Ported by Wayne Boyer
+ * mmap() should succeed returning the address of the mapped region.
+ * The memory area beyond the end of file to the end of page should be
+ * filled with zero. The changes beyond the end of file should not get
+ * written to the file.
  */
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <errno.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <string.h>
-#include <signal.h>
-#include <stdint.h>
-#include <sys/stat.h>
-#include <sys/mman.h>
-#include <sys/shm.h>
-
-#include "test.h"
-
-#define TEMPFILE	"mmapfile"
-
-char *TCID = "mmap01";
-int TST_TOTAL = 1;
+
+#include "tst_test.h"
+
+#define TEMPFILE "mmapfile"
+#define STRING "hello world\n"
 
 static char *addr;
 static char *dummy;
 static size_t page_sz;
 static size_t file_sz;
 static int fildes;
-static char cmd_buffer[BUFSIZ];
 
-static void setup(void);
-static void cleanup(void);
-
-int main(int ac, char **av)
+static void check_file(void)
 {
-	int lc;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
-		tst_count = 0;
-
-		/*
-		 * Call mmap to map the temporary file beyond EOF
-		 * with write access.
-		 */
-		errno = 0;
-		addr = mmap(NULL, page_sz, PROT_READ | PROT_WRITE,
-			    MAP_FILE | MAP_SHARED, fildes, 0);
-
-		/* Check for the return value of mmap() */
-		if (addr == MAP_FAILED) {
-			tst_resm(TFAIL | TERRNO, "mmap of %s failed", TEMPFILE);
-			continue;
-		}
-
-		/*
-		 * Check if mapped memory area beyond EOF are
-		 * zeros and changes beyond EOF are not written
-		 * to file.
-		 */
-		if (memcmp(&addr[file_sz], dummy, page_sz - file_sz)) {
-			tst_brkm(TFAIL, cleanup,
-				 "mapped memory area contains invalid "
-				 "data");
-		}
-
-		/*
-		 * Initialize memory beyond file size
-		 */
-		addr[file_sz] = 'X';
-		addr[file_sz + 1] = 'Y';
-		addr[file_sz + 2] = 'Z';
-
-		/*
-		 * Synchronize the mapped memory region
-		 * with the file.
-		 */
-		if (msync(addr, page_sz, MS_SYNC) != 0) {
-			tst_brkm(TFAIL | TERRNO, cleanup,
-				 "failed to synchronize mapped file");
-		}
-
-		/*
-		 * Now, Search for the pattern 'XYZ' in the
-		 * temporary file.  The pattern should not be
-		 * found and the return value should be 1.
-		 */
-		if (system(cmd_buffer) != 0) {
-			tst_resm(TPASS,
-				 "Functionality of mmap() successful");
-		} else {
-			tst_resm(TFAIL,
-				 "Specified pattern found in file");
-		}
-
-		/* Clean up things in case we are looping */
-		/* Unmap the mapped memory */
-		if (munmap(addr, page_sz) != 0) {
-			tst_brkm(TFAIL | TERRNO, NULL, "munmap failed");
-		}
+	int i, fildes, buf_len = sizeof(STRING) + 3;
+	char buf[buf_len];
+	ssize_t len;
+
+	fildes = SAFE_OPEN(TEMPFILE, O_RDONLY);
+	len = SAFE_READ(0, fildes, buf, sizeof(buf));
+	SAFE_CLOSE(fildes);
+
+	if (len != strlen(STRING)) {
+		tst_res(TFAIL, "Read %zi expected %zu", len, strlen(STRING));
+		return;
 	}
 
-	cleanup();
-	tst_exit();
+	for (i = 0; i < len; i++)
+		if (buf[i] == 'X' || buf[i] == 'Y' || buf[i] == 'Z')
+			break;
+
+	if (i == len)
+		tst_res(TPASS, "Specified pattern not found in file");
+	else
+		tst_res(TFAIL, "Specified pattern found in file");
 }
 
-static void setup(void)
+static void set_file(void)
 {
+	char *write_buf = STRING;
 	struct stat stat_buf;
-	char Path_name[PATH_MAX];
-	char write_buf[] = "hello world\n";
-
-	tst_sig(FORK, DEF_HANDLER, cleanup);
 
-	TEST_PAUSE;
-
-	tst_tmpdir();
-
-	/* Get the path of temporary file to be created */
-	if (getcwd(Path_name, sizeof(Path_name)) == NULL) {
-		tst_brkm(TFAIL | TERRNO, cleanup,
-			 "getcwd failed to get current working directory");
+	/* Reset file */
+	if (fildes > 0) {
+		SAFE_CLOSE(fildes);
+		SAFE_UNLINK(TEMPFILE);
 	}
 
-	/* Creat a temporary file used for mapping */
-	if ((fildes = open(TEMPFILE, O_RDWR | O_CREAT, 0666)) < 0) {
-		tst_brkm(TFAIL, cleanup, "opening %s failed", TEMPFILE);
-	}
+	/* Create a temporary file used for mapping */
+	fildes = SAFE_OPEN(TEMPFILE, O_RDWR | O_CREAT, 0666);
 
 	/* Write some data into temporary file */
-	if (write(fildes, write_buf, strlen(write_buf)) != (long)strlen(write_buf)) {
-		tst_brkm(TFAIL, cleanup, "writing to %s", TEMPFILE);
-	}
+	SAFE_WRITE(SAFE_WRITE_ALL, fildes, write_buf, strlen(write_buf));
 
 	/* Get the size of temporary file */
-	if (stat(TEMPFILE, &stat_buf) < 0) {
-		tst_brkm(TFAIL | TERRNO, cleanup, "stat of %s failed",
-			 TEMPFILE);
-	}
+	SAFE_STAT(TEMPFILE, &stat_buf);
 	file_sz = stat_buf.st_size;
+}
 
-	page_sz = getpagesize();
-
-	/* Allocate and initialize dummy string of system page size bytes */
-	if ((dummy = calloc(page_sz, sizeof(char))) == NULL) {
-		tst_brkm(TFAIL, cleanup, "calloc failed (dummy)");
+static void run(void)
+{
+	set_file();
+
+	addr = SAFE_MMAP(NULL, page_sz, PROT_READ | PROT_WRITE,
+			 MAP_FILE | MAP_SHARED, fildes, 0);
+
+	/*
+	 * Check if mapped memory area beyond EOF are zeros and changes beyond
+	 * EOF are not written to file.
+	 */
+	if (memcmp(&addr[file_sz], dummy, page_sz - file_sz))
+		tst_brk(TFAIL, "mapped memory area contains invalid data");
+
+	/*
+	 * Initialize memory beyond file size
+	 */
+	addr[file_sz] = 'X';
+	addr[file_sz + 1] = 'Y';
+	addr[file_sz + 2] = 'Z';
+
+	/*
+	 * Synchronize the mapped memory region with the file.
+	 */
+	SAFE_MSYNC(addr, page_sz, MS_SYNC);
+
+	/*
+	 * Now, search for the pattern 'XYZ' in the temporary file.
+	 * The pattern should not be found and the return value should be 1.
+	 */
+	if (!SAFE_FORK()) {
+		check_file();
+		SAFE_MUNMAP(addr, page_sz);
+		exit(0);
 	}
 
-	/* Create the command which will be executed in the test */
-	sprintf(cmd_buffer, "grep XYZ %s/%s > /dev/null", Path_name, TEMPFILE);
+	SAFE_MUNMAP(addr, page_sz);
 }
 
 static void cleanup(void)
 {
-	close(fildes);
-	free(dummy);
-	tst_rmdir();
+	if (dummy)
+		free(dummy);
+
+	if (fildes > 0)
+		SAFE_CLOSE(fildes);
 }
+
+static void setup(void)
+{
+	page_sz = getpagesize();
+
+	/* Allocate and initialize dummy string of system page size bytes */
+	dummy = SAFE_CALLOC(page_sz, 1);
+}
+
+static struct tst_test test = {
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+	.test_all = run,
+	.forks_child = 1,
+};
diff --git a/testcases/kernel/syscalls/mmap/mmap09.c b/testcases/kernel/syscalls/mmap/mmap09.c
index 16634dc30..133a890e4 100644
--- a/testcases/kernel/syscalls/mmap/mmap09.c
+++ b/testcases/kernel/syscalls/mmap/mmap09.c
@@ -45,7 +45,7 @@ static void verify_mmap(unsigned int nr)
 
 static void setup(void)
 {
-	fd = SAFE_OPEN("/tmp/mmaptest", O_RDWR | O_CREAT, 0666);
+	fd = SAFE_OPEN("mmaptest", O_RDWR | O_CREAT, 0666);
 
 	/* set the file to initial size */
 	SAFE_FTRUNCATE(fd, MAPSIZE);
diff --git a/testcases/kernel/syscalls/mmap/mmap14.c b/testcases/kernel/syscalls/mmap/mmap14.c
index 31632601b..de35982f9 100644
--- a/testcases/kernel/syscalls/mmap/mmap14.c
+++ b/testcases/kernel/syscalls/mmap/mmap14.c
@@ -1,124 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2013 FNST, DAN LI <li.dan@cn.fujitsu.com>
- *
- * This program is free software;  you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY;  without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- * the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program;  if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Copyright (c) 2024 Ricardo B. Marliere <rbm@suse.com>
  */
 
-/*
- * Test Description:
- *  Verify MAP_LOCKED works fine.
- *  "Lock the pages of the mapped region into memory in the manner of mlock(2)."
+/*\
+ * [Description]
+ *
+ * Verify basic functionality of mmap(2) with MAP_LOCKED.
  *
- * Expected Result:
- *  mmap() should succeed returning the address of the mapped region,
- *  and this region should be locked into memory.
+ * mmap(2) should succeed returning the address of the mapped region,
+ * and this region should be locked into memory.
  */
 #include <stdio.h>
 #include <sys/mman.h>
 
-#include "test.h"
+#include "tst_test.h"
+#include "tst_safe_stdio.h"
 
 #define TEMPFILE        "mmapfile"
 #define MMAPSIZE        (1UL<<20)
 #define LINELEN         256
 
-char *TCID = "mmap14";
-int TST_TOTAL = 1;
-
 static char *addr;
 
-static void getvmlck(unsigned int *lock_sz);
-static void setup(void);
-static void cleanup(void);
-
-int main(int argc, char *argv[])
-{
-	int lc;
-	unsigned int sz_before;
-	unsigned int sz_after;
-	unsigned int sz_ch;
-
-	tst_parse_opts(argc, argv, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
-		tst_count = 0;
-
-		getvmlck(&sz_before);
-
-		addr = mmap(NULL, MMAPSIZE, PROT_READ | PROT_WRITE,
-			    MAP_PRIVATE | MAP_LOCKED | MAP_ANONYMOUS,
-			    -1, 0);
-
-		if (addr == MAP_FAILED) {
-			tst_resm(TFAIL | TERRNO, "mmap of %s failed", TEMPFILE);
-			continue;
-		}
-
-		getvmlck(&sz_after);
-
-		sz_ch = sz_after - sz_before;
-		if (sz_ch == MMAPSIZE / 1024) {
-			tst_resm(TPASS, "Functionality of mmap() "
-					"successful");
-		} else {
-			tst_resm(TFAIL, "Expected %luK locked, "
-					"get %uK locked",
-					MMAPSIZE / 1024, sz_ch);
-		}
-
-		if (munmap(addr, MMAPSIZE) != 0)
-			tst_brkm(TFAIL | TERRNO, NULL, "munmap failed");
-	}
-
-	cleanup();
-	tst_exit();
-}
-
-void getvmlck(unsigned int *lock_sz)
+static void getvmlck(unsigned int *lock_sz)
 {
-	int ret;
 	char line[LINELEN];
 	FILE *fstatus = NULL;
 
-	fstatus = fopen("/proc/self/status", "r");
-	if (fstatus == NULL)
-		tst_brkm(TFAIL | TERRNO, NULL, "Open dev status failed");
+	fstatus = SAFE_FOPEN("/proc/self/status", "r");
 
 	while (fgets(line, LINELEN, fstatus) != NULL)
 		if (strstr(line, "VmLck") != NULL)
 			break;
 
-	ret = sscanf(line, "%*[^0-9]%d%*[^0-9]", lock_sz);
-	if (ret != 1)
-		tst_brkm(TFAIL | TERRNO, NULL, "Get lock size failed");
+	SAFE_SSCANF(line, "%*[^0-9]%d%*[^0-9]", lock_sz);
 
-	fclose(fstatus);
+	SAFE_FCLOSE(fstatus);
 }
 
-static void setup(void)
+static void run(void)
 {
-	tst_require_root();
+	unsigned int sz_before;
+	unsigned int sz_after;
+	unsigned int sz_ch;
 
-	tst_sig(FORK, DEF_HANDLER, cleanup);
+	getvmlck(&sz_before);
 
-	TEST_PAUSE;
-}
+	addr = mmap(NULL, MMAPSIZE, PROT_READ | PROT_WRITE,
+			MAP_PRIVATE | MAP_LOCKED | MAP_ANONYMOUS, -1, 0);
 
-static void cleanup(void)
-{
+	if (addr == MAP_FAILED) {
+		tst_res(TFAIL | TERRNO, "mmap() of %s failed", TEMPFILE);
+		return;
+	}
+
+	getvmlck(&sz_after);
+
+	sz_ch = sz_after - sz_before;
+	if (sz_ch == MMAPSIZE / 1024) {
+		tst_res(TPASS, "mmap() locked %uK", sz_ch);
+	} else {
+		tst_res(TFAIL, "Expected %luK locked, get %uK locked",
+				MMAPSIZE / 1024, sz_ch);
+	}
+
+	SAFE_MUNMAP(addr, MMAPSIZE);
 }
+
+static struct tst_test test = {
+	.needs_root = 1,
+	.test_all = run,
+};
diff --git a/testcases/kernel/syscalls/mmap/mmap16.c b/testcases/kernel/syscalls/mmap/mmap16.c
index 4e0d8a3f4..6b1708dff 100644
--- a/testcases/kernel/syscalls/mmap/mmap16.c
+++ b/testcases/kernel/syscalls/mmap/mmap16.c
@@ -176,19 +176,15 @@ static struct tst_test test = {
 	.needs_checkpoints = 1,
 	.mount_device = 1,
 	.mntpoint = MNTPOINT,
-	.dev_fs_type = "ext4",
-	.dev_fs_opts = (const char *const[]){
-		"-b",
-		"1024",
-		NULL,
-	},
-	.dev_extra_opts = (const char *const[]){
-		"10240",
-		NULL,
-	},
-	.needs_cmds = (const char *const[]){
-		"mkfs.ext4",
-		NULL,
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "ext4",
+			.mkfs_opts = (const char *const[]){
+				"-b", "1024", NULL
+			},
+			.mkfs_size_opt = "10240",
+		},
+		{}
 	},
 	.tags = (const struct tst_tag[]){
 		{"linux-git", "d6320cbfc929"},
diff --git a/testcases/kernel/syscalls/mount/mount06.c b/testcases/kernel/syscalls/mount/mount06.c
index 2376deab3..05d6fdf86 100644
--- a/testcases/kernel/syscalls/mount/mount06.c
+++ b/testcases/kernel/syscalls/mount/mount06.c
@@ -27,14 +27,14 @@
 #define MNTPOINT_DST "mntpoint2"
 
 static char *tmppath;
-static char mntpoint_src[PATH_MAX];
-static char mntpoint_dst[PATH_MAX];
-static char tstfiles_src[PATH_MAX];
-static char tstfiles_dst[PATH_MAX];
+static char *mntpoint_src;
+static char *mntpoint_dst;
+static char *tstfiles_src;
+static char *tstfiles_dst;
 
 static void setup(void)
 {
-	tmppath = tst_get_tmpdir();
+	tmppath = tst_tmpdir_path();
 
 	/*
 	 * Turn current dir into a private mount point being a parent
@@ -43,11 +43,10 @@ static void setup(void)
 	SAFE_MOUNT(tmppath, tmppath, "none", MS_BIND, NULL);
 	SAFE_MOUNT("none", tmppath, "none", MS_PRIVATE, NULL);
 
-	snprintf(mntpoint_src, PATH_MAX, "%s/%s", tmppath, MNTPOINT_SRC);
-	snprintf(mntpoint_dst, PATH_MAX, "%s/%s", tmppath, MNTPOINT_DST);
-
-	snprintf(tstfiles_src, PATH_MAX, "%s/%s/testfile", tmppath, MNTPOINT_SRC);
-	snprintf(tstfiles_dst, PATH_MAX, "%s/%s/testfile", tmppath, MNTPOINT_DST);
+	mntpoint_src = tst_tmpdir_genpath(MNTPOINT_SRC);
+	mntpoint_dst = tst_tmpdir_genpath(MNTPOINT_DST);
+	tstfiles_src = tst_tmpdir_genpath("%s/testfile", MNTPOINT_SRC);
+	tstfiles_dst = tst_tmpdir_genpath("%s/testfile", MNTPOINT_DST);
 
 	SAFE_MKDIR(mntpoint_dst, 0750);
 }
diff --git a/testcases/kernel/syscalls/mount/mount07.c b/testcases/kernel/syscalls/mount/mount07.c
index eb3fb55a0..8994d0f34 100644
--- a/testcases/kernel/syscalls/mount/mount07.c
+++ b/testcases/kernel/syscalls/mount/mount07.c
@@ -31,9 +31,9 @@
 
 #define MNTPOINT "mntpoint"
 
-static char test_file[PATH_MAX];
-static char link_file[PATH_MAX];
-static char temp_link_file[PATH_MAX];
+static char *test_file;
+static char *link_file;
+static char *temp_link_file;
 static int flag;
 
 static void setup_symlink(void)
@@ -114,15 +114,9 @@ static void test_statfs(bool nosymfollow)
 
 static void setup(void)
 {
-	char *tmpdir = tst_get_tmpdir();
-
-	snprintf(test_file, PATH_MAX, "%s/%s/test_file", tst_get_tmpdir(),
-			MNTPOINT);
-	snprintf(link_file, PATH_MAX, "%s/%s/link_file", tst_get_tmpdir(),
-			MNTPOINT);
-	snprintf(temp_link_file, PATH_MAX, "%s/%s/temp_link_file",
-			tst_get_tmpdir(), MNTPOINT);
-	free(tmpdir);
+	test_file = tst_tmpdir_genpath("%s/test_file", MNTPOINT);
+	link_file = tst_tmpdir_genpath("%s/link_file", MNTPOINT);
+	temp_link_file = tst_tmpdir_genpath("%s/temp_link_file", MNTPOINT);
 }
 
 static void cleanup(void)
diff --git a/testcases/kernel/syscalls/move_pages/move_pages04.c b/testcases/kernel/syscalls/move_pages/move_pages04.c
index f53453ab4..cde1f3120 100644
--- a/testcases/kernel/syscalls/move_pages/move_pages04.c
+++ b/testcases/kernel/syscalls/move_pages/move_pages04.c
@@ -1,58 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   Copyright (c) 2008 Vijay Kumar B. <vijaykumar@bravegnu.org>
- *
- *   Based on testcases/kernel/syscalls/waitpid/waitpid01.c
- *   Original copyright message:
- *
  *   Copyright (c) International Business Machines  Corp., 2001
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/*
- * NAME
- *	move_pages04.c
+/*\
+ * [Description]
  *
- * DESCRIPTION
- *      Failure when page does not exit.
+ * Verify that move_pages() properly reports failures when the memory area is
+ * not valid, no page is mapped yet or the shared zero page is mapped.
  *
- * ALGORITHM
+ * [Algorithm]
  *
- *      1. Pass zero page (allocated, but not written to) as one of the
- *         page addresses to move_pages().
- *      2. Check if the corresponding status is set to:
- *         -ENOENT for kernels < 4.3
- *         -EFAULT for kernels >= 4.3 [1]
+ *      1. Pass the address of a valid memory area where no page is
+ *         mapped yet (not read/written), the address of a valid memory area
+ *         where the shared zero page is mapped (read, but not written to)
+ *         and the address of an invalid memory area as page addresses to
+ *         move_pages().
+ *      2. Check if the corresponding status for "no page mapped" is set to
+ *         -ENOENT. Note that kernels >= 4.3 [1] and < 6.12 [2] wrongly returned
+ *         -EFAULT by accident.
+ *      3. Check if the corresponding status for "shared zero page" is set to:
+ *         -EFAULT. Note that kernels < 4.3 [1] wrongly returned -ENOENT.
+ *      4. Check if the corresponding status for "invalid memory area" is set
+ *         to -EFAULT.
  *
- * [1]
- * d899844e9c98 "mm: fix status code which move_pages() returns for zero page"
- *
- * USAGE:  <for command-line>
- *      move_pages04 [-c n] [-i n] [-I x] [-P x] [-t]
- *      where,  -c n : Run n copies concurrently.
- *              -i n : Execute test n times.
- *              -I x : Execute test for x seconds.
- *              -P x : Pause for x seconds between iterations.
- *              -t   : Turn on syscall timing.
- *
- * History
- *	05/2008 Vijay Kumar
- *		Initial Version.
- *
- * Restrictions
- *	None
+ *   [1] d899844e9c98 "mm: fix status code which move_pages() returns for zero page"
+ *   [2] 7dff875c9436 "mm/migrate: convert add_page_for_migration() from follow_page() to folio_walk"
  */
 
 #include <sys/mman.h>
@@ -61,124 +35,134 @@
 #include <unistd.h>
 #include <signal.h>
 #include <errno.h>
-#include "test.h"
+#include "tst_test.h"
 #include "move_pages_support.h"
 
-#define TEST_PAGES 2
+#define TEST_PAGES 4
 #define TEST_NODES 2
 #define TOUCHED_PAGES 1
-#define UNTOUCHED_PAGE (TEST_PAGES - 1)
-
-void setup(void);
-void cleanup(void);
-
-char *TCID = "move_pages04";
-int TST_TOTAL = 1;
+#define NO_PAGE TOUCHED_PAGES
+#define ZERO_PAGE (NO_PAGE + 1)
+#define INVALID_PAGE (ZERO_PAGE + 1)
 
-typedef void (*sighandler_t) (int);
-
-int main(int argc, char **argv)
+static void run(void)
 {
-
-	tst_parse_opts(argc, argv, NULL, NULL);
-
-	setup();
-
 #ifdef HAVE_NUMA_V2
 	unsigned int i;
-	int lc;
 	unsigned int from_node;
 	unsigned int to_node;
-	int ret, exp_status;
-
-	if ((tst_kvercmp(4, 3, 0)) >= 0)
-		exp_status = -EFAULT;
-	else
-		exp_status = -ENOENT;
+	int ret;
+	void *pages[TEST_PAGES] = { 0 };
+	int nodes[TEST_PAGES];
+	int status[TEST_PAGES];
+	unsigned long onepage = get_page_size();
+	char tmp;
 
 	ret = get_allowed_nodes(NH_MEMS, 2, &from_node, &to_node);
 	if (ret < 0)
-		tst_brkm(TBROK | TERRNO, cleanup, "get_allowed_nodes: %d", ret);
-
-	/* check for looping state if -i option is given */
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		void *pages[TEST_PAGES] = { 0 };
-		int nodes[TEST_PAGES];
-		int status[TEST_PAGES];
-		unsigned long onepage = get_page_size();
-
-		/* reset tst_count in case we are looping */
-		tst_count = 0;
-
-		ret = alloc_pages_on_node(pages, TOUCHED_PAGES, from_node);
-		if (ret == -1)
-			continue;
-
-		/* Allocate page and do not touch it. */
-		pages[UNTOUCHED_PAGE] = numa_alloc_onnode(onepage, from_node);
-		if (pages[UNTOUCHED_PAGE] == NULL) {
-			tst_resm(TBROK, "failed allocating page on node %d",
-				 from_node);
-			goto err_free_pages;
-		}
-
-		for (i = 0; i < TEST_PAGES; i++)
-			nodes[i] = to_node;
-
-		ret = numa_move_pages(0, TEST_PAGES, pages, nodes,
-				      status, MPOL_MF_MOVE);
-		if (ret == -1) {
-			tst_resm(TFAIL | TERRNO,
-				 "move_pages unexpectedly failed");
-			goto err_free_pages;
-		} else if (ret > 0) {
-			tst_resm(TINFO, "move_pages() returned %d", ret);
-		}
-
-		if (status[UNTOUCHED_PAGE] == exp_status) {
-			tst_resm(TPASS, "status[%d] has expected value",
-				 UNTOUCHED_PAGE);
-		} else {
-			tst_resm(TFAIL, "status[%d] is %s, expected %s",
-				UNTOUCHED_PAGE,
-				tst_strerrno(-status[UNTOUCHED_PAGE]),
-				tst_strerrno(-exp_status));
-		}
+		tst_brk(TBROK | TERRNO, "get_allowed_nodes: %d", ret);
 
-err_free_pages:
-		/* This is capable of freeing both the touched and
-		 * untouched pages.
-		 */
-		free_pages(pages, TEST_PAGES);
+	ret = alloc_pages_on_node(pages, TOUCHED_PAGES, from_node);
+	if (ret == -1)
+		tst_brk(TBROK, "failed allocating memory on node %d",
+			from_node);
+
+	/*
+	 * Allocate memory and do not touch it. Consequently, no
+	 * page will be faulted in / mapped into the page tables.
+	 */
+	pages[NO_PAGE] = numa_alloc_onnode(onepage, from_node);
+	if (pages[NO_PAGE] == NULL)
+		tst_brk(TBROK, "failed allocating memory on node %d",
+			from_node);
+
+	/*
+	 * Allocate memory, read from it, but do not write to it. This
+	 * will populate the shared zeropage.
+	 */
+	pages[ZERO_PAGE] = numa_alloc_onnode(onepage, from_node);
+	if (pages[ZERO_PAGE] == NULL)
+		tst_brk(TBROK, "failed allocating memory on node %d",
+			from_node);
+	/* Make the compiler not optimize-out the read. */
+	tmp = *((char *)pages[ZERO_PAGE]);
+	asm volatile("" : "+r" (tmp));
+
+	/*
+	 * Temporarily allocate memory and free it immediately. Do this
+	 * as the last step so the area won't get reused before we're
+	 * done.
+	 */
+	pages[INVALID_PAGE] = numa_alloc_onnode(onepage, from_node);
+	if (pages[INVALID_PAGE] == NULL)
+		tst_brk(TBROK, "failed allocating memory on node %d",
+			from_node);
+	numa_free(pages[INVALID_PAGE], onepage);
+
+	for (i = 0; i < TEST_PAGES; i++)
+		nodes[i] = to_node;
+
+	ret = numa_move_pages(0, TEST_PAGES, pages, nodes,
+			      status, MPOL_MF_MOVE);
+	if (ret == -1) {
+		tst_res(TFAIL | TERRNO,
+			"move_pages unexpectedly failed");
+		goto err_free_pages;
+	} else if (ret > 0) {
+		tst_res(TINFO, "move_pages() returned %d", ret);
 	}
+
+	if (status[NO_PAGE] == -ENOENT) {
+		tst_res(TPASS, "status[%d] has expected value",
+			NO_PAGE);
+	} else {
+		tst_res(TFAIL, "status[%d] is %s, expected %s",
+			NO_PAGE,
+			tst_strerrno(-status[NO_PAGE]),
+			tst_strerrno(ENOENT));
+	}
+
+	if (status[ZERO_PAGE] == -EFAULT) {
+		tst_res(TPASS, "status[%d] has expected value",
+			ZERO_PAGE);
+	} else {
+		tst_res(TFAIL, "status[%d] is %s, expected %s",
+			ZERO_PAGE,
+			tst_strerrno(-status[ZERO_PAGE]),
+			tst_strerrno(EFAULT));
+	}
+
+	if (status[INVALID_PAGE] == -EFAULT) {
+		tst_res(TPASS, "status[%d] has expected value",
+			INVALID_PAGE);
+	} else {
+		tst_res(TFAIL, "status[%d] is %s, expected %s",
+			INVALID_PAGE,
+			tst_strerrno(-status[INVALID_PAGE]),
+			tst_strerrno(EFAULT));
+	}
+
+err_free_pages:
+	/* Memory for the invalid page was already freed. */
+	pages[INVALID_PAGE] = NULL;
+	/* This is capable of freeing all memory we allocated. */
+	free_pages(pages, TEST_PAGES);
 #else
-	tst_resm(TCONF, NUMA_ERROR_MSG);
+	tst_res(TCONF, NUMA_ERROR_MSG);
 #endif
-
-	cleanup();
-	tst_exit();
 }
 
-/*
- * setup() - performs all ONE TIME setup for this test
- */
 void setup(void)
 {
-
-	tst_sig(FORK, DEF_HANDLER, cleanup);
-
 	check_config(TEST_NODES);
-
-	/* Pause if that option was specified
-	 * TEST_PAUSE contains the code to fork the test with the -c option.
-	 */
-	TEST_PAUSE;
 }
 
-/*
- * cleanup() - performs all ONE TIME cleanup for this test at completion
- */
-void cleanup(void)
-{
-
-}
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.tags = (const struct tst_tag[]) {
+		{"linux-git", "d899844e9c98"},
+		{"linux-git", "7dff875c9436"},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/move_pages/move_pages12.c b/testcases/kernel/syscalls/move_pages/move_pages12.c
index dd2764b42..78f17f99b 100644
--- a/testcases/kernel/syscalls/move_pages/move_pages12.c
+++ b/testcases/kernel/syscalls/move_pages/move_pages12.c
@@ -342,7 +342,7 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.test = do_test,
 	.tcnt = ARRAY_SIZE(tcases),
-	.max_runtime = 240,
+	.runtime = 240,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "e66f17ff7177"},
 		{"linux-git", "c9d398fa2378"},
diff --git a/testcases/kernel/syscalls/mq_timedreceive/mq_timedreceive01.c b/testcases/kernel/syscalls/mq_timedreceive/mq_timedreceive01.c
index be437e19a..20f25477f 100644
--- a/testcases/kernel/syscalls/mq_timedreceive/mq_timedreceive01.c
+++ b/testcases/kernel/syscalls/mq_timedreceive/mq_timedreceive01.c
@@ -22,56 +22,43 @@ static void *bad_addr;
 static struct test_case tcase[] = {
 	{
 		.fd = &fd,
-		.len = 0,
 		.send = 1,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.len = 1,
 		.send = 1,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.len = MAX_MSGSIZE,
 		.send = 1,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.len = 1,
 		.send = 1,
 		.prio = MQ_PRIO_MAX - 1,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.invalid_msg = 1,
-		.len = 0,
 		.send = 1,
 		.ret = -1,
 		.err = EMSGSIZE,
 	},
 	{
 		.fd = &fd_invalid,
-		.len = 0,
 		.ret = -1,
 		.err = EBADF,
 	},
 	{
 		.fd = &fd_maxint,
-		.len = 0,
 		.ret = -1,
 		.err = EBADF,
 	},
 	{
 		.fd = &fd_root,
-		.len = 0,
 		.ret = -1,
 		.err = EBADF,
 	},
@@ -85,7 +72,6 @@ static struct test_case tcase[] = {
 		.fd = &fd,
 		.len = 16,
 		.tv_sec = -1,
-		.tv_nsec = 0,
 		.rq = &ts,
 		.ret = -1,
 		.err = EINVAL,
@@ -93,7 +79,6 @@ static struct test_case tcase[] = {
 	{
 		.fd = &fd,
 		.len = 16,
-		.tv_sec = 0,
 		.tv_nsec = -1,
 		.rq = &ts,
 		.ret = -1,
@@ -102,7 +87,6 @@ static struct test_case tcase[] = {
 	{
 		.fd = &fd,
 		.len = 16,
-		.tv_sec = 0,
 		.tv_nsec = 1000000000,
 		.rq = &ts,
 		.ret = -1,
@@ -145,32 +129,15 @@ static void setup(void)
 	setup_common();
 }
 
-static void do_test(unsigned int i)
+static void verify_mqt_receive(unsigned int i, pid_t pid)
 {
 	struct time64_variants *tv = &variants[tst_variant];
 	const struct test_case *tc = &tcase[i];
-	unsigned int j;
-	unsigned int prio;
 	size_t len = MAX_MSGSIZE;
-	char rmsg[len];
-	pid_t pid = -1;
+	char rmsg[MAX_MSGSIZE];
 	void *abs_timeout;
-
-	tst_ts_set_sec(&ts, tc->tv_sec);
-	tst_ts_set_nsec(&ts, tc->tv_nsec);
-
-	if (tc->signal)
-		pid = set_sig(tc->rq, tv->clock_gettime);
-
-	if (tc->timeout)
-		set_timeout(tc->rq, tv->clock_gettime);
-
-	if (tc->send) {
-		if (tv->mqt_send(*tc->fd, smsg, tc->len, tc->prio, NULL) < 0) {
-			tst_res(TFAIL | TTERRNO, "mq_timedsend() failed");
-			return;
-		}
-	}
+	unsigned int j;
+	unsigned int prio;
 
 	if (tc->invalid_msg)
 		len -= 1;
@@ -199,7 +166,7 @@ static void do_test(unsigned int i)
 		return;
 	}
 
-	if (tc->len != TST_RET) {
+	if ((long)tc->len != TST_RET) {
 		tst_res(TFAIL, "mq_timedreceive() wrong length %ld, expected %u",
 			TST_RET, tc->len);
 		return;
@@ -224,6 +191,60 @@ static void do_test(unsigned int i)
 			TST_RET, prio, len);
 }
 
+static void test_bad_addr(unsigned int i)
+{
+	struct time64_variants *tv = &variants[tst_variant];
+	pid_t pid;
+	int status;
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		verify_mqt_receive(i, pid);
+		exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFEXITED(status) && !WEXITSTATUS(status))
+		return;
+
+	if (tv->ts_type == TST_LIBC_TIMESPEC &&
+		WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
+		tst_res(TPASS, "Child killed by expected signal");
+		return;
+	}
+
+	tst_res(TFAIL, "Child %s", tst_strstatus(status));
+}
+
+static void do_test(unsigned int i)
+{
+	struct time64_variants *tv = &variants[tst_variant];
+	const struct test_case *tc = &tcase[i];
+	pid_t pid = -1;
+
+	tst_ts_set_sec(&ts, tc->tv_sec);
+	tst_ts_set_nsec(&ts, tc->tv_nsec);
+
+	if (tc->bad_ts_addr) {
+		test_bad_addr(i);
+		return;
+	}
+
+	if (tc->signal)
+		pid = set_sig(tc->rq, tv->clock_gettime);
+
+	if (tc->timeout)
+		set_timeout(tc->rq, tv->clock_gettime);
+
+	if (tc->send && tv->mqt_send(*tc->fd, smsg, tc->len, tc->prio, NULL) < 0) {
+		tst_res(TFAIL | TTERRNO, "mq_timedsend() failed");
+		return;
+	}
+
+	verify_mqt_receive(i, pid);
+}
+
 static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(tcase),
 	.test = do_test,
diff --git a/testcases/kernel/syscalls/mq_timedsend/mq_timedsend01.c b/testcases/kernel/syscalls/mq_timedsend/mq_timedsend01.c
index 334131402..244092c68 100644
--- a/testcases/kernel/syscalls/mq_timedsend/mq_timedsend01.c
+++ b/testcases/kernel/syscalls/mq_timedsend/mq_timedsend01.c
@@ -22,28 +22,19 @@ static void *bad_addr;
 static struct test_case tcase[] = {
 	{
 		.fd = &fd,
-		.len = 0,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.len = 1,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.len = MAX_MSGSIZE,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
 		.len = 1,
 		.prio = MQ_PRIO_MAX - 1,
-		.ret = 0,
-		.err = 0,
 	},
 	{
 		.fd = &fd,
@@ -53,19 +44,16 @@ static struct test_case tcase[] = {
 	},
 	{
 		.fd = &fd_invalid,
-		.len = 0,
 		.ret = -1,
 		.err = EBADF,
 	},
 	{
 		.fd = &fd_maxint,
-		.len = 0,
 		.ret = -1,
 		.err = EBADF,
 	},
 	{
 		.fd = &fd_root,
-		.len = 0,
 		.ret = -1,
 		.err = EBADF,
 	},
@@ -86,7 +74,6 @@ static struct test_case tcase[] = {
 		.fd = &fd,
 		.len = 16,
 		.tv_sec = -1,
-		.tv_nsec = 0,
 		.rq = &ts,
 		.send = 1,
 		.ret = -1,
@@ -95,7 +82,6 @@ static struct test_case tcase[] = {
 	{
 		.fd = &fd,
 		.len = 16,
-		.tv_sec = 0,
 		.tv_nsec = -1,
 		.rq = &ts,
 		.send = 1,
@@ -105,7 +91,6 @@ static struct test_case tcase[] = {
 	{
 		.fd = &fd,
 		.len = 16,
-		.tv_sec = 0,
 		.tv_nsec = 1000000000,
 		.rq = &ts,
 		.send = 1,
@@ -158,34 +143,15 @@ static void setup(void)
 	setup_common();
 }
 
-static void do_test(unsigned int i)
+static void verify_mqt_send_receive(unsigned int i, pid_t pid)
 {
 	struct time64_variants *tv = &variants[tst_variant];
 	const struct test_case *tc = &tcase[i];
 	unsigned int j;
 	unsigned int prio;
-	size_t len = MAX_MSGSIZE;
-	char rmsg[len];
-	pid_t pid = -1;
+	char rmsg[MAX_MSGSIZE];
 	void *msg_ptr, *abs_timeout;
 
-	tst_ts_set_sec(&ts, tc->tv_sec);
-	tst_ts_set_nsec(&ts, tc->tv_nsec);
-
-	if (tc->signal)
-		pid = set_sig(tc->rq, tv->clock_gettime);
-
-	if (tc->timeout)
-		set_timeout(tc->rq, tv->clock_gettime);
-
-	if (tc->send) {
-		for (j = 0; j < MSG_LENGTH; j++)
-			if (tv->mqt_send(*tc->fd, smsg, tc->len, tc->prio, NULL) < 0) {
-				tst_res(TFAIL | TTERRNO, "mq_timedsend() failed");
-				return;
-			}
-	}
-
 	if (tc->bad_msg_addr)
 		msg_ptr = bad_addr;
 	else
@@ -215,7 +181,7 @@ static void do_test(unsigned int i)
 		return;
 	}
 
-	TEST(tv->mqt_receive(*tc->fd, rmsg, len, &prio, tst_ts_get(tc->rq)));
+	TEST(tv->mqt_receive(*tc->fd, rmsg, MAX_MSGSIZE, &prio, tst_ts_get(tc->rq)));
 
 	if (*tc->fd == fd)
 		cleanup_queue(fd);
@@ -235,7 +201,7 @@ static void do_test(unsigned int i)
 		}
 	}
 
-	if (tc->len != TST_RET) {
+	if ((long)tc->len != TST_RET) {
 		tst_res(TFAIL, "mq_timedreceive() wrong length %ld, expected %u",
 			TST_RET, tc->len);
 		return;
@@ -256,8 +222,66 @@ static void do_test(unsigned int i)
 		}
 	}
 
-	tst_res(TPASS, "mq_timedreceive() returned %ld, priority %u, length: %zu",
-			TST_RET, prio, len);
+	tst_res(TPASS, "mq_timedreceive() returned %ld, priority %u, length: %i",
+			TST_RET, prio, MAX_MSGSIZE);
+}
+
+static void test_bad_addr(unsigned int i)
+{
+	struct time64_variants *tv = &variants[tst_variant];
+	pid_t pid;
+	int status;
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		verify_mqt_send_receive(i, pid);
+		_exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFEXITED(status) && !WEXITSTATUS(status))
+		return;
+
+	if (tv->ts_type == TST_LIBC_TIMESPEC &&
+		WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
+		tst_res(TPASS, "Child killed by expected signal");
+		return;
+	}
+
+	tst_res(TFAIL, "Child %s", tst_strstatus(status));
+}
+
+static void do_test(unsigned int i)
+{
+	struct time64_variants *tv = &variants[tst_variant];
+	const struct test_case *tc = &tcase[i];
+	unsigned int j;
+	pid_t pid = -1;
+
+	tst_ts_set_sec(&ts, tc->tv_sec);
+	tst_ts_set_nsec(&ts, tc->tv_nsec);
+
+	if (tc->bad_ts_addr || tc->bad_msg_addr) {
+		test_bad_addr(i);
+		return;
+	}
+
+	if (tc->signal)
+		pid = set_sig(tc->rq, tv->clock_gettime);
+
+	if (tc->timeout)
+		set_timeout(tc->rq, tv->clock_gettime);
+
+	if (tc->send) {
+		for (j = 0; j < MSG_LENGTH; j++)
+			if (tv->mqt_send(*tc->fd, smsg, tc->len, tc->prio, NULL) < 0) {
+				tst_res(TFAIL | TTERRNO, "mq_timedsend() failed");
+				return;
+			}
+	}
+
+	verify_mqt_send_receive(i, pid);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/mremap/Makefile b/testcases/kernel/syscalls/mremap/Makefile
index 190b7659d..9f5aca9ec 100644
--- a/testcases/kernel/syscalls/mremap/Makefile
+++ b/testcases/kernel/syscalls/mremap/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpipc
+LTPLIBS = ipc
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/mremap/mremap03.c b/testcases/kernel/syscalls/mremap/mremap03.c
index 02b79bc47..2aa0bf9fd 100644
--- a/testcases/kernel/syscalls/mremap/mremap03.c
+++ b/testcases/kernel/syscalls/mremap/mremap03.c
@@ -128,7 +128,7 @@ int main(int ac, char **av)
 		}
 
 		/* Check for the expected errno */
-		if (errno == EFAULT) {
+		if (errno == EFAULT || errno == EPERM) {
 			tst_resm(TPASS, "mremap() Fails, 'old region not "
 				 "mapped', errno %d", TEST_ERRNO);
 		} else {
diff --git a/testcases/kernel/syscalls/mseal/.gitignore b/testcases/kernel/syscalls/mseal/.gitignore
new file mode 100644
index 000000000..2348efe30
--- /dev/null
+++ b/testcases/kernel/syscalls/mseal/.gitignore
@@ -0,0 +1,2 @@
+mseal01
+mseal02
diff --git a/testcases/kernel/syscalls/mseal/Makefile b/testcases/kernel/syscalls/mseal/Makefile
new file mode 100644
index 000000000..35317f446
--- /dev/null
+++ b/testcases/kernel/syscalls/mseal/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2023 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/mseal/mseal01.c b/testcases/kernel/syscalls/mseal/mseal01.c
new file mode 100644
index 000000000..00454a766
--- /dev/null
+++ b/testcases/kernel/syscalls/mseal/mseal01.c
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This is a smoke test that verifies if mseal() protects specific VMA portions
+ * of a process. According to documentation, the syscall should protect memory
+ * from the following actions:
+ *
+ * - unmapping, moving to another location, and shrinking the size, via munmap()
+ *   and mremap()
+ * - moving or expanding a different VMA into the current location, via mremap()
+ * - modifying a VMA via mmap(MAP_FIXED)
+ * - mprotect() and pkey_mprotect()
+ * - destructive madvice() behaviors (e.g. MADV_DONTNEED) for anonymous memory,
+ *   when users don't have write permission to the memory
+ *
+ * Any of the described actions is recognized via EPERM errno.
+ *
+ * TODO: support both raw syscall and libc wrapper via .test_variants.
+ */
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "lapi/syscalls.h"
+#include "lapi/pkey.h"
+
+#define MEMPAGES 8
+#define MEMSEAL 2
+
+static void *mem_addr;
+static int mem_size;
+static int mem_offset;
+static int mem_alignment;
+
+static inline int sys_mseal(void *start, size_t len)
+{
+	return tst_syscall(__NR_mseal, start, len, 0);
+}
+
+static void test_mprotect(void)
+{
+	TST_EXP_FAIL(mprotect(mem_addr, mem_size, PROT_NONE), EPERM);
+}
+
+static void test_pkey_mprotect(void)
+{
+	int pkey;
+
+	check_pkey_support();
+
+	pkey = pkey_alloc(0, 0);
+	if (pkey == -1)
+		tst_brk(TBROK | TERRNO, "pkey_alloc failed");
+
+	TST_EXP_FAIL(pkey_mprotect(
+		mem_addr, mem_size,
+		PROT_NONE,
+		pkey),
+		EPERM);
+
+	if (pkey_free(pkey) == -1)
+		tst_brk(TBROK | TERRNO, "pkey_free() error");
+}
+
+static void test_madvise(void)
+{
+	TST_EXP_FAIL(madvise(mem_addr, mem_size, MADV_DONTNEED), EPERM);
+}
+
+static void test_munmap(void)
+{
+	TST_EXP_FAIL(munmap(mem_addr, mem_size), EPERM);
+}
+
+static void test_mremap_resize(void)
+{
+	void *new_addr;
+	size_t new_size = 2 * mem_alignment;
+
+	new_addr = SAFE_MMAP(NULL, mem_size,
+		PROT_READ,
+		MAP_ANONYMOUS | MAP_PRIVATE,
+		-1, 0);
+
+	TST_EXP_FAIL_PTR_VOID(mremap(mem_addr, mem_size, new_size,
+		MREMAP_MAYMOVE | MREMAP_FIXED,
+		new_addr),
+		EPERM);
+
+	SAFE_MUNMAP(new_addr, new_size);
+}
+
+static void test_mmap_change_prot(void)
+{
+	TST_EXP_FAIL_PTR_VOID(mmap(mem_addr, mem_size,
+		PROT_READ,
+		MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED,
+		-1, 0), EPERM);
+}
+
+static struct tcase {
+	void (*func_test)(void);
+	int prot;
+	char *message;
+} tcases[] = {
+	{test_mprotect, PROT_READ | PROT_WRITE, "mprotect() availability"},
+	{test_pkey_mprotect, PROT_READ | PROT_WRITE, "pkey_mprotect() availability"},
+	{test_madvise, PROT_READ, "madvise() availability"},
+	{test_munmap, PROT_READ | PROT_WRITE, "munmap() availability from child"},
+	{test_mremap_resize, PROT_READ | PROT_WRITE, "mremap() address move/resize"},
+	{test_mmap_change_prot, PROT_READ | PROT_WRITE, "mmap() protection change"},
+};
+
+static void run(unsigned int n)
+{
+	/* the reason why we spawn a child is that mseal() will
+	 * protect VMA until process will call _exit()
+	 */
+	if (!SAFE_FORK()) {
+		struct tcase *tc = &tcases[n];
+
+		mem_addr = SAFE_MMAP(NULL, mem_size,
+			tc->prot,
+			MAP_ANONYMOUS | MAP_PRIVATE,
+			-1, 0);
+
+		tst_res(TINFO, "Testing %s", tc->message);
+
+		TST_EXP_PASS(sys_mseal(mem_addr + mem_offset, mem_alignment));
+
+		tc->func_test();
+		_exit(0);
+	}
+}
+
+static void setup(void)
+{
+	mem_alignment = getpagesize();
+	mem_size = mem_alignment * MEMPAGES;
+	mem_offset = mem_alignment * MEMSEAL;
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.forks_child = 1,
+};
+
diff --git a/testcases/kernel/syscalls/mseal/mseal02.c b/testcases/kernel/syscalls/mseal/mseal02.c
new file mode 100644
index 000000000..62eeb25b2
--- /dev/null
+++ b/testcases/kernel/syscalls/mseal/mseal02.c
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Author: Xiao Yang <ice_yangxiao@163.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Check various errnos for mseal(2).
+ *
+ * - mseal() fails with EINVAL if flags is invalid.
+ * - mseal() fails with EINVAL if the start address is not page aligned.
+ * - mseal() fails with EINVAL if address range overflows.
+ * - mseal() fails with ENOMEM if the start address is not allocated.
+ * - mseal() fails with ENOMEM if the end address is not allocated.
+ * - mseal() fails with ENOMEM if there is a gap (unallocated memory) between start and end address.
+ *
+ * TODO: support both raw syscall and libc wrapper via .test_variants.
+ */
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "lapi/syscalls.h"
+
+static void *start_addr, *unaligned_start_addr, *unallocated_start_addr, *unallocated_end_addr;
+static size_t page_size, twopages_size, fourpages_size, overflow_size;
+
+static struct tcase {
+	void **addr;
+	size_t *len;
+	unsigned long flags;
+	int exp_err;
+} tcases[] = {
+	{&start_addr, &page_size, ULONG_MAX, EINVAL},
+	{&unaligned_start_addr, &page_size, 0, EINVAL},
+	{&start_addr, &overflow_size, 0, EINVAL},
+	{&unallocated_start_addr, &twopages_size, 0, ENOMEM},
+	{&unallocated_end_addr, &twopages_size, 0, ENOMEM},
+	{&start_addr, &fourpages_size, 0, ENOMEM},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+
+	TST_EXP_FAIL(tst_syscall(__NR_mseal, *tc->addr, *tc->len, tc->flags), tc->exp_err,
+		"mseal(%p, %lu, %lu)", *tc->addr, *tc->len, tc->flags);
+}
+
+static void setup(void)
+{
+	page_size = getpagesize();
+	twopages_size = page_size * 2;
+	fourpages_size = page_size * 4;
+	overflow_size = ULONG_MAX - page_size + 2;
+	start_addr = SAFE_MMAP(NULL, fourpages_size, PROT_READ | PROT_WRITE,
+		MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+	unaligned_start_addr = start_addr + 1;
+	SAFE_MUNMAP(start_addr + twopages_size, page_size);
+	unallocated_start_addr = start_addr + twopages_size;
+	unallocated_end_addr = start_addr + page_size;
+}
+
+static void cleanup(void)
+{
+	SAFE_MUNMAP(start_addr, fourpages_size);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/syscalls/msync/msync04.c b/testcases/kernel/syscalls/msync/msync04.c
index 645201ee5..1af781a97 100644
--- a/testcases/kernel/syscalls/msync/msync04.c
+++ b/testcases/kernel/syscalls/msync/msync04.c
@@ -1,19 +1,24 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2017 Red Hat, Inc.
- *
+ * Copyright (c) Linux Test Project, 2017-2024
  */
 
-/*
- * Test description: Verify msync() after writing into mmap()-ed file works.
+/*\
+ * [Description]
+ *
+ * Verify msync() after writing into mmap()-ed file works.
  *
  * Write to mapped region and sync the memory back with file. Check the page
  * is no longer dirty after msync() call.
+ *
+ * In case the dirty bit is not set, check the content of file to verify
+ * the data is stored on disk.
  */
 
+#define _GNU_SOURCE
 #include <errno.h>
 #include "tst_test.h"
-#include "pgsize_helpers.h"
 
 static int test_fd;
 static char *mmaped_area;
@@ -21,14 +26,14 @@ static long pagesize;
 
 #define STRING_TO_WRITE	"AAAAAAAAAA"
 
-uint64_t get_dirty_bit(void *data)
+static uint64_t get_dirty_bit(void *data)
 {
 	int pagemap_fd, pageflags_fd;
 	unsigned long addr;
 	uint64_t pagemap_entry, pageflag_entry, pfn, index;
 
 	addr = (unsigned long)data;
-	index = (addr / kernel_page_size()) * sizeof(uint64_t);
+	index = (addr / pagesize) * sizeof(uint64_t);
 	pagemap_fd = SAFE_OPEN("/proc/self/pagemap", O_RDONLY);
 	SAFE_LSEEK(pagemap_fd, index, SEEK_SET);
 	SAFE_READ(1, pagemap_fd, &pagemap_entry, sizeof(pagemap_entry));
@@ -44,10 +49,34 @@ uint64_t get_dirty_bit(void *data)
 	return pageflag_entry & (1ULL << 4);
 }
 
-static void test_msync(void)
+static void verify_mmaped(void)
+{
+	char *buffer = SAFE_MEMALIGN(getpagesize(), getpagesize());
+
+	tst_res(TINFO, "Haven't seen dirty bit so we check content of file instead");
+	test_fd = SAFE_OPEN("msync04/testfile", O_RDONLY | O_DIRECT);
+	SAFE_READ(0, test_fd, buffer, getpagesize());
+
+	if (buffer[8] == 'B')
+		tst_res(TCONF, "Write was too fast, couldn't test msync()");
+	else
+		tst_res(TFAIL, "write file failed");
+
+	free(buffer);
+}
+
+static void verify_dirty(void)
 {
-	uint64_t dirty;
+	TST_EXP_PASS_SILENT(msync(mmaped_area, pagesize, MS_SYNC));
 
+	if (TST_RET == 0 && !get_dirty_bit(mmaped_area))
+		tst_res(TPASS, "msync() verify dirty page ok");
+	else
+		tst_res(TFAIL, "msync() verify dirty page failed");
+}
+
+static void test_msync(void)
+{
 	test_fd = SAFE_OPEN("msync04/testfile", O_CREAT | O_TRUNC | O_RDWR,
 		0644);
 	SAFE_WRITE(SAFE_WRITE_ANY, test_fd, STRING_TO_WRITE, sizeof(STRING_TO_WRITE) - 1);
@@ -55,24 +84,12 @@ static void test_msync(void)
 			MAP_SHARED, test_fd, 0);
 	SAFE_CLOSE(test_fd);
 	mmaped_area[8] = 'B';
-	dirty = get_dirty_bit(mmaped_area);
-	if (!dirty) {
-		tst_res(TFAIL, "Expected dirty bit to be set after writing to"
-				" mmap()-ed area");
-		goto clean;
-	}
-	if (msync(mmaped_area, pagesize, MS_SYNC) < 0) {
-		tst_res(TFAIL | TERRNO, "msync() failed");
-		goto clean;
-	}
-	dirty = get_dirty_bit(mmaped_area);
-	if (dirty)
-		tst_res(TFAIL, "msync() failed to write dirty page despite"
-				" succeeding");
+
+	if (!get_dirty_bit(mmaped_area))
+		verify_mmaped();
 	else
-		tst_res(TPASS, "msync() working correctly");
+		verify_dirty();
 
-clean:
 	SAFE_MUNMAP(mmaped_area, pagesize);
 	mmaped_area = NULL;
 }
diff --git a/testcases/kernel/syscalls/nanosleep/nanosleep01.c b/testcases/kernel/syscalls/nanosleep/nanosleep01.c
index eaacb89fa..bd9ae0caa 100644
--- a/testcases/kernel/syscalls/nanosleep/nanosleep01.c
+++ b/testcases/kernel/syscalls/nanosleep/nanosleep01.c
@@ -5,10 +5,11 @@
  * Copyright (C) 2015-2017 Cyril Hrubis <chrubis@suse.cz>
  */
 
-/*
- * Test Description:
- *  nanosleep() should return with value 0 and the process should be
- *  suspended for time specified by timespec structure.
+/*\
+ * [Description]
+ *
+ * Verify that nanosleep() should return with value 0 and the process should be
+ * suspended for time specified by timespec structure.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/nanosleep/nanosleep04.c b/testcases/kernel/syscalls/nanosleep/nanosleep04.c
index 4eed9d0ce..3582a3fb2 100644
--- a/testcases/kernel/syscalls/nanosleep/nanosleep04.c
+++ b/testcases/kernel/syscalls/nanosleep/nanosleep04.c
@@ -7,13 +7,11 @@
  * 07/2019    Yang Xu <xuyang2018.jy@cn.fujitsu.com>
  */
 
-/*
- * Test Description:
- *  Verify that nanosleep() will fail to suspend the execution
- *  of a process if the specified pause time is invalid.
+/*\
+ * [Description]
  *
- * Expected Result:
- *  nanosleep() should return with -1 value and sets errno to EINVAL.
+ * Verify that nanosleep() returns -1 and sets errno to EINVAL when failing to suspend the
+ * execution of a process if the specified pause time is invalid.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/nice/nice05.c b/testcases/kernel/syscalls/nice/nice05.c
index 2c8ae4156..270171317 100644
--- a/testcases/kernel/syscalls/nice/nice05.c
+++ b/testcases/kernel/syscalls/nice/nice05.c
@@ -154,5 +154,5 @@ static struct tst_test test = {
 	.setup = setup,
 	.test_all = verify_nice,
 	.needs_root = 1,
-	.max_runtime = 3,
+	.runtime = 3,
 };
diff --git a/testcases/kernel/syscalls/open/.gitignore b/testcases/kernel/syscalls/open/.gitignore
index 001d874d6..af5997572 100644
--- a/testcases/kernel/syscalls/open/.gitignore
+++ b/testcases/kernel/syscalls/open/.gitignore
@@ -12,3 +12,4 @@
 /open12_child
 /open13
 /open14
+/open15
diff --git a/testcases/kernel/syscalls/open/open10.c b/testcases/kernel/syscalls/open/open10.c
index d2d3729d2..916357158 100644
--- a/testcases/kernel/syscalls/open/open10.c
+++ b/testcases/kernel/syscalls/open/open10.c
@@ -27,7 +27,6 @@
 #define NOSETGID_B	DIR_B "/nosetgid"
 #define ROOT_SETGID	DIR_B "/root_setgid"
 
-static char *tmpdir;
 static uid_t orig_uid, nobody_uid;
 static gid_t nobody_gid, free_gid;
 static int fd = -1;
@@ -42,7 +41,6 @@ static void setup(void)
 	tst_res(TINFO, "User nobody: uid = %d, gid = %d", (int)nobody_uid,
 		(int)nobody_gid);
 	free_gid = tst_get_free_gid(nobody_gid);
-	tmpdir = tst_get_tmpdir();
 }
 
 static void file_test(const char *name, mode_t mode, int sgid, gid_t gid)
@@ -123,15 +121,13 @@ static void run(void)
 	file_test(ROOT_SETGID, MODE_SGID, 1, free_gid);
 
 	/* Cleanup between loops */
-	tst_purge_dir(tmpdir);
+	tst_purge_dir(tst_tmpdir_path());
 }
 
 static void cleanup(void)
 {
 	if (fd >= 0)
 		SAFE_CLOSE(fd);
-
-	free(tmpdir);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/open/open15.c b/testcases/kernel/syscalls/open/open15.c
new file mode 100644
index 000000000..4fa243e94
--- /dev/null
+++ b/testcases/kernel/syscalls/open/open15.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ * Author: David Fenner, Jon Hendrickson
+ * Copyright (C) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that open() is working correctly on symlink()
+ * generated files. We generate a file via symlink, then we read both from file
+ * and symlink, comparing that data has been correctly written.
+ */
+
+#include "tst_test.h"
+
+#define FILENAME "myfile.txt"
+#define SYMBNAME "myfile_symlink"
+#define BIG_STRING "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
+
+static char buff_file[128];
+static char buff_symb[128];
+static int str_size;
+
+static void run(void)
+{
+	int fd_file, fd_symb;
+
+	memset(buff_file, 0, sizeof(buff_file));
+	memset(buff_symb, 0, sizeof(buff_symb));
+
+	tst_res(TINFO, "Create symlink");
+	SAFE_TOUCH(FILENAME, 0777, NULL);
+	SAFE_SYMLINK(FILENAME, SYMBNAME);
+
+	fd_file = SAFE_OPEN(FILENAME, O_RDONLY, 0777);
+	fd_symb = SAFE_OPEN(SYMBNAME, O_RDWR, 0777);
+
+	tst_res(TINFO, "Write data via symlink");
+	SAFE_WRITE(SAFE_WRITE_ALL, fd_symb, BIG_STRING, str_size);
+	SAFE_LSEEK(fd_symb, 0, 0);
+
+	tst_res(TINFO, "Read data via file");
+	SAFE_READ(1, fd_file, buff_file, str_size);
+	SAFE_LSEEK(fd_file, 0, 0);
+
+	tst_res(TINFO, "Read data via symlink");
+	SAFE_READ(1, fd_symb, buff_symb, str_size);
+	SAFE_LSEEK(fd_symb, 0, 0);
+
+	TST_EXP_EXPR(!strncmp(buff_file, BIG_STRING, str_size),
+		"file data has been correctly written");
+
+	TST_EXP_EXPR(!strncmp(buff_file, buff_symb, str_size),
+		"file data is the equivalent to symlink generated file data");
+
+	SAFE_CLOSE(fd_file);
+	SAFE_CLOSE(fd_symb);
+
+	SAFE_UNLINK(SYMBNAME);
+	SAFE_UNLINK(FILENAME);
+}
+
+static void setup(void)
+{
+	str_size = strlen(BIG_STRING);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.needs_tmpdir = 1,
+};
diff --git a/testcases/kernel/syscalls/pathconf/pathconf01.c b/testcases/kernel/syscalls/pathconf/pathconf01.c
index 66b8d1fc1..280709a91 100644
--- a/testcases/kernel/syscalls/pathconf/pathconf01.c
+++ b/testcases/kernel/syscalls/pathconf/pathconf01.c
@@ -45,7 +45,7 @@ static void verify_pathconf(unsigned int i)
 {
 	struct tcase *tc = &tcases[i];
 
-	path = tst_get_tmpdir();
+	path = tst_tmpdir_path();
 
 	TEST(pathconf(path, tc->value));
 
@@ -55,14 +55,8 @@ static void verify_pathconf(unsigned int i)
 		tst_res(TPASS, "pathconf(%s, %s)", path, tc->name);
 }
 
-static void cleanup(void)
-{
-	free(path);
-}
-
 static struct tst_test test = {
 	.needs_tmpdir = 1,
 	.test = verify_pathconf,
 	.tcnt = ARRAY_SIZE(tcases),
-	.cleanup = cleanup,
 };
diff --git a/testcases/kernel/syscalls/pathconf/pathconf02.c b/testcases/kernel/syscalls/pathconf/pathconf02.c
index 3fb2cdbe8..a7af980ec 100644
--- a/testcases/kernel/syscalls/pathconf/pathconf02.c
+++ b/testcases/kernel/syscalls/pathconf/pathconf02.c
@@ -70,12 +70,9 @@ static void setup(void)
 
 	SAFE_TOUCH("testfile", 0777, NULL);
 
-	char *tmpdir =  tst_get_tmpdir();
+	abs_path = tst_tmpdir_genpath(FILEPATH);
 
-	abs_path = tst_aprintf("%s/%s", tmpdir, FILEPATH);
-
-	SAFE_CHMOD(tmpdir, 0);
-	free(tmpdir);
+	SAFE_CHMOD(tst_tmpdir_path(), 0);
 
 	memset(path, 'a', PATH_LEN);
 
diff --git a/testcases/kernel/syscalls/perf_event_open/perf_event_open01.c b/testcases/kernel/syscalls/perf_event_open/perf_event_open01.c
index 30c0d7594..86a134b51 100644
--- a/testcases/kernel/syscalls/perf_event_open/perf_event_open01.c
+++ b/testcases/kernel/syscalls/perf_event_open/perf_event_open01.c
@@ -148,7 +148,7 @@ static void verify(struct test_case_t *tc)
 	TEST(perf_event_open(&pe, 0, -1, -1, 0));
 	if (TEST_RETURN == -1) {
 		if (TEST_ERRNO == ENOENT || TEST_ERRNO == EOPNOTSUPP ||
-		    TEST_ERRNO == ENODEV) {
+		    TEST_ERRNO == ENODEV || TEST_ERRNO == EINVAL) {
 			tst_resm(TCONF | TTERRNO,
 			         "perf_event_open for %s not supported",
 			         tc->config_name);
diff --git a/testcases/kernel/syscalls/perf_event_open/perf_event_open02.c b/testcases/kernel/syscalls/perf_event_open/perf_event_open02.c
index 0b84fb31c..27cc83cdd 100644
--- a/testcases/kernel/syscalls/perf_event_open/perf_event_open02.c
+++ b/testcases/kernel/syscalls/perf_event_open/perf_event_open02.c
@@ -198,6 +198,12 @@ static void setup(void)
 {
 	int i;
 	struct perf_event_attr tsk_event, hw_event;
+	struct sched_param sparam = {.sched_priority = 1};
+
+	if (sched_setscheduler(0, SCHED_FIFO, &sparam)) {
+		tst_brk(TBROK | TERRNO,
+			"sched_setscheduler(0, SCHED_FIFO, ...) failed");
+	}
 
 	for (i = 0; i < MAX_CTRS; i++) {
 		hwfd[i] = -1;
@@ -271,12 +277,7 @@ static void verify(void)
 	unsigned long long vtsum = 0, vhsum = 0;
 	int i;
 	double ratio;
-	struct sched_param sparam = {.sched_priority = 1};
-
-	if (sched_setscheduler(0, SCHED_FIFO, &sparam)) {
-		tst_brk(TBROK | TERRNO,
-			"sched_setscheduler(0, SCHED_FIFO, ...) failed");
-	}
+	struct sched_param sparam = {.sched_priority = 0};
 
 	all_counters_set(PR_TASK_PERF_EVENTS_ENABLE);
 	do_work(8);
@@ -334,5 +335,5 @@ static struct tst_test test = {
 	},
 	.test_all = verify,
 	.needs_root = 1,
-	.max_runtime = 72
+	.timeout = 72
 };
diff --git a/testcases/kernel/syscalls/perf_event_open/perf_event_open03.c b/testcases/kernel/syscalls/perf_event_open/perf_event_open03.c
index 7dd31d3d2..389cc3511 100644
--- a/testcases/kernel/syscalls/perf_event_open/perf_event_open03.c
+++ b/testcases/kernel/syscalls/perf_event_open/perf_event_open03.c
@@ -77,22 +77,41 @@ static void check_progress(int i)
 
 static void run(void)
 {
-	long diff;
-	int i;
+	long diff, diff_total, mem_avail, mem_avail_prev;
+	int i, sample;
 
-	diff = SAFE_READ_MEMINFO("MemAvailable:");
+	sample = 0;
+	diff_total = 0;
+
+	mem_avail_prev = SAFE_READ_MEMINFO("MemAvailable:");
 	tst_timer_start(CLOCK_MONOTONIC);
 
 	/* leak about 100MB of RAM */
 	for (i = 0; i < iterations; i++) {
 		ioctl(fd, PERF_EVENT_IOC_SET_FILTER, "filter,0/0@abcd");
 		check_progress(i);
-	}
 
-	diff -= SAFE_READ_MEMINFO("MemAvailable:");
+		/*
+		 * Every 1200000 iterations, calculate the difference in memory
+		 * availability. If the difference is greater than 20 * 1024 (20MB),
+		 * increment the sample counter and log the event.
+		 */
+		if ((i % 1200000) == 0) {
+			mem_avail = SAFE_READ_MEMINFO("MemAvailable:");
+			diff = mem_avail_prev - mem_avail;
+			diff_total += diff;
+
+			if (diff > 20 * 1024) {
+				sample++;
+				tst_res(TINFO, "MemAvailable decreased by %ld kB at iteration %d", diff, i);
+			}
+
+			mem_avail_prev = mem_avail;
+		}
+	}
 
-	if (diff > 50 * 1024)
-		tst_res(TFAIL, "Likely kernel memory leak detected");
+	if ((sample > 5) || (diff_total > 100 * 1024))
+		tst_res(TFAIL, "Likely kernel memory leak detected, total decrease: %ld kB", diff_total);
 	else
 		tst_res(TPASS, "No memory leak found");
 }
@@ -108,7 +127,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.needs_root = 1,
-	.max_runtime = 300,
+	.runtime = 300,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "7bdb157cdebb"},
 		{"CVE", "2020-25704"},
diff --git a/testcases/kernel/syscalls/pkeys/Makefile b/testcases/kernel/syscalls/pkeys/Makefile
index 9ee2c2ea5..814593f3c 100644
--- a/testcases/kernel/syscalls/pkeys/Makefile
+++ b/testcases/kernel/syscalls/pkeys/Makefile
@@ -5,4 +5,6 @@ top_srcdir		?= ../../../..
 
 include $(top_srcdir)/include/mk/testcases.mk
 
+pkey01: CFLAGS += -falign-functions=64
+
 include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/pkeys/pkey01.c b/testcases/kernel/syscalls/pkeys/pkey01.c
index 0159822e1..444799670 100644
--- a/testcases/kernel/syscalls/pkeys/pkey01.c
+++ b/testcases/kernel/syscalls/pkeys/pkey01.c
@@ -1,6 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (c) 2019 Red Hat, Inc.
+ * Copyright (c) 2019-2024 Red Hat, Inc.
+ */
+
+/*\
+ * [Description]
  *
  * Memory Protection Keys for Userspace (PKU aka PKEYs) is a Skylake-SP
  * server feature that provides a mechanism for enforcing page-based
@@ -10,14 +14,15 @@
  * giving 16 possible keys.
  *
  * Basic method for PKEYs testing:
- *    1. test allocates a pkey(e.g. PKEY_DISABLE_ACCESS) via pkey_alloc()
- *    2. pkey_mprotect() apply this pkey to a piece of memory(buffer)
- *    3. check if access right of the buffer has been changed and take effect
- *    4. remove the access right(pkey) from this buffer via pkey_mprotect()
- *    5. check if buffer area can be read or write after removing pkey
- *    6. pkey_free() releases the pkey after using it
  *
- * Looping around this basic test on diffenrent types of memory.
+ * 1. test allocates a pkey(e.g. PKEY_DISABLE_ACCESS) via pkey_alloc()
+ * 2. pkey_mprotect() apply this pkey to a piece of memory(buffer)
+ * 3. check if access right of the buffer has been changed and take effect
+ * 4. remove the access right(pkey) from this buffer via pkey_mprotect()
+ * 5. check if buffer area can be read or write after removing pkey
+ * 6. pkey_free() releases the pkey after using it
+ *
+ * Looping around this basic test on different types of memory.
  */
 
 #define _GNU_SOURCE
@@ -29,29 +34,43 @@
 #include <sys/mman.h>
 #include <sys/wait.h>
 
-#include "pkey.h"
+#include "lapi/pkey.h"
 
 #define TEST_FILE "pkey_testfile"
 #define STR "abcdefghijklmnopqrstuvwxyz12345\n"
 #define PATH_VM_NRHPS "/proc/sys/vm/nr_hugepages"
 
 static int size;
+static int execute_supported = 1;
 
+#define PERM_NAME(x) .access_rights = x, .name = #x
 static struct tcase {
 	unsigned long flags;
 	unsigned long access_rights;
 	char *name;
 } tcases[] = {
-	{0, PKEY_DISABLE_ACCESS, "PKEY_DISABLE_ACCESS"},
-	{0, PKEY_DISABLE_WRITE, "PKEY_DISABLE_WRITE"},
+	{PERM_NAME(PKEY_DISABLE_ACCESS)},
+	{PERM_NAME(PKEY_DISABLE_WRITE)},
+	{PERM_NAME(PKEY_DISABLE_EXECUTE)} /* keep it the last */
 };
 
 static void setup(void)
 {
-	int i, fd;
+	int i, fd, pkey;
 
 	check_pkey_support();
 
+	pkey = pkey_alloc(0, PKEY_DISABLE_EXECUTE);
+	if (pkey == -1) {
+		if (errno == EINVAL) {
+			tst_res(TINFO, "PKEY_DISABLE_EXECUTE not implemented");
+			execute_supported = 0;
+		} else {
+			tst_brk(TBROK | TERRNO, "pkey_alloc failed");
+		}
+	}
+	pkey_free(pkey);
+
 	if (tst_hugepages == test.hugepages.number)
 		size = SAFE_READ_MEMINFO("Hugepagesize:") * 1024;
 	else
@@ -125,16 +144,35 @@ static char *flag_to_str(int flags)
 	}
 }
 
-static void pkey_test(struct tcase *tc, struct mmap_param *mpa)
+static long __attribute__ ((noinline)) dummy_func(void)
+{
+	return 0xdead;
+}
+
+/*
+ * return: 1 if it's safe to quit testing on failure (all following would be
+ * TCONF, O otherwise.
+ */
+static int pkey_test(struct tcase *tc, struct mmap_param *mpa)
 {
 	pid_t pid;
 	char *buffer;
 	int pkey, status;
 	int fd = mpa->fd;
+	long (*func)(void) = 0;
+	uintptr_t page_mask = ~(getpagesize() - 1);
+	uintptr_t offset_mask = (getpagesize() - 1);
+	uintptr_t func_page_offset = (uintptr_t)&dummy_func & offset_mask;
+	void *page_to_copy = (void *)((uintptr_t)&dummy_func & page_mask);
+
+	if (!execute_supported && (tc->access_rights == PKEY_DISABLE_EXECUTE)) {
+		tst_res(TCONF, "skip PKEY_DISABLE_EXECUTE test");
+		return 1;
+	}
 
 	if (!tst_hugepages && (mpa->flags & MAP_HUGETLB)) {
-		tst_res(TINFO, "Skip test on (%s) buffer", flag_to_str(mpa->flags));
-		return;
+		tst_res(TCONF, "Skip test on (%s) buffer", flag_to_str(mpa->flags));
+		return 0;
 	}
 
 	if (fd == 0)
@@ -142,12 +180,17 @@ static void pkey_test(struct tcase *tc, struct mmap_param *mpa)
 
 	buffer = SAFE_MMAP(NULL, size, mpa->prot, mpa->flags, fd, 0);
 
-	pkey = ltp_pkey_alloc(tc->flags, tc->access_rights);
+	if (mpa->prot == (PROT_READ | PROT_WRITE | PROT_EXEC)) {
+		memcpy(buffer, page_to_copy, getpagesize());
+		func = (long (*)(void))(buffer + func_page_offset);
+	}
+
+	pkey = pkey_alloc(tc->flags, tc->access_rights);
 	if (pkey == -1)
 		tst_brk(TBROK | TERRNO, "pkey_alloc failed");
 
 	tst_res(TINFO, "Set %s on (%s) buffer", tc->name, flag_to_str(mpa->flags));
-	if (ltp_pkey_mprotect(buffer, size, mpa->prot, pkey) == -1)
+	if (pkey_mprotect(buffer, size, mpa->prot, pkey) == -1)
 		tst_brk(TBROK | TERRNO, "pkey_mprotect failed");
 
 	pid = SAFE_FORK();
@@ -164,6 +207,9 @@ static void pkey_test(struct tcase *tc, struct mmap_param *mpa)
 			tst_res(TFAIL | TERRNO,
 				"Write buffer success, buffer[0] = %d", *buffer);
 		break;
+		case PKEY_DISABLE_EXECUTE:
+			tst_res(TFAIL | TERRNO, "Execute buffer result = %ld", func());
+		break;
 		}
 		exit(0);
 	}
@@ -176,7 +222,7 @@ static void pkey_test(struct tcase *tc, struct mmap_param *mpa)
                 tst_res(TFAIL, "Child: %s", tst_strstatus(status));
 
 	tst_res(TINFO, "Remove %s from the buffer", tc->name);
-	if (ltp_pkey_mprotect(buffer, size, mpa->prot, 0x0) == -1)
+	if (pkey_mprotect(buffer, size, mpa->prot, 0x0) == -1)
 		tst_brk(TBROK | TERRNO, "pkey_mprotect failed");
 
 	switch (mpa->prot) {
@@ -188,10 +234,15 @@ static void pkey_test(struct tcase *tc, struct mmap_param *mpa)
 		tst_res(TPASS, "Write buffer success, buffer[0] = %d", *buffer);
 	break;
 	case PROT_READ | PROT_WRITE:
-	case PROT_READ | PROT_WRITE | PROT_EXEC:
 		*buffer = 'a';
 		tst_res(TPASS, "Read & Write buffer success, buffer[0] = %d", *buffer);
 	break;
+	case PROT_READ | PROT_WRITE | PROT_EXEC:
+		if (dummy_func() == func())
+			tst_res(TPASS, "Execute buffer success, result = %ld", dummy_func());
+		else
+			tst_res(TFAIL, "Execute buffer with unexpected result: %ld", func());
+	break;
 	}
 
 	if (fd >= 0)
@@ -199,8 +250,10 @@ static void pkey_test(struct tcase *tc, struct mmap_param *mpa)
 
 	SAFE_MUNMAP(buffer, size);
 
-	if (ltp_pkey_free(pkey) == -1)
+	if (pkey_free(pkey) == -1)
 		tst_brk(TBROK | TERRNO, "pkey_free failed");
+
+	return 0;
 }
 
 static void verify_pkey(unsigned int i)
@@ -213,7 +266,8 @@ static void verify_pkey(unsigned int i)
 	for (j = 0; j < ARRAY_SIZE(mmap_params); j++) {
 		mpa = &mmap_params[j];
 
-		pkey_test(tc, mpa);
+		if (pkey_test(tc, mpa))
+			break;
 	}
 }
 
diff --git a/testcases/kernel/syscalls/prctl/.gitignore b/testcases/kernel/syscalls/prctl/.gitignore
index 50ee4bf60..8bcc22f98 100644
--- a/testcases/kernel/syscalls/prctl/.gitignore
+++ b/testcases/kernel/syscalls/prctl/.gitignore
@@ -1,7 +1,6 @@
 /prctl01
 /prctl02
 /prctl03
-/prctl04
 /prctl05
 /prctl06
 /prctl06_execve
diff --git a/testcases/kernel/syscalls/preadv/preadv.h b/testcases/kernel/syscalls/preadv/preadv.h
deleted file mode 100644
index c715715b1..000000000
--- a/testcases/kernel/syscalls/preadv/preadv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later
- *
- * Copyright (c) 2015 Fujitsu Ltd.
- * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
- * Copyright (c) Linux Test Project, 2016-2023
- */
-
-#ifndef PREADV_H
-#define PREADV_H
-
-#include <sys/types.h>
-#include "config.h"
-#include "lapi/syscalls.h"
-
-#if !defined(HAVE_PREADV)
-int preadv(int fd, const struct iovec *iov, int iovcnt, off_t offset)
-{
-	return tst_syscall(__NR_preadv, fd, iov, iovcnt, offset);
-}
-#endif
-
-#endif /* RREADV_H */
diff --git a/testcases/kernel/syscalls/preadv/preadv01.c b/testcases/kernel/syscalls/preadv/preadv01.c
index 871b3ab42..d5e5bd95f 100644
--- a/testcases/kernel/syscalls/preadv/preadv01.c
+++ b/testcases/kernel/syscalls/preadv/preadv01.c
@@ -20,7 +20,7 @@
 #include <sys/uio.h>
 
 #include "tst_test.h"
-#include "preadv.h"
+#include "lapi/uio.h"
 
 #define CHUNK           64
 
diff --git a/testcases/kernel/syscalls/preadv/preadv02.c b/testcases/kernel/syscalls/preadv/preadv02.c
index 9977a4f48..19b194314 100644
--- a/testcases/kernel/syscalls/preadv/preadv02.c
+++ b/testcases/kernel/syscalls/preadv/preadv02.c
@@ -23,7 +23,7 @@
 #include <sys/uio.h>
 #include <unistd.h>
 #include "tst_test.h"
-#include "preadv.h"
+#include "lapi/uio.h"
 
 #define CHUNK           64
 
diff --git a/testcases/kernel/syscalls/preadv/preadv03.c b/testcases/kernel/syscalls/preadv/preadv03.c
index 558d85050..997e7a07c 100644
--- a/testcases/kernel/syscalls/preadv/preadv03.c
+++ b/testcases/kernel/syscalls/preadv/preadv03.c
@@ -22,7 +22,7 @@
 #include <sys/ioctl.h>
 #include <sys/mount.h>
 #include "tst_test.h"
-#include "preadv.h"
+#include "lapi/uio.h"
 
 #define MNTPOINT	"mntpoint"
 #define FNAME	MNTPOINT"/file"
diff --git a/testcases/kernel/syscalls/preadv2/preadv201.c b/testcases/kernel/syscalls/preadv2/preadv201.c
index 110977290..32ed7862a 100644
--- a/testcases/kernel/syscalls/preadv2/preadv201.c
+++ b/testcases/kernel/syscalls/preadv2/preadv201.c
@@ -4,15 +4,17 @@
  * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
  */
 
-/*
- * Description:
- * Testcase to check the basic functionality of the preadv2(2).
- * 1) If the file offset argument is not -1, preadv2() should succeed
- *    in reading the expected content of data and the file offset is
- *    not changed after reading.
- * 2) If the file offset argument is -1, preadv2() should succeed in
- *    reading the expected content of data and the current file offset
- *    is used and changed after reading.
+/*\
+ * [Description]
+ *
+ * Verify the basic functionality of the preadv2(2):
+ *
+ * 1. If the file offset argument is not -1, preadv2() should succeed
+ * in reading the expected content of data and the file offset is not
+ * changed after reading.
+ * 2. If the file offset argument is -1, preadv2() should succeed in
+ * reading the expected content of data and the current file offset
+ * is used and changed after reading.
  */
 
 #define _GNU_SOURCE
@@ -20,7 +22,7 @@
 #include <sys/uio.h>
 
 #include "tst_test.h"
-#include "lapi/preadv2.h"
+#include "lapi/uio.h"
 
 #define CHUNK           64
 
diff --git a/testcases/kernel/syscalls/preadv2/preadv202.c b/testcases/kernel/syscalls/preadv2/preadv202.c
index 4e1e82ebd..f7279e0ad 100644
--- a/testcases/kernel/syscalls/preadv2/preadv202.c
+++ b/testcases/kernel/syscalls/preadv2/preadv202.c
@@ -4,20 +4,19 @@
  * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
  */
 
-/*
- * Description:
- * Check various errnos for preadv2(2).
- * 1) preadv2() fails and sets errno to EINVAL if iov_len is invalid.
- * 2) preadv2() fails and sets errno to EINVAL if the vector count iovcnt
- *    is less than zero.
- * 3) preadv2() fails and sets errno to EOPNOTSUPP if flag is invalid.
- * 4) preadv2() fails and sets errno to EFAULT when attempts to read into
- *    a invalid address.
- * 5) preadv2() fails and sets errno to EBADF if file descriptor is invalid.
- * 6) preadv2() fails and sets errno to EBADF if file descriptor is not
- *    open for reading.
- * 7) preadv2() fails and sets errno to EISDIR when fd refers to a directory.
- * 8) preadv2() fails and sets errno to ESPIPE if fd is associated with a pipe.
+/*\
+ * [Description]
+ *
+ * Verify that, preadv2(2) fails and sets errno to
+ *
+ * 1. EINVAL if iov_len is invalid.
+ * 2. EINVAL if the vector count iovcnt is less than zero.
+ * 3. EOPNOTSUPP if flag is invalid.
+ * 4. EFAULT when attempting to read into an invalid address.
+ * 5. EBADF if file descriptor is invalid.
+ * 6. EBADF if file descriptor is not open for reading.
+ * 7. EISDIR when fd refers to a directory.
+ * 8. ESPIPE if fd is associated with a pipe.
  */
 
 #define _GNU_SOURCE
@@ -25,7 +24,7 @@
 #include <unistd.h>
 
 #include "tst_test.h"
-#include "lapi/preadv2.h"
+#include "lapi/uio.h"
 
 #define CHUNK           64
 
diff --git a/testcases/kernel/syscalls/preadv2/preadv203.c b/testcases/kernel/syscalls/preadv2/preadv203.c
index c87deb674..72a35d3ab 100644
--- a/testcases/kernel/syscalls/preadv2/preadv203.c
+++ b/testcases/kernel/syscalls/preadv2/preadv203.c
@@ -45,7 +45,7 @@
 
 #include "tst_test.h"
 #include "tst_safe_pthread.h"
-#include "lapi/preadv2.h"
+#include "lapi/uio.h"
 
 #define CHUNK_SZ 4123
 #define CHUNKS 60
@@ -278,6 +278,6 @@ static struct tst_test test = {
 	.mntpoint = MNTPOINT,
 	.mount_device = 1,
 	.all_filesystems = 1,
-	.max_runtime = 60,
+	.runtime = 60,
 	.needs_root = 1,
 };
diff --git a/testcases/kernel/syscalls/process_madvise/process_madvise01.c b/testcases/kernel/syscalls/process_madvise/process_madvise01.c
index 0fd3c1ef4..ca314c4da 100644
--- a/testcases/kernel/syscalls/process_madvise/process_madvise01.c
+++ b/testcases/kernel/syscalls/process_madvise/process_madvise01.c
@@ -23,7 +23,9 @@
 #include "lapi/syscalls.h"
 #include "process_madvise.h"
 
-#define MEM_CHILD	(1 * TST_MB)
+#define MEM_LIMIT   (100 * TST_MB)
+#define MEMSW_LIMIT (200 * TST_MB)
+#define MEM_CHILD   (1   * TST_MB)
 
 static void **data_ptr;
 
@@ -67,6 +69,12 @@ static void child_alloc(void)
 
 static void setup(void)
 {
+	SAFE_CG_PRINTF(tst_cg, "memory.max", "%d", MEM_LIMIT);
+	if (SAFE_CG_HAS(tst_cg, "memory.swap.max"))
+		SAFE_CG_PRINTF(tst_cg, "memory.swap.max", "%d", MEMSW_LIMIT);
+
+	SAFE_CG_PRINTF(tst_cg, "cgroup.procs", "%d", getpid());
+
 	data_ptr = SAFE_MMAP(NULL, sizeof(void *),
 			PROT_READ | PROT_WRITE,
 			MAP_SHARED | MAP_ANONYMOUS, -1, 0);
@@ -123,7 +131,9 @@ static struct tst_test test = {
 	.min_kver = "5.10",
 	.needs_checkpoints = 1,
 	.needs_root = 1,
-	.min_swap_avail = MEM_CHILD / TST_MB,
+	.min_mem_avail = 2 * MEM_LIMIT / TST_MB,
+	.min_swap_avail = 2 * MEM_CHILD / TST_MB,
+	.needs_cgroup_ctrls = (const char *const []){ "memory", NULL },
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_SWAP=y",
 		NULL
diff --git a/testcases/kernel/syscalls/ptrace/ptrace05.c b/testcases/kernel/syscalls/ptrace/ptrace05.c
index 541018393..276faa77b 100644
--- a/testcases/kernel/syscalls/ptrace/ptrace05.c
+++ b/testcases/kernel/syscalls/ptrace/ptrace05.c
@@ -1,178 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- ******************************************************************************
- *
- *   ptrace05 - an app which ptraces itself as per arbitrarily specified signals,
- *   over a user specified range.
- *
- *   Copyright (C) 2009, Ngie Cooper
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License along
- *   with this program; if not, write to the Free Software Foundation, Inc.,
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * Copyright (c) Linux Test Project, 2009-2019
+ * Copyright (C) 2009, Ngie Cooper
+ * Copyright (c) 2023 Wei Gao <wegao@suse.com>
+ */
+
+/*\
+ * [Description]
  *
- ******************************************************************************
+ * This test ptraces itself as per arbitrarily specified signals,
+ * over 0 to SIGRTMAX range.
  */
 
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <signal.h>
-#include <errno.h>
-#include <libgen.h>
-#include <math.h>
 #include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
 #include <sys/ptrace.h>
-
-#include "test.h"
 #include "lapi/signal.h"
+#include "tst_test.h"
 
-char *TCID = "ptrace05";
-int TST_TOTAL = 0;
-
-int usage(const char *);
+static int expect_stop;
 
-int usage(const char *argv0)
+static void test_signal(int signum)
 {
-	fprintf(stderr, "usage: %s [start-signum] [end-signum]\n", argv0);
-	return 1;
-}
-
-int main(int argc, char **argv)
-{
-
-	int end_signum = -1;
-	int signum;
-	int start_signum = -1;
 	int status;
-
 	pid_t child;
 
-	tst_parse_opts(argc, argv, NULL, NULL);
+	child = SAFE_FORK();
 
-	if (start_signum == -1) {
-		start_signum = 0;
+	if (!child) {
+		TST_EXP_PASS_SILENT(ptrace(PTRACE_TRACEME, 0, NULL, NULL));
+		tst_res(TDEBUG, "[child] Sending kill(.., %s)", tst_strsig(signum));
+		SAFE_KILL(getpid(), signum);
+		exit(0);
 	}
-	if (end_signum == -1) {
-		end_signum = SIGRTMAX;
+
+	SAFE_WAITPID(child, &status, 0);
+
+	switch (signum) {
+	case 0:
+		if (WIFEXITED(status)
+				&& WEXITSTATUS(status) == 0) {
+			tst_res(TPASS,
+					"kill(.., 0) exited with 0, as expected.");
+		} else {
+			tst_res(TFAIL,
+					"kill(.., 0) exited with unexpected %s.", tst_strstatus(status));
+		}
+		break;
+	case SIGKILL:
+		if (WIFSIGNALED(status) && WTERMSIG(status) == SIGKILL)
+			tst_res(TPASS, "Child killed by SIGKILL");
+		else
+			tst_res(TFAIL, "Child %s", tst_strstatus(status));
+		break;
+		/* All other processes should be stopped. */
+	default:
+		if (WIFSTOPPED(status)) {
+			tst_res(TDEBUG, "Stopped as expected");
+		} else {
+			tst_res(TFAIL, "Didn't stop as expected. Child %s", tst_strstatus(status));
+			expect_stop++;
+		}
+		break;
 	}
 
-	for (signum = start_signum; signum <= end_signum; signum++) {
+	if (signum != 0 && signum != SIGKILL)
+		SAFE_PTRACE(PTRACE_CONT, child, NULL, NULL);
+}
+
+static void run(void)
+{
+	int signum = 0;
 
+	for (signum = 0; signum <= SIGRTMAX; signum++) {
 		if (signum >= __SIGRTMIN && signum < SIGRTMIN)
 			continue;
-
-		switch (child = fork()) {
-		case -1:
-			tst_brkm(TBROK | TERRNO, NULL, "fork() failed");
-		case 0:
-
-			if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != -1) {
-				tst_resm(TINFO, "[child] Sending kill(.., %d)",
-					 signum);
-				if (kill(getpid(), signum) < 0) {
-					tst_resm(TINFO | TERRNO,
-						 "[child] kill(.., %d) failed.",
-						 signum);
-				}
-			} else {
-
-				/*
-				 * This won't increment the TST_COUNT var.
-				 * properly, but it'll show up as a failure
-				 * nonetheless.
-				 */
-				tst_resm(TFAIL | TERRNO,
-					 "Failed to ptrace(PTRACE_TRACEME, ...) "
-					 "properly");
-
-			}
-			/* Shouldn't get here if signum == 0. */
-			exit((signum == 0 ? 0 : 2));
-			break;
-
-		default:
-
-			waitpid(child, &status, 0);
-
-			switch (signum) {
-			case 0:
-				if (WIFEXITED(status)
-				    && WEXITSTATUS(status) == 0) {
-					tst_resm(TPASS,
-						 "kill(.., 0) exited "
-						 "with 0, as expected.");
-				} else {
-					tst_resm(TFAIL,
-						 "kill(.., 0) didn't exit "
-						 "with 0.");
-				}
-				break;
-			case SIGKILL:
-				if (WIFSIGNALED(status)) {
-					/* SIGKILL must be uncatchable. */
-					if (WTERMSIG(status) == SIGKILL) {
-						tst_resm(TPASS,
-							 "Killed with SIGKILL, "
-							 "as expected.");
-					} else {
-						tst_resm(TPASS,
-							 "Didn't die with "
-							 "SIGKILL (?!) ");
-					}
-				} else if (WIFEXITED(status)) {
-					tst_resm(TFAIL,
-						 "Exited unexpectedly instead "
-						 "of dying with SIGKILL.");
-				} else if (WIFSTOPPED(status)) {
-					tst_resm(TFAIL,
-						 "Stopped instead of dying "
-						 "with SIGKILL.");
-				}
-				break;
-				/* All other processes should be stopped. */
-			default:
-				if (WIFSTOPPED(status)) {
-					tst_resm(TPASS, "Stopped as expected");
-				} else {
-					tst_resm(TFAIL, "Didn't stop as "
-						 "expected.");
-					if (kill(child, 0)) {
-						tst_resm(TINFO,
-							 "Is still alive!?");
-					} else if (WIFEXITED(status)) {
-						tst_resm(TINFO,
-							 "Exited normally");
-					} else if (WIFSIGNALED(status)) {
-						tst_resm(TINFO,
-							 "Was signaled with "
-							 "signum=%d",
-							 WTERMSIG(status));
-					}
-
-				}
-
-				break;
-
-			}
-
-		}
-		/* Make sure the child dies a quick and painless death ... */
-		kill(child, 9);
-
+		test_signal(signum);
 	}
-
-	tst_exit();
-
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.forks_child = 1,
+};
diff --git a/testcases/kernel/syscalls/ptrace/ptrace06.c b/testcases/kernel/syscalls/ptrace/ptrace06.c
index a1db3bab8..fa3f07fa1 100644
--- a/testcases/kernel/syscalls/ptrace/ptrace06.c
+++ b/testcases/kernel/syscalls/ptrace/ptrace06.c
@@ -1,199 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * check out-of-bound/unaligned addresses given to
+ * Copyright (c) 2008 Analog Devices Inc.
+ * Copyright (c) Linux Test Project, 2008-2023
+ * Copyright (c) 2025 Wei Gao <wegao@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Check out-of-bound/unaligned addresses given to
+ *
  *  - {PEEK,POKE}{DATA,TEXT,USER}
  *  - {GET,SET}{,FG}REGS
  *  - {GET,SET}SIGINFO
- *
- * Copyright (c) 2008 Analog Devices Inc.
- *
- * Licensed under the GPL-2 or later
  */
 
-#define _GNU_SOURCE
-
-#include <errno.h>
-#include <stdbool.h>
-#include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
 #include <sys/ptrace.h>
-
-#include "test.h"
-#include "spawn_ptrace_child.h"
+#include "tst_test.h"
 
 /* this should be sizeof(struct user), but that info is only found
  * in the kernel asm/user.h which is not exported to userspace.
  */
+
 #if defined(__i386__)
-#define SIZEOF_USER 284
+# define SIZEOF_USER 284
 #elif defined(__x86_64__)
-#define SIZEOF_USER 928
+# define SIZEOF_USER 928
 #else
-#define SIZEOF_USER 0x1000	/* just pick a big number */
+# define SIZEOF_USER 0x1000	/* just pick a big number */
 #endif
 
-char *TCID = "ptrace06";
-
-struct test_case_t {
+static struct test_case_t {
 	int request;
 	long addr;
 	long data;
 } test_cases[] = {
-	{
-	PTRACE_PEEKDATA,.addr = 0}, {
-	PTRACE_PEEKDATA,.addr = 1}, {
-	PTRACE_PEEKDATA,.addr = 2}, {
-	PTRACE_PEEKDATA,.addr = 3}, {
-	PTRACE_PEEKDATA,.addr = -1}, {
-	PTRACE_PEEKDATA,.addr = -2}, {
-	PTRACE_PEEKDATA,.addr = -3}, {
-	PTRACE_PEEKDATA,.addr = -4}, {
-	PTRACE_PEEKTEXT,.addr = 0}, {
-	PTRACE_PEEKTEXT,.addr = 1}, {
-	PTRACE_PEEKTEXT,.addr = 2}, {
-	PTRACE_PEEKTEXT,.addr = 3}, {
-	PTRACE_PEEKTEXT,.addr = -1}, {
-	PTRACE_PEEKTEXT,.addr = -2}, {
-	PTRACE_PEEKTEXT,.addr = -3}, {
-	PTRACE_PEEKTEXT,.addr = -4}, {
-	PTRACE_PEEKUSER,.addr = SIZEOF_USER + 1}, {
-	PTRACE_PEEKUSER,.addr = SIZEOF_USER + 2}, {
-	PTRACE_PEEKUSER,.addr = SIZEOF_USER + 3}, {
-	PTRACE_PEEKUSER,.addr = SIZEOF_USER + 4}, {
-	PTRACE_PEEKUSER,.addr = -1}, {
-	PTRACE_PEEKUSER,.addr = -2}, {
-	PTRACE_PEEKUSER,.addr = -3}, {
-	PTRACE_PEEKUSER,.addr = -4}, {
-	PTRACE_POKEDATA,.addr = 0}, {
-	PTRACE_POKEDATA,.addr = 1}, {
-	PTRACE_POKEDATA,.addr = 2}, {
-	PTRACE_POKEDATA,.addr = 3}, {
-	PTRACE_POKEDATA,.addr = -1}, {
-	PTRACE_POKEDATA,.addr = -2}, {
-	PTRACE_POKEDATA,.addr = -3}, {
-	PTRACE_POKEDATA,.addr = -4}, {
-	PTRACE_POKETEXT,.addr = 0}, {
-	PTRACE_POKETEXT,.addr = 1}, {
-	PTRACE_POKETEXT,.addr = 2}, {
-	PTRACE_POKETEXT,.addr = 3}, {
-	PTRACE_POKETEXT,.addr = -1}, {
-	PTRACE_POKETEXT,.addr = -2}, {
-	PTRACE_POKETEXT,.addr = -3}, {
-	PTRACE_POKETEXT,.addr = -4}, {
-	PTRACE_POKEUSER,.addr = SIZEOF_USER + 1}, {
-	PTRACE_POKEUSER,.addr = SIZEOF_USER + 2}, {
-	PTRACE_POKEUSER,.addr = SIZEOF_USER + 3}, {
-	PTRACE_POKEUSER,.addr = SIZEOF_USER + 4}, {
-	PTRACE_POKEUSER,.addr = -1}, {
-	PTRACE_POKEUSER,.addr = -2}, {
-	PTRACE_POKEUSER,.addr = -3}, {
-	PTRACE_POKEUSER,.addr = -4},
+	{PTRACE_PEEKDATA, .addr = 0},
+	{PTRACE_PEEKDATA, .addr = 1},
+	{PTRACE_PEEKDATA, .addr = 2},
+	{PTRACE_PEEKDATA, .addr = 3},
+	{PTRACE_PEEKDATA, .addr = -1},
+	{PTRACE_PEEKDATA, .addr = -2},
+	{PTRACE_PEEKDATA, .addr = -3},
+	{PTRACE_PEEKDATA, .addr = -4},
+	{PTRACE_PEEKTEXT, .addr = 0},
+	{PTRACE_PEEKTEXT, .addr = 1},
+	{PTRACE_PEEKTEXT, .addr = 2},
+	{PTRACE_PEEKTEXT, .addr = 3},
+	{PTRACE_PEEKTEXT, .addr = -1},
+	{PTRACE_PEEKTEXT, .addr = -2},
+	{PTRACE_PEEKTEXT, .addr = -3},
+	{PTRACE_PEEKTEXT, .addr = -4},
+	{PTRACE_PEEKUSER, .addr = SIZEOF_USER + 1},
+	{PTRACE_PEEKUSER, .addr = SIZEOF_USER + 2},
+	{PTRACE_PEEKUSER, .addr = SIZEOF_USER + 3},
+	{PTRACE_PEEKUSER, .addr = SIZEOF_USER + 4},
+	{PTRACE_PEEKUSER, .addr = -1},
+	{PTRACE_PEEKUSER, .addr = -2},
+	{PTRACE_PEEKUSER, .addr = -3},
+	{PTRACE_PEEKUSER, .addr = -4},
+	{PTRACE_POKEDATA, .addr = 0},
+	{PTRACE_POKEDATA, .addr = 1},
+	{PTRACE_POKEDATA, .addr = 2},
+	{PTRACE_POKEDATA, .addr = 3},
+	{PTRACE_POKEDATA, .addr = -1},
+	{PTRACE_POKEDATA, .addr = -2},
+	{PTRACE_POKEDATA, .addr = -3},
+	{PTRACE_POKEDATA, .addr = -4},
+	{PTRACE_POKETEXT, .addr = 0},
+	{PTRACE_POKETEXT, .addr = 1},
+	{PTRACE_POKETEXT, .addr = 2},
+	{PTRACE_POKETEXT, .addr = 3},
+	{PTRACE_POKETEXT, .addr = -1},
+	{PTRACE_POKETEXT, .addr = -2},
+	{PTRACE_POKETEXT, .addr = -3},
+	{PTRACE_POKETEXT, .addr = -4},
+	{PTRACE_POKEUSER, .addr = SIZEOF_USER + 1},
+	{PTRACE_POKEUSER, .addr = SIZEOF_USER + 2},
+	{PTRACE_POKEUSER, .addr = SIZEOF_USER + 3},
+	{PTRACE_POKEUSER, .addr = SIZEOF_USER + 4},
+	{PTRACE_POKEUSER, .addr = -1},
+	{PTRACE_POKEUSER, .addr = -2},
+	{PTRACE_POKEUSER, .addr = -3},
+	{PTRACE_POKEUSER, .addr = -4},
 #ifdef PTRACE_GETREGS
-	{
-	PTRACE_GETREGS,.data = 0}, {
-	PTRACE_GETREGS,.data = 1}, {
-	PTRACE_GETREGS,.data = 2}, {
-	PTRACE_GETREGS,.data = 3}, {
-	PTRACE_GETREGS,.data = -1}, {
-	PTRACE_GETREGS,.data = -2}, {
-	PTRACE_GETREGS,.data = -3}, {
-	PTRACE_GETREGS,.data = -4},
+	{PTRACE_GETREGS, .data = 0},
+	{PTRACE_GETREGS, .data = 1},
+	{PTRACE_GETREGS, .data = 2},
+	{PTRACE_GETREGS, .data = 3},
+	{PTRACE_GETREGS, .data = -1},
+	{PTRACE_GETREGS, .data = -2},
+	{PTRACE_GETREGS, .data = -3},
+	{PTRACE_GETREGS, .data = -4},
 #endif
 #ifdef PTRACE_GETFGREGS
-	{
-	PTRACE_GETFGREGS,.data = 0}, {
-	PTRACE_GETFGREGS,.data = 1}, {
-	PTRACE_GETFGREGS,.data = 2}, {
-	PTRACE_GETFGREGS,.data = 3}, {
-	PTRACE_GETFGREGS,.data = -1}, {
-	PTRACE_GETFGREGS,.data = -2}, {
-	PTRACE_GETFGREGS,.data = -3}, {
-	PTRACE_GETFGREGS,.data = -4},
+	{PTRACE_GETFGREGS, .data = 0},
+	{PTRACE_GETFGREGS, .data = 1},
+	{PTRACE_GETFGREGS, .data = 2},
+	{PTRACE_GETFGREGS, .data = 3},
+	{PTRACE_GETFGREGS, .data = -1},
+	{PTRACE_GETFGREGS, .data = -2},
+	{PTRACE_GETFGREGS, .data = -3},
+	{PTRACE_GETFGREGS, .data = -4},
 #endif
 #ifdef PTRACE_SETREGS
-	{
-	PTRACE_SETREGS,.data = 0}, {
-	PTRACE_SETREGS,.data = 1}, {
-	PTRACE_SETREGS,.data = 2}, {
-	PTRACE_SETREGS,.data = 3}, {
-	PTRACE_SETREGS,.data = -1}, {
-	PTRACE_SETREGS,.data = -2}, {
-	PTRACE_SETREGS,.data = -3}, {
-	PTRACE_SETREGS,.data = -4},
+	{PTRACE_SETREGS, .data = 0},
+	{PTRACE_SETREGS, .data = 1},
+	{PTRACE_SETREGS, .data = 2},
+	{PTRACE_SETREGS, .data = 3},
+	{PTRACE_SETREGS, .data = -1},
+	{PTRACE_SETREGS, .data = -2},
+	{PTRACE_SETREGS, .data = -3},
+	{PTRACE_SETREGS, .data = -4},
 #endif
 #ifdef PTRACE_SETFGREGS
-	{
-	PTRACE_SETFGREGS,.data = 0}, {
-	PTRACE_SETFGREGS,.data = 1}, {
-	PTRACE_SETFGREGS,.data = 2}, {
-	PTRACE_SETFGREGS,.data = 3}, {
-	PTRACE_SETFGREGS,.data = -1}, {
-	PTRACE_SETFGREGS,.data = -2}, {
-	PTRACE_SETFGREGS,.data = -3}, {
-	PTRACE_SETFGREGS,.data = -4},
+	{PTRACE_SETFGREGS, .data = 0},
+	{PTRACE_SETFGREGS, .data = 1},
+	{PTRACE_SETFGREGS, .data = 2},
+	{PTRACE_SETFGREGS, .data = 3},
+	{PTRACE_SETFGREGS, .data = -1},
+	{PTRACE_SETFGREGS, .data = -2},
+	{PTRACE_SETFGREGS, .data = -3},
+	{PTRACE_SETFGREGS, .data = -4},
 #endif
 #if HAVE_DECL_PTRACE_GETSIGINFO
-	{
-	PTRACE_GETSIGINFO,.data = 0}, {
-	PTRACE_GETSIGINFO,.data = 1}, {
-	PTRACE_GETSIGINFO,.data = 2}, {
-	PTRACE_GETSIGINFO,.data = 3}, {
-	PTRACE_GETSIGINFO,.data = -1}, {
-	PTRACE_GETSIGINFO,.data = -2}, {
-	PTRACE_GETSIGINFO,.data = -3}, {
-	PTRACE_GETSIGINFO,.data = -4},
+	{PTRACE_GETSIGINFO, .data = 0},
+	{PTRACE_GETSIGINFO, .data = 1},
+	{PTRACE_GETSIGINFO, .data = 2},
+	{PTRACE_GETSIGINFO, .data = 3},
+	{PTRACE_GETSIGINFO, .data = -1},
+	{PTRACE_GETSIGINFO, .data = -2},
+	{PTRACE_GETSIGINFO, .data = -3},
+	{PTRACE_GETSIGINFO, .data = -4},
 #endif
 #if HAVE_DECL_PTRACE_SETSIGINFO
-	{
-	PTRACE_SETSIGINFO,.data = 0}, {
-	PTRACE_SETSIGINFO,.data = 1}, {
-	PTRACE_SETSIGINFO,.data = 2}, {
-	PTRACE_SETSIGINFO,.data = 3}, {
-	PTRACE_SETSIGINFO,.data = -1}, {
-	PTRACE_SETSIGINFO,.data = -2}, {
-	PTRACE_SETSIGINFO,.data = -3}, {
-	PTRACE_SETSIGINFO,.data = -4},
+	{PTRACE_SETSIGINFO, .data = 0},
+	{PTRACE_SETSIGINFO, .data = 1},
+	{PTRACE_SETSIGINFO, .data = 2},
+	{PTRACE_SETSIGINFO, .data = 3},
+	{PTRACE_SETSIGINFO, .data = -1},
+	{PTRACE_SETSIGINFO, .data = -2},
+	{PTRACE_SETSIGINFO, .data = -3},
+	{PTRACE_SETSIGINFO, .data = -4},
+#endif
+};
+
+#define SPT(x)[PTRACE_##x] = #x,
+static char *strings[] = {
+	SPT(TRACEME)
+	SPT(PEEKTEXT)
+	SPT(PEEKDATA)
+	SPT(PEEKUSER)
+	SPT(POKETEXT)
+	SPT(POKEDATA)
+	SPT(POKEUSER)
+#ifdef PTRACE_GETREGS
+	SPT(GETREGS)
+#endif
+#ifdef PTRACE_SETREGS
+	SPT(SETREGS)
+#endif
+#ifdef PTRACE_GETSIGINFO
+	SPT(GETSIGINFO)
 #endif
+#ifdef PTRACE_SETSIGINFO
+	SPT(SETSIGINFO)
+#endif
+#ifdef PTRACE_GETFGREGS
+	SPT(GETFGREGS)
+#endif
+#ifdef PTRACE_SETFGREGS
+	SPT(SETFGREGS)
+#endif
+	SPT(KILL)
+	SPT(SINGLESTEP)
 };
 
-int TST_TOTAL = ARRAY_SIZE(test_cases);
+static void child(void)
+{
+	SAFE_PTRACE(PTRACE_TRACEME, 0, NULL, NULL);
+	raise(SIGSTOP);
+	exit(0);
+}
 
-int main(int argc, char *argv[])
+static void run(void)
 {
 	size_t i;
-	long ret;
-	int saved_errno;
+	int pid;
+	int status;
+	int exp_errnos[] = {EIO, EFAULT};
+
+	pid = SAFE_FORK();
 
-	tst_parse_opts(argc, argv, NULL, NULL);
+	if (!pid)
+		child();
 
-	make_a_baby(argc, argv);
+	SAFE_WAIT(&status);
+
+	if (!WIFSTOPPED(status))
+		tst_brk(TBROK, "child %d was not stopped", pid);
 
 	for (i = 0; i < ARRAY_SIZE(test_cases); ++i) {
 		struct test_case_t *tc = &test_cases[i];
 
-		errno = 0;
-		ret =
-		    ptrace(tc->request, pid, (void *)tc->addr,
-			   (void *)tc->data);
-		saved_errno = errno;
-		if (ret != -1)
-			tst_resm(TFAIL,
-				 "ptrace(%s, ..., %li, %li) returned %li instead of -1",
-				 strptrace(tc->request), tc->addr, tc->data,
-				 ret);
-		else if (saved_errno != EIO && saved_errno != EFAULT)
-			tst_resm(TFAIL,
-				 "ptrace(%s, ..., %li, %li) expected errno EIO or EFAULT; actual: %i (%s)",
-				 strptrace(tc->request), tc->addr, tc->data,
-				 saved_errno, strerror(saved_errno));
-		else
-			tst_resm(TPASS,
-				 "ptrace(%s, ..., %li, %li) failed as expected",
-				 strptrace(tc->request), tc->addr, tc->data);
+		TST_EXP_FAIL_ARR(ptrace(tc->request, pid, (void *)tc->addr,
+					(void *)tc->data), exp_errnos, ARRAY_SIZE(exp_errnos),
+					"ptrace(%s, ..., %li, %li) failed as expected",
+					 strings[tc->request], tc->addr, tc->data);
 	}
 
-	/* hopefully this worked */
-	ptrace(PTRACE_KILL, pid, NULL, NULL);
+	SAFE_PTRACE(PTRACE_CONT, pid, NULL, NULL);
 
-	tst_exit();
 }
+
+static struct tst_test test = {
+	.test_all = run,
+	.forks_child = 1,
+};
diff --git a/testcases/kernel/syscalls/pwritev/pwritev.h b/testcases/kernel/syscalls/pwritev/pwritev.h
deleted file mode 100644
index e657dc7e6..000000000
--- a/testcases/kernel/syscalls/pwritev/pwritev.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later
- *
- * Copyright (c) 2015 Fujitsu Ltd.
- * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
- * Copyright (c) Linux Test Project, 2016-2023
- */
-
-#ifndef PWRITEV_H
-#define PWRITEV_H
-
-#include <sys/types.h>
-#include "config.h"
-#include "lapi/syscalls.h"
-
-#if !defined(HAVE_PWRITEV)
-int pwritev(int fd, const struct iovec *iov, int iovcnt, off_t offset)
-{
-	return tst_syscall(__NR_pwritev, fd, iov, iovcnt, offset);
-}
-#endif
-
-#endif /* PWRITEV_H */
diff --git a/testcases/kernel/syscalls/pwritev/pwritev01.c b/testcases/kernel/syscalls/pwritev/pwritev01.c
index f5fce81f2..1a4f672bf 100644
--- a/testcases/kernel/syscalls/pwritev/pwritev01.c
+++ b/testcases/kernel/syscalls/pwritev/pwritev01.c
@@ -18,7 +18,7 @@
 #include <string.h>
 #include <sys/uio.h>
 #include "tst_test.h"
-#include "pwritev.h"
+#include "lapi/uio.h"
 #include "tst_safe_prw.h"
 
 #define	CHUNK		64
diff --git a/testcases/kernel/syscalls/pwritev/pwritev02.c b/testcases/kernel/syscalls/pwritev/pwritev02.c
index 59a286847..25eb242f5 100644
--- a/testcases/kernel/syscalls/pwritev/pwritev02.c
+++ b/testcases/kernel/syscalls/pwritev/pwritev02.c
@@ -22,7 +22,7 @@
 #include <sys/uio.h>
 #include <unistd.h>
 #include "tst_test.h"
-#include "pwritev.h"
+#include "lapi/uio.h"
 
 #define CHUNK           64
 
diff --git a/testcases/kernel/syscalls/pwritev/pwritev03.c b/testcases/kernel/syscalls/pwritev/pwritev03.c
index 1bf9d5731..81ccee9be 100644
--- a/testcases/kernel/syscalls/pwritev/pwritev03.c
+++ b/testcases/kernel/syscalls/pwritev/pwritev03.c
@@ -22,7 +22,7 @@
 #include <sys/ioctl.h>
 #include <sys/mount.h>
 #include "tst_test.h"
-#include "pwritev.h"
+#include "lapi/uio.h"
 #include "tst_safe_prw.h"
 
 #define MNTPOINT	"mntpoint"
diff --git a/testcases/kernel/syscalls/pwritev2/pwritev201.c b/testcases/kernel/syscalls/pwritev2/pwritev201.c
index 987412ba8..ae9047cdd 100644
--- a/testcases/kernel/syscalls/pwritev2/pwritev201.c
+++ b/testcases/kernel/syscalls/pwritev2/pwritev201.c
@@ -22,7 +22,7 @@
 #include <sys/uio.h>
 
 #include "tst_test.h"
-#include "lapi/pwritev2.h"
+#include "lapi/uio.h"
 #include "tst_safe_prw.h"
 
 #define CHUNK	64
diff --git a/testcases/kernel/syscalls/pwritev2/pwritev202.c b/testcases/kernel/syscalls/pwritev2/pwritev202.c
index 5a1c4c6b6..e4d80070d 100644
--- a/testcases/kernel/syscalls/pwritev2/pwritev202.c
+++ b/testcases/kernel/syscalls/pwritev2/pwritev202.c
@@ -26,7 +26,7 @@
 #include <unistd.h>
 
 #include "tst_test.h"
-#include "lapi/pwritev2.h"
+#include "lapi/uio.h"
 
 #define CHUNK	64
 
diff --git a/testcases/kernel/syscalls/quotactl/quotactl01.c b/testcases/kernel/syscalls/quotactl/quotactl01.c
index 36ec93edc..7b7fb6360 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl01.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl01.c
@@ -216,9 +216,14 @@ static struct tst_test test = {
 	.test = verify_quota,
 	.tcnt = ARRAY_SIZE(tcases),
 	.mount_device = 1,
-	.dev_fs_type = "ext4",
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "ext4",
+			.mnt_data = "usrquota,grpquota",
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
-	.mnt_data = "usrquota,grpquota",
 	.needs_cmds = (const char *const []) {
 		"quotacheck",
 		NULL
diff --git a/testcases/kernel/syscalls/quotactl/quotactl02.c b/testcases/kernel/syscalls/quotactl/quotactl02.c
index d9c4f9b2e..f83716556 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl02.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl02.c
@@ -150,9 +150,14 @@ static struct tst_test test = {
 	.test = verify_quota,
 	.tcnt = ARRAY_SIZE(tcases),
 	.mount_device = 1,
-	.dev_fs_type = "xfs",
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "xfs",
+			.mnt_data = "usrquota,grpquota",
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
-	.mnt_data = "usrquota,grpquota",
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_variants = QUOTACTL_SYSCALL_VARIANTS,
diff --git a/testcases/kernel/syscalls/quotactl/quotactl03.c b/testcases/kernel/syscalls/quotactl/quotactl03.c
index 22f5496b6..78d9a5458 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl03.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl03.c
@@ -83,9 +83,14 @@ static struct tst_test test = {
 	},
 	.test_all = verify_quota,
 	.mount_device = 1,
-	.dev_fs_type = "xfs",
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "xfs",
+			.mnt_data = "usrquota",
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
-	.mnt_data = "usrquota",
 	.test_variants = QUOTACTL_SYSCALL_VARIANTS,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "657bdfb7f5e6"},
diff --git a/testcases/kernel/syscalls/quotactl/quotactl04.c b/testcases/kernel/syscalls/quotactl/quotactl04.c
index a57e6be60..91f15eb5d 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl04.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl04.c
@@ -32,7 +32,7 @@
 #define FMTID QFMT_VFS_V1
 
 static int32_t fmt_id = FMTID;
-static int test_id, mount_flag;
+static int test_id;
 static struct dqblk set_dq = {
 	.dqb_bsoftlimit = 100,
 	.dqb_valid = QIF_BLIMITS
@@ -98,12 +98,8 @@ static struct tcase {
 
 static void setup(void)
 {
-	const char *const fs_opts[] = {"-I 256", "-O quota,project", NULL};
-
 	quotactl_info();
-	SAFE_MKFS(tst_device->dev, tst_device->fs_type, fs_opts, NULL);
-	SAFE_MOUNT(tst_device->dev, MNTPOINT, tst_device->fs_type, 0, NULL);
-	mount_flag = 1;
+
 	fd = SAFE_OPEN(MNTPOINT, O_RDONLY);
 
 	TEST(do_quotactl(fd, QCMD(Q_GETNEXTQUOTA, PRJQUOTA), tst_device->dev,
@@ -116,8 +112,6 @@ static void cleanup(void)
 {
 	if (fd > -1)
 		SAFE_CLOSE(fd);
-	if (mount_flag && tst_umount(MNTPOINT))
-		tst_res(TWARN | TERRNO, "umount(%s)", MNTPOINT);
 }
 
 static void verify_quota(unsigned int n)
@@ -161,8 +155,16 @@ static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
 	.cleanup = cleanup,
-	.needs_device = 1,
-	.dev_fs_type = "ext4",
+	.mount_device = 1,
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "ext4",
+			.mkfs_opts = (const char *const[]) {
+				"-I 256", "-O quota,project", NULL
+			},
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
 	.test_variants = QUOTACTL_SYSCALL_VARIANTS,
 	.needs_cmds = (const char *[]) {
diff --git a/testcases/kernel/syscalls/quotactl/quotactl05.c b/testcases/kernel/syscalls/quotactl/quotactl05.c
index ac75cee31..d19c729f8 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl05.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl05.c
@@ -113,9 +113,14 @@ static struct tst_test test = {
 	.test = verify_quota,
 	.tcnt = ARRAY_SIZE(tcases),
 	.mount_device = 1,
-	.dev_fs_type = "xfs",
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "xfs",
+			.mnt_data = "prjquota",
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
-	.mnt_data = "prjquota",
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_variants = QUOTACTL_SYSCALL_VARIANTS,
diff --git a/testcases/kernel/syscalls/quotactl/quotactl06.c b/testcases/kernel/syscalls/quotactl/quotactl06.c
index 74a098a8c..86b0d95d2 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl06.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl06.c
@@ -219,10 +219,15 @@ static struct tst_test test = {
 	},
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = verify_quotactl,
-	.dev_fs_type = "ext4",
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "ext4",
+			.mnt_data = "usrquota",
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
 	.mount_device = 1,
-	.mnt_data = "usrquota",
 	.needs_cmds = (const char *const []) {
 		"quotacheck",
 		NULL
diff --git a/testcases/kernel/syscalls/quotactl/quotactl07.c b/testcases/kernel/syscalls/quotactl/quotactl07.c
index 34ff2705d..c6e44b0a7 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl07.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl07.c
@@ -13,6 +13,8 @@
  * ("xfs: Sanity check flags of Q_XQUOTARM call").
  */
 
+#define _GNU_SOURCE
+#include <fcntl.h>
 #include <errno.h>
 #include <unistd.h>
 #include <stdio.h>
@@ -83,7 +85,10 @@ static struct tst_test test = {
 	},
 	.test_all = verify_quota,
 	.format_device = 1,
-	.dev_fs_type = "xfs",
+	.filesystems = (struct tst_fs []) {
+		{.type = "xfs"},
+		{}
+	},
 	.mntpoint = MNTPOINT,
 	.test_variants = QUOTACTL_SYSCALL_VARIANTS,
 	.tags = (const struct tst_tag[]) {
diff --git a/testcases/kernel/syscalls/quotactl/quotactl08.c b/testcases/kernel/syscalls/quotactl/quotactl08.c
index 0fabb51a5..85a2f4731 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl08.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl08.c
@@ -44,7 +44,7 @@
 #define MNTPOINT	"mntpoint"
 
 static int32_t fmt_id = QFMT_VFS_V1;
-static int test_id, mount_flag;
+static int test_id;
 static struct dqblk set_dq = {
 	.dqb_bsoftlimit = 100,
 	.dqb_valid = QIF_BLIMITS
@@ -153,14 +153,8 @@ static struct tcase {
 
 static void setup(void)
 {
-	const char *const fs_opts[] = { "-O quota", NULL};
-
 	quotactl_info();
 
-	SAFE_MKFS(tst_device->dev, tst_device->fs_type, fs_opts, NULL);
-	SAFE_MOUNT(tst_device->dev, MNTPOINT, tst_device->fs_type, 0, NULL);
-	mount_flag = 1;
-
 	fd = SAFE_OPEN(MNTPOINT, O_RDONLY);
 	TEST(do_quotactl(fd, QCMD(Q_GETNEXTQUOTA, USRQUOTA), tst_device->dev,
 		0, (void *) &res_ndq));
@@ -172,8 +166,6 @@ static void cleanup(void)
 {
 	if (fd > -1)
 		SAFE_CLOSE(fd);
-	if (mount_flag && tst_umount(MNTPOINT))
-		tst_res(TWARN | TERRNO, "umount(%s)", MNTPOINT);
 }
 
 static void verify_quota(unsigned int n)
@@ -216,8 +208,16 @@ static struct tst_test test = {
 	.test = verify_quota,
 	.tcnt = ARRAY_SIZE(tcases),
 	.mntpoint = MNTPOINT,
-	.dev_fs_type = "ext4",
-	.needs_device = 1,
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "ext4",
+			.mkfs_opts = (const char *const[]){
+				"-O quota", NULL
+			},
+		},
+		{}
+	},
+	.mount_device = 1,
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_variants = QUOTACTL_SYSCALL_VARIANTS,
diff --git a/testcases/kernel/syscalls/quotactl/quotactl09.c b/testcases/kernel/syscalls/quotactl/quotactl09.c
index 9a03bff5f..4ddcbd659 100644
--- a/testcases/kernel/syscalls/quotactl/quotactl09.c
+++ b/testcases/kernel/syscalls/quotactl/quotactl09.c
@@ -176,8 +176,13 @@ static struct tst_test test = {
 	},
 	.tcnt = ARRAY_SIZE(tcases),
 	.test = verify_quotactl,
-	.dev_fs_opts = (const char *const[]){"-O quota", NULL},
-	.dev_fs_type = "ext4",
+	.filesystems = (struct tst_fs []) {
+		{
+			.type = "ext4",
+			.mkfs_opts = (const char *const[]){"-O quota", NULL},
+		},
+		{}
+	},
 	.mntpoint = MNTPOINT,
 	.mount_device = 1,
 	.needs_root = 1,
diff --git a/testcases/kernel/syscalls/readahead/readahead02.c b/testcases/kernel/syscalls/readahead/readahead02.c
index a109573fe..f007db187 100644
--- a/testcases/kernel/syscalls/readahead/readahead02.c
+++ b/testcases/kernel/syscalls/readahead/readahead02.c
@@ -318,19 +318,6 @@ static void test_readahead(unsigned int n)
 		tst_res(TCONF, "Page cache on your system is too small "
 			"to hold whole testfile.");
 	}
-
-	/*
-	 * The time consuming of readahead quite depending on the platform IO
-	 * speed, sometime test timeout when the default max_runtime is used up.
-	 *
-	 *  readahead02.c:221: TINFO: Test #2: POSIX_FADV_WILLNEED on file
-	 *  readahead02.c:285: TINFO: read_testfile(0) took: 26317623 usec
-	 *  readahead02.c:286: TINFO: read_testfile(1) took: 26101484 usec
-	 *
-	 * Here raise the maximum runtime dynamically.
-	 */
-	if ((tc+1)->readahead)
-		tst_set_max_runtime(test.max_runtime + (usec + usec_ra) / 1000000);
 }
 
 
@@ -381,7 +368,7 @@ static void setup(void)
 {
 	if (opt_fsizestr) {
 		testfile_size = SAFE_STRTOL(opt_fsizestr, 1, INT_MAX);
-		tst_set_max_runtime(1 + testfile_size / (DEFAULT_FILESIZE/32));
+		tst_set_runtime(1 + testfile_size / (DEFAULT_FILESIZE/32));
 	}
 
 	if (access(PROC_IO_FNAME, F_OK))
@@ -422,7 +409,7 @@ static struct tst_test test = {
 	},
 	.test = test_readahead,
 	.tcnt = ARRAY_SIZE(tcases),
-	.max_runtime = 30,
+	.timeout = 60,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "b833a3660394"},
 		{"linux-git", "5b910bd615ba"},
diff --git a/testcases/kernel/syscalls/readdir/readdir01.c b/testcases/kernel/syscalls/readdir/readdir01.c
index 1bf70fd1f..2dc8f916d 100644
--- a/testcases/kernel/syscalls/readdir/readdir01.c
+++ b/testcases/kernel/syscalls/readdir/readdir01.c
@@ -22,6 +22,8 @@
 #include <stdio.h>
 #include "tst_test.h"
 
+#define MNTPOINT "mntpoint"
+
 static const char prefix[] = "readdirfile";
 static int nfiles = 10;
 
@@ -32,7 +34,7 @@ static void setup(void)
 	int fd;
 
 	for (i = 0; i < nfiles; i++) {
-		sprintf(fname, "%s_%d", prefix, i);
+		sprintf(fname, "%s/%s_%d", MNTPOINT, prefix, i);
 		fd = SAFE_OPEN(fname, O_RDWR | O_CREAT, 0700);
 		SAFE_WRITE(SAFE_WRITE_ALL, fd, "hello\n", 6);
 		SAFE_CLOSE(fd);
@@ -45,7 +47,7 @@ static void verify_readdir(void)
 	DIR *test_dir;
 	struct dirent *ent;
 
-	test_dir = SAFE_OPENDIR(".");
+	test_dir = SAFE_OPENDIR(MNTPOINT);
 	while ((ent = SAFE_READDIR(test_dir))) {
 		if (!strcmp(ent->d_name, ".") || !strcmp(ent->d_name, ".."))
 			continue;
@@ -66,5 +68,8 @@ static void verify_readdir(void)
 static struct tst_test test = {
 	.setup = setup,
 	.test_all = verify_readdir,
-	.needs_tmpdir = 1,
+	.needs_root = 1,
+	.all_filesystems = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT
 };
diff --git a/testcases/kernel/syscalls/readdir/readdir21.c b/testcases/kernel/syscalls/readdir/readdir21.c
index 7308c8bcc..7b747dbd3 100644
--- a/testcases/kernel/syscalls/readdir/readdir21.c
+++ b/testcases/kernel/syscalls/readdir/readdir21.c
@@ -20,9 +20,10 @@
 #include "lapi/syscalls.h"
 #include "lapi/readdir.h"
 
-#define TEST_DIR	"test_dir"
-#define TEST_DIR4	"test_dir4"
-#define TEST_FILE	"test_file"
+#define MNTPOINT	"mntpoint"
+#define TEST_DIR	MNTPOINT "/test_dir"
+#define TEST_DIR4	MNTPOINT "/test_dir4"
+#define TEST_FILE	MNTPOINT "/test_file"
 #define DIR_MODE	0755
 
 static unsigned int del_dir_fd, file_fd;
@@ -75,5 +76,8 @@ static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(tcases),
 	.setup = setup,
 	.test = verify_readdir,
-	.needs_tmpdir = 1,
+	.needs_root = 1,
+	.all_filesystems = 1,
+	.mount_device = 1,
+	.mntpoint = MNTPOINT
 };
diff --git a/testcases/kernel/syscalls/readlink/readlink01.c b/testcases/kernel/syscalls/readlink/readlink01.c
index 389ba1fee..8165547d4 100644
--- a/testcases/kernel/syscalls/readlink/readlink01.c
+++ b/testcases/kernel/syscalls/readlink/readlink01.c
@@ -4,10 +4,12 @@
  * Ported to LTP: Wayne Boyer
  */
 
-/*
- * Test Description :
- *   Testcase to check the basic functionality of the readlink(2),
- *   readlink() will succeed to read the contents of the symbolic link.
+/*\
+ * [Description]
+ *
+ * Tests basic functionality of readlink(2).
+ *
+ * - readlink() will succeed to read the contents of the symbolic link
  */
 
 #include <pwd.h>
diff --git a/testcases/kernel/syscalls/readlink/readlink03.c b/testcases/kernel/syscalls/readlink/readlink03.c
index 01ff304d8..dce636664 100644
--- a/testcases/kernel/syscalls/readlink/readlink03.c
+++ b/testcases/kernel/syscalls/readlink/readlink03.c
@@ -4,25 +4,22 @@
  * Ported to LTP: Wayne Boyer
  */
 
-/*
- * Test Description :
- *   1) readlink(2) returns -1 and sets errno to EACCES if search/write
- *	permission is denied in the directory where the symbolic link
- *	resides.
- *   2) readlink(2) returns -1 and sets errno to EINVAL if the buffer size
- *	is not positive.
- *   3) readlink(2) returns -1 and sets errno to EINVAL if the specified
- *	file is not a symbolic link file.
- *   4) readlink(2) returns -1 and sets errno to ENAMETOOLONG if the
- *	pathname component of symbolic link is too long (ie, > PATH_MAX).
- *   5) readlink(2) returns -1 and sets errno to ENOENT if the component of
- *	symbolic link points to an empty string.
- *   6) readlink(2) returns -1 and sets errno to ENOTDIR if a component of
- *	the path prefix is not a directory.
- *   7) readlink(2) returns -1 and sets errno to ELOOP if too many symbolic
- *	links were encountered in translating the pathname.
- *   8) readlink(2) returns -1 and sets errno to EFAULT if buf outside the
- *	process allocated address space.
+/*\
+ * [Description]
+ *
+ * Verify that, readlink(2) returns -1 and sets errno to
+ *
+ * 1. EACCES if search/write permission is denied in the directory where the
+ * symbolic link esides.
+ * 2. EINVAL if the buffer size is not positive.
+ * 3. EINVAL if the specified file is not a symbolic link file.
+ * 4. ENAMETOOLONG if the pathname component of symbolic link is too long
+ * (ie, > PATH_MAX).
+ * 5. ENOENT if the component of symbolic link points to an empty string.
+ * 6. ENOTDIR if a component of the path prefix is not a directory.
+ * 7. ELOOP if too many symbolic links were encountered in translating the
+ * pathname.
+ * 8. EFAULT if buf outside the process allocated address space.
  */
 
 #include <pwd.h>
diff --git a/testcases/kernel/syscalls/readlinkat/readlinkat01.c b/testcases/kernel/syscalls/readlinkat/readlinkat01.c
index b1214c3ae..9f238ff0a 100644
--- a/testcases/kernel/syscalls/readlinkat/readlinkat01.c
+++ b/testcases/kernel/syscalls/readlinkat/readlinkat01.c
@@ -66,10 +66,7 @@ static void verify_readlinkat(unsigned int i)
 
 static void setup(void)
 {
-	char *tmpdir = tst_get_tmpdir();
-
-	abspath = tst_aprintf("%s/" TEST_SYMLINK, tmpdir);
-	free(tmpdir);
+	abspath = tst_tmpdir_genpath(TEST_SYMLINK);
 
 	file_fd = SAFE_OPEN(TEST_FILE, O_CREAT, 0600);
 	SAFE_SYMLINK(TEST_FILE, TEST_SYMLINK);
diff --git a/testcases/kernel/syscalls/realpath/realpath01.c b/testcases/kernel/syscalls/realpath/realpath01.c
index c4c603609..e65debd58 100644
--- a/testcases/kernel/syscalls/realpath/realpath01.c
+++ b/testcases/kernel/syscalls/realpath/realpath01.c
@@ -3,12 +3,20 @@
  * Copyright (C) 2018 Petr Vorel <pvorel@suse.cz>
  * Copyright (C) 2018 Michael Moese <mmoese@suse.de>
  *
- * cve-2018-1000001 realpath buffer underflow
  * Based on the reproducer posted upstream so other copyrights may apply.
  * Author: Dmitry V. Levin <ldv@altlinux.org>
  * LTP conversion from glibc source: Petr Vorel <pvorel@suse.cz>
  */
 
+/*\
+ * [Description]
+ *
+ * CVE-2018-1000001 realpath buffer underflow.
+ *
+ * Based on glibc test io/tst-getcwd-abspath.c:
+ * https://sourceware.org/git/?p=glibc.git;a=commit;h=52a713fdd0a30e1bd79818e2e3c4ab44ddca1a94.
+ */
+
 #include "tst_test.h"
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/recv/recv01.c b/testcases/kernel/syscalls/recv/recv01.c
index d71243c30..bb2578355 100644
--- a/testcases/kernel/syscalls/recv/recv01.c
+++ b/testcases/kernel/syscalls/recv/recv01.c
@@ -113,14 +113,6 @@ int main(int argc, char *argv[])
 	for (lc = 0; TEST_LOOPING(lc); ++lc) {
 		tst_count = 0;
 		for (testno = 0; testno < TST_TOTAL; ++testno) {
-			if ((tst_kvercmp(3, 17, 0) < 0)
-			    && (tdat[testno].flags & MSG_ERRQUEUE)
-			    && (tdat[testno].type & SOCK_STREAM)) {
-				tst_resm(TCONF, "skip MSG_ERRQUEUE test, "
-						"it's supported from 3.17");
-				continue;
-			}
-
 			tdat[testno].setup();
 			TEST(recv(s, tdat[testno].buf, tdat[testno].buflen,
 				  tdat[testno].flags));
diff --git a/testcases/kernel/syscalls/recvfrom/recvfrom01.c b/testcases/kernel/syscalls/recvfrom/recvfrom01.c
index f26f85688..6ce9f1bde 100644
--- a/testcases/kernel/syscalls/recvfrom/recvfrom01.c
+++ b/testcases/kernel/syscalls/recvfrom/recvfrom01.c
@@ -137,14 +137,6 @@ int main(int argc, char *argv[])
 	for (lc = 0; TEST_LOOPING(lc); ++lc) {
 		tst_count = 0;
 		for (testno = 0; testno < TST_TOTAL; ++testno) {
-			if ((tst_kvercmp(3, 17, 0) < 0)
-			    && (tdat[testno].flags & MSG_ERRQUEUE)
-			    && (tdat[testno].type & SOCK_STREAM)) {
-				tst_resm(TCONF, "skip MSG_ERRQUEUE test, "
-						"it's supported from 3.17");
-				continue;
-			}
-
 			tdat[testno].setup();
 			TEST(recvfrom(s, tdat[testno].buf, tdat[testno].buflen,
 				      tdat[testno].flags, tdat[testno].from,
diff --git a/testcases/kernel/syscalls/recvmmsg/recvmmsg01.c b/testcases/kernel/syscalls/recvmmsg/recvmmsg01.c
index fb21ea1e7..146062089 100644
--- a/testcases/kernel/syscalls/recvmmsg/recvmmsg01.c
+++ b/testcases/kernel/syscalls/recvmmsg/recvmmsg01.c
@@ -47,7 +47,7 @@ static struct test_case tcase[] = {
 		.desc = "bad message vector address",
 		.fd = &receive_sockfd,
 		.exp_errno = EFAULT,
-		.msg_vec = (void*)&bad_addr,
+		.msg_vec = (void *)&bad_addr,
 	},
 	{
 		.desc = "negative seconds in timeout",
@@ -74,23 +74,54 @@ static struct test_case tcase[] = {
 	}
 };
 
-static void do_test(unsigned int i)
+static void verify_recvmmsg(unsigned int i, void *timeout)
 {
 	struct time64_variants *tv = &variants[tst_variant];
 	struct test_case *tc = &tcase[i];
-	void *timeout;
 
 	ts.type = tv->ts_type;
 	tst_ts_set_sec(&ts, tc->tv_sec);
 	tst_ts_set_nsec(&ts, tc->tv_nsec);
 
+	TST_EXP_FAIL2(tv->recvmmsg(*tc->fd, *tc->msg_vec, VLEN, 0, timeout),
+		      tc->exp_errno, "recvmmsg() %s", tc->desc);
+}
+
+static void test_bad_addr(unsigned int i)
+{
+	struct time64_variants *tv = &variants[tst_variant];
+	void *timeout = bad_addr;
+	pid_t pid;
+	int status;
+
+	pid = SAFE_FORK();
+	if (!pid) {
+		verify_recvmmsg(i, timeout);
+		exit(0);
+	}
+
+	SAFE_WAITPID(pid, &status, 0);
+
+	if (WIFEXITED(status) && !WEXITSTATUS(status))
+		return;
+
+	if (tv->ts_type == TST_LIBC_TIMESPEC &&
+		WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
+		tst_res(TPASS, "Child killed by expected signal");
+		return;
+	}
+
+	tst_res(TFAIL, "Child %s", tst_strstatus(status));
+}
+
+static void do_test(unsigned int i)
+{
+	struct test_case *tc = &tcase[i];
+
 	if (tc->bad_ts_addr)
-		timeout = bad_addr;
+		test_bad_addr(i);
 	else
-		timeout = tst_ts_get(&ts);
-
-	TST_EXP_FAIL2(tv->recvmmsg(*tc->fd, *tc->msg_vec, VLEN, 0, timeout),
-	             tc->exp_errno, "recvmmsg() %s", tc->desc);
+		verify_recvmmsg(i, tst_ts_get(&ts));
 }
 
 static void setup(void)
@@ -139,6 +170,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.test_variants = ARRAY_SIZE(variants),
+	.forks_child = 1,
 	.bufs = (struct tst_buffers []) {
 		{&iov, .iov_sizes = (int[]){1, -1}},
 		{&msg, .size = VLEN * sizeof(*msg)},
diff --git a/testcases/kernel/syscalls/recvmsg/recvmsg01.c b/testcases/kernel/syscalls/recvmsg/recvmsg01.c
index 80c1b3aa9..a265bc3bd 100644
--- a/testcases/kernel/syscalls/recvmsg/recvmsg01.c
+++ b/testcases/kernel/syscalls/recvmsg/recvmsg01.c
@@ -220,13 +220,6 @@ static void run(unsigned int n)
 	struct tcase *tc = &tcases[n];
 	int ret = tc->exp_errno ? -1 : 0;
 
-	if ((tst_kvercmp(3, 17, 0) < 0)
-			&& (tc->flags & MSG_ERRQUEUE)
-			&& (tc->type & SOCK_STREAM)) {
-		tst_res(TCONF, "MSG_ERRQUEUE requires kernel >= 3.17");
-		return;
-	}
-
 	setup_all();
 	tc->setup(n);
 
diff --git a/testcases/kernel/syscalls/rename/.gitignore b/testcases/kernel/syscalls/rename/.gitignore
index f95cf7d21..d17b80f09 100644
--- a/testcases/kernel/syscalls/rename/.gitignore
+++ b/testcases/kernel/syscalls/rename/.gitignore
@@ -11,3 +11,4 @@
 /rename12
 /rename13
 /rename14
+/rename15
diff --git a/testcases/kernel/syscalls/rename/rename09.c b/testcases/kernel/syscalls/rename/rename09.c
index 368a436c2..927b36f27 100644
--- a/testcases/kernel/syscalls/rename/rename09.c
+++ b/testcases/kernel/syscalls/rename/rename09.c
@@ -27,14 +27,12 @@
 #define PERMS    0700
 
 static uid_t orig_uid, test_users[2];
-static char *tmpdir;
 
 static void setup(void)
 {
 	umask(0);
 	orig_uid = getuid();
 	tst_get_uids(test_users, 0, 2);
-	tmpdir = tst_get_tmpdir();
 }
 
 static void run(void)
@@ -54,18 +52,12 @@ static void run(void)
 
 	/* Cleanup between loops */
 	SAFE_SETEUID(orig_uid);
-	tst_purge_dir(tmpdir);
-}
-
-static void cleanup(void)
-{
-	free(tmpdir);
+	tst_purge_dir(tst_tmpdir_path());
 }
 
 static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
-	.cleanup = cleanup,
 	.needs_root = 1,
 	.needs_tmpdir = 1,
 };
diff --git a/testcases/kernel/syscalls/rename/rename15.c b/testcases/kernel/syscalls/rename/rename15.c
new file mode 100644
index 000000000..d08b1e67f
--- /dev/null
+++ b/testcases/kernel/syscalls/rename/rename15.c
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ *    Authors: David Fenner, Jon Hendrickson
+ * Copyright (C) 2024 Andrea Cervesato andrea.cervesato@suse.com
+ */
+
+/*\
+ * [Description]
+ *
+ * This test suite validates the behavior of the `rename()` system call on
+ * symbolic links under three scenarios:
+ *
+ * - rename a symlink pointing to an existing file and verifies that the
+ *   symlink's inode and device number remain unchanged.
+ *
+ * - rename a symlink pointing to a non-existent path, ensuring that the
+ *   original symlink remains unaffected.
+ *
+ * - rename a symlink pointing to a created file, confirming that the new
+ *   symlink points to the correct file.
+ */
+
+#include "tst_test.h"
+#include "tst_tmpdir.h"
+
+#define MNTPOINT "mnt"
+#define OLDNAME MNTPOINT"/msymlink0"
+#define NEWNAME MNTPOINT"/asymlink0"
+#define OBJNAME MNTPOINT"/object"
+
+static char *tmpdir;
+static char *oldname;
+static char *newname;
+static char *objname;
+
+static void test_existing(void)
+{
+	tst_res(TINFO, "Test rename() on symlink pointing to an existent path");
+
+	struct stat buff_stat;
+	struct stat oldsym_stat;
+	struct stat newsym_stat;
+
+	SAFE_SYMLINK(tmpdir, oldname);
+	SAFE_STAT(oldname, &oldsym_stat);
+
+	SAFE_RENAME(oldname, newname);
+
+	TST_EXP_PASS(lstat(newname, &buff_stat));
+	TST_EXP_FAIL(lstat(oldname, &buff_stat), ENOENT);
+
+	SAFE_STAT(newname, &newsym_stat);
+	TST_EXP_EQ_LI(oldsym_stat.st_ino, newsym_stat.st_ino);
+	TST_EXP_EQ_LI(oldsym_stat.st_dev, newsym_stat.st_dev);
+
+	SAFE_UNLINK(newname);
+}
+
+static void test_non_existing(void)
+{
+	tst_res(TINFO, "Test rename() on symlink pointing to a non-existent path");
+
+	struct stat path_stat;
+
+	SAFE_SYMLINK("this_path_doesnt_exist", oldname);
+	TST_EXP_FAIL(stat(oldname, &path_stat), ENOENT);
+	TST_EXP_PASS(lstat(oldname, &path_stat));
+
+	SAFE_RENAME(oldname, newname);
+
+	TST_EXP_FAIL(lstat(oldname, &path_stat), ENOENT);
+	TST_EXP_PASS(lstat(newname, &path_stat));
+	TST_EXP_FAIL(stat(newname, &path_stat), ENOENT);
+
+	SAFE_UNLINK(newname);
+}
+
+static void test_creat(void)
+{
+	tst_res(TINFO, "Test rename() on symlink pointing to a path created lately");
+
+	struct stat path_stat;
+
+	SAFE_SYMLINK(objname, oldname);
+	TST_EXP_FAIL(stat(oldname, &path_stat), ENOENT);
+	TST_EXP_PASS(lstat(oldname, &path_stat));
+
+	tst_res(TINFO, "Create object file");
+
+	int fd;
+
+	fd = SAFE_CREAT(objname, 0700);
+	if (fd >= 0)
+		SAFE_CLOSE(fd);
+
+	SAFE_RENAME(oldname, newname);
+
+	TST_EXP_PASS(lstat(newname, &path_stat));
+	TST_EXP_PASS(stat(newname, &path_stat));
+
+	TST_EXP_FAIL(lstat(oldname, &path_stat), ENOENT);
+	TST_EXP_PASS(stat(objname, &path_stat));
+
+	SAFE_UNLINK(objname);
+	SAFE_UNLINK(newname);
+}
+
+static void run(void)
+{
+	test_existing();
+	test_creat();
+	test_non_existing();
+}
+
+static void setup(void)
+{
+	tmpdir = tst_tmpdir_path();
+	oldname = tst_tmpdir_genpath(OLDNAME);
+	newname = tst_tmpdir_genpath(NEWNAME);
+	objname = tst_tmpdir_genpath(OBJNAME);
+}
+
+static struct tst_test test = {
+	.setup = setup,
+	.test_all = run,
+	.all_filesystems = 1,
+	.mntpoint = MNTPOINT,
+	.format_device = 1,
+	.needs_root = 1,
+};
diff --git a/testcases/kernel/syscalls/renameat2/renameat201.c b/testcases/kernel/syscalls/renameat2/renameat201.c
index 9832b1cdb..23ed5758a 100644
--- a/testcases/kernel/syscalls/renameat2/renameat201.c
+++ b/testcases/kernel/syscalls/renameat2/renameat201.c
@@ -100,11 +100,6 @@ int main(int ac, char **av)
 
 static void setup(void)
 {
-	if ((tst_kvercmp(3, 15, 0)) < 0) {
-		tst_brkm(TCONF, NULL,
-			"This test can only run on kernels that are 3.15. and higher");
-	}
-
 	tst_tmpdir();
 
 	fs_type = tst_fs_type(cleanup, ".");
diff --git a/testcases/kernel/syscalls/renameat2/renameat202.c b/testcases/kernel/syscalls/renameat2/renameat202.c
index 0c1457022..88db04762 100644
--- a/testcases/kernel/syscalls/renameat2/renameat202.c
+++ b/testcases/kernel/syscalls/renameat2/renameat202.c
@@ -78,11 +78,6 @@ int main(int ac, char **av)
 
 static void setup(void)
 {
-	if ((tst_kvercmp(3, 15, 0)) < 0) {
-		tst_brkm(TCONF, NULL,
-			"This test can only run on kernels that are 3.15. and higher");
-	}
-
 	tst_tmpdir();
 
 	fs_type = tst_fs_type(cleanup, ".");
diff --git a/testcases/kernel/syscalls/request_key/.gitignore b/testcases/kernel/syscalls/request_key/.gitignore
index e8dc1c570..6dcf613c7 100644
--- a/testcases/kernel/syscalls/request_key/.gitignore
+++ b/testcases/kernel/syscalls/request_key/.gitignore
@@ -3,3 +3,4 @@
 /request_key03
 /request_key04
 /request_key05
+/request_key06
diff --git a/testcases/kernel/syscalls/request_key/request_key01.c b/testcases/kernel/syscalls/request_key/request_key01.c
index 251534efe..f349cd50d 100644
--- a/testcases/kernel/syscalls/request_key/request_key01.c
+++ b/testcases/kernel/syscalls/request_key/request_key01.c
@@ -2,23 +2,20 @@
 /*
  * Copyright (c) 2016 Fujitsu Ltd.
  * Copyright (c) 2017 Petr Vorel <pvorel@suse.cz>
- *
+ * Copyright (c) Linux Test Project, 2017-2024
  * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
  */
 
-/*
- * Test Name: request_key01
+/*\
+ * [Description]
+ *
+ * Test basic functionality of the request_key(2).
  *
- * Description:
- * The testcase checks basic functionality of the request_key(2).
  * request_key(2) asks the kernel to find a key which matches the
  * specified description. If successful, it attaches it to the
  * nominated keyring and returns its serial number.
- *
  */
 
-#include <errno.h>
-
 #include "tst_test.h"
 #include "lapi/keyctl.h"
 
@@ -27,11 +24,10 @@ static int key;
 static void verify_request_key(void)
 {
 
-	TEST(request_key("keyring", "ltp", NULL, KEY_REQKEY_DEFL_DEFAULT));
-	if (TST_RET == -1) {
-		tst_res(TFAIL | TTERRNO, "request_key() failed");
+	TST_EXP_POSITIVE(request_key("keyring", "ltp", NULL,
+					KEY_REQKEY_DEFL_DEFAULT));
+	if (!TST_PASS)
 		return;
-	}
 
 	if (TST_RET != key)
 		tst_res(TFAIL, "serial number mismatched");
diff --git a/testcases/kernel/syscalls/request_key/request_key02.c b/testcases/kernel/syscalls/request_key/request_key02.c
index 89a78142e..48bb978dd 100644
--- a/testcases/kernel/syscalls/request_key/request_key02.c
+++ b/testcases/kernel/syscalls/request_key/request_key02.c
@@ -2,22 +2,19 @@
 /*
  * Copyright (c) 2016 Fujitsu Ltd.
  * Copyright (c) 2017 Petr Vorel <pvorel@suse.cz>
- *
+ * Copyright (c) Linux Test Project, 2017-2024
  * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
  */
 
-/*
- * Test Name: request_key02
+/*\
+ * [Description]
  *
- * Description:
- * 1) request_key(2) fails if no matching key was found.
- * 2) request_key(2) fails if A revoked key was found.
- * 3) request_key(2) fails if An expired key was found.
+ * Basic request_key(2) failure checking. request_key(2) should return -1 and
+ * set expected errno:
  *
- * Expected Result:
- * 1) request_key(2) should return -1 and set errno to ENOKEY.
- * 2) request_key(2) should return -1 and set errno to EKEYREVOKED.
- * 3) request_key(2) should return -1 and set errno to EKEYEXPIRED.
+ * 1. ENOKEY (no matching key was found),
+ * 2. EKEYREVOKED (revoked key was found)
+ * 3. EKEYEXPIRED (expired key was found)
  */
 
 #include <errno.h>
@@ -43,19 +40,9 @@ static void verify_request_key(unsigned int n)
 {
 	struct test_case *tc = tcases + n;
 
-	TEST(request_key("keyring", tc->des, NULL, *tc->id));
-	if (TST_RET != -1) {
-		tst_res(TFAIL, "request_key() succeed unexpectly");
-		return;
-	}
-
-	if (TST_ERR == tc->exp_err) {
-		tst_res(TPASS | TTERRNO, "request_key() failed expectly");
-		return;
-	}
-
-	tst_res(TFAIL | TTERRNO, "request_key() failed unexpectly, "
-		"expected %s", tst_strerrno(tc->exp_err));
+	TST_EXP_FAIL2(request_key("keyring", tc->des, NULL, *tc->id),
+		      tc->exp_err, "request_key(\"keyring\", %s, NULL, %d)",
+		      tc->des, *tc->id);
 }
 
 static int init_key(char *name, int cmd)
@@ -68,9 +55,8 @@ static int init_key(char *name, int cmd)
 		tst_brk(TBROK | TERRNO, "add_key() failed");
 
 	if (cmd == KEYCTL_REVOKE) {
-		if (keyctl(cmd, n) == -1) {
+		if (keyctl(cmd, n) == -1)
 			tst_brk(TBROK | TERRNO,	"failed to revoke a key");
-		}
 	}
 
 	if (cmd == KEYCTL_SET_TIMEOUT) {
diff --git a/testcases/kernel/syscalls/request_key/request_key03.c b/testcases/kernel/syscalls/request_key/request_key03.c
index 464fcd8a4..3837993ef 100644
--- a/testcases/kernel/syscalls/request_key/request_key03.c
+++ b/testcases/kernel/syscalls/request_key/request_key03.c
@@ -1,15 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2017 Google, Inc.
+ * Copyright (c) Linux Test Project, 2018-2024
  */
 
-/*
+/*\
+ * [Description]
+ *
  * Regression test for two related bugs:
  *
- * (1) CVE-2017-15299, fixed by commit 60ff5b2f547a ("KEYS: don't let add_key()
- *     update an uninstantiated key")
- * (2) CVE-2017-15951, fixed by commit 363b02dab09b ("KEYS: Fix race between
- *     updating and finding a negative key")
+ * 1. CVE-2017-15299, fixed by commit 60ff5b2f547a ("KEYS: don't let add_key()
+ *    update an uninstantiated key")
+ * 2. CVE-2017-15951, fixed by commit 363b02dab09b ("KEYS: Fix race between
+ *    updating and finding a negative key")
  *
  * We test for the bugs together because the reproduction steps are essentially
  * the same: repeatedly try to add/update a key with add_key() while requesting
@@ -212,7 +215,7 @@ static struct tst_test test = {
 	.test = do_test,
 	.tcnt = ARRAY_SIZE(testcase_list),
 	.forks_child = 1,
-	.max_runtime = 20,
+	.runtime = 20,
 	.options = (struct tst_option[]) {
 		{"b:", &opt_bug,  "Bug to test for (cve-2017-15299 or cve-2017-15951; default is both)"},
 		{}
diff --git a/testcases/kernel/syscalls/request_key/request_key04.c b/testcases/kernel/syscalls/request_key/request_key04.c
index c125f4261..4a454731a 100644
--- a/testcases/kernel/syscalls/request_key/request_key04.c
+++ b/testcases/kernel/syscalls/request_key/request_key04.c
@@ -1,9 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2018 Google, Inc.
+ * Copyright (c) Linux Test Project, 2018-2024
  */
 
-/*
+/*\
+ * [Description]
+ *
  * Regression test for commit 4dca6ea1d943 ("KEYS: add missing permission check
  * for request_key() destination"), or CVE-2017-17807.  This bug allowed adding
  * a key to a keyring given only Search permission to that keyring, rather than
diff --git a/testcases/kernel/syscalls/request_key/request_key05.c b/testcases/kernel/syscalls/request_key/request_key05.c
index a17d1d058..35f326f50 100644
--- a/testcases/kernel/syscalls/request_key/request_key05.c
+++ b/testcases/kernel/syscalls/request_key/request_key05.c
@@ -1,9 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2017 Richard Palethorpe <rpalethorpe@suse.com>
+ * Copyright (c) Linux Test Project, 2018-2024
  */
-/*
- * Test for CVE-2017-6951, original reproducer can be found here:
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-6951, original reproducer:
  * http://www.spinics.net/lists/keyrings/msg01845.html
  *
  * request_key() is not in glibc, so we just use the syscall directly instead
diff --git a/testcases/kernel/syscalls/request_key/request_key06.c b/testcases/kernel/syscalls/request_key/request_key06.c
new file mode 100644
index 000000000..bd872867b
--- /dev/null
+++ b/testcases/kernel/syscalls/request_key/request_key06.c
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
+ * Author: Ma Xinjian <maxj.fnst@fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that request_key(2) fails with
+ *
+ * - EFAULT when type points outside the process's accessible address space
+ * - EFAULT when description points outside the process's accessible address space
+ * - EFAULT when callout_info points outside the process's accessible address space
+ * - EPERM when type argument started with a period '.'
+ */
+
+#include "tst_test.h"
+#include "lapi/keyctl.h"
+
+static struct test_case_t {
+	char *type;
+	char *description;
+	char *callout_info;
+	key_serial_t dest_keyring;
+	int expected_errno;
+	char *desc;
+} tcases[] = {
+	{(char *)(-1), "description", NULL, KEY_SPEC_PROCESS_KEYRING, EFAULT,
+		"type points outside the process's accessible address space"},
+	{"type", (char *)(-1), NULL, KEY_SPEC_PROCESS_KEYRING, EFAULT,
+		"description points outside the process's accessible address space"},
+	{"type", "description", (char *)(-1), KEY_SPEC_PROCESS_KEYRING, EFAULT,
+		"callout_info points outside the process's accessible address space"},
+	{".type", "description", NULL, KEY_SPEC_PROCESS_KEYRING, EPERM,
+		"type argument started with a period '.'"},
+};
+
+static void verify_request_key(unsigned int i)
+{
+	struct test_case_t *tc = &tcases[i];
+
+	TST_EXP_FAIL2(request_key(tc->type, tc->description, tc->callout_info,
+		tc->dest_keyring),
+		tc->expected_errno,
+		"%s", tc->desc);
+}
+
+static struct tst_test test = {
+	.tcnt = ARRAY_SIZE(tcases),
+	.test = verify_request_key,
+};
diff --git a/testcases/kernel/syscalls/rmdir/rmdir02.c b/testcases/kernel/syscalls/rmdir/rmdir02.c
index cb0aec857..b545e9cd2 100644
--- a/testcases/kernel/syscalls/rmdir/rmdir02.c
+++ b/testcases/kernel/syscalls/rmdir/rmdir02.c
@@ -2,17 +2,21 @@
 /* Copyright (c) International Business Machines Corp., 2001
  * Ported to LTP: Wayne Boyer
  */
-/*
- * Description:
- *   1) attempt to rmdir() non-empty directory -> ENOTEMPTY
- *   2) attempt to rmdir() directory with long path name -> ENAMETOOLONG
- *   3) attempt to rmdir() non-existing directory -> ENOENT
- *   4) attempt to rmdir() a file -> ENOTDIR
- *   5) attempt to rmdir() invalid pointer -> EFAULT
- *   6) attempt to rmdir() symlink loop -> ELOOP
- *   7) attempt to rmdir() dir on RO mounted FS -> EROFS
- *   8) attempt to rmdir() mount point -> EBUSY
- *   9) attempt to rmdir() current directory "." -> EINVAL
+
+/*\
+ * [Description]
+ *
+ * Verify that, rmdir(2) returns -1 and sets errno to
+ *
+ * 1. ENOTEMPTY when removing a non-empty directory
+ * 2. ENAMETOOLONG when removing a directory with long path name
+ * 3. ENOENT when removing a non-existing directory
+ * 4. ENOTDIR when removing a a file
+ * 5. EFAULT when removing a invalid pointer
+ * 6. ELOOP when removing a symlink loop
+ * 7. EROFS when removing a dir on RO mounted FS
+ * 8. EBUSY when removing a mount point
+ * 9. EINVAL when removing "." (current directory)
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/rt_sigqueueinfo/.gitignore b/testcases/kernel/syscalls/rt_sigqueueinfo/.gitignore
index 37cd20621..a26811b08 100644
--- a/testcases/kernel/syscalls/rt_sigqueueinfo/.gitignore
+++ b/testcases/kernel/syscalls/rt_sigqueueinfo/.gitignore
@@ -1 +1,2 @@
 /rt_sigqueueinfo01
+/rt_sigqueueinfo02
diff --git a/testcases/kernel/syscalls/rt_sigqueueinfo/rt_sigqueueinfo02.c b/testcases/kernel/syscalls/rt_sigqueueinfo/rt_sigqueueinfo02.c
new file mode 100644
index 000000000..ab30c2abd
--- /dev/null
+++ b/testcases/kernel/syscalls/rt_sigqueueinfo/rt_sigqueueinfo02.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
+ * Author: Ma Xinjian <maxj.fnst@fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that, rt_sigqueueinfo(2) sets errno to
+ *
+ * - EINVAL if sig is invalid
+ * - EPERM if uinfo->si_code is invalid
+ * - ESRCH if no thread group matching tgid is found
+ */
+
+#include <pwd.h>
+#include <signal.h>
+#include "config.h"
+#include "tst_test.h"
+
+#ifdef HAVE_STRUCT_SIGACTION_SA_SIGACTION
+#include "rt_sigqueueinfo.h"
+
+static siginfo_t siginfo_einval;
+static siginfo_t siginfo_eperm;
+static siginfo_t siginfo_esrch;
+
+static pid_t tgid_notfound = -1;
+
+static struct test_case_t {
+	pid_t *tgid;
+	int sig;
+	siginfo_t *uinfo;
+	int expected_errno;
+	char *desc;
+} tcases[] = {
+	{NULL, -1, &siginfo_einval, EINVAL, "sig is invalid"},
+	{NULL, SIGUSR1, &siginfo_eperm, EPERM, "uinfo->si_code is invalid"},
+	{&tgid_notfound, SIGUSR1, &siginfo_esrch, ESRCH,
+		"no thread group matching tgid is found"},
+};
+
+static void setup(void)
+{
+	siginfo_einval.si_code = SI_QUEUE;
+	siginfo_eperm.si_code = 0;
+	siginfo_esrch.si_code = SI_QUEUE;
+}
+
+static void parent_do(struct test_case_t *tc, pid_t pid)
+{
+	pid_t real_pid;
+
+	if (tc->tgid)
+		real_pid = *(tc->tgid);
+	else
+		real_pid = pid;
+
+	TST_EXP_FAIL(sys_rt_sigqueueinfo(real_pid, tc->sig, tc->uinfo),
+		tc->expected_errno, "%s", tc->desc);
+	TST_CHECKPOINT_WAKE(0);
+}
+
+static void child_do(void)
+{
+	TST_CHECKPOINT_WAIT(0);
+}
+
+static void verify_rt_sigqueueinfo(unsigned int i)
+{
+	struct test_case_t *tc = &tcases[i];
+	pid_t pid = SAFE_FORK();
+
+	if (!pid) {
+		child_do();
+		exit(0);
+	}
+	parent_do(tc, pid);
+	SAFE_WAITPID(pid, NULL, 0);
+}
+
+static struct tst_test test = {
+	.setup = setup,
+	.tcnt = ARRAY_SIZE(tcases),
+	.test = verify_rt_sigqueueinfo,
+	.forks_child = 1,
+	.needs_checkpoints = 1,
+	.bufs = (struct tst_buffers []) {
+		{&siginfo_einval, .size = sizeof(siginfo_einval)},
+		{&siginfo_eperm, .size = sizeof(siginfo_eperm)},
+		{&siginfo_esrch, .size = sizeof(siginfo_esrch)},
+		{},
+	}
+};
+
+#else
+	TST_TEST_TCONF("This system does not support rt_sigqueueinfo()");
+#endif /* HAVE_STRUCT_SIGACTION_SA_SIGACTION */
diff --git a/testcases/kernel/syscalls/rt_sigtimedwait/Makefile b/testcases/kernel/syscalls/rt_sigtimedwait/Makefile
index 1ae50b32c..f96d5dc3a 100644
--- a/testcases/kernel/syscalls/rt_sigtimedwait/Makefile
+++ b/testcases/kernel/syscalls/rt_sigtimedwait/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir ?= ../../../..
 
-LTPLIBS = ltpsigwait
+LTPLIBS = sigwait
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/rt_tgsigqueueinfo/rt_tgsigqueueinfo01.c b/testcases/kernel/syscalls/rt_tgsigqueueinfo/rt_tgsigqueueinfo01.c
index bee6a6271..9e45f35f7 100644
--- a/testcases/kernel/syscalls/rt_tgsigqueueinfo/rt_tgsigqueueinfo01.c
+++ b/testcases/kernel/syscalls/rt_tgsigqueueinfo/rt_tgsigqueueinfo01.c
@@ -1,17 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2019 Linaro Limited. All rights reserved.
+ * Copyright (c) Linux Test Project, 2019-2024
  * Author: Sumit Garg <sumit.garg@linaro.org>
  */
 
-/*
- * Test rt_tgsigqueueinfo
- *
- * This tests the rt_tgsigqueueinfo() syscall. It sends the signal and data
+/*\
+ * Basic test for rt_tgsigqueueinfo(2) syscall. It sends the signal and data
  * to the single thread specified by the combination of tgid, a thread group
  * ID, and tid, a thread in that thread group.
  *
  * Also this implement 3 tests differing on the basis of signal sender:
+ *
  * - Sender and receiver is the same thread.
  * - Sender is parent of the thread.
  * - Sender is different thread.
@@ -25,12 +25,6 @@
 #include "tst_test.h"
 #include "lapi/syscalls.h"
 
-#ifndef __ANDROID__
-#define SI_SIGVAL si_sigval
-#else
-#define SI_SIGVAL _sigval
-#endif
-
 static char sigval_send[] = "rt_tgsigqueueinfo data";
 static volatile int signum_rcv;
 static char *sigval_rcv;
@@ -39,7 +33,7 @@ static void sigusr1_handler(int signum, siginfo_t *uinfo,
 			    void *p LTP_ATTRIBUTE_UNUSED)
 {
 	signum_rcv = signum;
-	sigval_rcv = uinfo->_sifields._rt.SI_SIGVAL.sival_ptr;
+	sigval_rcv = uinfo->si_ptr;
 }
 
 void *send_rcv_func(void *arg)
@@ -51,7 +45,7 @@ void *send_rcv_func(void *arg)
 
 	uinfo.si_errno = 0;
 	uinfo.si_code = SI_QUEUE;
-	uinfo._sifields._rt.SI_SIGVAL.sival_ptr = sigval_send;
+	uinfo.si_ptr = sigval_send;
 
 	TEST(tst_syscall(__NR_rt_tgsigqueueinfo, getpid(),
 			 syscall(__NR_gettid), SIGUSR1, &uinfo));
@@ -113,7 +107,7 @@ static void verify_signal_parent_thread(void)
 
 	uinfo.si_errno = 0;
 	uinfo.si_code = SI_QUEUE;
-	uinfo._sifields._rt.SI_SIGVAL.sival_ptr = sigval_send;
+	uinfo.si_ptr = sigval_send;
 
 	TEST(tst_syscall(__NR_rt_tgsigqueueinfo, getpid(),
 			 tid, SIGUSR1, &uinfo));
@@ -130,7 +124,7 @@ void *sender_func(void *arg)
 
 	uinfo.si_errno = 0;
 	uinfo.si_code = SI_QUEUE;
-	uinfo._sifields._rt.SI_SIGVAL.sival_ptr = sigval_send;
+	uinfo.si_ptr = sigval_send;
 
 	TEST(tst_syscall(__NR_rt_tgsigqueueinfo, getpid(),
 			 *tid, SIGUSR1, &uinfo));
diff --git a/testcases/kernel/syscalls/sbrk/sbrk01.c b/testcases/kernel/syscalls/sbrk/sbrk01.c
index bb78d9a7b..39e92094b 100644
--- a/testcases/kernel/syscalls/sbrk/sbrk01.c
+++ b/testcases/kernel/syscalls/sbrk/sbrk01.c
@@ -26,12 +26,8 @@ static void run(unsigned int i)
 {
 	struct tcase *tc = &tcases[i];
 
-	TESTPTR(sbrk(tc->increment));
-
-	if (TST_RET_PTR == (void *) -1)
-		tst_res(TFAIL | TTERRNO, "sbrk(%ld) failed", tc->increment);
-	else
-		tst_res(TPASS, "sbrk(%ld) returned %p", tc->increment, TST_RET_PTR);
+	TST_EXP_PASS_PTR_VOID(sbrk(tc->increment),
+		"sbrk(%ld) returned %p", tc->increment, TST_RET_PTR);
 }
 
 static struct tst_test test = {
diff --git a/testcases/kernel/syscalls/sbrk/sbrk02.c b/testcases/kernel/syscalls/sbrk/sbrk02.c
index dc344577e..08cbdf367 100644
--- a/testcases/kernel/syscalls/sbrk/sbrk02.c
+++ b/testcases/kernel/syscalls/sbrk/sbrk02.c
@@ -19,21 +19,8 @@ static long increment = INC;
 
 static void run(void)
 {
-	TESTPTR(sbrk(increment));
-
-	if (TST_RET_PTR != (void *)-1) {
-		tst_res(TFAIL, "sbrk(%ld) unexpectedly passed and returned %p, "
-						"expected (void *)-1 with errno=%d",
-						increment, TST_RET_PTR, ENOMEM);
-		return;
-	}
-
-	if (TST_ERR == ENOMEM)
-		tst_res(TPASS | TTERRNO, "sbrk(%ld) failed as expected", increment);
-	else
-		tst_res(TFAIL | TTERRNO, "sbrk(%ld) failed but unexpected errno, "
-								"expected errno=%d - %s",
-								increment, ENOMEM, strerror(ENOMEM));
+	TST_EXP_FAIL_PTR_VOID(sbrk(increment), ENOMEM,
+		"sbrk(%ld) returned %p", increment, TST_RET_PTR);
 }
 
 static void setup(void)
diff --git a/testcases/kernel/syscalls/sbrk/sbrk03.c b/testcases/kernel/syscalls/sbrk/sbrk03.c
index 875815629..00536c757 100644
--- a/testcases/kernel/syscalls/sbrk/sbrk03.c
+++ b/testcases/kernel/syscalls/sbrk/sbrk03.c
@@ -1,14 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (c) 2016 Linux Test Project.
+ * Copyright (c) Linux Test Project, 2016-2024
  */
 
-/*
- * DESCRIPTION
+/*\
+ * [Description]
  *
  * Total s390 2^31 addr space is 0x80000000.
  *
- *     0x80000000 - 0x10000000 = 0x70000000
+ * 0x80000000 - 0x10000000 = 0x70000000
  *
  * 0x70000000 is a valid positive intptr_t and adding it to the current offset
  * produces a valid uintptr_t without overflow (since the MSB being set is OK),
@@ -24,12 +24,10 @@
  * in glibc, but it should be the kernel since one could call the syscall
  * directly without using the glibc entry points.
  *
- * The kernel part was fixed on v3.15 by commits:
- *     473a06572fcd (s390/compat: convert system call wrappers to C part 02)
- *
- * Note:
- *     The reproducer should be built(gcc -m31) in 32bit on s390 platform
+ * The kernel part was fixed on v3.15 by commit:
+ * 473a06572fcd ("s390/compat: convert system call wrappers to C part 02")
  *
+ * NOTE: The reproducer should be built in 32bit (gcc -m31) on s390 platform.
  */
 
 #include <stdio.h>
diff --git a/testcases/kernel/syscalls/sched_getattr/sched_getattr01.c b/testcases/kernel/syscalls/sched_getattr/sched_getattr01.c
index c1715d8ac..2e06d1809 100644
--- a/testcases/kernel/syscalls/sched_getattr/sched_getattr01.c
+++ b/testcases/kernel/syscalls/sched_getattr/sched_getattr01.c
@@ -96,9 +96,6 @@ int main(int argc, char **argv)
 
 	tst_require_root();
 
-	if ((tst_kvercmp(3, 14, 0)) < 0)
-		tst_brkm(TCONF, NULL, "EDF needs kernel 3.14 or higher");
-
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 		pthread_create(&thread, NULL, run_deadline, NULL);
 		pthread_join(thread, NULL);
diff --git a/testcases/kernel/syscalls/sched_getattr/sched_getattr02.c b/testcases/kernel/syscalls/sched_getattr/sched_getattr02.c
index 9f4a09f88..4b99cdb66 100644
--- a/testcases/kernel/syscalls/sched_getattr/sched_getattr02.c
+++ b/testcases/kernel/syscalls/sched_getattr/sched_getattr02.c
@@ -1,108 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) Huawei Technologies Co., Ltd., 2015
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
- * the GNU General Public License for more details.
+ * Copyright (c) Linux Test Project, 2015-2024
  */
 
- /* Description:
- *   Verify that:
- *              1) sched_getattr fails with unused pid
- *              2) sched_getattr fails with invalid address
- *              3) sched_getattr fails with invalid value
- *              4) sched_getattr fails with invalid flag
+/*\
+ * [Description]
+ *
+ * Verify that, sched_getattr(2) returns -1 and sets errno to:
+ *
+ * 1. ESRCH if pid is unused.
+ * 2. EINVAL if address is NULL.
+ * 3. EINVAL if size is invalid.
+ * 4. EINVAL if flag is not zero.
  */
 
 #define _GNU_SOURCE
 
-#include <unistd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <linux/unistd.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <sys/syscall.h>
-#include <pthread.h>
 #include <errno.h>
-
-#include "test.h"
+#include "tst_test.h"
 #include "lapi/sched.h"
 
-char *TCID = "sched_getattr02";
-
 static pid_t pid;
 static pid_t unused_pid;
-struct sched_attr attr_copy;
+static struct sched_attr attr_copy;
 
 static struct test_case {
 	pid_t *pid;
-	struct sched_attr *a;
+	struct sched_attr *attr;
 	unsigned int size;
 	unsigned int flags;
 	int exp_errno;
-} test_cases[] = {
+} tcase[] = {
 	{&unused_pid, &attr_copy, sizeof(struct sched_attr), 0, ESRCH},
 	{&pid, NULL, sizeof(struct sched_attr), 0, EINVAL},
-	{&pid, &attr_copy, sizeof(struct sched_attr) - 1, 0, EINVAL},
+	{&pid, &attr_copy, SCHED_ATTR_SIZE_VER0 - 1, 0, EINVAL},
 	{&pid, &attr_copy, sizeof(struct sched_attr), 1000, EINVAL}
 };
 
-static void setup(void);
-static void sched_getattr_verify(const struct test_case *test);
-
-int TST_TOTAL = ARRAY_SIZE(test_cases);
-
-static void sched_getattr_verify(const struct test_case *test)
+static void verify_sched_getattr(unsigned int n)
 {
-	TEST(sched_getattr(*(test->pid), test->a, test->size,
-			test->flags));
-
-	if (TEST_RETURN != -1) {
-		tst_resm(TFAIL, "sched_getattr() succeeded unexpectedly.");
-		return;
-	}
-
-	if (TEST_ERRNO == test->exp_errno) {
-		tst_resm(TPASS | TTERRNO,
-			"sched_getattr() failed expectedly");
-		return;
-	}
+	struct test_case *tc = &tcase[n];
 
-	tst_resm(TFAIL | TTERRNO, "sched_getattr() failed unexpectedly "
-		": expected: %d - %s",
-		test->exp_errno, tst_strerrno(test->exp_errno));
+	TST_EXP_FAIL(sched_getattr(*(tc->pid), tc->attr, tc->size, tc->flags),
+				 tc->exp_errno, "sched_getattr(%d, ..., %d, %d)", *tc->pid,
+				 tc->size, tc->flags);
 }
 
-int main(int argc, char **argv)
+static void setup(void)
 {
-	int lc, i;
-
-	tst_parse_opts(argc, argv, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		for (i = 0; i < TST_TOTAL; i++)
-			sched_getattr_verify(&test_cases[i]);
-	}
-
-	tst_exit();
+	unused_pid = tst_get_unused_pid();
 }
 
-void setup(void)
-{
-	unused_pid = tst_get_unused_pid(setup);
-
-	if ((tst_kvercmp(3, 14, 0)) < 0)
-		tst_brkm(TCONF, NULL, "EDF needs kernel 3.14 or higher");
-
-	TEST_PAUSE;
-}
+static struct tst_test test = {
+	.needs_tmpdir = 1,
+	.test = verify_sched_getattr,
+	.tcnt = ARRAY_SIZE(tcase),
+	.setup = setup,
+};
diff --git a/testcases/kernel/syscalls/sched_setaffinity/sched_setaffinity01.c b/testcases/kernel/syscalls/sched_setaffinity/sched_setaffinity01.c
index a56ae1f50..acd9b77be 100644
--- a/testcases/kernel/syscalls/sched_setaffinity/sched_setaffinity01.c
+++ b/testcases/kernel/syscalls/sched_setaffinity/sched_setaffinity01.c
@@ -6,13 +6,15 @@
  * Author: Stanislav Kholmanskikh <stanislav.kholmanskikh@oracle.com>
  */
 
-/*
- * Description:
+/*\
+ * [Description]
+ *
  * Check various errnos for sched_setaffinity():
- * 1) EFAULT, if the supplied memory address is invalid.
- * 2) EINVAL, if the mask doesn't contain at least one permitted cpu.
- * 3) ESRCH, if the process whose id is pid could not be found.
- * 4) EPERM, if the calling process doesn't have appropriate privileges.
+ *
+ * 1. EFAULT, if the supplied memory address is invalid.
+ * 2. EINVAL, if the mask doesn't contain at least one permitted cpu.
+ * 3. ESRCH, if the process whose id is pid could not be found.
+ * 4. EPERM, if the calling process doesn't have appropriate privileges.
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/sched_setattr/sched_setattr01.c b/testcases/kernel/syscalls/sched_setattr/sched_setattr01.c
index d5178e016..13380d177 100644
--- a/testcases/kernel/syscalls/sched_setattr/sched_setattr01.c
+++ b/testcases/kernel/syscalls/sched_setattr/sched_setattr01.c
@@ -130,8 +130,5 @@ void setup(void)
 
 	tst_require_root();
 
-	if ((tst_kvercmp(3, 14, 0)) < 0)
-		tst_brkm(TCONF, NULL, "EDF needs kernel 3.14 or higher");
-
 	TEST_PAUSE;
 }
diff --git a/testcases/kernel/syscalls/seccomp/.gitignore b/testcases/kernel/syscalls/seccomp/.gitignore
new file mode 100644
index 000000000..9196906cf
--- /dev/null
+++ b/testcases/kernel/syscalls/seccomp/.gitignore
@@ -0,0 +1 @@
+seccomp01
diff --git a/testcases/kernel/syscalls/seccomp/Makefile b/testcases/kernel/syscalls/seccomp/Makefile
new file mode 100644
index 000000000..8cf1b9024
--- /dev/null
+++ b/testcases/kernel/syscalls/seccomp/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/prctl/prctl04.c b/testcases/kernel/syscalls/seccomp/seccomp01.c
similarity index 72%
rename from testcases/kernel/syscalls/prctl/prctl04.c
rename to testcases/kernel/syscalls/seccomp/seccomp01.c
index 8b135d611..16abca78f 100644
--- a/testcases/kernel/syscalls/prctl/prctl04.c
+++ b/testcases/kernel/syscalls/seccomp/seccomp01.c
@@ -2,12 +2,14 @@
 /*
  * Copyright (c) 2019 FUJITSU LIMITED. All rights reserved.
  * Author: Yang Xu <xuyang2018.jy@cn.fujitsu.com>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
 /*\
  * [Description]
  *
- * Test PR_GET_SECCOMP and PR_SET_SECCOMP of prctl(2).
+ * Test PR_GET_SECCOMP and PR_SET_SECCOMP with both prctl(2) and seccomp(2).
+ * The second one is called via __NR_seccomp using tst_syscall().
  *
  * - If PR_SET_SECCOMP sets the SECCOMP_MODE_STRICT for the calling thread,
  *   the only system call that the thread is permitted to make are read(2),
@@ -27,7 +29,6 @@
 
 #include <errno.h>
 #include <signal.h>
-#include <sys/prctl.h>
 #include <sys/wait.h>
 #include <sys/types.h>
 #include <linux/filter.h>
@@ -35,6 +36,7 @@
 #include <stdlib.h>
 #include <stddef.h>
 #include "tst_test.h"
+#include "tst_kconfig.h"
 #include "lapi/syscalls.h"
 #include "lapi/prctl.h"
 #include "config.h"
@@ -62,11 +64,11 @@ static const struct sock_fprog  strict = {
 	.filter = (struct sock_filter *)strict_filter
 };
 
-static void check_strict_mode(int);
-static void check_filter_mode(int);
+static void check_strict_mode(int mode);
+static void check_filter_mode(int mode);
 
 static struct tcase {
-	void (*func_check)();
+	void (*func_check)(int mode);
 	int pass_flag;
 	int val;
 	int exp_signal;
@@ -94,8 +96,8 @@ static struct tcase {
 	"SECCOMP_MODE_FILTER doesn't permit exit()"}
 };
 
-
-static int mode_filter_not_supported;
+static int strict_not_supported;
+static int filter_not_supported;
 
 static void check_filter_mode_inherit(void)
 {
@@ -122,13 +124,20 @@ static void check_strict_mode(int val)
 	int fd;
 	char buf[2];
 
+	if (strict_not_supported)
+		return;
+
 	fd = SAFE_OPEN(FNAME, O_RDWR | O_CREAT, 0666);
 
-	TEST(prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT));
-	if (TST_RET == -1) {
-		tst_res(TFAIL | TTERRNO,
-			"prctl(PR_SET_SECCOMP) sets SECCOMP_MODE_STRICT failed");
-		return;
+	if (tst_variant == 1) {
+		TEST(tst_syscall(__NR_seccomp, SECCOMP_SET_MODE_STRICT, 0, NULL));
+		if (TST_RET == -1)
+			tst_brk(TBROK | TERRNO, "seccomp(SECCOMP_SET_MODE_STRICT) error");
+	} else {
+		TEST(prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT, 0, NULL));
+
+		if (TST_RET == -1)
+			tst_brk(TBROK | TERRNO, "prctl(SECCOMP_MODE_STRICT) error");
 	}
 
 	switch (val) {
@@ -158,18 +167,20 @@ static void check_filter_mode(int val)
 {
 	int fd;
 
-	if (mode_filter_not_supported == 1) {
-		tst_res(TCONF, "kernel doesn't support SECCOMP_MODE_FILTER");
+	if (filter_not_supported)
 		return;
-	}
 
 	fd = SAFE_OPEN(FNAME, O_RDWR | O_CREAT, 0666);
 
-	TEST(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &strict));
-	if (TST_RET == -1) {
-		tst_res(TFAIL | TERRNO,
-			"prctl(PR_SET_SECCOMP) sets SECCOMP_MODE_FILTER failed");
-		return;
+	if (tst_variant == 1) {
+		TEST(tst_syscall(__NR_seccomp, SECCOMP_SET_MODE_FILTER, 0, &strict));
+		if (TST_RET == -1)
+			tst_brk(TBROK | TERRNO, "seccomp(SECCOMP_SET_MODE_FILTER) error");
+	} else {
+		TEST(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &strict));
+
+		if (TST_RET == -1)
+			tst_brk(TBROK | TERRNO, "prctl(SECCOMP_MODE_FILTER) error");
 	}
 
 	switch (val) {
@@ -213,39 +224,43 @@ static void verify_prctl(unsigned int n)
 			return;
 		}
 
-		if (tc->pass_flag == 2 && mode_filter_not_supported == 0)
-			tst_res(TFAIL,
-				"SECCOMP_MODE_FILTER permits exit() unexpectedly");
+		if (tc->pass_flag == 2)
+			tst_res(TFAIL, "SECCOMP_MODE_FILTER permits exit() unexpectedly");
 	}
 }
 
 static void setup(void)
 {
-	TEST(prctl(PR_GET_SECCOMP));
-	if (TST_RET == 0) {
-		tst_res(TINFO, "kernel supports PR_GET/SET_SECCOMP");
+	static const char * const kconf_strict[] = {"CONFIG_SECCOMP=y", NULL};
+	static const char * const kconf_filter[] = {"CONFIG_SECCOMP_FILTER=y", NULL};
 
-		TEST(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, NULL));
-		if (TST_RET == -1 && TST_ERR == EINVAL) {
-			mode_filter_not_supported = 1;
-			return;
-		}
+	tst_res(TINFO, "Testing variant: %s",
+		tst_variant == 1 ? "seccomp()" : "pctrl(PR_SET_SECCOMP)");
 
-		tst_res(TINFO, "kernel supports SECCOMP_MODE_FILTER");
-		return;
+	if (tst_kconfig_check(kconf_strict)) {
+		tst_brk(TCONF, "kernel doesn't support SECCOMP_MODE_STRICT. "
+				"Skipping CONFIG_SECCOMP tests");
+
+		strict_not_supported = 1;
+	} else {
+		tst_res(TINFO, "kernel supports SECCOMP_MODE_STRICT");
 	}
 
-	if (TST_ERR == EINVAL)
-		tst_brk(TCONF, "kernel doesn't support PR_GET/SET_SECCOMP");
+	if (tst_kconfig_check(kconf_filter)) {
+		tst_brk(TCONF, "kernel doesn't support SECCOMP_MODE_FILTER. "
+				"Skipping CONFIG_SECCOMP_FILTER tests");
 
-	tst_brk(TBROK | TTERRNO,
-		"current environment doesn't permit PR_GET/SET_SECCOMP");
+		filter_not_supported = 1;
+	} else {
+		tst_res(TINFO, "kernel supports SECCOMP_MODE_FILTER");
+	}
 }
 
 static struct tst_test test = {
 	.setup = setup,
 	.test = verify_prctl,
 	.tcnt = ARRAY_SIZE(tcases),
+	.test_variants = 2,
 	.forks_child = 1,
 	.needs_tmpdir = 1,
 	.needs_root = 1,
diff --git a/testcases/kernel/syscalls/sendfile/sendfile09.c b/testcases/kernel/syscalls/sendfile/sendfile09.c
index 6cb3cd593..eeef44519 100644
--- a/testcases/kernel/syscalls/sendfile/sendfile09.c
+++ b/testcases/kernel/syscalls/sendfile/sendfile09.c
@@ -93,7 +93,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.test = run,
 	.tcnt = ARRAY_SIZE(tc),
-	.max_runtime = 120,
+	.timeout = 120,
 	.skip_in_compat = 1,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "5d73320a96fcc"},
diff --git a/testcases/kernel/syscalls/sendmsg/sendmsg03.c b/testcases/kernel/syscalls/sendmsg/sendmsg03.c
index 38459990f..2edccb8d9 100644
--- a/testcases/kernel/syscalls/sendmsg/sendmsg03.c
+++ b/testcases/kernel/syscalls/sendmsg/sendmsg03.c
@@ -1,20 +1,22 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2020 SUSE LLC <mdoucha@suse.cz>
+ */
+
+/*\
+ * [Description]
  *
  * CVE-2017-17712
  *
  * Test for race condition vulnerability in sendmsg() on SOCK_RAW sockets.
  * Changing the value of IP_HDRINCL socket option in parallel with sendmsg()
  * call may lead to uninitialized stack pointer usage, allowing arbitrary code
- * execution or privilege escalation. Fixed in:
+ * execution or privilege escalation.
  *
- *  commit 8f659a03a0ba9289b9aeb9b4470e6fb263d6f483
- *  Author: Mohamed Ghannam <simo.ghannam@gmail.com>
- *  Date:   Sun Dec 10 03:50:58 2017 +0000
- *
- *  net: ipv4: fix for a race condition in raw_sendmsg
+ * Fixed in 4.15
+ * 8f659a03a0ba ("net: ipv4: fix for a race condition in raw_sendmsg")
  */
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -103,7 +105,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 150,
+	.runtime = 150,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_USER_NS=y",
 		"CONFIG_NET_NS=y",
diff --git a/testcases/kernel/syscalls/sendto/sendto02.c b/testcases/kernel/syscalls/sendto/sendto02.c
index 743101733..a24a696dd 100644
--- a/testcases/kernel/syscalls/sendto/sendto02.c
+++ b/testcases/kernel/syscalls/sendto/sendto02.c
@@ -2,19 +2,18 @@
 /*
  * Copyright(c) 2016 Fujitsu Ltd.
  * Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
+ * Copyright (c) Linux Test Project, 2017-2019
  */
 
-/*
- * Test Name: sendto02
+/*\
+ * [Description]
  *
- * Description:
- * When sctp protocol is selected in socket(2) and buffer is invalid,
+ * When SCTP protocol created wih socket(2) and buffer is invalid,
  * sendto(2) should fail and set errno to EFAULT, but it sets errno
  * to ENOMEM.
  *
- * This is a regression test and has been fixed by kernel commit:
- * 6e51fe7572590d8d86e93b547fab6693d305fd0d (sctp: fix -ENOMEM result
- * with invalid user space pointer in sendto() syscall)
+ * This is a regression test fixed by kernel 3.7
+ * 6e51fe757259 (sctp: fix -ENOMEM result with invalid user space pointer in sendto() syscall)
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/sendto/sendto03.c b/testcases/kernel/syscalls/sendto/sendto03.c
index b07d5122b..59caffb9a 100644
--- a/testcases/kernel/syscalls/sendto/sendto03.c
+++ b/testcases/kernel/syscalls/sendto/sendto03.c
@@ -3,18 +3,17 @@
  * Copyright (c) 2019 SUSE LLC <mdoucha@suse.cz>
  */
 
-/*
+/*\
+ * [Description]
+ *
  * CVE-2020-14386
  *
  * Check for vulnerability in tpacket_rcv() which allows an unprivileged user
  * to write arbitrary data to a memory area outside the allocated packet
- * buffer. Kernel crash fixed in:
- *
- *  commit acf69c946233259ab4d64f8869d4037a198c7f06
- *  Author: Or Cohen <orcohen@paloaltonetworks.com>
- *  Date:   Thu Sep 3 21:05:28 2020 -0700
+ * buffer.
  *
- *  net/packet: fix overflow in tpacket_rcv
+ * Kernel crash fixed in 5.9
+ * acf69c946233 ("net/packet: fix overflow in tpacket_rcv")
  */
 
 #include <stdio.h>
diff --git a/testcases/kernel/syscalls/set_mempolicy/Makefile b/testcases/kernel/syscalls/set_mempolicy/Makefile
index 100780dc3..f203aa216 100644
--- a/testcases/kernel/syscalls/set_mempolicy/Makefile
+++ b/testcases/kernel/syscalls/set_mempolicy/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpnuma
+LTPLIBS = numa
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/set_mempolicy/set_mempolicy01.c b/testcases/kernel/syscalls/set_mempolicy/set_mempolicy01.c
index e9712b7be..39e7156d0 100644
--- a/testcases/kernel/syscalls/set_mempolicy/set_mempolicy01.c
+++ b/testcases/kernel/syscalls/set_mempolicy/set_mempolicy01.c
@@ -41,9 +41,9 @@ static void setup(void)
 	 * has multiple NUMA nodes, the test matrix combination grows exponentially
 	 * and bring about test time to increase extremely fast.
 	 *
-	 * Here reset the maximum runtime according to the NUMA nodes.
+	 * Here reset the entire timeout according to the NUMA nodes.
 	 */
-	tst_set_max_runtime(test.max_runtime * (1 << nodes->cnt/16));
+	tst_set_timeout(test.timeout * (1 << nodes->cnt/16));
 }
 
 static void cleanup(void)
@@ -119,7 +119,7 @@ static struct tst_test test = {
 	.tcnt = 2,
 	.forks_child = 1,
 	.needs_checkpoints = 1,
-	.max_runtime = 600,
+	.timeout = 600,
 };
 
 #else
diff --git a/testcases/kernel/syscalls/set_tid_address/set_tid_address01.c b/testcases/kernel/syscalls/set_tid_address/set_tid_address01.c
index 11fa27540..0b68f70f3 100644
--- a/testcases/kernel/syscalls/set_tid_address/set_tid_address01.c
+++ b/testcases/kernel/syscalls/set_tid_address/set_tid_address01.c
@@ -1,129 +1,25 @@
-/******************************************************************************/
-/* Copyright (c) Crackerjack Project., 2007                                   */
-/*                                                                            */
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA    */
-/*                                                                            */
-/******************************************************************************/
-/******************************************************************************/
-/*                                                                            */
-/* File:        set_tid_address01.c                                           */
-/*                                                                            */
-/* Description: This tests the set_tid_address() syscall                      */
-/*                                                                            */
-/* Usage:  <for command-line>                                                 */
-/* set_tid_address01 [-c n] [-e][-i n] [-I x] [-p x] [-t]                     */
-/*      where,  -c n : Run n copies concurrently.                             */
-/*              -e   : Turn on errno logging.                                 */
-/*              -i n : Execute test n times.                                  */
-/*              -I x : Execute test for x seconds.                            */
-/*              -P x : Pause for x seconds between iterations.                */
-/*              -t   : Turn on syscall timing.                                */
-/*                                                                            */
-/* Total Tests: 1                                                             */
-/*                                                                            */
-/* Test Name:   set_tid_address01                                             */
-/* History:     Porting from Crackerjack to LTP is done by                    */
-/*              Manas Kumar Nayak maknayak@in.ibm.com>                        */
-/******************************************************************************/
-
-#include <stdio.h>
-#include <errno.h>
-
-#include "test.h"
+// SPDX-License-Identifier: GPL-2.0-or-later
+/* Copyright (c) Crackerjack Project., 2007
+ * Copyright (c) Linux Test Project, 2007-2024
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify the basic functionality of set_tid_address() syscall.
+ */
+
+#include "tst_test.h"
 #include "lapi/syscalls.h"
 
-char *TCID = "set_tid_address01";
-int testno;
-int TST_TOTAL = 1;
-
-/* Extern Global Functions */
-/******************************************************************************/
-/*                                                                            */
-/* Function:    cleanup                                                       */
-/*                                                                            */
-/* Description: Performs all one time clean up for this test on successful    */
-/*              completion,  premature exit or  failure. Closes all temporary */
-/*              files, removes all temporary directories exits the test with  */
-/*              appropriate return code by calling tst_exit() function.       */
-/*                                                                            */
-/* Input:       None.                                                         */
-/*                                                                            */
-/* Output:      None.                                                         */
-/*                                                                            */
-/* Return:      On failure - Exits calling tst_exit(). Non '0' return code.   */
-/*              On success - Exits calling tst_exit(). With '0' return code.  */
-/*                                                                            */
-/******************************************************************************/
-void cleanup(void)
-{
-
-	tst_rmdir();
-
-	tst_exit();
-}
-
-/* Local  Functions */
-/******************************************************************************/
-/*                                                                            */
-/* Function:    setup                                                         */
-/*                                                                            */
-/* Description: Performs all one time setup for this test. This function is   */
-/*              typically used to capture signals, create temporary dirs      */
-/*              and temporary files that may be used in the course of this    */
-/*              test.                                                         */
-/*                                                                            */
-/* Input:       None.                                                         */
-/*                                                                            */
-/* Output:      None.                                                         */
-/*                                                                            */
-/* Return:      On failure - Exits by calling cleanup().                      */
-/*              On success - returns 0.                                       */
-/*                                                                            */
-/******************************************************************************/
-void setup(void)
-{
-	/* Capture signals if any */
-	/* Create temporary directories */
-	TEST_PAUSE;
-	tst_tmpdir();
-}
-
-int main(int ac, char **av)
+static void verify_set_tid_address(void)
 {
 	int newtid = -1;
-	int lc;
 
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); ++lc) {
-		tst_count = 0;
-		for (testno = 0; testno < TST_TOTAL; ++testno) {
-			TEST(tst_syscall(__NR_set_tid_address, &newtid));
-			if (TEST_RETURN == getpid()) {
-				tst_resm(TPASS,
-					 "set_tid_address call succeeded:  as expected %ld",
-					 TEST_RETURN);
-			} else {
-				tst_brkm(TFAIL, cleanup, "%s failed - errno = %d : %s",
-					 TCID, TEST_ERRNO,
-					 strerror(TEST_ERRNO));
-			}
-		}
-	}
-	cleanup();
-	tst_exit();
+	TST_EXP_VAL(tst_syscall(__NR_set_tid_address, &newtid), getpid());
 }
+
+static struct tst_test test = {
+	.test_all = verify_set_tid_address,
+	.needs_tmpdir = 1,
+};
diff --git a/testcases/kernel/syscalls/setpgid/setpgid01.c b/testcases/kernel/syscalls/setpgid/setpgid01.c
index 60034e016..c976c3a51 100644
--- a/testcases/kernel/syscalls/setpgid/setpgid01.c
+++ b/testcases/kernel/syscalls/setpgid/setpgid01.c
@@ -1,150 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it would be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * Further, this software is distributed without any warranty that it is
- * free of the rightful claim of any third person regarding infringement
- * or the like.  Any license provided herein, whether implied or
- * otherwise, applies only to this software file.  Patent licenses, if
- * any, provided herein do not apply to combinations of this program with
- * other software, or any other product whatsoever.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
- * Mountain View, CA  94043, or:
- *
- * http://www.sgi.com
- *
- * For further information regarding this notice, see:
- *
- * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
- *
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
-/* $Id: setpgid01.c,v 1.7 2009/11/02 13:57:18 subrata_modak Exp $ */
 
-/*
- * Description:
- * Verify that:
- *   1. Basic functionality test for setpgid(2).
- *   2. Check functioning of setpgid(2) with pid = 0 and pgid = 0.
+/*\
+ * [Description]
+ *
+ * Verify basic setpgid() functionality, re-setting group ID inside both parent
+ * and child. In the first case, we obtain getpgrp() and set it. In the second
+ * case, we use setpgid(0, 0).
  */
 
-#include <errno.h>
-#include <string.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <sys/wait.h>
-#include "test.h"
-
-static void setup(void);
-static void cleanup(void);
-
-char *TCID = "setpgid01";
-
-static void setpgid_test1(void);
-static void setpgid_test2(void);
-static void (*testfunc[])(void) = { setpgid_test1, setpgid_test2};
-int TST_TOTAL = ARRAY_SIZE(testfunc);
-
-int main(int ac, char **av)
-{
-	int i, lc;
-
-	tst_parse_opts(ac, av, NULL, NULL);
-
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		tst_count = 0;
-
-		for (i = 0; i < TST_TOTAL; i++)
-			(*testfunc[i])();
-	}
-
-	cleanup();
-	tst_exit();
-}
+#include "tst_test.h"
 
 static void setpgid_test1(void)
 {
 	pid_t pgid, pid;
 
-	pgid = getpgrp();
-	pid = getpid();
+	pgid = TST_EXP_PID(getpgrp());
+	pid = TST_EXP_PID(getpid());
 
-	TEST(setpgid(pid, pgid));
-	if (TEST_RETURN == -1 || getpgrp() != pgid) {
-		tst_resm(TFAIL | TTERRNO, "test setpgid(%d, %d) fail",
-			 pid, pgid);
-	} else {
-		tst_resm(TPASS, "test setpgid(%d, %d) success", pid, pgid);
-	}
-}
-
-static int wait4child(pid_t child)
-{
-	int status;
-
-	if (waitpid(child, &status, 0) == -1)
-		tst_resm(TBROK|TERRNO, "waitpid");
-	if (WIFEXITED(status))
-		return WEXITSTATUS(status);
-	else
-		return status;
+	TST_EXP_PASS(setpgid(pid, pgid));
+	TST_EXP_EQ_LI(pgid, getpgrp());
 }
 
 static void setpgid_test2(void)
 {
-	int ret;
-	pid_t pgid, pid;
+	pid_t pgid;
 
-	pid = tst_fork();
-	if (pid == -1)
-		tst_brkm(TBROK | TERRNO, cleanup, "fork()");
-
-	if (pid != 0) {
-		ret = wait4child(pid);
-	} else {
-		pid = getpid();
-		TEST(setpgid(0, 0));
-		pgid = getpgrp();
-		if (TEST_RETURN == -1) {
-			fprintf(stderr, "setpgid(0, 0) fails in "
-				"child process: %s\n", strerror(TEST_ERRNO));
-			exit(1);
-		} else if (pgid != pid) {
-			fprintf(stderr, "setpgid(0, 0) fails to make PGID"
-				"equal to PID\n");
-			exit(1);
-		} else {
-			exit(0);
-		}
+	if (!SAFE_FORK()) {
+		pgid = TST_EXP_PID(getpid());
+		TST_EXP_PASS(setpgid(0, 0));
+		TST_EXP_EQ_LI(pgid, getpgrp());
 	}
-
-	if (ret == 0)
-		tst_resm(TPASS, "test setpgid(0, 0) success");
-	else
-		tst_resm(TFAIL, "test setpgid(0, 0) fail");
 }
 
-
-static void setup(void)
+static void run(void)
 {
-	tst_sig(FORK, DEF_HANDLER, cleanup);
-
-	TEST_PAUSE;
+	setpgid_test1();
+	setpgid_test2();
 }
 
-static void cleanup(void)
-{
-}
+static struct tst_test test = {
+	.test_all = run,
+	.forks_child = 1,
+};
diff --git a/testcases/kernel/syscalls/setresgid/setresgid01.c b/testcases/kernel/syscalls/setresgid/setresgid01.c
index d66c42261..2301a6771 100644
--- a/testcases/kernel/syscalls/setresgid/setresgid01.c
+++ b/testcases/kernel/syscalls/setresgid/setresgid01.c
@@ -1,216 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) Wipro Technologies Ltd, 2002.  All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it would be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
-/**********************************************************
- *
- *    TEST IDENTIFIER   : setresgid01
- *
- *    EXECUTED BY       : root / superuser
- *
- *    TEST TITLE        : Checking functionality of setresgid(2)
- *
- *    TEST CASE TOTAL   : 5
- *
- *    AUTHOR            : Madhu T L <madhu.tarikere@wipro.com>
- *
- *    SIGNALS
- *      Uses SIGUSR1 to pause before test if option set.
- *      (See the parse_opts(3) man page).
- *
- *    DESCRIPTION
- *      Verify that,
- *	1. setresgid(2) is successful for setresgid(-1, -1, -1)
- *	2. setresgid(2) is successful for setresgid(-1, -1, nobody)
- *	3. setresgid(2) is successful for setresgid(-1, nobody, -1)
- *	4. setresgid(2) is successful for setresgid(nobody, -1, -1)
- *	5. setresgid(2) is successful for setresgid(root, root, root)
- *
- *      Setup:
- *	  Setup signal handling.
- *	  Test caller is superuser
- *	  Check existence of root and nobody user id's
- *	  Pause for SIGUSR1 if option specified.
- *
- *	Test:
- *	 Loop if the proper options are given.
- *	  Execute system call
- *	  Check return value and functionality, if success,
- *		 Issue PASS message
- *	Otherwise,
- *		Issue FAIL message
- *
- *	Cleanup:
- *	  Print errno log and/or timing stats if options given
- *
- * USAGE:  <for command-line>
- *  setresgid01 [-c n] [-e] [-f] [-h] [-i n] [-I x] [-p] [-P x] [-t]
- *		where,  -c n : Run n copies concurrently.
- *			-e   : Turn on errno logging.
- *			-f   : Turn off functional testing
- *			-h   : Show help screen
- *			-i n : Execute test n times.
- *			-I x : Execute test for x seconds.
- *			-p   : Pause for SIGUSR1 before starting
- *			-P x : Pause for x seconds between iterations.
- *			-t   : Turn on syscall timing.
- *
- ****************************************************************/
 
-#define _GNU_SOURCE 1
-#include <errno.h>
-#include <pwd.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include "test.h"
-#include "safe_macros.h"
-#include "compat_16.h"
+/*\
+ * [Description]
+ *
+ * Verify that setresgid() syscall correctly sets real user ID, effective user
+ * ID and the saved set-user ID in the calling process.
+ */
 
-#define EXP_RET_VAL	0
+#define _GNU_SOURCE
 
-struct test_case_t {		/* test case structure */
-	uid_t *rgid;		/* real GID */
-	uid_t *egid;		/* effective GID */
-	uid_t *sgid;		/* saved GID */
-	struct passwd *exp_rgid;	/* Expected real GID */
-	struct passwd *exp_egid;	/* Expected effective GID */
-	struct passwd *exp_sgid;	/* Expected saved GID */
-	char *desc;		/* Test description */
+#include <pwd.h>
+#include "tst_test.h"
+#include "compat_tst_16.h"
+
+struct tcase {
+	uid_t *rgid;
+	uid_t *egid;
+	uid_t *sgid;
+	uid_t *exp_rgid;
+	uid_t *exp_egid;
+	uid_t *exp_sgid;
 };
 
-TCID_DEFINE(setresgid01);
-static int testno;
-static struct passwd nobody, root;
-static uid_t nobody_gid, root_gid, neg = -1;
-
-static int test_functionality(uid_t, uid_t, uid_t);
-static void setup(void);
-static void cleanup(void);
-
-/* Don't change order of these test cases */
-static struct test_case_t tdat[] = {
-	{&neg, &neg, &neg, &root, &root, &root,
-	 "setresgid(-1, -1, -1)"},
-	{&neg, &neg, &nobody.pw_gid, &root, &root, &nobody,
-	 "setresgid(-1, -1, nobody)"},
-	{&neg, &nobody.pw_gid, &neg, &root, &nobody, &nobody,
-	 "setresgid(-1, nobody, -1)"},
-	{&nobody.pw_gid, &neg, &neg, &nobody, &nobody, &nobody,
-	 "setresgid(nobody, -1, -1)"},
-	{&root.pw_gid, &root.pw_gid, &root.pw_gid, &root, &root, &root,
-	 "setresgid(root, root, root)"},
+static uid_t nobody_gid;
+static uid_t root_gid;
+static uid_t neg = -1;
+
+static struct tcase tcases[] = {
+	{
+		&neg, &neg, &neg,
+		&root_gid, &root_gid, &root_gid,
+	},
+	{
+		&neg, &neg, &nobody_gid,
+		&root_gid, &root_gid, &nobody_gid,
+	},
+	{
+		&neg, &nobody_gid, &neg,
+		&root_gid, &nobody_gid, &nobody_gid,
+	},
+	{
+		&nobody_gid, &neg, &neg,
+		&nobody_gid, &nobody_gid, &nobody_gid,
+	},
+	{
+		&root_gid, &root_gid, &root_gid,
+		&root_gid, &root_gid, &root_gid,
+	},
 };
 
-int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]);
-
-int main(int argc, char **argv)
+static void run(unsigned int n)
 {
-	int lc;
+	struct tcase *tc = &tcases[n];
 
-	tst_parse_opts(argc, argv, NULL, NULL);
+	uid_t cur_rgid;
+	uid_t cur_egid;
+	uid_t cur_sgid;
 
-	setup();
+	TST_EXP_PASS(SETRESGID(*tc->rgid, *tc->egid, *tc->sgid));
+	if (!TST_PASS)
+		return;
 
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		/* reset tst_count in case we are looping */
-		tst_count = 0;
+	SAFE_GETRESGID(&cur_rgid, &cur_egid, &cur_sgid);
 
-		for (testno = 0; testno < TST_TOTAL; ++testno) {
-
-			TEST(SETRESGID(cleanup, *tdat[testno].rgid, *tdat[testno].egid,
-				       *tdat[testno].sgid));
-
-			if (TEST_RETURN == EXP_RET_VAL) {
-				if (!test_functionality
-				    (tdat[testno].exp_rgid->pw_gid,
-				     tdat[testno].exp_egid->pw_gid,
-				     tdat[testno].exp_sgid->pw_gid)) {
-
-					tst_resm(TPASS, "Test for %s "
-						 "successful",
-						 tdat[testno].desc);
-				} else {
-					tst_resm(TFAIL, "Functionality test "
-						 "for %s failed",
-						 tdat[testno].desc);
-				}
-			} else {
-				tst_resm(TFAIL, "Test for %s failed; returned"
-					 " %ld (expected %d), errno %d (expected"
-					 " 0)", tdat[testno].desc,
-					 TEST_RETURN, EXP_RET_VAL, TEST_ERRNO);
-			}
-		}
-	}
-	cleanup();
-
-	tst_exit();
+	TST_EXP_EQ_LI(*tc->exp_rgid, cur_rgid);
+	TST_EXP_EQ_LI(*tc->exp_egid, cur_egid);
+	TST_EXP_EQ_LI(*tc->exp_sgid, cur_sgid);
 }
 
-static int test_functionality(uid_t exp_rgid, uid_t exp_egid, uid_t exp_sgid)
-{
-	uid_t cur_rgid, cur_egid, cur_sgid;
-
-	/* Get current real, effective and saved group id's */
-	SAFE_GETRESGID(cleanup, &cur_rgid, &cur_egid, &cur_sgid);
-
-	if ((cur_rgid == exp_rgid) && (cur_egid == exp_egid)
-	    && (cur_sgid == exp_sgid)) {
-		return 0;
-	}
-	return 1;
-}
-
-/*
- * setup()
- *	performs all ONE TIME setup for this test
- */
-void setup(void)
+static void setup(void)
 {
-	struct passwd *passwd_p;
+	struct passwd *pwd_buf;
 
-	tst_require_root();
+	pwd_buf = SAFE_GETPWNAM("root");
+	GID16_CHECK(pwd_buf->pw_gid, "setresgid");
+	root_gid = pwd_buf->pw_gid;
 
-	tst_sig(NOFORK, DEF_HANDLER, cleanup);
-
-	if ((passwd_p = getpwnam("root")) == NULL) {
-		tst_brkm(TBROK, NULL, "getpwnam() failed for root");
-
-	}
-	root = *passwd_p;
-	GID16_CHECK((root_gid = root.pw_gid), "setresgid", cleanup)
-
-	if ((passwd_p = getpwnam("nobody")) == NULL) {
-		tst_brkm(TBROK, NULL, "nobody user id doesn't exist");
-
-	}
-	nobody = *passwd_p;
-	GID16_CHECK((nobody_gid = nobody.pw_gid), "setresgid", cleanup)
-
-	/* Pause if that option was specified
-	 * TEST_PAUSE contains the code to fork the test with the -c option.
-	 */
-	TEST_PAUSE;
+	pwd_buf = SAFE_GETPWNAM("nobody");
+	GID16_CHECK(pwd_buf->pw_gid, "setresgid");
+	nobody_gid = pwd_buf->pw_gid;
 }
 
-/*
- * cleanup()
- *	performs all ONE TIME cleanup for this test at
- *	completion or premature exit
- */
-void cleanup(void)
-{
-
-}
+static struct tst_test test = {
+	.test = run,
+	.setup = setup,
+	.tcnt = ARRAY_SIZE(tcases),
+	.needs_root = 1,
+};
diff --git a/testcases/kernel/syscalls/setresgid/setresgid04.c b/testcases/kernel/syscalls/setresgid/setresgid04.c
index 4d8e9685e..1eedb883a 100644
--- a/testcases/kernel/syscalls/setresgid/setresgid04.c
+++ b/testcases/kernel/syscalls/setresgid/setresgid04.c
@@ -1,101 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2014 Fujitsu Ltd.
- * Author: Zeng Linggang <zenglg.jy@cn.fujitsu.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it would be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * Copyright (c) Zeng Linggang <zenglg.jy@cn.fujitsu.com>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
-/*
- * Test Description:
- *  Verify that,
- *	File system GID is always set to the same value as the (possibly new)
- *	effective GID.
+
+/*\
+ * [Description]
+ *
+ * Verify that setresgid() syscall always sets the file system GID to the same
+ * value as the new effective GID.
  */
 
 #define _GNU_SOURCE
 
-#include <errno.h>
-#include <unistd.h>
 #include <pwd.h>
-#include <sys/stat.h>
-#include "test.h"
-#include "safe_macros.h"
-#include "compat_16.h"
+#include "tst_test.h"
+#include "compat_tst_16.h"
 
-TCID_DEFINE(setresgid04);
-int TST_TOTAL = 1;
 static struct passwd *ltpuser;
-static void setup(void);
-static void setresgid_verify(void);
-static void cleanup(void);
 
-int main(int argc, char **argv)
+static void run(void)
 {
-	int i, lc;
-
-	tst_parse_opts(argc, argv, NULL, NULL);
+	struct stat buf;
 
-	setup();
+	TST_EXP_PASS(SETRESGID(-1, ltpuser->pw_gid, -1));
 
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		tst_count = 0;
-		for (i = 0; i < TST_TOTAL; i++)
-			setresgid_verify();
-	}
+	SAFE_TOUCH("test_file", 0644, NULL);
+	SAFE_STAT("test_file", &buf);
 
-	cleanup();
-	tst_exit();
+	TST_EXP_EQ_LI(ltpuser->pw_gid, buf.st_gid);
 }
 
 static void setup(void)
 {
-	tst_require_root();
-
-	tst_sig(NOFORK, DEF_HANDLER, cleanup);
-
-	TEST_PAUSE;
-
-	tst_tmpdir();
-
-	ltpuser = SAFE_GETPWNAM(cleanup, "nobody");
+	ltpuser = SAFE_GETPWNAM("nobody");
 
-	GID16_CHECK(ltpuser->pw_gid, "setresgid", cleanup)
+	GID16_CHECK(ltpuser->pw_gid, "setresgid");
 }
 
-static void setresgid_verify(void)
-{
-	struct stat buf;
-
-	TEST(SETRESGID(cleanup, -1, ltpuser->pw_gid, -1));
-
-	if (TEST_RETURN != 0) {
-		tst_resm(TFAIL | TTERRNO, "setresgid failed unexpectedly");
-		return;
-	}
-
-	SAFE_TOUCH(cleanup, "test_file", 0644, NULL);
-
-	SAFE_STAT(cleanup, "test_file", &buf);
-
-	if (ltpuser->pw_gid == buf.st_gid) {
-		tst_resm(TPASS, "setresgid succeeded as expected");
-	} else {
-		tst_resm(TFAIL,
-			 "setresgid failed unexpectedly; egid(%d) - st_gid(%d)",
-			 ltpuser->pw_gid, buf.st_gid);
-	}
-}
-
-static void cleanup(void)
-{
-	tst_rmdir();
-}
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.needs_root = 1,
+	.needs_tmpdir = 1,
+};
diff --git a/testcases/kernel/syscalls/setrlimit/setrlimit01.c b/testcases/kernel/syscalls/setrlimit/setrlimit01.c
index 188d310b2..d00153533 100644
--- a/testcases/kernel/syscalls/setrlimit/setrlimit01.c
+++ b/testcases/kernel/syscalls/setrlimit/setrlimit01.c
@@ -33,6 +33,7 @@
 #include <sys/wait.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <signal.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include "test.h"
@@ -256,8 +257,7 @@ static void test4(void)
 		tst_brkm(TBROK, cleanup, "fork() failed");
 
 	if (pid == 0) {		/* child */
-		char *testbuf = NULL;
-		strcpy(testbuf, "abcd");
+		raise(SIGSEGV);
 		exit(0);
 	}
 	wait(&status);
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt01.c b/testcases/kernel/syscalls/setsockopt/setsockopt01.c
index 4c48a0d95..d8c70cbc5 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt01.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt01.c
@@ -1,13 +1,23 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *   Copyright (c) International Business Machines  Corp., 2001
- *	07/2001 John George
- *   Copyright (c) 2020 Martin Doucha <mdoucha@suse.cz>
+ * Copyright (c) International Business Machines Corp., 2001
+ * Author: John George
+ * Copyright (c) 2020 Martin Doucha <mdoucha@suse.cz>
  */
 
-/*
- * Test Description:
- *  Verify that setsockopt() returns the proper errno for various failure cases
+/*\
+ * [Description]
+ *
+ * Verify that setsockopt() fails and set errno:
+ *
+ * - EBADF on invalid file descriptor
+ * - ENOTSOCK on non-socket file descriptor
+ * - EFAULT on invalid option buffer
+ * - EINVAL on invalid optlen
+ * - ENOPROTOOPT on invalid level
+ * - ENOPROTOOPT on invalid option name (UDP)
+ * - ENOPROTOOPT on invalid option name (IP)
+ * - ENOPROTOOPT on invalid option name (TCP)
  */
 
 #include <unistd.h>
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt02.c b/testcases/kernel/syscalls/setsockopt/setsockopt02.c
index 3349c9970..23e56ee7e 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt02.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt02.c
@@ -2,7 +2,11 @@
 /*
  * Copyright (c) 2017 Richard Palethorpe <rpalethorpe@suse.com>
  */
-/* Test for CVE-2017-7308 on a raw socket's ring buffer
+
+/*\
+ * [Description]
+ *
+ * Test for CVE-2017-7308 on a raw socket's ring buffer
  *
  * Try to set tpacket_req3.tp_sizeof_priv to a value with the high bit set. So
  * that tp_block_size < tp_sizeof_priv. If the vulnerability is present then
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt03.c b/testcases/kernel/syscalls/setsockopt/setsockopt03.c
index 7a1458277..82d5aebf1 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt03.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt03.c
@@ -48,9 +48,8 @@ struct payload {
 
 static void setup(void)
 {
-	if (tst_kernel_bits() == 32 || sizeof(long) > 4)
-		tst_res(TCONF,
-			"The vulnerability was only present in 32-bit compat mode");
+	if (!tst_is_compat_mode())
+		tst_res(TINFO, "The vulnerability was only present in 32-bit compat mode");
 }
 
 static void run(void)
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt04.c b/testcases/kernel/syscalls/setsockopt/setsockopt04.c
index 50d82346c..a4c0a371e 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt04.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt04.c
@@ -3,7 +3,10 @@
  * Copyright (c) 2019 SUSE LLC
  * Author: Christian Amann <camann@suse.com>
  */
-/* Test for CVE-2016-9793
+/*\
+ * [Description]
+ *
+ * CVE-2016-9793
  *
  * With kernels between version 3.11 and 4.8 missing commit b98b0bc8 it
  * is possible to pass a very high unsigned integer as send buffer size
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt05.c b/testcases/kernel/syscalls/setsockopt/setsockopt05.c
index 3263da98a..68a093694 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt05.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt05.c
@@ -3,18 +3,16 @@
  * Copyright (c) 2019 SUSE LLC <mdoucha@suse.cz>
  */
 
-/*
+/*\
+ * [Description]
+ *
  * CVE-2017-1000112
  *
  * Check that UDP fragmentation offload doesn't cause memory corruption
  * if the userspace process turns off UFO in between two send() calls.
- * Kernel crash fixed in:
- *
- *  commit 85f1bd9a7b5a79d5baa8bf44af19658f7bf77bfa
- *  Author: Willem de Bruijn <willemb@google.com>
- *  Date:   Thu Aug 10 12:29:19 2017 -0400
  *
- *  udp: consistently apply ufo or fragmentation
+ * Kernel crash fixed in 4.13
+ * 85f1bd9a7b5a ("udp: consistently apply ufo or fragmentation")
  */
 
 #include <sys/types.h>
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt06.c b/testcases/kernel/syscalls/setsockopt/setsockopt06.c
index 00dc69bfb..1c2421fe9 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt06.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt06.c
@@ -3,17 +3,16 @@
  * Copyright (c) 2020 SUSE LLC <mdoucha@suse.cz>
  */
 
-/*
+/*\
+ * [Description]
+ *
  * CVE-2016-8655
  *
  * Check for race condition between packet_set_ring() and tp_version. On some
- * kernels, this may lead to use-after-free. Kernel crash fixed in:
- *
- *  commit 84ac7260236a49c79eede91617700174c2c19b0c
- *  Author: Philip Pettersson <philip.pettersson@gmail.com>
- *  Date:   Wed Nov 30 14:55:36 2016 -0800
+ * kernels, this may lead to use-after-free.
  *
- *  packet: fix race condition in packet_set_ring
+ * Kernel crash fixed in 4.9
+ * 84ac7260236a ("packet: fix race condition in packet_set_ring")
  */
 
 #include <unistd.h>
@@ -111,7 +110,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 270,
+	.runtime = 270,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_USER_NS=y",
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt07.c b/testcases/kernel/syscalls/setsockopt/setsockopt07.c
index f6f94ad97..ed80d2c50 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt07.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt07.c
@@ -3,20 +3,18 @@
  * Copyright (c) 2020 SUSE LLC <mdoucha@suse.cz>
  */
 
-/*
+/*\
+ * [Description]
+ *
  * CVE-2017-1000111
  *
  * Check for race condition between packet_set_ring() and tp_reserve.
  * The race allows you to set tp_reserve bigger than ring buffer size.
  * While this will cause truncation of all incoming packets to 0 bytes,
  * sanity checks in tpacket_rcv() prevent any exploitable buffer overflows.
- * Race fixed in:
- *
- *  commit c27927e372f0785f3303e8fad94b85945e2c97b7 (HEAD)
- *  Author: Willem de Bruijn <willemb@google.com>
- *  Date:   Thu Aug 10 12:41:58 2017 -0400
  *
- *  packet: fix tp_reserve race in packet_set_ring
+ * Race fixed in v4.13
+ * c27927e372f0 ("packet: fix tp_reserve race in packet_set_ring")
  */
 
 #include <unistd.h>
@@ -125,7 +123,7 @@ static struct tst_test test = {
 	.test_all = run,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 150,
+	.runtime = 150,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_USER_NS=y",
 		"CONFIG_NET_NS=y",
diff --git a/testcases/kernel/syscalls/setsockopt/setsockopt08.c b/testcases/kernel/syscalls/setsockopt/setsockopt08.c
index 7f8243de1..a246cfddd 100644
--- a/testcases/kernel/syscalls/setsockopt/setsockopt08.c
+++ b/testcases/kernel/syscalls/setsockopt/setsockopt08.c
@@ -3,6 +3,7 @@
  * Copyright (c) 2021 SUSE LLC <rpalethorpe@suse.com>
  * Based on reproducer by Nicolai Stange based on PoC Andy Nguyen
  */
+
 /*\
  * [Description]
  *
@@ -95,10 +96,8 @@ static void *buffer;
 
 void setup(void)
 {
-	if (tst_kernel_bits() == 32 || sizeof(long) > 4) {
-		tst_res(TINFO,
-			"The vulnerability was only present in 32-bit compat mode");
-	}
+	if (!tst_is_compat_mode())
+		tst_res(TINFO, "The vulnerability was only present in 32-bit compat mode");
 
 	tst_setup_netns();
 }
diff --git a/testcases/kernel/syscalls/shutdown/.gitignore b/testcases/kernel/syscalls/shutdown/.gitignore
new file mode 100644
index 000000000..fd1ed807d
--- /dev/null
+++ b/testcases/kernel/syscalls/shutdown/.gitignore
@@ -0,0 +1,2 @@
+shutdown01
+shutdown02
diff --git a/testcases/kernel/syscalls/shutdown/Makefile b/testcases/kernel/syscalls/shutdown/Makefile
new file mode 100644
index 000000000..8cf1b9024
--- /dev/null
+++ b/testcases/kernel/syscalls/shutdown/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/shutdown/shutdown01.c b/testcases/kernel/syscalls/shutdown/shutdown01.c
new file mode 100644
index 000000000..91e437805
--- /dev/null
+++ b/testcases/kernel/syscalls/shutdown/shutdown01.c
@@ -0,0 +1,121 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies the following shutdown() functionalities:
+ *
+ * - SHUT_RD should enable send() ops but disable recv() ops
+ * - SHUT_WR should enable recv() ops but disable send() ops
+ * - SHUT_RDWR should disable both recv() and send() ops
+ */
+
+#include "tst_test.h"
+#include "tst_safe_net.h"
+
+#define MSGSIZE 4
+#define SOCKETFILE "socket"
+
+#define OP_DESC(x) .shutdown_op = x, .desc = #x
+static struct tcase {
+	int shutdown_op;
+	int recv_flag;
+	int recv_err;
+	int send_flag;
+	int send_err;
+	char *desc;
+} tcases[] = {
+	{OP_DESC(SHUT_RD)},
+	{OP_DESC(SHUT_WR), .recv_flag = MSG_DONTWAIT, .recv_err = EWOULDBLOCK,
+		.send_flag = MSG_NOSIGNAL, .send_err = EPIPE},
+	{OP_DESC(SHUT_RDWR), .send_flag = MSG_NOSIGNAL, .send_err = EPIPE}
+};
+
+static struct sockaddr_un *sock_addr;
+
+static void run_server(void)
+{
+	int server_sock;
+
+	server_sock = SAFE_SOCKET(sock_addr->sun_family, SOCK_STREAM, 0);
+
+	SAFE_BIND(server_sock,
+		(struct sockaddr *)sock_addr,
+		sizeof(struct sockaddr_un));
+	SAFE_LISTEN(server_sock, 10);
+
+	tst_res(TINFO, "Running server on socket file");
+
+	TST_CHECKPOINT_WAKE_AND_WAIT(0);
+
+	SAFE_CLOSE(server_sock);
+	SAFE_UNLINK(SOCKETFILE);
+}
+
+static int start_test(void)
+{
+	int client_sock;
+
+	if (!SAFE_FORK()) {
+		run_server();
+		_exit(0);
+	}
+
+	TST_CHECKPOINT_WAIT(0);
+
+	tst_res(TINFO, "Connecting to the server");
+
+	client_sock = SAFE_SOCKET(sock_addr->sun_family, SOCK_STREAM, 0);
+	SAFE_CONNECT(client_sock,
+		(struct sockaddr *)sock_addr,
+		sizeof(struct sockaddr_un));
+
+	return client_sock;
+}
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+	int client_sock;
+	char buff[MSGSIZE] = {0};
+
+	client_sock = start_test();
+
+	tst_res(TINFO, "Testing %s flag", tc->desc);
+
+	TST_EXP_PASS(shutdown(client_sock, tc->shutdown_op));
+
+	if (tc->recv_err)
+		TST_EXP_FAIL(recv(client_sock, buff, MSGSIZE, tc->recv_flag), tc->recv_err);
+	else
+		SAFE_RECV(0, client_sock, buff, MSGSIZE, tc->recv_flag);
+
+	if (tc->send_err)
+		TST_EXP_FAIL(send(client_sock, buff, MSGSIZE, tc->send_flag), tc->send_err);
+	else
+		SAFE_SEND(MSGSIZE, client_sock, buff, MSGSIZE, tc->send_flag);
+
+	SAFE_CLOSE(client_sock);
+	TST_CHECKPOINT_WAKE(0);
+}
+
+static void setup(void)
+{
+	sock_addr->sun_family = AF_UNIX;
+	memcpy(sock_addr->sun_path, SOCKETFILE, sizeof(SOCKETFILE));
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.forks_child = 1,
+	.needs_checkpoints = 1,
+	.bufs = (struct tst_buffers []) {
+		{&sock_addr, .size = sizeof(struct sockaddr_un)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/shutdown/shutdown02.c b/testcases/kernel/syscalls/shutdown/shutdown02.c
new file mode 100644
index 000000000..33f748814
--- /dev/null
+++ b/testcases/kernel/syscalls/shutdown/shutdown02.c
@@ -0,0 +1,76 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies the following shutdown() errors:
+ *
+ * - EBADF sockfd is not a valid file descriptor
+ * - EINVAL An invalid value was specified in how
+ * - ENOTCONN The specified socket is not connected
+ * - ENOTSOCK The file descriptor sockfd does not refer to a socket
+ */
+
+#include "tst_test.h"
+
+static int file_desc;
+static int valid_sock;
+static int invalid_sock = -1;
+
+static struct sockaddr_in *server_addr;
+
+static struct tcase {
+	int *socket;
+	int flags;
+	int error;
+} tcases[] = {
+	{&invalid_sock, PF_INET, EBADF},
+	{&valid_sock,   -1,      EINVAL},
+	{&valid_sock,   PF_INET, ENOTCONN},
+	{&file_desc,    PF_INET, ENOTSOCK},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+
+	TST_EXP_FAIL(shutdown(*tc->socket, tc->flags), tc->error);
+}
+
+static void setup(void)
+{
+	file_desc = SAFE_OPEN("notasocket", O_CREAT, 0640);
+	valid_sock = SAFE_SOCKET(PF_INET, SOCK_STREAM, 0);
+
+	server_addr->sin_family = AF_INET;
+	server_addr->sin_port = 0;
+	server_addr->sin_addr.s_addr = INADDR_ANY;
+
+	SAFE_BIND(valid_sock,
+		(struct sockaddr *)server_addr,
+		sizeof(struct sockaddr_in));
+}
+
+static void cleanup(void)
+{
+	if (valid_sock > 0)
+		SAFE_CLOSE(valid_sock);
+
+	if (file_desc > 0)
+		SAFE_CLOSE(file_desc);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+	.bufs = (struct tst_buffers []) {
+		{&server_addr, .size = sizeof(struct sockaddr_in)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/signalfd/.gitignore b/testcases/kernel/syscalls/signalfd/.gitignore
index 3c9ed737c..959022f41 100644
--- a/testcases/kernel/syscalls/signalfd/.gitignore
+++ b/testcases/kernel/syscalls/signalfd/.gitignore
@@ -1 +1,2 @@
 /signalfd01
+/signalfd02
diff --git a/testcases/kernel/syscalls/signalfd/signalfd01.c b/testcases/kernel/syscalls/signalfd/signalfd01.c
index 8fb16800f..e54d4a606 100644
--- a/testcases/kernel/syscalls/signalfd/signalfd01.c
+++ b/testcases/kernel/syscalls/signalfd/signalfd01.c
@@ -1,302 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *
- *   Copyright (c) Red Hat Inc., 2008
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Copyright (c) Red Hat Inc., 2008
+ * Copyright (c) Linux Test Project, 2006-2024
  */
 
-/*
- * NAME
- *	signalfd01.c
- *
- * DESCRIPTION
- *	Check signalfd can receive signals
- *
- * USAGE
- * 	signalfd01
+/*\
+ * [Description]
  *
- * HISTORY
- *	9/2008 Initial version by Masatake YAMATO <yamato@redhat.com>
+ * Verify that signalfd() works as expected.
  *
- * RESTRICTIONS
- * 	None
+ * - signalfd() can create fd, and fd can receive signal.
+ * - signalfd() can reassign fd, and fd can receive signal.
  */
-#define _GNU_SOURCE
 
-#include "config.h"
-
-#include "test.h"
-
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include "ltp_signal.h"
-
-TCID_DEFINE(signalfd01);
-int TST_TOTAL = 1;
-
-#ifndef HAVE_SIGNALFD
-#define  USE_STUB
-#endif
-
-#if defined HAVE_SYS_SIGNALFD_H
 #include <sys/signalfd.h>
-#elif defined HAVE_LINUX_SIGNALFD_H
-#include <linux/signalfd.h>
-#define USE_OWNIMPL
-#else
-#define  USE_STUB
-#endif
+#include "tst_test.h"
 
-#ifndef HAVE_STRUCT_SIGNALFD_SIGINFO_SSI_SIGNO
-#define USE_STUB
-#endif
+static int fd_signal = -1;
+static sigset_t mask1;
+static sigset_t mask2;
 
-#ifdef USE_STUB
-int main(void)
+static void check_signal(int fd, uint32_t signal)
 {
-	tst_brkm(TCONF, NULL, "System doesn't support execution of the test");
+	pid_t pid = getpid();
+	ssize_t bytes;
+	struct signalfd_siginfo siginfo;
+
+	SAFE_KILL(pid, signal);
+	bytes = SAFE_READ(0, fd, &siginfo, sizeof(siginfo));
+	TST_EXP_EQ_LI(bytes, sizeof(siginfo));
+	TST_EXP_EQ_LI(siginfo.ssi_signo, signal);
 }
 
-#else
-#if defined USE_OWNIMPL
-#include "lapi/syscalls.h"
-int signalfd(int fd, const sigset_t * mask, int flags)
+static void setup(void)
 {
-	/* Taken from GLIBC. */
-	return tst_syscall(__NR_signalfd, fd, mask, SIGSETSIZE);
+	SAFE_SIGEMPTYSET(&mask1);
+	SAFE_SIGADDSET(&mask1, SIGUSR1);
+	SAFE_SIGPROCMASK(SIG_BLOCK, &mask1, NULL);
+	SAFE_SIGEMPTYSET(&mask2);
+	SAFE_SIGADDSET(&mask2, SIGUSR2);
+	SAFE_SIGPROCMASK(SIG_BLOCK, &mask2, NULL);
 }
-#endif
-
-void cleanup(void);
-void setup(void);
 
-int do_test1(uint32_t sig)
+static void cleanup(void)
 {
-	int sfd_for_next;
-	int sfd;
-	sigset_t mask;
-	pid_t pid;
-	struct signalfd_siginfo fdsi;
-	ssize_t s;
-
-	sigemptyset(&mask);
-	sigaddset(&mask, sig);
-	if (sigprocmask(SIG_BLOCK, &mask, NULL) < 0) {
-		tst_brkm(TBROK, cleanup,
-			 "sigprocmask() Failed: errno=%d : %s",
-			 errno, strerror(errno));
-	}
-
-	TEST(signalfd(-1, &mask, 0));
-
-	if ((sfd = TEST_RETURN) == -1) {
-		tst_resm(TFAIL,
-			 "signalfd() Failed, errno=%d : %s",
-			 TEST_ERRNO, strerror(TEST_ERRNO));
-		sfd_for_next = -1;
-		return sfd_for_next;
-
-	} else {
-		tst_resm(TPASS, "signalfd is created successfully");
-		sfd_for_next = sfd;
-		goto out;
-	}
-
-	if (fcntl(sfd, F_SETFL, O_NONBLOCK) == -1) {
-		close(sfd);
-		tst_brkm(TBROK, cleanup,
-			 "setting signalfd nonblocking mode failed: errno=%d : %s",
-			 errno, strerror(errno));
-	}
-
-	pid = getpid();
-	if (kill(pid, sig) == -1) {
-		close(sfd);
-		tst_brkm(TBROK, cleanup,
-			 "kill(self, %s) failed: errno=%d : %s",
-			 strsignal(sig), errno, strerror(errno));
-	}
-
-	s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
-	if ((s > 0) && (s != sizeof(struct signalfd_siginfo))) {
-		tst_resm(TFAIL,
-			 "getting incomplete signalfd_siginfo data: "
-			 "actual-size=%zd, expected-size=%zu",
-			 s, sizeof(struct signalfd_siginfo));
-		sfd_for_next = -1;
-		close(sfd);
-		goto out;
-	} else if (s < 0) {
-		if (errno == EAGAIN) {
-			tst_resm(TFAIL,
-				 "signalfd_siginfo data is not delivered yet");
-			sfd_for_next = -1;
-			close(sfd);
-			goto out;
-		} else {
-			close(sfd);
-			tst_brkm(TBROK, cleanup,
-				 "read signalfd_siginfo data failed: errno=%d : %s",
-				 errno, strerror(errno));
-		}
-	} else if (s == 0) {
-		tst_resm(TFAIL, "got EOF unexpectedly");
-		sfd_for_next = -1;
-		close(sfd);
-		goto out;
-	}
-
-	if (fdsi.ssi_signo == sig) {
-		tst_resm(TPASS, "got expected signal");
-		sfd_for_next = sfd;
-		goto out;
-	} else {
-		tst_resm(TFAIL, "got unexpected signal: signal=%d : %s",
-			 fdsi.ssi_signo, strsignal(fdsi.ssi_signo));
-		sfd_for_next = -1;
-		close(sfd);
-		goto out;
-	}
-
-out:
-	return sfd_for_next;
+	if (fd_signal > 0)
+		SAFE_CLOSE(fd_signal);
 }
 
-void do_test2(int fd, uint32_t sig)
+static void verify_signalfd(void)
 {
-	int sfd;
-	sigset_t mask;
-	pid_t pid;
-	struct signalfd_siginfo fdsi;
-	ssize_t s;
-
-	sigemptyset(&mask);
-	sigaddset(&mask, sig);
-	if (sigprocmask(SIG_BLOCK, &mask, NULL) < 0) {
-		close(fd);
-		tst_brkm(TBROK, cleanup,
-			 "sigprocmask() Failed: errno=%d : %s",
-			 errno, strerror(errno));
-	}
-
-	TEST(signalfd(fd, &mask, 0));
-
-	if ((sfd = TEST_RETURN) == -1) {
-		tst_resm(TFAIL,
-			 "reassignment the file descriptor by signalfd() failed, errno=%d : %s",
-			 TEST_ERRNO, strerror(TEST_ERRNO));
+	/* create fd */
+	TST_EXP_FD(signalfd(fd_signal, &mask1, 0),
+		"%s", "signalfd() create fd");
+	if (TST_RET == -1)
 		return;
-	} else if (sfd != fd) {
-		tst_resm(TFAIL,
-			 "different fd is returned in reassignment: expected-fd=%d, actual-fd=%d",
-			 fd, sfd);
-		close(sfd);
+	fd_signal = TST_RET;
+	check_signal(fd_signal, SIGUSR1);
+	/* reassign fd */
+	TST_EXP_FD(signalfd(fd_signal, &mask2, 0), "%s",
+		"signalfd() reassign fd");
+	if (TST_RET == -1)
 		return;
-
-	} else {
-		tst_resm(TPASS, "signalfd is successfully reassigned");
-		goto out;
-	}
-
-	pid = getpid();
-	if (kill(pid, sig) == -1) {
-		close(sfd);
-		tst_brkm(TBROK, cleanup,
-			 "kill(self, %s) failed: errno=%d : %s",
-			 strsignal(sig), errno, strerror(errno));
-	}
-
-	s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
-	if ((s > 0) && (s != sizeof(struct signalfd_siginfo))) {
-		tst_resm(TFAIL,
-			 "getting incomplete signalfd_siginfo data: "
-			 "actual-size=%zd, expected-size= %zu",
-			 s, sizeof(struct signalfd_siginfo));
-		goto out;
-	} else if (s < 0) {
-		if (errno == EAGAIN) {
-			tst_resm(TFAIL,
-				 "signalfd_siginfo data is not delivered yet");
-			goto out;
-		} else {
-			close(sfd);
-			tst_brkm(TBROK, cleanup,
-				 "read signalfd_siginfo data failed: errno=%d : %s",
-				 errno, strerror(errno));
-		}
-	} else if (s == 0) {
-		tst_resm(TFAIL, "got EOF unexpectedly");
-		goto out;
-	}
-
-	if (fdsi.ssi_signo == sig) {
-		tst_resm(TPASS, "got expected signal");
-		goto out;
-	} else {
-		tst_resm(TFAIL, "got unexpected signal: signal=%d : %s",
-			 fdsi.ssi_signo, strsignal(fdsi.ssi_signo));
-		goto out;
-	}
-
-out:
-	return;
-}
-
-int main(int argc, char **argv)
-{
-	int lc;
-	int sfd;
-
-	tst_parse_opts(argc, argv, NULL, NULL);
-
-	setup();
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		tst_count = 0;
-
-		sfd = do_test1(SIGUSR1);
-		if (sfd < 0)
-			continue;
-
-		do_test2(sfd, SIGUSR2);
-		close(sfd);
-	}
-
-	cleanup();
-
-	tst_exit();
-}
-
-/*
- * setup() - performs all the ONE TIME setup for this test.
- */
-void setup(void)
-{
-
-	TEST_PAUSE;
-}
-
-/*
- * cleanup() - performs all the ONE TIME cleanup for this test at completion
- * 	       or premature exit.
- */
-void cleanup(void)
-{
-
+	TST_EXP_EQ_LI(TST_RET, fd_signal);
+	check_signal(fd_signal, SIGUSR2);
 }
 
-#endif
+static struct tst_test test = {
+	.test_all = verify_signalfd,
+	.setup = setup,
+	.cleanup = cleanup,
+};
diff --git a/testcases/kernel/syscalls/signalfd/signalfd02.c b/testcases/kernel/syscalls/signalfd/signalfd02.c
new file mode 100644
index 000000000..fdd15781c
--- /dev/null
+++ b/testcases/kernel/syscalls/signalfd/signalfd02.c
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
+ * Author: Ma Xinjian <maxj.fnst@fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that signalfd(2) fails with:
+ *
+ * - EBADF when fd is invalid
+ * - EINVAL when fd is not a valid signalfd file descriptor
+ * - EINVAL when flags are invalid
+ */
+
+#include <sys/signalfd.h>
+#include "tst_test.h"
+
+#define SIGNAL_FILE "signal_file"
+
+static int fd_ebadf = -2;
+static int fd_einval1;
+static int fd_einval2 = -1;
+
+static sigset_t *mask;
+
+static struct test_case_t {
+	int *fd;
+	int flags;
+	int expected_errno;
+	char *desc;
+} tcases[] = {
+	{&fd_ebadf, 0, EBADF, "fd is invalid"},
+	{&fd_einval1, 0, EINVAL,
+		"fd is not a valid signalfd file descriptor"},
+	{&fd_einval2, -1, EINVAL, "flags are invalid"},
+};
+
+static void setup(void)
+{
+	SAFE_SIGEMPTYSET(mask);
+	SAFE_SIGADDSET(mask, SIGUSR1);
+	SAFE_SIGPROCMASK(SIG_BLOCK, mask, NULL);
+
+	fd_einval1 = SAFE_OPEN(SIGNAL_FILE, O_CREAT, 0777);
+}
+
+static void cleanup(void)
+{
+	if (fd_einval1 > 0)
+		SAFE_CLOSE(fd_einval1);
+}
+
+static void verify_signalfd(unsigned int i)
+{
+	struct test_case_t *tc = &tcases[i];
+
+	TST_EXP_FAIL2(signalfd(*(tc->fd), mask, tc->flags),
+		tc->expected_errno, "%s", tc->desc);
+}
+
+static struct tst_test test = {
+	.tcnt = ARRAY_SIZE(tcases),
+	.test = verify_signalfd,
+	.setup = setup,
+	.cleanup = cleanup,
+	.needs_tmpdir = 1,
+	.bufs = (struct tst_buffers []) {
+		{&mask, .size = sizeof(sigset_t)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/sigsuspend/.gitignore b/testcases/kernel/syscalls/sigsuspend/.gitignore
index 46ea52f73..926b73571 100644
--- a/testcases/kernel/syscalls/sigsuspend/.gitignore
+++ b/testcases/kernel/syscalls/sigsuspend/.gitignore
@@ -1 +1,2 @@
 /sigsuspend01
+/sigsuspend02
diff --git a/testcases/kernel/syscalls/sigsuspend/sigsuspend01.c b/testcases/kernel/syscalls/sigsuspend/sigsuspend01.c
index 2276132e3..4d9edcbed 100644
--- a/testcases/kernel/syscalls/sigsuspend/sigsuspend01.c
+++ b/testcases/kernel/syscalls/sigsuspend/sigsuspend01.c
@@ -1,14 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (c) International Business Machines  Corp., 2001
+ * Copyright (c) International Business Machines Corp., 2001
+ * Copyright (c) Linux Test Project, 2003-2024
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify the basic sigsuspend(2) syscall functionality:
  *
- * Description:
- * Verify the basic function of sigsuspend():
- * 1) sigsuspend() can replace process's current signal mask
- *    by the specified signal mask and suspend the process
- *    execution until the delivery of a signal.
- * 2) sigsuspend() should return after the execution of signal
- *    handler and restore the previous signal mask.
+ * - sigsuspend(2) can replace process's current signal mask by the specified
+ *   signal mask and suspend the process execution until the delivery of a
+ *   signal.
+ * - sigsuspend(2) should return after the execution of signal handler and
+ *   restore the previous signal mask.
  */
 
 #include <errno.h>
diff --git a/testcases/kernel/syscalls/sigsuspend/sigsuspend02.c b/testcases/kernel/syscalls/sigsuspend/sigsuspend02.c
new file mode 100644
index 000000000..cfe95393f
--- /dev/null
+++ b/testcases/kernel/syscalls/sigsuspend/sigsuspend02.c
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
+ * Copyright (c) Linux Test Project, 2024
+ * Author: Ma Xinjian <maxj.fnst@fujitsu.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that sigsuspend(2) fails with
+ *
+ * - EFAULT mask points to memory which is not a valid part of the
+ *          process address space.
+ */
+
+#include "tst_test.h"
+
+static void *invalid_mask;
+
+static void setup(void)
+{
+	invalid_mask = tst_get_bad_addr(NULL);
+}
+
+static void verify_sigsuspend(void)
+{
+	TST_EXP_FAIL(sigsuspend(invalid_mask), EFAULT);
+}
+
+static struct tst_test test = {
+	.test_all = verify_sigsuspend,
+	.setup = setup,
+};
diff --git a/testcases/kernel/syscalls/sigtimedwait/Makefile b/testcases/kernel/syscalls/sigtimedwait/Makefile
index 1ae50b32c..f96d5dc3a 100644
--- a/testcases/kernel/syscalls/sigtimedwait/Makefile
+++ b/testcases/kernel/syscalls/sigtimedwait/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir ?= ../../../..
 
-LTPLIBS = ltpsigwait
+LTPLIBS = sigwait
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/sigwait/Makefile b/testcases/kernel/syscalls/sigwait/Makefile
index 1ae50b32c..f96d5dc3a 100644
--- a/testcases/kernel/syscalls/sigwait/Makefile
+++ b/testcases/kernel/syscalls/sigwait/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir ?= ../../../..
 
-LTPLIBS = ltpsigwait
+LTPLIBS = sigwait
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/sigwaitinfo/Makefile b/testcases/kernel/syscalls/sigwaitinfo/Makefile
index 1ae50b32c..f96d5dc3a 100644
--- a/testcases/kernel/syscalls/sigwaitinfo/Makefile
+++ b/testcases/kernel/syscalls/sigwaitinfo/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir ?= ../../../..
 
-LTPLIBS = ltpsigwait
+LTPLIBS = sigwait
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/socket/socket01.c b/testcases/kernel/syscalls/socket/socket01.c
index 4724609d1..ca4731563 100644
--- a/testcases/kernel/syscalls/socket/socket01.c
+++ b/testcases/kernel/syscalls/socket/socket01.c
@@ -1,15 +1,23 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
 * Copyright (c) International Business Machines Corp., 2001
+* Copyright (c) Linux Test Project, 2003-2024
 */
 
-/*
-* Test Name: socket01
-*
-* Test Description:
-* Verify that socket() returns the proper errno for various failure cases
-*
-*/
+/*\
+ * [Description]
+ *
+ * Test creating TCP, UDP, and Unix doman dgram sockets with socket() syscall.
+ *
+ * Also verify that socket() fails and set proper errno
+ *
+ * - EAFNOSUPPORT on invalid domain
+ * - EINVAL on invalid type
+ * - EPROTONOSUPPORT on raw open as non-root
+ * - EPROTONOSUPPORT on UDP stream
+ * - EPROTONOSUPPORT on TCP dgram
+ * - EPROTONOSUPPORT on ICMP stream
+ */
 
 #include <stdio.h>
 #include <unistd.h>
diff --git a/testcases/kernel/syscalls/socket/socket02.c b/testcases/kernel/syscalls/socket/socket02.c
index 51b8cc59c..957a25701 100644
--- a/testcases/kernel/syscalls/socket/socket02.c
+++ b/testcases/kernel/syscalls/socket/socket02.c
@@ -2,15 +2,14 @@
 /*
 * Copyright (c) Ulrich Drepper <drepper@redhat.com>
 * Copyright (c) International Business Machines Corp., 2009
+* Copyright (c) Linux Test Project, 2010-2022
 */
 
-/*
-* Test Name:	socket02
-*
-* Description:
-* This program tests the new flag SOCK_CLOEXEC and SOCK_NONBLOCK introduced
-* in socket() in kernel 2.6.27.
-*/
+/*\
+ * [Description]
+ *
+ * Test socket() with SOCK_CLOEXEC and SOCK_NONBLOCK flags.
+ */
 
 #include <stdio.h>
 #include <unistd.h>
diff --git a/testcases/kernel/syscalls/socketcall/socketcall01.c b/testcases/kernel/syscalls/socketcall/socketcall01.c
index 205306377..85ffd9d1e 100644
--- a/testcases/kernel/syscalls/socketcall/socketcall01.c
+++ b/testcases/kernel/syscalls/socketcall/socketcall01.c
@@ -4,8 +4,14 @@
  * Copyright (c) 2016 Cyril Hrubis <chrubis@suse.cz>
  * Copyright (c) Linux Test Project, 2017-2020
  * Author: Sowmya Adiga <sowmya.adiga@wipro.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Basic test for the socketcall(2) raw syscall.
  *
- * This is a basic test for the socketcall(2) system call.
+ * Test creating TCP, UDP, raw socket and unix domain dgram.
  */
 
 #include <unistd.h>
diff --git a/testcases/kernel/syscalls/socketpair/socketpair01.c b/testcases/kernel/syscalls/socketpair/socketpair01.c
index 5d9610b12..b1e140a55 100644
--- a/testcases/kernel/syscalls/socketpair/socketpair01.c
+++ b/testcases/kernel/syscalls/socketpair/socketpair01.c
@@ -1,14 +1,26 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
 * Copyright (c) International Business Machines Corp., 2001
+* Copyright (c) Linux Test Project, 2003-2022
 */
 
-/*
-* Test Name: socketpair01
-*
-* Test Description:
-* Verify that socketpair() returns the proper errno for various failure cases
-*/
+/*\
+ * [Description]
+ *
+ * Verify that socketpair(2) fails and set proper errno
+ *
+ * - EAFNOSUPPORT on invalid domain
+ * - EINVAL on invalid type
+ * - EPROTONOSUPPORT on raw open as non-root
+ * - EFAULT on bad aligned pointer
+ * - EFAULT on bad unaligned pointer
+ * - EOPNOTSUPP on UDP socket
+ * - EPROTONOSUPPORT on TCP dgram
+ * - EOPNOTSUPP on TCP socket
+ * - EPROTONOSUPPORT on ICMP stream
+ *
+ * Also test creating UNIX domain dgram.
+ */
 
 #include <stdio.h>
 #include <unistd.h>
diff --git a/testcases/kernel/syscalls/socketpair/socketpair02.c b/testcases/kernel/syscalls/socketpair/socketpair02.c
index eb679d5d9..b43cf7295 100644
--- a/testcases/kernel/syscalls/socketpair/socketpair02.c
+++ b/testcases/kernel/syscalls/socketpair/socketpair02.c
@@ -2,15 +2,14 @@
 /*
 * Copyright (c) Ulrich Drepper <drepper@redhat.com>
 * Copyright (c) International Business Machines Corp., 2009
+* Copyright (c) Linux Test Project, 2010-2022
 */
 
-/*
-* Test Name:	socketpair02
-*
-* Description:
-* This Program tests the new flag SOCK_CLOEXEC and SOCK_NONBLOCK introduced
-* in socketpair() in kernel 2.6.27.
-*/
+/*\
+ * [Description]
+ *
+ * Test socket() with SOCK_CLOEXEC and SOCK_NONBLOCK flags.
+ */
 
 #include <errno.h>
 #include <pthread.h>
diff --git a/testcases/kernel/syscalls/splice/splice03.c b/testcases/kernel/syscalls/splice/splice03.c
index c054e6c1c..26beb562a 100644
--- a/testcases/kernel/syscalls/splice/splice03.c
+++ b/testcases/kernel/syscalls/splice/splice03.c
@@ -3,23 +3,19 @@
  * Copyright (c) 2014 Fujitsu Ltd.
  * Author: Xing Gu <gux.fnst@cn.fujitsu.com>
  */
-/*
- * Description:
- *   Verify that,
- *   1) splice() returns -1 and sets errno to EBADF if the file
- *      descriptor fd_in is not valid.
- *   2) splice() returns -1 and sets errno to EBADF if the file
- *      descriptor fd_out is not valid.
- *   3) splice() returns -1 and sets errno to EBADF if the file
- *      descriptor fd_in does not have proper read-write mode.
- *   4) splice() returns -1 and sets errno to EINVAL if target
- *      file is opened in append mode.
- *   5) splice() returns -1 and sets errno to EINVAL if neither
- *      of the descriptors refer to a pipe.
- *   6) splice() returns -1 and sets errno to ESPIPE if off_in is
- *      not NULL when the file descriptor fd_in refers to a pipe.
- *   7) splice() returns -1 and sets errno to ESPIPE if off_out is
- *      not NULL when the file descriptor fd_out refers to a pipe.
+
+/*\
+ * [Description]
+ *
+ * Verify that, splice(2) returns -1 and sets errno to
+ *
+ * 1. EBADF if the file descriptor fd_in is not valid
+ * 2. EBADF if the file descriptor fd_out is not valid
+ * 3. EBADF if the file descriptor fd_in does not have proper read-write mode
+ * 4. EINVAL if target file is opened in append mode
+ * 5. EINVAL if neither of the descriptors refer to a pipe
+ * 6. ESPIPE if off_in is not NULL when the file descriptor fd_in refers to a pipe
+ * 7. ESPIPE if off_out is not NULL when the file descriptor fd_out refers to a pipe
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/stat/.gitignore b/testcases/kernel/syscalls/stat/.gitignore
index fa0a4ce9f..0a62dc6ee 100644
--- a/testcases/kernel/syscalls/stat/.gitignore
+++ b/testcases/kernel/syscalls/stat/.gitignore
@@ -4,3 +4,5 @@
 /stat02_64
 /stat03
 /stat03_64
+/stat04
+/stat04_64
diff --git a/testcases/kernel/syscalls/stat/stat04.c b/testcases/kernel/syscalls/stat/stat04.c
new file mode 100644
index 000000000..05ace606a
--- /dev/null
+++ b/testcases/kernel/syscalls/stat/stat04.c
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ * Author: David Fenner, Jon Hendrickson
+ * Copyright (C) 2024 Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test checks that stat() executed on file provide the same information
+ * of symlink linking to it.
+ */
+
+#include <stdlib.h>
+#include "tst_test.h"
+#include "tst_safe_stdio.h"
+
+#define FILENAME "file.txt"
+#define MNTPOINT "mntpoint"
+#define SYMBNAME MNTPOINT"/file_symlink"
+
+static char *symb_path;
+static char *file_path;
+static struct stat *file_stat;
+static struct stat *symb_stat;
+
+static void run(void)
+{
+	SAFE_STAT(file_path, file_stat);
+	SAFE_STAT(symb_path, symb_stat);
+
+	TST_EXP_EQ_LI(file_stat->st_dev, symb_stat->st_dev);
+	TST_EXP_EQ_LI(file_stat->st_mode, symb_stat->st_mode);
+	TST_EXP_EQ_LI(file_stat->st_nlink, symb_stat->st_nlink);
+	TST_EXP_EQ_LI(file_stat->st_uid, symb_stat->st_uid);
+	TST_EXP_EQ_LI(file_stat->st_gid, symb_stat->st_gid);
+	TST_EXP_EQ_LI(file_stat->st_size, symb_stat->st_size);
+	TST_EXP_EQ_LI(file_stat->st_atime, symb_stat->st_atime);
+	TST_EXP_EQ_LI(file_stat->st_mtime, symb_stat->st_mtime);
+	TST_EXP_EQ_LI(file_stat->st_ctime, symb_stat->st_ctime);
+}
+
+static void setup(void)
+{
+	char opt_bsize[32];
+	const char *const fs_opts[] = {opt_bsize, NULL};
+	struct stat sb;
+	int pagesize;
+	int fd;
+
+	file_path = tst_tmpdir_genpath(FILENAME);
+	symb_path = tst_tmpdir_genpath(SYMBNAME);
+
+	/* change st_blksize / st_dev */
+	SAFE_STAT(".", &sb);
+	pagesize = sb.st_blksize == 4096 ? 1024 : 4096;
+
+	snprintf(opt_bsize, sizeof(opt_bsize), "-b %i", pagesize);
+	SAFE_MKFS(tst_device->dev, tst_device->fs_type, fs_opts, NULL);
+	SAFE_MOUNT(tst_device->dev, MNTPOINT, tst_device->fs_type, 0, 0);
+
+	SAFE_TOUCH(FILENAME, 0777, NULL);
+
+	/* change st_nlink */
+	SAFE_LINK(FILENAME, "linked_file");
+
+	/* change st_uid and st_gid */
+	SAFE_CHOWN(FILENAME, 1000, 1000);
+
+	/* change st_size */
+	fd = SAFE_OPEN(FILENAME, O_WRONLY, 0777);
+	tst_fill_fd(fd, 'a', TST_KB, 500);
+	SAFE_CLOSE(fd);
+
+	/* change st_atime / st_mtime / st_ctime */
+	usleep(1001000);
+
+	SAFE_SYMLINK(file_path, symb_path);
+}
+
+static void cleanup(void)
+{
+	if (tst_is_mounted(MNTPOINT))
+		SAFE_UMOUNT(MNTPOINT);
+}
+
+static struct tst_test test = {
+	.setup = setup,
+	.cleanup = cleanup,
+	.test_all = run,
+	.needs_root = 1,
+	.needs_device = 1,
+	.mntpoint = MNTPOINT,
+	.bufs = (struct tst_buffers []) {
+		{&file_stat, .size = sizeof(struct stat)},
+		{&symb_stat, .size = sizeof(struct stat)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/.gitignore b/testcases/kernel/syscalls/statmount/.gitignore
new file mode 100644
index 000000000..6106fcf07
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/.gitignore
@@ -0,0 +1,8 @@
+statmount01
+statmount02
+statmount03
+statmount04
+statmount05
+statmount06
+statmount07
+statmount08
diff --git a/testcases/kernel/syscalls/statmount/Makefile b/testcases/kernel/syscalls/statmount/Makefile
new file mode 100644
index 000000000..8cf1b9024
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+
+top_srcdir		?= ../../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/kernel/syscalls/statmount/statmount.h b/testcases/kernel/syscalls/statmount/statmount.h
new file mode 100644
index 000000000..d21d7f8da
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+#ifndef STATMOUNT_H
+#define STATMOUNT_H
+
+#define _GNU_SOURCE
+
+#include "tst_test.h"
+#include "lapi/mount.h"
+#include "lapi/syscalls.h"
+#include "tst_safe_stdio.h"
+
+static inline int statmount(uint64_t mnt_id, uint64_t mask, struct statmount *buf,
+		     size_t bufsize, unsigned int flags)
+{
+	struct mnt_id_req req = {
+		.size = MNT_ID_REQ_SIZE_VER0,
+		.mnt_id = mnt_id,
+		.param = mask,
+	};
+
+	return tst_syscall(__NR_statmount, &req, buf, bufsize, flags);
+}
+
+static inline int read_peer_group(const char *path)
+{
+	FILE *file;
+	char line[PATH_MAX];
+	char mroot[PATH_MAX];
+	int group = -1;
+
+	file = SAFE_FOPEN("/proc/self/mountinfo", "r");
+
+	while (fgets(line, sizeof(line), file)) {
+		if (sscanf(line, "%*d %*d %*d:%*d %s %*s %*s shared:%d", mroot, &group) != 2)
+			continue;
+
+		if (strcmp(mroot, path) == 0)
+			break;
+	}
+
+	if (group == -1)
+		tst_brk(TBROK, "Can't reed peer group ID for %s", path);
+
+	return group;
+}
+
+#endif
diff --git a/testcases/kernel/syscalls/statmount/statmount01.c b/testcases/kernel/syscalls/statmount/statmount01.c
new file mode 100644
index 000000000..73b9a59b0
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount01.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that statmount() is working with no mask flags.
+ *
+ * [Algorithm]
+ *
+ * - create a mount point
+ * - run statmount() on the mount point without giving any mask
+ * - read results and check that mask and size are correct
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+
+#define MNTPOINT "mntpoint"
+
+static uint64_t mntpoint_id;
+static struct statmount *st_mount;
+
+static void run(void)
+{
+	memset(st_mount, 0, sizeof(struct statmount));
+
+	TST_EXP_PASS(statmount(mntpoint_id, 0, st_mount, sizeof(struct statmount), 0));
+
+	if (!TST_PASS)
+		return;
+
+	TST_EXP_EQ_LI(st_mount->size, sizeof(struct statmount));
+	TST_EXP_EQ_LI(st_mount->mask, 0);
+	TST_EXP_EQ_LI(st_mount->sb_dev_major, 0);
+	TST_EXP_EQ_LI(st_mount->sb_dev_minor, 0);
+	TST_EXP_EQ_LI(st_mount->sb_magic, 0);
+	TST_EXP_EQ_LI(st_mount->sb_flags, 0);
+	TST_EXP_EQ_LI(st_mount->fs_type, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_id, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_parent_id, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_id_old, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_parent_id_old, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_attr, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_propagation, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_peer_group, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_master, 0);
+	TST_EXP_EQ_LI(st_mount->propagate_from, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_root, 0);
+	TST_EXP_EQ_LI(st_mount->mnt_point, 0);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+
+	SAFE_STATX(AT_FDCWD, MNTPOINT, 0, STATX_MNT_ID_UNIQUE, &sx);
+
+	mntpoint_id = sx.data.stx_mnt_id;
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = sizeof(struct statmount)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount02.c b/testcases/kernel/syscalls/statmount/statmount02.c
new file mode 100644
index 000000000..4e23c6979
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount02.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that statmount() is correctly reading basic filesystem
+ * info using STATMOUNT_SB_BASIC.
+ * The btrfs validation is currently skipped due to the lack of support for VFS.
+ *
+ * [Algorithm]
+ *
+ * - create a mount point and read its mount info
+ * - run statmount() on the mount point using STATMOUNT_SB_BASIC
+ * - read results and check if mount info are correct
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+#include <linux/btrfs.h>
+
+#define MNTPOINT "mntpoint"
+
+static struct statmount *st_mount;
+static struct ltp_statx *sx_mount;
+static struct statfs *sf_mount;
+
+static void run(void)
+{
+	memset(st_mount, 0, sizeof(struct statmount));
+
+	TST_EXP_PASS(statmount(sx_mount->data.stx_mnt_id, STATMOUNT_SB_BASIC,
+		st_mount, sizeof(struct statmount), 0));
+
+	if (!TST_PASS)
+		return;
+
+	TST_EXP_EQ_LI(st_mount->mask, STATMOUNT_SB_BASIC);
+	TST_EXP_EQ_LI(st_mount->size, sizeof(struct statmount));
+	TST_EXP_EQ_LI(st_mount->sb_dev_major, sx_mount->data.stx_dev_major);
+	TST_EXP_EQ_LI(st_mount->sb_dev_minor, sx_mount->data.stx_dev_minor);
+	TST_EXP_EQ_LI(st_mount->sb_magic, sf_mount->f_type);
+	TST_EXP_EQ_LI(st_mount->sb_flags, MS_RDONLY);
+}
+
+static void setup(void)
+{
+	SAFE_MOUNT(tst_device->dev, MNTPOINT, tst_device->fs_type, MS_RDONLY, NULL);
+
+	SAFE_STATX(AT_FDCWD, MNTPOINT, 0, STATX_MNT_ID_UNIQUE, sx_mount);
+	SAFE_STATFS(MNTPOINT, sf_mount);
+}
+
+static void cleanup(void)
+{
+	if (tst_is_mounted(MNTPOINT))
+		SAFE_UMOUNT(MNTPOINT);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "6.8",
+	.mntpoint = MNTPOINT,
+	.format_device = 1,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *const []) {
+		"fuse",
+		"btrfs",
+		NULL
+	},
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = sizeof(struct statmount)},
+		{&sx_mount, .size = sizeof(struct ltp_statx)},
+		{&sf_mount, .size = sizeof(struct statfs)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount03.c b/testcases/kernel/syscalls/statmount/statmount03.c
new file mode 100644
index 000000000..dface528f
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount03.c
@@ -0,0 +1,138 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that statmount() is correctly reading mount information
+ * (mount id, parent mount id, mount attributes etc.) using STATMOUNT_MNT_BASIC.
+ *
+ * [Algorithm]
+ *
+ * - create a mount point
+ * - create a new parent folder inside the mount point and obtain its mount info
+ * - create the new "/" mount folder and obtain its mount info
+ * - run statmount() on the mount point using STATMOUNT_MNT_BASIC
+ * - read results and check if mount info are correct
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+
+#define DIR_A "LTP_DIR_A"
+#define DIR_B "LTP_DIR_B"
+
+static uint64_t mnt_id;
+static uint64_t mnt_id_old;
+static uint64_t parent_id;
+static uint64_t parent_id_old;
+static uint64_t mnt_peer_group;
+static uint64_t mnt_master;
+static struct statmount *st_mount;
+
+static void read_mnt_id(
+	const char *path,
+	uint64_t *mnt_id,
+	uint64_t *mnt_id_unique)
+{
+	struct ltp_statx sx;
+
+	if (mnt_id) {
+		sx.data.stx_mask = STATX_MNT_ID;
+
+		SAFE_STATX(AT_FDCWD, path, 0, STATX_MNT_ID, &sx);
+		*mnt_id = sx.data.stx_mnt_id;
+	}
+
+	if (mnt_id_unique) {
+		sx.data.stx_mask = STATX_MNT_ID_UNIQUE;
+
+		SAFE_STATX(AT_FDCWD, path, 0, STATX_MNT_ID_UNIQUE, &sx);
+		*mnt_id_unique = sx.data.stx_mnt_id;
+	}
+}
+
+static struct tcase {
+	uint64_t prop_type;
+	char *msg;
+} tcases[] = {
+	{ MS_PRIVATE, TST_TO_STR_(MS_PRIVATE) },
+	{ MS_SHARED, TST_TO_STR_(MS_SHARED) },
+	{ MS_SLAVE, TST_TO_STR_(MS_SLAVE) },
+	{ MS_UNBINDABLE, TST_TO_STR_(MS_UNBINDABLE) },
+};
+
+static void run(unsigned int i)
+{
+	struct tcase *tc = &tcases[i];
+
+	tst_res(TINFO,  "Testing statmount() on %s", tc->msg);
+
+	SAFE_MOUNT(DIR_B, DIR_A, "none", MS_BIND, NULL);
+	SAFE_MOUNT("none", DIR_A, "none", tc->prop_type, NULL);
+	read_mnt_id(DIR_A, &mnt_id_old, &mnt_id);
+
+	memset(st_mount, 0, sizeof(struct statmount));
+
+	TST_EXP_PASS(statmount(mnt_id, STATMOUNT_MNT_BASIC, st_mount,
+		sizeof(struct statmount), 0));
+
+	SAFE_UMOUNT(DIR_A);
+
+	if (!TST_PASS)
+		return;
+
+	mnt_peer_group = tc->prop_type == MS_SHARED ? read_peer_group(DIR_A) : 0;
+	mnt_master = tc->prop_type == MS_SLAVE ? read_peer_group(DIR_A) : 0;
+
+	TST_EXP_EQ_LI(st_mount->mask, STATMOUNT_MNT_BASIC);
+	TST_EXP_EQ_LI(st_mount->size, sizeof(struct statmount));
+	TST_EXP_EQ_LI(st_mount->mnt_id, mnt_id);
+	TST_EXP_EQ_LI(st_mount->mnt_id_old, mnt_id_old);
+	TST_EXP_EQ_LI(st_mount->mnt_parent_id, parent_id);
+	TST_EXP_EQ_LI(st_mount->mnt_parent_id_old, parent_id_old);
+	TST_EXP_EQ_LU(st_mount->mnt_propagation & tc->prop_type, tc->prop_type);
+	TST_EXP_EQ_LI(st_mount->mnt_master, mnt_master);
+	TST_EXP_EQ_LI(st_mount->mnt_peer_group, mnt_peer_group);
+}
+
+static void setup(void)
+{
+	SAFE_MKDIR(DIR_A, 0700);
+	SAFE_MKDIR(DIR_B, 0700);
+
+	SAFE_UNSHARE(CLONE_NEWNS);
+	SAFE_MOUNT("none", "/", "none", MS_REC | MS_PRIVATE, NULL);
+
+	SAFE_MOUNT(DIR_B, DIR_B, "none", MS_BIND, NULL);
+	SAFE_MOUNT("none", DIR_B, "none", MS_SHARED, NULL);
+
+	read_mnt_id(DIR_A, &parent_id_old, &parent_id);
+}
+
+static void cleanup(void)
+{
+	if (tst_is_mounted(DIR_B))
+		SAFE_UMOUNT(DIR_B);
+
+	if (tst_is_mounted(DIR_A))
+		SAFE_UMOUNT(DIR_A);
+}
+
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "6.8",
+	.needs_tmpdir = 1,
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = sizeof(struct statmount)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount04.c b/testcases/kernel/syscalls/statmount/statmount04.c
new file mode 100644
index 000000000..509fdf6a1
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount04.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that statmount() is correctly reading propagation from
+ * what mount in current namespace using STATMOUNT_PROPAGATE_FROM.
+ *
+ * [Algorithm]
+ *
+ * - create a mount point
+ * - propagate a mounted folder inside the mount point
+ * - run statmount() on the mount point using STATMOUNT_PROPAGATE_FROM
+ * - read results and check propagated_from parameter contains the propagated
+ *   folder ID
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+
+#define MNTPOINT "mntpoint"
+#define DIR_A MNTPOINT "/LTP_DIR_A"
+#define DIR_C_SUBFOLDER "/LTP_DIR_A/propagated"
+#define DIR_C (MNTPOINT DIR_C_SUBFOLDER)
+#define DIR_B MNTPOINT "/LTP_DIR_B"
+#define DIR_D MNTPOINT "/LTP_DIR_B/propagated"
+
+static uint64_t peer_group_id;
+static uint64_t dird_id;
+static struct statmount *st_mount;
+
+static void run(void)
+{
+	memset(st_mount, 0, sizeof(struct statmount));
+
+	TST_EXP_PASS(statmount(dird_id, STATMOUNT_PROPAGATE_FROM, st_mount,
+		sizeof(struct statmount), 0));
+
+	if (!TST_PASS)
+		return;
+
+	TST_EXP_EQ_LI(st_mount->mask, STATMOUNT_PROPAGATE_FROM);
+	TST_EXP_EQ_LI(st_mount->size, sizeof(struct statmount));
+	TST_EXP_EQ_LI(st_mount->propagate_from, peer_group_id);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+
+	/* create DIR_A / DIR_C structure with DIR_C mounted */
+	SAFE_MKDIR(DIR_A, 0700);
+	SAFE_MOUNT(DIR_A, DIR_A, "none", MS_BIND, NULL);
+	SAFE_MOUNT("none", DIR_A, "none", MS_SHARED, NULL);
+
+	SAFE_MKDIR(DIR_C, 0700);
+	SAFE_MOUNT(DIR_C, DIR_C, "none", MS_BIND, NULL);
+	SAFE_MOUNT("none", DIR_C, "none", MS_SHARED, NULL);
+
+	/* DIR_A mounts into DIR_B. DIR_D is propagated */
+	SAFE_MKDIR(DIR_B, 0700);
+	SAFE_MOUNT(DIR_A, DIR_B, "none", MS_BIND, NULL);
+	SAFE_MOUNT("none", DIR_B, "none", MS_SLAVE, NULL);
+
+	SAFE_STATX(AT_FDCWD, DIR_D, 0, STATX_MNT_ID_UNIQUE, &sx);
+	dird_id = sx.data.stx_mnt_id;
+
+	peer_group_id = read_peer_group(DIR_A);
+}
+
+static void cleanup(void)
+{
+	if (tst_is_mounted(DIR_C))
+		SAFE_UMOUNT(DIR_C);
+
+	if (tst_is_mounted(DIR_B))
+		SAFE_UMOUNT(DIR_B);
+
+	if (tst_is_mounted(DIR_A))
+		SAFE_UMOUNT(DIR_A);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *const []) {
+		"fuse",
+		NULL
+	},
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = sizeof(struct statmount)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount05.c b/testcases/kernel/syscalls/statmount/statmount05.c
new file mode 100644
index 000000000..95e674c06
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount05.c
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies STATMOUNT_MNT_ROOT and STATMOUNT_MNT_POINT functionalities
+ * of statmount(). In particular, STATMOUNT_MNT_ROOT will give the mount root
+ * (i.e. mount --bind /mnt /bla -> /mnt) and STATMOUNT_MNT_POINT will
+ * give the mount point (i.e. mount --bind /mnt /bla -> /bla).
+ *
+ * [Algorithm]
+ *
+ * - create a mount point
+ * - mount a folder inside the mount point
+ * - run statmount() on the mounted folder using STATMOUNT_MNT_ROOT
+ * - read results and check if contain the mount root path
+ * - run statmount() on the mounted folder using STATMOUNT_MNT_POINT
+ * - read results and check if contain the mount point path
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+#include "tst_tmpdir.h"
+
+#define MNTPOINT "mntpoint"
+#define DIRA MNTPOINT "/LTP_DIR_A"
+#define DIRB MNTPOINT "/LTP_DIR_B"
+#define SM_SIZE (1 << 10)
+
+static uint64_t root_id;
+static struct statmount *st_mount;
+static char *mnt_root;
+static char *mnt_point;
+
+static void test_mount_root(void)
+{
+	tst_res(TINFO, "Testing STATMOUNT_MNT_ROOT");
+
+	char *last_root;
+
+	memset(st_mount, 0, SM_SIZE);
+
+	TST_EXP_PASS(statmount(root_id, STATMOUNT_MNT_ROOT, st_mount,
+		SM_SIZE, 0));
+
+	if (!TST_PASS)
+		return;
+
+	last_root = strrchr(mnt_root, '/');
+
+	TST_EXP_EQ_LI(st_mount->mask, STATMOUNT_MNT_ROOT);
+	TST_EXP_EQ_STR(st_mount->str + st_mount->mnt_root, last_root);
+}
+
+static void test_mount_point(void)
+{
+	tst_res(TINFO, "Testing STATMOUNT_MNT_POINT");
+
+	memset(st_mount, 0, SM_SIZE);
+
+	TST_EXP_POSITIVE(statmount(root_id, STATMOUNT_MNT_POINT, st_mount,
+		SM_SIZE, 0));
+
+	if (!TST_PASS)
+		return;
+
+	TST_EXP_EQ_LI(st_mount->mask, STATMOUNT_MNT_POINT);
+	TST_EXP_EQ_STR(st_mount->str + st_mount->mnt_point, mnt_point);
+}
+
+static void run(void)
+{
+	test_mount_root();
+	test_mount_point();
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+
+	mnt_root = tst_tmpdir_genpath(DIRA);
+	mnt_point = tst_tmpdir_genpath(DIRB);
+
+	SAFE_MKDIR(mnt_root, 0700);
+	SAFE_MKDIR(mnt_point, 0700);
+	SAFE_MOUNT(mnt_root, mnt_point, "none", MS_BIND, NULL);
+
+	SAFE_STATX(AT_FDCWD, mnt_point, 0, STATX_MNT_ID_UNIQUE, &sx);
+	root_id = sx.data.stx_mnt_id;
+}
+
+static void cleanup(void)
+{
+	if (tst_is_mounted(DIRB))
+		SAFE_UMOUNT(DIRB);
+
+	if (tst_is_mounted(DIRA))
+		SAFE_UMOUNT(DIRA);
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.cleanup = cleanup,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *const []) {
+		"fuse",
+		NULL
+	},
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = SM_SIZE},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount06.c b/testcases/kernel/syscalls/statmount/statmount06.c
new file mode 100644
index 000000000..73740407e
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount06.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that statmount() is correctly reading name of the
+ * filesystem type using STATMOUNT_FS_TYPE.
+ *
+ * [Algorithm]
+ *
+ * - create a mount point
+ * - run statmount() on the mount point using STATMOUNT_FS_TYPE
+ * - read results and check if contain the name of the filesystem
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+#include "lapi/sched.h"
+
+#define MNTPOINT "mntpoint"
+#define SM_SIZE (1 << 10)
+
+static uint64_t root_id;
+static struct statmount *st_mount;
+
+static void run(void)
+{
+	memset(st_mount, 0, SM_SIZE);
+
+	TST_EXP_PASS(statmount(root_id,	STATMOUNT_FS_TYPE, st_mount,
+		SM_SIZE, 0));
+
+	if (!TST_PASS)
+		return;
+
+	TST_EXP_EQ_LI(st_mount->mask, STATMOUNT_FS_TYPE);
+	TST_EXP_EQ_STR(st_mount->str + st_mount->fs_type, tst_device->fs_type);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+
+	SAFE_STATX(AT_FDCWD, MNTPOINT, 0, STATX_MNT_ID_UNIQUE, &sx);
+	root_id = sx.data.stx_mnt_id;
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *const []) {
+		"fuse",
+		NULL
+	},
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = SM_SIZE},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount07.c b/testcases/kernel/syscalls/statmount/statmount07.c
new file mode 100644
index 000000000..fc4f20479
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount07.c
@@ -0,0 +1,124 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * This test verifies that statmount() is raising the correct errors according
+ * with invalid input values.
+ */
+
+#define _GNU_SOURCE
+
+#include "statmount.h"
+#include "lapi/stat.h"
+
+#define MNTPOINT "mntpoint"
+
+static struct statmount *st_mount;
+static struct statmount *st_mount_null;
+static struct statmount *st_mount_small;
+static struct statmount *st_mount_bad;
+static uint64_t mnt_id;
+static uint64_t mnt_id_dont_exist = -1;
+static size_t buff_size;
+
+struct tcase {
+	int exp_errno;
+	char *msg;
+	uint64_t *mnt_id;
+	uint64_t mask;
+	unsigned int flags;
+	struct statmount **buff;
+} tcases[] = {
+	{
+		.exp_errno = ENOENT,
+		.msg = "mount id doesn't exist'",
+		.mnt_id = &mnt_id_dont_exist,
+		.buff = &st_mount
+	},
+	{
+		.exp_errno = EOVERFLOW,
+		.msg = "invalid mask",
+		.mnt_id = &mnt_id,
+		.mask = -1,
+		.buff = &st_mount
+	},
+	{
+		.exp_errno = EOVERFLOW,
+		.msg = "small buffer for fs type",
+		.mnt_id = &mnt_id,
+		.mask = STATMOUNT_FS_TYPE,
+		.buff = &st_mount_small,
+	},
+	{
+		.exp_errno = EOVERFLOW,
+		.msg = "small buffer for mnt root",
+		.mnt_id = &mnt_id,
+		.mask = STATMOUNT_MNT_ROOT,
+		.buff = &st_mount_small,
+	},
+	{
+		.exp_errno = EOVERFLOW,
+		.msg = "small buffer for mnt point",
+		.mnt_id = &mnt_id,
+		.mask = STATMOUNT_MNT_POINT,
+		.buff = &st_mount_small,
+	},
+	{
+		.exp_errno = EINVAL,
+		.msg = "flags must be zero",
+		.mnt_id = &mnt_id,
+		.flags = 1,
+		.buff = &st_mount,
+	},
+	{
+		.exp_errno = EFAULT,
+		.msg = "buffer crosses to PROT_NONE",
+		.mnt_id = &mnt_id,
+		.buff = &st_mount_bad,
+	},
+	{
+		.exp_errno = EFAULT,
+		.msg = "invalid buffer pointer",
+		.mnt_id = &mnt_id,
+		.buff = &st_mount_null,
+	},
+};
+
+static void run(unsigned int n)
+{
+	struct tcase *tc = &tcases[n];
+
+	memset(st_mount, 0, sizeof(struct statmount));
+
+	TST_EXP_FAIL(statmount(*tc->mnt_id, tc->mask,
+		*tc->buff, buff_size, tc->flags),
+		tc->exp_errno, "%s", tc->msg);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+
+	SAFE_STATX(AT_FDCWD, MNTPOINT, 0, STATX_MNT_ID_UNIQUE, &sx);
+
+	mnt_id = sx.data.stx_mnt_id;
+	buff_size = sizeof(struct statmount);
+}
+static struct tst_test test = {
+	.test = run,
+	.tcnt = ARRAY_SIZE(tcases),
+	.setup = setup,
+	.min_kver = "6.8",
+	.mount_device = 1,
+	.mntpoint = MNTPOINT,
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = sizeof(struct statmount)},
+		{&st_mount_small, .size = sizeof(struct statmount)},
+		{&st_mount_bad, .size = 1},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statmount/statmount08.c b/testcases/kernel/syscalls/statmount/statmount08.c
new file mode 100644
index 000000000..21b8b7342
--- /dev/null
+++ b/testcases/kernel/syscalls/statmount/statmount08.c
@@ -0,0 +1,65 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that statmount() raises EPERM when mount point is not accessible.
+ */
+
+#define _GNU_SOURCE
+
+#include <pwd.h>
+#include "statmount.h"
+#include "lapi/stat.h"
+
+static struct statmount *st_mount;
+static uint64_t root_id;
+static gid_t nobody_gid;
+static uid_t nobody_uid;
+
+static void run(void)
+{
+	if (SAFE_FORK())
+		return;
+
+	SAFE_SETEGID(nobody_gid);
+	SAFE_SETEUID(nobody_uid);
+
+	memset(st_mount, 0, sizeof(struct statmount));
+
+	TST_EXP_FAIL(statmount(root_id,	STATMOUNT_SB_BASIC, st_mount,
+		sizeof(struct statmount), 0), EPERM);
+
+	exit(0);
+}
+
+static void setup(void)
+{
+	struct ltp_statx sx;
+	struct passwd *pw;
+
+	pw = SAFE_GETPWNAM("nobody");
+	nobody_gid = pw->pw_gid;
+	nobody_uid = pw->pw_uid;
+
+	SAFE_STATX(AT_FDCWD, "/", 0, STATX_MNT_ID_UNIQUE, &sx);
+	root_id = sx.data.stx_mnt_id;
+
+	SAFE_CHROOT(tst_tmpdir_path());
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.setup = setup,
+	.needs_root = 1,
+	.needs_tmpdir = 1,
+	.forks_child = 1,
+	.min_kver = "6.8",
+	.bufs = (struct tst_buffers []) {
+		{&st_mount, .size = sizeof(struct statmount)},
+		{}
+	}
+};
diff --git a/testcases/kernel/syscalls/statx/statx05.c b/testcases/kernel/syscalls/statx/statx05.c
index 9781b3e70..2411f3f9f 100644
--- a/testcases/kernel/syscalls/statx/statx05.c
+++ b/testcases/kernel/syscalls/statx/statx05.c
@@ -121,7 +121,10 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.needs_device = 1,
 	.mntpoint = MNTPOINT,
-	.dev_fs_type = "ext4",
+	.filesystems = (struct tst_fs []) {
+		{.type = "ext4"},
+		{}
+	},
 	.needs_cmds = (const char *[]) {
 		"mkfs.ext4 >= 1.43.0",
 		"e4crypt",
diff --git a/testcases/kernel/syscalls/statx/statx06.c b/testcases/kernel/syscalls/statx/statx06.c
index 1771dff49..d3dd9b9cf 100644
--- a/testcases/kernel/syscalls/statx/statx06.c
+++ b/testcases/kernel/syscalls/statx/statx06.c
@@ -155,7 +155,12 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.mntpoint = MOUNT_POINT,
 	.mount_device = 1,
-	.dev_fs_type = "ext4",
-	.dev_fs_opts = (const char *const []){"-I", "256", NULL},
-	.mnt_flags = MS_STRICTATIME,
+	.filesystems = (struct tst_fs[]) {
+		{
+			.type = "ext4",
+			.mkfs_opts = (const char *const []){"-I", "256", NULL},
+			.mnt_flags = MS_STRICTATIME,
+		},
+		{}
+	},
 };
diff --git a/testcases/kernel/syscalls/statx/statx07.c b/testcases/kernel/syscalls/statx/statx07.c
index 1a568ec9e..968174330 100644
--- a/testcases/kernel/syscalls/statx/statx07.c
+++ b/testcases/kernel/syscalls/statx/statx07.c
@@ -54,7 +54,6 @@
 #define SERV_FORCE_SYNC "server/force_sync_file"
 #define SERV_DONT_SYNC "server/dont_sync_file"
 
-static char *cwd;
 static char cmd[BUFF_SIZE];
 static int mounted;
 static int exported;
@@ -116,8 +115,6 @@ static void setup(void)
 	int ret;
 	char server_path[BUFF_SIZE];
 
-	cwd = tst_get_tmpdir();
-
 	mode_t old_umask = umask(0);
 
 	SAFE_MKDIR(SERV_PATH, DEFAULT_MODE);
@@ -127,7 +124,7 @@ static void setup(void)
 
 	umask(old_umask);
 
-	snprintf(server_path, sizeof(server_path), ":%s/%s", cwd, SERV_PATH);
+	snprintf(server_path, sizeof(server_path), ":%s/%s", tst_tmpdir_path(), SERV_PATH);
 
 	snprintf(cmd, sizeof(cmd),
 		 "exportfs -i -o no_root_squash,rw,sync,no_subtree_check,fsid=%d *%.1024s",
@@ -155,7 +152,7 @@ static void cleanup(void)
 	if (!exported)
 		return;
 	snprintf(cmd, sizeof(cmd),
-		 "exportfs -u *:%s/%s", cwd, SERV_PATH);
+		 "exportfs -u *:%s/%s", tst_tmpdir_path(), SERV_PATH);
 
 	if (tst_system(cmd) == -1)
 		tst_res(TWARN | TST_ERR, "failed to clear exportfs");
@@ -168,7 +165,10 @@ static struct tst_test test = {
 	.cleanup = cleanup,
 	.min_kver = "4.16",
 	.needs_tmpdir = 1,
-	.dev_fs_type = "nfs",
+	.filesystems = (struct tst_fs []) {
+		{.type = "nfs"},
+		{}
+	},
 	.needs_root = 1,
 	.needs_cmds = (const char *[]) {
 		"exportfs",
diff --git a/testcases/kernel/syscalls/statx/statx09.c b/testcases/kernel/syscalls/statx/statx09.c
index 6e75ff3ec..864e35c7d 100644
--- a/testcases/kernel/syscalls/statx/statx09.c
+++ b/testcases/kernel/syscalls/statx/statx09.c
@@ -156,7 +156,10 @@ static struct tst_test test = {
 	.needs_root = 1,
 	.needs_device = 1,
 	.mntpoint = MNTPOINT,
-	.dev_fs_type = "ext4",
+	.filesystems = (struct tst_fs []) {
+		{.type = "ext4"},
+		{}
+	},
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_FS_VERITY",
 		NULL
diff --git a/testcases/kernel/syscalls/swapoff/Makefile b/testcases/kernel/syscalls/swapoff/Makefile
index 6954112a8..c39c321ea 100644
--- a/testcases/kernel/syscalls/swapoff/Makefile
+++ b/testcases/kernel/syscalls/swapoff/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpswap
+LTPLIBS = swap
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/swapoff/swapoff01.c b/testcases/kernel/syscalls/swapoff/swapoff01.c
index 314630267..e97ff2c62 100644
--- a/testcases/kernel/syscalls/swapoff/swapoff01.c
+++ b/testcases/kernel/syscalls/swapoff/swapoff01.c
@@ -53,5 +53,6 @@ static struct tst_test test = {
 	.all_filesystems = 1,
 	.needs_root = 1,
 	.test_all = verify_swapoff,
+	.timeout = 60,
 	.setup = setup
 };
diff --git a/testcases/kernel/syscalls/swapon/Makefile b/testcases/kernel/syscalls/swapon/Makefile
index 6954112a8..c39c321ea 100644
--- a/testcases/kernel/syscalls/swapon/Makefile
+++ b/testcases/kernel/syscalls/swapon/Makefile
@@ -3,7 +3,7 @@
 
 top_srcdir		?= ../../../..
 
-LTPLIBS = ltpswap
+LTPLIBS = swap
 
 include $(top_srcdir)/include/mk/testcases.mk
 
diff --git a/testcases/kernel/syscalls/swapon/swapon01.c b/testcases/kernel/syscalls/swapon/swapon01.c
index 49915c32d..7d1ec7070 100644
--- a/testcases/kernel/syscalls/swapon/swapon01.c
+++ b/testcases/kernel/syscalls/swapon/swapon01.c
@@ -51,5 +51,6 @@ static struct tst_test test = {
 	.all_filesystems = 1,
 	.needs_cgroup_ctrls = (const char *const []){ "memory", NULL },
 	.test_all = verify_swapon,
+	.timeout = 60,
 	.setup = setup
 };
diff --git a/testcases/kernel/syscalls/syscall/syscall01.c b/testcases/kernel/syscalls/syscall/syscall01.c
index 76e793221..356eb8f0d 100644
--- a/testcases/kernel/syscalls/syscall/syscall01.c
+++ b/testcases/kernel/syscalls/syscall/syscall01.c
@@ -3,10 +3,15 @@
  * Copyright (c) International Business Machines Corp., 2002
  * 01/02/2003	Port to LTP avenkat@us.ibm.com
  * 06/30/2001	Port to Linux nsharoff@us.ibm.com
+ * Copyright (c) Linux Test Project, 2002-2024
  */
 
-/*
+/*\
+ * [Description]
+ *
  * Basic test for syscall().
+ *
+ * Compare raw get{g,p,u}id results with their glibc wrappers.
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/tee/tee02.c b/testcases/kernel/syscalls/tee/tee02.c
index 5ebb3c3f6..945261223 100644
--- a/testcases/kernel/syscalls/tee/tee02.c
+++ b/testcases/kernel/syscalls/tee/tee02.c
@@ -3,15 +3,15 @@
  * Copyright (c) 2014 Fujitsu Ltd.
  * Author: Xing Gu <gux.fnst@cn.fujitsu.com>
  */
-/*
- * Description:
- *   Verify that,
- *   1) tee() returns -1 and sets errno to EINVAL if fd_in does
- *      not refer to a pipe.
- *   2) tee() returns -1 and sets errno to EINVAL if fd_out does
- *      not refer to a pipe.
- *   3) tee() returns -1 and sets errno to EINVAL if fd_in and
- *      fd_out refer to the same pipe.
+
+/*\
+ * [Description]
+ *
+ * Verify that, tee(2) returns -1 and sets errno to:
+ *
+ * 1. EINVAL if fd_in does not refer to a pipe.
+ * 2. EINVAL if fd_out does not refer to a pipe.
+ * 3. EINVAL if fd_in and fd_out refer to the same pipe.
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/timer_settime/timer_settime01.c b/testcases/kernel/syscalls/timer_settime/timer_settime01.c
index 1d9d5e49b..f8e7ffa22 100644
--- a/testcases/kernel/syscalls/timer_settime/timer_settime01.c
+++ b/testcases/kernel/syscalls/timer_settime/timer_settime01.c
@@ -58,14 +58,18 @@ static struct time64_variants variants[] = {
 
 static volatile int caught_signal;
 
-static void clear_signal(void)
+static void clear_signal(clock_t clock, const struct tst_ts *exptime)
 {
+	struct time64_variants *tv = &variants[tst_variant];
+	struct tst_ts curtime = { .type = tv->ts_type };
+
 	/*
 	 * The busy loop is intentional. The signal is sent after X
 	 * seconds of CPU time has been accumulated for the process and
 	 * thread specific clocks.
 	 */
-	while (!caught_signal);
+	while (!caught_signal)
+		;
 
 	if (caught_signal != SIGALRM) {
 		tst_res(TFAIL, "Received incorrect signal: %s",
@@ -73,6 +77,17 @@ static void clear_signal(void)
 	}
 
 	caught_signal = 0;
+
+	if (tv->clock_gettime(clock, tst_ts_get(&curtime)) < 0) {
+		tst_res(TFAIL, "clock_gettime(%s) failed",
+			get_clock_str(clock));
+		return;
+	}
+
+	if (tst_ts_lt(curtime, *exptime)) {
+		tst_res(TFAIL, "Timer %s expired too early",
+			get_clock_str(clock));
+	}
 }
 
 static void sighandler(int sig)
@@ -115,22 +130,22 @@ static void run(unsigned int n)
 		memset(&new_set, 0, sizeof(new_set));
 		memset(&old_set, 0, sizeof(old_set));
 
-		new_set.type = old_set.type = tv->ts_type;
+		new_set.type = old_set.type = timenow.type = tv->ts_type;
 		val = tc->it_value_tv_usec;
 
-		if (tc->flag & TIMER_ABSTIME) {
-			timenow.type = tv->ts_type;
-			if (tv->clock_gettime(clock, tst_ts_get(&timenow)) < 0) {
-				tst_res(TFAIL,
-					"clock_gettime(%s) failed - skipping the test",
-					get_clock_str(clock));
-				continue;
-			}
-			tst_ts_add_us(timenow, val);
+		if (tv->clock_gettime(clock, tst_ts_get(&timenow)) < 0) {
+			tst_res(TFAIL,
+				"clock_gettime(%s) failed - skipping the test",
+				get_clock_str(clock));
+			continue;
+		}
+
+		timenow = tst_ts_add_us(timenow, val);
+
+		if (tc->flag & TIMER_ABSTIME)
 			tst_its_set_value_from_ts(&new_set, timenow);
-		} else {
+		else
 			tst_its_set_value_from_us(&new_set, val);
-		}
 
 		tst_its_set_interval_from_us(&new_set, tc->it_interval_tv_usec);
 
@@ -156,11 +171,14 @@ static void run(unsigned int n)
 				tst_its_get_value_nsec(new_set));
 		}
 
-		clear_signal();
+		clear_signal(clock, &timenow);
 
 		/* Wait for another event when interval was set */
-		if (tc->it_interval_tv_usec)
-			clear_signal();
+		if (tc->it_interval_tv_usec) {
+			timenow = tst_ts_add_us(timenow,
+				tc->it_interval_tv_usec);
+			clear_signal(clock, &timenow);
+		}
 
 		tst_res(TPASS, "timer_settime(%s) passed",
 			get_clock_str(clock));
diff --git a/testcases/kernel/syscalls/timer_settime/timer_settime02.c b/testcases/kernel/syscalls/timer_settime/timer_settime02.c
index 2723dc03d..de8607619 100644
--- a/testcases/kernel/syscalls/timer_settime/timer_settime02.c
+++ b/testcases/kernel/syscalls/timer_settime/timer_settime02.c
@@ -29,10 +29,11 @@
 #include "tst_timer.h"
 
 static struct tst_its new_set, old_set;
-static struct tst_its *pnew_set = &new_set, *pold_set = &old_set, *null_set = NULL;
+static struct tst_its *pnew_set = &new_set, *pold_set = &old_set, *null_set;
 static void *faulty_set;
 static kernel_timer_t timer;
 static kernel_timer_t timer_inval = (kernel_timer_t)-1;
+static volatile int caught_sig;
 
 /* separate description-array to (hopefully) improve readability */
 static const char * const descriptions[] = {
@@ -69,10 +70,16 @@ static struct time64_variants variants[] = {
 #endif
 };
 
+static void sighandler(int sig)
+{
+	caught_sig = sig;
+}
+
 static void setup(void)
 {
 	tst_res(TINFO, "Testing variant: %s", variants[tst_variant].desc);
 	faulty_set = tst_get_bad_addr(NULL);
+	signal(SIGALRM, sighandler);
 }
 
 static void run(unsigned int n)
@@ -87,6 +94,8 @@ static void run(unsigned int n)
 	for (i = 0; i < CLOCKS_DEFINED; ++i) {
 		clock_t clock = clock_list[i];
 
+		caught_sig = 0;
+
 		/* Init temporary timer */
 		TEST(tst_syscall(__NR_timer_create, clock, NULL, &timer));
 		if (TST_RET != 0) {
@@ -131,6 +140,12 @@ static void run(unsigned int n)
 		TEST(tst_syscall(__NR_timer_delete, timer));
 		if (TST_RET != 0)
 			tst_res(TFAIL | TTERRNO, "timer_delete() failed!");
+
+		if (caught_sig) {
+			tst_res(TFAIL,
+				"Caught unexpected signal %s while testing %s",
+				tst_strsig(caught_sig), get_clock_str(clock));
+		}
 	}
 }
 
diff --git a/testcases/kernel/syscalls/timer_settime/timer_settime03.c b/testcases/kernel/syscalls/timer_settime/timer_settime03.c
index a828f63d3..005bcf4c5 100644
--- a/testcases/kernel/syscalls/timer_settime/timer_settime03.c
+++ b/testcases/kernel/syscalls/timer_settime/timer_settime03.c
@@ -67,7 +67,7 @@ static void setup(void)
 	SAFE_CLOCK_GETRES(CLOCK_REALTIME, &realtime_resolution);
 
 	tst_res(TINFO, "CLOCK_REALTIME resolution %lins",
-	        (long)realtime_resolution.tv_nsec);
+		(long)realtime_resolution.tv_nsec);
 }
 
 static void run(void)
@@ -93,7 +93,9 @@ static void run(void)
 	spec.it_interval.tv_nsec = realtime_resolution.tv_nsec;
 
 	SAFE_TIMER_SETTIME(timer, TIMER_ABSTIME, &spec, NULL);
-	while (!handler_called);
+	while (!handler_called)
+		;
+
 	errno = saved_errno;
 
 	if (overrun == -1)
diff --git a/testcases/kernel/syscalls/timerfd/timerfd_settime02.c b/testcases/kernel/syscalls/timerfd/timerfd_settime02.c
index 33d9f7b46..769ff3647 100644
--- a/testcases/kernel/syscalls/timerfd/timerfd_settime02.c
+++ b/testcases/kernel/syscalls/timerfd/timerfd_settime02.c
@@ -111,7 +111,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 150,
+	.runtime = 150,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "1e38da300e1e"},
 		{"CVE", "2017-10661"},
diff --git a/testcases/kernel/syscalls/unlink/.gitignore b/testcases/kernel/syscalls/unlink/.gitignore
index 6038cc29d..4fc24059a 100644
--- a/testcases/kernel/syscalls/unlink/.gitignore
+++ b/testcases/kernel/syscalls/unlink/.gitignore
@@ -2,3 +2,4 @@
 /unlink07
 /unlink08
 /unlink09
+/unlink10
diff --git a/testcases/kernel/syscalls/unlink/unlink09.c b/testcases/kernel/syscalls/unlink/unlink09.c
index cc4b4a07e..55bc4ab27 100644
--- a/testcases/kernel/syscalls/unlink/unlink09.c
+++ b/testcases/kernel/syscalls/unlink/unlink09.c
@@ -2,92 +2,103 @@
 /*
  * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
  * Author: Yang Xu <xuyang2018.jy@fujitsu.com>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
  */
 
 /*\
  * [Description]
  *
- * Verify that unlink(2) fails with
- *
- * - EPERM when target file is marked as immutable or append-only
- * - EROFS when target file is on a read-only filesystem.
+ * Verify that unlink(2) fails with EPERM when target file is marked as
+ * immutable or append-only.
  */
 
 #include <sys/ioctl.h>
 #include "tst_test.h"
 #include "lapi/fs.h"
 
-#define TEST_EPERM_IMMUTABLE "test_eperm_immutable"
-#define TEST_EPERM_APPEND_ONLY "test_eperm_append_only"
-#define DIR_EROFS "erofs"
-#define TEST_EROFS "erofs/test_erofs"
+#define MNTPOINT "mnt"
+#define TEST_EPERM_IMMUTABLE MNTPOINT"/test_eperm_immutable"
+#define TEST_EPERM_APPEND_ONLY MNTPOINT"/test_eperm_append_only"
 
-static int fd_immutable;
-static int fd_append_only;
+static int fd_immutable = -1;
+static int fd_append_only = -1;
 
 static struct test_case_t {
 	char *filename;
 	int *fd;
 	int flag;
-	int expected_errno;
 	char *desc;
 } tcases[] = {
-	{TEST_EPERM_IMMUTABLE, &fd_immutable, FS_IMMUTABLE_FL, EPERM,
+	{TEST_EPERM_IMMUTABLE, &fd_immutable, FS_IMMUTABLE_FL,
 		"target file is immutable"},
-	{TEST_EPERM_APPEND_ONLY, &fd_append_only, FS_APPEND_FL, EPERM,
+	{TEST_EPERM_APPEND_ONLY, &fd_append_only, FS_APPEND_FL,
 		"target file is append-only"},
-	{TEST_EROFS, NULL, 0, EROFS, "target file in read-only filesystem"},
 };
 
+static void setup_inode_flag(const int fd, const int flag, const int set)
+{
+	int attr;
+
+	SAFE_IOCTL(fd, FS_IOC_GETFLAGS, &attr);
+
+	if (set)
+		attr |= flag;
+	else
+		attr &= ~flag;
+
+	SAFE_IOCTL(fd, FS_IOC_SETFLAGS, &attr);
+}
+
 static void setup(void)
 {
 	int attr;
 
-	fd_immutable = SAFE_OPEN(TEST_EPERM_IMMUTABLE, O_CREAT, 0600);
-	SAFE_IOCTL(fd_immutable, FS_IOC_GETFLAGS, &attr);
+	/* inode attributes in tmpfs are supported from kernel 6.0
+	 * https://lore.kernel.org/all/20220715015912.2560575-1-tytso@mit.edu/
+	 */
+	if (!strcmp(tst_device->fs_type, "tmpfs") && tst_kvercmp(6, 0, 0) < 0)
+		tst_brk(TCONF, "FS_IOC_GETFLAGS on tmpfs not supported for kernel<6.0");
+
+	fd_immutable = SAFE_CREAT(TEST_EPERM_IMMUTABLE, 0600);
+	TEST(ioctl(fd_immutable, FS_IOC_GETFLAGS, &attr));
+
+	if (TST_RET == -1 && TST_ERR == ENOTTY) {
+		SAFE_CLOSE(fd_immutable);
+
+		tst_brk(TBROK, "Inode attributes not supported by '%s'",
+			tst_device->fs_type);
+	}
+
 	attr |= FS_IMMUTABLE_FL;
 	SAFE_IOCTL(fd_immutable, FS_IOC_SETFLAGS, &attr);
 
-	fd_append_only = SAFE_OPEN(TEST_EPERM_APPEND_ONLY, O_CREAT, 0600);
-	SAFE_IOCTL(fd_append_only, FS_IOC_GETFLAGS, &attr);
-	attr |= FS_APPEND_FL;
-	SAFE_IOCTL(fd_append_only, FS_IOC_SETFLAGS, &attr);
+	fd_append_only = SAFE_CREAT(TEST_EPERM_APPEND_ONLY, 0600);
+	setup_inode_flag(fd_append_only, FS_APPEND_FL, 1);
 }
 
 static void cleanup(void)
 {
-	int attr;
-
-	SAFE_IOCTL(fd_immutable, FS_IOC_GETFLAGS, &attr);
-	attr &= ~FS_IMMUTABLE_FL;
-	SAFE_IOCTL(fd_immutable, FS_IOC_SETFLAGS, &attr);
-	SAFE_CLOSE(fd_immutable);
+	if (fd_immutable != -1) {
+		setup_inode_flag(fd_immutable, FS_IMMUTABLE_FL, 0);
+		SAFE_CLOSE(fd_immutable);
+	}
 
-	SAFE_IOCTL(fd_append_only, FS_IOC_GETFLAGS, &attr);
-	attr &= ~FS_APPEND_FL;
-	SAFE_IOCTL(fd_append_only, FS_IOC_SETFLAGS, &attr);
-	SAFE_CLOSE(fd_append_only);
+	if (fd_append_only != -1) {
+		setup_inode_flag(fd_append_only, FS_APPEND_FL, 0);
+		SAFE_CLOSE(fd_append_only);
+	}
 }
 
 static void verify_unlink(unsigned int i)
 {
 	struct test_case_t *tc = &tcases[i];
-	int attr;
 
-	TST_EXP_FAIL(unlink(tc->filename), tc->expected_errno, "%s", tc->desc);
+	TST_EXP_FAIL(unlink(tc->filename), EPERM, "%s", tc->desc);
 
 	/* If unlink() succeeded unexpectedly, test file should be restored. */
 	if (!TST_RET) {
-		if (tc->fd) {
-			*(tc->fd) = SAFE_OPEN(tc->filename, O_CREAT, 0600);
-			if (tc->flag) {
-				SAFE_IOCTL(*(tc->fd), FS_IOC_GETFLAGS, &attr);
-				attr |= tc->flag;
-				SAFE_IOCTL(*(tc->fd), FS_IOC_SETFLAGS, &attr);
-			}
-		} else {
-			SAFE_TOUCH(tc->filename, 0600, 0);
-		}
+		*(tc->fd) = SAFE_CREAT(tc->filename, 0600);
+		setup_inode_flag(*(tc->fd), tc->flag, 1);
 	}
 }
 
@@ -96,7 +107,15 @@ static struct tst_test test = {
 	.tcnt = ARRAY_SIZE(tcases),
 	.cleanup = cleanup,
 	.test = verify_unlink,
-	.needs_rofs = 1,
-	.mntpoint = DIR_EROFS,
+	.mntpoint = MNTPOINT,
 	.needs_root = 1,
+	.mount_device = 1,
+	.all_filesystems = 1,
+	.skip_filesystems = (const char *const[]) {
+		"fuse",
+		"exfat",
+		"vfat",
+		"ntfs",
+		NULL
+	},
 };
diff --git a/testcases/kernel/syscalls/unlink/unlink10.c b/testcases/kernel/syscalls/unlink/unlink10.c
new file mode 100644
index 000000000..861f24a50
--- /dev/null
+++ b/testcases/kernel/syscalls/unlink/unlink10.c
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 FUJITSU LIMITED. All Rights Reserved.
+ * Author: Yang Xu <xuyang2018.jy@fujitsu.com>
+ * Copyright (C) 2024 SUSE LLC Andrea Cervesato <andrea.cervesato@suse.com>
+ */
+
+/*\
+ * [Description]
+ *
+ * Verify that unlink(2) fails with EROFS when target file is on a read-only
+ * filesystem.
+ */
+
+#include <sys/ioctl.h>
+#include "tst_test.h"
+#include "lapi/fs.h"
+
+#define MNTPOINT "erofs"
+#define FILENAME MNTPOINT"/file"
+
+static void run(void)
+{
+	TST_EXP_FAIL(unlink(FILENAME), EROFS,
+		"%s", "target file in read-only filesystem");
+}
+
+static struct tst_test test = {
+	.test_all = run,
+	.needs_rofs = 1,
+	.needs_root = 1,
+	.mntpoint = MNTPOINT,
+};
diff --git a/testcases/kernel/syscalls/userfaultfd/userfaultfd01.c b/testcases/kernel/syscalls/userfaultfd/userfaultfd01.c
index c2c684d2b..2e5c68709 100644
--- a/testcases/kernel/syscalls/userfaultfd/userfaultfd01.c
+++ b/testcases/kernel/syscalls/userfaultfd/userfaultfd01.c
@@ -87,6 +87,10 @@ static void run(void)
 			tst_res(TCONF, "Hint: check /proc/sys/vm/unprivileged_userfaultfd");
 			tst_brk(TCONF | TTERRNO,
 				"userfaultfd() requires CAP_SYS_PTRACE on this system");
+		} if (TST_ERR == EOPNOTSUPP) {
+			/* TODO: b/384985178 - userfaultfd is not supported when emulating 16k pages */
+			tst_brk(TCONF | TTERRNO,
+				"userfaultfd not supported when emulating 16k pages");
 		} else
 			tst_brk(TBROK | TTERRNO,
 				"Could not create userfault file descriptor");
diff --git a/testcases/kernel/syscalls/utime/utime07.c b/testcases/kernel/syscalls/utime/utime07.c
index 3aff2c8ef..8889b3a6d 100644
--- a/testcases/kernel/syscalls/utime/utime07.c
+++ b/testcases/kernel/syscalls/utime/utime07.c
@@ -43,7 +43,7 @@ static void test_utime(void)
 
 	tst_res(TINFO, "Test if utime() changes access time");
 
-	create_symlink(tst_get_tmpdir(), symname);
+	create_symlink(tst_tmpdir_path(), symname);
 	SAFE_STAT(symname, &oldsym_stat);
 
 	struct utimbuf utimes = {
diff --git a/testcases/kernel/syscalls/utimensat/utimensat01.c b/testcases/kernel/syscalls/utimensat/utimensat01.c
index efcb5c7a4..f9f5d7f6c 100644
--- a/testcases/kernel/syscalls/utimensat/utimensat01.c
+++ b/testcases/kernel/syscalls/utimensat/utimensat01.c
@@ -3,6 +3,12 @@
  * Copyright (c) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
  * Copyright (c) 2008 Subrata Modak <subrata@linux.vnet.ibm.com>
  * Copyright (c) 2020 Viresh Kumar <viresh.kumar@linaro.org>
+ * Copyright (c) Linux Test Project, 2020-2024
+ *
+ */
+
+/*\
+ * [Description]
  *
  * Basic utimnsat() test.
  */
diff --git a/testcases/kernel/syscalls/utimes/utimes01.c b/testcases/kernel/syscalls/utimes/utimes01.c
index 2bfc1654b..3c97c4053 100644
--- a/testcases/kernel/syscalls/utimes/utimes01.c
+++ b/testcases/kernel/syscalls/utimes/utimes01.c
@@ -1,25 +1,24 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (c) Crackerjack Project., 2007 ,Hitachi, Ltd
+ * Copyright (c) Crackerjack Project., 2007, Hitachi, Ltd
  * Author(s): Takahiro Yasui <takahiro.yasui.mp@hitachi.com>
+ * Copyright (c) Linux Test Project, 2014-2018
  * Ported to LTP: Manas Kumar Nayak maknayak@in.ibm.com>
  */
-/*
- * Description:
- *   Verify that,
- *   1) utimes() returns -1 and sets errno to EACCES if times
- *      is NULL, the caller's effective user ID does not match
- *      the owner of the file, the caller does not have write
- *      access to the file, and the caller is not privileged.
- *   2) utimes() returns -1 and sets errno to ENOENT if filename
- *      does not exist.
- *   3) utimes() returns -1 and sets errno to EFAULT if filename
- *      is NULL.
- *   4) utimes() returns -1 and sets errno to EPERM if times is
- *      not NULL, the caller's effective UID does not match the
- *      owner of the file, and the caller is not privileged.
- *   5) utimes() returns -1 and sets errno to EROFS if path resides
- *      on a read-only file system.
+
+/*\
+ * [Description]
+ *
+ * Verify that, utimes(2) returns -1 and sets errno to
+ *
+ * 1. EACCES if times is NULL, the caller's effective user ID does not match
+ * the owner of the file, the caller does not have write access to the file,
+ * and the caller is not privileged
+ * 2. ENOENT if filename does not exist
+ * 3. EFAULT if filename is NULL
+ * 4. EPERM if times is not NULL, the caller's effective UID does not match
+ * the owner of the file, and the caller is not privileged
+ * 5. EROFS if path resides on a read-only file system
  */
 
 #include <sys/types.h>
diff --git a/testcases/kernel/syscalls/vmsplice/vmsplice02.c b/testcases/kernel/syscalls/vmsplice/vmsplice02.c
index 8f1965c2e..24ff3c0f8 100644
--- a/testcases/kernel/syscalls/vmsplice/vmsplice02.c
+++ b/testcases/kernel/syscalls/vmsplice/vmsplice02.c
@@ -3,15 +3,15 @@
  * Copyright (c) 2014 Fujitsu Ltd.
  * Author: Xing Gu <gux.fnst@cn.fujitsu.com>
  */
-/*
- * Description:
- *   Verify that,
- *   1) vmsplice() returns -1 and sets errno to EBADF if fd
- *      is not valid.
- *   2) vmsplice() returns -1 and sets errno to EBADF if fd
- *      doesn't refer to a pipe.
- *   3) vmsplice() returns -1 and sets errno to EINVAL if
- *      nr_segs is greater than IOV_MAX.
+
+/*\
+ * [Description]
+ *
+ * Verify that, vmsplice(2) returns -1 and sets errno to:
+ *
+ * - EBADF if fd is not valid.
+ * - EBADF if fd doesn't refer to a pipe.
+ * - EINVAL if nr_segs is greater than IOV_MAX.
  */
 
 #define _GNU_SOURCE
diff --git a/testcases/kernel/syscalls/writev/writev03.c b/testcases/kernel/syscalls/writev/writev03.c
index 3575ca449..7074a418a 100644
--- a/testcases/kernel/syscalls/writev/writev03.c
+++ b/testcases/kernel/syscalls/writev/writev03.c
@@ -145,7 +145,7 @@ static struct tst_test test = {
 	.min_cpus = 2,
 	.setup = setup,
 	.cleanup = cleanup,
-	.max_runtime = 75,
+	.runtime = 75,
 	.tags = (const struct tst_tag[]) {
 		{"linux-git", "d4690f1e1cda"},
 		{}
diff --git a/testcases/kernel/uevents/Makefile b/testcases/kernel/uevents/Makefile
index d5ceb0719..12fc57dff 100644
--- a/testcases/kernel/uevents/Makefile
+++ b/testcases/kernel/uevents/Makefile
@@ -2,7 +2,7 @@
 
 top_srcdir			?= ../../..
 
-LTPLIBS = ltpuinput
+LTPLIBS = uinput
 
 uevent03: LDLIBS += -lltpuinput
 
diff --git a/testcases/kernel/uevents/uevent03.c b/testcases/kernel/uevents/uevent03.c
index 5b3dd701f..f7072db1c 100644
--- a/testcases/kernel/uevents/uevent03.c
+++ b/testcases/kernel/uevents/uevent03.c
@@ -27,6 +27,9 @@ static int mouse_fd;
 static void create_uinput_mouse(void)
 {
 	mouse_fd = open_uinput();
+	if (mouse_fd == -1)
+		tst_brk(TCONF, "Virtual device is not available");
+
 	setup_mouse_events(mouse_fd);
 	create_input_device(mouse_fd);
 }
diff --git a/testcases/lib/.gitignore b/testcases/lib/.gitignore
index e8afd06f3..385f3c3ca 100644
--- a/testcases/lib/.gitignore
+++ b/testcases/lib/.gitignore
@@ -23,3 +23,5 @@
 /tst_sleep
 /tst_supported_fs
 /tst_timeout_kill
+/tst_res_
+/tst_run_shell
diff --git a/testcases/lib/Makefile b/testcases/lib/Makefile
index 990b46089..b3a9181c1 100644
--- a/testcases/lib/Makefile
+++ b/testcases/lib/Makefile
@@ -4,6 +4,9 @@
 
 top_srcdir		?= ../..
 
+LTPLIBS = ujson
+tst_run_shell: LTPLDLIBS = -lujson
+
 include $(top_srcdir)/include/mk/testcases.mk
 
 INSTALL_TARGETS		:= *.sh
@@ -13,6 +16,7 @@ MAKE_TARGETS		:= tst_sleep tst_random tst_checkpoint tst_rod tst_kvcmp\
 			   tst_getconf tst_supported_fs tst_check_drivers tst_get_unused_port\
 			   tst_get_median tst_hexdump tst_get_free_pids tst_timeout_kill\
 			   tst_check_kconfigs tst_cgctl tst_fsfreeze tst_ns_create tst_ns_exec\
-			   tst_ns_ifmove tst_lockdown_enabled tst_secureboot_enabled
+			   tst_ns_ifmove tst_lockdown_enabled tst_secureboot_enabled tst_res_\
+			   tst_run_shell
 
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
+include $(top_srcdir)/include/mk/generic_trunk_target.mk
diff --git a/testcases/lib/run_tests.sh b/testcases/lib/run_tests.sh
new file mode 100755
index 000000000..0abca2f3c
--- /dev/null
+++ b/testcases/lib/run_tests.sh
@@ -0,0 +1,112 @@
+#!/bin/sh
+# Copyright (c) 2024 Petr Vorel <pvorel@suse.cz>
+
+TESTS_PASS="
+shell_loader.sh
+shell_loader_all_filesystems.sh
+shell_loader_c_child.sh
+shell_loader_filesystems.sh
+shell_loader_kconfigs.sh
+shell_loader_supported_archs.sh
+shell_loader_tcnt.sh
+shell_test01
+shell_test02
+shell_test03
+shell_test04
+shell_test05"
+
+TESTS_FAIL="shell_loader_tags.sh"
+
+TESTS_TBROK="
+shell_loader_invalid_block.sh
+shell_loader_invalid_metadata.sh
+shell_loader_no_metadata.sh
+shell_loader_wrong_metadata.sh"
+
+TESTS_TCONF="shell_test06"
+
+FAIL=
+
+srcdir="$(realpath $(dirname $0))"
+builddir="$srcdir"
+
+usage()
+{
+	cat << EOF
+Usage: $0 [-b DIR ] [-s TESTS]
+-b DIR   build directory (required for out-of-tree build)
+-h       print this help
+EOF
+}
+
+while getopts b:h opt; do
+	case $opt in
+		'h') usage; exit 0;;
+		'b')
+			builddir="$OPTARG/testcases/lib/"
+			if [ ! -d "$builddir" ]; then
+				echo "directory '$builddir' does not exist!" >&2
+				exit 1
+			fi
+			;;
+		*) usage; runtest_brk TBROK "Error: invalid option";;
+	esac
+done
+
+# srcdir is for *.sh, builddir for *.c
+export PATH="$PATH:$srcdir:$builddir:$srcdir/tests/:$builddir/tests/"
+
+
+tst_mask2flag()
+{
+	case "$1" in
+	0) echo TPASS;;
+	1) echo TFAIL;;
+	2) echo TBROK;;
+	4) echo TWARN;;
+	16) echo TINFO;;
+	32) echo TCONF;;
+	esac
+}
+
+run_tests()
+{
+	local exp="$1"
+	local test rc
+	shift
+
+	for test in "$@"; do
+		printf "\n*** Running '$test' (exp: $(tst_mask2flag $exp)) ***\n"
+		$test
+		rc=$?
+		if [ "$rc" = 127 ]; then
+			echo "Test '$test' not found, maybe out-of-tree build and unset builddir?" >&2
+			exit 1
+		elif [ "$rc" != "$exp" ]; then
+			FAIL="$FAIL\n* $test ($(tst_mask2flag $rc), exp: $(tst_mask2flag $exp))"
+		fi
+	done
+}
+
+run_tests 0 $TESTS_PASS
+run_tests 32 $TESTS_TCONF
+
+echo
+echo "*** Testing LTP test -h option ***"
+echo
+run_tests 0 "shell_loader.sh -h"
+
+echo
+echo "*** Testing LTP test -i option ***"
+echo
+run_tests 0 "shell_loader.sh -i 2"
+
+echo
+echo "***** RESULTS *****"
+
+if [ "$FAIL" ]; then
+	printf "Failed tests:$FAIL\n"
+	exit 1
+fi
+
+echo "All tests passed"
diff --git a/testcases/lib/tests/.gitignore b/testcases/lib/tests/.gitignore
new file mode 100644
index 000000000..e9e163d13
--- /dev/null
+++ b/testcases/lib/tests/.gitignore
@@ -0,0 +1,7 @@
+shell_test01
+shell_test02
+shell_test03
+shell_test04
+shell_test05
+shell_test06
+shell_c_child
diff --git a/testcases/lib/tests/Makefile b/testcases/lib/tests/Makefile
new file mode 100644
index 000000000..4895b71a2
--- /dev/null
+++ b/testcases/lib/tests/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 Cyril Hrubis <chrubis@suse.cz>
+
+top_srcdir		?= ../../..
+
+include $(top_srcdir)/include/mk/testcases.mk
+
+INSTALL_TARGETS=
+
+include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/lib/tests/shell_c_child.c b/testcases/lib/tests/shell_c_child.c
new file mode 100644
index 000000000..fda5133a6
--- /dev/null
+++ b/testcases/lib/tests/shell_c_child.c
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test C child example.
+ */
+
+#define TST_NO_DEFAULT_MAIN
+#include "tst_test.h"
+
+int main(void)
+{
+	tst_reinit();
+
+	tst_res(TPASS, "C child works fine!");
+
+	return 0;
+}
diff --git a/testcases/lib/tests/shell_loader.sh b/testcases/lib/tests/shell_loader.sh
new file mode 100755
index 000000000..f5d74ee63
--- /dev/null
+++ b/testcases/lib/tests/shell_loader.sh
@@ -0,0 +1,28 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# doc
+#
+# [Description]
+#
+# This is a simple shell test loader example.
+# ---
+#
+# ---
+# env
+# {
+#  "needs_tmpdir": true
+# }
+# ---
+
+. tst_loader.sh
+
+tst_res TPASS "Shell loader works fine!"
+case "$PWD" in
+	/tmp/*)
+		tst_res TPASS "We are running in temp directory in $PWD";;
+	*)
+		tst_res TFAIL "We are not running in temp directory but $PWD";;
+esac
diff --git a/testcases/lib/tests/shell_loader_all_filesystems.sh b/testcases/lib/tests/shell_loader_all_filesystems.sh
new file mode 100755
index 000000000..91fac89fd
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_all_filesystems.sh
@@ -0,0 +1,29 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# env
+# {
+#  "needs_root": true,
+#  "mount_device": true,
+#  "all_filesystems": true,
+#  "mntpoint": "ltp_mntpoint"
+# }
+# ---
+
+. tst_loader.sh
+
+tst_res TINFO "In shell"
+
+mntpath=$(realpath ltp_mntpoint)
+mounted=$(grep $mntpath /proc/mounts)
+
+if [ -n "$mounted" ]; then
+	device=$(echo $mounted |cut -d' ' -f 1)
+	path=$(echo $mounted |cut -d' ' -f 2)
+
+	tst_res TPASS "$device mounted at $path"
+else
+	tst_res TFAIL "Device not mounted!"
+fi
diff --git a/testcases/lib/tests/shell_loader_c_child.sh b/testcases/lib/tests/shell_loader_c_child.sh
new file mode 100755
index 000000000..61f138ad5
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_c_child.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# doc
+#
+# [Description]
+#
+# This is an example how to run C child from shell.
+# ---
+#
+# ---
+# env
+# {
+# }
+# ---
+
+. tst_loader.sh
+
+if [ -n "LTP_IPC_PATH" ]; then
+	tst_res TPASS "LTP_IPC_PATH=$LTP_IPC_PATH!"
+fi
+
+tst_res TINFO "Running C child"
+shell_c_child
diff --git a/testcases/lib/tests/shell_loader_filesystems.sh b/testcases/lib/tests/shell_loader_filesystems.sh
new file mode 100755
index 000000000..fe6170800
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_filesystems.sh
@@ -0,0 +1,35 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# env
+# {
+#  "mount_device": true,
+#  "mntpoint": "ltp_mntpoint",
+#  "filesystems": [
+#   {
+#    "type": "btrfs"
+#   },
+#   {
+#    "type": "xfs",
+#    "mkfs_opts": ["-m", "reflink=1"]
+#   }
+#  ]
+# }
+# ---
+
+. tst_loader.sh
+
+tst_res TINFO "In shell"
+
+mntpoint=$(realpath ltp_mntpoint)
+mounted=$(grep $mntpoint /proc/mounts)
+
+if [ -n "$mounted" ]; then
+	fs=$(echo $mounted |cut -d' ' -f 3)
+
+	tst_res TPASS "Mounted device formatted with $fs"
+else
+	tst_res TFAIL "Device not mounted!"
+fi
diff --git a/testcases/lib/tests/shell_loader_invalid_block.sh b/testcases/lib/tests/shell_loader_invalid_block.sh
new file mode 100755
index 000000000..a98f1c152
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_invalid_block.sh
@@ -0,0 +1,28 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# doc
+#
+# [Description]
+#
+# This is a simple shell test loader example.
+# ---
+#
+# ---
+# env
+# {
+#  "needs_tmpdir": true
+# }
+# ---
+#
+# ---
+# inv
+#
+# This is an invalid block that breaks the test.
+# ---
+
+. tst_loader.sh
+
+tst_res TPASS "This should pass!"
diff --git a/testcases/lib/tests/shell_loader_invalid_metadata.sh b/testcases/lib/tests/shell_loader_invalid_metadata.sh
new file mode 100755
index 000000000..aeae06684
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_invalid_metadata.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# This test has wrong metadata and should not be run
+#
+# ---
+# env
+# {
+#  {"needs_tmpdir": 42,
+# }
+# ---
+#
+
+. tst_loader.sh
+
+tst_res TFAIL "Shell loader should TBROK the test"
diff --git a/testcases/lib/tests/shell_loader_kconfigs.sh b/testcases/lib/tests/shell_loader_kconfigs.sh
new file mode 100755
index 000000000..b896f03ce
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_kconfigs.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# env
+# {
+#  "needs_kconfigs": ["CONFIG_NUMA=y"]
+# }
+# ---
+
+. tst_loader.sh
+
+tst_res TPASS "Shell loader works fine!"
diff --git a/testcases/lib/tests/shell_loader_no_metadata.sh b/testcases/lib/tests/shell_loader_no_metadata.sh
new file mode 100755
index 000000000..e344327ed
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_no_metadata.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# This test has no metadata and should not be executed
+#
+
+. tst_loader.sh
+
+tst_res TFAIL "Shell loader should TBROK the test"
diff --git a/testcases/lib/tests/shell_loader_supported_archs.sh b/testcases/lib/tests/shell_loader_supported_archs.sh
new file mode 100755
index 000000000..45f0b1b1c
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_supported_archs.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# env
+# {
+#  "supported_archs": ["x86", "ppc64", "x86_64"]
+# }
+# ---
+
+. tst_loader.sh
+
+tst_res TPASS "We are running on supported architecture"
diff --git a/testcases/lib/tests/shell_loader_tags.sh b/testcases/lib/tests/shell_loader_tags.sh
new file mode 100755
index 000000000..0b9416ea9
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_tags.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# ---
+# env
+# {
+#  "tags": [
+#   ["linux-git", "832478cd342ab"],
+#   ["CVE", "2099-999"]
+#  ]
+# }
+# ---
+
+. tst_loader.sh
+
+tst_res TFAIL "Fails the test so that tags are shown."
diff --git a/testcases/lib/tests/shell_loader_tcnt.sh b/testcases/lib/tests/shell_loader_tcnt.sh
new file mode 100755
index 000000000..ecf48396d
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_tcnt.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# The script should be executed tcnt times and the iteration number should be in $1
+#
+# ---
+# env
+# {
+#  "tcnt": 2
+# }
+# ---
+#
+
+. tst_loader.sh
+
+tst_res TPASS "Iteration $1"
diff --git a/testcases/lib/tests/shell_loader_wrong_metadata.sh b/testcases/lib/tests/shell_loader_wrong_metadata.sh
new file mode 100755
index 000000000..b90b21237
--- /dev/null
+++ b/testcases/lib/tests/shell_loader_wrong_metadata.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# This test has wrong metadata and should not be run
+#
+# ---
+# env
+# {
+#  "needs_tmpdir": 42,
+# }
+# ---
+#
+
+. tst_loader.sh
+
+tst_res TFAIL "Shell loader should TBROK the test"
diff --git a/testcases/lib/tests/shell_test01.c b/testcases/lib/tests/shell_test01.c
new file mode 100644
index 000000000..b9f07308e
--- /dev/null
+++ b/testcases/lib/tests/shell_test01.c
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test example.
+ */
+
+#include "tst_test.h"
+
+static void run_test(void)
+{
+	tst_run_script("shell_test_pass.sh", NULL);
+	tst_res(TINFO, "C test exits now");
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+	.test_all = run_test,
+};
diff --git a/testcases/lib/tests/shell_test02.c b/testcases/lib/tests/shell_test02.c
new file mode 100644
index 000000000..087055794
--- /dev/null
+++ b/testcases/lib/tests/shell_test02.c
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test example.
+ */
+
+#include "tst_test.h"
+
+static void run_test(void)
+{
+	tst_run_script("shell_test_pass.sh", NULL);
+	tst_reap_children();
+	tst_res(TINFO, "Shell test has finished at this point!");
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+	.test_all = run_test,
+};
diff --git a/testcases/lib/tests/shell_test03.c b/testcases/lib/tests/shell_test03.c
new file mode 100644
index 000000000..61436891e
--- /dev/null
+++ b/testcases/lib/tests/shell_test03.c
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test example.
+ */
+
+#include <sys/wait.h>
+#include "tst_test.h"
+
+static void run_test(void)
+{
+	int pid, status;
+
+	pid = tst_run_script("shell_test_pass.sh", NULL);
+
+	tst_res(TINFO, "Waiting for the pid %i", pid);
+
+	waitpid(pid, &status, 0);
+
+	tst_res(TINFO, "Shell test has %s", tst_strstatus(status));
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+	.test_all = run_test,
+};
diff --git a/testcases/lib/tests/shell_test04.c b/testcases/lib/tests/shell_test04.c
new file mode 100644
index 000000000..a32dd1e9f
--- /dev/null
+++ b/testcases/lib/tests/shell_test04.c
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test example.
+ */
+
+#include "tst_test.h"
+
+static void run_test(void)
+{
+	char *const params[] = {"param1", "param2", NULL};
+
+	tst_run_script("shell_test_check_argv.sh", params);
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+	.test_all = run_test,
+};
diff --git a/testcases/lib/tests/shell_test05.c b/testcases/lib/tests/shell_test05.c
new file mode 100644
index 000000000..771af8fc3
--- /dev/null
+++ b/testcases/lib/tests/shell_test05.c
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test example.
+ */
+
+#include "tst_test.h"
+
+static void run_test(void)
+{
+	int pid;
+
+	pid = tst_run_script("shell_test_checkpoint.sh", NULL);
+
+	tst_res(TINFO, "Waiting for shell to sleep on checkpoint!");
+
+	TST_PROCESS_STATE_WAIT(pid, 'S', 10000);
+
+	tst_res(TINFO, "Waking shell child!");
+
+	TST_CHECKPOINT_WAKE(0);
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+	.needs_checkpoints = 1,
+	.test_all = run_test,
+};
diff --git a/testcases/lib/tests/shell_test06.c b/testcases/lib/tests/shell_test06.c
new file mode 100644
index 000000000..89d66bab0
--- /dev/null
+++ b/testcases/lib/tests/shell_test06.c
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Shell test example.
+ */
+
+#include "tst_test.h"
+
+static void run_test(void)
+{
+	tst_run_script("shell_test_brk.sh", NULL);
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+	.test_all = run_test,
+};
diff --git a/testcases/lib/tests/shell_test_brk.sh b/testcases/lib/tests/shell_test_brk.sh
new file mode 100755
index 000000000..d0c72c31c
--- /dev/null
+++ b/testcases/lib/tests/shell_test_brk.sh
@@ -0,0 +1,8 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+
+. tst_env.sh
+
+tst_brk TCONF "This exits test and the next message should not be reached"
+tst_res TFAIL "If you see this the test failed"
diff --git a/testcases/lib/tests/shell_test_check_argv.sh b/testcases/lib/tests/shell_test_check_argv.sh
new file mode 100755
index 000000000..ea2fc1bb3
--- /dev/null
+++ b/testcases/lib/tests/shell_test_check_argv.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+
+. tst_env.sh
+
+tst_res TINFO "argv = $@"
+
+if [ $# -ne 2 ]; then
+	tst_res TFAIL "Wrong number of parameters got $# expected 2"
+else
+	tst_res TPASS "Got 2 parameters"
+fi
+
+if [ "$1" != "param1" ]; then
+	tst_res TFAIL "First parameter is $1 expected param1"
+else
+	tst_res TPASS "First parameter is $1"
+fi
+
+if [ "$2" != "param2" ]; then
+	tst_res TFAIL "Second parameter is $2 expected param2"
+else
+	tst_res TPASS "Second parameter is $2"
+fi
diff --git a/testcases/lib/tests/shell_test_checkpoint.sh b/testcases/lib/tests/shell_test_checkpoint.sh
new file mode 100755
index 000000000..18a3ac3b3
--- /dev/null
+++ b/testcases/lib/tests/shell_test_checkpoint.sh
@@ -0,0 +1,9 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+
+. tst_env.sh
+
+tst_res TINFO "Waiting for a checkpoint 0"
+tst_checkpoint wait 10000 0
+tst_res TPASS "Continuing after checkpoint"
diff --git a/testcases/lib/tests/shell_test_pass.sh b/testcases/lib/tests/shell_test_pass.sh
new file mode 100755
index 000000000..ad81fea76
--- /dev/null
+++ b/testcases/lib/tests/shell_test_pass.sh
@@ -0,0 +1,8 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+
+. tst_env.sh
+
+tst_res TPASS "This is called from the shell script!"
+tst_sleep 100ms
diff --git a/testcases/lib/tst_env.sh b/testcases/lib/tst_env.sh
new file mode 100644
index 000000000..68f9a0daa
--- /dev/null
+++ b/testcases/lib/tst_env.sh
@@ -0,0 +1,37 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# This is a minimal test environment for a shell scripts executed from C by
+# tst_run_shell() function. Shell tests must use the tst_loader.sh instead!
+#
+
+tst_script_name=$(basename $0)
+
+# bash does not expand aliases in non-iteractive mode, enable it
+if [ -n "$BASH_VERSION" ]; then
+	shopt -s expand_aliases
+fi
+
+# dash does not support line numbers even though this is mandated by POSIX
+if [ -z "$LINENO" ]; then
+	LINENO=-1
+fi
+
+if [ -z "$LTP_IPC_PATH" ]; then
+	echo "This script has to be executed from a LTP loader!"
+	exit 1
+fi
+
+tst_brk_()
+{
+	tst_res_ "$@"
+
+	case "$3" in
+		"TBROK") exit 2;;
+		*) exit 0;;
+	esac
+}
+
+alias tst_res="tst_res_ $tst_script_name \$LINENO"
+alias tst_brk="tst_brk_ $tst_script_name \$LINENO"
diff --git a/testcases/lib/tst_loader.sh b/testcases/lib/tst_loader.sh
new file mode 100644
index 000000000..62c9cc6d8
--- /dev/null
+++ b/testcases/lib/tst_loader.sh
@@ -0,0 +1,13 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024-2025 Cyril Hrubis <chrubis@suse.cz>
+#
+# This is a loader for shell tests that use the C test library.
+#
+
+if [ -z "$LTP_IPC_PATH" ]; then
+	tst_run_shell $(basename "$0") "$@"
+	exit $?
+else
+	. tst_env.sh
+fi
diff --git a/testcases/lib/tst_ns_create.c b/testcases/lib/tst_ns_create.c
index ce3707a60..bd7633b0b 100644
--- a/testcases/lib/tst_ns_create.c
+++ b/testcases/lib/tst_ns_create.c
@@ -23,12 +23,6 @@
 #include "tst_test.h"
 #include "tst_ns_common.h"
 
-extern struct tst_test *tst_test;
-
-static struct tst_test test = {
-	.forks_child = 1, /* Needed by SAFE_CLONE */
-};
-
 static void print_help(void)
 {
 	int i;
@@ -66,8 +60,6 @@ int main(int argc, char *argv[])
 		return 1;
 	}
 
-	tst_test = &test;
-
 	while ((token = strsep(&argv[1], ","))) {
 		struct param *p = get_param(token);
 
@@ -80,7 +72,12 @@ int main(int argc, char *argv[])
 		args.flags |= p->flag;
 	}
 
-	pid = SAFE_CLONE(&args);
+	pid = tst_clone(&args);
+	if (pid < 0) {
+		printf("clone() failed");
+		return 1;
+	}
+
 	if (!pid) {
 		child_fn();
 		return 0;
diff --git a/testcases/lib/tst_ns_exec.c b/testcases/lib/tst_ns_exec.c
index 6a8e39339..5d34e9ad5 100644
--- a/testcases/lib/tst_ns_exec.c
+++ b/testcases/lib/tst_ns_exec.c
@@ -20,12 +20,6 @@
 #include "tst_test.h"
 #include "tst_ns_common.h"
 
-extern struct tst_test *tst_test;
-
-static struct tst_test test = {
-	.forks_child = 1, /* Needed by SAFE_CLONE */
-};
-
 static int ns_fd[NS_TOTAL];
 static int ns_fds;
 
@@ -71,8 +65,6 @@ int main(int argc, char *argv[])
 	int i, status, pid;
 	char *token;
 
-	tst_test = &test;
-
 	if (argc < 4) {
 		print_help();
 		return 1;
@@ -100,7 +92,12 @@ int main(int argc, char *argv[])
 	for (i = 0; i < ns_fds; i++)
 		SAFE_SETNS(ns_fd[i], 0);
 
-	pid = SAFE_CLONE(&args);
+	pid = tst_clone(&args);
+	if (pid < 0) {
+		printf("clone() failed");
+		return 1;
+	}
+
 	if (!pid)
 		SAFE_EXECVP(argv[3], argv+3);
 
diff --git a/testcases/lib/tst_res_.c b/testcases/lib/tst_res_.c
new file mode 100644
index 000000000..fd9b8e841
--- /dev/null
+++ b/testcases/lib/tst_res_.c
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 Cyril Hrubis <chrubis@suse.cz>
+ */
+
+#define TST_NO_DEFAULT_MAIN
+#include "tst_test.h"
+
+static void print_help(void)
+{
+	printf("Usage: tst_{res,brk} filename lineno [TPASS|TBROK|TFAIL|TCONF|TINFO|TDEBUG] 'A short description'\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int type, i;
+
+	if (argc < 5) {
+		printf("argc = %i expected 5\n", argc);
+		goto help;
+	}
+
+	if (!strcmp(argv[3], "TPASS")) {
+		type = TPASS;
+	} else if (!strcmp(argv[3], "TFAIL")) {
+		type = TFAIL;
+	} else if (!strcmp(argv[3], "TCONF")) {
+		type = TCONF;
+	} else if (!strcmp(argv[3], "TINFO")) {
+		type = TINFO;
+	} else if (!strcmp(argv[3], "TDEBUG")) {
+		type = TDEBUG;
+	} else if (!strcmp(argv[3], "TBROK")) {
+		type = TBROK;
+	} else {
+		printf("Wrong type '%s'\n", argv[3]);
+		goto help;
+	}
+
+	size_t len = 0;
+
+	for (i = 4; i < argc; i++)
+		len += strlen(argv[i]) + 1;
+
+	char *msg = SAFE_MALLOC(len);
+	char *msgp = msg;
+
+	for (i = 4; i < argc; i++) {
+		msgp = strcpy(msgp, argv[i]);
+		msgp += strlen(argv[i]);
+		*(msgp++) = ' ';
+	}
+
+	*(msgp - 1) = 0;
+
+	tst_reinit();
+
+	tst_res_(argv[1], atoi(argv[2]), type, "%s", msg);
+
+	return 0;
+help:
+	print_help();
+	return 1;
+}
diff --git a/testcases/lib/tst_run_shell.c b/testcases/lib/tst_run_shell.c
new file mode 100644
index 000000000..7a446e004
--- /dev/null
+++ b/testcases/lib/tst_run_shell.c
@@ -0,0 +1,605 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 Cyril Hrubis <chrubis@suse.cz>
+ */
+#include <sys/mount.h>
+
+#define TST_NO_DEFAULT_MAIN
+#include "tst_test.h"
+#include "tst_safe_stdio.h"
+#include "ujson.h"
+
+static char *shell_filename;
+
+static void run_shell(void)
+{
+	tst_run_script(shell_filename, NULL);
+}
+
+static void run_shell_tcnt(unsigned int n)
+{
+	char buf[128];
+	char *const params[] = {buf, NULL};
+
+	snprintf(buf, sizeof(buf), "%u", n);
+
+	tst_run_script(shell_filename, params);
+}
+
+static struct tst_test test = {
+	.runs_script = 1,
+};
+
+static void print_help(void)
+{
+	printf("Usage: tst_shell_loader ltp_shell_test.sh ...\n");
+}
+
+static char *metadata;
+static size_t metadata_size;
+static size_t metadata_used;
+
+static void metadata_append(const char *line)
+{
+	size_t linelen = strlen(line);
+
+	if (metadata_size - metadata_used < linelen + 1) {
+		metadata_size += 4096;
+		metadata = SAFE_REALLOC(metadata, metadata_size);
+	}
+
+	strcpy(metadata + metadata_used, line);
+	metadata_used += linelen;
+}
+
+enum test_attr_ids {
+	ALL_FILESYSTEMS,
+	DEV_MIN_SIZE,
+	FILESYSTEMS,
+	FORMAT_DEVICE,
+	MIN_CPUS,
+	MIN_MEM_AVAIL,
+	MIN_KVER,
+	MIN_SWAP_AVAIL,
+	MNTPOINT,
+	MOUNT_DEVICE,
+	NEEDS_ABI_BITS,
+	NEEDS_CMDS,
+	NEEDS_DEVFS,
+	NEEDS_DEVICE,
+	NEEDS_DRIVERS,
+	NEEDS_HUGETLBFS,
+	NEEDS_KCONFIGS,
+	NEEDS_ROFS,
+	NEEDS_ROOT,
+	NEEDS_TMPDIR,
+	RESTORE_WALLCLOCK,
+	SAVE_RESTORE,
+	SKIP_FILESYSTEMS,
+	SKIP_IN_COMPAT,
+	SKIP_IN_LOCKDOWN,
+	SKIP_IN_SECUREBOOT,
+	SUPPORTED_ARCHS,
+	TAGS,
+	TAINT_CHECK,
+	TCNT,
+};
+
+static ujson_obj_attr test_attrs[] = {
+	UJSON_OBJ_ATTR_IDX(ALL_FILESYSTEMS, "all_filesystems", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(DEV_MIN_SIZE, "dev_min_size", UJSON_INT),
+	UJSON_OBJ_ATTR_IDX(FILESYSTEMS, "filesystems", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(FORMAT_DEVICE, "format_device", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(MIN_CPUS, "min_cpus", UJSON_INT),
+	UJSON_OBJ_ATTR_IDX(MIN_MEM_AVAIL, "min_mem_avail", UJSON_INT),
+	UJSON_OBJ_ATTR_IDX(MIN_KVER, "min_kver", UJSON_STR),
+	UJSON_OBJ_ATTR_IDX(MIN_SWAP_AVAIL, "min_swap_avail", UJSON_INT),
+	UJSON_OBJ_ATTR_IDX(MNTPOINT, "mntpoint", UJSON_STR),
+	UJSON_OBJ_ATTR_IDX(MOUNT_DEVICE, "mount_device", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(NEEDS_ABI_BITS, "needs_abi_bits", UJSON_INT),
+	UJSON_OBJ_ATTR_IDX(NEEDS_CMDS, "needs_cmds", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(NEEDS_DEVFS, "needs_devfs", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(NEEDS_DEVICE, "needs_device", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(NEEDS_DRIVERS, "needs_drivers", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(NEEDS_HUGETLBFS, "needs_hugetlbfs", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(NEEDS_KCONFIGS, "needs_kconfigs", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(NEEDS_ROFS, "needs_rofs", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(NEEDS_ROOT, "needs_root", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(NEEDS_TMPDIR, "needs_tmpdir", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(RESTORE_WALLCLOCK, "restore_wallclock", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(SAVE_RESTORE, "save_restore", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(SKIP_FILESYSTEMS, "skip_filesystems", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(SKIP_IN_COMPAT, "skip_in_compat", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(SKIP_IN_LOCKDOWN, "skip_in_lockdown", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(SKIP_IN_SECUREBOOT, "skip_in_secureboot", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(SUPPORTED_ARCHS, "supported_archs", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(TAGS, "tags", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(TAINT_CHECK, "taint_check", UJSON_BOOL),
+	UJSON_OBJ_ATTR_IDX(TCNT, "tcnt", UJSON_INT)
+};
+
+static ujson_obj test_obj = {
+	.attrs = test_attrs,
+	.attr_cnt = UJSON_ARRAY_SIZE(test_attrs),
+};
+
+static const char *const *parse_strarr(ujson_reader *reader, ujson_val *val)
+{
+	unsigned int cnt = 0, i = 0;
+	char **ret;
+
+	ujson_reader_state state = ujson_reader_state_save(reader);
+
+	UJSON_ARR_FOREACH(reader, val) {
+		if (val->type != UJSON_STR) {
+			ujson_err(reader, "Expected string!");
+			return NULL;
+		}
+
+		cnt++;
+	}
+
+	ujson_reader_state_load(reader, state);
+
+	ret = SAFE_MALLOC(sizeof(char *) * (cnt + 1));
+
+	UJSON_ARR_FOREACH(reader, val) {
+		ret[i++] = strdup(val->val_str);
+	}
+
+	ret[i] = NULL;
+
+	return (const char *const *)ret;
+}
+
+enum fs_ids {
+	FS_MIN_KVER,
+	MKFS_OPTS,
+	MKFS_SIZE_OPT,
+	MKFS_VER,
+	MNT_FLAGS,
+	TYPE,
+};
+
+static ujson_obj_attr fs_attrs[] = {
+	UJSON_OBJ_ATTR_IDX(FS_MIN_KVER, "min_kver", UJSON_STR),
+	UJSON_OBJ_ATTR_IDX(MKFS_OPTS, "mkfs_opts", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(MKFS_SIZE_OPT, "mkfs_size_opt", UJSON_STR),
+	UJSON_OBJ_ATTR_IDX(MKFS_VER, "mkfs_ver", UJSON_STR),
+	UJSON_OBJ_ATTR_IDX(MNT_FLAGS, "mnt_flags", UJSON_ARR),
+	UJSON_OBJ_ATTR_IDX(TYPE, "type", UJSON_STR),
+};
+
+static ujson_obj fs_obj = {
+	.attrs = fs_attrs,
+	.attr_cnt = UJSON_ARRAY_SIZE(fs_attrs),
+};
+
+static int parse_mnt_flags(ujson_reader *reader, ujson_val *val)
+{
+	int ret = 0;
+
+	UJSON_ARR_FOREACH(reader, val) {
+		if (val->type != UJSON_STR) {
+			ujson_err(reader, "Expected string!");
+			return ret;
+		}
+
+		if (!strcmp(val->val_str, "RDONLY"))
+			ret |= MS_RDONLY;
+		else if (!strcmp(val->val_str, "NOATIME"))
+			ret |= MS_NOATIME;
+		else if (!strcmp(val->val_str, "NOEXEC"))
+			ret |= MS_NOEXEC;
+		else if (!strcmp(val->val_str, "NOSUID"))
+			ret |= MS_NOSUID;
+		else
+			ujson_err(reader, "Invalid mount flag");
+	}
+
+	return ret;
+}
+
+static struct tst_fs *parse_filesystems(ujson_reader *reader, ujson_val *val)
+{
+	unsigned int i = 0, cnt = 0;
+	struct tst_fs *ret;
+
+	ujson_reader_state state = ujson_reader_state_save(reader);
+
+	UJSON_ARR_FOREACH(reader, val) {
+		if (val->type != UJSON_OBJ) {
+			ujson_err(reader, "Expected object!");
+			return NULL;
+		}
+		ujson_obj_skip(reader);
+		cnt++;
+	}
+
+	ujson_reader_state_load(reader, state);
+
+	ret = SAFE_MALLOC(sizeof(struct tst_fs) * (cnt + 1));
+	memset(ret, 0, sizeof(*ret) * (cnt+1));
+
+	UJSON_ARR_FOREACH(reader, val) {
+		UJSON_OBJ_FOREACH_FILTER(reader, val, &fs_obj, ujson_empty_obj) {
+			switch ((enum fs_ids)val->idx) {
+			case MKFS_OPTS:
+				ret[i].mkfs_opts = parse_strarr(reader, val);
+			break;
+			case MKFS_SIZE_OPT:
+				ret[i].mkfs_size_opt = strdup(val->val_str);
+			break;
+			case MKFS_VER:
+				ret[i].mkfs_ver = strdup(val->val_str);
+			break;
+			case MNT_FLAGS:
+				ret[i].mnt_flags = parse_mnt_flags(reader, val);
+			break;
+			case TYPE:
+				ret[i].type = strdup(val->val_str);
+			break;
+			case FS_MIN_KVER:
+				ret[i].min_kver = strdup(val->val_str);
+			break;
+			}
+
+		}
+
+		i++;
+	}
+
+	return ret;
+}
+
+static struct tst_tag *parse_tags(ujson_reader *reader, ujson_val *val)
+{
+	unsigned int i = 0, cnt = 0;
+	struct tst_tag *ret;
+
+	ujson_reader_state state = ujson_reader_state_save(reader);
+
+	UJSON_ARR_FOREACH(reader, val) {
+		if (val->type != UJSON_ARR) {
+			ujson_err(reader, "Expected array!");
+			return NULL;
+		}
+		ujson_arr_skip(reader);
+		cnt++;
+	}
+
+	ujson_reader_state_load(reader, state);
+
+	ret = SAFE_MALLOC(sizeof(struct tst_tag) * (cnt + 1));
+	memset(&ret[cnt], 0, sizeof(ret[cnt]));
+
+	UJSON_ARR_FOREACH(reader, val) {
+		char *name = NULL;
+		char *value = NULL;
+
+		UJSON_ARR_FOREACH(reader, val) {
+			if (val->type != UJSON_STR) {
+				ujson_err(reader, "Expected string!");
+				return NULL;
+			}
+
+			if (!name) {
+				name = strdup(val->val_str);
+			} else if (!value) {
+				value = strdup(val->val_str);
+			} else {
+				ujson_err(reader, "Expected only two members!");
+				return NULL;
+			}
+		}
+
+		ret[i].name = name;
+		ret[i].value = value;
+		i++;
+	}
+
+	return ret;
+}
+
+static struct tst_path_val *parse_save_restore(ujson_reader *reader, ujson_val *val)
+{
+	unsigned int i = 0, cnt = 0;
+	struct tst_path_val *ret;
+
+	ujson_reader_state state = ujson_reader_state_save(reader);
+
+	UJSON_ARR_FOREACH(reader, val) {
+		if (val->type != UJSON_ARR) {
+			ujson_err(reader, "Expected array!");
+			return NULL;
+		}
+		ujson_arr_skip(reader);
+		cnt++;
+	}
+
+	ujson_reader_state_load(reader, state);
+
+	ret = SAFE_MALLOC(sizeof(struct tst_path_val) * (cnt + 1));
+	memset(&ret[cnt], 0, sizeof(ret[cnt]));
+
+	UJSON_ARR_FOREACH(reader, val) {
+		char *path = NULL;
+		char *pval = NULL;
+		int flags_set = 0;
+		int val_set = 0;
+		unsigned int flags = 0;
+
+		UJSON_ARR_FOREACH(reader, val) {
+			if (!path) {
+				if (val->type != UJSON_STR) {
+					ujson_err(reader, "Expected string!");
+					return NULL;
+				}
+
+				path = strdup(val->val_str);
+			} else if (!val_set) {
+				if (val->type == UJSON_STR) {
+					pval = strdup(val->val_str);
+				} else if (val->type != UJSON_NULL) {
+					ujson_err(reader, "Expected string or NULL!");
+					return NULL;
+				}
+				val_set = 1;
+			} else if (!flags_set) {
+				if (val->type != UJSON_STR) {
+					ujson_err(reader, "Expected string!");
+					return NULL;
+				}
+
+				if (!strcmp(val->val_str, "TCONF")) {
+					flags = TST_SR_TCONF;
+				} else if (!strcmp(val->val_str, "TBROK")) {
+					flags = TST_SR_TBROK;
+				} else if (!strcmp(val->val_str, "SKIP")) {
+					flags = TST_SR_SKIP;
+				} else {
+					ujson_err(reader, "Invalid flags!");
+					return NULL;
+				}
+
+				flags_set = 1;
+			} else {
+				ujson_err(reader, "Expected only two members!");
+				return NULL;
+			}
+		}
+
+		if (!path || !flags_set) {
+			ujson_err(reader, "Expected [\"/{proc,sys}/path\", {\"TCONF\", \"TBROK\", \"TSKIP\"}]!");
+			return NULL;
+		}
+
+		ret[i].path = path;
+		ret[i].val = pval;
+		ret[i].flags = flags;
+		i++;
+	}
+
+	return ret;
+}
+
+static void parse_metadata(void)
+{
+	ujson_reader reader = UJSON_READER_INIT(metadata, metadata_used, UJSON_READER_STRICT);
+	char str_buf[128];
+	ujson_val val = UJSON_VAL_INIT(str_buf, sizeof(str_buf));
+
+	UJSON_OBJ_FOREACH_FILTER(&reader, &val, &test_obj, ujson_empty_obj) {
+		switch ((enum test_attr_ids)val.idx) {
+		case ALL_FILESYSTEMS:
+			test.all_filesystems = val.val_bool;
+		break;
+		case DEV_MIN_SIZE:
+			if (val.val_int <= 0)
+				ujson_err(&reader, "Device size must be > 0");
+			else
+				test.dev_min_size = val.val_int;
+		break;
+		case FILESYSTEMS:
+			test.filesystems = parse_filesystems(&reader, &val);
+		break;
+		case FORMAT_DEVICE:
+			test.format_device = val.val_bool;
+		break;
+		case MIN_CPUS:
+			if (val.val_int <= 0)
+				ujson_err(&reader, "Minimal number of cpus must be > 0");
+			else
+				test.min_cpus = val.val_int;
+		break;
+		case MIN_MEM_AVAIL:
+			if (val.val_int <= 0)
+				ujson_err(&reader, "Minimal available memory size must be > 0");
+			else
+				test.min_mem_avail = val.val_int;
+		break;
+		case MIN_KVER:
+			test.min_kver = strdup(val.val_str);
+		break;
+		case MIN_SWAP_AVAIL:
+			if (val.val_int <= 0)
+				ujson_err(&reader, "Minimal available swap size must be > 0");
+			else
+				test.min_swap_avail = val.val_int;
+		break;
+		case MNTPOINT:
+			test.mntpoint = strdup(val.val_str);
+		break;
+		case MOUNT_DEVICE:
+			test.mount_device = val.val_bool;
+		break;
+		case NEEDS_ABI_BITS:
+			if (val.val_int == 32 || val.val_int == 64)
+				test.needs_abi_bits = val.val_int;
+			else
+				ujson_err(&reader, "ABI bits must be 32 or 64");
+		break;
+		case NEEDS_CMDS:
+			test.needs_cmds = parse_strarr(&reader, &val);
+		break;
+		case NEEDS_DEVFS:
+			test.needs_devfs = val.val_bool;
+		break;
+		case NEEDS_DEVICE:
+			test.needs_device = val.val_bool;
+		break;
+		case NEEDS_DRIVERS:
+			test.needs_drivers = parse_strarr(&reader, &val);
+		break;
+		case NEEDS_HUGETLBFS:
+			test.needs_hugetlbfs = val.val_bool;
+		break;
+		case NEEDS_KCONFIGS:
+			test.needs_kconfigs = parse_strarr(&reader, &val);
+		break;
+		case NEEDS_ROFS:
+			test.needs_rofs = val.val_bool;
+		break;
+		case NEEDS_ROOT:
+			test.needs_root = val.val_bool;
+		break;
+		case NEEDS_TMPDIR:
+			test.needs_tmpdir = val.val_bool;
+		break;
+		case RESTORE_WALLCLOCK:
+			test.restore_wallclock = val.val_bool;
+		break;
+		case SAVE_RESTORE:
+			test.save_restore = parse_save_restore(&reader, &val);
+		break;
+		case SKIP_FILESYSTEMS:
+			test.skip_filesystems = parse_strarr(&reader, &val);
+		break;
+		case SKIP_IN_COMPAT:
+			test.skip_in_compat = val.val_bool;
+		break;
+		case SKIP_IN_LOCKDOWN:
+			test.skip_in_lockdown = val.val_bool;
+		break;
+		case SKIP_IN_SECUREBOOT:
+			test.skip_in_secureboot = val.val_bool;
+		break;
+		case SUPPORTED_ARCHS:
+			test.supported_archs = parse_strarr(&reader, &val);
+		break;
+		case TAGS:
+			test.tags = parse_tags(&reader, &val);
+		break;
+		case TAINT_CHECK:
+			test.taint_check = val.val_bool;
+		break;
+		case TCNT:
+			if (val.val_int <= 0)
+				ujson_err(&reader, "Number of tests must be > 0");
+			else
+				test.tcnt = val.val_int;
+		break;
+		}
+	}
+
+	ujson_reader_finish(&reader);
+
+	if (ujson_reader_err(&reader))
+		tst_brk(TBROK, "Invalid metadata");
+}
+
+enum parser_state {
+	PAR_NONE,
+	PAR_ESC,
+	PAR_DOC,
+	PAR_ENV,
+};
+
+static void extract_metadata(void)
+{
+	FILE *f;
+	char line[4096];
+	char path[4096];
+	enum parser_state state = PAR_NONE;
+	unsigned int lineno = 1;
+
+	if (tst_get_path(shell_filename, path, sizeof(path)) == -1)
+		tst_brk(TBROK, "Failed to find %s in $PATH", shell_filename);
+
+	f = SAFE_FOPEN(path, "r");
+
+	while (fgets(line, sizeof(line), f)) {
+		switch (state) {
+		case PAR_NONE:
+			if (!strcmp(line, "# ---\n"))
+				state = PAR_ESC;
+		break;
+		case PAR_ESC:
+			if (!strcmp(line, "# env\n")) {
+				state = PAR_ENV;
+			} else if (!strcmp(line, "# doc\n")) {
+				state = PAR_DOC;
+			} else {
+				tst_brk(TBROK, "%s: %u: Unknown comment block %s",
+				        path, lineno, line);
+			}
+		break;
+		case PAR_ENV:
+			if (line[0] != '#') {
+				tst_brk(TBROK,
+					"%s: %u: Unexpected end of comment block!",
+					path, lineno);
+			}
+
+			if (!strcmp(line, "# ---\n"))
+				state = PAR_NONE;
+			else
+				metadata_append(line + 2);
+		break;
+		case PAR_DOC:
+			if (line[0] != '#') {
+				tst_brk(TBROK,
+					"%s: %u: Unexpected end of comment block!",
+					path, lineno);
+			}
+
+			if (!strcmp(line, "# ---\n"))
+				state = PAR_NONE;
+		break;
+		}
+
+		lineno++;
+	}
+
+	fclose(f);
+}
+
+static void prepare_test_struct(void)
+{
+	extract_metadata();
+
+	if (metadata)
+		parse_metadata();
+	else
+		tst_brk(TBROK, "No metadata found!");
+}
+
+int main(int argc, char *argv[])
+{
+	if (argc < 2)
+		goto help;
+
+	shell_filename = argv[1];
+
+	prepare_test_struct();
+
+	if (test.tcnt)
+		test.test = run_shell_tcnt;
+	else
+		test.test_all = run_shell;
+
+	tst_run_tcases(argc - 1, argv + 1, &test);
+help:
+	print_help();
+	return 1;
+}
diff --git a/testcases/lib/tst_test.sh b/testcases/lib/tst_test.sh
index 72279cc37..10506a72b 100644
--- a/testcases/lib/tst_test.sh
+++ b/testcases/lib/tst_test.sh
@@ -691,6 +691,7 @@ tst_run()
 			CHECKPOINT_WAKE2|CHECKPOINT_WAKE_AND_WAIT);;
 			DEV_EXTRA_OPTS|DEV_FS_OPTS|FORMAT_DEVICE|MOUNT_DEVICE);;
 			SKIP_FILESYSTEMS|SKIP_IN_LOCKDOWN|SKIP_IN_SECUREBOOT);;
+			DEVICE_SIZE);;
 			*) tst_res TWARN "Reserved variable TST_$_tst_i used!";;
 			esac
 		done
@@ -749,11 +750,12 @@ tst_run()
 
 		TST_STARTWD=$(pwd)
 		cd "$TST_TMPDIR"
+		tst_res TINFO "Using $TST_TMPDIR as tmpdir ($(stat -f -c '%T' $TST_TMPDIR) filesystem)"
 	fi
 
 	# needs to be after cd $TST_TMPDIR to keep test_dev.img under $TST_TMPDIR
 	if [ "$TST_NEEDS_DEVICE" = 1 ]; then
-		TST_DEVICE=$(tst_device acquire)
+		TST_DEVICE=$(tst_device acquire $TST_DEVICE_SIZE)
 
 		if [ ! -b "$TST_DEVICE" -o $? -ne 0 ]; then
 			unset TST_DEVICE
@@ -911,6 +913,7 @@ if [ -z "$TST_NO_DEFAULT_RUN" ]; then
 	TST_ARGS="$@"
 
 	tst_res TINFO "Running: $(basename $0) $TST_ARGS"
+	tst_res TINFO "Tested kernel: $(uname -a)"
 
 	OPTIND=1
 
diff --git a/testcases/misc/lvm/datafiles/runfile.tpl b/testcases/misc/lvm/datafiles/runfile.tpl
index 4c80e9391..ee733626f 100644
--- a/testcases/misc/lvm/datafiles/runfile.tpl
+++ b/testcases/misc/lvm/datafiles/runfile.tpl
@@ -29,6 +29,10 @@
 {fsname}_gf28 growfiles -W {fsname}_gf28 -b -D 0 -w -g 16b -C 1 -b -i 1000 -u {tempdir}/{fsname}/gfsparse-2-$$
 {fsname}_gf29 growfiles -W {fsname}_gf29 -b -D 0 -r 1-4096 -R 0-33554432 -i 0 -L 60 -B 805306368 -C 1 -u {tempdir}/{fsname}/gfsparse-3-$$
 {fsname}_gf30 growfiles -W {fsname}_gf30 -D 0 -b -i 0 -L 60 -u -B 1000b -e 1 -o O_RDWR,O_CREAT,O_SYNC -g 20480 -T 10 -t 20480 {tempdir}/{fsname}/gf-sync-$$
+{fsname}_plough01 fsplough -d {tempdir}/{fsname}
+{fsname}_plough02 fsplough -R -d {tempdir}/{fsname}
+{fsname}_plough03 fsplough -W -d {tempdir}/{fsname}
+{fsname}_plough04 fsplough -RW -d {tempdir}/{fsname}
 {fsname}_rwtest01 rwtest -N {fsname}_rwtest01 -c -q -i 60s  -f sync 10%25000:rw-sync-$$ 500b:{tempdir}/{fsname}/rwtest01%f
 {fsname}_rwtest02 rwtest -N {fsname}_rwtest02 -c -q -i 60s  -f buffered 10%25000:rw-buffered-$$ 500b:{tempdir}/{fsname}/rwtest02%f
 {fsname}_rwtest03 rwtest -N {fsname}_rwtest03 -c -q -i 60s -n 2  -f buffered -s mmread,mmwrite -m random -Dv 10%25000:mm-buff-$$ 500b:{tempdir}/{fsname}/rwtest03%f
diff --git a/testcases/network/Makefile b/testcases/network/Makefile
index ccc908396..05d7f95fd 100644
--- a/testcases/network/Makefile
+++ b/testcases/network/Makefile
@@ -14,7 +14,6 @@ CLEAN_TARGETS		+= $(DIR)
 INSTALL_DIR		:= testcases/bin
 
 INSTALL_TARGETS		:= $(addprefix $(DIR)/ascii.,sm med lg jmb)
-INSTALL_TARGETS		+= $(addprefix $(DIR)/bin.,sm med lg jmb)
 
 RM			+= -r
 
diff --git a/testcases/network/busy_poll/busy_poll_lib.sh b/testcases/network/busy_poll/busy_poll_lib.sh
index de61d3fcd..dd88dd9c7 100755
--- a/testcases/network/busy_poll/busy_poll_lib.sh
+++ b/testcases/network/busy_poll/busy_poll_lib.sh
@@ -5,7 +5,6 @@
 TST_SETUP="setup"
 TST_TESTFUNC="test"
 TST_CLEANUP="cleanup"
-TST_MIN_KVER="3.11"
 TST_NEEDS_TMPDIR=1
 TST_NEEDS_ROOT=1
 TST_NEEDS_CMDS="pkill sysctl ethtool"
diff --git a/testcases/network/can/cve/can_bcm01.c b/testcases/network/can/cve/can_bcm01.c
index d9a835b03..30d85ad62 100644
--- a/testcases/network/can/cve/can_bcm01.c
+++ b/testcases/network/can/cve/can_bcm01.c
@@ -141,7 +141,7 @@ static struct tst_test test = {
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
 	.needs_root = 1,
 	.skip_in_compat = 1,
-	.max_runtime = 30,
+	.runtime = 30,
 	.needs_drivers = (const char *const[]) {
 		"vcan",
 		"can-bcm",
diff --git a/testcases/network/generate.sh b/testcases/network/generate.sh
index 939f792cc..af48f7738 100755
--- a/testcases/network/generate.sh
+++ b/testcases/network/generate.sh
@@ -51,29 +51,3 @@ fi
 "$make_file" "$medium_file" $medium_size
 "$make_file" "$large_file" $large_size
 "$make_file" "$jumbo_file" $jumbo_size
-
-if [ ! -e "bin.sm" ] ; then
-	cnt=0
-	while [ $cnt -lt 5 ] ; do
-		gzip -1 -c -n ascii.sm >> "bin.sm"
-		cnt=$(($cnt + 1))
-	done
-fi
-
-genfile() {
-	local input="$1" output="$2"
-	local cnt=19
-
-	[ -e "$output" ] && return $?
-
-	while [ $cnt -ge 0 ] ; do
-		cat "$input" >> "$output"
-		cnt=$(($cnt-1))
-	done
-}
-
-genfile bin.sm bin.med
-genfile bin.med bin.lg
-genfile bin.lg bin.jmb
-
-chmod 666 bin.*
diff --git a/testcases/network/iproute/ip_tests.sh b/testcases/network/iproute/ip_tests.sh
index ee9768073..77940481a 100755
--- a/testcases/network/iproute/ip_tests.sh
+++ b/testcases/network/iproute/ip_tests.sh
@@ -12,7 +12,7 @@ TST_TESTFUNC="test"
 TST_CLEANUP="cleanup"
 TST_NEEDS_TMPDIR=1
 TST_NEEDS_ROOT=1
-TST_NEEDS_CMDS="cat awk diff"
+TST_NEEDS_CMDS="awk cat diff ip lsmod modprobe"
 TST_NEEDS_DRIVERS="dummy"
 
 
@@ -179,7 +179,7 @@ test5()
 $ip4_addr via 127.0.0.1 dev lo
 	EOF
 
-	ip route show | grep "$ip4_addr via 127.0.0.1 dev lo" > tst_ip.out 2>&1
+	ip route show | grep "$ip4_addr via 127\.0\.0\.1 dev lo" > tst_ip\.out 2>&1
 	if [ $? -ne 0 ]; then
 		tst_res TFAIL "'ip route show' command failed"
 		return
@@ -195,7 +195,7 @@ $ip4_addr via 127.0.0.1 dev lo
 
 	ROD ip route del $ip4_addr via 127.0.0.1
 
-	ip route show | grep 127.0.0.1 > /dev/null
+	ip route show | grep -q "$ip4_addr via 127\.0\.0\.1 dev lo"
 	if [ $? -eq 0 ]; then
 		tst_res TFAIL "route not deleted"
 		return
diff --git a/testcases/network/mpls/mpls01.sh b/testcases/network/mpls/mpls01.sh
index 196b5b2f9..e453f8130 100755
--- a/testcases/network/mpls/mpls01.sh
+++ b/testcases/network/mpls/mpls01.sh
@@ -21,7 +21,7 @@ cleanup()
 
 setup()
 {
-	ROD modprobe mpls_router
+	mpls_setup_driver
 }
 
 test1()
@@ -66,5 +66,5 @@ test3()
 	tst_res TPASS "created and removed mpls routes"
 }
 
-. tst_net.sh
+. mpls_lib.sh
 tst_run
diff --git a/testcases/network/mpls/mpls_lib.sh b/testcases/network/mpls/mpls_lib.sh
index 380b568bb..486389be5 100755
--- a/testcases/network/mpls/mpls_lib.sh
+++ b/testcases/network/mpls/mpls_lib.sh
@@ -33,11 +33,21 @@ mpls_virt_cleanup()
 	mpls_cleanup
 }
 
+mpls_setup_driver()
+{
+	local args
+
+	grep -q -w ID_LIKE.*suse /etc/os-release && args='--allow-unsupported'
+	if [ "$TST_NEEDS_DRIVERS" ]; then
+		tst_net_run -s "modprobe $args -a $TST_NEEDS_DRIVERS"
+	fi
+}
+
 mpls_setup()
 {
 	local label="$1"
 
-	tst_net_run -s "modprobe -a $TST_NEEDS_DRIVERS"
+	mpls_setup_driver
 
 	ROD sysctl -q net.mpls.conf.$(tst_iface).input=1
 	tst_set_sysctl net.mpls.conf.lo.input 1 safe
diff --git a/testcases/network/netstress/netstress.c b/testcases/network/netstress/netstress.c
index 03bfe33f2..36dbf05c8 100644
--- a/testcases/network/netstress/netstress.c
+++ b/testcases/network/netstress/netstress.c
@@ -884,9 +884,6 @@ static void setup(void)
 	if (!clients_num)
 		clients_num = sysconf(_SC_NPROCESSORS_ONLN);
 
-	if (busy_poll >= 0 && tst_kvercmp(3, 11, 0) < 0)
-		tst_brk(TCONF, "Test must be run with kernel 3.11 or newer");
-
 	set_protocol_type();
 
 	if (client_mode) {
@@ -1027,6 +1024,6 @@ static struct tst_test test = {
 		{"B:", &server_bg, "Run in background, arg is the process directory"},
 		{}
 	},
-	.max_runtime = 300,
+	.timeout = 300,
 	.needs_checkpoints = 1,
 };
diff --git a/testcases/network/nfs/nfs_stress/nfs02.sh b/testcases/network/nfs/nfs_stress/nfs02.sh
index b7fbbce9c..b4ec5ecb9 100755
--- a/testcases/network/nfs/nfs_stress/nfs02.sh
+++ b/testcases/network/nfs/nfs_stress/nfs02.sh
@@ -8,7 +8,7 @@
 #
 # Ported by: Robbie Williamson (robbiew@us.ibm.com)
 
-TST_CNT=3
+TST_CNT=4
 TST_TESTFUNC="do_test"
 LTP_DATAFILES="$LTPROOT/testcases/bin/datafiles"
 
@@ -46,5 +46,20 @@ do_test3()
 	tst_res TPASS "test3 passed"
 }
 
+do_test4()
+{
+	tst_require_cmds dd diff
+
+	tst_res TINFO "do_test4, copy data in direct mode"
+	ROD dd oflag=direct if="$LTP_DATAFILES/ascii.jmb" of=ascii2.jmb
+	echo 3 >/proc/sys/vm/drop_caches
+	ROD dd iflag=direct if=ascii2.jmb of="$TST_TMPDIR/ascii2.jmb"
+	echo 3 >/proc/sys/vm/drop_caches
+	tst_res TINFO "compare both ascii.jmbs"
+	ROD diff "$LTP_DATAFILES/ascii.jmb" ascii2.jmb
+	ROD diff "$LTP_DATAFILES/ascii.jmb" "$TST_TMPDIR/ascii2.jmb"
+	tst_res TPASS "test4 passed"
+}
+
 . nfs_lib.sh
 tst_run
diff --git a/testcases/network/nfs/nfs_stress/nfs05_make_tree.c b/testcases/network/nfs/nfs_stress/nfs05_make_tree.c
index f4ec5b332..0c2df5614 100644
--- a/testcases/network/nfs/nfs_stress/nfs05_make_tree.c
+++ b/testcases/network/nfs/nfs_stress/nfs05_make_tree.c
@@ -214,5 +214,5 @@ static struct tst_test test = {
 	.options = opts,
 	.test_all = do_test,
 	.setup = setup,
-	.max_runtime = 300,
+	.timeout = 300,
 };
diff --git a/testcases/network/nfs/nfs_stress/nfs10.sh b/testcases/network/nfs/nfs_stress/nfs10.sh
new file mode 100755
index 000000000..17fb4e866
--- /dev/null
+++ b/testcases/network/nfs/nfs_stress/nfs10.sh
@@ -0,0 +1,50 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2024 SUSE LLC <mdoucha@suse.cz>
+#
+# DESCRIPTION: Verify data integrity over NFS, with and without O_DIRECT
+
+TST_CNT=4
+TST_SETUP="nfs10_setup"
+TST_TESTFUNC="do_test"
+TST_DEVICE_SIZE=1024
+TST_TIMEOUT=660
+
+nfs10_setup()
+{
+	local bsize=$(stat -f -c %s .)
+
+	if [ -z "$bsize" ] || [ "$bsize" -lt 1024 ]; then
+		bsize=1024
+	fi
+
+	NFS_MOUNT_OPTS="rsize=$bsize,wsize=$bsize"
+	nfs_setup
+}
+
+do_test1()
+{
+	tst_res TINFO "Testing buffered write, buffered read"
+	EXPECT_PASS fsplough -c 512 -d "$PWD"
+}
+
+do_test2()
+{
+	tst_res TINFO "Testing buffered write, direct read"
+	EXPECT_PASS fsplough -c 512 -R -d "$PWD"
+}
+
+do_test3()
+{
+	tst_res TINFO "Testing direct write, buffered read"
+	EXPECT_PASS fsplough -c 512 -W -d "$PWD"
+}
+
+do_test4()
+{
+	tst_res TINFO "Testing direct write, direct read"
+	EXPECT_PASS fsplough -c 512 -RW -d "$PWD"
+}
+
+. nfs_lib.sh
+tst_run
diff --git a/testcases/network/nfs/nfs_stress/nfs_lib.sh b/testcases/network/nfs/nfs_stress/nfs_lib.sh
index d3de3b7f1..14425898f 100644
--- a/testcases/network/nfs/nfs_stress/nfs_lib.sh
+++ b/testcases/network/nfs/nfs_stress/nfs_lib.sh
@@ -168,6 +168,7 @@ nfs_setup()
 	local local_dir
 	local remote_dir
 	local mount_dir
+	local nfs_opts
 
 	if [ "$(stat -f . | grep "Type: nfs")" ]; then
 		tst_brk TCONF "Cannot run nfs-stress test on mounted NFS"
@@ -192,8 +193,14 @@ nfs_setup()
 		remote_dir="$(get_remote_dir $i $type)"
 		nfs_setup_server "$remote_dir" "$(($$ + n))"
 		local_dir="$(get_local_dir $i $n)"
+		nfs_opts="-o proto=$type,vers=$i"
+
+		if [ -n "$NFS_MOUNT_OPTS" ]; then
+			nfs_opts="$nfs_opts,$NFS_MOUNT_OPTS"
+		fi
+
 		tst_res TINFO "Mounting $local_dir"
-		nfs_mount "$local_dir" "$remote_dir" "-o proto=$type,vers=$i"
+		nfs_mount "$local_dir" "$remote_dir" "$nfs_opts"
 
 		n=$(( n + 1 ))
 	done
diff --git a/testcases/network/nfs/nfsstat01/nfsstat01.sh b/testcases/network/nfs/nfsstat01/nfsstat01.sh
index c2856eff1..3379c4d46 100755
--- a/testcases/network/nfs/nfsstat01/nfsstat01.sh
+++ b/testcases/network/nfs/nfsstat01/nfsstat01.sh
@@ -3,27 +3,47 @@
 # Copyright (c) 2016-2018 Oracle and/or its affiliates. All Rights Reserved.
 # Copyright (c) International Business Machines  Corp., 2001
 
+TST_SETUP="nfsstat_setup"
 TST_TESTFUNC="do_test"
 TST_NEEDS_CMDS="nfsstat"
+NS_STAT_RHOST=0
+
+nfsstat_setup()
+{
+	nfs_setup
+
+	if tst_net_use_netns && [ -z "$LTP_NFS_NETNS_USE_LO" ]; then
+		tst_rhost_run -c "test -r /proc/net/rpc/nfs" && NS_STAT_RHOST=1
+	fi
+}
 
 get_calls()
 {
 	local name=$1
 	local field=$2
 	local nfs_f=$3
+	local netns=${4:-rhost}
 	local type="lhost"
 	local calls opt
 
 	[ "$name" = "rpc" ] && opt="r" || opt="n"
-	! tst_net_use_netns && [ "$nfs_f" != "nfs" ] && type="rhost"
+	[ "$nfs_f" = "nfsd" ] && opt="-s$opt" || opt="-c$opt"
+
+	if tst_net_use_netns; then
+		# In netns setup, rhost is the client
+		[ "$nfs_f" = "nfs" ] && [ $NS_STAT_RHOST -ne 0 ] && \
+			type="$netns"
+	else
+		[ "$nfs_f" != "nfs" ] && type="rhost"
+	fi
 
 	if [ "$type" = "lhost" ]; then
 		calls="$(grep $name /proc/net/rpc/$nfs_f | cut -d' ' -f$field)"
-		ROD nfsstat -c$opt | grep -q "$calls"
+		ROD nfsstat $opt | grep -q "$calls"
 	else
 		calls=$(tst_rhost_run -c "grep $name /proc/net/rpc/$nfs_f" | \
 			cut -d' ' -f$field)
-		tst_rhost_run -s -c "nfsstat -s$opt" | grep -q "$calls"
+		tst_rhost_run -s -c "nfsstat $opt" | grep -q "$calls"
 	fi
 
 	if ! tst_is_int "$calls"; then
@@ -46,13 +66,14 @@ get_calls()
 do_test()
 {
 	local client_calls server_calls new_server_calls new_client_calls
-	local client_field server_field
+	local client_field server_field root_calls new_root_calls
 	local client_v=$VERSION server_v=$VERSION
 
 	tst_res TINFO "checking RPC calls for server/client"
 
 	server_calls="$(get_calls rpc 2 nfsd)"
 	client_calls="$(get_calls rpc 2 nfs)"
+	root_calls="$(get_calls rpc 2 nfs lhost)"
 
 	tst_res TINFO "calls $server_calls/$client_calls"
 
@@ -61,6 +82,7 @@ do_test()
 
 	new_server_calls="$(get_calls rpc 2 nfsd)"
 	new_client_calls="$(get_calls rpc 2 nfs)"
+	new_root_calls="$(get_calls rpc 2 nfs lhost)"
 	tst_res TINFO "new calls $new_server_calls/$new_client_calls"
 
 	if [ "$new_server_calls" -le "$server_calls" ]; then
@@ -75,6 +97,16 @@ do_test()
 		tst_res TPASS "client RPC calls increased"
 	fi
 
+	if [ $NS_STAT_RHOST -ne 0 ]; then
+		tst_res TINFO "Root NS client RPC calls: $root_calls => $new_root_calls"
+
+		if [ $root_calls -ne $new_root_calls ]; then
+			tst_res TFAIL "RPC stats leaked between net namespaces"
+		else
+			tst_res TPASS "RPC stats stay within net namespaces"
+		fi
+	fi
+
 	tst_res TINFO "checking NFS calls for server/client"
 	case $VERSION in
 	2) client_field=13 server_field=13
diff --git a/testcases/network/nfs/nfsstat01/nfsstat02.sh b/testcases/network/nfs/nfsstat01/nfsstat02.sh
new file mode 100755
index 000000000..75a1a01b5
--- /dev/null
+++ b/testcases/network/nfs/nfsstat01/nfsstat02.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (c) 2024 SUSE LLC <mdoucha@suse.cz>
+
+TST_TESTFUNC="do_test"
+
+# PURPOSE:  Check that /proc/net/rpc/nfs exists in nested network namespaces
+# d47151b79e32 ("nfs: expose /proc/net/sunrpc/nfs in net namespaces")
+# part of patchset
+# https://lore.kernel.org/linux-nfs/cover.1708026931.git.josef@toxicpanda.com/
+do_test()
+{
+	local procfile="/proc/net/rpc/nfs"
+
+	if tst_rhost_run -c "test -e '$procfile'"; then
+		tst_res TPASS "$procfile exists in net namespaces"
+	else
+		tst_res TFAIL "$procfile missing in net namespaces"
+	fi
+}
+
+# Force use of nested net namespace
+unset RHOST
+
+. nfs_lib.sh
+tst_run
diff --git a/testcases/network/packet/fanout01.c b/testcases/network/packet/fanout01.c
index 4243f8400..b2b271aea 100644
--- a/testcases/network/packet/fanout01.c
+++ b/testcases/network/packet/fanout01.c
@@ -85,12 +85,11 @@ void run(void)
 }
 
 static struct tst_test test = {
-	.min_kver = "3.19",
 	.setup = setup,
 	.test_all = run,
 	.cleanup = cleanup,
 	.needs_root = 1,
-	.max_runtime = 180,
+	.runtime = 180,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_USER_NS=y",
 		"CONFIG_NET_NS=y",
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create.c
index 98793c640..8578d943c 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create.c
@@ -52,6 +52,13 @@ int main(int argn, char *argc[])
 	//First of all, create a client
 	clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	if (run_mode == 1) {
 		printf("CLIENT : %p\n", clnt);
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create_stress.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create_stress.c
index 58f55d71e..667c2a796 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create_stress.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_create/rpc_clnt_create_stress.c
@@ -57,8 +57,14 @@ int main(int argn, char *argc[])
 	for (i = 0; i < nbCall; i++) {
 		clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
 
-		if (clnt != NULL)
-			nbOk++;
+		if (clnt == NULL) {
+			clnt_pcreateerror("err");
+			printf("%d\n", rpc_createerr.cf_stat);
+
+			return 1;
+		}
+
+		nbOk++;
 	}
 
 	if (run_mode == 1) {
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy.c
index f10f15d9b..85c0d5fe6 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy.c
@@ -48,6 +48,13 @@ int main(int argn, char *argc[])
 	//First of all, create a client
 	clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call destroy macro
 	clnt_destroy(clnt);
 
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy_stress.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy_stress.c
index 9fef30f6b..ba5324c18 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy_stress.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_createdestroy_clnt_destroy/rpc_clnt_destroy_stress.c
@@ -56,6 +56,11 @@ int main(int argn, char *argc[])
 	//First of all, create a client
 	for (i = 0; i < nbCall; i++) {
 		clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
+		if (clnt == NULL) {
+			clnt_pcreateerror("err");
+			printf("%d\n", rpc_createerr.cf_stat);
+			return 1;
+		}
 		clnt_destroy(clnt);
 		nbOk++;
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_pcreateerror/rpc_clnt_pcreateerror.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_pcreateerror/rpc_clnt_pcreateerror.c
index 0aaa50c27..03756cf7e 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_pcreateerror/rpc_clnt_pcreateerror.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_pcreateerror/rpc_clnt_pcreateerror.c
@@ -49,6 +49,13 @@ int main(int argn, char *argc[])
 
 	clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	clnt_pcreateerror("#SUCCESS");
 
 	//If we are here, test has passed
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perrno/rpc_clnt_perrno.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perrno/rpc_clnt_perrno.c
index 489c6c8b6..a881a4a09 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perrno/rpc_clnt_perrno.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perrno/rpc_clnt_perrno.c
@@ -65,6 +65,13 @@ int main(int argn, char *argc[])
 	    //First of all, create client using top level API
 	    clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	rslt = clnt_call((CLIENT *) clnt, PROCNUM, (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_in
 			 (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perror/rpc_clnt_perror.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perror/rpc_clnt_perror.c
index 74c6201d3..ddf2ec441 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perror/rpc_clnt_perror.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_perror/rpc_clnt_perror.c
@@ -65,6 +65,13 @@ int main(int argn, char *argc[])
 	    //First of all, create client using top level API
 	    clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	rslt = clnt_call((CLIENT *) clnt, PROCNUM, (xdrproc_t) xdr_void, NULL,	// xdr_in
 			 (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_spcreateerror/rpc_clnt_spcreateerror.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_spcreateerror/rpc_clnt_spcreateerror.c
index 65e68dae6..a85e87787 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_spcreateerror/rpc_clnt_spcreateerror.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_spcreateerror/rpc_clnt_spcreateerror.c
@@ -50,6 +50,13 @@ int main(int argn, char *argc[])
 
 	clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	rslt = clnt_spcreateerror("#SUCCESS");
 
 	//If we are here, test has passed
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperrno/rpc_clnt_sperrno.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperrno/rpc_clnt_sperrno.c
index 1e74c39a3..728f35a97 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperrno/rpc_clnt_sperrno.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperrno/rpc_clnt_sperrno.c
@@ -66,6 +66,13 @@ int main(int argn, char *argc[])
 	    //First of all, create client using top level API
 	    clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	rslt = clnt_call((CLIENT *) clnt, PROCNUM, (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_in
 			 (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperror/rpc_clnt_sperror.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperror/rpc_clnt_sperror.c
index fc10f9e04..de4734579 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperror/rpc_clnt_sperror.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_clnt_sperror/rpc_clnt_sperror.c
@@ -66,6 +66,13 @@ int main(int argn, char *argc[])
 	    //First of all, create client using top level API
 	    clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	rslt = clnt_call((CLIENT *) clnt, PROCNUM, (xdrproc_t) xdr_void, NULL,	// xdr_in
 			 (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_auth/rpc_svcerr_auth.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_auth/rpc_svcerr_auth.c
index 50232a91a..34b1b2bf9 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_auth/rpc_svcerr_auth.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_auth/rpc_svcerr_auth.c
@@ -62,6 +62,13 @@ int main(int argn, char *argc[])
 
 	client = clnt_create(argc[1], progNum, VERSNUM, nettype);	/* Call AuthErr RP */
 
+	if (client == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	cs = clnt_call(client, PROCNUM,
 		       (xdrproc_t) xdr_int, (char *)&var_snd,
 		       (xdrproc_t) xdr_int, (char *)&var_snd, tv);
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_noproc/rpc_svcerr_noproc.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_noproc/rpc_svcerr_noproc.c
index 3f9ea9142..4483fb6ab 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_noproc/rpc_svcerr_noproc.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_noproc/rpc_svcerr_noproc.c
@@ -65,6 +65,13 @@ int main(int argn, char *argc[])
 
 	client = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (client == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	cs = clnt_call((CLIENT *) client, PROCNUM, (xdrproc_t) xdr_int, (char *)&var_snd,	// xdr_in
 		       (xdrproc_t) xdr_int, (char *)&var_snd,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_progvers/rpc_svcerr_progvers.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_progvers/rpc_svcerr_progvers.c
index 8fa54d9f0..9dfc65431 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_progvers/rpc_svcerr_progvers.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_progvers/rpc_svcerr_progvers.c
@@ -62,6 +62,13 @@ int main(int argn, char *argc[])
 
 	client = clnt_create(argc[1], progNum, VERSNUM, nettype);	/* Call wrong version RP */
 
+	if (client == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	cs = clnt_call(client, PROCNUM,
 		       (xdrproc_t) xdr_int, (char *)&var_snd,
 		       (xdrproc_t) xdr_int, (char *)&var_snd, tv);
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_systemerr/rpc_svcerr_systemerr.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_systemerr/rpc_svcerr_systemerr.c
index 2a45f5055..17546fe0a 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_systemerr/rpc_svcerr_systemerr.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_systemerr/rpc_svcerr_systemerr.c
@@ -62,6 +62,13 @@ int main(int argn, char *argc[])
 
 	client = clnt_create(argc[1], progNum, VERSNUM, nettype);	/* Call SysErr RP */
 
+	if (client == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	cs = clnt_call(client, PROCNUM,
 		       (xdrproc_t) xdr_int, (char *)&var_snd,
 		       (xdrproc_t) xdr_int, (char *)&var_snd, tv);
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_weakauth/rpc_svcerr_weakauth.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_weakauth/rpc_svcerr_weakauth.c
index 563b11a36..a9dd71b5d 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_weakauth/rpc_svcerr_weakauth.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_err_svcerr_weakauth/rpc_svcerr_weakauth.c
@@ -62,6 +62,13 @@ int main(int argn, char *argc[])
 
 	client = clnt_create(argc[1], progNum, VERSNUM, nettype);	/* Call WeakAuthErr RP */
 
+	if (client == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	cs = clnt_call(client, PROCNUM,
 		       (xdrproc_t) xdr_int, (char *)&var_snd,
 		       (xdrproc_t) xdr_int, (char *)&var_snd, tv);
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control.c
index 0b37585ec..91d087141 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control.c
@@ -53,6 +53,13 @@ int main(int argn, char *argc[])
 	//First of all, create a client
 	clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	if (run_mode == 1) {
 		printf("CLIENT : %p\n", clnt);
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control_dataint.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control_dataint.c
index 3616d652c..10de96e10 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control_dataint.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_control/rpc_clnt_control_dataint.c
@@ -54,6 +54,13 @@ int main(int argn, char *argc[])
 	//First of all, create a client
 	clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	if (run_mode) {
 		printf("CLIENT : %p\n", clnt);
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_geterr/rpc_clnt_geterr.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_geterr/rpc_clnt_geterr.c
index 9bbce26af..d0505e623 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_geterr/rpc_clnt_geterr.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/rpc/rpc_stdcall_clnt_geterr/rpc_clnt_geterr.c
@@ -53,6 +53,13 @@ int main(int argn, char *argc[])
 	//First of all, create a client
 	clnt = clnt_create(argc[1], progNum, VERSNUM, proto);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	if (run_mode == 1) {
 		printf("CLIENT : %p\n", clnt);
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_pcreateerror/tirpc_clnt_pcreateerror.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_pcreateerror/tirpc_clnt_pcreateerror.c
index 029d158ff..81bf37e36 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_pcreateerror/tirpc_clnt_pcreateerror.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_pcreateerror/tirpc_clnt_pcreateerror.c
@@ -50,6 +50,13 @@ int main(int argn, char *argc[])
 
 	clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	clnt_pcreateerror("#SUCCESS");
 
 	//If we are here, test has passed
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perrno/tirpc_clnt_perrno.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perrno/tirpc_clnt_perrno.c
index a1b16416a..c3ec08887 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perrno/tirpc_clnt_perrno.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perrno/tirpc_clnt_perrno.c
@@ -65,6 +65,13 @@ int main(int argn, char *argc[])
 	    //First of all, create client using top level API
 	    clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	rslt = clnt_call((CLIENT *) clnt, PROCNUM, (xdrproc_t) xdr_void, NULL,	// xdr_in
 			 (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror.c
index 445ecfd32..8a8cdf238 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror.c
@@ -65,6 +65,13 @@ int main(int argn, char *argc[])
 	    //First of all, create client using top level API
 	    clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Then call remote procedure
 	rslt = clnt_call((CLIENT *) clnt, PROCNUM, (xdrproc_t) xdr_void, NULL,	// xdr_in
 			 (xdrproc_t) xdr_int, (char *)&recVar,	// xdr_out
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror_complex.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror_complex.c
index e363e00b9..a97bbfa17 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror_complex.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_err_clnt_perror/tirpc_clnt_perror_complex.c
@@ -64,6 +64,13 @@ int main(int argn, char *argc[])
 	total_timeout.tv_usec = 1;
 	/**/ clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//Multiple test case
 	rslt = rpc_call(argc[1], progNum, VERSNUM, PROCNUM,
 			(xdrproc_t) xdr_int, (char *)&sndVar,
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create/tirpc_clnt_create.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create/tirpc_clnt_create.c
index eaca14747..6a9aae6c0 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create/tirpc_clnt_create.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create/tirpc_clnt_create.c
@@ -57,6 +57,13 @@ int main(int argn, char *argc[])
 	}
 	clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	if (run_mode == 1) {
 		printf("Client after creation : %p\n", clnt);
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create_timed/tirpc_clnt_create_timed.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create_timed/tirpc_clnt_create_timed.c
index 43df4d95f..8723ca8c8 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create_timed/tirpc_clnt_create_timed.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_create_timed/tirpc_clnt_create_timed.c
@@ -62,6 +62,13 @@ int main(int argn, char *argc[])
 
 	clnt = clnt_create_timed(argc[1], progNum, VERSNUM, nettype, &tv);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	if (run_mode == 1) {
 		printf("Client after creation : %p\n", clnt);
 	}
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_destroy/tirpc_clnt_destroy.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_destroy/tirpc_clnt_destroy.c
index 939ff3e4a..bb9a47503 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_destroy/tirpc_clnt_destroy.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_suite/tirpc/tirpc_toplevel_clnt_destroy/tirpc_clnt_destroy.c
@@ -58,6 +58,13 @@ int main(int argn, char *argc[])
 	//first create client
 	clnt = clnt_create(argc[1], progNum, VERSNUM, nettype);
 
+	if (clnt == NULL) {
+		clnt_pcreateerror("err");
+		printf("%d\n", rpc_createerr.cf_stat);
+
+		return 1;
+	}
+
 	//then call destroy macro
 	clnt_destroy(clnt);
 
diff --git a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_svc_1/rpc_svc_1.c b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_svc_1/rpc_svc_1.c
index d1c4df97f..d367691c4 100644
--- a/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_svc_1/rpc_svc_1.c
+++ b/testcases/network/rpc/rpc-tirpc/tests_pack/rpc_svc_1/rpc_svc_1.c
@@ -106,7 +106,7 @@ char *svc_getcaller_test(union u_argument *inVar, SVCXPRT * transp)
 	struct sockaddr_in *sa = NULL;
 	static int result;
 
-	sa = svc_getcaller(transp);
+	sa = (struct sockaddr_in *) svc_getcaller(transp);
 	//If the result is not NULL we consider that function call succeeds
 	//so returns 0 (PASS)
 	result = (sa != NULL) ? 0 : 1;
diff --git a/testcases/network/sockets/vsock01.c b/testcases/network/sockets/vsock01.c
index 7be71a83b..7eecebdfc 100644
--- a/testcases/network/sockets/vsock01.c
+++ b/testcases/network/sockets/vsock01.c
@@ -112,7 +112,7 @@ static struct tst_test test = {
 	.setup = setup,
 	.cleanup = cleanup,
 	.taint_check = TST_TAINT_W | TST_TAINT_D,
-	.max_runtime = 60,
+	.runtime = 60,
 	.needs_kconfigs = (const char *[]) {
 		"CONFIG_VSOCKETS_LOOPBACK",
 		NULL
diff --git a/testcases/network/tcp_cc/dctcp01.sh b/testcases/network/tcp_cc/dctcp01.sh
index fbce6f4a0..a9e09d131 100755
--- a/testcases/network/tcp_cc/dctcp01.sh
+++ b/testcases/network/tcp_cc/dctcp01.sh
@@ -7,7 +7,6 @@
 TST_SETUP="setup"
 TST_TESTFUNC="do_test"
 TST_CLEANUP="cleanup"
-TST_MIN_KVER="3.18"
 
 cleanup()
 {
diff --git a/testcases/network/tcp_cmds/Makefile b/testcases/network/tcp_cmds/Makefile
index 8c1e4f6f3..ba8b879ef 100644
--- a/testcases/network/tcp_cmds/Makefile
+++ b/testcases/network/tcp_cmds/Makefile
@@ -7,13 +7,9 @@ top_srcdir		?= ../../..
 
 include $(top_srcdir)/include/mk/env_pre.mk
 
-ifneq ($(WITH_EXPECT),yes)
-FILTER_OUT_SUBDIRS	:= ftp ssh telnet
-endif
+INSTALL_DEPS		:= ../datafiles/ascii.sm
 
-INSTALL_DEPS		:= ../datafiles/bin.sm
-
-../datafiles/bin.sm:
+../datafiles/ascii.sm:
 	$(MAKE) -C .. -f "$(abs_srcdir)/../Makefile" generate
 
 include $(top_srcdir)/include/mk/generic_trunk_target.mk
diff --git a/testcases/network/tcp_cmds/Makefile.inc b/testcases/network/tcp_cmds/Makefile.inc
index 114141b2c..0ca5ec0e3 100644
--- a/testcases/network/tcp_cmds/Makefile.inc
+++ b/testcases/network/tcp_cmds/Makefile.inc
@@ -22,7 +22,7 @@
 
 GENERATE_FILE_DIR	:= ../..
 
-MAKE_DEPS		:= $(GENERATE_FILE_DIR)/datafiles/bin.sm
+MAKE_DEPS		:= $(GENERATE_FILE_DIR)/datafiles/ascii.sm
 
 $(MAKE_DEPS):
 	$(MAKE) -C $(GENERATE_FILE_DIR) \
diff --git a/testcases/network/tcp_cmds/ftp/Makefile b/testcases/network/tcp_cmds/ftp/Makefile
deleted file mode 100644
index 35022f8b9..000000000
--- a/testcases/network/tcp_cmds/ftp/Makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-#
-#    network/tcp_cmds/ftp testcases Makefile.
-#
-#    Copyright (C) 2009, Cisco Systems Inc.
-#
-#    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
-#    the Free Software Foundation; either version 2 of the License, or
-#    (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU General Public License for more details.
-#
-#    You should have received a copy of the GNU General Public License along
-#    with this program; if not, write to the Free Software Foundation, Inc.,
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Ngie Cooper, September 2009
-#
-
-top_srcdir		?= ../../../..
-
-include $(top_srcdir)/include/mk/testcases.mk
-include $(abs_srcdir)/../Makefile.inc
-
-INSTALL_TARGETS		:= ftp*
-
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/network/tcp_cmds/ftp/ftp01.sh b/testcases/network/tcp_cmds/ftp/ftp01.sh
deleted file mode 100755
index 53d1eec53..000000000
--- a/testcases/network/tcp_cmds/ftp/ftp01.sh
+++ /dev/null
@@ -1,75 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-or-later
-# Copyright (c) 2022 Akihiko Odaki <akihiko.odaki@daynix.com>
-# Copyright (c) 2003 Manoj Iyer <manjo@mail.utexas.edu>
-# Copyright (c) 2001 Robbie Williamson <robbiew@us.ibm.com>
-
-TST_TESTFUNC=do_test
-TST_CNT=4
-TST_NEEDS_CMDS='awk ftp'
-TST_NEEDS_TMPDIR=1
-
-RUSER="${RUSER:-root}"
-RHOST="${RHOST:-localhost}"
-
-do_test()
-{
-    case $1 in
-    1) test_get binary;;
-    2) test_get ascii;;
-    3) test_put binary;;
-    4) test_put ascii;;
-    esac
-}
-
-list_files()
-{
-    case $1 in
-    ascii) echo 'ascii.sm ascii.med ascii.lg ascii.jmb';;
-    binary) echo 'bin.sm bin.med bin.lg bin.jmb';;
-    esac
-}
-
-test_get()
-{
-    local file sum1 sum2
-
-    for file in $(list_files $1); do
-        {
-            echo user $RUSER $PASSWD
-            echo $1
-            echo cd $TST_NET_DATAROOT
-            echo get $file
-            echo quit
-        } | ftp -nv $RHOST
-
-        sum1="$(ls -l $file | awk '{print $5}')"
-        sum2="$(ls -l $TST_NET_DATAROOT/$file | awk '{print $5}')"
-        rm -f $file
-        EXPECT_PASS "[ '$sum1' = '$sum2' ]"
-    done
-}
-
-test_put()
-{
-    local file sum1 sum2
-
-    for file in $(list_files $1); do
-        {
-            echo user $RUSER $PASSWD
-            echo lcd $TST_NET_DATAROOT
-            echo $1
-            echo cd $TST_TMPDIR
-            echo put $file
-            echo quit
-        } | ftp -nv $RHOST
-
-        sum1="$(tst_rhost_run -c "sum $TST_TMPDIR/$file" -s | awk '{print $1}')"
-        sum2="$(sum $TST_NET_DATAROOT/$file | awk '{print $1}')"
-        tst_rhost_run -c "rm -f $TST_TMPDIR/$file"
-        EXPECT_PASS "[ '$sum1' = '$sum2' ]"
-    done
-}
-
-. tst_net.sh
-tst_run
diff --git a/testcases/network/tcp_fastopen/tcp_fastopen_run.sh b/testcases/network/tcp_fastopen/tcp_fastopen_run.sh
index 88438c3e1..a3dad55ac 100755
--- a/testcases/network/tcp_fastopen/tcp_fastopen_run.sh
+++ b/testcases/network/tcp_fastopen/tcp_fastopen_run.sh
@@ -7,7 +7,6 @@ TST_SETUP="setup"
 TST_TESTFUNC="test"
 TST_CNT=2
 TST_CLEANUP="cleanup"
-TST_MIN_KVER="3.7"
 TST_NEEDS_TMPDIR=1
 TST_NEEDS_ROOT=1
 TST_NEEDS_CMDS="tc"
@@ -38,10 +37,6 @@ cleanup()
 
 setup()
 {
-	if tst_kvcmp -lt "3.16" && [ "$TST_IPV6" ]; then
-		tst_brk TCONF "test must be run with kernel 3.16 or newer"
-	fi
-
 	ROD tc qdisc add dev $(tst_iface) root netem delay 100
 }
 
diff --git a/testcases/open_posix_testsuite/conformance/definitions/aio_h/4-1.c b/testcases/open_posix_testsuite/conformance/definitions/aio_h/4-1.c
index f30f14df2..9283e1de8 100644
--- a/testcases/open_posix_testsuite/conformance/definitions/aio_h/4-1.c
+++ b/testcases/open_posix_testsuite/conformance/definitions/aio_h/4-1.c
@@ -16,7 +16,7 @@ static ssize_t (*dummy4) (struct aiocb*) = aio_return;
 static int (*dummy5) (const struct aiocb* const[], int,
 	       const struct timespec *) = aio_suspend;
 static int (*dummy6) (struct aiocb *) = aio_write;
-static int (*dummy7) (int, struct aiocb *restrict const [restrict],
+static int (*dummy7) (int, struct aiocb *const [restrict],
 	       int, struct sigevent *restrict) = lio_listio;
 
 int main(void)
diff --git a/testcases/open_posix_testsuite/conformance/interfaces/sem_timedwait/2-1.c b/testcases/open_posix_testsuite/conformance/interfaces/sem_timedwait/2-1.c
index 655e35108..d9012cc5e 100644
--- a/testcases/open_posix_testsuite/conformance/interfaces/sem_timedwait/2-1.c
+++ b/testcases/open_posix_testsuite/conformance/interfaces/sem_timedwait/2-1.c
@@ -20,20 +20,44 @@
 #include <fcntl.h>
 #include <signal.h>
 #include <time.h>
+#include <sys/mman.h>
 #include "posixtest.h"
 
 #define TEST "2-1"
+#define SHM_NAME "/posixtest_2-1"
 #define FUNCTION "sem_timedwait"
 #define ERROR_PREFIX "unexpected error: " FUNCTION " " TEST ": "
 
 int main(void)
 {
-	sem_t mysemp;
+	sem_t *mysemp;
 	struct timespec ts;
-	int pid;
+	int fd, pid;
+
+	fd = shm_open(SHM_NAME, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+	if (fd == -1) {
+		perror(ERROR_PREFIX "shm_open()");
+		return PTS_UNRESOLVED;
+	}
+
+	if (ftruncate(fd, sizeof(*mysemp)) == -1) {
+		perror(ERROR_PREFIX "ftruncate()");
+		return PTS_UNRESOLVED;
+	}
+
+	if (shm_unlink(SHM_NAME) != 0) {
+		perror(ERROR_PREFIX "shm_unlink()");
+		return PTS_UNRESOLVED;
+	}
+
+	mysemp = mmap(NULL, sizeof(*mysemp), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (mysemp == MAP_FAILED) {
+		perror(ERROR_PREFIX "mmap");
+		return PTS_UNRESOLVED;
+	}
 
 	/* Semaphore started out locked */
-	if (sem_init(&mysemp, 0, 0) == -1) {
+	if (sem_init(mysemp, 1, 0) == -1) {
 		perror(ERROR_PREFIX "sem_init");
 		return PTS_UNRESOLVED;
 	}
@@ -44,19 +68,19 @@ int main(void)
 		ts.tv_sec = time(NULL) + 2;
 		ts.tv_nsec = 0;
 
-		if (sem_timedwait(&mysemp, &ts) == -1) {
+		if (sem_timedwait(mysemp, &ts) == -1) {
 			puts("TEST FAILED");
 			return PTS_FAIL;
 		} else {
 			puts("TEST PASSED");
-			sem_destroy(&mysemp);
+			sem_destroy(mysemp);
 			return PTS_PASS;
 		}
 	} else if (pid > 0)	// parent to unlock semaphore
 	{
 		int i;
 		sleep(1);
-		if (sem_post(&mysemp) == -1) {
+		if (sem_post(mysemp) == -1) {
 			perror(ERROR_PREFIX "sem_post");
 			return PTS_FAIL;
 		}
@@ -65,12 +89,18 @@ int main(void)
 			return PTS_UNRESOLVED;
 		}
 
-		if (!WEXITSTATUS(i)) {
+		if (!WIFEXITED(i) || WEXITSTATUS(i)) {
 			return PTS_FAIL;
 		}
 		puts("TEST PASSED");
-		sem_destroy(&mysemp);
+		sem_destroy(mysemp);
+		if (munmap(mysemp, sizeof(*mysemp)) == -1) {
+			perror(ERROR_PREFIX "munmap");
+			return PTS_UNRESOLVED;
+		}
 		return PTS_PASS;
 	}
+
+	close(fd);
 	return PTS_UNRESOLVED;
 }
diff --git a/testcases/realtime/Makefile b/testcases/realtime/Makefile
index 61663bfd9..4d783b01d 100644
--- a/testcases/realtime/Makefile
+++ b/testcases/realtime/Makefile
@@ -22,73 +22,14 @@
 
 top_srcdir		?= ../..
 
-# Override these variables to use non-system available tools.
-ACLOCAL			?= aclocal
-AUTOCONF		?= autoconf
-AUTOHEADER		?= autoheader
-AUTOMAKE		?= automake
-
 include $(top_srcdir)/include/mk/env_pre.mk
-# Ensure that this error / warning only applies for build targets.
-#
-# NOTE (garrcoop): this criterium should be in-sync with include/mk/env_pre.mk
-# (minus help as that's only invoked in the top-level Makefile).
-ifeq ($(filter autotools %clean .gitignore gitignore.%,$(MAKECMDGOALS)),)
-include $(abs_srcdir)/config.mk
-endif
 
 LIBDIR			:= lib
-FILTER_OUT_DIRS		:= $(LIBDIR) m4
+FILTER_OUT_DIRS		:= $(LIBDIR)
 LIB			:= $(LIBDIR)/librealtime.a
 
-# START autotools junk
-AUTOGENERATED_FILES	= \
-			m4/Makefile
-
-AUTOMAKE_FILES := config.guess config.sub install-sh missing stamp-h1
-
-.PHONY: autotools aclocal autoconf autoheader automake
-autotools: aclocal autoconf autoheader automake
-
-.PHONY: ac-clean ac-distclean ac-maintainer-clean
-ac-clean::
-	$(RM) -rf autom4te.cache
-	$(RM) -f aclocal.m4 config.log config.status
-	$(RM) -f include/realtime_config.h include/stamp-h1
-
-ac-distclean:: ac-clean
-ac-maintainer-clean:: ac-distclean
-	$(RM) -f aclocal.m4 configure $(AUTOMAKE_FILES) m4/Makefile.in
-	$(RM) -f include/realtime_config.h.in
-
-aclocal.m4:
-	$(ACLOCAL) -I $(abs_srcdir)/m4
-
-autoconf: configure
-
-include/realtime_config.h.in: configure.ac $(wildcard m4/*.m4) aclocal.m4
-	$(AUTOHEADER)
-
-configure: configure.ac aclocal.m4
-	$(AUTOCONF)
-automake: $(AUTOMAKE_FILES)
-$(AUTOMAKE_FILES): m4/Makefile.in
-m4/Makefile.in: m4/Makefile.am aclocal.m4
-	$(AUTOMAKE) -c -a
-
-.PHONY: autoheader
-autoheader: include/realtime_config.h.in
-	$(AUTOHEADER)
-
-distclean:: %: clean ac-distclean
-	$(RM) -f $(AUTOGENERATED_FILES)
-
-maintainer-clean:: distclean ac-maintainer-clean
-
-$(AUTOGENERATED_FILES): $(top_builddir)/config.status
-	$(SHELL) $^
-
-# END autotools junk
+INSTALL_DIR             := $(srcdir)
+INSTALL_TARGETS         := run.sh
 
 $(LIBDIR):
 	mkdir -p "$@"
diff --git a/testcases/realtime/configure.ac b/testcases/realtime/configure.ac
deleted file mode 100644
index 6f50f1490..000000000
--- a/testcases/realtime/configure.ac
+++ /dev/null
@@ -1,42 +0,0 @@
-AC_PREREQ(2.61)
-AC_INIT([realtime],[realtime-20090930],[ltp-results@lists.sourceforge.net])
-AC_CONFIG_AUX_DIR([.])
-AM_INIT_AUTOMAKE
-AC_CONFIG_HEADERS([include/realtime_config.h])
-AC_CONFIG_FILES([   \
-	m4/Makefile \
-])
-AC_CHECK_HEADERS_ONCE([ \
-	pthread.h \
-])
-AC_CANONICAL_HOST
-
-AC_PROG_CC
-# <= autoconf 2.61 doesn't have AC_PROG_AR, but 2.63 has it. Not sure about
-# 2.62.
-AC_DEFUN([AC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])
-AC_PROG_AR
-AC_PROG_RANLIB
-
-AC_MSG_CHECKING([for __sync_add_and_fetch gcc builtin function])
-AC_LINK_IFELSE([AC_LANG_SOURCE([
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-#include <stdlib.h>
-int main(void) {
-	char *c;
-	return __sync_add_and_fetch(c, 1);
-}])],[has___sync_add_and_fetch=yes])
-if test "x$has___sync_add_and_fetch" = xyes; then
-	AC_DEFINE(HAVE___SYNC_ADD_AND_FETCH,1,[Define to 1 if you have the __sync_add_and_fetch gcc builtin function])
-	AC_MSG_RESULT(yes)
-else
-	AC_MSG_RESULT(no)
-fi
-
-AC_CHECK_LIB([m], [exp10], [AC_DEFINE([HAVE_EXP10], 1, [Define to 1 if you have exp10 function])])
-
-REALTIME_CHECK_PRIO_INHERIT
-
-AC_OUTPUT
diff --git a/testcases/realtime/func/async_handler/async_handler.c b/testcases/realtime/func/async_handler/async_handler.c
index 70ef56cc1..bbe1d9adc 100644
--- a/testcases/realtime/func/async_handler/async_handler.c
+++ b/testcases/realtime/func/async_handler/async_handler.c
@@ -39,8 +39,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 #include <getopt.h>
 
 #define SIGNAL_PRIO 89
diff --git a/testcases/realtime/func/async_handler/async_handler_jk.c b/testcases/realtime/func/async_handler/async_handler_jk.c
index 4d8721822..8ce826b78 100644
--- a/testcases/realtime/func/async_handler/async_handler_jk.c
+++ b/testcases/realtime/func/async_handler/async_handler_jk.c
@@ -41,8 +41,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 // This is the normal priority for an event handler if not specified.
 #define NORMAL_PRIORITY	43
diff --git a/testcases/realtime/func/async_handler/async_handler_tsc.c b/testcases/realtime/func/async_handler/async_handler_tsc.c
index 73d4ee5c6..0fe109c51 100644
--- a/testcases/realtime/func/async_handler/async_handler_tsc.c
+++ b/testcases/realtime/func/async_handler/async_handler_tsc.c
@@ -44,8 +44,8 @@
 #include <math.h>
 #include <stdint.h>
 #include <pthread.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #include "tst_tsc.h"
 
diff --git a/testcases/realtime/func/gtod_latency/gtod_infinite.c b/testcases/realtime/func/gtod_latency/gtod_infinite.c
index 676b132cb..cee469bd4 100644
--- a/testcases/realtime/func/gtod_latency/gtod_infinite.c
+++ b/testcases/realtime/func/gtod_latency/gtod_infinite.c
@@ -50,7 +50,7 @@
 #include <stdlib.h>
 #include <time.h>
 #include <sched.h>
-#include <librttest.h>
+#include "librttest.h"
 #include <sys/mman.h>
 #include <unistd.h>
 #include <signal.h>
diff --git a/testcases/realtime/func/gtod_latency/gtod_latency.c b/testcases/realtime/func/gtod_latency/gtod_latency.c
index 26ee85f53..8f8174cd7 100644
--- a/testcases/realtime/func/gtod_latency/gtod_latency.c
+++ b/testcases/realtime/func/gtod_latency/gtod_latency.c
@@ -52,8 +52,8 @@
 #include <sched.h>
 #include <errno.h>
 #include <limits.h>
-#include <libstats.h>
-#include <librttest.h>
+#include "libstats.h"
+#include "librttest.h"
 #include <sys/mman.h>
 
 #define ITERATIONS 10000000
diff --git a/testcases/realtime/func/hrtimer-prio/hrtimer-prio.c b/testcases/realtime/func/hrtimer-prio/hrtimer-prio.c
index cbc2343f6..5a382f5bd 100644
--- a/testcases/realtime/func/hrtimer-prio/hrtimer-prio.c
+++ b/testcases/realtime/func/hrtimer-prio/hrtimer-prio.c
@@ -42,8 +42,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define DEF_MED_PRIO 60		// (softirqd-hrtimer,98)
 #define DEF_ITERATIONS 10000
diff --git a/testcases/realtime/func/matrix_mult/matrix_mult.c b/testcases/realtime/func/matrix_mult/matrix_mult.c
index c32092344..e028952be 100644
--- a/testcases/realtime/func/matrix_mult/matrix_mult.c
+++ b/testcases/realtime/func/matrix_mult/matrix_mult.c
@@ -16,8 +16,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define MAX_CPUS	8192
 #define PRIO		43
diff --git a/testcases/realtime/func/measurement/preempt_timing.c b/testcases/realtime/func/measurement/preempt_timing.c
index b84d54692..87286f63f 100644
--- a/testcases/realtime/func/measurement/preempt_timing.c
+++ b/testcases/realtime/func/measurement/preempt_timing.c
@@ -51,7 +51,7 @@
 #include <errno.h>
 #include <sys/mman.h>
 #include <stdint.h>
-#include <librttest.h>
+#include "librttest.h"
 
 #include "tst_tsc.h"
 
diff --git a/testcases/realtime/func/measurement/rdtsc-latency.c b/testcases/realtime/func/measurement/rdtsc-latency.c
index 3829947bc..dba5a90f6 100644
--- a/testcases/realtime/func/measurement/rdtsc-latency.c
+++ b/testcases/realtime/func/measurement/rdtsc-latency.c
@@ -43,7 +43,7 @@
 #include <sched.h>
 #include <errno.h>
 #include <stdint.h>
-#include <librttest.h>
+#include "librttest.h"
 
 #include "tst_tsc.h"
 
diff --git a/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load.c b/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load.c
index 9b9307a27..386eed98b 100644
--- a/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load.c
+++ b/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load.c
@@ -38,8 +38,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define PRIO_A 63
 #define PRIO_B 53
diff --git a/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load_single.c b/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load_single.c
index ebbb46139..1e23d8839 100644
--- a/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load_single.c
+++ b/testcases/realtime/func/periodic_cpu_load/periodic_cpu_load_single.c
@@ -38,8 +38,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define HIST_BUCKETS 100
 
diff --git a/testcases/realtime/func/pi-tests/test-skeleton.c b/testcases/realtime/func/pi-tests/test-skeleton.c
index 7816cf877..816076e0c 100644
--- a/testcases/realtime/func/pi-tests/test-skeleton.c
+++ b/testcases/realtime/func/pi-tests/test-skeleton.c
@@ -41,7 +41,7 @@
 #include <unistd.h>
 #include <sys/wait.h>
 #include <time.h>
-#include <librttest.h>
+#include "librttest.h"
 
 void usage(void)
 {
diff --git a/testcases/realtime/func/pi-tests/testpi-0.c b/testcases/realtime/func/pi-tests/testpi-0.c
index fd8ad0717..093082382 100644
--- a/testcases/realtime/func/pi-tests/testpi-0.c
+++ b/testcases/realtime/func/pi-tests/testpi-0.c
@@ -42,7 +42,7 @@
 #include <pthread.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 void usage(void)
 {
diff --git a/testcases/realtime/func/pi-tests/testpi-1.c b/testcases/realtime/func/pi-tests/testpi-1.c
index 3dbe292d2..8acf215ba 100644
--- a/testcases/realtime/func/pi-tests/testpi-1.c
+++ b/testcases/realtime/func/pi-tests/testpi-1.c
@@ -44,7 +44,7 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 pthread_barrier_t barrier;
 
diff --git a/testcases/realtime/func/pi-tests/testpi-2.c b/testcases/realtime/func/pi-tests/testpi-2.c
index 3f7185e8d..1752d0af9 100644
--- a/testcases/realtime/func/pi-tests/testpi-2.c
+++ b/testcases/realtime/func/pi-tests/testpi-2.c
@@ -45,7 +45,7 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 pthread_barrier_t barrier;
 
diff --git a/testcases/realtime/func/pi-tests/testpi-4.c b/testcases/realtime/func/pi-tests/testpi-4.c
index e9e0ed6d6..cb309e8bf 100644
--- a/testcases/realtime/func/pi-tests/testpi-4.c
+++ b/testcases/realtime/func/pi-tests/testpi-4.c
@@ -45,7 +45,7 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 pthread_barrier_t barrier;
 
diff --git a/testcases/realtime/func/pi-tests/testpi-5.c b/testcases/realtime/func/pi-tests/testpi-5.c
index a52486417..24bbb334c 100644
--- a/testcases/realtime/func/pi-tests/testpi-5.c
+++ b/testcases/realtime/func/pi-tests/testpi-5.c
@@ -39,7 +39,7 @@
 #include <pthread.h>
 #include <string.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 pthread_mutex_t child_mutex;
 
 void *child_thread(void *arg)
diff --git a/testcases/realtime/func/pi-tests/testpi-6.c b/testcases/realtime/func/pi-tests/testpi-6.c
index 637d38355..d09e6d2dc 100644
--- a/testcases/realtime/func/pi-tests/testpi-6.c
+++ b/testcases/realtime/func/pi-tests/testpi-6.c
@@ -39,7 +39,7 @@
 #include <pthread.h>
 #include <string.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 pthread_mutex_t child_mutex;
 
diff --git a/testcases/realtime/func/pi-tests/testpi-7.c b/testcases/realtime/func/pi-tests/testpi-7.c
index 20908b662..499898775 100644
--- a/testcases/realtime/func/pi-tests/testpi-7.c
+++ b/testcases/realtime/func/pi-tests/testpi-7.c
@@ -40,7 +40,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
+#include "librttest.h"
 
 #define HIGH_PRIO 15
 #define MED_PRIO 10
diff --git a/testcases/realtime/func/pi_perf/pi_perf.c b/testcases/realtime/func/pi_perf/pi_perf.c
index 45cf8ed15..fa87839f6 100644
--- a/testcases/realtime/func/pi_perf/pi_perf.c
+++ b/testcases/realtime/func/pi_perf/pi_perf.c
@@ -47,8 +47,8 @@
 #include <unistd.h>
 #include <string.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define LOWPRIO 30
 #define HIGHPRIO 40
diff --git a/testcases/realtime/func/prio-preempt/prio-preempt.c b/testcases/realtime/func/prio-preempt/prio-preempt.c
index 9bd5e7ad8..5dd717d1f 100644
--- a/testcases/realtime/func/prio-preempt/prio-preempt.c
+++ b/testcases/realtime/func/prio-preempt/prio-preempt.c
@@ -59,6 +59,7 @@
  *
  *****************************************************************************/
 
+#define _GNU_SOURCE
 #include <stdio.h>
 #include <stdlib.h>
 #include <signal.h>
@@ -67,7 +68,7 @@
 #include <sched.h>
 #include <errno.h>
 #include <sys/syscall.h>
-#include <librttest.h>
+#include "librttest.h"
 
 #define NUM_WORKERS	27
 #define CHECK_LIMIT	1
@@ -295,10 +296,10 @@ int main(int argc, char *argv[])
 	pass_criteria = CHECK_LIMIT;
 	rt_init("hin:", parse_args, argc, argv);
 
-	numcpus = sysconf(_SC_NPROCESSORS_ONLN);
+	numcpus = get_numcpus();
 
-	/* Max no. of busy threads should always be less than/equal the no. of cpus
-	   Otherwise, the box will hang */
+	/* Max no. of busy threads should always be less than/equal the no. of
+	   housekeeping cpus. Otherwise, the box will hang */
 
 	if (rt_threads == -1 || rt_threads > numcpus) {
 		rt_threads = numcpus;
diff --git a/testcases/realtime/func/prio-wake/prio-wake.c b/testcases/realtime/func/prio-wake/prio-wake.c
index 8b3bee7b8..94eea0f41 100644
--- a/testcases/realtime/func/prio-wake/prio-wake.c
+++ b/testcases/realtime/func/prio-wake/prio-wake.c
@@ -53,8 +53,8 @@
 #include <sched.h>
 #include <errno.h>
 #include <sys/syscall.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 volatile int running_threads = 0;
 static int rt_threads = 0;
diff --git a/testcases/realtime/func/pthread_kill_latency/pthread_kill_latency.c b/testcases/realtime/func/pthread_kill_latency/pthread_kill_latency.c
index dc3dd3e81..48cbffb87 100644
--- a/testcases/realtime/func/pthread_kill_latency/pthread_kill_latency.c
+++ b/testcases/realtime/func/pthread_kill_latency/pthread_kill_latency.c
@@ -51,8 +51,8 @@
 #include <sched.h>
 #include <signal.h>
 #include <errno.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define PRIO 89
 #define ITERATIONS 10000
diff --git a/testcases/realtime/func/rt-migrate/rt-migrate.c b/testcases/realtime/func/rt-migrate/rt-migrate.c
index 252e77e6a..2a17628f4 100644
--- a/testcases/realtime/func/rt-migrate/rt-migrate.c
+++ b/testcases/realtime/func/rt-migrate/rt-migrate.c
@@ -67,8 +67,8 @@
 #include <errno.h>
 #include <sched.h>
 #include <pthread.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define gettid() syscall(__NR_gettid)
 
diff --git a/testcases/realtime/func/sched_football/Makefile b/testcases/realtime/func/sched_football/Makefile
index 61753f030..aac98eab6 100644
--- a/testcases/realtime/func/sched_football/Makefile
+++ b/testcases/realtime/func/sched_football/Makefile
@@ -1,28 +1,16 @@
-#
-#    realtime/func/sched_football test suite Makefile.
-#
-#    Copyright (C) 2009, Cisco Systems Inc.
-#
-#    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
-#    the Free Software Foundation; either version 2 of the License, or
-#    (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU General Public License for more details.
-#
-#    You should have received a copy of the GNU General Public License along
-#    with this program; if not, write to the Free Software Foundation, Inc.,
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-#
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2009, Cisco Systems Inc.
+# Copyright (c) Linux Test Project, 2009-2024
+# realtime/func/sched_football test suite Makefile.
 # Ngie Cooper, September 2009
-#
 
 top_srcdir		?= ../../../..
 
-INSTALL_TARGETS		:= run_auto.sh
 include $(top_srcdir)/include/mk/env_pre.mk
 include $(abs_srcdir)/../../config.mk
+
+INSTALL_DIR=testcases/bin
+
+# TODO: integrate properly with LTP library
+LDLIBS			+= -lltp
 include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/realtime/func/sched_football/run_auto.sh b/testcases/realtime/func/sched_football/run_auto.sh
deleted file mode 100755
index 7e0703acf..000000000
--- a/testcases/realtime/func/sched_football/run_auto.sh
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-
-profile=${1:-default}
-
-cd $(dirname $0) # Move to test directory
-if [ ! $SCRIPTS_DIR ]; then
-        # assume we're running standalone
-        export SCRIPTS_DIR=../../scripts/
-fi
-
-. $SCRIPTS_DIR/setenv.sh
-
-# Warning: tests args are now set in profiles
-$SCRIPTS_DIR/run_c_files.sh $profile sched_football
diff --git a/testcases/realtime/func/sched_football/sched_football.c b/testcases/realtime/func/sched_football/sched_football.c
index 6f075aea3..5ffc1ff46 100644
--- a/testcases/realtime/func/sched_football/sched_football.c
+++ b/testcases/realtime/func/sched_football/sched_football.c
@@ -1,175 +1,150 @@
-/******************************************************************************
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright  International Business Machines Corp., 2007, 2008
+ * Copyright (c) 2024 Petr Vorel <pvorel@suse.cz>
+ * Author: John Stultz <jstultz@google.com>
+ */
+
+/*\
+ * [Description]
  *
- *   Copyright  International Business Machines  Corp., 2007, 2008
+ * Scheduler test that uses a football analogy.
  *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
+ * The premise is that we want to make sure that lower priority threads
+ * don't run while we have runnable higher priority threads.
+ * The offense is trying to increment the balls position, while the
+ * defense is trying to block that from happening.
+ * And the ref (highest priority thread) will blow the wistle if the
+ * ball moves. Finally, we have crazy fans (higer prority) that try to
+ * distract the defense by occasionally running onto the field.
  *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
+ * [Algorithm]
  *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * NAME
- *      sched_football.c
- *
- * DESCRIPTION
- *      This is a scheduler test that uses a football analogy.
- *      The premise is that we want to make sure that lower priority threads
- *      (defensive team). The offense is trying to increment the balls position,
- *      while the defense is trying to block that from happening.
- *      And the ref (highest priority thread) will blow the wistle if the
- *      ball moves. Finally, we have crazy fans (higer prority) that try to
- *      distract the defense by occasionally running onto the field.
- *
- *      Steps:
- *       - Create a fixed number of offense threads (lower priority)
- *       - Create a referee thread (highest priority)
- *       - Once everyone is on the field, the offense thread increments the
- *	 value of 'the_ball' and yields. The defense thread tries to block
- *	 the ball by never letting the offense players get the CPU (it just
- * 	   does a sched_yield).
- *       - The refree threads wakes up regularly to check if the game is over :)
- *       - In the end, if the value of 'the_ball' is >0, the test is considered
- *	 to have failed.
- *
- * USAGE:
- *      Use run_auto.sh script in current directory to build and run test.
- *
- * AUTHOR
- *      John Stultz <johnstul@xxxxxxxxx >
- *
- * HISTORY
- *     2006-03-16 Reduced verbosity, non binary failure reporting, removal of
- *		crazy_fans thread, added game_length argument by Darren Hart.
- *     2007-08-01 Remove all thread cleanup in favor of simply exiting.Various
- *		bugfixes and cleanups. -- Josh Triplett
- *     2009-06-23 Simplified atomic startup mechanism, avoiding thundering herd
- *		scheduling at the beginning of the game. -- Darren Hart
- *
- *****************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <time.h>
-#include <string.h>
-#include <pthread.h>
-#include <sched.h>
-#include <errno.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-#include <sys/time.h>
-#include <librttest.h>
+ * - Create NR_CPU offense threads (lower priority).
+ * - Create NR_CPU defense threads (mid priority).
+ * - Create 2*NR_CPU fan threads (high priority).
+ * - Create a referee thread (highest priority).
+ * - Once everyone is on the field, the offense thread spins incrementing
+ *   the value of 'the_ball'. The defense thread tries to block 'the_ball'
+ *   by never letting the offense players get the CPU (it just spins).
+ *   The crazy fans sleep a bit, then jump the rail and run across the
+ *   field, disrupting the players on the field.
+ * - The refree threads wakes up regularly to check if the game is over :).
+ * - If the value of 'the_ball' is > 0, the test is considered to have failed.
+ */
+
+#include <sys/prctl.h>
+#include <tst_atomic.h>
+#include <tst_timer.h>
+#include "librttest.h"
+#include "tst_test.h"
 
 #define DEF_GAME_LENGTH 5
+#define SPIN_TIME_NS 200000000ULL
+#define SLEEP_TIME_NS 50000000ULL
 
-/* Here's the position of the ball */
-volatile int the_ball;
-
+static int the_ball;
 static int players_per_team = 0;
 static int game_length = DEF_GAME_LENGTH;
-static atomic_t players_ready;
+static int players_ready;
 
-void usage(void)
-{
-	rt_help();
-	printf("sched_football specific options:\n");
-	printf("  -nPLAYERS     players per team (defaults to num_cpus)\n");
-	printf("  -lGAME_LENGTH game length in seconds (defaults to %d s)\n",
-	       DEF_GAME_LENGTH);
-}
+static char *str_game_length;
+static char *str_players_per_team;
 
-int parse_args(int c, char *v)
+/* These are fans running across the field. They're trying to interrupt/distract everyone */
+void *thread_fan(void *arg LTP_ATTRIBUTE_UNUSED)
 {
-
-	int handled = 1;
-	switch (c) {
-	case 'h':
-		usage();
-		exit(0);
-	case 'n':
-		players_per_team = atoi(v);
-		break;
-	case 'l':
-		game_length = atoi(v);
-		break;
-	default:
-		handled = 0;
-		break;
+	prctl(PR_SET_NAME, "crazy_fan", 0, 0, 0);
+	tst_atomic_add_return(1, &players_ready);
+	/*occasionally wake up and run across the field */
+	while (1) {
+		struct timespec start, stop;
+		nsec_t nsec;
+
+		start.tv_sec = 0;
+		start.tv_nsec = SLEEP_TIME_NS;
+		clock_nanosleep(CLOCK_MONOTONIC, 0, &start, NULL);
+		clock_gettime(CLOCK_MONOTONIC, &start);
+		clock_gettime(CLOCK_MONOTONIC, &stop);
+		nsec = tst_timespec_diff_ns(stop, start);
+		while (nsec < SPIN_TIME_NS) {
+			clock_gettime(CLOCK_MONOTONIC, &stop);
+			nsec = tst_timespec_diff_ns(stop, start);
+		}
 	}
-	return handled;
+
+	return NULL;
 }
 
 /* This is the defensive team. They're trying to block the offense */
-void *thread_defense(void *arg)
+void *thread_defense(void *arg LTP_ATTRIBUTE_UNUSED)
 {
-	atomic_inc(&players_ready);
+	prctl(PR_SET_NAME, "defense", 0, 0, 0);
+	tst_atomic_add_return(1, &players_ready);
 	/*keep the ball from being moved */
 	while (1) {
-		sched_yield();	/* let other defenders run */
 	}
+
 	return NULL;
 }
 
 /* This is the offensive team. They're trying to move the ball */
-void *thread_offense(void *arg)
+void *thread_offense(void *arg LTP_ATTRIBUTE_UNUSED)
 {
-	atomic_inc(&players_ready);
+	prctl(PR_SET_NAME, "offense", 0, 0, 0);
+	tst_atomic_add_return(1, &players_ready);
 	while (1) {
-		the_ball++;	/* move the ball ahead one yard */
-		sched_yield();	/* let other offensive players run */
+		tst_atomic_add_return(1, &the_ball); /* move the ball ahead one yard */
 	}
+
 	return NULL;
 }
 
-int referee(int game_length)
+void referee(int game_length)
 {
 	struct timeval start, now;
 	int final_ball;
 
-	printf("Game On (%d seconds)!\n", game_length);
+	tst_res(TINFO, "Starting referee thread");
+
+	prctl(PR_SET_NAME, "referee", 0, 0, 0);
+	tst_res(TINFO, "Starting the game (%d sec)", game_length);
 
+	/* open trace marker early to avoid latency with the first message */
+	trace_marker_prep();
 	gettimeofday(&start, NULL);
 	now = start;
 
 	/* Start the game! */
-	the_ball = 0;
+	tst_atomic_store(0, &the_ball);
+	atrace_marker_write("sched_football", "Game_started!");
 
 	/* Watch the game */
 	while ((now.tv_sec - start.tv_sec) < game_length) {
 		sleep(1);
 		gettimeofday(&now, NULL);
 	}
+	atrace_marker_write("sched_football", "Game_Over!");
+	final_ball = tst_atomic_load(&the_ball);
+
 	/* Blow the whistle */
-	printf("Game Over!\n");
-	final_ball = the_ball;
-	printf("Final ball position: %d\n", final_ball);
-	return final_ball != 0;
+	tst_res(TINFO, "Final ball position: %d", final_ball);
+
+	TST_EXP_EXPR(final_ball == 0);
 }
 
-int main(int argc, char *argv[])
+static void do_test(void)
 {
 	struct sched_param param;
 	int priority;
 	int i;
-	int result;
-	setup();
-
-	rt_init("n:l:h", parse_args, argc, argv);
 
 	if (players_per_team == 0)
-		players_per_team = sysconf(_SC_NPROCESSORS_ONLN);
+		players_per_team = get_numcpus();
 
-	atomic_set(0, &players_ready);
+	tst_atomic_store(0, &players_ready);
 
-	printf("Running with: players_per_team=%d game_length=%d\n",
+	tst_res(TINFO, "players_per_team: %d game_length: %d",
 	       players_per_team, game_length);
 
 	/* We're the ref, so set our priority right */
@@ -181,30 +156,62 @@ int main(int argc, char *argv[])
 	 * They are lower priority than defense, so they must be started first.
 	 */
 	priority = 15;
-	printf("Starting %d offense threads at priority %d\n",
+	tst_res(TINFO, "Starting %d offense threads at priority %d",
 	       players_per_team, priority);
 	for (i = 0; i < players_per_team; i++)
 		create_fifo_thread(thread_offense, NULL, priority);
 
 	/* Wait for the offense threads to start */
-	while (atomic_get(&players_ready) < players_per_team)
+	while (tst_atomic_load(&players_ready) < players_per_team)
 		usleep(100);
 
 	/* Start the defense */
 	priority = 30;
-	printf("Starting %d defense threads at priority %d\n",
+	tst_res(TINFO, "Starting %d defense threads at priority %d",
 	       players_per_team, priority);
 	for (i = 0; i < players_per_team; i++)
 		create_fifo_thread(thread_defense, NULL, priority);
 
 	/* Wait for the defense threads to start */
-	while (atomic_get(&players_ready) < players_per_team * 2)
+	while (tst_atomic_load(&players_ready) < players_per_team * 2)
+		usleep(100);
+
+	/* Start the crazy fans*/
+	priority = 50;
+	tst_res(TINFO, "Starting %d fan threads at priority %d",
+	       players_per_team, priority);
+	for (i = 0; i < players_per_team*2; i++)
+		create_fifo_thread(thread_fan, NULL, priority);
+
+	/* Wait for the crazy fan threads to start */
+	while (tst_atomic_load(&players_ready) < players_per_team * 4)
 		usleep(100);
 
+	/* let things get into steady state */
+	sleep(2);
 	/* Ok, everyone is on the field, bring out the ref */
-	printf("Starting referee thread\n");
-	result = referee(game_length);
-	printf("Result: %s\n", result ? "FAIL" : "PASS");
-	return result;
 
+	referee(game_length);
 }
+
+static void do_setup(void)
+{
+	if (tst_parse_int(str_game_length, &game_length, 1, INT_MAX))
+		tst_brk(TBROK, "Invalid game length '%s'", str_game_length);
+
+	if (tst_parse_int(str_players_per_team, &players_per_team, 1, INT_MAX))
+		tst_brk(TBROK, "Invalid number of players '%s'", str_players_per_team);
+}
+
+static struct tst_test test = {
+	.test_all = do_test,
+	.setup = do_setup,
+	.needs_root = 1,
+	.options = (struct tst_option[]) {
+		{"l:", &str_game_length, "Game length in sec (default: "
+			TST_TO_STR(DEF_GAME_LENGTH) " sec)"},
+		{"n:", &str_players_per_team,
+			"Number of players (default: number of CPU)"},
+		{}
+	},
+};
diff --git a/testcases/realtime/func/sched_jitter/sched_jitter.c b/testcases/realtime/func/sched_jitter/sched_jitter.c
index 998952895..d1fba431b 100644
--- a/testcases/realtime/func/sched_jitter/sched_jitter.c
+++ b/testcases/realtime/func/sched_jitter/sched_jitter.c
@@ -47,8 +47,8 @@
 #include <pthread.h>
 #include <sched.h>
 #include <unistd.h>
-#include <libstats.h>
-#include <librttest.h>
+#include "libstats.h"
+#include "librttest.h"
 
 #define NUMRUNS 1000
 #define NUMLOOPS 1000000
diff --git a/testcases/realtime/func/sched_latency/sched_latency.c b/testcases/realtime/func/sched_latency/sched_latency.c
index d19d5889a..49d253b3c 100644
--- a/testcases/realtime/func/sched_latency/sched_latency.c
+++ b/testcases/realtime/func/sched_latency/sched_latency.c
@@ -49,8 +49,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #define PRIO 89
 //#define PERIOD 17*NS_PER_MS
diff --git a/testcases/realtime/func/thread_clock/tc-2.c b/testcases/realtime/func/thread_clock/tc-2.c
index f994d40d6..323fbd125 100644
--- a/testcases/realtime/func/thread_clock/tc-2.c
+++ b/testcases/realtime/func/thread_clock/tc-2.c
@@ -46,7 +46,7 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 #define NS_PER_SEC 1000000000
 #define THRESHOLD 0.5		/* 500 milliseconds */
diff --git a/testcases/realtime/include/librttest.h b/testcases/realtime/include/librttest.h
index 8e3421869..39538c47c 100644
--- a/testcases/realtime/include/librttest.h
+++ b/testcases/realtime/include/librttest.h
@@ -56,7 +56,6 @@
 #include <time.h>
 #include <unistd.h>
 #include "list.h"
-#include "realtime_config.h"
 
 extern void setup(void);
 extern void cleanup(int i);
@@ -113,15 +112,9 @@ extern double pass_criteria;
  */
 static inline int atomic_add(int i, atomic_t *v)
 {
-	/* XXX (garrcoop): only available in later versions of gcc */
-#if HAVE___SYNC_ADD_AND_FETCH
 	return __sync_add_and_fetch(&v->counter, i);
-#else
-	printf("%s: %s\n", __func__, strerror(ENOSYS));
-	exit(1);
-	return -1;
-#endif
 }
+
 /* atomic_inc: atomically increment the integer passed by reference
  */
 static inline int atomic_inc(atomic_t *v)
@@ -349,4 +342,21 @@ void latency_trace_stop(void);
  */
 void latency_trace_print(void);
 
+/* trace_marker_prep: open trace_marker file (optional)
+ */
+void trace_marker_prep(void);
+
+/* trace_marker_write: write buf to trace_marker.
+ * Will open trace_marker file if not already open
+ */
+int trace_marker_write(char *buf, int len);
+
+/* atrace_marker_write: write atrace format message to trace_marker
+ */
+int atrace_marker_write(char *tag, char *msg);
+
+/* get_numcpus: get the number of cpus accessible to the current process
+ */
+int get_numcpus(void);
+
 #endif /* LIBRTTEST_H */
diff --git a/testcases/realtime/include/list.h b/testcases/realtime/include/list.h
index f87d602e4..01159e34f 100644
--- a/testcases/realtime/include/list.h
+++ b/testcases/realtime/include/list.h
@@ -39,6 +39,8 @@
 #ifndef _LINUX_LIST_H
 #define _LINUX_LIST_H
 
+#include <stddef.h>
+
 /*
  * These are non-NULL pointers that will result in page faults
  * under normal circumstances, used to verify that nobody uses
@@ -241,7 +243,6 @@ static inline void list_splice_init(struct list_head *list,
 	}
 }
 
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
 /**
  * container_of - cast a member of a structure out to the containing structure
  * @ptr:	the pointer to the member.
diff --git a/testcases/realtime/lib/librttest.c b/testcases/realtime/lib/librttest.c
index eaa623b72..99ce78b33 100644
--- a/testcases/realtime/lib/librttest.c
+++ b/testcases/realtime/lib/librttest.c
@@ -40,8 +40,8 @@
  *
  *****************************************************************************/
 
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -732,3 +732,49 @@ void latency_trace_print(void)
 {
 	read_and_print("/proc/latency_trace", STDOUT_FILENO);
 }
+
+static int trace_marker_fd = -1;
+
+void trace_marker_prep(void)
+{
+	if (trace_marker_fd != -1)
+		return;
+	trace_marker_fd = open("/sys/kernel/tracing/trace_marker", O_RDWR, 0);
+}
+
+int trace_marker_write(char *buf, int len)
+{
+	if (trace_marker_fd == -1)
+		trace_marker_prep();
+
+	if (trace_marker_fd < 0)
+		return -1;
+
+	return write(trace_marker_fd, buf, len);
+}
+
+#define TRACE_BUF_LEN 256
+static char trace_buf[TRACE_BUF_LEN];
+
+int atrace_marker_write(char *tag, char *msg)
+{
+	/* Uses atrace format perfetto can visualize */
+	snprintf(trace_buf, TRACE_BUF_LEN, "I|%i|%s: %s\n", getpid(), tag, msg);
+	return trace_marker_write(trace_buf,
+				  strnlen(trace_buf, TRACE_BUF_LEN));
+}
+
+int get_numcpus(void)
+{
+	long numcpus_conf = sysconf(_SC_NPROCESSORS_CONF);
+	size_t size = CPU_ALLOC_SIZE(numcpus_conf);
+	int cpu_count;
+	cpu_set_t *cpuset = CPU_ALLOC(numcpus_conf);
+
+	CPU_ZERO_S(size, cpuset);
+	/* Get the number of cpus accessible to the current process */
+	sched_getaffinity(0, size, cpuset);
+	cpu_count = CPU_COUNT_S(size, cpuset);
+	CPU_FREE(cpuset);
+	return cpu_count;
+}
diff --git a/testcases/realtime/lib/libstats.c b/testcases/realtime/lib/libstats.c
index f12d618f4..52b0cca6e 100644
--- a/testcases/realtime/lib/libstats.c
+++ b/testcases/realtime/lib/libstats.c
@@ -43,14 +43,8 @@
 #include <errno.h>
 #include <unistd.h>
 #include <math.h>
-#include <libstats.h>
-#include <librttest.h>
-
-#include "../include/realtime_config.h"
-
-#ifndef HAVE_EXP10
-# define exp10(x) (exp((x) * log(10)))
-#endif
+#include "libstats.h"
+#include "librttest.h"
 
 int save_stats = 0;
 
diff --git a/testcases/realtime/m4/.gitignore b/testcases/realtime/m4/.gitignore
deleted file mode 100644
index 5fc607b9e..000000000
--- a/testcases/realtime/m4/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/Makefile
diff --git a/testcases/realtime/m4/GNUmakefile b/testcases/realtime/m4/GNUmakefile
deleted file mode 100644
index 2a5b4c613..000000000
--- a/testcases/realtime/m4/GNUmakefile
+++ /dev/null
@@ -1,37 +0,0 @@
-#
-#    m4 Makefile.
-#
-#    Copyright (C) 2009, Cisco Systems Inc.
-#
-#    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
-#    the Free Software Foundation; either version 2 of the License, or
-#    (at your option) any later version.
-#
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU General Public License for more details.
-#
-#    You should have received a copy of the GNU General Public License along
-#    with this program; if not, write to the Free Software Foundation, Inc.,
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Ngie Cooper, July 2009
-#
-
-top_srcdir		?= ../../..
-
-include $(top_srcdir)/include/mk/env_pre.mk
-
-M4MACROS		:= $(notdir $(wildcard *.m4))
-
-INSTALL_DIR		:= $(datarootdir)/aclocal
-
-INSTALL_MODE		:= 00644
-
-INSTALL_TARGETS		:= $(M4_MACROS)
-
-MAKE_TARGETS		:=
-
-include $(top_srcdir)/include/mk/generic_leaf_target.mk
diff --git a/testcases/realtime/m4/Makefile.am b/testcases/realtime/m4/Makefile.am
deleted file mode 100644
index 87c304b42..000000000
--- a/testcases/realtime/m4/Makefile.am
+++ /dev/null
@@ -1 +0,0 @@
-# bogus makefile to appease automake
diff --git a/testcases/realtime/m4/check.m4 b/testcases/realtime/m4/check.m4
deleted file mode 100644
index d04a2cc73..000000000
--- a/testcases/realtime/m4/check.m4
+++ /dev/null
@@ -1,14 +0,0 @@
-AC_DEFUN([REALTIME_CHECK_PRIO_INHERIT],[
-AC_MSG_CHECKING([for PTHREAD_PRIO_INHERIT])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <pthread.h>]], [[int main(void) {
-	pthread_mutexattr_t attr;
-	return pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
-}]])],[has_priority_inherit="yes"],[])
-if test "x$has_priority_inherit" = "xyes" ; then
-	AC_DEFINE(HAS_PRIORITY_INHERIT,1,[Define to 1 if you have PTHREAD_PRIO_INHERIT])
-	AC_MSG_RESULT(yes)
-else
-	AC_MSG_RESULT(no)
-fi
-])
diff --git a/testcases/realtime/perf/latency/pthread_cond_latency.c b/testcases/realtime/perf/latency/pthread_cond_latency.c
index d0048d5e4..c1b64b20a 100644
--- a/testcases/realtime/perf/latency/pthread_cond_latency.c
+++ b/testcases/realtime/perf/latency/pthread_cond_latency.c
@@ -41,7 +41,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <stdlib.h>
-#include <librttest.h>
+#include "librttest.h"
 
 pthread_mutex_t child_mutex = PTHREAD_MUTEX_INITIALIZER;
 volatile int child_waiting = 0;
diff --git a/testcases/realtime/perf/latency/pthread_cond_many.c b/testcases/realtime/perf/latency/pthread_cond_many.c
index 9c6a89729..2bc9c1ed3 100644
--- a/testcases/realtime/perf/latency/pthread_cond_many.c
+++ b/testcases/realtime/perf/latency/pthread_cond_many.c
@@ -44,8 +44,8 @@
 #include <sys/poll.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include <librttest.h>
-#include <libstats.h>
+#include "librttest.h"
+#include "libstats.h"
 #define PASS_US 100
 pthread_mutex_t child_mutex;
 volatile int *child_waiting = NULL;
diff --git a/testcases/realtime/stress/pi-tests/lookup_pi_state.c b/testcases/realtime/stress/pi-tests/lookup_pi_state.c
index 83781d80e..1799892aa 100644
--- a/testcases/realtime/stress/pi-tests/lookup_pi_state.c
+++ b/testcases/realtime/stress/pi-tests/lookup_pi_state.c
@@ -34,7 +34,7 @@
  *****************************************************************************/
 
 #include <stdio.h>
-#include <librttest.h>
+#include "librttest.h"
 
 #define NUM_SLAVES 20
 #define SLAVE_PRIO 89
diff --git a/testcases/realtime/stress/pi-tests/testpi-3.c b/testcases/realtime/stress/pi-tests/testpi-3.c
index 1c3d44452..70ec94513 100644
--- a/testcases/realtime/stress/pi-tests/testpi-3.c
+++ b/testcases/realtime/stress/pi-tests/testpi-3.c
@@ -41,7 +41,7 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
-#include <librttest.h>
+#include "librttest.h"
 
 void usage(void)
 {
diff --git a/tools/genhtml.pl b/tools/genhtml.pl
index d8f52663b..79c178d01 100644
--- a/tools/genhtml.pl
+++ b/tools/genhtml.pl
@@ -87,6 +87,11 @@ sub get_background_colour_column() {
     }
 }
 
+print STDERR "-------------------------------------------------\n";
+print STDERR "INFO: genhtml.pl script is deprecated, try kirk\n";
+print STDERR "(new LTP runner which also generates JSON output)\n";
+print STDERR "https://github.com/linux-test-project/kirk\n";
+print STDERR "-------------------------------------------------\n";
 
 if ($start_tag eq "" || $end_tag eq "" || $output_tag eq "" || $execution_tag eq "") {
 	syntax();
@@ -162,6 +167,7 @@ foreach my $file (@ARGV) {
                                               "<td><p><strong>$termination_id_value[1]</strong></p></td>\n"  .
                                               "<td><p><strong>$corefile_value[1]</strong></p></td>\n";
                                   $row_line =~ s/<tr>/<tr\ bgcolor=$background_colour>/;
+                                  $flag4++;
                              }
                              if ( $flag4 == 3 ) {
                                   @variable_value_pair    = split(/\ /, $line);
@@ -170,7 +176,6 @@ foreach my $file (@ARGV) {
                                   $row_line = $row_line . "<td><p><strong>$cutime_value[1]</strong></p></td>\n" .
                                               "<td><p><strong>$cstime_value[1]</strong></p></td></tr>\n";
                              }
-                             $flag4++;
                         }
                         if ( $line =~ /$execution_tag/ ) {
                              $flag2 = 0;
@@ -186,18 +191,23 @@ foreach my $file (@ARGV) {
 			 	 if ($line =~ "termination_id=1" ) {
 					 $detected_fail = 1;
 					 $failed_test_counter++;
+					 $flag4 = 2;
 				 } elsif ($line =~ "termination_id=2" ) {
 					 $detected_brok = 1;
 					 $brok_test_counter++;
+					 $flag4 = 2;
 				 } elsif ($line =~ "termination_id=4" ) {
 					 $detected_warn = 1;
 					 $warn_test_counter++;
+					 $flag4 = 2;
 				 } elsif ($line =~ "termination_id=32" ) {
 					 $detected_conf = 1;
 					 $conf_test_counter++;
+					 $flag4 = 2;
 				 } elsif ($line =~ "termination_id=0" ) {
 					 $detected_pass = 1;
 					 $test_passed++;
+					 $flag4 = 2;
 				 }
 			 }
                         if ( $line =~ /$output_tag/ ) {
diff --git a/tools/genload/genload.c b/tools/genload/genload.c
index 7f56d5272..a19d519fd 100644
--- a/tools/genload/genload.c
+++ b/tools/genload/genload.c
@@ -641,9 +641,16 @@ int hogvm(long long forks, long long chunks, long long bytes)
 			/* Use a backoff sleep to ensure we get good fork throughput.  */
 			usleep(backoff);
 
+			/* If chunks is 0, ptr will allocate 0 bytes's
+			 * memory, it will cause the process to crash
+			 * during runtime, so adjust to 1 */
+			if (chunks == 0)
+				chunks = 1;
+
 			while (1) {
-				ptr = (char **)malloc(chunks * 2);
-				for (j = 0; chunks == 0 || j < chunks; j++) {
+				ptr = (char **)malloc(chunks *
+						sizeof(char *));
+				for (j = 0; j < chunks; j++) {
 					if ((ptr[j] =
 					     (char *)malloc(bytes *
 							    sizeof(char)))) {
@@ -674,10 +681,8 @@ int hogvm(long long forks, long long chunks, long long bytes)
 				if (retval == 0) {
 					dbg(stdout,
 					    "hogvm worker freeing memory and starting over\n");
-					for (j = 0; chunks == 0 || j < chunks;
-					     j++) {
+					for (j = 0; j < chunks; j++)
 						free(ptr[j]);
-					}
 					free(ptr);
 					continue;
 				}
diff --git a/tools/genload/stress.c b/tools/genload/stress.c
index 7f56d5272..a19d519fd 100644
--- a/tools/genload/stress.c
+++ b/tools/genload/stress.c
@@ -641,9 +641,16 @@ int hogvm(long long forks, long long chunks, long long bytes)
 			/* Use a backoff sleep to ensure we get good fork throughput.  */
 			usleep(backoff);
 
+			/* If chunks is 0, ptr will allocate 0 bytes's
+			 * memory, it will cause the process to crash
+			 * during runtime, so adjust to 1 */
+			if (chunks == 0)
+				chunks = 1;
+
 			while (1) {
-				ptr = (char **)malloc(chunks * 2);
-				for (j = 0; chunks == 0 || j < chunks; j++) {
+				ptr = (char **)malloc(chunks *
+						sizeof(char *));
+				for (j = 0; j < chunks; j++) {
 					if ((ptr[j] =
 					     (char *)malloc(bytes *
 							    sizeof(char)))) {
@@ -674,10 +681,8 @@ int hogvm(long long forks, long long chunks, long long bytes)
 				if (retval == 0) {
 					dbg(stdout,
 					    "hogvm worker freeing memory and starting over\n");
-					for (j = 0; chunks == 0 || j < chunks;
-					     j++) {
+					for (j = 0; j < chunks; j++)
 						free(ptr[j]);
-					}
 					free(ptr);
 					continue;
 				}
diff --git a/utils/benchmark/ebizzy-0.3/README b/utils/benchmark/ebizzy-0.3/README
index 6552f420d..57797d3b2 100644
--- a/utils/benchmark/ebizzy-0.3/README
+++ b/utils/benchmark/ebizzy-0.3/README
@@ -11,7 +11,7 @@ Compiling
 ---------
 
 First configure ebizzy for your platform by typing "./configure".
-Currently Linux and Solaris anre supported.  Then type "make".  The
+Currently Linux and Solaris are supported.  Then type "make".  The
 resulting binary will be named "ebizzy".
 
 Running
diff --git a/ver_linux b/ver_linux
index 7dd0fe176..4fa34f4a9 100755
--- a/ver_linux
+++ b/ver_linux
@@ -91,9 +91,9 @@ pppd --version 2>&1| grep version | awk \
 isdnctrl 2>&1 | grep version | awk \
 'NR==1{print "isdn4k-utils          ", $NF}'
 
-ls -l `ldd /bin/sh | awk '/libc/{print $3}'` | sed \
--e 's/\.so$//' | awk -F'[.-]'   '{print "Linux C Library        " \
-$(NF-2)"."$(NF-1)"."$NF}'
+printf "Linux C Library        $($(ldd /bin/sh | \
+awk '/libc/{print $3}') 2>&1 | \
+grep -i -e libc.*version -e musl.*libc -e ^version)\n"
 
 ldd -v > /dev/null 2>&1 && ldd -v || ldd --version |head -n 1 | awk \
 'NR==1{print "Dynamic linker (ldd)  ", $NF}'
@@ -158,6 +158,9 @@ else
 	df
 fi
 
+echo
+echo 'tainted (/proc/sys/kernel/tainted):'
+cat /proc/sys/kernel/tainted
 
 echo
 if is_enabled /sys/module/apparmor/parameters/enabled; then
```

